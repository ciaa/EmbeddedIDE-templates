diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/app/inc/blinky.h ./app/inc/blinky.h
--- a_qSC69Z/app/inc/blinky.h	1969-12-31 21:00:00.000000000 -0300
+++ ./app/inc/blinky.h	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,53 @@
+/**
+ *  \file       bkliny.h
+ *  \brief      Example application.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2016.03.17  LeFr  v1.0.00  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __BLINKY_H__
+#define __BLINKY_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ................................ Signals ................................ */
+typedef enum Signals
+{
+	TIMEOUT,      /* timeout */
+	TERMINATE,		/* press the key escape on the keyboard */
+	BLINKY_NUM_EVENTS
+}Signals;
+
+/* ........................ Declares active object ......................... */
+RKH_SMA_DCLR(blinky);
+
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/app/inc/rkhcfg.h ./app/inc/rkhcfg.h
--- a_qSC69Z/app/inc/rkhcfg.h	1969-12-31 21:00:00.000000000 -0300
+++ ./app/inc/rkhcfg.h	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,703 @@
+/**
+ *  \file       rkhcfg.c
+ *  \brief      RKH user configuration.
+ */
+
+#ifndef __RKHCFG_H__
+#define __RKHCFG_H__
+
+/**
+ *  Defines standard constants and macros.
+ */
+#include "rkhdef.h"
+
+/* --- Configuration options related to framework ------------------------- */
+
+/**
+ *	Specify the maximum number of state machine applications (SMA) to be used
+ *	by the application (can be a number in the range [1..64]).
+ */
+#define RKH_CFG_FWK_MAX_SMA             2u
+
+/**
+ *	If the dynamic event support (see #RKH_CFG_FWK_DYN_EVT_EN) is set to
+ *	1, RKH allows to use event with parameters, defer/recall, allocating
+ *	and recycling dynamic events, among other features.
+ */
+#define RKH_CFG_FWK_DYN_EVT_EN          RKH_DISABLED
+
+/**
+ *	If the dynamic event support is enabled (see #RKH_CFG_FWK_DYN_EVT_EN)
+ *	then the #RKH_CFG_FWK_MAX_EVT_POOL can be used to specify the maximum
+ *	number of fixed-size memory block pools to be used by the application
+ *	(can be a number in the range [0..256]).
+ *	Note that a value of 0 will completely suppress the memory pool services.
+ */
+#define RKH_CFG_FWK_MAX_EVT_POOL        0u
+
+/**
+ *  Specify the size of the event signal. The valid values [in bits] are
+ *  8, 16 or 32. Default is 8. The higher the signal size, the higher the
+ *  event structure size and therefore more memory consumption.
+ *  See #RKH_SIG_T data type.
+ */
+#define RKH_CFG_FWK_SIZEOF_EVT          8u
+
+/**
+ *	Specify the maximum number of event signals to be used by the
+ *	application.
+ */
+#define RKH_CFG_FWK_MAX_SIGNALS         16u
+
+/**
+ *  Specify the data type of event size. The valid values [in bits] are
+ *  8, 16 or 32. Default is 8. See #RKH_ES_T, rkh_fwk_epool_register(), and
+ *	RKH_ALLOC_EVT(). Use a 8 value if the bigger event size is minor to
+ *	256 bytes.
+ */
+#define RKH_CFG_FWK_SIZEOF_EVT_SIZE     16u
+
+/**
+ *	If the #RKH_CFG_FWK_DEFER_EVT_EN is set to 1 and the dynamic event
+ *	support is enabled (see #RKH_CFG_FWK_DYN_EVT_EN), RKH enables the
+ *	defer and recall event features.
+ */
+#define RKH_CFG_FWK_DEFER_EVT_EN        RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_FWK_ASSERT_EN is set to 0 the checking assertions are
+ *	disabled.
+ *  In particular macros RKH_ASSERT(), RKH_REQUIRE(), RKH_ENSURE(),
+ *  RKH_INVARIANT(), and RKH_ERROR() do NOT evaluate the test condition
+ *  passed as the argument to these macros. One notable exception is the
+ *  macro RKH_ALLEGE(), that still evaluates the test condition, but does
+ *  not report assertion failures when the #RKH_CFG_FWK_ASSERT_EN is enabled.
+ */
+#define RKH_CFG_FWK_ASSERT_EN           RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_HOOK_DISPATCH_EN is set to 1, RKH will invoke the
+ *	dispatch hook function rkh_hook_dispatch() when dispatching an event to
+ *	a SMA. When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_DISPATCH_EN        RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_HOOK_SIGNAL_EN is set to 1, RKH will invoke the signal
+ *	hook function rkh_hook_signal() when the producer of an event directly
+ *	posts the event to the event queue of the consumer SMA.
+ *	When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_SIGNAL_EN          RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_HOOK_TIMEOUT_EN is set to 1, RKH will invoke the timeout
+ *	hook function rkh_hook_timeout() when a timer expires just before the
+ *	assigned event is directly posted into the state machine application
+ *	queue.
+ *	When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_TIMEOUT_EN         RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_HOOK_START_EN is set to 1, RKH will invoke the start
+ *	hook function rkh_hook_start() just before the RKH takes over control of
+ *  the application.
+ *	When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_START_EN           RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_HOOK_EXIT_EN is set to 1, RKH will invoke the exit
+ *	hook function just before it returns to the underlying OS/RTOS. Usually,
+ *	the rkh_hook_exit() is useful when executing clean-up code upon SMA
+ *	terminate or framework exit.
+ *	When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_EXIT_EN            RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_HOOK_TIMETICK_EN is set to 1, RKH will invoke the time
+ *	tick hook function from rkh_tmr_tick(), at the very beginning of that,
+ *	to give priority to user or port-specific code when the tick interrupt
+ *	occurs.
+ *	Usually, the rkh_hook_timetick() allows to the application to extend the
+ *	functionality of RKH, giving the port developer the opportunity to add
+ *	code that will be called by rkh_tmr_tick(). Frequently, the
+ *	rkh_hook_timetick() is called from the tick ISR and must not make any
+ *	blocking calls and must execute as quickly as possible.
+ *	When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_TIMETICK_EN        RKH_ENABLED
+
+/**
+ *  If the #RKH_CFG_HOOK_PUT_TRCEVT_EN is set to 1, RKH will invoke the
+ *  rkh_hook_putTrcEvt() function from rkh_trc_end() function, at the end of
+ *  that, to allow to the application to extend the functionality of RKH,
+ *  giving the port developer the opportunity to add code that will be called
+ *  when is put a trace event into the stream buffer.
+ *  When this is set the application must provide the hook function.
+ */
+#define RKH_CFG_HOOK_PUT_TRCEVT_EN        RKH_DISABLED
+
+/**
+ *  Specify the frequency of the framework tick interrupt (number of ticks
+ *  in one second). It's the rate at which the rkh_tmr_tick() function is
+ *  invoked. This configuration constant is not used by RKH, it is just a
+ *  value to allow an application to deal with time when using timer
+ *  services, converting ticks to time. See RKH_TICK_RATE_MS constant.
+ */
+#define RKH_CFG_FWK_TICK_RATE_HZ            100u
+
+/* --- Configuration options related to state machine applications -------- */
+
+/**
+ *	If the #RKH_CFG_SMA_GET_INFO_EN is set to 1 then RKH will include the
+ *	rkh_clear_info() and rkh_get_info() functions.
+ */
+#define RKH_CFG_SMA_GET_INFO_EN         RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_PPRO_EN is set to 1 then RKH allows to reference a
+ *	event preprocessor to any basic state. Aditionally, by means of single
+ *	inheritance in C it could be used as state's abstract data.
+ *	Moreover, implementing the single inheritance in C is very simply by
+ *	literally embedding the base type, #RKH_PPRO_T in this case, as the first
+ *	member of the derived structure. See \a prepro member of #RKH_ST_T
+ *	structure for more information.
+ */
+#define RKH_CFG_SMA_PPRO_EN             RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_HCAL_EN is set to 1, the RKH allows state nesting.
+ *	When #RKH_CFG_SMA_HCAL_EN is set to 0 some important features of RKH are
+ *	not included: state nesting, composite state, history (shallow and deep)
+ *	pseudostate, entry action, and exit action.
+ */
+#define RKH_CFG_SMA_HCAL_EN             RKH_DISABLED
+
+/**
+ *  Specify the maximum number of hierarchical levels. The smaller this
+ *  number, the lower the RAM consumption. Typically, the most of
+ *  hierarchical state machines uses up to 4 levels. Currently
+ *  #RKH_CFG_SMA_MAX_HCAL_DEPTH cannot exceed 8.
+ */
+#define RKH_CFG_SMA_MAX_HCAL_DEPTH      2u
+
+/**
+ *	Specify the maximum number of linked transition segments. The smaller
+ *	this number, the lower the RAM consumption. Typically, the most of
+ *	hierarchical state machines uses up to 4 transition segments.
+ *	Currently #RKH_CFG_SMA_MAX_TRC_SEGS cannot exceed 8.
+ */
+#define RKH_CFG_SMA_MAX_TRC_SEGS        2u
+
+/**
+ *	If the #RKH_CFG_SMA_PSEUDOSTATE_EN is set to 1, the RKH allows
+ *	pseudostates usage.
+ */
+#define RKH_CFG_SMA_PSEUDOSTATE_EN      RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_DEEP_HIST_EN and #RKH_CFG_SMA_PSEUDOSTATE_EN are
+ *	set to 1, the RKH allows deep history pseudostate usage.
+ */
+#define RKH_CFG_SMA_DEEP_HIST_EN        RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_SHALLOW_HIST_EN and #RKH_CFG_SMA_PSEUDOSTATE_EN
+ *	are set to 1, the RKH allows shallow history pseudostate usage.
+ */
+#define RKH_CFG_SMA_SHALLOW_HIST_EN     RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_CHOICE_EN and #RKH_CFG_SMA_PSEUDOSTATE_EN are set to
+ *	1, the RKH allows choice pseudostate usage.
+ */
+#define RKH_CFG_SMA_CHOICE_EN           RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_CONDITIONAL_EN and #RKH_CFG_SMA_PSEUDOSTATE_EN are
+ *	set to 1, the RKH allows branch (or conditional) pseudostate usage.
+ */
+#define RKH_CFG_SMA_CONDITIONAL_EN      RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_SUBMACHINE_EN and #RKH_CFG_SMA_PSEUDOSTATE_EN are
+ *	set to 1, the RKH allows submachine state (and exit/entry points) usage.
+ */
+#define RKH_CFG_SMA_SUBMACHINE_EN       RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_TRC_SNDR_EN and #RKH_CFG_TRC_EN are set to 1,
+ *	when posting an event the RKH inserts a pointer to the sender object.
+ */
+#define RKH_CFG_SMA_TRC_SNDR_EN         RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_INIT_EVT_EN is set to 1 then an initial event could
+ *	be be passed to state machine application when it starts, like an
+ *	argc/argv. Also, the #RKH_CFG_SMA_INIT_EVT_EN changes the initial action
+ *	prototype.
+ */
+#define RKH_CFG_SMA_INIT_EVT_EN         RKH_DISABLED
+
+/* --- Configuration options related to SMA action featues ---------------- */
+
+/**
+ *	If the #RKH_CFG_SMA_INIT_ARG_SMA_EN is set to 1 then the initial action
+ *	prototype will add as argument a pointer to state machine structure
+ *	#RKH_SMA_T. See #RKH_INIT_ACT_T definition.
+ */
+#define RKH_CFG_SMA_INIT_ARG_SMA_EN     RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_ENT_ARG_SMA_EN is set to 1 then the entry action
+ *	prototype will add as argument a pointer to state machine structure
+ *	#RKH_SMA_T. See #RKH_ENT_ACT_T definition.
+ */
+#define RKH_CFG_SMA_ENT_ARG_SMA_EN      RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_ENT_ARG_STATE_EN is set to 1 then the entry action
+ *	prototype will add as argument a pointer to "this" state structure
+ *	#RKH_ST_T. See #RKH_ENT_ACT_T definition.
+ */
+#define RKH_CFG_SMA_ENT_ARG_STATE_EN    RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_EXT_ARG_SMA_EN is set to 1 then the exit action
+ *	prototype will add as argument a pointer to state machine structure
+ *	#RKH_SMA_T. See #RKH_EXT_ACT_T definition.
+ */
+#define RKH_CFG_SMA_EXT_ARG_SMA_EN      RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_EXT_ARG_STATE_EN is set to 1 then the exit action
+ *	prototype will add as argument a pointer to "this" state structure
+ *	#RKH_ST_T. See #RKH_EXT_ACT_T definition.
+ */
+#define RKH_CFG_SMA_EXT_ARG_STATE_EN    RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_SMA_ACT_ARG_SMA_EN is set to 1 then the transition action
+ *	prototype will add as argument a pointer to state machine structure
+ *	#RKH_SMA_T. See #RKH_TRN_ACT_T definition.
+ */
+#define RKH_CFG_SMA_ACT_ARG_SMA_EN      RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_ACT_ARG_EVT_EN is set to 1 then the transition action
+ *	prototype will add as argument a pointer to ocurred event.
+ *	See RKH_TRN_ACT_T definition.
+ */
+#define RKH_CFG_SMA_ACT_ARG_EVT_EN      RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_GRD_ARG_EVT_EN is set to 1 then the transition guard
+ *	prototype will add as argument a pointer to ocurred event.
+ *	See RKH_GUARD_T definition.
+ */
+#define RKH_CFG_SMA_GRD_ARG_EVT_EN      RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_GRD_ARG_SMA_EN is set to 1 then the transition guard
+ *	prototype will add as argument a pointer to state machine structure
+ *	RKH_SMA_T. See RKH_GUARD_T definition.
+ */
+#define RKH_CFG_SMA_GRD_ARG_SMA_EN      RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_SMA_PPRO_ARG_SMA_EN is set to 1 then the event preprocessor
+ *	(Moore function like entry and exit actions) prototype will add as
+ *	argument a pointer to state machine structure
+ *	RKH_SMA_T. See RKH_PPRO_T definition.
+ */
+#define RKH_CFG_SMA_PPRO_ARG_SMA_EN     RKH_ENABLED
+
+/**
+ *  \brief
+ *  If RKH_CFG_SMA_SM_CONST_EN is set to RKH_ENABLED then much of the state
+ *  machine object is allocated in ROM. This approach does have as key benefit
+ *  the little RAM consuming as compared when RKH_CFG_SMA_SM_CONST_EN is set
+ *  to RKH_DISABLED.
+ *  Nevertheless, the primary drawback of this approach is the obfuscated API
+ *  to use it.
+ *  In constrast, if RKH_CFG_SMA_SM_CONST_EN is set to RKH_ENABLED then the
+ *  whole state machine object is allocated in RAM, including its own
+ *  constant part. However, the API to use it is very simple, intuitive,
+ *  and flexible, allowing easily the dynamic memory allocation
+ */
+#define RKH_CFG_SMA_SM_CONST_EN         RKH_ENABLED
+
+/**
+ *  \brief
+ *  If RKH_CFG_SMA_RT_CTOR_EN is set to RKH_ENABLED then is allowed the use
+ *  of run-time constructors of RKH_SM_T and RKH_SMA_T classes, rkh_sm_ctor()
+ *  and rkh_sma_ctor() respectively.
+ *
+ *  \type       Boolean
+ *  \range
+ *  \default    RKH_DISABLED
+ */
+#define RKH_CFG_SMA_RT_CTOR_EN          RKH_DISABLED
+
+/**
+ *  \brief
+ *  If RKH_CFG_SMA_VFUNCT_EN is set to RKH_ENABLED, the active objects are
+ *  defined as polymorphics, since it incorporates a virtual table of
+ *  functions. See the default virtual table rkhSmaVtbl to known the
+ *  available polymorphic operations.
+ *
+ *  \type       Boolean
+ *  \range
+ *  \default    RKH_DISABLED
+ */
+#define RKH_CFG_SMA_VFUNCT_EN           RKH_DISABLED
+
+/* --- Configuration options related to trace facility -------------------- */
+
+/**
+ *	If the #RKH_CFG_TRC_EN is set to 1 then RKH will include the trace
+ *	facility.
+ */
+#define RKH_CFG_TRC_EN                  RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_RTFIL_EN is set to 1 then RKH will include
+ *	the runtime trace filter facility.
+ *  When #RKH_CFG_TRC_RTFIL_EN is enabled RKH also will
+ *  automatically define RKH_FILTER_ON_GROUP(), RKH_FILTER_OFF_GROUP(),
+ *  RKH_FILTER_ON_EVENT(), RKH_FILTER_OFF_EVENT(),
+ *  RKH_FILTER_ON_GROUP_ALL_EVENTS(), RKH_FILTER_OFF_GROUP_ALL_EVENTS(),
+ *  RKH_FILTER_ON_SMA(), and RKH_FILTER_OFF_SMA() macros.
+ */
+#define RKH_CFG_TRC_RTFIL_EN            RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_RTFIL_EN and #RKH_CFG_TRC_RTFIL_SMA_EN are
+ *	set to 1, the RKH allows the usage of runtime trace filter for state
+ *	machine applications (active objects).
+ */
+#define RKH_CFG_TRC_RTFIL_SMA_EN        RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_RTFIL_EN and #RKH_CFG_TRC_RTFIL_SIGNAL_EN
+ *	are set to 1, the RKH allows the usage of runtime trace filter for
+ *	signals (events).
+ */
+#define RKH_CFG_TRC_RTFIL_SIGNAL_EN     RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_USER_TRACE_EN is set to 1 then RKH will allow to
+ *	build and generate tracing information from the application-level code.
+ *	This trace records are application-specific.
+ */
+#define RKH_CFG_TRC_USER_TRACE_EN       RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_ALL_EN is set to 1 then RKH will include all its own
+ *	trace records.
+ */
+#define RKH_CFG_TRC_ALL_EN              RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_MP_EN is set to 1 then RKH will include all trace
+ *	records related to the native fixed-size memory blocks.
+ */
+#define RKH_CFG_TRC_MP_EN               RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_QUE_EN is set to 1 then RKH will include all trace
+ *	records related to the native queues.
+ */
+#define RKH_CFG_TRC_QUE_EN               RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SMA_EN is set to 1 then RKH will include all trace
+ *	records related to the state machine applications.
+ */
+#define RKH_CFG_TRC_SMA_EN              RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_TMR_EN is set to 1 then RKH will include all trace
+ *	records related to the native software timer.
+ */
+#define RKH_CFG_TRC_TMR_EN              RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_EN is set to 1 then RKH will include all trace
+ *	records related to the state machine (hierarchical and "flat").
+ */
+#define RKH_CFG_TRC_SM_EN               RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_FWK_EN is set to 1 then RKH will include all trace
+ *	records related to the nativenative  event framework.
+ */
+#define RKH_CFG_TRC_FWK_EN              RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_ASSERT_EN and #RKH_CFG_TRC_FWK_EN are set to 1 then
+ *	RKH will include the "assertion" trace record.
+ */
+#define RKH_CFG_TRC_ASSERT_EN           RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_INIT_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "init state machine" trace record.
+ */
+#define RKH_CFG_TRC_SM_INIT_EN          RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_DCH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "start a state machine" trace record.
+ */
+#define RKH_CFG_TRC_SM_DCH_EN          RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "dispatch an event to state machine" trace record.
+ */
+#define RKH_CFG_TRC_SM_CLRH_EN          RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "clear the history pseudostate" trace record.
+ */
+#define RKH_CFG_TRC_SM_TRN_EN           RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_STATE_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "final state of transition" trace record.
+ */
+#define RKH_CFG_TRC_SM_STATE_EN         RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "entry state" trace record.
+ */
+#define RKH_CFG_TRC_SM_ENSTATE_EN       RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "exit state" trace record.
+ */
+#define RKH_CFG_TRC_SM_EXSTATE_EN       RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "number of entry and exit states in transition"
+ *	trace record.
+ */
+#define RKH_CFG_TRC_SM_NENEX_EN         RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "number of executed actions in transition" trace
+ *	record.
+ */
+#define RKH_CFG_TRC_SM_NTRNACT_EN       RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "state or pseudostate in a compound transition"
+ *	trace record.
+ */
+#define RKH_CFG_TRC_SM_TS_STATE_EN      RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_CLRH_EN and #RKH_CFG_TRC_SM_EN are set to 1 then
+ *	RKH will include the "returned code from dispatch function" trace record.
+ */
+#define RKH_CFG_TRC_SM_PROCESS_EN       RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TRC_SM_EXE_ACT_EN and #RKH_CFG_TRC_SM_EN are set to 1
+ *	then RKH will include the "executed behavior of state machine" trace
+ *	record.
+ */
+#define RKH_CFG_TRC_SM_EXE_ACT_EN       RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_NSEQ_EN is set to 1 then RKH will add to the trace
+ *	record an incremental number (1-byte), used like a sequence number.
+ *	See RKH_TRC_NSEQ() and RKH_TRC_HDR() macros.
+ */
+#define RKH_CFG_TRC_NSEQ_EN             RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_CHK_EN is set to 1 then RKH will add to the trace
+ *	record a checksum (1-byte). See RKH_TRC_CHK() macro.
+ */
+#define RKH_CFG_TRC_CHK_EN              RKH_ENABLED
+
+/**
+ *	If the #RKH_CFG_TRC_TSTAMP_EN is set to 1 then RKH will add to the trace
+ *	record a timestamp field. It's configurable by means of
+ *	#RKH_CFGPORT_TRC_SIZEOF_TSTAMP.
+ */
+#define RKH_CFG_TRC_TSTAMP_EN           RKH_ENABLED
+
+/**
+ *	Specify the maximum number of trace events in the stream. The smaller
+ *	this number, the lower the RAM consumption.
+ */
+#define RKH_CFG_TRC_SIZEOF_STREAM       128u
+
+/* --- Configuration options related to queue (by reference) facility ----- */
+
+/**
+ *	If the #RKH_CFG_QUE_EN is set to 1 then RKH will include the native queue
+ *	facility.
+ */
+#define RKH_CFG_QUE_EN                   RKH_ENABLED
+
+/**
+ *  Specify the maximum number of elements that any queue can contain.
+ *  The valid values [in bits] are 8, 16 or 32. Default is 8.
+ *	See #RKH_QUENE_T type.
+ */
+#define RKH_CFG_QUE_SIZEOF_NELEM         8u
+
+/**
+ *	If the #RKH_CFG_QUE_GET_LWMARK_EN is set to 1 then RKH allows to known the
+ *  minimum number of free elements ever in the queue (low-watermark ).
+ *  This provides valuable empirical data for proper sizing of the queue.
+ *  See rkh_rq_get_lwm() function.
+ */
+#define RKH_CFG_QUE_GET_LWMARK_EN        RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_QUE_GET_INFO_EN is set to 1 then RKH allows to collect and
+ *	retrives performance information for a particular queue.
+ *	See rkh_rq_get_info() and rkh_rq_clear_info() functions.
+ */
+#define RKH_CFG_QUE_GET_INFO_EN          RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_QUE_READ_EN is set to 1 then RKH will include the
+ *	rkh_rq_read() function that allows read an element from a queue without
+ *	remove it. See rkh_rq_read() function.
+ */
+#define RKH_CFG_QUE_READ_EN              RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_QUE_DEPLETE_EN is set to 1 then RKH will include the
+ *	rkh_rq_deplete() function that empties the contents of the queue and
+ *	eliminates all stored elements.
+ *	See rkh_rq_deplete() function.
+ */
+#define RKH_CFG_QUE_DEPLETE_EN           RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_QUE_IS_FULL_EN is set to 1 then RKH will include the
+ *	rkh_rq_is_full() function that allows to known if a queue is full.
+ *	See rkh_rq_is_full() function.
+ */
+#define RKH_CFG_QUE_IS_FULL_EN           RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_QUE_GET_NELEMS_EN is set to 1 then RKH will include the
+ *	rkh_rq_get_num() function that returns the number of elements currently
+ *	in the queue.
+ *	See rkh_rq_get_num() function.
+ */
+#define RKH_CFG_QUE_GET_NELEMS_EN        RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_QUE_PUT_LIFO_EN is set to 1 then RKH will include the
+ *	rkh_rq_put_lifo() function that puts an element on a queue in a LIFO
+ *	manner.
+ *	See rkh_rq_put_lifo() function.
+ */
+#define RKH_CFG_QUE_PUT_LIFO_EN          RKH_DISABLED
+
+/* --- Configuration options related to fixed-sized memory block facility - */
+
+/**
+ *	If the #RKH_CFG_MP_EN is set to 1 then RKH will include the native
+ *	fixed-size memory block management.
+ */
+#define RKH_CFG_MP_EN                   RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_MP_EN is set to 1 then RKH will include the native
+ *	fixed-size memory block management.
+ */
+#define RKH_CFG_MP_REDUCED_EN           RKH_DISABLED
+
+/**
+ *  Specify the size of memory block size. The valid values [in bits] are
+ *  8, 16 or 32. Default is 8. See #RKH_MPBS_T type.
+ */
+#define RKH_CFG_MP_SIZEOF_BSIZE         8u
+
+/**
+ *  Specify size of number of memory block size. The valid values [in bits]
+ *  are 8, 16 or 32. Default is 8. See #RKH_MPNB_T type.
+ */
+#define RKH_CFG_MP_SIZEOF_NBLOCK        8u
+
+/**
+ *	If the #RKH_CFG_MP_GET_BSIZE_EN is set to 1 then RKH will include the
+ *	rkh_mp_get_bsize() function that returns the size of memory block in
+ *	bytes. See rkh_mp_get_bsize() function.
+ */
+#define RKH_CFG_MP_GET_BSIZE_EN         RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_MP_GET_NFREE_EN is set to 1 then RKH will include the
+ *	rkh_mp_get_nfree() function that returns the current number of free
+ *	memory blocks in the pool.
+ *	See rkh_mp_get_nfree() function.
+ */
+#define RKH_CFG_MP_GET_NFREE_EN         RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_MP_GET_LWM_EN is set to 1 then RKH will include the
+ *	rkh_mp_get_low_wmark() function that returns the lowest number of free
+ *	blocks ever present in the pool. This number provides valuable empirical
+ *	data for proper sizing of the memory pool.
+ *	See rkh_mp_get_low_wmark() function.
+ */
+#define RKH_CFG_MP_GET_LWM_EN           RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_MP_GET_INFO_EN is set to 1 then RKH will include the
+ *	rkh_mp_get_info() function that retrieves performance information for
+ *	a particular memory pool. See rkh_mp_get_info() function.
+ */
+#define RKH_CFG_MP_GET_INFO_EN          RKH_DISABLED
+
+/* --- Configuration options related to software timer facility ----------- */
+
+/**
+ *	If the #RKH_CFG_QUE_EN is set to 1 then RKH will include the native software
+ *	timer facility.
+ */
+#define RKH_CFG_TMR_EN                  RKH_ENABLED
+
+/**
+ *  Specify the dynamic range of the time delays measured in clock ticks
+ *  (maximum number of ticks). The valid values [in bits] are 8, 16 or 32.
+ *  Default is 8.
+ */
+#define RKH_CFG_TMR_SIZEOF_NTIMER       16u
+
+/**
+ *	If the #RKH_CFG_TMR_HOOK_EN is set to 1 then RKH will invoke a hook
+ *	function when a timer expires. When this is set the application must
+ *	provide the hook function.
+ */
+#define RKH_CFG_TMR_HOOK_EN             RKH_DISABLED
+
+/**
+ *	If the #RKH_CFG_TMR_GET_INFO_EN is set to 1 then RKH will include the
+ *	rkh_tmr_get_info() function that retrieves performance information for
+ *	a particular software timer. See rkh_tmr_get_info() function.
+ */
+#define RKH_CFG_TMR_GET_INFO_EN         RKH_DISABLED
+
+#endif
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/app/src/blinky.c ./app/src/blinky.c
--- a_qSC69Z/app/src/blinky.c	1969-12-31 21:00:00.000000000 -0300
+++ ./app/src/blinky.c	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,120 @@
+/**
+ *  \file       blinky.c
+ *  \brief      Example application.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2016.03.17  LeFr  v1.0.00  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "rkhfwk_dynevt.h"
+#include "blinky.h"
+#include "bsp.h"
+
+/* ----------------------------- Local macros ------------------------------ */
+#define LED_OFF_TIME            RKH_TIME_SEC(2)
+#define LED_ON_TIME             RKH_TIME_SEC(2)
+
+/* ......................... Declares active object ........................ */
+typedef struct Blinky Blinky;
+
+/* ................... Declares states and pseudostates .................... */
+RKH_DCLR_BASIC_STATE ledOff, ledOn;
+
+/* ........................ Declares initial action ........................ */
+static void blinky_init(Blinky *const me);
+
+/* ........................ Declares effect actions ........................ */
+static void blinky_ledOn(Blinky *const me, RKH_EVT_T *pe);
+static void blinky_ledOff(Blinky *const me, RKH_EVT_T *pe);
+
+/* ......................... Declares entry actions ........................ */
+/* ......................... Declares exit actions ......................... */
+/* ............................ Declares guards ............................ */
+/* ........................ States and pseudostates ........................ */
+RKH_CREATE_BASIC_STATE(ledOn, NULL, NULL, RKH_ROOT, NULL);
+RKH_CREATE_TRANS_TABLE(ledOn)
+    RKH_TRREG(TIMEOUT, NULL, blinky_ledOff, &ledOff),
+RKH_END_TRANS_TABLE
+
+RKH_CREATE_BASIC_STATE(ledOff, NULL, NULL, RKH_ROOT, NULL);
+RKH_CREATE_TRANS_TABLE(ledOff)
+    RKH_TRREG(TIMEOUT, NULL, blinky_ledOn, &ledOn),
+RKH_END_TRANS_TABLE
+
+/* ............................. Active object ............................. */
+struct Blinky
+{
+    RKH_SMA_T sma;      /* base structure */
+    rui8_t cnt;         /* private member */
+    RKH_TMR_T timer;    /* which is responsible for toggling the LED */
+                        /* posting the TIMEOUT signal event to active object */
+                        /* 'blinky' */
+};
+
+RKH_SMA_CREATE(Blinky, blinky, 0, HCAL, &ledOn, blinky_init, NULL);
+RKH_SMA_DEF_PTR(blinky);
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/*
+ *  Declare and allocate the 'e_tout' event.
+ *  The 'e_tout' event with TIMEOUT signal never changes, so it can be
+ *  statically allocated just once by means of RKH_ROM_STATIC_EVENT() macro.
+ */
+static RKH_ROM_STATIC_EVENT(e_tout, TIMEOUT);
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ............................ Initial action ............................. */
+static void
+blinky_init(Blinky *const me)
+{
+    RKH_TR_FWK_AO(me);
+    RKH_TR_FWK_QUEUE(&RKH_UPCAST(RKH_SMA_T, me)->equeue);
+    RKH_TR_FWK_STATE(me, &ledOn);
+    RKH_TR_FWK_STATE(me, &ledOff);
+    RKH_TR_FWK_TIMER(&me->timer);
+    RKH_TR_FWK_SIG(TIMEOUT);
+
+    RKH_TMR_INIT(&me->timer, &e_tout, NULL);
+    blinky_ledOn(me, NULL);
+}
+
+/* ............................ Effect actions ............................. */
+static void
+blinky_ledOn(Blinky *const me, RKH_EVT_T *pe)
+{
+    (void)pe;
+
+    RKH_TMR_ONESHOT(&me->timer, RKH_UPCAST(RKH_SMA_T, me), LED_ON_TIME);
+    bsp_ledOn();
+    ++me->cnt;
+}
+
+static void
+blinky_ledOff(Blinky *const me, RKH_EVT_T *pe)
+{
+    (void)me;
+    (void)pe;
+
+    RKH_TMR_ONESHOT(&me->timer, RKH_UPCAST(RKH_SMA_T, me), LED_OFF_TIME);
+    bsp_ledOff();
+}
+
+/* ............................. Entry actions ............................. */
+/* ............................. Exit actions .............................. */
+/* ................................ Guards ................................. */
+/* ---------------------------- Global functions --------------------------- */
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/app/src/main.c ./app/src/main.c
--- a_qSC69Z/app/src/main.c	1969-12-31 21:00:00.000000000 -0300
+++ ./app/src/main.c	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,48 @@
+/**
+ *  \file       main.c
+ *  \brief      Example application.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2016.03.17  LeFr  v1.0.00  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "rkhfwk_sched.h"
+#include "blinky.h"
+#include "bsp.h"
+
+
+/* ----------------------------- Local macros ------------------------------ */
+#define QSTO_SIZE           4
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static RKH_EVT_T *qsto[QSTO_SIZE];
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+int
+main(int argc, char *argv[])
+{
+    bsp_init(argc, argv);
+
+    RKH_SMA_ACTIVATE(blinky, qsto, QSTO_SIZE, 0, 0);
+    rkh_fwk_enter();
+
+    RKH_TRC_CLOSE();
+    return 0;
+}
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/bsp/inc/bsp.h ./bsp/inc/bsp.h
--- a_qSC69Z/bsp/inc/bsp.h	1969-12-31 21:00:00.000000000 -0300
+++ ./bsp/inc/bsp.h	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,79 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       bsp.h
+ *  \brief      BSP for Cortex-M3 EDU-CIAA LPC4337 ARM-GCC
+ *
+ *  \ingroup    bsp
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.06.23  DaBa  v1.0.00  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  DaBa  Dario Baliña       dariosb@gmail.com
+ */
+
+/* --------------------------------- Module -------------------------------- */
+#ifndef __BSP_H__
+#define __BSP_H__
+
+/* ----------------------------- Include files ----------------------------- */
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+#define BSP_TICK_RATE_MS    (1000/RKH_CFG_FWK_TICK_RATE_HZ)
+
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+void bsp_init(int argc, char *argv[]);
+void bsp_timeTick(void);
+void bsp_ledOn(void);
+void bsp_ledOff(void);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ File footer ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/bsp/src/assert.c ./bsp/src/assert.c
--- a_qSC69Z/bsp/src/assert.c	1969-12-31 21:00:00.000000000 -0300
+++ ./bsp/src/assert.c	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,81 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       assert.c
+ *  \brief      RKH assert function for EDU-CIAA
+ *
+ *  \ingroup    bsp
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  DaBa  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  DaBa  Dario Baliï¿½a       dariosb@gmail.com
+ */
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "rkhfwk_sched.h"
+#include "sapi.h"
+
+RKH_THIS_MODULE
+
+/* ----------------------------- Local macros ------------------------------ */
+#ifdef DEBUG
+#define reset_now()		__asm volatile	("	bkpt 0x00FF\n" )
+#else
+#define reset_now()		NVIC_SystemReset()
+#endif
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_assert(RKHROM char * const file, int line)
+{
+	(void)line;
+
+	RKH_DIS_INTERRUPT();
+	RKH_TR_FWK_ASSERT( (RKHROM char *)file, __LINE__ );
+	rkh_fwk_exit();
+	reset_now();
+}
+
+/* ------------------------------ File footer ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/bsp/src/bsp.c ./bsp/src/bsp.c
--- a_qSC69Z/bsp/src/bsp.c	1969-12-31 21:00:00.000000000 -0300
+++ ./bsp/src/bsp.c	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,119 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       bsp.c
+ *  \brief      BSP for Cortex-M3 EDU-CIAA LPC4337 ARM-GCC
+ *
+ *  \ingroup    bsp
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.06.23  DaBa  v1.0.00  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  DaBa  Dario Baliña       dariosb@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "rkhfwk_sched.h"
+#include "blinky.h"
+#include "bsp.h"
+#include "sapi.h"
+
+RKH_THIS_MODULE
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static RKH_TS_T tstamp;
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+bsp_timeTick(void)
+{
+    ++tstamp;
+}
+
+RKH_TS_T
+rkh_trc_getts(void)
+{
+    return tstamp;
+}
+
+void
+bsp_init(int argc, char *argv[])
+{
+    (void)argc;
+    (void)argv;
+
+    boardConfig();
+
+    gpioConfig(0, GPIO_ENABLE);
+
+    gpioConfig(LED1, GPIO_OUTPUT);
+
+    rkh_fwk_init();
+
+    RKH_FILTER_ON_GROUP(RKH_TRC_ALL_GROUPS);
+    RKH_FILTER_ON_EVENT(RKH_TRC_ALL_EVENTS);
+    RKH_FILTER_OFF_EVENT(RKH_TE_TMR_TOUT);
+    RKH_FILTER_OFF_EVENT(RKH_TE_SM_STATE);
+    RKH_FILTER_OFF_SMA(blinky);
+    RKH_FILTER_OFF_ALL_SIGNALS();
+
+    RKH_TRC_OPEN();
+
+    RKH_ENA_INTERRUPT();
+}
+
+void
+bsp_ledOn(void)
+{
+    gpioWrite(LED1, ON);
+}
+
+void
+bsp_ledOff(void)
+{
+    gpioWrite(LED1, OFF);
+}
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/bsp/src/hook.c ./bsp/src/hook.c
--- a_qSC69Z/bsp/src/hook.c	1969-12-31 21:00:00.000000000 -0300
+++ ./bsp/src/hook.c	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,97 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       hook.c
+ *  \brief      RKH hooks functions for Edu-CIAA
+ *
+ *  \ingroup    bsp
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  DaBa  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  DaBa  Dario Baliï¿½a     dariosb@gmail.com
+ */
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "bsp.h"
+#include "sapi.h"
+
+RKH_THIS_MODULE
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+static bool_t tickHook(void *p);
+
+/* ---------------------------- Local functions ---------------------------- */
+static bool_t
+tickHook(void *p)
+{
+    RKH_TIM_TICK();
+}
+
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_hook_start(void)
+{    
+    tickConfig(BSP_TICK_RATE_MS, tickHook);
+}
+
+void
+rkh_hook_exit(void)
+{
+    RKH_TRC_FLUSH();
+}
+
+void
+rkh_hook_timetick(void)
+{
+    bsp_timeTick();
+}
+
+void
+rkh_hook_idle(void)             /* called within critical section */
+{
+	RKH_ENA_INTERRUPT();
+    RKH_TRC_FLUSH();
+}
+
+/* ------------------------------ File footer ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/bsp/src/trace_io.c ./bsp/src/trace_io.c
--- a_qSC69Z/bsp/src/trace_io.c	1969-12-31 21:00:00.000000000 -0300
+++ ./bsp/src/trace_io.c	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,110 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       trace_io.c
+ *  \brief      Serial support for EDU-CIAA
+ *
+ *  \ingroup    bsp
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  DaBa  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  DaBa  Dario Baliï¿½a       dariosb@gmail.com
+ */
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "bsp.h"
+#include "sapi.h"
+
+#if RKH_CFG_TRC_EN == 1
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+#define TRC_COM_PORT        UART_USB
+#define TRC_BAUD_RATE       115200
+#define BSP_TS_RATE_HZ      BSP_TICK_RATE_MS
+
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_trc_open(void)
+{
+    rkh_trc_init();
+    uartConfig(TRC_COM_PORT, TRC_BAUD_RATE);
+    RKH_TRC_SEND_CFG(BSP_TS_RATE_HZ);
+}
+
+void
+rkh_trc_close(void)
+{
+}
+
+void
+rkh_trc_flush(void)
+{
+    rui8_t *blk;
+    TRCQTY_T nbytes;
+    RKH_SR_ALLOC();
+
+    FOREVER
+    {
+        nbytes = 128;
+
+        RKH_ENTER_CRITICAL_();
+        blk = rkh_trc_get_block(&nbytes);
+        RKH_EXIT_CRITICAL_();
+
+        if ((blk != (rui8_t *)0))
+        {
+            while (nbytes--)
+            {
+                uartWriteByte(TRC_COM_PORT,*blk++);
+            }
+        }
+        else
+        {
+            break;
+        }
+    }
+}
+#endif
+
+/* ------------------------------ File footer ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/ciaa_lpc4337.ld ./ciaa_lpc4337.ld
--- a_qSC69Z/ciaa_lpc4337.ld	1969-12-31 21:00:00.000000000 -0300
+++ ./ciaa_lpc4337.ld	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,278 @@
+GROUP(
+  libgcc.a
+  libc.a
+  libm.a
+)
+
+MEMORY
+{
+  /* Define each memory region */
+  MFlashA512 (rx) : ORIGIN = 0x1a000000, LENGTH = 0x80000 /* 512K bytes */
+  MFlashB512 (rx) : ORIGIN = 0x1b000000, LENGTH = 0x80000 /* 512K bytes */
+  RamLoc32 (rwx) : ORIGIN = 0x10000000, LENGTH = 0x8000 /* 32K bytes */
+  RamLoc40 (rwx) : ORIGIN = 0x10080000, LENGTH = 0xa000 /* 40K bytes */
+  RamAHB32 (rwx) : ORIGIN = 0x20000000, LENGTH = 0x8000 /* 32K bytes */
+  RamAHB16 (rwx) : ORIGIN = 0x20008000, LENGTH = 0x4000 /* 16K bytes */
+  RamAHB_ETB16 (rwx) : ORIGIN = 0x2000c000, LENGTH = 0x4000 /* 16K bytes */
+}
+
+/* Define a symbol for the top of each memory region */
+__top_MFlashA512 = 0x1a000000 + 0x80000;
+__top_MFlashB512 = 0x1b000000 + 0x80000;
+__top_RamLoc32 = 0x10000000 + 0x8000;
+__top_RamLoc40 = 0x10080000 + 0xa000;
+__top_RamAHB32 = 0x20000000 + 0x8000;
+__top_RamAHB16 = 0x20008000 + 0x4000;
+__top_RamAHB_ETB16 = 0x2000c000 + 0x4000;
+
+ENTRY(ResetISR)
+
+SECTIONS
+{
+
+    .text_Flash2 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.text_Flash2*) /* for compatibility with previous releases */
+       *(.text_MFlashB512*) /* for compatibility with previous releases */
+       *(.text.$Flash2*)
+       *(.text.$MFlashB512*)
+       *(.rodata.$Flash2*)
+       *(.rodata.$MFlashB512*)
+    } > MFlashB512
+
+    /* MAIN TEXT SECTION */
+    .text : ALIGN(4)
+    {
+        FILL(0xff)
+        __vectors_start__ = ABSOLUTE(.) ;
+        KEEP(*(.isr_vector))
+
+        /* Global Section Table */
+        . = ALIGN(4) ;
+        __section_table_start = .;
+        __data_section_table = .;
+        LONG(LOADADDR(.data));
+        LONG(    ADDR(.data));
+        LONG(  SIZEOF(.data));
+        LONG(LOADADDR(.data_RAM2));
+        LONG(    ADDR(.data_RAM2));
+        LONG(  SIZEOF(.data_RAM2));
+        LONG(LOADADDR(.data_RAM3));
+        LONG(    ADDR(.data_RAM3));
+        LONG(  SIZEOF(.data_RAM3));
+        LONG(LOADADDR(.data_RAM4));
+        LONG(    ADDR(.data_RAM4));
+        LONG(  SIZEOF(.data_RAM4));
+        LONG(LOADADDR(.data_RAM5));
+        LONG(    ADDR(.data_RAM5));
+        LONG(  SIZEOF(.data_RAM5));
+        __data_section_table_end = .;
+        __bss_section_table = .;
+        LONG(    ADDR(.bss));
+        LONG(  SIZEOF(.bss));
+        LONG(    ADDR(.bss_RAM2));
+        LONG(  SIZEOF(.bss_RAM2));
+        LONG(    ADDR(.bss_RAM3));
+        LONG(  SIZEOF(.bss_RAM3));
+        LONG(    ADDR(.bss_RAM4));
+        LONG(  SIZEOF(.bss_RAM4));
+        LONG(    ADDR(.bss_RAM5));
+        LONG(  SIZEOF(.bss_RAM5));
+        __bss_section_table_end = .;
+        __section_table_end = . ;
+        /* End of Global Section Table */
+
+
+        *(.after_vectors*)
+
+        /* Code Read Protect data */
+        . = 0x000002FC ;
+        PROVIDE(__CRP_WORD_START__ = .) ;
+        KEEP(*(.crp))
+        PROVIDE(__CRP_WORD_END__ = .) ;
+        ASSERT(!(__CRP_WORD_START__ == __CRP_WORD_END__), "Linker CRP Enabled, but no CRP_WORD provided within application");
+        /* End of Code Read Protect */
+
+    } >MFlashA512
+
+    .text : ALIGN(4)
+    {
+         *(.text*)
+        *(.rodata .rodata.* .constdata .constdata.*)
+        . = ALIGN(4);
+
+    } > MFlashA512
+
+    /*
+     * for exception handling/unwind - some Newlib functions (in common
+     * with C++ and STDC++) use this.
+     */
+    .ARM.extab : ALIGN(4)
+    {
+       *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > MFlashA512
+    __exidx_start = .;
+
+    .ARM.exidx : ALIGN(4)
+    {
+       *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > MFlashA512
+    __exidx_end = .;
+
+    _etext = .;
+
+
+    /* DATA section for RamLoc40 */
+   .data_RAM2 : ALIGN(4)
+    {
+       FILL(0xff)
+      /*  __core_m0app_START__ = .; start of slave image
+         KEEP(*(.core_m0app))
+       __core_m0app_END__ = .;  end of slave image
+       ASSERT(!(__core_m0app_START__ == __core_m0app_END__), "No slave code for _core_m0app");
+       ASSERT( (ABSOLUTE(__core_m0app_START__) == __vectors_start___core_m0app), "M0APP execute address differs from address provided in source image");*/
+       *(.ramfunc.$RAM2)
+       *(.ramfunc.$RamLoc40)
+       *(.data.$RAM2*)
+       *(.data.$RamLoc40*)
+       . = ALIGN(4) ;
+    } > RamLoc40 AT>MFlashA512
+
+    /* DATA section for RamAHB32 */
+    .data_RAM3 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.ramfunc.$RAM3)
+       *(.ramfunc.$RamAHB32)
+       *(.data.$RAM3*)
+       *(.data.$RamAHB32*)
+       . = ALIGN(4) ;
+    } > RamAHB32 AT>MFlashA512
+
+    /* DATA section for RamAHB16 */
+    .data_RAM4 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.ramfunc.$RAM4)
+       *(.ramfunc.$RamAHB16)
+       *(.data.$RAM4*)
+       *(.data.$RamAHB16*)
+       . = ALIGN(4) ;
+    } > RamAHB16 AT>MFlashA512
+
+    /* DATA section for RamAHB_ETB16 */
+    .data_RAM5 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.ramfunc.$RAM5)
+       *(.ramfunc.$RamAHB_ETB16)
+       *(.data.$RAM5*)
+       *(.data.$RamAHB_ETB16*)
+       . = ALIGN(4) ;
+    } > RamAHB_ETB16 AT>MFlashA512
+
+    /* MAIN DATA SECTION */
+
+
+    .uninit_RESERVED : ALIGN(4)
+    {
+        KEEP(*(.bss.$RESERVED*))
+        . = ALIGN(4) ;
+        _end_uninit_RESERVED = .;
+    } > RamLoc32
+
+
+   /* Main DATA section (RamLoc32) */
+   .data : ALIGN(4)
+   {
+      FILL(0xff)
+      _data = . ;
+      *(vtable)
+      *(.ramfunc*)
+      *(.data*)
+      . = ALIGN(4) ;
+      _edata = . ;
+   } > RamLoc32 AT>MFlashA512
+
+    /* BSS section for RamLoc40 */
+    .bss_RAM2 : ALIGN(4)
+    {
+       *(.bss.$RAM2*)
+       *(.bss.$RamLoc40*)
+       . = ALIGN(4) ;
+    } > RamLoc40
+    /* BSS section for RamAHB32 */
+    .bss_RAM3 : ALIGN(4)
+    {
+       *(.bss.$RAM3*)
+       *(.bss.$RamAHB32*)
+       . = ALIGN(4) ;
+    } > RamAHB32
+    /* BSS section for RamAHB16 */
+    .bss_RAM4 : ALIGN(4)
+    {
+       *(.bss.$RAM4*)
+       *(.bss.$RamAHB16*)
+       . = ALIGN(4) ;
+    } > RamAHB16
+    /* BSS section for RamAHB_ETB16 */
+    .bss_RAM5 : ALIGN(4)
+    {
+       *(.bss.$RAM5*)
+       *(.bss.$RamAHB_ETB16*)
+       . = ALIGN(4) ;
+    } > RamAHB_ETB16
+
+    /* MAIN BSS SECTION */
+    .bss : ALIGN(4)
+    {
+        _bss = .;
+        *(.bss*)
+        *(COMMON)
+        . = ALIGN(4) ;
+        _ebss = .;
+        PROVIDE(end = .);
+    } > RamLoc32
+
+    /* NOINIT section for RamLoc40 */
+    .noinit_RAM2 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM2*)
+       *(.noinit.$RamLoc40*)
+       . = ALIGN(4) ;
+    } > RamLoc40
+    /* NOINIT section for RamAHB32 */
+    .noinit_RAM3 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM3*)
+       *(.noinit.$RamAHB32*)
+       . = ALIGN(4) ;
+    } > RamAHB32
+    /* NOINIT section for RamAHB16 */
+    .noinit_RAM4 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM4*)
+       *(.noinit.$RamAHB16*)
+       . = ALIGN(4) ;
+    } > RamAHB16
+    /* NOINIT section for RamAHB_ETB16 */
+    .noinit_RAM5 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM5*)
+       *(.noinit.$RamAHB_ETB16*)
+       . = ALIGN(4) ;
+    } > RamAHB_ETB16
+
+    /* DEFAULT NOINIT SECTION */
+    .noinit (NOLOAD): ALIGN(4)
+    {
+        _noinit = .;
+        *(.noinit*)
+         . = ALIGN(4) ;
+        _end_noinit = .;
+    } > RamLoc32
+
+    PROVIDE(_pvHeapStart = .);
+    PROVIDE(_vStackTop = __top_RamLoc32 - 0);
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/ciaa-nxp.cfg ./ciaa-nxp.cfg
--- a_qSC69Z/ciaa-nxp.cfg	1969-12-31 21:00:00.000000000 -0300
+++ ./ciaa-nxp.cfg	2018-01-19 23:55:10.952318166 -0300
@@ -0,0 +1,161 @@
+###############################################################################
+#
+# Copyright 2014, Juan Cecconi (UTN-FRBA, Numetron)
+#
+# This file is part of CIAA Firmware.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its
+#    contributors may be used to endorse or promote products derived from this
+#    software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+###############################################################################
+#OpenOCD configuration (target and interface) for CIAA-NXP
+
+######################################################################################################
+# Utilizar una interface tipo FTDI, todo lo que sigue estÃ¡ basado en ello
+######################################################################################################
+interface ftdi
+
+######################################################################################################
+# Agrego el Par VID-PID del FTDI, si hay mÃ¡s agregar a continuaciÃ³n...
+######################################################################################################
+ftdi_vid_pid 0x0403 0x6010
+
+######################################################################################################
+# Se utilizÃ³ el Channel A (ADBUS0 a ADBUS3) para conectar el JTAG mediante MPSSE
+######################################################################################################
+ftdi_channel 0
+
+######################################################################################################
+# ftdi_layout_init 'Valor' 'DirecciÃ³n', Configura los GPIO (H-L), su valor y direcciÃ³n en ese orden(1 = Salida, 0 = entrada)
+# los 16 bits se arman H-L como sigue 'ACBUS7-0+ADBUS7-0'
+#ADBUS0 = FT_CLCK = 1, salida de Clock
+#ADBUS1 = FT_TDI = 1, salida de datos del FT
+#ADBUS2 = FT_TDO = 0, entrada de datos al FT
+#ADBUS3 = FT_TMS = 1, salida de Test Mode Select, setear a 1
+#ADBUS4 = Pin 14 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ADBUS5 = Pin 12 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ADBUS6 = Pin 10 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ADBUS7 = Pin 8 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ACBUS0 = FT_TRST = 1, salida de TRST...va al buffer y luego no se usa, setear a 1
+#ACBUS1 = FT_RST = 1, salida de RST...va al buffer y luego no se usa, setear a 1
+#ACBUS2 = FT_OE = 1, salida de OE para manejar el Buffer del JTAG, setear a 1
+#ACBUS3 = Pin 6 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ACBUS4 = Pin 4 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ACBUS5 = Pin 2 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ACBUS6 = Pin 1 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+#ACBUS7 = Pin 3 - conector P9 = 1 salida para no dejar flotante e ingresar ruido al FT
+######################################################################################################
+ftdi_layout_init 0x0708 0xFFFB
+
+######################################################################################################
+# La creaciÃ³n de las seÃ±ales que siguen no hacen falta porque se indicÃ³ en el Target cfg que no se
+# las tiene conectadas a ningÃºn lado
+######################################################################################################
+
+######################################################################################################
+# Creo la seÃ±al llamada nTRST (Not TAP Reset) que es una tipo dato, y usa el bit 8 del GPIO (H-L), es
+# decir GPIOH0 (pin ACBUS0) por eso 0x100, y a la vez se activa conjuntamente con el OE que
+# estÃ¡ usado en el bit 10 del GPIO, es decir, en GPIOH2 (pin ACBUS2) por eso 0x400
+######################################################################################################
+ftdi_layout_signal nTRST -data 0x0100
+
+######################################################################################################
+# Creo la seÃ±al llamada nSRST (Not System Reset) que se activa cuando se hace un cmd 'reset'
+# Es tipo dato y usa el bit 9 del GPIO (H-L), es decir GPIOH1 (pin ACBUS1) por eso 0x200,
+# y a la vez se activa conjuntamente con el OE que  estÃ¡ usado en el bit 10 del GPIO, es decir,
+# en GPIOH2 (pin ACBUS2) por eso 0x400
+######################################################################################################
+ftdi_layout_signal nSRST -data 0x0200
+
+################################################################
+# Especifica en KHz la frecuencia del Clock en el JTAG (TCK)
+################################################################
+transport select jtag
+adapter_khz 2000
+
+################################################################
+# Defino nombre de CHIP
+################################################################
+set _CHIPNAME lpc4337
+
+################################################################
+# Defino los TAP del JTAG, para el core M4 y M0
+################################################################
+
+# M4 JTAG mode TAP
+set _M4_JTAG_TAPID 0x4ba00477
+
+# M0 TAP
+set _M0_JTAG_TAPID 0x0ba01477
+
+jtag newtap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M4_JTAG_TAPID
+
+jtag newtap $_CHIPNAME m0 -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M0_JTAG_TAPID
+
+################################################################
+# Creo los 2 targets lpc4337.m4 y lpc4337.m0
+################################################################
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+target create $_CHIPNAME.m0 cortex_m -chain-position $_CHIPNAME.m0
+
+################################################################
+# Defino un area de trabajo en la RAM para acelerar el proceso
+# de programaciÃ³n de la flash
+################################################################
+set _WORKAREASIZE 0x8000
+$_CHIPNAME.m4 configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE
+
+################################################################
+# Se define un banco de flash, grabable usando el driver lpc2000
+# que es compatible con el LPC4337
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
+################################################################
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME lpc2000 0x1a000000 0x80000 0 0 $_CHIPNAME.m4 lpc4300 96000 calc_checksum
+
+################################################################
+# TRST (TAP Reset) y SRST (System Reset) no estÃ¡n conectados mÃ¡s allÃ¡ del Buffer
+# en el prototipo.
+# Por lo tanto se indica 'none'
+################################################################
+reset_config none
+#reset_config trst_only
+
+################################################################
+# on this CPU we should use VECTRESET to perform a soft reset and
+# manually reset the periphery
+# SRST or SYSRESETREQ disable the debug interface for the time of
+# the reset and will not fit our requirements for a consistent debug
+# session
+################################################################
+cortex_m reset_config vectreset
+
+targets $_CHIPNAME.m4
+
+$_CHIPNAME.m4 configure -event gdb-attach {
+   echo "Reset Halt, due to gdb attached...!"
+   reset halt
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/config.mk ./config.mk
--- a_qSC69Z/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./config.mk	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,10 @@
+APP=blinky
+
+MODULES=app lpc_chip_43xx lpc_board_ciaa_edu_4337 sapi rkh bsp
+DEFINES=CORE_M4 __USE_LPCOPEN __USE_NEWLIB __EDUCIAA_EID__
+
+VERBOSE=n
+OPT=g
+USE_NANO=y
+SEMIHOST=n
+USE_FPU=y
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/inc/board_api.h ./lpc_board_ciaa_edu_4337/inc/board_api.h
--- a_qSC69Z/lpc_board_ciaa_edu_4337/inc/board_api.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/inc/board_api.h	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,176 @@
+/*
+ * @brief Common board API functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __BOARD_API_H_
+#define __BOARD_API_H_
+
+#include "lpc_types.h"
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup BOARD_COMMON_API BOARD: Common board functions
+ * @ingroup BOARD_Common
+ * This file contains common board definitions that are shared across
+ * boards and devices. All of these functions do not need to be
+ * implemented for a specific board, but if they are implemented, they
+ * should use this API standard.
+ * @{
+ */
+
+/**
+ * @brief  Setup and initialize hardware prior to call to main()
+ * @return None
+ * @note   Board_SystemInit() is called prior to the application and sets up system
+ * clocking, memory, and any resources needed prior to the application
+ * starting.
+ */
+void Board_SystemInit(void);
+
+/**
+ * @brief  Setup pin multiplexer per board schematics
+ * @return None
+ * @note   Board_SetupMuxing() should be called from SystemInit() prior to application
+ * main() is called. So that the PINs are set in proper state.
+ */
+void Board_SetupMuxing(void);
+
+/**
+ * @brief  Setup system clocking
+ * @return None
+ * @note   This sets up board clocking.
+ */
+void Board_SetupClocking(void);
+
+/**
+ * @brief  Setup external system memory
+ * @return None
+ * @note   This function is typically called after pin mux setup and clock setup and
+ * sets up any external memory needed by the system (DRAM, SRAM, etc.). Not all
+ * boards need this function.
+ */
+void Board_SetupExtMemory(void);
+
+/**
+ * @brief  Set up and initialize all required blocks and functions related to the board hardware.
+ * @return None
+ */
+void Board_Init(void);
+
+/**
+ * @brief  Initializes board UART for output, required for printf redirection
+ * @return None
+ */
+void Board_Debug_Init(void);
+
+/**
+ * @brief  Sends a single character on the UART, required for printf redirection
+ * @param  ch  : character to send
+ * @return None
+ */
+void Board_UARTPutChar(char ch);
+
+/**
+ * @brief  Get a single character from the UART, required for scanf input
+ * @return EOF if not character was received, or character value
+ */
+int Board_UARTGetChar(void);
+
+/**
+ * @brief  Prints a string to the UART
+ * @param  str : Terminated string to output
+ * @return None
+ */
+void Board_UARTPutSTR(const char *str);
+
+/**
+ * @brief  Sets the state of a board LED to on or off
+ * @param  LEDNumber   : LED number to set state for
+ * @param  State       : true for on, false for off
+ * @return None
+ */
+void Board_LED_Set(uint8_t LEDNumber, bool State);
+
+/**
+ * @brief  Returns the current state of a board LED
+ * @param  LEDNumber   : LED number to set state for
+ * @return true if the LED is on, otherwise false
+ */
+bool Board_LED_Test(uint8_t LEDNumber);
+
+/**
+ * @brief  Toggles the current state of a board LED
+ * @param  LEDNumber   : LED number to change state for
+ * @return None
+ */
+void Board_LED_Toggle(uint8_t LEDNumber);
+
+/**
+ * @brief Function prototype for a MS delay function. Board layers or example code may
+ *        define this function as needed.
+ */
+typedef void (*p_msDelay_func_t)(uint32_t);
+
+/* The DEBUG* functions are selected based on system configuration.
+   Code that uses the DEBUG* functions will have their I/O routed to
+   the UART, semihosting, or nowhere. */
+#if defined(DEBUG_ENABLE)
+#if defined(DEBUG_SEMIHOSTING)
+#define DEBUGINIT()
+#define DEBUGOUT(...) printf(__VA_ARGS__)
+#define DEBUGSTR(str) printf(str)
+#define DEBUGIN() (int) EOF
+
+#else
+#define DEBUGINIT() Board_Debug_Init()
+#define DEBUGOUT(...) printf(__VA_ARGS__)
+#define DEBUGSTR(str) Board_UARTPutSTR(str)
+#define DEBUGIN() Board_UARTGetChar()
+#endif /* defined(DEBUG_SEMIHOSTING) */
+
+#else
+#define DEBUGINIT()
+#define DEBUGOUT(...)
+#define DEBUGSTR(str)
+#define DEBUGIN() (int) EOF
+#endif /* defined(DEBUG_ENABLE) */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BOARD_API_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/inc/board.h ./lpc_board_ciaa_edu_4337/inc/board.h
--- a_qSC69Z/lpc_board_ciaa_edu_4337/inc/board.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/inc/board.h	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,178 @@
+/*
+ * @brief NGX Xplorer 4330 board file
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __BOARD_H_
+#define __BOARD_H_
+
+#include "chip.h"
+/* board_api.h is included at the bottom of this file after DEBUG setup */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup BOARD_NGX_XPLORER_4330 LPC4330 NGX Xplorer board support software API functions
+ * @ingroup LPCOPEN_43XX_BOARD_NGX4330
+ * The board support software API functions provide some simple abstracted
+ * functions used across multiple LPCOpen board examples. See @ref BOARD_COMMON_API
+ * for the functions defined by this board support layer.<br>
+ * @{
+ */
+
+/** @defgroup BOARD_NGX_XPLORER_4330_OPTIONS BOARD: LPC4330 NGX Xplorer board options
+ * This board has options that configure its operation at build-time.<br>
+ * @{
+ */
+
+/** Define DEBUG_ENABLE to enable IO via the DEBUGSTR, DEBUGOUT, and
+    DEBUGIN macros. If not defined, DEBUG* functions will be optimized
+   out of the code at build time.
+ */
+#define DEBUG_ENABLE
+
+/** Define DEBUG_SEMIHOSTING along with DEBUG_ENABLE to enable IO support
+    via semihosting. You may need to use a C library that supports
+   semihosting with this option.
+ */
+//#define DEBUG_SEMIHOSTING
+
+/** Board UART used for debug output and input using the DEBUG* macros. This
+    is also the port used for Board_UARTPutChar, Board_UARTGetChar, and
+   Board_UARTPutSTR functions. */
+#define DEBUG_UART LPC_USART2
+
+/**
+ * @}
+ */
+
+/* Board name */
+#define BOARD_CIAA_EDU_NXP_4337
+
+/* Build for RMII interface */
+#define USE_RMII
+#define BOARD_ENET_PHY_ADDR    0x00
+
+#define LED_3 2
+#define LED_2 1
+#define LED_1 0
+#define LED_RED 3
+#define LED_GREEN 4
+#define LED_BLUE 5
+
+/**
+ * @brief  Sets up board specific I2C interface
+ * @param  id  : I2C Peripheral ID (I2C0, I2C1)
+ * @return Nothing
+ */
+void Board_I2C_Init(I2C_ID_T id);
+
+/**
+ * @brief  Sets up I2C Fast Plus mode
+ * @param  id  : Must always be I2C0
+ * @return Nothing
+ * @note   This function must be called before calling
+ *          Chip_I2C_SetClockRate() to set clock rates above
+ *          normal range 100KHz to 400KHz. Only I2C0 supports
+ *          this mode.
+ */
+STATIC INLINE void Board_I2C_EnableFastPlus(I2C_ID_T id)
+{
+   Chip_SCU_I2C0PinConfig(I2C0_FAST_MODE_PLUS);
+}
+
+/**
+ * @brief  Disable I2C Fast Plus mode and enables default mode
+ * @param  id  : Must always be I2C0
+ * @return Nothing
+ * @sa     Board_I2C_EnableFastPlus()
+ */
+STATIC INLINE void Board_I2C_DisableFastPlus(I2C_ID_T id)
+{
+   Chip_SCU_I2C0PinConfig(I2C0_STANDARD_FAST_MODE);
+}
+
+/**
+ * @brief  Initializes board specific GPIO Interrupt
+ * @return Nothing
+ */
+void Board_GPIO_Int_Init(void);
+
+/**
+ * @brief  Initialize pin muxing for SSP interface
+ * @param  pSSP    : Pointer to SSP interface to initialize
+ * @return Nothing
+ */
+void Board_SSP_Init(LPC_SSP_T *pSSP);
+
+/**
+ * @brief  Returns the MAC address assigned to this board
+ * @param  mcaddr : Pointer to 6-byte character array to populate with MAC address
+ * @return Nothing
+ */
+void Board_ENET_GetMacADDR(uint8_t *mcaddr);
+
+/**
+ * @brief  Initialize pin muxing for a UART
+ * @param  pUART   : Pointer to UART register block for UART pins to init
+ * @return Nothing
+ */
+void Board_UART_Init(LPC_USART_T *pUART);
+
+/**
+ * @brief  Initialize pin muxing for SDMMC interface
+ * @return Nothing
+ */
+void Board_SDMMC_Init(void);
+
+/**
+ * @brief  Initialize DAC
+ * @param  pDAC    : Pointer to DAC register interface used on this board
+ * @return Nothing
+ */
+void Board_DAC_Init(LPC_DAC_T *pDAC);
+
+/**
+ * @brief  Initialize ADC
+ * @return Nothing
+ */
+STATIC INLINE void Board_ADC_Init(void){}
+
+/**
+ * @}
+ */
+
+#include "board_api.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BOARD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/src/board.c ./lpc_board_ciaa_edu_4337/src/board.c
--- a_qSC69Z/lpc_board_ciaa_edu_4337/src/board.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/src/board.c	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,201 @@
+/*
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "board.h"
+#include "string.h"
+
+/** @ingroup BOARD_NGX_XPLORER_18304330
+ * @{
+ */
+
+/* SDIO Data pin configuration bits */
+#define SDIO_DAT_PINCFG (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_PULLUP | SCU_MODE_FUNC7)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/* System configuration variables used by chip driver */
+const uint32_t ExtRateIn = 0;
+const uint32_t OscRateIn = 12000000;
+
+typedef struct {
+   uint8_t port;
+   uint8_t pin;
+} io_port_t;
+
+static const io_port_t gpioLEDBits[] = {{0, 14}, {1, 11}, {1, 12}, {5, 0}, {5, 1}, {5, 2}};
+static uint32_t lcd_cfg_val;
+
+void Board_UART_Init(LPC_USART_T *pUART)
+{
+   Chip_SCU_PinMuxSet(0x6, 4, (SCU_MODE_INACT | SCU_MODE_FUNC2));                  /* P6,4 : UART0_TXD */
+   Chip_SCU_PinMuxSet(0x2, 1, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC1));/* P2.1 : UART0_RXD */
+}
+
+/* Initialize debug output via UART for board */
+void Board_Debug_Init(void)
+{
+#if defined(DEBUG_UART)
+   Board_UART_Init(DEBUG_UART);
+
+   Chip_UART_Init(DEBUG_UART);
+   Chip_UART_SetBaudFDR(DEBUG_UART, 115200);
+   Chip_UART_ConfigData(DEBUG_UART, UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS);
+
+   /* Enable UART Transmit */
+   Chip_UART_TXEnable(DEBUG_UART);
+#endif
+}
+
+/* Sends a character on the UART */
+void Board_UARTPutChar(char ch)
+{
+#if defined(DEBUG_UART)
+   /* Wait for space in FIFO */
+   while ((Chip_UART_ReadLineStatus(DEBUG_UART) & UART_LSR_THRE) == 0) {}
+   Chip_UART_SendByte(DEBUG_UART, (uint8_t) ch);
+#endif
+}
+
+/* Gets a character from the UART, returns EOF if no character is ready */
+int Board_UARTGetChar(void)
+{
+#if defined(DEBUG_UART)
+   if (Chip_UART_ReadLineStatus(DEBUG_UART) & UART_LSR_RDR) {
+       return (int) Chip_UART_ReadByte(DEBUG_UART);
+   }
+#endif
+   return EOF;
+}
+
+/* Outputs a string on the debug UART */
+void Board_UARTPutSTR(const char *str)
+{
+#if defined(DEBUG_UART)
+   while (*str != '\0') {
+       Board_UARTPutChar(*str++);
+   }
+#endif
+}
+
+static void Board_LED_Init()
+{
+   uint32_t idx;
+
+   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
+       /* Set pin direction and init to off */
+       Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin);
+       Chip_GPIO_SetPinState(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin, (bool) false);
+   }
+}
+
+void Board_LED_Set(uint8_t LEDNumber, bool On)
+{
+   if (LEDNumber < (sizeof(gpioLEDBits) / sizeof(io_port_t)))
+        Chip_GPIO_SetPinState(LPC_GPIO_PORT, gpioLEDBits[LEDNumber].port, gpioLEDBits[LEDNumber].pin, (bool) !On);
+}
+
+bool Board_LED_Test(uint8_t LEDNumber)
+{
+   if (LEDNumber < (sizeof(gpioLEDBits) / sizeof(io_port_t)))
+       return (bool) !Chip_GPIO_GetPinState(LPC_GPIO_PORT, gpioLEDBits[LEDNumber].port, gpioLEDBits[LEDNumber].pin);
+
+   return false;
+}
+
+void Board_LED_Toggle(uint8_t LEDNumber)
+{
+   Board_LED_Set(LEDNumber, !Board_LED_Test(LEDNumber));
+}
+
+/* Returns the MAC address assigned to this board */
+void Board_ENET_GetMacADDR(uint8_t *mcaddr)
+{
+   uint8_t boardmac[] = {0x00, 0x60, 0x37, 0x12, 0x34, 0x56};
+
+   memcpy(mcaddr, boardmac, 6);
+}
+
+/* Set up and initialize all required blocks and functions related to the
+   board hardware */
+void Board_Init(void)
+{
+   /* Sets up DEBUG UART */
+   DEBUGINIT();
+
+   /* Initializes GPIO */
+   Chip_GPIO_Init(LPC_GPIO_PORT);
+
+   /* Initialize LEDs */
+   Board_LED_Init();
+   Chip_ENET_RMIIEnable(LPC_ETHERNET);
+}
+
+void Board_I2C_Init(I2C_ID_T id)
+{
+   if (id == I2C1) {
+       /* Configure pin function for I2C1*/
+       Chip_SCU_PinMuxSet(0x2, 3, (SCU_MODE_ZIF_DIS | SCU_MODE_INBUFF_EN | SCU_MODE_FUNC1));       /* P2.3 : I2C1_SDA */
+       Chip_SCU_PinMuxSet(0x2, 4, (SCU_MODE_ZIF_DIS | SCU_MODE_INBUFF_EN | SCU_MODE_FUNC1));       /* P2.4 : I2C1_SCL */
+   } else {
+       Chip_SCU_I2C0PinConfig(I2C0_STANDARD_FAST_MODE);
+   }
+}
+
+void Board_SDMMC_Init(void)
+{
+   Chip_SCU_PinMuxSet(0x1, 9, SDIO_DAT_PINCFG);    /* P1.9 connected to SDIO_D0 */
+   Chip_SCU_PinMuxSet(0x1, 10, SDIO_DAT_PINCFG);   /* P1.10 connected to SDIO_D1 */
+   Chip_SCU_PinMuxSet(0x1, 11, SDIO_DAT_PINCFG);   /* P1.11 connected to SDIO_D2 */
+   Chip_SCU_PinMuxSet(0x1, 12, SDIO_DAT_PINCFG);   /* P1.12 connected to SDIO_D3 */
+
+   Chip_SCU_ClockPinMuxSet(2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_FUNC4)); /* CLK2 connected to SDIO_CLK */
+   Chip_SCU_PinMuxSet(0x1, 6, SDIO_DAT_PINCFG);    /* P1.6 connected to SDIO_CMD */
+   Chip_SCU_PinMuxSet(0x1, 13, (SCU_MODE_INBUFF_EN | SCU_MODE_FUNC7)); /* P1.13 connected to SDIO_CD */
+}
+
+void Board_SSP_Init(LPC_SSP_T *pSSP)
+{
+   if (pSSP == LPC_SSP1) {
+       Chip_SCU_PinMuxSet(0x1, 5, (SCU_PINIO_FAST | SCU_MODE_FUNC5));  /* P1.5 => SSEL1 */
+       Chip_SCU_PinMuxSet(0xF, 4, (SCU_PINIO_FAST | SCU_MODE_FUNC0));  /* PF.4 => SCK1 */
+       Chip_SCU_PinMuxSet(0x1, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC5)); /* P1.4 => MOSI1 */
+       Chip_SCU_PinMuxSet(0x1, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC5)); /* P1.3 => MISO1 */
+   } else {
+       return;
+   }
+}
+
+/* Initialize DAC interface for the board */
+void Board_DAC_Init(LPC_DAC_T *pDAC)
+{
+   Chip_SCU_DAC_Analog_Config();
+}
+
+/**
+ * @}
+ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/src/board_sysinit.c ./lpc_board_ciaa_edu_4337/src/board_sysinit.c
--- a_qSC69Z/lpc_board_ciaa_edu_4337/src/board_sysinit.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/src/board_sysinit.c	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,143 @@
+/*
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "board.h"
+
+/* The System initialization code is called prior to the application and
+   initializes the board for run-time operation. Board initialization
+   includes clock setup and default pin muxing configuration. */
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Structure for initial base clock states */
+struct CLK_BASE_STATES {
+   CHIP_CGU_BASE_CLK_T clk;    /* Base clock */
+   CHIP_CGU_CLKIN_T clkin; /* Base clock source, see UM for allowable souorces per base clock */
+   bool autoblock_enab;/* Set to true to enable autoblocking on frequency change */
+   bool powerdn;       /* Set to true if the base clock is initially powered down */
+};
+
+/* Initial base clock states are mostly on */
+STATIC const struct CLK_BASE_STATES InitClkStates[] = {
+
+   /* Ethernet Clock base */
+   {CLK_BASE_PHY_TX, CLKIN_ENET_TX, true, false},
+   {CLK_BASE_PHY_RX, CLKIN_ENET_TX, true, false},
+
+   /* Clocks derived from dividers */
+   {CLK_BASE_USB0, CLKIN_IDIVD, true, true}
+};
+
+STATIC const PINMUX_GRP_T pinmuxing[] = {
+   /* Board LEDs */
+   {2, 10, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC0)},
+   {2, 11, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC0)},
+   {2, 12, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC0)},
+   {2, 0, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC4)},
+   {2, 1, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC4)},
+   {2, 2, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC4)},
+
+   /* UART 3 */
+   {2, 3, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC2)},
+   {2, 4, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC2)},
+
+   /* UART 0 */
+   {9, 5, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC2)},
+    {9, 6, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC7)},
+    {6, 2, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC7)},
+
+    /* BUTTONS */
+    {1, 0, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {1, 1, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {1, 2, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {1, 6, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+
+   /* ENET Pin mux (RMII Pins) */
+   {1, 15, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* RXD0 */
+   {1, 16, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC7)}, /* CRS_DV */
+   {1, 17, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* MDIO */
+   {1, 18, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* TXD0 */
+   {1, 19, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC0)}, /* REFCLK */
+   {1, 20, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* TXD1 */
+   {7,  7, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC6)}, /* MDC */
+   {0,  0, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC2)},  /* RXD1 */
+   {0,  1, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC6)}, /* TXEN */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Sets up system pin muxing */
+void Board_SetupMuxing(void)
+{
+   /* Setup system level pin muxing */
+   Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
+}
+
+/* Set up and initialize clocking prior to call to main */
+void Board_SetupClocking(void)
+{
+   int i;
+
+   /* Enable Flash acceleration and setup wait states */
+   Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);
+
+   /* Setup System core frequency to MAX_CLOCK_FREQ */
+   Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
+
+   /* Setup system base clocks and initial states. This won't enable and
+      disable individual clocks, but sets up the base clock sources for
+      each individual peripheral clock. */
+   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
+       Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
+                               InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
+   }
+
+   /* Reset and enable 32Khz oscillator */
+   LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
+   LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Board_SystemInit(void)
+{
+   /* Setup system clocking and memory. This is done early to allow the
+      application and tools to clear memory and use scatter loading to
+      external memory. */
+   Board_SetupMuxing();
+   Board_SetupClocking();
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/src/crp.c ./lpc_board_ciaa_edu_4337/src/crp.c
--- a_qSC69Z/lpc_board_ciaa_edu_4337/src/crp.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/src/crp.c	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,3 @@
+#define CRP_NO_CRP          0xFFFFFFFF
+
+__attribute__ ((used,section(".crp"))) const unsigned int CRP_WORD = CRP_NO_CRP ;
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/src/cr_startup_lpc43xx.c ./lpc_board_ciaa_edu_4337/src/cr_startup_lpc43xx.c
--- a_qSC69Z/lpc_board_ciaa_edu_4337/src/cr_startup_lpc43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/src/cr_startup_lpc43xx.c	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,502 @@
+//*****************************************************************************
+// LPC43xx (Cortex-M4) Microcontroller Startup code for use with LPCXpresso IDE
+//
+// Version : 140113
+//*****************************************************************************
+//
+// Copyright(C) NXP Semiconductors, 2013-2014
+// All rights reserved.
+//
+// Software that is described herein is for illustrative purposes only
+// which provides customers with programming information regarding the
+// LPC products.  This software is supplied "AS IS" without any warranties of
+// any kind, and NXP Semiconductors and its licensor disclaim any and
+// all warranties, express or implied, including all implied warranties of
+// merchantability, fitness for a particular purpose and non-infringement of
+// intellectual property rights.  NXP Semiconductors assumes no responsibility
+// or liability for the use of the software, conveys no license or rights under any
+// patent, copyright, mask work right, or any other intellectual property rights in
+// or to any products. NXP Semiconductors reserves the right to make changes
+// in the software without notification. NXP Semiconductors also makes no
+// representation or warranty that such application will be suitable for the
+// specified use without further testing or modification.
+//
+// Permission to use, copy, modify, and distribute this software and its
+// documentation is hereby granted, under NXP Semiconductors' and its
+// licensor's relevant copyrights in the software, without fee, provided that it
+// is used in conjunction with NXP Semiconductors microcontrollers.  This
+// copyright, permission, and disclaimer notice must appear in all copies of
+// this code.
+//*****************************************************************************
+
+#if defined (__cplusplus)
+#ifdef __REDLIB__
+#error Redlib does not support C++
+#else
+//*****************************************************************************
+//
+// The entry point for the C++ library startup
+//
+//*****************************************************************************
+extern "C" {
+    extern void __libc_init_array(void);
+}
+#endif
+#endif
+
+#define WEAK __attribute__ ((weak))
+#define ALIAS(f) __attribute__ ((weak, alias (#f)))
+
+//*****************************************************************************
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+//*****************************************************************************
+#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
+// Declaration of external SystemInit function
+extern void SystemInit(void);
+#endif
+
+//*****************************************************************************
+//
+// Forward declaration of the default handlers. These are aliased.
+// When the application defines a handler (with the same name), this will
+// automatically take precedence over these weak definitions
+//
+//*****************************************************************************
+void ResetISR(void);
+WEAK void NMI_Handler(void);
+WEAK void HardFault_Handler(void);
+WEAK void MemManage_Handler(void);
+WEAK void BusFault_Handler(void);
+WEAK void UsageFault_Handler(void);
+WEAK void SVC_Handler(void);
+WEAK void DebugMon_Handler(void);
+WEAK void PendSV_Handler(void);
+WEAK void SysTick_Handler(void);
+WEAK void IntDefaultHandler(void);
+
+//*****************************************************************************
+//
+// Forward declaration of the specific IRQ handlers. These are aliased
+// to the IntDefaultHandler, which is a 'forever' loop. When the application
+// defines a handler (with the same name), this will automatically take
+// precedence over these weak definitions
+//
+//*****************************************************************************
+void DAC_IRQHandler(void) ALIAS(IntDefaultHandler);
+#if defined (__USE_LPCOPEN)
+void M0APP_IRQHandler(void) ALIAS(IntDefaultHandler);
+#else
+void M0CORE_IRQHandler(void) ALIAS(IntDefaultHandler);
+#endif
+void DMA_IRQHandler(void) ALIAS(IntDefaultHandler);
+void FLASH_EEPROM_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ETH_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SDIO_IRQHandler(void) ALIAS(IntDefaultHandler);
+void LCD_IRQHandler(void) ALIAS(IntDefaultHandler);
+void USB0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void USB1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SCT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void RIT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void MCPWM_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPI_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SSP0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SSP1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2S0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2S1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPIFI_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SGPIO_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO4_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO5_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO6_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO7_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GINT0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GINT1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void EVRT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CAN1_IRQHandler(void) ALIAS(IntDefaultHandler);
+#if defined (__USE_LPCOPEN)
+void ADCHS_IRQHandler(void) ALIAS(IntDefaultHandler);
+#else
+void VADC_IRQHandler(void) ALIAS(IntDefaultHandler);
+#endif
+void ATIMER_IRQHandler(void) ALIAS(IntDefaultHandler);
+void RTC_IRQHandler(void) ALIAS(IntDefaultHandler);
+void WDT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void M0SUB_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CAN0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void QEI_IRQHandler(void) ALIAS(IntDefaultHandler);
+
+//*****************************************************************************
+//
+// The entry point for the application.
+// __main() is the entry point for Redlib based applications
+// main() is the entry point for Newlib based applications
+//
+//*****************************************************************************
+#if defined (__REDLIB__)
+extern void __main(void);
+#endif
+extern int main(void);
+//*****************************************************************************
+//
+// External declaration for the pointer to the stack top from the Linker Script
+//
+//*****************************************************************************
+extern void _vStackTop(void);
+
+//*****************************************************************************
+#if defined (__cplusplus)
+} // extern "C"
+#endif
+//*****************************************************************************
+//
+// The vector table.
+// This relies on the linker script to place at correct location in memory.
+//
+//*****************************************************************************
+extern void (* const g_pfnVectors[])(void);
+__attribute__ ((used,section(".isr_vector")))
+void (* const g_pfnVectors[])(void) = {
+    // Core Level - CM4
+    &_vStackTop,                    // The initial stack pointer
+    ResetISR,                       // The reset handler
+    NMI_Handler,                    // The NMI handler
+    HardFault_Handler,              // The hard fault handler
+    MemManage_Handler,              // The MPU fault handler
+    BusFault_Handler,               // The bus fault handler
+    UsageFault_Handler,             // The usage fault handler
+    0,                              // Reserved
+    0,                              // Reserved
+    0,                              // Reserved
+    0,                              // Reserved
+    SVC_Handler,                    // SVCall handler
+    DebugMon_Handler,               // Debug monitor handler
+    0,                              // Reserved
+    PendSV_Handler,                 // The PendSV handler
+    SysTick_Handler,                // The SysTick handler
+
+    // Chip Level - LPC43 (M4)
+    DAC_IRQHandler,           // 16
+#if defined (__USE_LPCOPEN)
+    M0APP_IRQHandler,        // 17 CortexM4/M0 (LPC43XX ONLY)
+#else
+    M0CORE_IRQHandler,        // 17
+#endif
+    DMA_IRQHandler,           // 18
+    0,           // 19
+    FLASH_EEPROM_IRQHandler,   // 20 ORed flash Bank A, flash Bank B, EEPROM interrupts
+    ETH_IRQHandler,           // 21
+    SDIO_IRQHandler,          // 22
+    LCD_IRQHandler,           // 23
+    USB0_IRQHandler,          // 24
+    USB1_IRQHandler,          // 25
+    SCT_IRQHandler,           // 26
+    RIT_IRQHandler,           // 27
+    TIMER0_IRQHandler,        // 28
+    TIMER1_IRQHandler,        // 29
+    TIMER2_IRQHandler,        // 30
+    TIMER3_IRQHandler,        // 31
+    MCPWM_IRQHandler,         // 32
+    ADC0_IRQHandler,          // 33
+    I2C0_IRQHandler,          // 34
+    I2C1_IRQHandler,          // 35
+    SPI_IRQHandler,           // 36
+    ADC1_IRQHandler,          // 37
+    SSP0_IRQHandler,          // 38
+    SSP1_IRQHandler,          // 39
+    UART0_IRQHandler,         // 40
+    UART1_IRQHandler,         // 41
+    UART2_IRQHandler,         // 42
+    UART3_IRQHandler,         // 43
+    I2S0_IRQHandler,          // 44
+    I2S1_IRQHandler,          // 45
+    SPIFI_IRQHandler,         // 46
+    SGPIO_IRQHandler,         // 47
+    GPIO0_IRQHandler,         // 48
+    GPIO1_IRQHandler,         // 49
+    GPIO2_IRQHandler,         // 50
+    GPIO3_IRQHandler,         // 51
+    GPIO4_IRQHandler,         // 52
+    GPIO5_IRQHandler,         // 53
+    GPIO6_IRQHandler,         // 54
+    GPIO7_IRQHandler,         // 55
+    GINT0_IRQHandler,         // 56
+    GINT1_IRQHandler,         // 57
+    EVRT_IRQHandler,          // 58
+    CAN1_IRQHandler,          // 59
+    0,                        // 60
+#if defined (__USE_LPCOPEN)
+    ADCHS_IRQHandler,         // 61 ADCHS combined interrupt
+#else
+    VADC_IRQHandler,          // 61
+#endif
+    ATIMER_IRQHandler,        // 62
+    RTC_IRQHandler,           // 63
+    0,                        // 64
+    WDT_IRQHandler,           // 65
+    M0SUB_IRQHandler,         // 66
+    CAN0_IRQHandler,          // 67
+    QEI_IRQHandler,           // 68
+};
+
+
+//*****************************************************************************
+// Functions to carry out the initialization of RW and BSS data sections. These
+// are written as separate functions rather than being inlined within the
+// ResetISR() function in order to cope with MCUs with multiple banks of
+// memory.
+//*****************************************************************************
+        __attribute__((section(".after_vectors"
+)))
+void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
+    unsigned int *pulDest = (unsigned int*) start;
+    unsigned int *pulSrc = (unsigned int*) romstart;
+    unsigned int loop;
+    for (loop = 0; loop < len; loop = loop + 4)
+        *pulDest++ = *pulSrc++;
+}
+
+__attribute__ ((section(".after_vectors")))
+void bss_init(unsigned int start, unsigned int len) {
+    unsigned int *pulDest = (unsigned int*) start;
+    unsigned int loop;
+    for (loop = 0; loop < len; loop = loop + 4)
+        *pulDest++ = 0;
+}
+
+//*****************************************************************************
+// The following symbols are constructs generated by the linker, indicating
+// the location of various points in the "Global Section Table". This table is
+// created by the linker via the Code Red managed linker script mechanism. It
+// contains the load address, execution address and length of each RW data
+// section and the execution and length of each BSS (zero initialized) section.
+//*****************************************************************************
+extern unsigned int __data_section_table;
+extern unsigned int __data_section_table_end;
+extern unsigned int __bss_section_table;
+extern unsigned int __bss_section_table_end;
+
+//*****************************************************************************
+// Reset entry point for your code.
+// Sets up a simple runtime environment and initializes the C/C++
+// library.
+//
+//*****************************************************************************
+void ResetISR(void) {
+
+// *************************************************************
+// The following conditional block of code manually resets as
+// much of the peripheral set of the LPC43 as possible. This is
+// done because the LPC43 does not provide a means of triggering
+// a full system reset under debugger control, which can cause
+// problems in certain circumstances when debugging.
+//
+// You can prevent this code block being included if you require
+// (for example when creating a final executable which you will
+// not debug) by setting the define 'DONT_RESET_ON_RESTART'.
+//
+#ifndef DONT_RESET_ON_RESTART
+
+    // Disable interrupts
+    __asm volatile ("cpsid i");
+    // equivalent to CMSIS '__disable_irq()' function
+
+    unsigned int *RESET_CONTROL = (unsigned int *) 0x40053100;
+    // LPC_RGU->RESET_CTRL0 @ 0x40053100
+    // LPC_RGU->RESET_CTRL1 @ 0x40053104
+    // Note that we do not use the CMSIS register access mechanism,
+    // as there is no guarantee that the project has been configured
+    // to use CMSIS.
+
+    // Write to LPC_RGU->RESET_CTRL0
+    *(RESET_CONTROL + 0) = 0x10DF1000;
+    // GPIO_RST|AES_RST|ETHERNET_RST|SDIO_RST|DMA_RST|
+    // USB1_RST|USB0_RST|LCD_RST|M0_SUB_RST
+
+    // Write to LPC_RGU->RESET_CTRL1
+    *(RESET_CONTROL + 1) = 0x01DFF7FF;
+    // M0APP_RST|CAN0_RST|CAN1_RST|I2S_RST|SSP1_RST|SSP0_RST|
+    // I2C1_RST|I2C0_RST|UART3_RST|UART1_RST|UART1_RST|UART0_RST|
+    // DAC_RST|ADC1_RST|ADC0_RST|QEI_RST|MOTOCONPWM_RST|SCT_RST|
+    // RITIMER_RST|TIMER3_RST|TIMER2_RST|TIMER1_RST|TIMER0_RST
+
+    // Clear all pending interrupts in the NVIC
+    volatile unsigned int *NVIC_ICPR = (unsigned int *) 0xE000E280;
+    unsigned int irqpendloop;
+    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
+        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
+    }
+
+    // Reenable interrupts
+    __asm volatile ("cpsie i");
+    // equivalent to CMSIS '__enable_irq()' function
+
+#endif  // ifndef DONT_RESET_ON_RESTART
+// *************************************************************
+
+#if defined (__USE_LPCOPEN)
+    SystemInit();
+#endif
+
+    //
+    // Copy the data sections from flash to SRAM.
+    //
+    unsigned int LoadAddr, ExeAddr, SectionLen;
+    unsigned int *SectionTableAddr;
+
+    // Load base address of Global Section Table
+    SectionTableAddr = &__data_section_table;
+
+    // Copy the data sections from flash to SRAM.
+    while (SectionTableAddr < &__data_section_table_end) {
+        LoadAddr = *SectionTableAddr++;
+        ExeAddr = *SectionTableAddr++;
+        SectionLen = *SectionTableAddr++;
+        data_init(LoadAddr, ExeAddr, SectionLen);
+    }
+    // At this point, SectionTableAddr = &__bss_section_table;
+    // Zero fill the bss segment
+    while (SectionTableAddr < &__bss_section_table_end) {
+        ExeAddr = *SectionTableAddr++;
+        SectionLen = *SectionTableAddr++;
+        bss_init(ExeAddr, SectionLen);
+    }
+
+#if !defined (__USE_LPCOPEN)
+// LPCOpen init code deals with FP and VTOR initialisation
+#if defined (__VFP_FP__) && !defined (__SOFTFP__)
+    /*
+     * Code to enable the Cortex-M4 FPU only included
+     * if appropriate build options have been selected.
+     * Code taken from Section 7.1, Cortex-M4 TRM (DDI0439C)
+     */
+    // CPACR is located at address 0xE000ED88
+    asm("LDR.W R0, =0xE000ED88");
+    // Read CPACR
+    asm("LDR R1, [R0]");
+    // Set bits 20-23 to enable CP10 and CP11 coprocessors
+    asm(" ORR R1, R1, #(0xF << 20)");
+    // Write back the modified value to the CPACR
+    asm("STR R1, [R0]");
+#endif // (__VFP_FP__) && !(__SOFTFP__)
+    // ******************************
+    // Check to see if we are running the code from a non-zero
+    // address (eg RAM, external flash), in which case we need
+    // to modify the VTOR register to tell the CPU that the
+    // vector table is located at a non-0x0 address.
+
+    // Note that we do not use the CMSIS register access mechanism,
+    // as there is no guarantee that the project has been configured
+    // to use CMSIS.
+    unsigned int * pSCB_VTOR = (unsigned int *) 0xE000ED08;
+    if ((unsigned int *) g_pfnVectors != (unsigned int *) 0x00000000) {
+        // CMSIS : SCB->VTOR = <address of vector table>
+        *pSCB_VTOR = (unsigned int) g_pfnVectors;
+    }
+#endif
+
+#if defined (__USE_CMSIS)
+    SystemInit();
+#endif
+
+#if defined (__cplusplus)
+    //
+    // Call C++ library initialisation
+    //
+    __libc_init_array();
+#endif
+
+#if defined (__REDLIB__)
+    // Call the Redlib library, which in turn calls main()
+    __main();
+#else
+    main();
+#endif
+
+    //
+    // main() shouldn't return, but if it does, we'll just enter an infinite loop
+    //
+    while (1) {
+        ;
+    }
+}
+
+//*****************************************************************************
+// Default exception handlers. Override the ones here by defining your own
+// handler routines in your application code.
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void NMI_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void HardFault_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void MemManage_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void BusFault_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void UsageFault_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void SVC_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void DebugMon_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void PendSV_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void SysTick_Handler(void) {
+    while (1) {
+    }
+}
+
+//*****************************************************************************
+//
+// Processor ends up here if an unexpected interrupt occurs or a specific
+// handler is not present in the application code.
+//
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void IntDefaultHandler(void) {
+    while (1) {
+    }
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/src/sysinit.c ./lpc_board_ciaa_edu_4337/src/sysinit.c
--- a_qSC69Z/lpc_board_ciaa_edu_4337/src/sysinit.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/src/sysinit.c	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,89 @@
+/*
+ * @brief Common SystemInit function for LPC18xx/LPC43xx chips
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+#if defined(NO_BOARD_LIB)
+#include "chip.h"
+const uint32_t ExtRateIn = 0;
+const uint32_t OscRateIn = 12000000;
+#else
+#include "board.h"
+#endif
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set up and initialize hardware prior to call to main */
+void SystemInit(void)
+{
+#if defined(CORE_M3) || defined(CORE_M4)
+   unsigned int *pSCB_VTOR = (unsigned int *) 0xE000ED08;
+
+#if defined(__IAR_SYSTEMS_ICC__)
+   extern void *__vector_table;
+
+   *pSCB_VTOR = (unsigned int) &__vector_table;
+#elif defined(__CODE_RED)
+   extern void *g_pfnVectors;
+
+   *pSCB_VTOR = (unsigned int) &g_pfnVectors;
+#elif defined(__ARMCC_VERSION)
+   extern void *__Vectors;
+
+   *pSCB_VTOR = (unsigned int) &__Vectors;
+#endif
+
+#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
+   fpuInit();
+#endif
+
+#if defined(NO_BOARD_LIB)
+   /* Chip specific SystemInit */
+   Chip_SystemInit();
+#else
+   /* Board specific SystemInit */
+   Board_SystemInit();
+#endif
+
+#endif /* defined(CORE_M3) || defined(CORE_M4) */
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_board_ciaa_edu_4337/src/system.c ./lpc_board_ciaa_edu_4337/src/system.c
--- a_qSC69Z/lpc_board_ciaa_edu_4337/src/system.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_board_ciaa_edu_4337/src/system.c	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,190 @@
+#include <reent.h>
+#include <errno.h>
+#include <signal.h>
+
+#include <board.h>
+
+#define UNUSED(...) ((void) (__VA_ARGS__))
+#define SET_ERR(e) (r->_errno = e)
+
+void _exit(int code) {
+   register int __params__ __asm__("r0") = code;
+   while (1)
+       __asm__ __volatile__("bkpt 0");
+}
+
+int _close_r(struct _reent *r, int fd) {
+   UNUSED(fd);
+   SET_ERR(EBADF);
+   return -1;
+}
+
+int _execve_r(struct _reent *r, const char *f, char * const *args,
+       char * const *env) {
+   UNUSED(f, args, env);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _fcntl_r(struct _reent *r, int fd, int cmd, int arg) {
+   UNUSED(fd, cmd, arg);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _fork_r(struct _reent *r) {
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _fstat_r(struct _reent *r, int fd, struct stat *st) {
+   UNUSED(fd, st);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _getpid_r(struct _reent *r) {
+   UNUSED(r);
+   return 1;
+}
+
+int _isatty_r(struct _reent *r, int fd) {
+   switch (fd) {
+   case 0:
+   case 1:
+   case 2:
+       return 1;
+   default:
+       SET_ERR(EBADF);
+       return -1;
+   }
+}
+
+int _kill_r(struct _reent *r, int pid, int signal) {
+   if (pid == _getpid_r(r)) {
+       switch (signal) {
+       case SIGHUP:
+       case SIGINT:
+       case SIGQUIT:
+       case SIGILL:
+       case SIGTRAP:
+       case SIGEMT:
+       case SIGFPE:
+       case SIGKILL:
+       case SIGBUS:
+       case SIGSEGV:
+       case SIGSYS:
+       case SIGPIPE:
+       case SIGALRM:
+       case SIGTERM:
+       default:
+           _exit(0);
+       }
+   } else {
+       SET_ERR(ECHILD);
+   }
+   return -1;
+}
+
+int _link_r(struct _reent *r, const char *oldf, const char *newf) {
+   UNUSED(oldf, newf);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+_off_t _lseek_r(struct _reent *r, int fd, _off_t off, int w) {
+   UNUSED(fd, off, w);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _mkdir_r(struct _reent *r, const char *name, int m) {
+   UNUSED(name, m);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _open_r(struct _reent *r, const char *name, int f, int m) {
+   UNUSED(name, f, m);
+   SET_ERR(EBADF);
+   return -1;
+}
+
+_ssize_t _read_r(struct _reent *r, int fd, void *b, size_t n) {
+   size_t i;
+   switch (fd) {
+   case 0:
+   case 1:
+   case 2:
+       for (i = 0; i < n; i++)
+           ((char*) b)[i] = Board_UARTGetChar();
+       return n;
+   default:
+       SET_ERR(ENODEV);
+       return -1;
+   }
+}
+
+int _rename_r(struct _reent *r, const char *oldf, const char *newf) {
+   UNUSED(oldf, newf);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+void *_sbrk_r(struct _reent *r, ptrdiff_t incr) {
+   extern int _pvHeapStart;
+   static void *heap_end;
+   void *prev_heap_end;
+   if (heap_end == 0) {
+       heap_end = &_pvHeapStart;
+   }
+   prev_heap_end = heap_end;
+   heap_end += incr;
+   return prev_heap_end;
+}
+
+int _stat_r(struct _reent *r, const char *name, struct stat *s) {
+   UNUSED(name, s);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+_CLOCK_T_ _times_r(struct _reent *r, struct tms *tm) {
+   UNUSED(tm);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _unlink_r(struct _reent *r, const char *name) {
+   UNUSED(name);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _wait_r(struct _reent *r, int *st) {
+   UNUSED(st);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+_ssize_t _write_r(struct _reent *r, int fd, const void *b, size_t n) {
+   size_t i;
+   switch (fd) {
+   case 0:
+   case 1:
+   case 2:
+       for (i = 0; i < n; i++)
+           Board_UARTPutChar(((char*) b)[i]);
+       return n;
+   default:
+       SET_ERR(ENODEV);
+       return -1;
+   }
+}
+
+/* This one is not guaranteed to be available on all targets.  */
+int _gettimeofday_r(struct _reent *r, struct timeval *__tp, void *__tzp) {
+   UNUSED(__tp, __tzp);
+   SET_ERR(ENOSYS);
+   return -1;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/adc_18xx_43xx.h ./lpc_chip_43xx/inc/adc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/adc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/adc_18xx_43xx.h	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,268 @@
+/*
+ * @brief  LPC18xx/43xx A/D conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ADC_18XX_43XX_H_
+#define __ADC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ADC_18XX_43XX CHIP:  LPC18xx/43xx A/D conversion driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define ADC_ACC_10BITS
+
+#define ADC_MAX_SAMPLE_RATE 400000
+
+/**
+ * @brief 10 or 12-bit ADC register block structure
+ */
+typedef struct {                   /*!< ADCn Structure */
+   __IO uint32_t CR;               /*!< A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur. */
+   __I  uint32_t GDR;              /*!< A/D Global Data Register. Contains the result of the most recent A/D conversion. */
+   __I  uint32_t RESERVED0;
+   __IO uint32_t INTEN;            /*!< A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt. */
+   __I  uint32_t DR[8];            /*!< A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel n. */
+   __I  uint32_t STAT;             /*!< A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag. */
+} LPC_ADC_T;
+
+/**
+ * @brief ADC register support bitfields and mask
+ */
+
+#define ADC_DR_RESULT(n)        ((((n) >> 6) & 0x3FF)) /*!< Mask for getting the 10 bits ADC data read value */
+#define ADC_CR_BITACC(n)        ((((n) & 0x7) << 17))  /*!< Number of ADC accuracy bits */
+#define ADC_DR_DONE(n)          (((n) >> 31))          /*!< Mask for reading the ADC done status */
+#define ADC_DR_OVERRUN(n)       ((((n) >> 30) & (1UL)))    /*!< Mask for reading the ADC overrun status */
+#define ADC_CR_CH_SEL(n)        ((1UL << (n)))         /*!< Selects which of the AD0.0:7 pins is (are) to be sampled and converted */
+#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 8))  /*!< The APB clock (PCLK) is divided by (this value plus one) to produce the clock for the A/D */
+#define ADC_CR_BURST            ((1UL << 16))          /*!< Repeated conversions A/D enable bit */
+#define ADC_CR_PDN              ((1UL << 21))          /*!< ADC convert is operational */
+#define ADC_CR_START_MASK       ((7UL << 24))          /*!< ADC start mask bits */
+#define ADC_CR_START_MODE_SEL(SEL)  ((SEL << 24))      /*!< Select Start Mode */
+#define ADC_CR_START_NOW        ((1UL << 24))          /*!< Start conversion now */
+#define ADC_CR_START_CTOUT15    ((2UL << 24))          /*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_15 */
+#define ADC_CR_START_CTOUT8     ((3UL << 24))          /*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_8 */
+#define ADC_CR_START_ADCTRIG0   ((4UL << 24))          /*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG0 */
+#define ADC_CR_START_ADCTRIG1   ((5UL << 24))          /*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG1 */
+#define ADC_CR_START_MCOA2      ((6UL << 24))          /*!< Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2 */
+#define ADC_CR_EDGE             ((1UL << 27))          /*!< Start conversion on a falling edge on the selected CAP/MAT signal */
+#define ADC_SAMPLE_RATE_CONFIG_MASK         (ADC_CR_CLKDIV(0xFF) | ADC_CR_BITACC(0x07))
+
+/**
+ * @brief  ADC status register used for IP drivers
+ */
+typedef enum IP_ADC_STATUS {
+   ADC_DR_DONE_STAT,   /*!< ADC data register staus */
+   ADC_DR_OVERRUN_STAT,/*!< ADC data overrun staus */
+   ADC_DR_ADINT_STAT   /*!< ADC interrupt status */
+} ADC_STATUS_T;
+
+/** The channels on one ADC peripheral*/
+typedef enum CHIP_ADC_CHANNEL {
+   ADC_CH0 = 0,    /**< ADC channel 0 */
+   ADC_CH1,        /**< ADC channel 1 */
+   ADC_CH2,        /**< ADC channel 2 */
+   ADC_CH3,        /**< ADC channel 3 */
+   ADC_CH4,        /**< ADC channel 4 */
+   ADC_CH5,        /**< ADC channel 5 */
+   ADC_CH6,        /**< ADC channel 6 */
+   ADC_CH7,        /**< ADC channel 7 */
+} ADC_CHANNEL_T;
+
+/** The number of bits of accuracy of the result in the LS bits of ADDR*/
+typedef enum CHIP_ADC_RESOLUTION {
+   ADC_10BITS = 0,     /**< ADC 10 bits */
+   ADC_9BITS,          /**< ADC 9 bits  */
+   ADC_8BITS,          /**< ADC 8 bits  */
+   ADC_7BITS,          /**< ADC 7 bits  */
+   ADC_6BITS,          /**< ADC 6 bits  */
+   ADC_5BITS,          /**< ADC 5 bits  */
+   ADC_4BITS,          /**< ADC 4 bits  */
+   ADC_3BITS,          /**< ADC 3 bits  */
+} ADC_RESOLUTION_T;
+
+/** Edge configuration, which controls rising or falling edge on the selected signal for the start of a conversion */
+typedef enum CHIP_ADC_EDGE_CFG {
+   ADC_TRIGGERMODE_RISING = 0,     /**< Trigger event: rising edge */
+   ADC_TRIGGERMODE_FALLING,        /**< Trigger event: falling edge */
+} ADC_EDGE_CFG_T;
+
+/** Start mode, which controls the start of an A/D conversion when the BURST bit is 0. */
+typedef enum CHIP_ADC_START_MODE {
+   ADC_NO_START = 0,
+   ADC_START_NOW,          /*!< Start conversion now */
+   ADC_START_ON_CTOUT15,   /*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_15 */
+   ADC_START_ON_CTOUT8,    /*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_8 */
+   ADC_START_ON_ADCTRIG0,  /*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG0 */
+   ADC_START_ON_ADCTRIG1,  /*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG1 */
+   ADC_START_ON_MCOA2      /*!< Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2 */
+} ADC_START_MODE_T;
+
+/** Clock setup structure for ADC controller passed to the initialize function */
+typedef struct {
+   uint32_t adcRate;       /*!< ADC rate */
+   uint8_t  bitsAccuracy;  /*!< ADC bit accuracy */
+   bool     burstMode;     /*!< ADC Burt Mode */
+} ADC_CLOCK_SETUP_T;
+
+/**
+ * @brief  Initialize the ADC peripheral and the ADC setup structure to default value
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  ADCSetup    : ADC setup structure to be set
+ * @return Nothing
+ * @note   Default setting for ADC is 400kHz - 10bits
+ */
+void Chip_ADC_Init(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup);
+
+/**
+ * @brief  Shutdown ADC
+ * @param  pADC    : The base of ADC peripheral on the chip
+ * @return Nothing
+ */
+void Chip_ADC_DeInit(LPC_ADC_T *pADC);
+
+/**
+ * @brief  Read the ADC value from a channel
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  channel     : ADC channel to read
+ * @param  data        : Pointer to where to put data
+ * @return SUCCESS or ERROR if no conversion is ready
+ */
+Status Chip_ADC_ReadValue(LPC_ADC_T *pADC, uint8_t channel, uint16_t *data);
+
+/**
+ * @brief  Read the ADC value and convert it to 8bits value
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  channel:    selected channel
+ * @param  data        : Storage for data
+ * @return Status  : ERROR or SUCCESS
+ */
+Status Chip_ADC_ReadByte(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, uint8_t *data);
+
+/**
+ * @brief  Read the ADC channel status
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  channel     : ADC channel to read
+ * @param  StatusType  : Status type of ADC_DR_*
+ * @return SET or RESET
+ */
+FlagStatus Chip_ADC_ReadStatus(LPC_ADC_T *pADC, uint8_t channel, uint32_t StatusType);
+
+/**
+ * @brief  Enable/Disable interrupt for ADC channel
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  channel     : ADC channel to read
+ * @param  NewState    : New state, ENABLE or DISABLE
+ * @return SET or RESET
+ */
+void Chip_ADC_Int_SetChannelCmd(LPC_ADC_T *pADC, uint8_t channel, FunctionalState NewState);
+
+/**
+ * @brief  Enable/Disable global interrupt for ADC channel
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  NewState    : New state, ENABLE or DISABLE
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ADC_Int_SetGlobalCmd(LPC_ADC_T *pADC, FunctionalState NewState)
+{
+   Chip_ADC_Int_SetChannelCmd(pADC, 8, NewState);
+}
+
+/**
+ * @brief  Select the mode starting the AD conversion
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  mode        : Stating mode, should be :
+ *                         - ADC_NO_START              : Must be set for Burst mode
+ *                         - ADC_START_NOW             : Start conversion now
+ *                         - ADC_START_ON_CTOUT15      : Start conversion when the edge selected by bit 27 occurs on CTOUT_15
+ *                         - ADC_START_ON_CTOUT8       : Start conversion when the edge selected by bit 27 occurs on CTOUT_8
+ *                         - ADC_START_ON_ADCTRIG0     : Start conversion when the edge selected by bit 27 occurs on ADCTRIG0
+ *                         - ADC_START_ON_ADCTRIG1     : Start conversion when the edge selected by bit 27 occurs on ADCTRIG1
+ *                         - ADC_START_ON_MCOA2        : Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2
+ * @param  EdgeOption  : Stating Edge Condition, should be :
+ *                         - ADC_TRIGGERMODE_RISING    : Trigger event on rising edge
+ *                         - ADC_TRIGGERMODE_FALLING   : Trigger event on falling edge
+ * @return Nothing
+ */
+void Chip_ADC_SetStartMode(LPC_ADC_T *pADC, ADC_START_MODE_T mode, ADC_EDGE_CFG_T EdgeOption);
+
+/**
+ * @brief  Set the ADC Sample rate
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  ADCSetup    : ADC setup structure to be modified
+ * @param  rate        : Sample rate, should be set so the clock for A/D converter is less than or equal to 4.5MHz.
+ * @return Nothing
+ */
+void Chip_ADC_SetSampleRate(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, uint32_t rate);
+
+/**
+ * @brief  Set the ADC accuracy bits
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  ADCSetup    : ADC setup structure to be modified
+ * @param  resolution  : The resolution, should be ADC_10BITS -> ADC_3BITS
+ * @return Nothing
+ */
+void Chip_ADC_SetResolution(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, ADC_RESOLUTION_T resolution);
+
+/**
+ * @brief  Enable or disable the ADC channel on ADC peripheral
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  channel     : Channel to be enable or disable
+ * @param  NewState    : New state, should be:
+ *                             - ENABLE
+ *                             - DISABLE
+ * @return Nothing
+ */
+void Chip_ADC_EnableChannel(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, FunctionalState NewState);
+
+/**
+ * @brief  Enable burst mode
+ * @param  pADC        : The base of ADC peripheral on the chip
+ * @param  NewState    : New state, should be:
+ *                         - ENABLE
+ *                         - DISABLE
+ * @return Nothing
+ */
+void Chip_ADC_SetBurstCmd(LPC_ADC_T *pADC, FunctionalState NewState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ADC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/aes_18xx_43xx.h ./lpc_chip_43xx/inc/aes_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/aes_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/aes_18xx_43xx.h	2018-01-19 23:55:10.956318237 -0300
@@ -0,0 +1,161 @@
+/*
+ * @brief LPC18xx/43xx AES Engine driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __AES_18XX_43XX_H_
+#define __AES_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup AES_18XX_43XX CHIP: LPC18xx/43xx AES Engine driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief  AES Engine operation mode
+ */
+typedef enum CHIP_AES_OP_MODE {
+   CHIP_AES_API_CMD_ENCODE_ECB,    /*!< ECB Encode mode */
+   CHIP_AES_API_CMD_DECODE_ECB,    /*!< ECB Decode mode */
+   CHIP_AES_API_CMD_ENCODE_CBC,    /*!< CBC Encode mode */
+   CHIP_AES_API_CMD_DECODE_CBC,    /*!< CBC Decode mode */
+} CHIP_AES_OP_MODE_T;
+
+/**
+ * @brief  Initialize the AES Engine function
+ * @return None
+ * This function will initialize all the AES Engine driver function pointers
+ * and call the AES Engine Initialization function.
+ */
+void Chip_AES_Init(void);
+
+/**
+ * @brief  Set operation mode in AES Engine
+ * @param  AesMode     : AES Operation Mode
+ * @return Status
+ */
+uint32_t Chip_AES_SetMode(CHIP_AES_OP_MODE_T AesMode);
+
+/**
+ * @brief  Load 128-bit AES user key in AES Engine
+ * @param  keyNum: 0 - Load AES 128-bit user key 1, else load user key2
+ * @return None
+ */
+void Chip_AES_LoadKey(uint32_t keyNum);
+
+/**
+ * @brief  Load randomly generated key in AES engine
+ * @return None
+ * To update the RNG and load a new random number,
+ * the API call Chip_OTP_GenRand should be used
+ */
+void Chip_AES_LoadKeyRNG(void);
+
+/**
+ * @brief  Load 128-bit AES software defined user key in AES Engine
+ * @param  pKey        : Pointer to 16 byte user key
+ * @return None
+ */
+void Chip_AES_LoadKeySW(uint8_t *pKey);
+
+/**
+ * @brief Load 128-bit AES initialization vector in AES Engine
+ * @param  pVector     : Pointer to 16 byte Initialisation vector
+ * @return None
+ */
+void Chip_AES_LoadIV_SW(uint8_t *pVector);
+
+/**
+ * @brief Load IC specific 128-bit AES initialization vector in AES Engine
+ * @return None
+ * This loads 128-bit AES IC specific initialization vector,
+ * which is used to decrypt a boot image
+ */
+void Chip_AES_LoadIV_IC(void);
+
+/**
+ * @brief Operate AES Engine
+ * @param  pDatOut     : Pointer to output data stream
+ * @param  pDatIn      : Pointer to input data stream
+ * @param  Size        : Size of the data stream (128-bit)
+ * @return Status
+ * This function performs the AES operation after the AES mode
+ * has been set using Chip_AES_SetMode and the appropriate keys
+ * and init vectors have been loaded
+ */
+uint32_t Chip_AES_Operate(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t Size);
+
+/**
+ * @brief  Program 128-bit AES Key in OTP
+ * @param  KeyNum      : Key Number (Select 0 or 1)
+ * @param  pKey        : Pointer to AES Key (16 bytes required)
+ * @return Status
+ * When calling the aes_ProgramKey2 function, ensure that VPP = 2.7 V to 3.6 V.
+ */
+uint32_t Chip_AES_ProgramKey(uint32_t KeyNum, uint8_t *pKey);
+
+/**
+ * @brief  Checks for valid AES configuration of the chip and setup
+ *         DMA channel to process an AES data block.
+ * @param  channel_id  : channel id
+ * @return Status
+ */
+uint32_t Chip_AES_Config_DMA(uint32_t channel_id);
+
+/**
+ * @brief  Checks for valid AES configuration of the chip and
+ *         enables DMA channel to process an AES data block.
+ * @param  channel_id  : channel_id
+ * @param  dataOutAddr : destination address(16 x size of consecutive bytes)
+ * @param  dataInAddr  : source address(16 x size of consecutive bytes)
+ * @param  size        : number of 128 bit AES blocks
+ * @return Status
+ */
+uint32_t Chip_AES_OperateDMA(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size);
+
+/**
+ * @brief  Read status of DMA channels that process an AES data block.
+ * @param  channel_id  : channel id
+ * @return Status
+ */
+ uint32_t Chip_AES_GetStatusDMA(uint32_t channel_id);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __AES_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/atimer_18xx_43xx.h ./lpc_chip_43xx/inc/atimer_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/atimer_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/atimer_18xx_43xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,143 @@
+/*
+ * @brief LPC18xx/43xx Alarm Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ATIMER_18XX_43XX_H_
+#define __ATIMER_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ATIMER_18XX_43XX CHIP: LPC18xx/43xx Alarm Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Alarm Timer register block structure
+ */
+typedef struct {                   /*!< ATIMER Structure       */
+   __IO uint32_t DOWNCOUNTER;      /*!< Downcounter register   */
+   __IO uint32_t PRESET;           /*!< Preset value register  */
+   __I  uint32_t RESERVED0[1012];
+   __O  uint32_t CLR_EN;           /*!< Interrupt clear enable register */
+   __O  uint32_t SET_EN;           /*!< Interrupt set enable register */
+   __I  uint32_t STATUS;           /*!< Status register        */
+   __I  uint32_t ENABLE;           /*!< Enable register        */
+   __O  uint32_t CLR_STAT;         /*!< Clear register         */
+   __O  uint32_t SET_STAT;         /*!< Set register           */
+} LPC_ATIMER_T;
+
+/**
+ * @brief  Initialize Alarm Timer
+ * @param  pATIMER     : The base of ATIMER peripheral on the chip
+ * @param  PresetValue : Count of 1 to 1024s for Alarm
+ * @return None
+ */
+void Chip_ATIMER_Init(LPC_ATIMER_T *pATIMER, uint32_t PresetValue);
+
+/**
+ * @brief  Close ATIMER device
+ * @param  pATIMER : The base of ATIMER peripheral on the chip
+ * @return None
+ */
+void Chip_ATIMER_DeInit(LPC_ATIMER_T *pATIMER);
+
+/**
+ * @brief  Enable ATIMER Interrupt
+ * @param  pATIMER : The base of ATIMER peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_ATIMER_IntEnable(LPC_ATIMER_T *pATIMER)
+{
+   pATIMER->SET_EN = 1;
+}
+
+/**
+ * @brief  Disable ATIMER Interrupt
+ * @param  pATIMER : The base of ATIMER peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_ATIMER_IntDisable(LPC_ATIMER_T *pATIMER)
+{
+   pATIMER->CLR_EN = 1;
+}
+
+/**
+ * @brief  Clear ATIMER Interrupt Status
+ * @param  pATIMER : The base of ATIMER peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_ATIMER_ClearIntStatus(LPC_ATIMER_T *pATIMER)
+{
+   pATIMER->CLR_STAT = 1;
+}
+
+/**
+ * @brief  Set ATIMER Interrupt Status
+ * @param  pATIMER : The base of ATIMER peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_ATIMER_SetIntStatus(LPC_ATIMER_T *pATIMER)
+{
+   pATIMER->SET_STAT = 1;
+}
+
+/**
+ * @brief  Update Preset value
+ * @param  pATIMER     : The base of ATIMER peripheral on the chip
+ * @param  PresetValue : updated preset value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ATIMER_UpdatePresetValue(LPC_ATIMER_T *pATIMER, uint32_t PresetValue)
+{
+   pATIMER->PRESET = PresetValue;
+}
+
+/**
+ * @brief  Read value of preset register
+ * @param  pATIMER : The base of ATIMER peripheral on the chip
+ * @return Value of capture register
+ */
+STATIC INLINE uint32_t Chip_ATIMER_GetPresetValue(LPC_ATIMER_T *pATIMER)
+{
+   return pATIMER->PRESET;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ATIMER_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/ccan_18xx_43xx.h ./lpc_chip_43xx/inc/ccan_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/ccan_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/ccan_18xx_43xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,505 @@
+/*
+ * @brief LPC18xx/43xx CCAN driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CCAN_18XX_43XX_H_
+#define __CCAN_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CCAN_18XX_43XX CHIP: LPC18xx/43xx CCAN driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief CCAN message interface register block structure
+ */
+typedef struct {   /*!< C_CAN message interface Structure       */
+   __IO uint32_t CMDREQ;           /*!< Message interface command request  */
+   __IO uint32_t CMDMSK;           /*!< Message interface command mask*/
+   __IO uint32_t MSK1;             /*!< Message interface mask 1 */
+   __IO uint32_t MSK2;             /*!< Message interface mask 2 */
+   __IO uint32_t ARB1;             /*!< Message interface arbitration 1 */
+   __IO uint32_t ARB2;             /*!< Message interface arbitration 2 */
+   __IO uint32_t MCTRL;            /*!< Message interface message control */
+   __IO uint32_t DA1;              /*!< Message interface data A1 */
+   __IO uint32_t DA2;              /*!< Message interface data A2 */
+   __IO uint32_t DB1;              /*!< Message interface data B1 */
+   __IO uint32_t DB2;              /*!< Message interface data B2 */
+   __I  uint32_t  RESERVED[13];
+} CCAN_IF_T;
+
+/**
+ * @brief CCAN Controller Area Network register block structure
+ */
+typedef struct {                       /*!< C_CAN Structure       */
+   __IO uint32_t CNTL;                 /*!< CAN control            */
+   __IO uint32_t STAT;                 /*!< Status register        */
+   __I  uint32_t EC;                   /*!< Error counter          */
+   __IO uint32_t BT;                   /*!< Bit timing register    */
+   __I  uint32_t INT;                  /*!< Interrupt register     */
+   __IO uint32_t TEST;                 /*!< Test register          */
+   __IO uint32_t BRPE;                 /*!< Baud rate prescaler extension register */
+   __I  uint32_t  RESERVED0;
+   CCAN_IF_T IF[2];
+   __I  uint32_t  RESERVED2[8];
+   __I  uint32_t TXREQ1;               /*!< Transmission request 1 */
+   __I  uint32_t TXREQ2;               /*!< Transmission request 2 */
+   __I  uint32_t  RESERVED3[6];
+   __I  uint32_t ND1;                  /*!< New data 1             */
+   __I  uint32_t ND2;                  /*!< New data 2             */
+   __I  uint32_t  RESERVED4[6];
+   __I  uint32_t IR1;                  /*!< Interrupt pending 1    */
+   __I  uint32_t IR2;                  /*!< Interrupt pending 2    */
+   __I  uint32_t  RESERVED5[6];
+   __I  uint32_t MSGV1;                /*!< Message valid 1        */
+   __I  uint32_t MSGV2;                /*!< Message valid 2        */
+   __I  uint32_t  RESERVED6[6];
+   __IO uint32_t CLKDIV;               /*!< CAN clock divider register */
+} LPC_CCAN_T;
+
+/* CCAN Control register bit definitions */
+#define CCAN_CTRL_INIT      (1 << 0)   /*!< Initialization is started. */
+#define CCAN_CTRL_IE        (1 << 1)   /*!< Module Interupt Enable. */
+#define CCAN_CTRL_SIE       (1 << 2)   /*!< Status Change Interupt Enable. */
+#define CCAN_CTRL_EIE       (1 << 3)   /*!< Error Interupt Enable. */
+#define CCAN_CTRL_DAR       (1 << 5)   /*!< Automatic retransmission disabled. */
+#define CCAN_CTRL_CCE       (1 << 6)   /*!< The CPU has write access to the CANBT register while the INIT bit is one.*/
+#define CCAN_CTRL_TEST      (1 << 7)   /*!< Test mode. */
+
+/* CCAN STAT register bit definitions */
+#define CCAN_STAT_LEC_MASK  (0x07)     /* Mask for Last Error Code */
+#define CCAN_STAT_TXOK      (1 << 3)   /* Transmitted a message successfully */
+#define CCAN_STAT_RXOK      (1 << 4)   /* Received a message successfully */
+#define CCAN_STAT_EPASS     (1 << 5)   /* The CAN controller is in the error passive state*/
+#define CCAN_STAT_EWARN     (1 << 6)   /*At least one of the error counters in the EC has reached the error warning limit of 96.*/
+#define CCAN_STAT_BOFF      (1 << 7)   /*The CAN controller is in busoff state.*/
+
+/**
+ * @brief Last Error Code definition
+ */
+typedef enum {
+   CCAN_LEC_NO_ERROR,      /*!< No error */
+   CCAN_LEC_STUFF_ERROR,   /*!< More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed. */
+   CCAN_LEC_FORM_ERROR,    /*!< A fixed format part of a received frame has the wrong format */
+   CCAN_LEC_ACK_ERROR,     /*!< The message this CAN core transmitted was not acknowledged. */
+   CCAN_LEC_BIT1_ERROR,    /*!< During the transmission of a message (with the exception of the arbitration field), the device wanted to send a HIGH/recessive level
+                               (bit of logical value "1"), but the monitored bus value was LOW/dominant. */
+   CCAN_LEC_BIT0_ERROR,    /*!< During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a
+                               LOW/dominant level (data or identifier bit logical value "0"), but the monitored Bus value was HIGH/recessive. During busoff recovery this
+                               status is set each time a sequence of 11 HIGH/recessive bits has been monitored. This enables
+                               the CPU to monitor the proceeding of the busoff recovery sequence (indicating the bus is not stuck at LOW/dominant or continuously disturbed). */
+   CCAN_LEC_CRC_ERROR,     /*!< The CRC checksum was incorrect in the message received. */
+} CCAN_LEC_T;
+
+/* CCAN INT register bit definitions */
+#define CCAN_INT_NO_PENDING       0            /*!< No interrupt pending */
+#define CCAN_INT_STATUS           0x8000   /*!< Status interrupt*/
+#define CCAN_INT_MSG_NUM(n)       (n)      /*!<Number of messages which caused interrupts */
+
+/* CCAN TEST register bit definitions */
+#define CCAN_TEST_BASIC_MODE      (1 << 2) /*!<IF1 registers used as TX buffer, IF2 registers used as RX buffer. */
+#define CCAN_TEST_SILENT_MODE     (1 << 3) /*!<The module is in silent mode. */
+#define CCAN_TEST_LOOPBACK_MODE   (1 << 4) /*!<Loop back mode is enabled.*/
+#define CCAN_TEST_TD_CONTROLLED   (0)      /*!< Level at the TD pin is controlled by the CAN controller.*/
+#define CCAN_TEST_TD_MONITORED    (1 << 5) /*!< The sample point can be monitored at the TD pin.*/
+#define CCAN_TEST_TD_DOMINANT     (2 << 5) /*!< TD pin is driven LOW/dominant.*/
+#define CCAN_TEST_TD_RECESSIVE    (3 << 5) /*!< TD pin is driven HIGH/recessive.*/
+#define CCAN_TEST_RD_DOMINANT     (0)      /*!< The CAN bus is dominant (RD = 0).*/
+#define CCAN_TEST_RD_RECESSIVE    (1 << 7)     /*!< The CAN bus is recessive (RD = 1).*/
+
+#define CCAN_SEG1_DEFAULT_VAL 5
+#define CCAN_SEG2_DEFAULT_VAL 4
+#define CCAN_SJW_DEFAULT_VAL  0
+
+/**
+ * @brief CCAN Transfer direction definition
+ */
+typedef enum {
+   CCAN_RX_DIR,
+   CCAN_TX_DIR,
+} CCAN_TRANSFER_DIR_T;
+
+/**
+ * @brief  Enable CCAN Interrupts
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  mask    : Interrupt mask, or-ed bit value of
+ *                     - CCAN_CTRL_IE <br>
+ *                     - CCAN_CTRL_SIE <br>
+ *                     - CCAN_CTRL_EIE <br>
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_EnableInt(LPC_CCAN_T *pCCAN, uint32_t mask)
+{
+   pCCAN->CNTL |= mask;
+}
+
+/**
+ * @brief  Disable CCAN Interrupts
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  mask    : Interrupt mask, or-ed bit value of
+ *                     - CCAN_CTRL_IE <br>
+ *                     - CCAN_CTRL_SIE <br>
+ *                     - CCAN_CTRL_EIE <br>
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_DisableInt(LPC_CCAN_T *pCCAN, uint32_t mask)
+{
+   pCCAN->CNTL &= ~mask;
+}
+
+/**
+ * @brief  Get the source ID of an interrupt
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @return Interrupt source ID
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetIntID(LPC_CCAN_T *pCCAN)
+{
+   return pCCAN->INT;
+}
+
+/**
+ * @brief  Get the CCAN status register
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @return CCAN status register (or-ed bit value of  CCAN_STAT_*)
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetStatus(LPC_CCAN_T *pCCAN)
+{
+   return pCCAN->STAT;
+}
+
+/**
+ * @brief  Set the CCAN status
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  val     : Value to be set for status register (or-ed bit value of  CCAN_STAT_*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_SetStatus(LPC_CCAN_T *pCCAN, uint32_t val)
+{
+   pCCAN->STAT = val & 0x1F;
+}
+
+/**
+ * @brief  Clear the status of CCAN bus
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  val : Status to be cleared (or-ed bit value of  CCAN_STAT_*)
+ * @return Nothing
+ */
+void Chip_CCAN_ClearStatus(LPC_CCAN_T *pCCAN, uint32_t val);
+
+/**
+ * @brief  Get the current value of the transmit/receive error counter
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  dir : direction
+ * @return Current value of the transmit/receive error counter
+ * @note   When @a dir is #CCAN_RX_DIR, then MSB (bit-7) indicates the
+ * receiver error passive level, if the bit is High(1) then the reciever
+ * counter has reached error passive level as specified in CAN2.0
+ * specification; else if the bit is Low(0) it indicates that the
+ * error counter is below the passive level. Bits from (bit6-0) has
+ * the actual error count. When @a dir is #CCAN_TX_DIR, the complete
+ * 8-bits indicates the number of tx errors.
+ */
+STATIC INLINE uint8_t Chip_CCAN_GetErrCounter(LPC_CCAN_T *pCCAN, CCAN_TRANSFER_DIR_T dir)
+{
+   return (dir == CCAN_TX_DIR) ? (pCCAN->EC & 0x0FF) : ((pCCAN->EC >> 8) & 0x0FF);
+}
+
+/**
+ * @brief  Enable test mode in CCAN
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_EnableTestMode(LPC_CCAN_T *pCCAN)
+{
+   pCCAN->CNTL |= CCAN_CTRL_TEST;
+}
+
+/**
+ * @brief  Enable test mode in CCAN
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_DisableTestMode(LPC_CCAN_T *pCCAN)
+{
+   pCCAN->CNTL &= ~CCAN_CTRL_TEST;
+}
+
+/**
+ * @brief  Enable/Disable test mode in CCAN
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  cfg : Test function, or-ed bit values of CCAN_TEST_*
+ * @return Nothing
+ * @note   Test Mode must be enabled before using Chip_CCAN_EnableTestMode function.
+ */
+STATIC INLINE void Chip_CCAN_ConfigTestMode(LPC_CCAN_T *pCCAN, uint32_t cfg)
+{
+   pCCAN->TEST = cfg;
+}
+
+/**
+ * @brief  Enable automatic retransmission
+ * @param  pCCAN           : The base of CCAN peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_EnableAutoRetransmit(LPC_CCAN_T *pCCAN)
+{
+   pCCAN->CNTL &= ~CCAN_CTRL_DAR;
+}
+
+/**
+ * @brief  Disable automatic retransmission
+ * @param  pCCAN           : The base of CCAN peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_DisableAutoRetransmit(LPC_CCAN_T *pCCAN)
+{
+   pCCAN->CNTL |= CCAN_CTRL_DAR;
+}
+
+/**
+ * @brief  Get the transmit repuest bit in all message objects
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @return A 32 bits value, each bit corresponds to transmit request bit in message objects
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetTxRQST(LPC_CCAN_T *pCCAN)
+{
+   return pCCAN->TXREQ1 | (pCCAN->TXREQ2 << 16);
+}
+
+/**
+ * @brief  Initialize the CCAN peripheral, free all message object in RAM
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @return Nothing
+ */
+void Chip_CCAN_Init(LPC_CCAN_T *pCCAN);
+
+/**
+ * @brief  De-initialize the CCAN peripheral
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @return Nothing
+ */
+void Chip_CCAN_DeInit(LPC_CCAN_T *pCCAN);
+
+/**
+ * @brief  Select bit rate for CCAN bus
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  bitRate : Bit rate to be set
+ * @return SUCCESS/ERROR
+ */
+Status Chip_CCAN_SetBitRate(LPC_CCAN_T *pCCAN, uint32_t bitRate);
+
+/** Number of message objects in Message RAM */
+#define CCAN_MSG_MAX_NUM                              32
+
+/**
+ * @brief CAN message object structure
+ */
+typedef struct {
+   uint32_t    id;     /**< ID of message, if bit 30 is set then this is extended frame */
+   uint32_t    dlc;    /**< Message data length */
+   uint8_t     data[8];    /**< Message data */
+} CCAN_MSG_OBJ_T;
+
+typedef enum {
+   CCAN_MSG_IF1 = 0,
+   CCAN_MSG_IF2 = 1,
+} CCAN_MSG_IF_T;
+
+/* bit field of IF command request n register */
+#define CCAN_IF_CMDREQ_MSG_NUM(n)  (n)         /* Message number (1->20) */
+#define CCAN_IF_CMDREQ_BUSY          0x8000            /* 1 is writing is progress, cleared when RD/WR done */
+
+/* bit field of IF command mask register */
+#define CCAN_IF_CMDMSK_DATAB        (1 << 0)       /** 1 is transfer data byte 4-7 to message object, 0 is not */
+#define CCAN_IF_CMDMSK_DATAA        (1 << 1)       /** 1 is transfer data byte 0-3 to message object, 0 is not */
+#define CCAN_IF_CMDMSK_W_TXRQST     (1 << 2)       /** Request a transmission. Set the TXRQST bit IF1/2_MCTRL. */
+#define CCAN_IF_CMDMSK_R_NEWDAT     (1 << 2)       /** Clear NEWDAT bit in the message object */
+#define CCAN_IF_CMDMSK_R_CLRINTPND  (1 << 3)       /** Clear INTPND bit in the message object. */
+#define CCAN_IF_CMDMSK_CTRL         (1 << 4)       /** 1 is transfer the CTRL bit to the message object, 0 is not */
+#define CCAN_IF_CMDMSK_ARB          (1 << 5)       /** 1 is transfer the ARB bits to the message object, 0 is not */
+#define CCAN_IF_CMDMSK_MASK         (1 << 6)       /** 1 is transfer the MASK bit to the message object, 0 is not */
+#define CCAN_IF_CMDMSK_WR           (1 << 7)       /*  Tranfer direction: Write */
+#define CCAN_IF_CMDMSK_RD           (0)                /*  Tranfer direction: Read */
+#define CCAN_IF_CMDMSK_TRANSFER_ALL (CCAN_IF_CMDMSK_CTRL | CCAN_IF_CMDMSK_MASK | CCAN_IF_CMDMSK_ARB | \
+                                    CCAN_IF_CMDMSK_DATAB | CCAN_IF_CMDMSK_DATAA)
+
+/* bit field of IF mask 2 register */
+#define CCAN_IF_MASK2_MXTD          (1 << 15)              /* 1 is extended identifier bit is used in the RX filter unit, 0 is not */
+#define CCAN_IF_MASK2_MDIR(n)       (((n) & 0x01) <<  14)  /* 1 is direction bit is used in the RX filter unit, 0 is not */
+
+/* bit field of IF arbitration 2 register */
+#define CCAN_IF_ARB2_DIR(n)         (((n) & 0x01) << 13)   /* 1: Dir = transmit, 0: Dir = receive */
+#define CCAN_IF_ARB2_XTD            (1 << 14)      /* Extended identifier bit is used*/
+#define CCAN_IF_ARB2_MSGVAL         (1 << 15)      /* Message valid bit, 1 is valid in the MO handler, 0 is ignored */
+
+/* bit field of IF message control register */
+#define CCAN_IF_MCTRL_DLC_MSK        0x000F            /* bit mask for DLC */
+#define CCAN_IF_MCTRL_EOB           (1 << 7)       /* End of buffer, always write to 1 */
+#define CCAN_IF_MCTRL_TXRQ          (1 << 8)       /* 1 is TxRqst enabled */
+#define CCAN_IF_MCTRL_RMTEN(n)      (((n) & 1UL) << 9) /* 1 is remote frame enabled */
+#define CCAN_IF_MCTRL_RXIE          (1 << 10)      /* 1 is RX interrupt enabled */
+#define CCAN_IF_MCTRL_TXIE          (1 << 11)      /* 1 is TX interrupt enabled */
+#define CCAN_IF_MCTRL_UMSK          (1 << 12)      /* 1 is to use the mask for the receive filter mask. */
+#define CCAN_IF_MCTRL_INTP          (1 << 13)      /* 1 indicates message object is an interrupt source */
+#define CCAN_IF_MCTRL_MLST          (1 << 14)      /* 1 indicates a message loss. */
+#define CCAN_IF_MCTRL_NEWD          (1 << 15)      /* 1 indicates new data is in the message buffer.  */
+
+#define CCAN_MSG_ID_STD_MASK        0x07FF
+#define CCAN_MSG_ID_EXT_MASK        0x1FFFFFFF
+
+/**
+ * @brief  Tranfer message object between IF registers and Message RAM
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  IFSel       : The Message interface to be used
+ * @param  mask    : command mask (or-ed bit value of CCAN_IF_CMDMSK_*)
+ * @param  msgNum      : The number of message object in message RAM to be get
+ * @return Nothing
+ */
+void Chip_CCAN_TransferMsgObject(LPC_CCAN_T *pCCAN,
+                                CCAN_MSG_IF_T IFSel,
+                                uint32_t mask,
+                                uint32_t msgNum);
+
+/**
+ * @brief  Set a message into the message object in message RAM
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  IFSel       : The Message interface to be used
+ * @param  dir : transmit/receive
+ * @param  remoteFrame: Enable/Disable passives transmit by using remote frame
+ * @param  msgNum      : Message number
+ * @param  pMsgObj     : Pointer of message to be set
+ * @return Nothing
+ */
+void Chip_CCAN_SetMsgObject (LPC_CCAN_T *pCCAN,
+                            CCAN_MSG_IF_T IFSel,
+                            CCAN_TRANSFER_DIR_T dir,
+                            bool remoteFrame,
+                            uint8_t msgNum,
+                            const CCAN_MSG_OBJ_T *pMsgObj);
+
+/**
+ * @brief  Get a message object in message RAM into the message buffer
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  IFSel   : The Message interface to be used
+ * @param  msgNum      : The number of message object in message RAM to be get
+ * @param  pMsgObj     : Pointer of the message buffer
+ * @return Nothing
+ */
+void Chip_CCAN_GetMsgObject(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, CCAN_MSG_OBJ_T *pMsgObj);
+
+/**
+ * @brief  Enable/Disable the message object to valid
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  IFSel   : The Message interface to be used
+ * @param  msgNum  : Message number
+ * @param  valid   : true: valid, false: invalide
+ * @return Nothing
+ */
+void Chip_CCAN_SetValidMsg(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, bool valid);
+
+/**
+ * @brief  Check the message objects is valid or not
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @return A 32 bits value, each bit corresponds to a message objects form 0 to 31 (1 is valid, 0 is invalid)
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetValidMsg(LPC_CCAN_T *pCCAN)
+{
+   return pCCAN->MSGV1 | (pCCAN->MSGV2 << 16);
+}
+
+/**
+ * @brief  Clear the pending message interrupt
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  IFSel   : The Message interface to be used
+ * @param  msgNum  : Message number
+ * @param  dir : Select transmit or receive interrupt to be cleared
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_ClearMsgIntPend(LPC_CCAN_T *pCCAN,
+                                            CCAN_MSG_IF_T IFSel,
+                                            uint8_t msgNum,
+                                            CCAN_TRANSFER_DIR_T dir)
+{
+   Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_RD | CCAN_IF_CMDMSK_R_CLRINTPND, msgNum);
+}
+
+/**
+ * @brief  Clear new data flag bit in the message object
+ * @param  pCCAN   : The base of CCAN peripheral on the chip
+ * @param  IFSel   : The Message interface to be used
+ * @param  msgNum  : Message number
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CCAN_ClearNewDataFlag(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum)
+{
+   Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_RD | CCAN_IF_CMDMSK_R_NEWDAT, msgNum);
+}
+
+/**
+ * @brief  Send a message
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  IFSel   : The Message interface to be used
+ * @param  remoteFrame: Enable/Disable passives transmit by using remote frame
+ * @param  pMsgObj     : Message to be transmitted
+ * @return Nothing
+ */
+void Chip_CCAN_Send (LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, bool remoteFrame, CCAN_MSG_OBJ_T *pMsgObj);
+
+/**
+ * @brief  Register a message ID for receiving
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  IFSel   : The Message interface to be used
+ * @param  id      : Received message ID
+ * @return Nothing
+ */
+void Chip_CCAN_AddReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id);
+
+/**
+ * @brief  Remove a registered message ID from receiving
+ * @param  IFSel   : The Message interface to be used
+ * @param  pCCAN       : The base of CCAN peripheral on the chip
+ * @param  id      : Received message ID to be removed
+ * @return Nothing
+ */
+void Chip_CCAN_DeleteReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CCAN_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/cguccu_18xx_43xx.h ./lpc_chip_43xx/inc/cguccu_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/cguccu_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/cguccu_18xx_43xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,114 @@
+/*
+ * @brief CGU/CCU registers and control functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CGUCCU_18XX_43XX_H_
+#define __CGUCCU_18XX_43XX_H_
+
+#include "chip_clocks.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup CLOCK_18XX_43XX
+ * @{
+ */
+
+/**
+ * Audio or USB PLL selection
+ */
+typedef enum CHIP_CGU_USB_AUDIO_PLL {
+   CGU_USB_PLL,
+   CGU_AUDIO_PLL
+} CHIP_CGU_USB_AUDIO_PLL_T;
+
+/**
+ * PLL register block
+ */
+typedef struct {
+   __I  uint32_t  PLL_STAT;                /*!< PLL status register */
+   __IO uint32_t  PLL_CTRL;                /*!< PLL control register */
+   __IO uint32_t  PLL_MDIV;                /*!< PLL M-divider register */
+   __IO uint32_t  PLL_NP_DIV;              /*!< PLL N/P-divider register */
+} CGU_PLL_REG_T;
+
+/**
+ * @brief LPC18XX/43XX CGU register block structure
+ */
+typedef struct {                           /*!< (@ 0x40050000) CGU Structure          */
+   __I  uint32_t  RESERVED0[5];
+   __IO uint32_t  FREQ_MON;                /*!< (@ 0x40050014) Frequency monitor register */
+   __IO uint32_t  XTAL_OSC_CTRL;           /*!< (@ 0x40050018) Crystal oscillator control register */
+   CGU_PLL_REG_T  PLL[CGU_AUDIO_PLL + 1];  /*!< (@ 0x4005001C) USB and audio PLL blocks */
+   __IO uint32_t  PLL0AUDIO_FRAC;          /*!< (@ 0x4005003C) PLL0 (audio)           */
+   __I  uint32_t  PLL1_STAT;               /*!< (@ 0x40050040) PLL1 status register   */
+   __IO uint32_t  PLL1_CTRL;               /*!< (@ 0x40050044) PLL1 control register  */
+   __IO uint32_t  IDIV_CTRL[CLK_IDIV_LAST];/*!< (@ 0x40050048) Integer divider A-E control registers */
+   __IO uint32_t  BASE_CLK[CLK_BASE_LAST]; /*!< (@ 0x4005005C) Start of base clock registers */
+} LPC_CGU_T;
+
+/**
+ * @brief CCU clock config/status register pair
+ */
+typedef struct {
+   __IO uint32_t  CFG;                     /*!< CCU clock configuration register */
+   __I  uint32_t  STAT;                    /*!< CCU clock status register */
+} CCU_CFGSTAT_T;
+
+/**
+ * @brief CCU1 register block structure
+ */
+typedef struct {                           /*!< (@ 0x40051000) CCU1 Structure         */
+   __IO uint32_t  PM;                      /*!< (@ 0x40051000) CCU1 power mode register */
+   __I  uint32_t  BASE_STAT;               /*!< (@ 0x40051004) CCU1 base clocks status register */
+   __I  uint32_t  RESERVED0[62];
+   CCU_CFGSTAT_T  CLKCCU[CLK_CCU1_LAST];   /*!< (@ 0x40051100) Start of CCU1 clock registers */
+} LPC_CCU1_T;
+
+/**
+ * @brief CCU2 register block structure
+ */
+typedef struct {                           /*!< (@ 0x40052000) CCU2 Structure         */
+   __IO uint32_t  PM;                      /*!< (@ 0x40052000) Power mode register    */
+   __I  uint32_t  BASE_STAT;               /*!< (@ 0x40052004) CCU base clocks status register */
+   __I  uint32_t  RESERVED0[62];
+   CCU_CFGSTAT_T  CLKCCU[CLK_CCU2_LAST - CLK_CCU1_LAST];   /*!< (@ 0x40052100) Start of CCU2 clock registers */
+} LPC_CCU2_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CGUCCU_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/chip_clocks.h ./lpc_chip_43xx/inc/chip_clocks.h
--- a_qSC69Z/lpc_chip_43xx/inc/chip_clocks.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/chip_clocks.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,252 @@
+/*
+ * @brief  LPC18xx/43xx chip clock list used by CGU and CCU drivers
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_CLOCKS_H_
+#define __CHIP_CLOCKS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup CLOCK_18XX_43XX
+ * @{
+ */
+
+/**
+ * @brief CGU clock input list
+ * These are possible input clocks for the CGU and can come
+ * from both external (crystal) and internal (PLL) sources. These
+ * clock inputs can be routed to the base clocks (@ref CHIP_CGU_BASE_CLK_T).
+ */
+typedef enum CHIP_CGU_CLKIN {
+   CLKIN_32K,      /*!< External 32KHz input */
+   CLKIN_IRC,      /*!< Internal IRC (12MHz) input */
+   CLKIN_ENET_RX,  /*!< External ENET_RX pin input */
+   CLKIN_ENET_TX,  /*!< External ENET_TX pin input */
+   CLKIN_CLKIN,    /*!< External GPCLKIN pin input */
+   CLKIN_RESERVED1,
+   CLKIN_CRYSTAL,  /*!< External (main) crystal pin input */
+   CLKIN_USBPLL,   /*!< Internal USB PLL input */
+   CLKIN_AUDIOPLL, /*!< Internal Audio PLL input */
+   CLKIN_MAINPLL,  /*!< Internal Main PLL input */
+   CLKIN_RESERVED2,
+   CLKIN_RESERVED3,
+   CLKIN_IDIVA,    /*!< Internal divider A input */
+   CLKIN_IDIVB,    /*!< Internal divider B input */
+   CLKIN_IDIVC,    /*!< Internal divider C input */
+   CLKIN_IDIVD,    /*!< Internal divider D input */
+   CLKIN_IDIVE,    /*!< Internal divider E input */
+   CLKINPUT_PD     /*!< External 32KHz input */
+} CHIP_CGU_CLKIN_T;
+
+/**
+ * @brief CGU base clocks
+ * CGU base clocks are clocks that are associated with a single input clock
+ * and are routed out to 1 or more peripherals. For example, the CLK_BASE_PERIPH
+ * clock can be configured to use the CLKIN_MAINPLL input clock, which will in
+ * turn route that clock to the CLK_PERIPH_BUS, CLK_PERIPH_CORE, and
+ * CLK_PERIPH_SGPIO periphral clocks.
+ */
+typedef enum CHIP_CGU_BASE_CLK {
+   CLK_BASE_SAFE,      /*!< Base clock for WDT oscillator, IRC input only */
+   CLK_BASE_USB0,      /*!< Base USB clock for USB0, USB PLL input only */
+#if defined(CHIP_LPC43XX)
+   CLK_BASE_PERIPH,    /*!< Base clock for SGPIO */
+#else
+   CLK_BASE_RESERVED1,
+#endif
+   CLK_BASE_USB1,      /*!< Base USB clock for USB1 */
+   CLK_BASE_MX,        /*!< Base clock for CPU core */
+   CLK_BASE_SPIFI,     /*!< Base clock for SPIFI */
+#if defined(CHIP_LPC43XX)
+   CLK_BASE_SPI,       /*!< Base clock for SPI */
+#else
+   CLK_BASE_RESERVED2,
+#endif
+   CLK_BASE_PHY_RX,    /*!< Base clock for PHY RX */
+   CLK_BASE_PHY_TX,    /*!< Base clock for PHY TX */
+   CLK_BASE_APB1,      /*!< Base clock for APB1 group */
+   CLK_BASE_APB3,      /*!< Base clock for APB3 group */
+   CLK_BASE_LCD,       /*!< Base clock for LCD pixel clock */
+#if defined(CHIP_LPC43XX)
+   CLK_BASE_ADCHS,     /*!< Base clock for ADCHS */
+#else
+   CLK_BASE_RESERVED3,
+#endif
+   CLK_BASE_SDIO,      /*!< Base clock for SDIO */
+   CLK_BASE_SSP0,      /*!< Base clock for SSP0 */
+   CLK_BASE_SSP1,      /*!< Base clock for SSP1 */
+   CLK_BASE_UART0,     /*!< Base clock for UART0 */
+   CLK_BASE_UART1,     /*!< Base clock for UART1 */
+   CLK_BASE_UART2,     /*!< Base clock for UART2 */
+   CLK_BASE_UART3,     /*!< Base clock for UART3 */
+   CLK_BASE_OUT,       /*!< Base clock for CLKOUT pin */
+   CLK_BASE_RESERVED4,
+   CLK_BASE_RESERVED5,
+   CLK_BASE_RESERVED6,
+   CLK_BASE_RESERVED7,
+   CLK_BASE_APLL,      /*!< Base clock for audio PLL */
+   CLK_BASE_CGU_OUT0,  /*!< Base clock for CGUOUT0 pin */
+   CLK_BASE_CGU_OUT1,  /*!< Base clock for CGUOUT1 pin */
+   CLK_BASE_LAST,
+   CLK_BASE_NONE = CLK_BASE_LAST
+} CHIP_CGU_BASE_CLK_T;
+
+/**
+ * @brief CGU dividers
+ * CGU dividers provide an extra clock state where a specific clock can be
+ * divided before being routed to a peripheral group. A divider accepts an
+ * input clock and then divides it. To use the divided clock for a base clock
+ * group, use the divider as the input clock for the base clock (for example,
+ * use CLKIN_IDIVB, where CLKIN_MAINPLL might be the input into the divider).
+ */
+typedef enum CHIP_CGU_IDIV {
+   CLK_IDIV_A,     /*!< CGU clock divider A */
+   CLK_IDIV_B,     /*!< CGU clock divider B */
+   CLK_IDIV_C,     /*!< CGU clock divider A */
+   CLK_IDIV_D,     /*!< CGU clock divider D */
+   CLK_IDIV_E,     /*!< CGU clock divider E */
+   CLK_IDIV_LAST
+} CHIP_CGU_IDIV_T;
+
+#define CHIP_CGU_IDIV_MASK(x)  ("\x03\x0F\x0F\x0F\xFF"[x])
+
+/**
+ * @brief Peripheral clocks
+ * Peripheral clocks are individual clocks routed to peripherals. Although
+ * multiple peripherals may share a same base clock, each peripheral's clock
+ * can be enabled or disabled individually. Some peripheral clocks also have
+ * additional dividers associated with them.
+ */
+typedef enum CHIP_CCU_CLK {
+   /* CCU1 clocks */
+   CLK_APB3_BUS,       /*!< APB3 bus clock from base clock CLK_BASE_APB3 */
+   CLK_APB3_I2C1,      /*!< I2C1 register/perigheral clock from base clock CLK_BASE_APB3 */
+   CLK_APB3_DAC,       /*!< DAC peripheral clock from base clock CLK_BASE_APB3 */
+   CLK_APB3_ADC0,      /*!< ADC0 register/perigheral clock from base clock CLK_BASE_APB3 */
+   CLK_APB3_ADC1,      /*!< ADC1 register/perigheral clock from base clock CLK_BASE_APB3 */
+   CLK_APB3_CAN0,      /*!< CAN0 register/perigheral clock from base clock CLK_BASE_APB3 */
+   CLK_APB1_BUS = 32,  /*!< APB1 bus clock clock from base clock CLK_BASE_APB1 */
+   CLK_APB1_MOTOCON,   /*!< Motor controller register/perigheral clock from base clock CLK_BASE_APB1 */
+   CLK_APB1_I2C0,      /*!< I2C0 register/perigheral clock from base clock CLK_BASE_APB1 */
+   CLK_APB1_I2S,       /*!< I2S register/perigheral clock from base clock CLK_BASE_APB1 */
+   CLK_APB1_CAN1,      /*!< CAN1 register/perigheral clock from base clock CLK_BASE_APB1 */
+   CLK_SPIFI = 64,     /*!< SPIFI SCKI input clock from base clock CLK_BASE_SPIFI */
+   CLK_MX_BUS = 96,    /*!< M3/M4 BUS core clock from base clock CLK_BASE_MX */
+   CLK_MX_SPIFI,       /*!< SPIFI register clock from base clock CLK_BASE_MX */
+   CLK_MX_GPIO,        /*!< GPIO register clock from base clock CLK_BASE_MX */
+   CLK_MX_LCD,         /*!< LCD register clock from base clock CLK_BASE_MX */
+   CLK_MX_ETHERNET,    /*!< ETHERNET register clock from base clock CLK_BASE_MX */
+   CLK_MX_USB0,        /*!< USB0 register clock from base clock CLK_BASE_MX */
+   CLK_MX_EMC,         /*!< EMC clock from base clock CLK_BASE_MX */
+   CLK_MX_SDIO,        /*!< SDIO register clock from base clock CLK_BASE_MX */
+   CLK_MX_DMA,         /*!< DMA register clock from base clock CLK_BASE_MX */
+   CLK_MX_MXCORE,      /*!< M3/M4 CPU core clock from base clock CLK_BASE_MX */
+   RESERVED_ALIGN = CLK_MX_MXCORE + 3,
+   CLK_MX_SCT,         /*!< SCT register clock from base clock CLK_BASE_MX */
+   CLK_MX_USB1,        /*!< USB1 register clock from base clock CLK_BASE_MX */
+   CLK_MX_EMC_DIV,     /*!< ENC divider clock from base clock CLK_BASE_MX */
+   CLK_MX_FLASHA,      /*!< FLASHA bank clock from base clock CLK_BASE_MX */
+   CLK_MX_FLASHB,      /*!< FLASHB bank clock from base clock CLK_BASE_MX */
+#if defined(CHIP_LPC43XX)
+   CLK_M4_M0APP,       /*!< M0 app CPU core clock from base clock CLK_BASE_MX */
+   CLK_MX_ADCHS,       /*!< ADCHS clock from base clock CLK_BASE_ADCHS */
+#else
+   CLK_RESERVED1,
+   CLK_RESERVED2,
+#endif
+   CLK_MX_EEPROM,      /*!< EEPROM clock from base clock CLK_BASE_MX */
+   CLK_MX_WWDT = 128,  /*!< WWDT register clock from base clock CLK_BASE_MX */
+   CLK_MX_UART0,       /*!< UART0 register clock from base clock CLK_BASE_MX */
+   CLK_MX_UART1,       /*!< UART1 register clock from base clock CLK_BASE_MX */
+   CLK_MX_SSP0,        /*!< SSP0 register clock from base clock CLK_BASE_MX */
+   CLK_MX_TIMER0,      /*!< TIMER0 register/perigheral clock from base clock CLK_BASE_MX */
+   CLK_MX_TIMER1,      /*!< TIMER1 register/perigheral clock from base clock CLK_BASE_MX */
+   CLK_MX_SCU,         /*!< SCU register/perigheral clock from base clock CLK_BASE_MX */
+   CLK_MX_CREG,        /*!< CREG clock from base clock CLK_BASE_MX */
+   CLK_MX_RITIMER = 160,   /*!< RITIMER register/perigheral clock from base clock CLK_BASE_MX */
+   CLK_MX_UART2,       /*!< UART3 register clock from base clock CLK_BASE_MX */
+   CLK_MX_UART3,       /*!< UART4 register clock from base clock CLK_BASE_MX */
+   CLK_MX_TIMER2,      /*!< TIMER2 register/perigheral clock from base clock CLK_BASE_MX */
+   CLK_MX_TIMER3,      /*!< TIMER3 register/perigheral clock from base clock CLK_BASE_MX */
+   CLK_MX_SSP1,        /*!< SSP1 register clock from base clock CLK_BASE_MX */
+   CLK_MX_QEI,         /*!< QEI register/perigheral clock from base clock CLK_BASE_MX */
+#if defined(CHIP_LPC43XX)
+   CLK_PERIPH_BUS = 192,   /*!< Peripheral bus clock from base clock CLK_BASE_PERIPH */
+   CLK_RESERVED3,
+   CLK_PERIPH_CORE,    /*!< Peripheral core clock from base clock CLK_BASE_PERIPH */
+   CLK_PERIPH_SGPIO,   /*!< SGPIO clock from base clock CLK_BASE_PERIPH */
+#else
+   CLK_RESERVED3 = 192,
+   CLK_RESERVED3A,
+   CLK_RESERVED4,
+   CLK_RESERVED5,
+#endif
+   CLK_USB0 = 224,         /*!< USB0 clock from base clock CLK_BASE_USB0 */
+   CLK_USB1 = 256,         /*!< USB1 clock from base clock CLK_BASE_USB1 */
+#if defined(CHIP_LPC43XX)
+   CLK_SPI = 288,          /*!< SPI clock from base clock CLK_BASE_SPI */
+   CLK_ADCHS = 320,        /*!< ADCHS clock from base clock CLK_BASE_ADCHS */
+#else
+   CLK_RESERVED7 = 320,
+   CLK_RESERVED8,
+#endif
+   CLK_CCU1_LAST,
+
+   /* CCU2 clocks */
+   CLK_CCU2_START,
+   CLK_APLL = CLK_CCU2_START,  /*!< Audio PLL clock from base clock CLK_BASE_APLL */
+   RESERVED_ALIGNB = CLK_CCU2_START + 31,
+   CLK_APB2_UART3,         /*!< UART3 clock from base clock CLK_BASE_UART3 */
+   RESERVED_ALIGNC = CLK_CCU2_START + 63,
+   CLK_APB2_UART2,         /*!< UART2 clock from base clock CLK_BASE_UART2 */
+   RESERVED_ALIGND = CLK_CCU2_START + 95,
+   CLK_APB0_UART1,         /*!< UART1 clock from base clock CLK_BASE_UART1 */
+   RESERVED_ALIGNE = CLK_CCU2_START + 127,
+   CLK_APB0_UART0,         /*!< UART0 clock from base clock CLK_BASE_UART0 */
+   RESERVED_ALIGNF = CLK_CCU2_START + 159,
+   CLK_APB2_SSP1,          /*!< SSP1 clock from base clock CLK_BASE_SSP1 */
+   RESERVED_ALIGNG = CLK_CCU2_START + 191,
+   CLK_APB0_SSP0,          /*!< SSP0 clock from base clock CLK_BASE_SSP0 */
+   RESERVED_ALIGNH = CLK_CCU2_START + 223,
+   CLK_APB2_SDIO,          /*!< SDIO clock from base clock CLK_BASE_SDIO */
+   CLK_CCU2_LAST
+} CHIP_CCU_CLK_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_CLOCKS_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/chip.h ./lpc_chip_43xx/inc/chip.h
--- a_qSC69Z/lpc_chip_43xx/inc/chip.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/chip.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,163 @@
+/*
+ * @brief Chip inclusion selector file
+ *
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_H_
+#define __CHIP_H_
+
+#include "sys_config.h"
+#include "cmsis.h"
+
+#if defined(CHIP_LPC18XX)
+#include "chip_lpc18xx.h"
+
+#elif defined(CHIP_LPC43XX)
+#include "chip_lpc43xx.h"
+
+#else
+#error CHIP_LPC18XX or CHIP_LPC43XX must be defined
+#endif
+
+/* Aliasing for Chip_USB_Init */
+#define Chip_USB_Init  Chip_USB0_Init
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/** @ingroup CHIP_18XX_43XX_DRIVER_OPTIONS
+ * @{
+ */
+
+/**
+ * @brief  System oscillator rate
+ * This value is defined externally to the chip layer and contains
+ * the value in Hz for the external oscillator for the board. If using the
+ * internal oscillator, this rate can be 0.
+ */
+extern const uint32_t OscRateIn;
+
+/**
+ * @brief  Clock rate on the CLKIN pin
+ * This value is defined externally to the chip layer and contains
+ * the value in Hz for the CLKIN pin for the board. If this pin isn't used,
+ * this rate can be 0.
+ */
+extern const uint32_t ExtRateIn;
+
+/**
+ * @}
+ */
+
+/** @defgroup SUPPORT_18XX_43XX_FUNC CHIP: LPC18xx/43xx support functions
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief  Current system clock rate, mainly used for sysTick
+ */
+extern uint32_t SystemCoreClock;
+
+/**
+ * @brief  Update system core clock rate, should be called if the
+ *         system has a clock rate change
+ * @return None
+ */
+void SystemCoreClockUpdate(void);
+
+/**
+ * @brief USB0 Pin and clock initialization
+ * Calling this function will initialize the USB0 pins and the clock
+ * @note This function will assume that the chip is clocked by an
+ * external crystal oscillator of frequency 12MHz
+ */
+void Chip_USB0_Init(void);
+
+/**
+ * @brief USB1 Pin and clock initialization
+ * Calling this function will initialize the USB0 pins and the clock
+ * @note This function will assume that the chip is clocked by an
+ * external crystal oscillator of frequency 12MHz
+ */
+void Chip_USB1_Init(void);
+
+/**
+ * @brief  Set up and initialize hardware prior to call to main()
+ * @return None
+ * @note   Chip_SystemInit() is called prior to the application and sets up
+ * system clocking prior to the application starting.
+ */
+void Chip_SystemInit(void);
+
+/**
+ * @brief  Clock and PLL initialization based input given in @a clkin
+ * @param  clkin       : Input reference clock to PLL1 (MAINPLL) see #CHIP_CGU_CLKIN_T
+ * @param  core_freq   : Desired output frequency of the PLL1 (Base clock to CPU Core)
+ * @param  setbase     : Setup default base clock of peripherals (see notes)
+ * @return None
+ * @note   This API will initialize the MAINPLL (PLL1) to the frequency given by
+ *             @a core_freq, and will use this PLL's output as the base clock for CPU
+ *             Core. If @a clkin is #CLKIN_CRYSTAL then External Crystal Oscillator
+ *             of frequency 12MHz will be used as the input reference clock to PLL1.<br>
+ *             Parameter @a setbase if true will set APB[1,3], SSP[0,1], UART[0,1,2,3],
+ *             SPI base clocks to MAINPLL's output clock. If @a setbase is false then
+ *             the base clock settings for the peripherals will not be modified, only
+ *             CPU Core's base clock will be updated to use clock generated by PLL1.
+ */
+void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase);
+
+/**
+ * @brief  Clock and PLL initialization based on the external oscillator
+ * @return None
+ * @note   This API will initialize the MAINPLL (PLL1) to the maximum
+ *             frequency (180MHz[LPC18xx] or 204MHz[LPC43xx]) and uses this
+ *             PLL's output as the base clock for CPU Core. External Crystal Oscillator
+ *             of frequency 12MHz will be used as the input reference clock to PLL1.
+ */
+void Chip_SetupXtalClocking(void);
+
+/**
+ * @brief  Clock and PLL initialization based on the internal oscillator
+ * @return None
+ * @note   This API will initialize the MAINPLL (PLL1) to the maximum
+ *             frequency (180MHz[LPC18xx] or 204MHz[LPC43xx]) and uses this
+ *             PLL's output as the base clock for CPU Core. Internal RC Oscillator
+ *             will be used as the input reference clock to PLL1.
+ */
+void Chip_SetupIrcClocking(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/chip_lpc18xx.h ./lpc_chip_43xx/inc/chip_lpc18xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/chip_lpc18xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/chip_lpc18xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,210 @@
+/*
+ * @brief LPC18xx basic chip inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_LPC18XX_H_
+#define __CHIP_LPC18XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lpc_types.h"
+#include "sys_config.h"
+
+#ifndef CORE_M3
+#error CORE_M3 is not defined for the LPC18xx architecture
+#error CORE_M3 should be defined as part of your compiler define list
+#endif
+
+#ifndef CHIP_LPC18XX
+#error The LPC18XX Chip include path is used for this build, but
+#error CHIP_LPC18XX is not defined!
+#endif
+
+/** @defgroup PERIPH_18XX_BASE CHIP: LPC18xx Peripheral addresses and register set declarations
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define LPC_SCT_BASE              0x40000000
+#define LPC_GPDMA_BASE            0x40002000
+#define LPC_SPIFI_BASE            0x40003000
+#define LPC_SDMMC_BASE            0x40004000
+#define LPC_EMC_BASE              0x40005000
+#define LPC_USB0_BASE             0x40006000
+#define LPC_USB1_BASE             0x40007000
+#define LPC_LCD_BASE              0x40008000
+#define LPC_FMCA_BASE             0x4000C000
+#define LPC_FMCB_BASE             0x4000D000
+#define LPC_ETHERNET_BASE         0x40010000
+#define LPC_ATIMER_BASE           0x40040000
+#define LPC_REGFILE_BASE          0x40041000
+#define LPC_PMC_BASE              0x40042000
+#define LPC_CREG_BASE             0x40043000
+#define LPC_EVRT_BASE             0x40044000
+#define LPC_OTP_BASE              0x40045000
+#define LPC_RTC_BASE              0x40046000
+#define LPC_CGU_BASE              0x40050000
+#define LPC_CCU1_BASE             0x40051000
+#define LPC_CCU2_BASE             0x40052000
+#define LPC_RGU_BASE              0x40053000
+#define LPC_WWDT_BASE             0x40080000
+#define LPC_USART0_BASE           0x40081000
+#define LPC_USART2_BASE           0x400C1000
+#define LPC_USART3_BASE           0x400C2000
+#define LPC_UART1_BASE            0x40082000
+#define LPC_SSP0_BASE             0x40083000
+#define LPC_SSP1_BASE             0x400C5000
+#define LPC_TIMER0_BASE           0x40084000
+#define LPC_TIMER1_BASE           0x40085000
+#define LPC_TIMER2_BASE           0x400C3000
+#define LPC_TIMER3_BASE           0x400C4000
+#define LPC_SCU_BASE              0x40086000
+#define LPC_PIN_INT_BASE          0x40087000
+#define LPC_GPIO_GROUP_INT0_BASE  0x40088000
+#define LPC_GPIO_GROUP_INT1_BASE  0x40089000
+#define LPC_MCPWM_BASE            0x400A0000
+#define LPC_I2C0_BASE             0x400A1000
+#define LPC_I2C1_BASE             0x400E0000
+#define LPC_I2S0_BASE             0x400A2000
+#define LPC_I2S1_BASE             0x400A3000
+#define LPC_C_CAN1_BASE           0x400A4000
+#define LPC_RITIMER_BASE          0x400C0000
+#define LPC_QEI_BASE              0x400C6000
+#define LPC_GIMA_BASE             0x400C7000
+#define LPC_DAC_BASE              0x400E1000
+#define LPC_C_CAN0_BASE           0x400E2000
+#define LPC_ADC0_BASE             0x400E3000
+#define LPC_ADC1_BASE             0x400E4000
+#define LPC_GPIO_PORT_BASE        0x400F4000
+#define LPC_SPI_BASE              0x40100000
+#define LPC_SGPIO_BASE            0x40101000
+#define LPC_EEPROM_BASE           0x4000E000
+#define LPC_ROM_API_BASE          0x10400100
+
+#define LPC_SCT                   ((LPC_SCT_T              *) LPC_SCT_BASE)
+#define LPC_GPDMA                 ((LPC_GPDMA_T            *) LPC_GPDMA_BASE)
+#define LPC_SDMMC                 ((LPC_SDMMC_T            *) LPC_SDMMC_BASE)
+#define LPC_EMC                   ((LPC_EMC_T              *) LPC_EMC_BASE)
+#define LPC_USB0                  ((LPC_USBHS_T            *) LPC_USB0_BASE)
+#define LPC_USB1                  ((LPC_USBHS_T            *) LPC_USB1_BASE)
+#define LPC_LCD                   ((LPC_LCD_T              *) LPC_LCD_BASE)
+#define LPC_ETHERNET              ((LPC_ENET_T             *) LPC_ETHERNET_BASE)
+#define LPC_ATIMER                ((LPC_ATIMER_T           *) LPC_ATIMER_BASE)
+#define LPC_REGFILE               ((LPC_REGFILE_T          *) LPC_REGFILE_BASE)
+#define LPC_PMC                   ((LPC_PMC_T              *) LPC_PMC_BASE)
+#define LPC_EVRT                  ((LPC_EVRT_T             *) LPC_EVRT_BASE)
+#define LPC_RTC                   ((LPC_RTC_T              *) LPC_RTC_BASE)
+#define LPC_CGU                   ((LPC_CGU_T              *) LPC_CGU_BASE)
+#define LPC_CCU1                  ((LPC_CCU1_T             *) LPC_CCU1_BASE)
+#define LPC_CCU2                  ((LPC_CCU2_T             *) LPC_CCU2_BASE)
+#define LPC_CREG                  ((LPC_CREG_T             *) LPC_CREG_BASE)
+#define LPC_RGU                   ((LPC_RGU_T              *) LPC_RGU_BASE)
+#define LPC_WWDT                  ((LPC_WWDT_T             *) LPC_WWDT_BASE)
+#define LPC_USART0                ((LPC_USART_T            *) LPC_USART0_BASE)
+#define LPC_USART2                ((LPC_USART_T            *) LPC_USART2_BASE)
+#define LPC_USART3                ((LPC_USART_T            *) LPC_USART3_BASE)
+#define LPC_UART1                 ((LPC_USART_T            *) LPC_UART1_BASE)
+#define LPC_SSP0                  ((LPC_SSP_T              *) LPC_SSP0_BASE)
+#define LPC_SSP1                  ((LPC_SSP_T              *) LPC_SSP1_BASE)
+#define LPC_TIMER0                ((LPC_TIMER_T            *) LPC_TIMER0_BASE)
+#define LPC_TIMER1                ((LPC_TIMER_T            *) LPC_TIMER1_BASE)
+#define LPC_TIMER2                ((LPC_TIMER_T            *) LPC_TIMER2_BASE)
+#define LPC_TIMER3                ((LPC_TIMER_T            *) LPC_TIMER3_BASE)
+#define LPC_SCU                   ((LPC_SCU_T              *) LPC_SCU_BASE)
+#define LPC_GPIO_PIN_INT          ((LPC_PIN_INT_T          *) LPC_PIN_INT_BASE)
+#define LPC_GPIOGROUP             ((LPC_GPIOGROUPINT_T     *) LPC_GPIO_GROUP_INT0_BASE)
+#define LPC_MCPWM                 ((LPC_MCPWM_T            *) LPC_MCPWM_BASE)
+#define LPC_I2C0                  ((LPC_I2C_T              *) LPC_I2C0_BASE)
+#define LPC_I2C1                  ((LPC_I2C_T              *) LPC_I2C1_BASE)
+#define LPC_I2S0                  ((LPC_I2S_T              *) LPC_I2S0_BASE)
+#define LPC_I2S1                  ((LPC_I2S_T              *) LPC_I2S1_BASE)
+#define LPC_C_CAN1                ((LPC_CCAN_T             *) LPC_C_CAN1_BASE)
+#define LPC_RITIMER               ((LPC_RITIMER_T          *) LPC_RITIMER_BASE)
+#define LPC_QEI                   ((LPC_QEI_T              *) LPC_QEI_BASE)
+#define LPC_GIMA                  ((LPC_GIMA_T             *) LPC_GIMA_BASE)
+#define LPC_DAC                   ((LPC_DAC_T              *) LPC_DAC_BASE)
+#define LPC_C_CAN0                ((LPC_CCAN_T             *) LPC_C_CAN0_BASE)
+#define LPC_ADC0                  ((LPC_ADC_T              *) LPC_ADC0_BASE)
+#define LPC_ADC1                  ((LPC_ADC_T              *) LPC_ADC1_BASE)
+#define LPC_GPIO_PORT             ((LPC_GPIO_T             *) LPC_GPIO_PORT_BASE)
+#define LPC_EEPROM                ((LPC_EEPROM_T           *) LPC_EEPROM_BASE)
+#define LPC_FMCA                  ((LPC_FMC_T              *) LPC_FMCA_BASE)
+#define LPC_FMC                   ((LPC_FMC_T            * *) LPC_FMCA_BASE)
+#define LPC_FMCB                  ((LPC_FMC_T              *) LPC_FMCB_BASE)
+#define LPC_ROM_API               ((LPC_ROM_API_T          *) LPC_ROM_API_BASE)
+
+/**
+ * @}
+ */
+
+#include "scu_18xx_43xx.h"
+#include "clock_18xx_43xx.h"
+#include "rgu_18xx_43xx.h"
+#include "creg_18xx_43xx.h"
+#include "evrt_18xx_43xx.h"
+#include "otp_18xx_43xx.h"
+#include "sdif_18xx_43xx.h"
+#include "adc_18xx_43xx.h"
+#include "atimer_18xx_43xx.h"
+#include "aes_18xx_43xx.h"
+#include "ccan_18xx_43xx.h"
+#include "dac_18xx_43xx.h"
+#include "eeprom_18xx_43xx.h"
+#include "emc_18xx_43xx.h"
+#include "enet_18xx_43xx.h"
+#include "fmc_18xx_43xx.h"
+#include "i2c_18xx_43xx.h"
+#include "i2s_18xx_43xx.h"
+#include "gima_18xx_43xx.h"
+#include "gpdma_18xx_43xx.h"
+#include "gpio_18xx_43xx.h"
+#include "pinint_18xx_43xx.h"
+#include "gpiogroup_18xx_43xx.h"
+#include "lcd_18xx_43xx.h"
+#include "mcpwm_18xx_43xx.h"
+#include "pmc_18xx_43xx.h"
+#include "qei_18xx_43xx.h"
+#include "ritimer_18xx_43xx.h"
+#include "rtc_18xx_43xx.h"
+#include "sct_18xx_43xx.h"
+#include "sct_pwm_18xx_43xx.h"
+#include "sdmmc_18xx_43xx.h"
+#include "ssp_18xx_43xx.h"
+#include "timer_18xx_43xx.h"
+#include "uart_18xx_43xx.h"
+#include "usbhs_18xx_43xx.h"
+#include "wwdt_18xx_43xx.h"
+#include "romapi_18xx_43xx.h"
+#include "i2cm_18xx_43xx.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_LPC18XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/chip_lpc43xx.h ./lpc_chip_43xx/inc/chip_lpc43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/chip_lpc43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/chip_lpc43xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,221 @@
+/*
+ * @brief LPC43xx basic chip inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_LPC43XX_H_
+#define __CHIP_LPC43XX_H_
+
+#include "lpc_types.h"
+#include "sys_config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(CORE_M4) && !defined(CORE_M0)
+#error CORE_M4 or CORE_M0 is not defined for the LPC43xx architecture
+#error CORE_M4 or CORE_M0 should be defined as part of your compiler define list
+#endif
+
+#ifndef CHIP_LPC43XX
+#error The LPC43XX Chip include path is used for this build, but
+#error CHIP_LPC43XX is not defined!
+#endif
+
+/** @defgroup PERIPH_43XX_BASE CHIP: LPC43xx Peripheral addresses and register set declarations
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define LPC_SCT_BASE              0x40000000
+#define LPC_GPDMA_BASE            0x40002000
+#define LPC_SPIFI_BASE            0x40003000
+#define LPC_SDMMC_BASE            0x40004000
+#define LPC_EMC_BASE              0x40005000
+#define LPC_USB0_BASE             0x40006000
+#define LPC_USB1_BASE             0x40007000
+#define LPC_LCD_BASE              0x40008000
+#define LPC_FMCA_BASE             0x4000C000
+#define LPC_FMCB_BASE             0x4000D000
+#define LPC_ETHERNET_BASE         0x40010000
+#define LPC_ATIMER_BASE           0x40040000
+#define LPC_REGFILE_BASE          0x40041000
+#define LPC_PMC_BASE              0x40042000
+#define LPC_CREG_BASE             0x40043000
+#define LPC_EVRT_BASE             0x40044000
+#define LPC_RTC_BASE              0x40046000
+#define LPC_CGU_BASE              0x40050000
+#define LPC_CCU1_BASE             0x40051000
+#define LPC_CCU2_BASE             0x40052000
+#define LPC_RGU_BASE              0x40053000
+#define LPC_WWDT_BASE             0x40080000
+#define LPC_USART0_BASE           0x40081000
+#define LPC_USART2_BASE           0x400C1000
+#define LPC_USART3_BASE           0x400C2000
+#define LPC_UART1_BASE            0x40082000
+#define LPC_SSP0_BASE             0x40083000
+#define LPC_SSP1_BASE             0x400C5000
+#define LPC_TIMER0_BASE           0x40084000
+#define LPC_TIMER1_BASE           0x40085000
+#define LPC_TIMER2_BASE           0x400C3000
+#define LPC_TIMER3_BASE           0x400C4000
+#define LPC_SCU_BASE              0x40086000
+#define LPC_PIN_INT_BASE          0x40087000
+#define LPC_GPIO_GROUP_INT0_BASE  0x40088000
+#define LPC_GPIO_GROUP_INT1_BASE  0x40089000
+#define LPC_MCPWM_BASE            0x400A0000
+#define LPC_I2C0_BASE             0x400A1000
+#define LPC_I2C1_BASE             0x400E0000
+#define LPC_I2S0_BASE             0x400A2000
+#define LPC_I2S1_BASE             0x400A3000
+#define LPC_C_CAN1_BASE           0x400A4000
+#define LPC_RITIMER_BASE          0x400C0000
+#define LPC_QEI_BASE              0x400C6000
+#define LPC_GIMA_BASE             0x400C7000
+#define LPC_DAC_BASE              0x400E1000
+#define LPC_C_CAN0_BASE           0x400E2000
+#define LPC_ADC0_BASE             0x400E3000
+#define LPC_ADC1_BASE             0x400E4000
+#define LPC_ADCHS_BASE            0x400F0000
+#define LPC_GPIO_PORT_BASE        0x400F4000
+#define LPC_SPI_BASE              0x40100000
+#define LPC_SGPIO_BASE            0x40101000
+#define LPC_EEPROM_BASE           0x4000E000
+#define LPC_ROM_API_BASE          0x10400100
+
+#define LPC_SCT                   ((LPC_SCT_T              *) LPC_SCT_BASE)
+#define LPC_GPDMA                 ((LPC_GPDMA_T            *) LPC_GPDMA_BASE)
+#define LPC_SDMMC                 ((LPC_SDMMC_T            *) LPC_SDMMC_BASE)
+#define LPC_EMC                   ((LPC_EMC_T              *) LPC_EMC_BASE)
+#define LPC_USB0                  ((LPC_USBHS_T            *) LPC_USB0_BASE)
+#define LPC_USB1                  ((LPC_USBHS_T            *) LPC_USB1_BASE)
+#define LPC_LCD                   ((LPC_LCD_T              *) LPC_LCD_BASE)
+#define LPC_ETHERNET              ((LPC_ENET_T             *) LPC_ETHERNET_BASE)
+#define LPC_ATIMER                ((LPC_ATIMER_T           *) LPC_ATIMER_BASE)
+#define LPC_REGFILE               ((LPC_REGFILE_T          *) LPC_REGFILE_BASE)
+#define LPC_PMC                   ((LPC_PMC_T              *) LPC_PMC_BASE)
+#define LPC_EVRT                  ((LPC_EVRT_T             *) LPC_EVRT_BASE)
+#define LPC_RTC                   ((LPC_RTC_T              *) LPC_RTC_BASE)
+#define LPC_CGU                   ((LPC_CGU_T              *) LPC_CGU_BASE)
+#define LPC_CCU1                  ((LPC_CCU1_T             *) LPC_CCU1_BASE)
+#define LPC_CCU2                  ((LPC_CCU2_T             *) LPC_CCU2_BASE)
+#define LPC_CREG                  ((LPC_CREG_T             *) LPC_CREG_BASE)
+#define LPC_RGU                   ((LPC_RGU_T              *) LPC_RGU_BASE)
+#define LPC_WWDT                  ((LPC_WWDT_T             *) LPC_WWDT_BASE)
+#define LPC_USART0                ((LPC_USART_T            *) LPC_USART0_BASE)
+#define LPC_USART2                ((LPC_USART_T            *) LPC_USART2_BASE)
+#define LPC_USART3                ((LPC_USART_T            *) LPC_USART3_BASE)
+#define LPC_UART1                 ((LPC_USART_T            *) LPC_UART1_BASE)
+#define LPC_SSP0                  ((LPC_SSP_T              *) LPC_SSP0_BASE)
+#define LPC_SSP1                  ((LPC_SSP_T              *) LPC_SSP1_BASE)
+#define LPC_TIMER0                ((LPC_TIMER_T            *) LPC_TIMER0_BASE)
+#define LPC_TIMER1                ((LPC_TIMER_T            *) LPC_TIMER1_BASE)
+#define LPC_TIMER2                ((LPC_TIMER_T            *) LPC_TIMER2_BASE)
+#define LPC_TIMER3                ((LPC_TIMER_T            *) LPC_TIMER3_BASE)
+#define LPC_SCU                   ((LPC_SCU_T              *) LPC_SCU_BASE)
+#define LPC_GPIO_PIN_INT          ((LPC_PIN_INT_T          *) LPC_PIN_INT_BASE)
+#define LPC_GPIOGROUP             ((LPC_GPIOGROUPINT_T     *) LPC_GPIO_GROUP_INT0_BASE)
+#define LPC_MCPWM                 ((LPC_MCPWM_T            *) LPC_MCPWM_BASE)
+#define LPC_I2C0                  ((LPC_I2C_T              *) LPC_I2C0_BASE)
+#define LPC_I2C1                  ((LPC_I2C_T              *) LPC_I2C1_BASE)
+#define LPC_I2S0                  ((LPC_I2S_T              *) LPC_I2S0_BASE)
+#define LPC_I2S1                  ((LPC_I2S_T              *) LPC_I2S1_BASE)
+#define LPC_C_CAN1                ((LPC_CCAN_T             *) LPC_C_CAN1_BASE)
+#define LPC_RITIMER               ((LPC_RITIMER_T          *) LPC_RITIMER_BASE)
+#define LPC_QEI                   ((LPC_QEI_T              *) LPC_QEI_BASE)
+#define LPC_GIMA                  ((LPC_GIMA_T             *) LPC_GIMA_BASE)
+#define LPC_DAC                   ((LPC_DAC_T              *) LPC_DAC_BASE)
+#define LPC_C_CAN0                ((LPC_CCAN_T             *) LPC_C_CAN0_BASE)
+#define LPC_ADC0                  ((LPC_ADC_T              *) LPC_ADC0_BASE)
+#define LPC_ADC1                  ((LPC_ADC_T              *) LPC_ADC1_BASE)
+#define LPC_ADCHS                 ((LPC_HSADC_T            *) LPC_ADCHS_BASE)
+#define LPC_GPIO_PORT             ((LPC_GPIO_T             *) LPC_GPIO_PORT_BASE)
+#define LPC_SPI                   ((LPC_SPI_T              *) LPC_SPI_BASE)
+#define LPC_SGPIO                 ((LPC_SGPIO_T            *) LPC_SGPIO_BASE)
+#define LPC_EEPROM                ((LPC_EEPROM_T           *) LPC_EEPROM_BASE)
+#define LPC_FMCA                  ((LPC_FMC_T              *) LPC_FMCA_BASE)
+#define LPC_FMC                   ((LPC_FMC_T            * *) LPC_FMCA_BASE)
+#define LPC_FMCB                  ((LPC_FMC_T              *) LPC_FMCB_BASE)
+#define LPC_ROM_API               ((LPC_ROM_API_T          *) LPC_ROM_API_BASE)
+
+/**
+ * @}
+ */
+
+#include "scu_18xx_43xx.h"
+#include "clock_18xx_43xx.h"
+#include "rgu_18xx_43xx.h"
+#include "creg_18xx_43xx.h"
+#include "evrt_18xx_43xx.h"
+#include "otp_18xx_43xx.h"
+#include "sdif_18xx_43xx.h"
+#include "adc_18xx_43xx.h"
+#include "hsadc_18xx_43xx.h"
+#include "atimer_18xx_43xx.h"
+#include "aes_18xx_43xx.h"
+#include "ccan_18xx_43xx.h"
+#include "dac_18xx_43xx.h"
+#include "eeprom_18xx_43xx.h"
+#include "emc_18xx_43xx.h"
+#include "enet_18xx_43xx.h"
+#include "fmc_18xx_43xx.h"
+#include "i2c_18xx_43xx.h"
+#include "i2s_18xx_43xx.h"
+#include "gima_18xx_43xx.h"
+#include "gpdma_18xx_43xx.h"
+#include "gpio_18xx_43xx.h"
+#include "pinint_18xx_43xx.h"
+#include "gpiogroup_18xx_43xx.h"
+#include "lcd_18xx_43xx.h"
+#include "mcpwm_18xx_43xx.h"
+#include "pmc_18xx_43xx.h"
+#include "qei_18xx_43xx.h"
+#include "ritimer_18xx_43xx.h"
+#include "rtc_18xx_43xx.h"
+#include "sct_18xx_43xx.h"
+#include "sct_pwm_18xx_43xx.h"
+#include "sdmmc_18xx_43xx.h"
+#include "sdio_18xx_43xx.h"
+#include "sgpio_18xx_43xx.h"
+#include "spi_18xx_43xx.h"
+#include "ssp_18xx_43xx.h"
+#include "timer_18xx_43xx.h"
+#include "uart_18xx_43xx.h"
+#include "usbhs_18xx_43xx.h"
+#include "wwdt_18xx_43xx.h"
+#include "romapi_18xx_43xx.h"
+#include "i2cm_18xx_43xx.h"
+
+#if defined(CORE_M4)
+#include "fpu_init.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_LPC43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/clock_18xx_43xx.h ./lpc_chip_43xx/inc/clock_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/clock_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/clock_18xx_43xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,394 @@
+/*
+ * @brief LPC18xx/43xx clock driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CLOCK_18XX_43XX_H_
+#define __CLOCK_18XX_43XX_H_
+
+#include "cguccu_18xx_43xx.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CLOCK_18XX_43XX CHIP: LPC18xx/43xx Clock Driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/** @defgroup CLOCK_18XX_43XX_OPTIONS CHIP: LPC18xx/43xx Clock Driver driver options
+ * @ingroup CLOCK_18XX_43XX CHIP_18XX_43XX_DRIVER_OPTIONS
+ * The clock driver has options that configure it's operation at build-time.<br>
+ *
+ * <b>MAX_CLOCK_FREQ</b><br>
+ * This macro defines the maximum frequency supported by the Chip [204MHz for LPC43xx
+ * 180MHz for LPC18xx]. API Chip_SetupXtalClocking() and Chip_SetupIrcClocking() will
+ * use this macro to set the CPU Core frequency to the maximum supported.<br>
+ * To set a Core frequency other than the maximum frequency Chip_SetupCoreClock() API
+ * must be used. <b>Using this macro to set the Core freqency is not recommended.</b>
+ * @{
+ */
+
+/**
+ * @}
+ */
+
+/* Internal oscillator frequency */
+#define CGU_IRC_FREQ (12000000)
+
+#ifndef MAX_CLOCK_FREQ
+#if defined(CHIP_LPC43XX)
+#define MAX_CLOCK_FREQ (204000000)
+#else
+#define MAX_CLOCK_FREQ (180000000)
+#endif
+#endif
+
+#define PLL_MIN_CCO_FREQ 156000000  /**< Min CCO frequency of main PLL */
+#define PLL_MAX_CCO_FREQ 320000000  /**< Max CCO frequency of main PLL */
+
+/**
+ * @brief  PLL Parameter strucutre
+ */
+typedef struct {
+   int ctrl;       /**< Control register value */
+   CHIP_CGU_CLKIN_T srcin; /**< Input clock Source see #CHIP_CGU_CLKIN_T */
+   int nsel;       /**< Pre-Div value */
+   int psel;       /**< Post-Div Value */
+   int msel;       /**< M-Div value */
+   uint32_t fin;   /**< Input frequency */
+   uint32_t fout;  /**< Output frequency */
+   uint32_t fcco;  /**< CCO frequency */
+} PLL_PARAM_T;
+
+/**
+ * @brief  Enables the crystal oscillator
+ * @return Nothing
+ */
+void Chip_Clock_EnableCrystal(void);
+
+/**
+ * @brief  Disables the crystal oscillator
+ * @return Nothing
+ */
+void Chip_Clock_DisableCrystal(void);
+
+/**
+ * @brief   Configures the main PLL
+ * @param   Input      : Which clock input to use as the PLL input
+ * @param   MinHz      : Minimum allowable PLL output frequency
+ * @param   DesiredHz  : Desired PLL output frequency
+ * @param   MaxHz      : Maximum allowable PLL output frequency
+ * @return Frequency of the PLL in Hz
+ * Returns the configured PLL frequency or zero if the PLL can not be configured between MinHz
+ * and MaxHz. This will not wait for PLL lock. Call Chip_Clock_MainPLLLocked() to determine if
+ * the PLL is locked.
+ */
+uint32_t Chip_Clock_SetupMainPLLHz(CHIP_CGU_CLKIN_T Input, uint32_t MinHz, uint32_t DesiredHz, uint32_t MaxHz);
+
+/**
+ * @brief  Directly set the PLL multipler
+ * @param   Input  : Which clock input to use as the PLL input
+ * @param  mult    : How many times to multiply the input clock
+ * @return Frequency of the PLL in Hz
+ */
+uint32_t Chip_Clock_SetupMainPLLMult(CHIP_CGU_CLKIN_T Input, uint32_t mult);
+
+/**
+ * @brief   Returns the frequency of the main PLL
+ * @return Frequency of the PLL in Hz
+ * Returns zero if the main PLL is not running.
+ */
+uint32_t Chip_Clock_GetMainPLLHz(void);
+
+/**
+ * @brief  Disables the main PLL
+ * @return none
+ * Make sure the main PLL is not needed to clock the part before disabling it.
+ * Saves power if the main PLL is not needed.
+ */
+__STATIC_INLINE void Chip_Clock_DisableMainPLL(void)
+{
+   /* power down main PLL */
+   LPC_CGU->PLL1_CTRL |= 1;
+}
+
+/**
+ * @brief  Enbles the main PLL
+ * @return none
+ * Make sure the main PLL is enabled.
+ */
+__STATIC_INLINE void Chip_Clock_EnableMainPLL(void)
+{
+   /* power up main PLL */
+   LPC_CGU->PLL1_CTRL &= ~1;
+}
+/**
+ * @brief  Sets-up the main PLL
+ * @param  ppll    : Pointer to pll param structure #PLL_PARAM_T
+ * @return none
+ * Make sure the main PLL is enabled.
+ */
+__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
+{
+   /* power up main PLL */
+   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
+}
+
+/**
+ * @brief  Sets up a CGU clock divider and it's input clock
+ * @param  Divider : CHIP_CGU_IDIV_T value indicating which divider to configure
+ * @param  Input   : CHIP_CGU_CLKIN_T value indicating which clock source to use or CLOCKINPUT_PD to power down divider
+ * @param  Divisor : value to divide Input clock by
+ * @return Nothing
+ * Maximum divider on A = 4, B/C/D = 16, E = 256.
+ * See the user manual for allowable combinations for input clock.
+ */
+void Chip_Clock_SetDivider(CHIP_CGU_IDIV_T Divider, CHIP_CGU_CLKIN_T Input, uint32_t Divisor);
+
+/**
+ * @brief  Gets a CGU clock divider source
+ * @param  Divider : CHIP_CGU_IDIV_T value indicating which divider to get the source of
+ * @return CHIP_CGU_CLKIN_T indicating which clock source is set or CLOCKINPUT_PD
+ */
+CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider);
+
+/**
+ * @brief  Gets a CGU clock divider divisor
+ * @param  Divider : CHIP_CGU_IDIV_T value indicating which divider to get the source of
+ * @return the divider value for the divider
+ */
+uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider);
+
+/**
+ * @brief  Returns the frequency of the specified input clock source
+ * @param  input   : Which clock input to return the frequency of
+ * @return Frequency of input source in Hz
+ * This function returns an ideal frequency and not the actual frequency. Returns
+ * zero if the clock source is disabled.
+ */
+uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input);
+
+/**
+ * @brief  Returns the frequency of the specified base clock source
+ * @param  clock   : which base clock to return the frequency of.
+ * @return Frequency of base source in Hz
+ * This function returns an ideal frequency and not the actual frequency. Returns
+ * zero if the clock source is disabled.
+ */
+uint32_t Chip_Clock_GetBaseClocktHz(CHIP_CGU_BASE_CLK_T clock);
+
+/**
+ * @brief  Sets a CGU Base Clock clock source
+ * @param  BaseClock   : CHIP_CGU_BASE_CLK_T value indicating which base clock to set
+ * @param  Input       : CHIP_CGU_CLKIN_T value indicating which clock source to use or CLOCKINPUT_PD to power down base clock
+ * @param  autoblocken : Enables autoblocking during frequency change if true
+ * @param  powerdn     : The clock base is setup, but powered down if true
+ * @return Nothing
+ */
+void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn);
+
+/**
+ * @brief  Get CGU Base Clock clock source information
+ * @param  BaseClock   : CHIP_CGU_BASE_CLK_T value indicating which base clock to get
+ * @param  Input       : Pointer to CHIP_CGU_CLKIN_T value of the base clock
+ * @param  autoblocken : Pointer to autoblocking value of the base clock
+ * @param  powerdn     : Pointer to power down flag
+ * @return Nothing
+ */
+void Chip_Clock_GetBaseClockOpts(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T *Input, bool *autoblocken,
+                                bool *powerdn);
+
+/**
+ * @brief  Gets a CGU Base Clock clock source
+ * @param  BaseClock   : CHIP_CGU_BASE_CLK_T value indicating which base clock to get inpuot clock for
+ * @return CHIP_CGU_CLKIN_T indicating which clock source is set or CLOCKINPUT_PD
+ */
+CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief  Enables a base clock source
+ * @param  BaseClock   : CHIP_CGU_BASE_CLK_T value indicating which base clock to enable
+ * @return Nothing
+ */
+void Chip_Clock_EnableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief  Disables a base clock source
+ * @param  BaseClock   : CHIP_CGU_BASE_CLK_T value indicating which base clock to disable
+ * @return Nothing
+ */
+void Chip_Clock_DisableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief  Returns base clock enable state
+ * @param  BaseClock   : CHIP_CGU_BASE_CLK_T value indicating which base clock to check
+ * @return true if the base clock is enabled, false if disabled
+ */
+bool Chip_Clock_IsBaseClockEnabled(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief  Enables a peripheral clock and sets clock states
+ * @param  clk         : CHIP_CCU_CLK_T value indicating which clock to enable
+ * @param  autoen      : true to enable autoblocking on a clock rate change, false to disable
+ * @param  wakeupen    : true to enable wakeup mechanism, false to disable
+ * @param  div         : Divider for the clock, must be 1 for most clocks, 2 supported on others
+ * @return Nothing
+ */
+void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div);
+
+/**
+ * @brief  Enables a peripheral clock
+ * @param  clk : CHIP_CCU_CLK_T value indicating which clock to enable
+ * @return Nothing
+ */
+void Chip_Clock_Enable(CHIP_CCU_CLK_T clk);
+
+/**
+ * @brief  Enables RTCclock
+ * @return Nothing
+ */
+void Chip_Clock_RTCEnable(void);
+
+/**
+ * @brief  Disables a peripheral clock
+ * @param  clk : CHIP_CCU_CLK_T value indicating which clock to disable
+ * @return Nothing
+ */
+void Chip_Clock_Disable(CHIP_CCU_CLK_T clk);
+
+/**
+ * @brief  Returns a peripheral clock rate
+ * @param  clk : CHIP_CCU_CLK_T value indicating which clock to get rate for
+ * @return 0 if the clock is disabled, or the rate of the clock
+ */
+uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk);
+
+/**
+ * @brief  Returns EMC clock rate
+ * @return 0 if the clock is disabled, or the rate of the clock
+ */
+uint32_t Chip_Clock_GetEMCRate(void);
+
+/**
+ * @brief  Start the power down sequence by disabling the branch output
+ *          clocks with wake up mechanism (Only the clocks which
+ *          wake up mechanism bit enabled will be disabled)
+ * @return Nothing
+ */
+void Chip_Clock_StartPowerDown(void);
+
+/**
+ * @brief  Clear the power down mode bit & proceed normal operation of branch output
+ *          clocks (Only the clocks which wake up mechanism bit enabled will be
+ *          enabled after the wake up event)
+ * @return Nothing
+ */
+void Chip_Clock_ClearPowerDown(void);
+
+/**
+ * Structure for setting up the USB or audio PLL
+ */
+typedef struct {
+   uint32_t ctrl;      /* Default control word for PLL */
+   uint32_t mdiv;      /* Default M-divider value for PLL */
+   uint32_t ndiv;      /* Default NP-divider value for PLL */
+   uint32_t fract;     /* Default fractional value for audio PLL only */
+   uint32_t freq;      /* Output frequency of the pll */
+} CGU_USBAUDIO_PLL_SETUP_T;
+
+/**
+ * @brief  Sets up the audio or USB PLL
+ * @param  Input       : Input clock
+ * @param  pllnum      : PLL identifier
+ * @param  pPLLSetup   : Pointer to PLL setup structure
+ * @return Nothing
+ * Sets up the PLL with the passed structure values.
+ */
+void Chip_Clock_SetupPLL(CHIP_CGU_CLKIN_T Input, CHIP_CGU_USB_AUDIO_PLL_T pllnum,
+                        const CGU_USBAUDIO_PLL_SETUP_T *pPLLSetup);
+
+/**
+ * @brief  Enables the audio or USB PLL
+ * @param  pllnum  : PLL identifier
+ * @return Nothing
+ */
+void Chip_Clock_EnablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum);
+
+/**
+ * @brief  Disables the audio or USB PLL
+ * @param  pllnum  : PLL identifier
+ * @return Nothing
+ */
+void Chip_Clock_DisablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum);
+
+#define CGU_PLL_LOCKED (1 << 0)    /* PLL locked status */
+#define CGU_PLL_FR     (1 << 1)    /* PLL free running indicator status */
+
+/**
+ * @brief  Returns the PLL status
+ * @param  pllnum  : PLL identifier
+ * @return An OR'ed value of CGU_PLL_LOCKED or CGU_PLL_FR
+ */
+uint32_t Chip_Clock_GetPLLStatus(CHIP_CGU_USB_AUDIO_PLL_T pllnum);
+
+/**
+ * @brief  Calculate main PLL Pre, Post and M div values
+ * @param  freq    : Expected output frequency
+ * @param  ppll    : Pointer to #PLL_PARAM_T structure
+ * @return 0 on success; < 0 on failure
+ * @note
+ * ppll->srcin[IN] should have the appropriate Input clock source selected<br>
+ * ppll->fout[OUT] will have the actual output frequency<br>
+ * ppll->fcco[OUT] will have the frequency of CCO
+ */
+int Chip_Clock_CalcMainPLLValue(uint32_t freq, PLL_PARAM_T *ppll);
+
+
+/**
+ * @brief  Wait for Main PLL to be locked
+ * @return 1 - PLL is LOCKED; 0 - PLL is not locked
+ * @note   The main PLL should be locked prior to using it as a clock input for a base clock.
+ */
+__STATIC_INLINE int Chip_Clock_MainPLLLocked(void)
+{
+   /* Return true if locked */
+   return (LPC_CGU->PLL1_STAT & 1) != 0;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CLOCK_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/cmsis_43xx.h ./lpc_chip_43xx/inc/cmsis_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/cmsis_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/cmsis_43xx.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,167 @@
+/*
+ * @brief Basic CMSIS include file for LPC43XX
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_43XX_M0_H_
+#define __CMSIS_43XX_M0_H_
+
+#ifndef __CMSIS_H_
+#error "cmsis_43xx.h should not be included directly use cmsis.h instead"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_43XX CHIP: LPC43xx CMSIS include file
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/** @defgroup CMSIS_43XX_COMMON CHIP: LPC43xx Cortex CMSIS definitions
+ * @{
+ */
+
+#define __CM4_REV              0x0001      /*!< Cortex-M4 Core Revision               */
+#define __MPU_PRESENT             1            /*!< MPU present or not                    */
+#define __NVIC_PRIO_BITS          3            /*!< Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0            /*!< Set to 1 if different SysTick Config is used */
+#define __FPU_PRESENT             1            /*!< FPU present or not                    */
+
+/**
+ * @}
+ */
+
+/** @defgroup CMSIS_43XX_IRQ CHIP: LPC43xx peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+   /* -------------------------  Cortex-M4 Processor Exceptions Numbers  ----------------------------- */
+   Reset_IRQn                        = -15,/*!<   1  Reset Vector, invoked on Power up and warm reset */
+   NonMaskableInt_IRQn               = -14,/*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
+   HardFault_IRQn                    = -13,/*!<   3  Hard Fault, all classes of Fault */
+   MemoryManagement_IRQn             = -12,/*!<   4  Memory Management, MPU mismatch, including Access Violation and No Match */
+   BusFault_IRQn                     = -11,/*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault */
+   UsageFault_IRQn                   = -10,/*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition */
+   SVCall_IRQn                       =  -5,/*!<  11  System Service Call via SVC instruction */
+   DebugMonitor_IRQn                 =  -4,/*!<  12  Debug Monitor                    */
+   PendSV_IRQn                       =  -2,/*!<  14  Pendable request for system service */
+   SysTick_IRQn                      =  -1,/*!<  15  System Tick Timer                */
+
+   /* ---------------------------  LPC18xx/43xx Specific Interrupt Numbers  ------------------------------- */
+   DAC_IRQn                          =   0,/*!<   0  DAC                              */
+   M0APP_IRQn                        =   1,/*!<   1  M0APP Core interrupt             */
+   DMA_IRQn                          =   2,/*!<   2  DMA                              */
+   RESERVED1_IRQn                    =   3,/*!<   3  EZH/EDM                          */
+   RESERVED2_IRQn                    =   4,
+   ETHERNET_IRQn                     =   5,/*!<   5  ETHERNET                         */
+   SDIO_IRQn                         =   6,/*!<   6  SDIO                             */
+   LCD_IRQn                          =   7,/*!<   7  LCD                              */
+   USB0_IRQn                         =   8,/*!<   8  USB0                             */
+   USB1_IRQn                         =   9,/*!<   9  USB1                             */
+   SCT_IRQn                          =  10,/*!<  10  SCT                              */
+   RITIMER_IRQn                      =  11,/*!<  11  RITIMER                          */
+   TIMER0_IRQn                       =  12,/*!<  12  TIMER0                           */
+   TIMER1_IRQn                       =  13,/*!<  13  TIMER1                           */
+   TIMER2_IRQn                       =  14,/*!<  14  TIMER2                           */
+   TIMER3_IRQn                       =  15,/*!<  15  TIMER3                           */
+   MCPWM_IRQn                        =  16,/*!<  16  MCPWM                            */
+   ADC0_IRQn                         =  17,/*!<  17  ADC0                             */
+   I2C0_IRQn                         =  18,/*!<  18  I2C0                             */
+   I2C1_IRQn                         =  19,/*!<  19  I2C1                             */
+   SPI_INT_IRQn                      =  20,/*!<  20  SPI_INT                          */
+   ADC1_IRQn                         =  21,/*!<  21  ADC1                             */
+   SSP0_IRQn                         =  22,/*!<  22  SSP0                             */
+   SSP1_IRQn                         =  23,/*!<  23  SSP1                             */
+   USART0_IRQn                       =  24,/*!<  24  USART0                           */
+   UART1_IRQn                        =  25,/*!<  25  UART1                            */
+   USART2_IRQn                       =  26,/*!<  26  USART2                           */
+   USART3_IRQn                       =  27,/*!<  27  USART3                           */
+   I2S0_IRQn                         =  28,/*!<  28  I2S0                             */
+   I2S1_IRQn                         =  29,/*!<  29  I2S1                             */
+   RESERVED4_IRQn                    =  30,
+   SGPIO_INT_IRQn                    =  31,/*!<  31  SGPIO_IINT                       */
+   PIN_INT0_IRQn                     =  32,/*!<  32  PIN_INT0                         */
+   PIN_INT1_IRQn                     =  33,/*!<  33  PIN_INT1                         */
+   PIN_INT2_IRQn                     =  34,/*!<  34  PIN_INT2                         */
+   PIN_INT3_IRQn                     =  35,/*!<  35  PIN_INT3                         */
+   PIN_INT4_IRQn                     =  36,/*!<  36  PIN_INT4                         */
+   PIN_INT5_IRQn                     =  37,/*!<  37  PIN_INT5                         */
+   PIN_INT6_IRQn                     =  38,/*!<  38  PIN_INT6                         */
+   PIN_INT7_IRQn                     =  39,/*!<  39  PIN_INT7                         */
+   GINT0_IRQn                        =  40,/*!<  40  GINT0                            */
+   GINT1_IRQn                        =  41,/*!<  41  GINT1                            */
+   EVENTROUTER_IRQn                  =  42,/*!<  42  EVENTROUTER                      */
+   C_CAN1_IRQn                       =  43,/*!<  43  C_CAN1                           */
+   RESERVED6_IRQn                    =  44,
+   ADCHS_IRQn                        =  45,/*!<  45  ADCHS interrupt                  */
+   ATIMER_IRQn                       =  46,/*!<  46  ATIMER                           */
+   RTC_IRQn                          =  47,/*!<  47  RTC                              */
+   RESERVED8_IRQn                    =  48,
+   WWDT_IRQn                         =  49,/*!<  49  WWDT                             */
+   M0SUB_IRQn                        =  50,/*!<  50  M0SUB core interrupt             */
+   C_CAN0_IRQn                       =  51,/*!<  51  C_CAN0                           */
+   QEI_IRQn                          =  52,/*!<  52  QEI                              */
+} LPC43XX_IRQn_Type;
+
+/**
+ * @}
+ */
+
+typedef LPC43XX_IRQn_Type IRQn_Type;
+
+/* Cortex-M4 processor and core peripherals */
+#include "core_cm4.h"
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef __CMSIS_43XX_M0_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/cmsis.h ./lpc_chip_43xx/inc/cmsis.h
--- a_qSC69Z/lpc_chip_43xx/inc/cmsis.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/cmsis.h	2018-01-19 23:55:10.960318308 -0300
@@ -0,0 +1,63 @@
+/*
+ * @brief LPC11xx selective CMSIS inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_H_
+#define __CMSIS_H_
+
+#include "lpc_types.h"
+#include "sys_config.h"
+
+/* Select correct CMSIS include file based on CHIP_* definition */
+#if defined(CHIP_LPC43XX)
+
+#ifdef CORE_M4
+#include "cmsis_43xx.h"
+
+#elif defined(CORE_M0)
+#if defined(LPC43XX_CORE_M0APP)
+#include "cmsis_43xx_m0app.h"
+
+#elif (defined(LPC43XX_CORE_M0SUB))
+#include "cmsis_43xx_m0sub.h"
+
+#else
+#error "LPC43XX_CORE_M0APP or LPC43XX_CORE_M0SUB must be defined"
+#endif
+
+#else
+#error "CORE_M0 or CORE_M4 must be defined for CHIP_LPC43XX"
+#endif
+
+#elif defined(CHIP_LPC18XX)
+#include "cmsis_18xx.h"
+
+#else
+#error "No CHIP_* definition is defined"
+#endif
+
+#endif /* __CMSIS_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/core_cm4.h ./lpc_chip_43xx/inc/core_cm4.h
--- a_qSC69Z/lpc_chip_43xx/inc/core_cm4.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/core_cm4.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,1772 @@
+/**************************************************************************//**
+ * @file     core_cm4.h
+ * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_H_GENERIC
+#define __CORE_CM4_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex_M4
+  @{
+ */
+
+/*  CMSIS CM4 definitions */
+#define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
+#define __CM4_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
+                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TMS470__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
+*/
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TMS470__ )
+  #if defined __TI_VFP_SUPPORT__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+#include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
+
+#endif /* __CORE_CM4_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM4_H_DEPENDANT
+#define __CORE_CM4_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM4_REV
+    #define __CM4_REV               0x0000
+    #warning "__CM4_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __FPU_PRESENT
+    #define __FPU_PRESENT             0
+    #warning "__FPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          4
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex_M4 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core Debug Register
+  - Core MPU Register
+  - Core FPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+
+/* Software Triggered Interrupt Register Definitions */
+#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
+#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
+  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
+  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
+  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
+  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
+  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
+       uint32_t RESERVED0[5];
+  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Vector Table Offset Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
+  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
+} SCnSCB_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
+#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
+
+/* Auxiliary Control Register Definitions */
+#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
+#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
+
+#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
+#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
+
+#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
+#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
+
+#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
+#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
+
+#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
+#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
+    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+
+/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
+  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
+  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
+  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
+#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+
+/*@}*/ /* end of group CMSIS_ITM */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
+    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
+  @{
+ */
+
+/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
+  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
+  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
+  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
+  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
+  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
+  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
+  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
+  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
+  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
+  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
+       uint32_t RESERVED0[1];
+  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
+  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
+  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
+       uint32_t RESERVED1[1];
+  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
+  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
+  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
+       uint32_t RESERVED2[1];
+  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
+  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
+  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
+} DWT_Type;
+
+/* DWT Control Register Definitions */
+#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
+#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
+
+#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
+#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
+
+#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
+#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
+
+#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
+#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
+
+#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
+#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
+
+#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
+#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
+
+#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
+#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
+
+#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
+#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
+
+#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
+#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
+
+#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
+#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
+
+#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
+#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
+
+#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
+#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
+
+#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
+#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
+
+#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
+#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
+
+#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
+#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
+
+#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
+#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
+
+#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
+#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
+
+#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
+#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
+
+/* DWT CPI Count Register Definitions */
+#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
+#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
+
+/* DWT Exception Overhead Count Register Definitions */
+#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
+#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
+
+/* DWT Sleep Count Register Definitions */
+#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
+#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
+
+/* DWT LSU Count Register Definitions */
+#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
+#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
+
+/* DWT Folded-instruction Count Register Definitions */
+#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
+#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
+
+/* DWT Comparator Mask Register Definitions */
+#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
+#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
+
+/* DWT Comparator Function Register Definitions */
+#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
+#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
+
+#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
+#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
+
+#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
+#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
+
+#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
+#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
+
+#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
+#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
+
+#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
+#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
+
+#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
+#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
+
+#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
+#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
+
+#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
+#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
+
+/*@}*/ /* end of group CMSIS_DWT */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
+    \brief      Type definitions for the Trace Port Interface (TPI)
+  @{
+ */
+
+/** \brief  Structure type to access the Trace Port Interface Register (TPI).
+ */
+typedef struct
+{
+  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
+  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
+       uint32_t RESERVED1[55];
+  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
+       uint32_t RESERVED2[131];
+  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
+  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
+  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
+       uint32_t RESERVED3[759];
+  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
+  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
+  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
+       uint32_t RESERVED4[1];
+  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
+  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
+  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
+       uint32_t RESERVED5[39];
+  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
+  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
+       uint32_t RESERVED7[8];
+  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
+  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
+} TPI_Type;
+
+/* TPI Asynchronous Clock Prescaler Register Definitions */
+#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
+#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
+
+/* TPI Selected Pin Protocol Register Definitions */
+#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
+#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
+
+/* TPI Formatter and Flush Status Register Definitions */
+#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
+#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
+
+#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
+#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
+
+#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
+#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
+
+#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
+#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
+
+/* TPI Formatter and Flush Control Register Definitions */
+#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
+#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
+
+#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
+#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
+
+/* TPI TRIGGER Register Definitions */
+#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
+#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
+
+/* TPI Integration ETM Data Register Definitions (FIFO0) */
+#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
+#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
+
+#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
+#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
+
+#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
+#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
+
+#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
+#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
+
+#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
+#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
+
+#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
+#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
+
+#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
+#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
+
+/* TPI ITATBCTR2 Register Definitions */
+#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
+#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
+
+/* TPI Integration ITM Data Register Definitions (FIFO1) */
+#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
+#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
+
+#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
+#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
+
+#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
+#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
+
+#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
+#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
+
+#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
+#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
+
+#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
+#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
+
+#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
+#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
+
+/* TPI ITATBCTR0 Register Definitions */
+#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
+#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
+
+/* TPI Integration Mode Control Register Definitions */
+#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
+#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
+
+/* TPI DEVID Register Definitions */
+#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
+#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
+
+#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
+#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
+
+#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
+#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
+
+#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
+#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
+
+#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
+#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
+
+#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
+#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
+
+/* TPI DEVTYPE Register Definitions */
+#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
+#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
+
+#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
+#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
+
+/*@}*/ /* end of group CMSIS_TPI */
+
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+#if (__FPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
+    \brief      Type definitions for the Floating Point Unit (FPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Floating Point Unit (FPU).
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
+  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
+  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
+  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
+  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
+} FPU_Type;
+
+/* Floating-Point Context Control Register */
+#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
+#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
+
+#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
+#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
+
+#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
+#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
+
+#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
+#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
+
+#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
+#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
+
+#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
+#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
+
+#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
+#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
+
+#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
+#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
+
+#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
+#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
+
+/* Floating-Point Context Address Register */
+#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
+#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
+
+/* Floating-Point Default Status Control Register */
+#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
+#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
+
+#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
+#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
+
+#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
+#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
+
+#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
+#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
+
+/* Media and FP Feature Register 0 */
+#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
+#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
+
+#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
+#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
+
+#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
+#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
+
+#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
+#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
+
+#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
+#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
+
+#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
+#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
+
+#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
+#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
+
+#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
+#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
+
+/* Media and FP Feature Register 1 */
+#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
+#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
+
+#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
+#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
+
+#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
+#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
+
+#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
+#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
+
+/*@} end of group CMSIS_FPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Type definitions for the Core Debug Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Core Debug Register (CoreDebug).
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M4 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
+#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
+#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
+#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
+#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
+#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
+#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+#if (__FPU_PRESENT == 1)
+  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
+  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Debug Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/** \brief  Set Priority Grouping
+
+  The function sets the priority grouping field using the required unlock sequence.
+  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
+  Only values from 0..7 are used.
+  In case of a conflict between priority grouping and available
+  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
+
+    \param [in]      PriorityGroup  Priority grouping field.
+ */
+__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                                 |
+                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+
+/** \brief  Get Priority Grouping
+
+  The function reads the priority grouping field from the NVIC Interrupt Controller.
+
+    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
+  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Get Active Interrupt
+
+    The function reads the active register in NVIC and returns the active bit.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not active.
+    \return             1  Interrupt status is active.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  Encode Priority
+
+    The function encodes the priority for an interrupt with the given priority group,
+    preemptive priority value, and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
+
+    \param [in]     PriorityGroup  Used priority group.
+    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
+    \param [in]       SubPriority  Subpriority value (starting from 0).
+    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
+ */
+__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/** \brief  Decode Priority
+
+    The function decodes an interrupt priority value with a given priority group to
+    preemptive priority value and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+
+    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
+    \param [in]     PriorityGroup  Used priority group.
+    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
+    \param [out]     pSubPriority  Subpriority value (starting from 0).
+ */
+__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_core_DebugFunctions ITM Functions
+    \brief   Functions that access the ITM debug interface.
+  @{
+ */
+
+extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
+#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
+
+
+/** \brief  ITM Send Character
+
+    The function transmits a character via the ITM channel 0, and
+    \li Just returns when no debugger is connected that has booked the output.
+    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
+
+    \param [in]     ch  Character to transmit.
+
+    \returns            Character to transmit.
+ */
+__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/** \brief  ITM Receive Character
+
+    The function inputs a character via the external variable \ref ITM_RxBuffer.
+
+    \return             Received character.
+    \return         -1  No character pending.
+ */
+__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
+  int32_t ch = -1;                           /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/** \brief  ITM Check Character
+
+    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
+
+    \return          0  No character available.
+    \return          1  Character available.
+ */
+__STATIC_INLINE int32_t ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@} end of CMSIS_core_DebugFunctions */
+
+#endif /* __CORE_CM4_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/core_cm4_simd.h ./lpc_chip_43xx/inc/core_cm4_simd.h
--- a_qSC69Z/lpc_chip_43xx/inc/core_cm4_simd.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/core_cm4_simd.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,673 @@
+/**************************************************************************//**
+ * @file     core_cm4_simd.h
+ * @brief    CMSIS Cortex-M4 SIMD Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_SIMD_H
+#define __CORE_CM4_SIMD_H
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+ ******************************************************************************/
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
+  Access to dedicated SIMD instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#define __SADD8                           __sadd8
+#define __QADD8                           __qadd8
+#define __SHADD8                          __shadd8
+#define __UADD8                           __uadd8
+#define __UQADD8                          __uqadd8
+#define __UHADD8                          __uhadd8
+#define __SSUB8                           __ssub8
+#define __QSUB8                           __qsub8
+#define __SHSUB8                          __shsub8
+#define __USUB8                           __usub8
+#define __UQSUB8                          __uqsub8
+#define __UHSUB8                          __uhsub8
+#define __SADD16                          __sadd16
+#define __QADD16                          __qadd16
+#define __SHADD16                         __shadd16
+#define __UADD16                          __uadd16
+#define __UQADD16                         __uqadd16
+#define __UHADD16                         __uhadd16
+#define __SSUB16                          __ssub16
+#define __QSUB16                          __qsub16
+#define __SHSUB16                         __shsub16
+#define __USUB16                          __usub16
+#define __UQSUB16                         __uqsub16
+#define __UHSUB16                         __uhsub16
+#define __SASX                            __sasx
+#define __QASX                            __qasx
+#define __SHASX                           __shasx
+#define __UASX                            __uasx
+#define __UQASX                           __uqasx
+#define __UHASX                           __uhasx
+#define __SSAX                            __ssax
+#define __QSAX                            __qsax
+#define __SHSAX                           __shsax
+#define __USAX                            __usax
+#define __UQSAX                           __uqsax
+#define __UHSAX                           __uhsax
+#define __USAD8                           __usad8
+#define __USADA8                          __usada8
+#define __SSAT16                          __ssat16
+#define __USAT16                          __usat16
+#define __UXTB16                          __uxtb16
+#define __UXTAB16                         __uxtab16
+#define __SXTB16                          __sxtb16
+#define __SXTAB16                         __sxtab16
+#define __SMUAD                           __smuad
+#define __SMUADX                          __smuadx
+#define __SMLAD                           __smlad
+#define __SMLADX                          __smladx
+#define __SMLALD                          __smlald
+#define __SMLALDX                         __smlaldx
+#define __SMUSD                           __smusd
+#define __SMUSDX                          __smusdx
+#define __SMLSD                           __smlsd
+#define __SMLSDX                          __smlsdx
+#define __SMLSLD                          __smlsld
+#define __SMLSLDX                         __smlsldx
+#define __SEL                             __sel
+#define __QADD                            __qadd
+#define __QSUB                            __qsub
+
+#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
+                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
+
+#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
+                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
+
+#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
+                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_iar.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_ccs.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SSAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+#define __USAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLALD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLALDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLSLD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLSLDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+#define __PKHBT(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+#define __PKHTB(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  if (ARG3 == 0) \
+    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
+  else \
+    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
+{
+ int32_t result;
+
+ __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
+ return(result);
+}
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+/* not yet supported */
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+#endif
+
+/*@} end of group CMSIS_SIMD_intrinsics */
+
+
+#endif /* __CORE_CM4_SIMD_H */
+
+#ifdef __cplusplus
+}
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/core_cmFunc.h ./lpc_chip_43xx/inc/core_cmFunc.h
--- a_qSC69Z/lpc_chip_43xx/inc/core_cmFunc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/core_cmFunc.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,636 @@
+/**************************************************************************//**
+ * @file     core_cmFunc.h
+ * @brief    CMSIS Cortex-M Core Function Access Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMFUNC_H
+#define __CORE_CMFUNC_H
+
+
+/* ###########################  Core Function Access  ########################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
+  @{
+ */
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM("control");
+  return(__regControl);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM("control");
+  __regControl = control;
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  register uint32_t __regIPSR          __ASM("ipsr");
+  return(__regIPSR);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__STATIC_INLINE uint32_t __get_APSR(void)
+{
+  register uint32_t __regAPSR          __ASM("apsr");
+  return(__regAPSR);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  register uint32_t __regXPSR          __ASM("xpsr");
+  return(__regXPSR);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  return(__regProcessStackPointer);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  __regProcessStackPointer = topOfProcStack;
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  return(__regMainStackPointer);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  __regMainStackPointer = topOfMainStack;
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  return(__regPriMask);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  __regPriMask = (priMask);
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __enable_fault_irq                __enable_fiq
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __disable_fault_irq               __disable_fiq
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__STATIC_INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  return(__regBasePri);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  __regBasePri = (basePri & 0xff);
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  return(__regFaultMask);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  __regFaultMask = (faultMask & (uint32_t)1);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  return(__regfpscr);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  __regfpscr = (fpscr);
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/** \brief  Enable IRQ Interrupts
+
+  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
+{
+  __ASM volatile ("cpsie i" : : : "memory");
+}
+
+
+/** \brief  Disable IRQ Interrupts
+
+  This function disables IRQ interrupts by setting the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
+{
+  __ASM volatile ("cpsid i" : : : "memory");
+}
+
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, control" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
+{
+  __ASM volatile ("cpsie f" : : : "memory");
+}
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
+{
+  __ASM volatile ("cpsid f" : : : "memory");
+}
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  uint32_t result;
+
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
+  __ASM volatile ("");
+  return(result);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
+  __ASM volatile ("");
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@} end of CMSIS_Core_RegAccFunctions */
+
+
+#endif /* __CORE_CMFUNC_H */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/core_cmInstr.h ./lpc_chip_43xx/inc/core_cmInstr.h
--- a_qSC69Z/lpc_chip_43xx/inc/core_cmInstr.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/core_cmInstr.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,688 @@
+/**************************************************************************//**
+ * @file     core_cmInstr.h
+ * @brief    CMSIS Cortex-M Core Instruction Access Header File
+ * @version  V3.20
+ * @date     05. March 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMINSTR_H
+#define __CORE_CMINSTR_H
+
+
+/* ##########################  Core Instruction Access  ######################### */
+/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
+  Access to dedicated instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+#define __NOP                             __nop
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+#define __WFI                             __wfi
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+#define __WFE                             __wfe
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+#define __SEV                             __sev
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+#define __ISB()                           __isb(0xF)
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+#define __DSB()                           __dsb(0xF)
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+#define __DMB()                           __dmb(0xF)
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __REV                             __rev
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+#endif
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+#endif
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+#define __ROR                             __ror
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __breakpoint(value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __RBIT                            __rbit
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXB(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXH(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+#define __CLREX                           __clrex
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT                            __ssat
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT                            __usat
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+#define __CLZ                             __clz
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/* Define macros for porting to both thumb1 and thumb2.
+ * For thumb1, use low register (r0-r7), specified by constrant "l"
+ * Otherwise, use general registers, specified by constrant "r" */
+#if defined (__thumb__) && !defined (__thumb2__)
+#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
+#define __CMSIS_GCC_USE_REG(r) "l" (r)
+#else
+#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
+#define __CMSIS_GCC_USE_REG(r) "r" (r)
+#endif
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
+{
+  __ASM volatile ("nop");
+}
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
+{
+  __ASM volatile ("wfi");
+}
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
+{
+  __ASM volatile ("wfe");
+}
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
+{
+  __ASM volatile ("sev");
+}
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
+{
+  __ASM volatile ("isb");
+}
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
+{
+  __ASM volatile ("dsb");
+}
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
+{
+  __ASM volatile ("dmb");
+}
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+  return __builtin_bswap32(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
+{
+  uint32_t result;
+
+  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+}
+
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+  return (short)__builtin_bswap16(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
+{
+  return (op1 >> op2) | (op1 << (32 - op2));
+}
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result;
+
+   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
+{
+    uint32_t result;
+
+   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
+{
+  __ASM volatile ("clrex" ::: "memory");
+}
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
+{
+   uint32_t result;
+
+  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all intrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
+
+#endif /* __CORE_CMINSTR_H */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/creg_18xx_43xx.h ./lpc_chip_43xx/inc/creg_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/creg_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/creg_18xx_43xx.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,238 @@
+/*
+ * @brief LPC18XX/43XX CREG control functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CREG_18XX_43XX_H_
+#define __CREG_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CREG_18XX_43XX CHIP: LPC18xx/43xx CREG driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief CREG Register Block
+ */
+typedef struct {                       /*!< CREG Structure         */
+   __I  uint32_t  RESERVED0;
+   __IO uint32_t  CREG0;               /*!< Chip configuration register 32 kHz oscillator output and BOD control register. */
+   __I  uint32_t  RESERVED1[62];
+   __IO uint32_t  MXMEMMAP;            /*!< ARM Cortex-M3/M4 memory mapping */
+#if defined(CHIP_LPC18XX)
+   __I  uint32_t  RESERVED2[5];
+#else
+   __I  uint32_t  RESERVED2;
+   __I  uint32_t  CREG1;               /*!< Configuration Register 1 */
+   __I  uint32_t  CREG2;               /*!< Configuration Register 2 */
+   __I  uint32_t  CREG3;               /*!< Configuration Register 3 */
+   __I  uint32_t  CREG4;               /*!< Configuration Register 4 */
+#endif
+   __IO uint32_t  CREG5;               /*!< Chip configuration register 5. Controls JTAG access. */
+   __IO uint32_t  DMAMUX;              /*!< DMA muxing control     */
+   __IO uint32_t  FLASHCFGA;           /*!< Flash accelerator configuration register for flash bank A */
+   __IO uint32_t  FLASHCFGB;           /*!< Flash accelerator configuration register for flash bank B */
+   __IO uint32_t  ETBCFG;              /*!< ETB RAM configuration  */
+   __IO uint32_t  CREG6;               /*!< Chip configuration register 6. */
+#if defined(CHIP_LPC18XX)
+   __I  uint32_t  RESERVED4[52];
+#else
+   __IO uint32_t  M4TXEVENT;           /*!< M4 IPC event register */
+   __I  uint32_t  RESERVED4[51];
+#endif
+   __I  uint32_t  CHIPID;              /*!< Part ID                */
+#if defined(CHIP_LPC18XX)
+   __I  uint32_t  RESERVED5[191];
+#else
+   __I  uint32_t  RESERVED5[65];
+   __IO uint32_t  M0SUBMEMMAP;         /*!< M0SUB IPC Event memory mapping */
+   __I  uint32_t  RESERVED6[2];
+   __IO uint32_t  M0SUBTXEVENT;        /*!< M0SUB IPC Event register */
+   __I  uint32_t  RESERVED7[58];
+   __IO uint32_t  M0APPTXEVENT;        /*!< M0APP IPC Event register */
+   __IO uint32_t  M0APPMEMMAP;         /*!< ARM Cortex M0APP memory mapping */
+   __I  uint32_t  RESERVED8[62];
+#endif
+   __IO uint32_t  USB0FLADJ;           /*!< USB0 frame length adjust register */
+   __I  uint32_t  RESERVED9[63];
+   __IO uint32_t  USB1FLADJ;           /*!< USB1 frame length adjust register */
+} LPC_CREG_T;
+
+/**
+ * @brief  Identifies whether on-chip flash is present
+ * @return true if on chip flash is available, otherwise false
+ */
+STATIC INLINE uint32_t Chip_CREG_OnChipFlashIsPresent(void)
+{
+   return LPC_CREG->CHIPID != 0x3284E02B;
+}
+
+/**
+ * @brief  Configures the onboard Flash Accelerator in flash-based LPC18xx/LPC43xx parts.
+ * @param  Hz  : Current frequency in Hz of the CPU
+ * @return Nothing
+ * This function should be called with the higher frequency before the clock frequency is
+ * increased and it should be called with the new lower value after the clock frequency is
+ * decreased.
+ */
+STATIC INLINE void Chip_CREG_SetFlashAcceleration(uint32_t Hz)
+{
+   uint32_t FAValue = Hz / 21510000;
+
+   LPC_CREG->FLASHCFGA = (LPC_CREG->FLASHCFGA & (~(0xF << 12))) | (FAValue << 12);
+   LPC_CREG->FLASHCFGB = (LPC_CREG->FLASHCFGB & (~(0xF << 12))) | (FAValue << 12);
+}
+
+/**
+ * @brief FLASH Access time definitions
+ */
+typedef enum {
+   FLASHTIM_20MHZ_CPU = 0,     /*!< Flash accesses use 1 CPU clocks. Use for up to 20 MHz CPU clock */
+   FLASHTIM_40MHZ_CPU = 1,     /*!< Flash accesses use 2 CPU clocks. Use for up to 40 MHz CPU clock */
+   FLASHTIM_60MHZ_CPU = 2,     /*!< Flash accesses use 3 CPU clocks. Use for up to 60 MHz CPU clock */
+   FLASHTIM_80MHZ_CPU = 3,     /*!< Flash accesses use 4 CPU clocks. Use for up to 80 MHz CPU clock */
+   FLASHTIM_100MHZ_CPU = 4,    /*!< Flash accesses use 5 CPU clocks. Use for up to 100 MHz CPU clock */
+   FLASHTIM_120MHZ_CPU = 5,    /*!< Flash accesses use 6 CPU clocks. Use for up to 120 MHz CPU clock */
+   FLASHTIM_150MHZ_CPU = 6,    /*!< Flash accesses use 7 CPU clocks. Use for up to 150 Mhz CPU clock */
+   FLASHTIM_170MHZ_CPU = 7,        /*!< Flash accesses use 8 CPU clocks. Use for up to 170 MHz CPU clock */
+   FLASHTIM_190MHZ_CPU = 8,        /*!< Flash accesses use 9 CPU clocks. Use for up to 190 MHz CPU clock */
+   FLASHTIM_SAFE_SETTING = 9,      /*!< Flash accesses use 10 CPU clocks. Safe setting for any allowed conditions */
+} CREG_FLASHTIM_T;
+
+/**
+ * @brief  Set FLASH memory access time in clocks
+ * @param  clks    : FLASH access speed rating
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_SetFLASHAccess(CREG_FLASHTIM_T clks)
+{
+   uint32_t tmpA, tmpB;
+
+   /* Don't alter lower bits */
+   tmpA = LPC_CREG->FLASHCFGA & ~(0xF << 12);
+   LPC_CREG->FLASHCFGA = tmpA | ((uint32_t) clks << 12);
+   tmpB = LPC_CREG->FLASHCFGB & ~(0xF << 12);
+   LPC_CREG->FLASHCFGB = tmpB | ((uint32_t) clks << 12);
+}
+
+/**
+ * @brief  Enables the USB0 high-speed PHY on LPC18xx/LPC43xx parts
+ * @return Nothing
+ * @note   The USB0 PLL & clock should be configured before calling this function. This function
+ * should be called before the USB0 registers are accessed.
+ */
+STATIC INLINE void Chip_CREG_EnableUSB0Phy(void)
+{
+   LPC_CREG->CREG0 &= ~(1 << 5);
+}
+
+/**
+ * @brief  Disable the USB0 high-speed PHY on LPC18xx/LPC43xx parts
+ * @return Nothing
+ * @note   The USB0 PLL & clock should be configured before calling this function. This function
+ * should be called before the USB0 registers are accessed.
+ */
+STATIC INLINE void Chip_CREG_DisableUSB0Phy(void)
+{
+   LPC_CREG->CREG0 |= (1 << 5);
+}
+
+/**
+ * @brief  Configures the BOD and Reset on LPC18xx/LPC43xx parts.
+ * @param  BODVL   : Brown-Out Detect voltage level (0-3)
+ * @param  BORVL   : Brown-Out Reset voltage level (0-3)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_ConfigureBODaR(uint32_t BODVL, uint32_t BORVL)
+{
+   LPC_CREG->CREG0 = (LPC_CREG->CREG0 & ~((3 << 8) | (3 << 10))) | (BODVL << 8) | (BORVL << 10);
+}
+
+#if (defined(CHIP_LPC43XX) && defined(LPC_CREG))
+/**
+ * @brief  Configures base address of image to be run in the Cortex M0APP Core.
+ * @param  memaddr : Address of the image (must be aligned to 4K)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_SetM0AppMemMap(uint32_t memaddr)
+{
+   LPC_CREG->M0APPMEMMAP = memaddr & ~0xFFF;
+}
+
+/**
+ * @brief  Configures base address of image to be run in the Cortex M0SUB Core.
+ * @param  memaddr : Address of the image (must be aligned to 4K)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_SetM0SubMemMap(uint32_t memaddr)
+{
+   LPC_CREG->M0SUBMEMMAP = memaddr & ~0xFFF;
+}
+
+/**
+ * @brief  Clear M4 IPC Event
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_ClearM4Event(void)
+{
+   LPC_CREG->M4TXEVENT = 0;
+}
+
+/**
+ * @brief  Clear M0APP IPC Event
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_ClearM0AppEvent(void)
+{
+   LPC_CREG->M0APPTXEVENT = 0;
+}
+
+/**
+ * @brief  Clear M0APP IPC Event
+ * @return Nothing
+ */
+STATIC INLINE void Chip_CREG_ClearM0SubEvent(void)
+{
+   LPC_CREG->M0SUBTXEVENT = 0;
+}
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CREG_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/dac_18xx_43xx.h ./lpc_chip_43xx/inc/dac_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/dac_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/dac_18xx_43xx.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,166 @@
+/*
+ * @brief LPC18xx/43xx D/A conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __DAC_18XX_43XX_H_
+#define __DAC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup DAC_18XX_43XX CHIP: LPC18xx/43xx D/A conversion driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief DAC register block structure
+ */
+typedef struct {           /*!< DAC Structure          */
+   __IO uint32_t  CR;      /*!< DAC register. Holds the conversion data. */
+   __IO uint32_t  CTRL;    /*!< DAC control register.  */
+   __IO uint32_t  CNTVAL;  /*!< DAC counter value register. */
+} LPC_DAC_T;
+
+/** After the selected settling time after this field is written with a
+   new VALUE, the voltage on the AOUT pin (with respect to VSSA)
+   is VALUE/1024 ? VREF */
+#define DAC_VALUE(n)        ((uint32_t) ((n & 0x3FF) << 6))
+/** If this bit = 0: The settling time of the DAC is 1 microsecond max,
+ * and the maximum current is 700 microAmpere
+ * If this bit = 1: The settling time of the DAC is 2.5 microsecond
+ * and the maximum current is 350 microAmpere
+ */
+#define DAC_BIAS_EN         ((uint32_t) (1 << 16))
+/** Value to reload interrupt DMA counter */
+#define DAC_CCNT_VALUE(n)  ((uint32_t) (n & 0xffff))
+
+/** DCAR double buffering */
+#define DAC_DBLBUF_ENA      ((uint32_t) (1 << 1))
+/** DCAR Time out count enable */
+#define DAC_CNT_ENA         ((uint32_t) (1 << 2))
+/** DCAR DMA access */
+#define DAC_DMA_ENA         ((uint32_t) (1 << 3))
+/** DCAR DACCTRL mask bit */
+#define DAC_DACCTRL_MASK    ((uint32_t) (0x0F))
+
+/**
+ * @brief Current option in DAC configuration option
+ */
+typedef enum IP_DAC_CURRENT_OPT {
+   DAC_MAX_UPDATE_RATE_1MHz = 0,   /*!< Shorter settling times and higher power consumption;
+                                       allows for a maximum update rate of 1 MHz */
+   DAC_MAX_UPDATE_RATE_400kHz      /*!< Longer settling times and lower power consumption;
+                                       allows for a maximum update rate of 400 kHz */
+} DAC_CURRENT_OPT_T;
+
+/**
+ * @brief  Initial DAC configuration
+ *              - Maximum  current is 700 uA
+ *              - Value to AOUT is 0
+ * @param  pDAC    : pointer to LPC_DAC_T
+ * @return Nothing
+ */
+void Chip_DAC_Init(LPC_DAC_T *pDAC);
+
+/**
+ * @brief  Shutdown DAC
+ * @param  pDAC    : pointer to LPC_DAC_T
+ * @return Nothing
+ */
+void Chip_DAC_DeInit(LPC_DAC_T *pDAC);
+
+/**
+ * @brief  Update value to DAC buffer
+ * @param  pDAC        : pointer to LPC_DAC_T
+ * @param  dac_value   : value 10 bit to be converted to output
+ * @return Nothing
+ */
+void Chip_DAC_UpdateValue(LPC_DAC_T *pDAC, uint32_t dac_value);
+
+/**
+ * @brief  Set maximum update rate for DAC
+ * @param  pDAC    : pointer to LPC_DAC_T
+ * @param  bias    : Using Bias value, should be:
+ *              - 0 is 1MHz
+ *              - 1 is 400kHz
+ * @return Nothing
+ */
+void Chip_DAC_SetBias(LPC_DAC_T *pDAC, uint32_t bias);
+
+/**
+ * @brief  Enables the DMA operation and controls DMA timer
+ * @param  pDAC        : pointer to LPC_DAC_T
+ * @param  dacFlags    : An Or'ed value of the following DAC values:
+ *                  - DAC_DBLBUF_ENA :enable/disable DACR double buffering feature
+ *                  - DAC_CNT_ENA    :enable/disable timer out counter
+ *                  - DAC_DMA_ENA    :enable/disable DMA access
+ * @return Nothing
+ * @note   Pass an Or'ed value of the DAC flags to enable those options.
+ */
+STATIC INLINE void Chip_DAC_ConfigDAConverterControl(LPC_DAC_T *pDAC, uint32_t dacFlags)
+{
+   uint32_t temp;
+
+   temp = pDAC->CTRL & ~DAC_DACCTRL_MASK;
+   pDAC->CTRL = temp | dacFlags;
+}
+
+/**
+ * @brief  Set reload value for interrupt/DMA counter
+ * @param  pDAC        : pointer to LPC_DAC_T
+ * @param  time_out    : time out to reload for interrupt/DMA counter
+ * @return Nothing
+ */
+STATIC INLINE void Chip_DAC_SetDMATimeOut(LPC_DAC_T *pDAC, uint32_t time_out)
+{
+   pDAC->CNTVAL = DAC_CCNT_VALUE(time_out);
+}
+
+/**
+ * @brief  Get status for interrupt/DMA time out
+ * @param  pDAC    : pointer to LPC_DAC_T
+ * @return interrupt/DMA time out status, should be SET or RESET
+ */
+STATIC INLINE IntStatus Chip_DAC_GetIntStatus(LPC_DAC_T *pDAC)
+{
+   return (pDAC->CTRL & 0x01) ? SET : RESET;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DAC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/eeprom_18xx_43xx.h ./lpc_chip_43xx/inc/eeprom_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/eeprom_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/eeprom_18xx_43xx.h	2018-01-19 23:55:10.964318379 -0300
@@ -0,0 +1,275 @@
+/*
+ * @brief LPC18xx/43xx EEPROM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef _EEPROM_18XX_43XX_H_
+#define _EEPROM_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup EEPROM_18XX_43XX CHIP: LPC18xx/43xx EEPROM driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/* FIX ME: Move to chip.h */
+/** EEPROM start address */
+#define EEPROM_START                    (0x20040000)
+/** EEPROM byes per page */
+#define EEPROM_PAGE_SIZE                (128)
+/**The number of EEPROM pages. The last page is not writable.*/
+#define EEPROM_PAGE_NUM                 (128)
+/** Get the eeprom address */
+#define EEPROM_ADDRESS(page, offset)     (EEPROM_START + (EEPROM_PAGE_SIZE * (page)) + offset)
+#define EEPROM_CLOCK_DIV                 1500000
+#define EEPROM_READ_WAIT_STATE_VAL       0x58
+#define EEPROM_WAIT_STATE_VAL            0x232
+
+/**
+ * @brief EEPROM register block structure
+ */
+typedef struct {               /* EEPROM Structure */
+   __IO uint32_t CMD;          /*!< EEPROM command register */
+   uint32_t RESERVED0;
+   __IO uint32_t RWSTATE;      /*!< EEPROM read wait state register */
+   __IO uint32_t AUTOPROG;     /*!< EEPROM auto programming register */
+   __IO uint32_t WSTATE;       /*!< EEPROM wait state register */
+   __IO uint32_t CLKDIV;       /*!< EEPROM clock divider register */
+   __IO uint32_t PWRDWN;       /*!< EEPROM power-down register */
+   uint32_t RESERVED2[1007];
+   __O  uint32_t INTENCLR;     /*!< EEPROM interrupt enable clear */
+   __O  uint32_t INTENSET;     /*!< EEPROM interrupt enable set */
+   __I  uint32_t INTSTAT;      /*!< EEPROM interrupt status */
+   __I  uint32_t INTEN;        /*!< EEPROM interrupt enable */
+   __O  uint32_t INTSTATCLR;   /*!< EEPROM interrupt status clear */
+   __O  uint32_t INTSTATSET;   /*!< EEPROM interrupt status set */
+} LPC_EEPROM_T;
+
+/*
+ * @brief Macro defines for EEPROM command register
+ */
+#define EEPROM_CMD_ERASE_PRG_PAGE       (6)        /*!< EEPROM erase/program command */
+
+/*
+ * @brief Macro defines for EEPROM Auto Programming register
+ */
+#define EEPROM_AUTOPROG_OFF     (0)        /*!<Auto programming off */
+#define EEPROM_AUTOPROG_AFT_1WORDWRITTEN     (1)       /*!< Erase/program cycle is triggered after 1 word is written */
+#define EEPROM_AUTOPROG_AFT_LASTWORDWRITTEN  (2)       /*!< Erase/program cycle is triggered after a write to AHB
+                                                          address ending with ......1111100 (last word of a page) */
+
+/*
+ * @brief Macro defines for EEPROM power down register
+ */
+#define EEPROM_PWRDWN                   (1 << 0)
+
+/*
+ * @brief Macro defines for EEPROM interrupt related registers
+ */
+#define EEPROM_INT_ENDOFPROG            (1 << 2)
+
+/**
+ * @brief  Put EEPROM device in power down mode
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_EnablePowerDown(LPC_EEPROM_T *pEEPROM)
+{
+   pEEPROM->PWRDWN = EEPROM_PWRDWN;
+}
+
+/**
+ * @brief  Bring EEPROM device out of power down mode
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_DisablePowerDown(LPC_EEPROM_T *pEEPROM)
+{
+   pEEPROM->PWRDWN = 0;
+}
+
+/**
+ * @brief  Initializes EEPROM
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return Nothing
+ */
+void Chip_EEPROM_Init(LPC_EEPROM_T *pEEPROM);
+
+/**
+ * @brief  De-initializes EEPROM
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_DeInit(LPC_EEPROM_T *pEEPROM)
+{
+   /* Enable EEPROM power down mode */
+   Chip_EEPROM_EnablePowerDown(pEEPROM);
+}
+
+/**
+ * @brief  Set Auto program mode
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  mode    : Auto Program Mode (One of EEPROM_AUTOPROG_* value)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_SetAutoProg(LPC_EEPROM_T *pEEPROM, uint32_t mode)
+{
+   pEEPROM->AUTOPROG = mode;
+}
+
+/**
+ * @brief  Set EEPROM Read Wait State
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  ws      : Wait State value
+ * @return Nothing
+ * @note    Bits 7:0 represents wait state for Read Phase 2 and
+ *          Bits 15:8 represents wait state for Read Phase1
+ */
+STATIC INLINE void Chip_EEPROM_SetReadWaitState(LPC_EEPROM_T *pEEPROM, uint32_t ws)
+{
+   pEEPROM->RWSTATE = ws;
+}
+
+/**
+ * @brief  Set EEPROM wait state
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  ws      : Wait State value
+ * @return Nothing
+ * @note    Bits 7:0 represents wait state for Phase 3,
+ *          Bits 15:8 represents wait state for Phase2, and
+ *          Bits 23:16 represents wait state for Phase1
+ */
+STATIC INLINE void Chip_EEPROM_SetWaitState(LPC_EEPROM_T *pEEPROM, uint32_t ws)
+{
+   pEEPROM->WSTATE = ws;
+}
+
+/**
+ * @brief  Select an EEPROM command
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  cmd     : EEPROM command
+ * @return Nothing
+ * @note   The cmd is OR-ed bits value of  EEPROM_CMD_*
+ */
+STATIC INLINE void Chip_EEPROM_SetCmd(LPC_EEPROM_T *pEEPROM, uint32_t cmd)
+{
+   pEEPROM->CMD = cmd;
+}
+
+/**
+ * @brief  Erase/Program an EEPROM page
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return Nothing
+ */
+void Chip_EEPROM_EraseProgramPage(LPC_EEPROM_T *pEEPROM);
+
+/**
+ * @brief  Wait for interrupt occurs
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  mask    : Expected interrupt
+ * @return Nothing
+ */
+void Chip_EEPROM_WaitForIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask);
+
+/**
+ * @brief  Enable EEPROM interrupt
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  mask    : Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_EnableInt(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+   pEEPROM->INTENSET =  mask;
+}
+
+/**
+ * @brief  Disable EEPROM interrupt
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  mask    : Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_DisableInt(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+   pEEPROM->INTENCLR =  mask;
+}
+
+/**
+ * @brief  Get the value of the EEPROM interrupt enable register
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return OR-ed bits value of EEPROM_INT_*
+ */
+STATIC INLINE uint32_t Chip_EEPROM_GetIntEnable(LPC_EEPROM_T *pEEPROM)
+{
+   return pEEPROM->INTEN;
+}
+
+/**
+ * @brief  Get EEPROM interrupt status
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @return OR-ed bits value of EEPROM_INT_*
+ */
+STATIC INLINE uint32_t Chip_EEPROM_GetIntStatus(LPC_EEPROM_T *pEEPROM)
+{
+   return pEEPROM->INTSTAT;
+}
+
+/**
+ * @brief  Set EEPROM interrupt status
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  mask    : Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_SetIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+   pEEPROM->INTSTATSET =  mask;
+}
+
+/**
+ * @brief  Clear EEPROM interrupt status
+ * @param  pEEPROM : Pointer to EEPROM peripheral block structure
+ * @param  mask    : Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EEPROM_ClearIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+   pEEPROM->INTSTATCLR =  mask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _EEPROM_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/emc_18xx_43xx.h ./lpc_chip_43xx/inc/emc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/emc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/emc_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,354 @@
+/*
+ * @brief LPC18xx/43xx EMC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __EMC_18XX_43XX_H_
+#define __EMC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup EMC_18XX_43XX CHIP: LPC18xx/43xx External Memory Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ * The EMC interface clocks must be enabled outside this driver prior to
+ * calling any function of this driver.
+ */
+
+/**
+ * @brief External Memory Controller (EMC) register block structure
+ */
+typedef struct {                           /*!< EMC Structure          */
+   __IO uint32_t  CONTROL;                 /*!< Controls operation of the memory controller. */
+   __I  uint32_t  STATUS;                  /*!< Provides EMC status information. */
+   __IO uint32_t  CONFIG;                  /*!< Configures operation of the memory controller. */
+   __I  uint32_t  RESERVED0[5];
+   __IO uint32_t  DYNAMICCONTROL;          /*!< Controls dynamic memory operation. */
+   __IO uint32_t  DYNAMICREFRESH;          /*!< Configures dynamic memory refresh operation. */
+   __IO uint32_t  DYNAMICREADCONFIG;       /*!< Configures the dynamic memory read strategy. */
+   __I  uint32_t  RESERVED1;
+   __IO uint32_t  DYNAMICRP;               /*!< Selects the precharge command period. */
+   __IO uint32_t  DYNAMICRAS;              /*!< Selects the active to precharge command period. */
+   __IO uint32_t  DYNAMICSREX;             /*!< Selects the self-refresh exit time. */
+   __IO uint32_t  DYNAMICAPR;              /*!< Selects the last-data-out to active command time. */
+   __IO uint32_t  DYNAMICDAL;              /*!< Selects the data-in to active command time. */
+   __IO uint32_t  DYNAMICWR;               /*!< Selects the write recovery time. */
+   __IO uint32_t  DYNAMICRC;               /*!< Selects the active to active command period. */
+   __IO uint32_t  DYNAMICRFC;              /*!< Selects the auto-refresh period. */
+   __IO uint32_t  DYNAMICXSR;              /*!< Selects the exit self-refresh to active command time. */
+   __IO uint32_t  DYNAMICRRD;              /*!< Selects the active bank A to active bank B latency. */
+   __IO uint32_t  DYNAMICMRD;              /*!< Selects the load mode register to active command time. */
+   __I  uint32_t  RESERVED2[9];
+   __IO uint32_t  STATICEXTENDEDWAIT;      /*!< Selects time for long static memory read and write transfers. */
+   __I  uint32_t  RESERVED3[31];
+   __IO uint32_t  DYNAMICCONFIG0;          /*!< Selects the configuration information for dynamic memory chip select n. */
+   __IO uint32_t  DYNAMICRASCAS0;          /*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+   __I  uint32_t  RESERVED4[6];
+   __IO uint32_t  DYNAMICCONFIG1;          /*!< Selects the configuration information for dynamic memory chip select n. */
+   __IO uint32_t  DYNAMICRASCAS1;          /*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+   __I  uint32_t  RESERVED5[6];
+   __IO uint32_t  DYNAMICCONFIG2;          /*!< Selects the configuration information for dynamic memory chip select n. */
+   __IO uint32_t  DYNAMICRASCAS2;          /*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+   __I  uint32_t  RESERVED6[6];
+   __IO uint32_t  DYNAMICCONFIG3;          /*!< Selects the configuration information for dynamic memory chip select n. */
+   __IO uint32_t  DYNAMICRASCAS3;          /*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+   __I  uint32_t  RESERVED7[38];
+   __IO uint32_t  STATICCONFIG0;           /*!< Selects the memory configuration for static chip select n. */
+   __IO uint32_t  STATICWAITWEN0;          /*!< Selects the delay from chip select n to write enable. */
+   __IO uint32_t  STATICWAITOEN0;          /*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+   __IO uint32_t  STATICWAITRD0;           /*!< Selects the delay from chip select n to a read access. */
+   __IO uint32_t  STATICWAITPAG0;          /*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+   __IO uint32_t  STATICWAITWR0;           /*!< Selects the delay from chip select n to a write access. */
+   __IO uint32_t  STATICWAITTURN0;         /*!< Selects bus turnaround cycles */
+   __I  uint32_t  RESERVED8;
+   __IO uint32_t  STATICCONFIG1;           /*!< Selects the memory configuration for static chip select n. */
+   __IO uint32_t  STATICWAITWEN1;          /*!< Selects the delay from chip select n to write enable. */
+   __IO uint32_t  STATICWAITOEN1;          /*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+   __IO uint32_t  STATICWAITRD1;           /*!< Selects the delay from chip select n to a read access. */
+   __IO uint32_t  STATICWAITPAG1;          /*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+   __IO uint32_t  STATICWAITWR1;           /*!< Selects the delay from chip select n to a write access. */
+   __IO uint32_t  STATICWAITTURN1;         /*!< Selects bus turnaround cycles */
+   __I  uint32_t  RESERVED9;
+   __IO uint32_t  STATICCONFIG2;           /*!< Selects the memory configuration for static chip select n. */
+   __IO uint32_t  STATICWAITWEN2;          /*!< Selects the delay from chip select n to write enable. */
+   __IO uint32_t  STATICWAITOEN2;          /*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+   __IO uint32_t  STATICWAITRD2;           /*!< Selects the delay from chip select n to a read access. */
+   __IO uint32_t  STATICWAITPAG2;          /*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+   __IO uint32_t  STATICWAITWR2;           /*!< Selects the delay from chip select n to a write access. */
+   __IO uint32_t  STATICWAITTURN2;         /*!< Selects bus turnaround cycles */
+   __I  uint32_t  RESERVED10;
+   __IO uint32_t  STATICCONFIG3;           /*!< Selects the memory configuration for static chip select n. */
+   __IO uint32_t  STATICWAITWEN3;          /*!< Selects the delay from chip select n to write enable. */
+   __IO uint32_t  STATICWAITOEN3;          /*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+   __IO uint32_t  STATICWAITRD3;           /*!< Selects the delay from chip select n to a read access. */
+   __IO uint32_t  STATICWAITPAG3;          /*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+   __IO uint32_t  STATICWAITWR3;           /*!< Selects the delay from chip select n to a write access. */
+   __IO uint32_t  STATICWAITTURN3;         /*!< Selects bus turnaround cycles */
+} LPC_EMC_T;
+
+/**
+ * Dynamic Chip Select Address
+ */
+#define EMC_ADDRESS_DYCS0   (0x28000000)
+#define EMC_ADDRESS_DYCS1   (0x30000000)
+#define EMC_ADDRESS_DYCS2   (0x60000000)
+#define EMC_ADDRESS_DYCS3   (0x70000000)
+
+/**
+ * Static Chip Select Address
+ */
+#define EMC_ADDRESS_CS0     (0x1C000000)
+#define EMC_ADDRESS_CS1     (0x1D000000)
+#define EMC_ADDRESS_CS2     (0x1E000000)
+#define EMC_ADDRESS_CS3     (0x1F000000)
+
+/**
+ * @brief EMC register support bitfields and mask
+ */
+/* Reserve for extending support to ARM9 or nextgen LPC */
+#define EMC_SUPPORT_ONLY_PL172 /*!< Reserve for extending support to ARM9 or nextgen LPC */
+
+#define EMC_CONFIG_ENDIAN_LITTLE    (0)        /*!< Value for EMC to operate in Little Endian Mode */
+#define EMC_CONFIG_ENDIAN_BIG         (1)  /*!< Value for EMC to operate in Big Endian Mode */
+
+#define EMC_CONFIG_BUFFER_ENABLE    (1 << 19)  /*!< EMC Buffer enable bit in EMC Dynamic Configuration register */
+#define EMC_CONFIG_WRITE_PROTECT    (1 << 20)  /*!< EMC Write protect bit in EMC Dynamic Configuration register */
+
+/* Dynamic Memory Configuration Register Bit Definitions */
+#define EMC_DYN_CONFIG_MD_BIT             (3)                              /*!< Memory device bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_MD_SDRAM         (0 << EMC_DYN_CONFIG_MD_BIT)       /*!< Select device as SDRAM in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_MD_LPSDRAM       (1 << EMC_DYN_CONFIG_MD_BIT)       /*!< Select device as LPSDRAM in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_LPSDRAM_BIT      (12)                           /*!< LPSDRAM bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_LPSDRAM          (1 << EMC_DYN_CONFIG_LPSDRAM_BIT)  /*!< LPSDRAM value in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_DEV_SIZE_BIT     (9)                                    /*!< Device Size starting bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_16Mb    (0x00 << EMC_DYN_CONFIG_DEV_SIZE_BIT)  /*!< 16Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_64Mb    (0x01 << EMC_DYN_CONFIG_DEV_SIZE_BIT)  /*!< 64Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_128Mb   (0x02 << EMC_DYN_CONFIG_DEV_SIZE_BIT)  /*!< 128Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_256Mb   (0x03 << EMC_DYN_CONFIG_DEV_SIZE_BIT)  /*!< 256Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_512Mb   (0x04 << EMC_DYN_CONFIG_DEV_SIZE_BIT)  /*!< 512Mb Device Size value in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_DEV_BUS_BIT      (7)                                    /*!< Device bus width starting bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_BUS_8        (0x00 << EMC_DYN_CONFIG_DEV_BUS_BIT)   /*!< Device 8-bit bus width value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_BUS_16       (0x01 << EMC_DYN_CONFIG_DEV_BUS_BIT)   /*!< Device 16-bit bus width value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_BUS_32       (0x02 << EMC_DYN_CONFIG_DEV_BUS_BIT)   /*!< Device 32-bit bus width value in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT   (14)                                   /*!< Device data bus width starting bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DATA_BUS_16      (0x00 << EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT)    /*!< Device 16-bit data bus width value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DATA_BUS_32      (0x01 << EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT)    /*!< Device 32-bit bus width value in EMC Dynamic Configuration register */
+
+/*!< Memory configuration values in EMC Dynamic Configuration Register */
+#define EMC_DYN_CONFIG_2Mx8_2BANKS_11ROWS_9COLS     ((0x0 << 9) | (0x0 << 7))  /*!< Value for Memory configuration - 2Mx8 2 Banks 11 Rows 9 Columns */
+#define EMC_DYN_CONFIG_1Mx16_2BANKS_11ROWS_8COLS    ((0x0 << 9) | (0x1 << 7))  /*!< Value for Memory configuration - 1Mx16 2 Banks 11 Rows 8 Columns */
+#define EMC_DYN_CONFIG_8Mx8_4BANKS_12ROWS_9COLS     ((0x1 << 9) | (0x0 << 7))  /*!< Value for Memory configuration - 8Mx8 4 Banks 12 Rows 9 Columns */
+#define EMC_DYN_CONFIG_4Mx16_4BANKS_12ROWS_8COLS    ((0x1 << 9) | (0x1 << 7))  /*!< Value for Memory configuration - 4Mx16 4 Banks 12 Rows 8 Columns */
+#define EMC_DYN_CONFIG_2Mx32_4BANKS_11ROWS_8COLS    ((0x1 << 9) | (0x2 << 7))  /*!< Value for Memory configuration - 2Mx32 4 Banks 11 Rows 8 Columns */
+#define EMC_DYN_CONFIG_16Mx8_4BANKS_12ROWS_10COLS   ((0x2 << 9) | (0x0 << 7))  /*!< Value for Memory configuration - 16Mx8 4 Banks 12 Rows 10 Columns */
+#define EMC_DYN_CONFIG_8Mx16_4BANKS_12ROWS_9COLS    ((0x2 << 9) | (0x1 << 7))  /*!< Value for Memory configuration - 8Mx16 4 Banks 12 Rows 9 Columns */
+#define EMC_DYN_CONFIG_4Mx32_4BANKS_12ROWS_8COLS    ((0x2 << 9) | (0x2 << 7))  /*!< Value for Memory configuration - 4Mx32 4 Banks 12 Rows 8 Columns */
+#define EMC_DYN_CONFIG_32Mx8_4BANKS_13ROWS_10COLS   ((0x3 << 9) | (0x0 << 7))  /*!< Value for Memory configuration - 32Mx8 4 Banks 13 Rows 10 Columns */
+#define EMC_DYN_CONFIG_16Mx16_4BANKS_13ROWS_9COLS   ((0x3 << 9) | (0x1 << 7))  /*!< Value for Memory configuration - 16Mx16 4 Banks 13 Rows 8 Columns */
+#define EMC_DYN_CONFIG_8Mx32_4BANKS_13ROWS_8COLS    ((0x3 << 9) | (0x2 << 7))  /*!< Value for Memory configuration - 8Mx32 4 Banks 13 Rows 8 Columns */
+#define EMC_DYN_CONFIG_64Mx8_4BANKS_13ROWS_11COLS   ((0x4 << 9) | (0x0 << 7))  /*!< Value for Memory configuration - 64Mx8 4 Banks 13 Rows 11 Columns */
+#define EMC_DYN_CONFIG_32Mx16_4BANKS_13ROWS_10COLS  ((0x4 << 9) | (0x1 << 7))  /*!< Value for Memory configuration - 32Mx16 4 Banks 13 Rows 10 Columns */
+
+/*!< Dynamic Memory Mode Register Bit Definition */
+#define EMC_DYN_MODE_BURST_LEN_BIT      (0)    /*!< Starting bit No. of Burst Length in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_1        (0)    /*!< Value to set Burst Length to 1 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_2        (1)    /*!< Value to set Burst Length to 2 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_4        (2)    /*!< Value to set Burst Length to 4 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_8        (3)    /*!< Value to set Burst Length to 8 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_FULL     (7)    /*!< Value to set Burst Length to Full in Dynamic Memory Mode Register */
+
+#define EMC_DYN_MODE_BURST_TYPE_BIT         (3)                                    /*!< Burst Type bit in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_TYPE_SEQUENTIAL  (0 << EMC_DYN_MODE_BURST_TYPE_BIT) /*!< Burst Type Sequential in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_TYPE_INTERLEAVE  (1 << EMC_DYN_MODE_BURST_TYPE_BIT) /*!< Burst Type Interleaved in Dynamic Memory Mode Register */
+
+/*!< CAS Latency in Dynamic Mode Register */
+#define EMC_DYN_MODE_CAS_BIT    (4)                            /*!< CAS latency starting bit in Dynamic Memory Mode register */
+#define EMC_DYN_MODE_CAS_1      (1 << EMC_DYN_MODE_CAS_BIT)    /*!< value for CAS latency of 1 cycle */
+#define EMC_DYN_MODE_CAS_2      (2 << EMC_DYN_MODE_CAS_BIT)    /*!< value for CAS latency of 2 cycle */
+#define EMC_DYN_MODE_CAS_3      (3 << EMC_DYN_MODE_CAS_BIT)    /*!< value for CAS latency of 3 cycle */
+
+/*!< Operation Mode in Dynamic Mode register */
+#define EMC_DYN_MODE_OPMODE_BIT           (7)                          /*!< Dynamic Mode Operation bit */
+#define EMC_DYN_MODE_OPMODE_STANDARD    (0 << EMC_DYN_MODE_OPMODE_BIT) /*!< Value for Dynamic standard operation Mode */
+
+/*!< Write Burst Mode in Dynamic Mode register */
+#define EMC_DYN_MODE_WBMODE_BIT             (9)                            /*!< Write Burst Mode bit */
+#define EMC_DYN_MODE_WBMODE_PROGRAMMED  (0 << EMC_DYN_MODE_WBMODE_BIT) /*!< Write Burst Mode programmed */
+#define EMC_DYN_MODE_WBMODE_SINGLE_LOC  (1 << EMC_DYN_MODE_WBMODE_BIT) /*!< Write Burst Mode Single LOC */
+
+/*!< Dynamic Memory Control Register Bit Definitions */
+#define EMC_DYN_CONTROL_ENABLE          (0x03) /*!< Control Enable value */
+
+/*!< Static Memory Configuration Register Bit Definitions */
+#define EMC_STATIC_CONFIG_MEM_WIDTH_8       (0)    /*!< Static Memory Configuration - 8-bit width */
+#define EMC_STATIC_CONFIG_MEM_WIDTH_16      (1)    /*!< Static Memory Configuration - 16-bit width */
+#define EMC_STATIC_CONFIG_MEM_WIDTH_32      (2)    /*!< Static Memory Configuration - 32-bit width */
+
+#define EMC_STATIC_CONFIG_PAGE_MODE_BIT         (3)                                        /*!< Page Mode bit No */
+#define EMC_STATIC_CONFIG_PAGE_MODE_ENABLE      (1 << EMC_STATIC_CONFIG_PAGE_MODE_BIT) /*!< Value to enable Page Mode */
+
+#define EMC_STATIC_CONFIG_CS_POL_BIT            (6)                                    /*!< Chip Select bit No */
+#define EMC_STATIC_CONFIG_CS_POL_ACTIVE_HIGH    (1 << EMC_STATIC_CONFIG_CS_POL_BIT)    /*!< Chip Select polarity - Active High */
+#define EMC_STATIC_CONFIG_CS_POL_ACTIVE_LOW     (0 << EMC_STATIC_CONFIG_CS_POL_BIT)    /*!< Chip Select polarity - Active Low */
+
+#define EMC_STATIC_CONFIG_BLS_BIT           (7)                                /*!< BLS Configuration bit No */
+#define EMC_STATIC_CONFIG_BLS_HIGH          (1 << EMC_STATIC_CONFIG_BLS_BIT)   /*!< BLS High Configuration value */
+#define EMC_STATIC_CONFIG_BLS_LOW           (0 << EMC_STATIC_CONFIG_BLS_BIT)   /*!< BLS Low Configuration value */
+
+#define EMC_STATIC_CONFIG_EW_BIT            (8)                                /*!< Ext Wait bit No */
+#define EMC_STATIC_CONFIG_EW_ENABLE         (1 << EMC_STATIC_CONFIG_EW_BIT)    /*!< Ext Wait Enabled value */
+#define EMC_STATIC_CONFIG_EW_DISABLE        (0 << EMC_STATIC_CONFIG_EW_BIT)    /*!< Ext Wait Diabled value */
+
+/*!< Q24.8 Fixed Point Helper */
+#define Q24_8_FP(x) ((x) * 256)
+#define EMC_NANOSECOND(x)   Q24_8_FP(x)
+#define EMC_CLOCK(x)        Q24_8_FP(-(x))
+
+/**
+ * @brief  EMC Dynamic Device Configuration structure used for IP drivers
+ */
+typedef struct {
+   uint32_t    BaseAddr;       /*!< Base Address */
+   uint8_t     RAS;            /*!< RAS value */
+   uint32_t    ModeRegister;   /*!< Mode Register value */
+   uint32_t    DynConfig;      /*!< Dynamic Configuration value */
+} IP_EMC_DYN_DEVICE_CONFIG_T;
+
+/**
+ * @brief EMC Dynamic Configure Struct
+ */
+typedef struct {
+   int32_t RefreshPeriod;                          /*!< Refresh period */
+   uint32_t ReadConfig;                            /*!< Clock*/
+   int32_t tRP;                                    /*!< Precharge Command Period */
+   int32_t tRAS;                                   /*!< Active to Precharge Command Period */
+   int32_t tSREX;                                  /*!< Self Refresh Exit Time */
+   int32_t tAPR;                                   /*!< Last Data Out to Active Time */
+   int32_t tDAL;                                   /*!< Data In to Active Command Time */
+   int32_t tWR;                                    /*!< Write Recovery Time */
+   int32_t tRC;                                    /*!< Active to Active Command Period */
+   int32_t tRFC;                                   /*!< Auto-refresh Period */
+   int32_t tXSR;                                   /*!< Exit Selt Refresh */
+   int32_t tRRD;                                   /*!< Active Bank A to Active Bank B Time */
+   int32_t tMRD;                                   /*!< Load Mode register command to Active Command */
+   IP_EMC_DYN_DEVICE_CONFIG_T DevConfig[4];        /*!< Device Configuration array */
+} IP_EMC_DYN_CONFIG_T;
+
+/**
+ * @brief EMC Static Configure Structure
+ */
+typedef struct {
+   uint8_t ChipSelect;     /*!< Chip select */
+   uint32_t Config;        /*!< Configuration value */
+   int32_t WaitWen;        /*!< Write Enable Wait */
+   int32_t WaitOen;        /*!< Output Enable Wait */
+   int32_t WaitRd;         /*!< Read Wait */
+   int32_t WaitPage;       /*!< Page Access Wait */
+   int32_t WaitWr;         /*!< Write Wait */
+   int32_t WaitTurn;       /*!< Turn around wait */
+} IP_EMC_STATIC_CONFIG_T;
+
+/**
+ * @brief  Dyanmic memory setup
+ * @param  Dynamic_Config  : Pointer to dynamic memory setup data
+ * @return None
+ */
+void Chip_EMC_Dynamic_Init(IP_EMC_DYN_CONFIG_T *Dynamic_Config);
+
+/**
+ * @brief  Static memory setup
+ * @param  Static_Config   : Pointer to static memory setup data
+ * @return None
+ */
+void Chip_EMC_Static_Init(IP_EMC_STATIC_CONFIG_T *Static_Config);
+
+/**
+ * @brief  Enable Dynamic Memory Controller
+ * @param  Enable  : 1 = Enable Dynamic Memory Controller, 0 = Disable
+ * @return None
+ */
+void Chip_EMC_Dynamic_Enable(uint8_t Enable);
+
+/**
+ * @brief  Mirror CS1 to CS0 and DYCS0
+ * @param  Enable  : 1 = Mirror, 0 = Normal Memory Map
+ * @return None
+ */
+void Chip_EMC_Mirror(uint8_t Enable);
+
+/**
+ * @brief  Enable EMC
+ * @param  Enable  : 1 = Enable, 0 = Disable
+ * @return None
+ */
+void Chip_EMC_Enable(uint8_t Enable);
+
+/**
+ * @brief  Set EMC LowPower Mode
+ * @param  Enable  : 1 = Enable, 0 = Disable
+ * @return None
+ * @note   This function should only be called when the memory
+ * controller is not busy (bit 0 of the status register is not set).
+ */
+void Chip_EMC_LowPowerMode(uint8_t Enable);
+
+/**
+ * @brief  Initialize EMC
+ * @param  Enable      : 1 = Enable, 0 = Disable
+ * @param  ClockRatio  : clock out ratio, 0 = 1:1, 1 = 1:2
+ * @param  EndianMode  : Endian Mode, 0 = Little, 1 = Big
+ * @return None
+ */
+void Chip_EMC_Init(uint32_t Enable, uint32_t ClockRatio, uint32_t EndianMode);
+
+/**
+ * @brief  Set Static Memory Extended Wait in Clock
+ * @param  Wait16Clks  : Number of '16 clock' delay cycles
+ * @return None
+ */
+STATIC INLINE void Chip_EMC_SetStaticExtendedWait(uint32_t Wait16Clks)
+{
+   LPC_EMC->STATICEXTENDEDWAIT = Wait16Clks;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __EMC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/enet_18xx_43xx.h ./lpc_chip_43xx/inc/enet_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/enet_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/enet_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,680 @@
+/*
+ * @brief LPC18xx/43xx Ethernet driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ENET_18XX_43XX_H_
+#define __ENET_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ENET_18XX_43XX CHIP: LPC18xx/43xx Ethernet driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief 10/100 MII & RMII Ethernet with timestamping register block structure
+ */
+typedef struct {                           /*!< ETHERNET Structure */
+   __IO uint32_t  MAC_CONFIG;              /*!< MAC configuration register */
+   __IO uint32_t  MAC_FRAME_FILTER;        /*!< MAC frame filter */
+   __IO uint32_t  MAC_HASHTABLE_HIGH;      /*!< Hash table high register */
+   __IO uint32_t  MAC_HASHTABLE_LOW;       /*!< Hash table low register */
+   __IO uint32_t  MAC_MII_ADDR;            /*!< MII address register */
+   __IO uint32_t  MAC_MII_DATA;            /*!< MII data register */
+   __IO uint32_t  MAC_FLOW_CTRL;           /*!< Flow control register */
+   __IO uint32_t  MAC_VLAN_TAG;            /*!< VLAN tag register */
+   __I  uint32_t  RESERVED0;
+   __I  uint32_t  MAC_DEBUG;               /*!< Debug register */
+   __IO uint32_t  MAC_RWAKE_FRFLT;         /*!< Remote wake-up frame filter */
+   __IO uint32_t  MAC_PMT_CTRL_STAT;       /*!< PMT control and status */
+   __I  uint32_t  RESERVED1[2];
+   __I  uint32_t  MAC_INTR;                /*!< Interrupt status register */
+   __IO uint32_t  MAC_INTR_MASK;           /*!< Interrupt mask register */
+   __IO uint32_t  MAC_ADDR0_HIGH;          /*!< MAC address 0 high register */
+   __IO uint32_t  MAC_ADDR0_LOW;           /*!< MAC address 0 low register */
+   __I  uint32_t  RESERVED2[430];
+   __IO uint32_t  MAC_TIMESTP_CTRL;        /*!< Time stamp control register */
+   __IO uint32_t  SUBSECOND_INCR;          /*!< Sub-second increment register */
+   __I  uint32_t  SECONDS;                 /*!< System time seconds register */
+   __I  uint32_t  NANOSECONDS;             /*!< System time nanoseconds register */
+   __IO uint32_t  SECONDSUPDATE;           /*!< System time seconds update register */
+   __IO uint32_t  NANOSECONDSUPDATE;       /*!< System time nanoseconds update register */
+   __IO uint32_t  ADDEND;                  /*!< Time stamp addend register */
+   __IO uint32_t  TARGETSECONDS;           /*!< Target time seconds register */
+   __IO uint32_t  TARGETNANOSECONDS;       /*!< Target time nanoseconds register */
+   __IO uint32_t  HIGHWORD;                /*!< System time higher word seconds register */
+   __I  uint32_t  TIMESTAMPSTAT;           /*!< Time stamp status register */
+   __IO uint32_t  PPSCTRL;                 /*!< PPS control register */
+   __I  uint32_t  AUXNANOSECONDS;          /*!< Auxiliary time stamp nanoseconds register */
+   __I  uint32_t  AUXSECONDS;              /*!< Auxiliary time stamp seconds register */
+   __I  uint32_t  RESERVED3[562];
+   __IO uint32_t  DMA_BUS_MODE;            /*!< Bus Mode Register      */
+   __IO uint32_t  DMA_TRANS_POLL_DEMAND;   /*!< Transmit poll demand register */
+   __IO uint32_t  DMA_REC_POLL_DEMAND;     /*!< Receive poll demand register */
+   __IO uint32_t  DMA_REC_DES_ADDR;        /*!< Receive descriptor list address register */
+   __IO uint32_t  DMA_TRANS_DES_ADDR;      /*!< Transmit descriptor list address register */
+   __IO uint32_t  DMA_STAT;                /*!< Status register */
+   __IO uint32_t  DMA_OP_MODE;             /*!< Operation mode register */
+   __IO uint32_t  DMA_INT_EN;              /*!< Interrupt enable register */
+   __I  uint32_t  DMA_MFRM_BUFOF;          /*!< Missed frame and buffer overflow register */
+   __IO uint32_t  DMA_REC_INT_WDT;         /*!< Receive interrupt watchdog timer register */
+   __I  uint32_t  RESERVED4[8];
+   __I  uint32_t  DMA_CURHOST_TRANS_DES;   /*!< Current host transmit descriptor register */
+   __I  uint32_t  DMA_CURHOST_REC_DES;     /*!< Current host receive descriptor register */
+   __I  uint32_t  DMA_CURHOST_TRANS_BUF;   /*!< Current host transmit buffer address register */
+   __I  uint32_t  DMA_CURHOST_REC_BUF;     /*!< Current host receive buffer address register */
+} LPC_ENET_T;
+
+/*
+ * @brief MAC_CONFIG register bit defines
+ */
+#define MAC_CFG_RE     (1 << 2)        /*!< Receiver enable */
+#define MAC_CFG_TE     (1 << 3)        /*!< Transmitter Enable */
+#define MAC_CFG_DF     (1 << 4)        /*!< Deferral Check */
+#define MAC_CFG_BL(n)  ((n) << 5)  /*!< Back-Off Limit */
+#define MAC_CFG_ACS    (1 << 7)        /*!< Automatic Pad/CRC Stripping */
+#define MAC_CFG_LUD    (1 << 8)        /*!< Link Up/Down, 1 = up */
+#define MAC_CFG_DR     (1 << 9)        /*!< Disable Retry */
+#define MAC_CFG_IPC    (1 << 10)   /*!< Checksum Offload */
+#define MAC_CFG_DM     (1 << 11)   /*!< Duplex Mode, 1 = full, 0 = half */
+#define MAC_CFG_LM     (1 << 12)   /*!< Loopback Mode */
+#define MAC_CFG_DO     (1 << 13)   /*!< Disable Receive Own */
+#define MAC_CFG_FES    (1 << 14)   /*!< Speed, 1 = 100Mbps, 0 = 10Mbos */
+#define MAC_CFG_PS     (1 << 15)   /*!< Port select, must always be 1 */
+#define MAC_CFG_DCRS   (1 << 16)   /*!< Disable carrier sense during transmission */
+#define MAC_CFG_IFG(n) ((n) << 17) /*!< Inter-frame gap, 40..96, n incs by 8 */
+#define MAC_CFG_JE     (1 << 20)   /*!< Jumbo Frame Enable */
+#define MAC_CFG_JD     (1 << 22)   /*!< Jabber Disable */
+#define MAC_CFG_WD     (1 << 23)   /*!< Watchdog Disable */
+
+/*
+ * @brief MAC_FRAME_FILTER register bit defines
+ */
+#define MAC_FF_PR      (1 << 0)        /*!< Promiscuous Mode */
+#define MAC_FF_DAIF    (1 << 3)        /*!< DA Inverse Filtering */
+#define MAC_FF_PM      (1 << 4)        /*!< Pass All Multicast */
+#define MAC_FF_DBF     (1 << 5)        /*!< Disable Broadcast Frames */
+#define MAC_FF_PCF(n)  ((n) << 6)  /*!< Pass Control Frames, n = see user manual */
+#define MAC_FF_SAIF    (1 << 8)        /*!< SA Inverse Filtering */
+#define MAC_FF_SAF     (1 << 9)        /*!< Source Address Filter Enable */
+#define MAC_FF_RA      (1UL << 31) /*!< Receive all */
+
+/*
+ * @brief MAC_MII_ADDR register bit defines
+ */
+#define MAC_MIIA_GB    (1 << 0)        /*!< MII busy */
+#define MAC_MIIA_W     (1 << 1)        /*!< MII write */
+#define MAC_MIIA_CR(n) ((n) << 2)  /*!< CSR clock range, n = see manual */
+#define MAC_MIIA_GR(n) ((n) << 6)  /*!< MII register. n = 0..31 */
+#define MAC_MIIA_PA(n) ((n) << 11) /*!< Physical layer address, n = 0..31 */
+
+/*
+ * @brief MAC_MII_DATA register bit defines
+ */
+#define MAC_MIID_GDMSK (0xFFFF)        /*!< MII data mask */
+
+/**
+ * @brief MAC_FLOW_CONTROL register bit defines
+ */
+#define MAC_FC_FCB     (1 << 0)        /*!< Flow Control Busy/Backpressure Activate */
+#define MAC_FC_TFE     (1 << 1)        /*!< Transmit Flow Control Enable */
+#define MAC_FC_RFE     (1 << 2)        /*!< Receive Flow Control Enable */
+#define MAC_FC_UP      (1 << 3)        /*!< Unicast Pause Frame Detect */
+#define MAC_FC_PLT(n)  ((n) << 4)  /*!< Pause Low Threshold, n = see manual */
+#define MAC_FC_DZPQ    (1 << 7)        /*!< Disable Zero-Quanta Pause */
+#define MAC_FC_PT(n)   ((n) << 16) /*!< Pause time */
+
+/*
+ * @brief MAC_VLAN_TAG register bit defines
+ */
+#define MAC_VT_VL(n)   ((n) << 0)  /*!< VLAN Tag Identifier for Receive Frames */
+#define MAC_VT_ETC     (1 << 7)        /*!< Enable 12-Bit VLAN Tag Comparison */
+
+/*
+ * @brief MAC_PMT_CTRL_STAT register bit defines
+ */
+#define MAC_PMT_PD     (1 << 0)        /*!< Power-down */
+#define MAC_PMT_MPE    (1 << 1)        /*!< Magic packet enable */
+#define MAC_PMT_WFE    (1 << 2)        /*!< Wake-up frame enable */
+#define MAC_PMT_MPR    (1 << 5)        /*!< Magic Packet Received */
+#define MAC_PMT_WFR    (1 << 6)        /*!< Wake-up Frame Received */
+#define MAC_PMT_GU     (1 << 9)        /*!< Global Unicast */
+#define MAC_PMT_WFFRPR (1UL << 31) /*!< Wake-up Frame Filter Register Pointer Reset */
+
+/*
+ * @brief MAC_INTR_MASK register bit defines
+ */
+#define MAC_IM_PMT     (1 << 3)        /*!< PMT Interrupt Mask */
+
+/*
+ * @brief MAC_ADDR0_HIGH register bit defines
+ */
+#define MAC_ADRH_MO    (1UL << 31) /*!< Always 1 when writing register */
+
+/*
+ * @brief MAC_ADDR0_HIGH register bit defines
+ */
+#define MAC_ADRH_MO    (1UL << 31) /*!< Always 1 when writing register */
+
+/*
+ * @brief MAC_TIMESTAMP register bit defines
+ */
+#define MAC_TS_TSENA   (1 << 0)        /*!< Time Stamp Enable */
+#define MAC_TS_TSCFUP  (1 << 1)        /*!< Time Stamp Fine or Coarse Update */
+#define MAC_TS_TSINIT  (1 << 2)        /*!< Time Stamp Initialize */
+#define MAC_TS_TSUPDT  (1 << 3)        /*!< Time Stamp Update */
+#define MAC_TS_TSTRIG  (1 << 4)        /*!< Time Stamp Interrupt Trigger Enable */
+#define MAC_TS_TSADDR  (1 << 5)        /*!< Addend Reg Update */
+#define MAC_TS_TSENAL  (1 << 8)        /*!< Enable Time Stamp for All Frames */
+#define MAC_TS_TSCTRL  (1 << 9)        /*!< Time Stamp Digital or Binary rollover control */
+#define MAC_TS_TSVER2  (1 << 10)   /*!< Enable PTP packet snooping for version 2 format */
+#define MAC_TS_TSIPENA (1 << 11)   /*!< Enable Time Stamp Snapshot for PTP over Ethernet frames */
+#define MAC_TS_TSIPV6E (1 << 12)   /*!< Enable Time Stamp Snapshot for IPv6 frames */
+#define MAC_TS_TSIPV4E (1 << 13)   /*!< Enable Time Stamp Snapshot for IPv4 frames */
+#define MAC_TS_TSEVNT  (1 << 14)   /*!< Enable Time Stamp Snapshot for Event Messages */
+#define MAC_TS_TSMSTR  (1 << 15)   /*!< Enable Snapshot for Messages Relevant to Master */
+#define MAC_TS_TSCLKT(n) ((n) << 16)   /*!< Select the type of clock node, n = see menual */
+#define MAC_TS_TSENMA  (1 << 18)   /*!< Enable MAC address for PTP frame filtering */
+
+/*
+ * @brief DMA_BUS_MODE register bit defines
+ */
+#define DMA_BM_SWR     (1 << 0)        /*!< Software reset */
+#define DMA_BM_DA      (1 << 1)        /*!< DMA arbitration scheme, 1 = TX has priority over TX */
+#define DMA_BM_DSL(n)  ((n) << 2)  /*!< Descriptor skip length, n = see manual */
+#define DMA_BM_ATDS    (1 << 7)        /*!< Alternate (Enhanced) descriptor size */
+#define DMA_BM_PBL(n)  ((n) << 8)  /*!< Programmable burst length, n = see manual */
+#define DMA_BM_PR(n)   ((n) << 14) /*!< Rx-to-Tx priority ratio, n = see manual */
+#define DMA_BM_FB      (1 << 16)   /*!< Fixed burst */
+#define DMA_BM_RPBL(n) ((n) << 17) /*!< RxDMA PBL, n = see manual */
+#define DMA_BM_USP     (1 << 23)   /*!< Use separate PBL */
+#define DMA_BM_PBL8X   (1 << 24)   /*!< 8 x PBL mode */
+#define DMA_BM_AAL     (1 << 25)   /*!< Address-aligned beats */
+#define DMA_BM_MB      (1 << 26)   /*!< Mixed burst */
+#define DMA_BM_TXPR    (1 << 27)   /*!< Transmit DMA has higher priority than receive DMA */
+
+/*
+ * @brief DMA_STAT register bit defines
+ */
+#define DMA_ST_TI      (1 << 0)        /*!< Transmit interrupt */
+#define DMA_ST_TPS     (1 << 1)        /*!< Transmit process stopped */
+#define DMA_ST_TU      (1 << 2)        /*!< Transmit buffer unavailable */
+#define DMA_ST_TJT     (1 << 3)        /*!< Transmit jabber timeout */
+#define DMA_ST_OVF     (1 << 4)        /*!< Receive overflow */
+#define DMA_ST_UNF     (1 << 5)        /*!< Transmit underflow */
+#define DMA_ST_RI      (1 << 6)        /*!< Receive interrupt */
+#define DMA_ST_RU      (1 << 7)        /*!< Receive buffer unavailable */
+#define DMA_ST_RPS     (1 << 8)        /*!< Received process stopped */
+#define DMA_ST_RWT     (1 << 9)        /*!< Receive watchdog timeout */
+#define DMA_ST_ETI     (1 << 10)   /*!< Early transmit interrupt */
+#define DMA_ST_FBI     (1 << 13)   /*!< Fatal bus error interrupt */
+#define DMA_ST_ERI     (1 << 14)   /*!< Early receive interrupt */
+#define DMA_ST_AIE     (1 << 15)   /*!< Abnormal interrupt summary */
+#define DMA_ST_NIS     (1 << 16)   /*!< Normal interrupt summary */
+#define DMA_ST_ALL     (0x1E7FF)   /*!< All interrupts */
+
+/*
+ * @brief DMA_OP_MODE register bit defines
+ */
+#define DMA_OM_SR      (1 << 1)        /*!< Start/stop receive */
+#define DMA_OM_OSF     (1 << 2)        /*!< Operate on second frame */
+#define DMA_OM_RTC(n)  ((n) << 3)  /*!< Receive threshold control, n = see manual */
+#define DMA_OM_FUF     (1 << 6)        /*!< Forward undersized good frames */
+#define DMA_OM_FEF     (1 << 7)        /*!< Forward error frames */
+#define DMA_OM_ST      (1 << 13)   /*!< Start/Stop Transmission Command */
+#define DMA_OM_TTC(n)  ((n) << 14) /*!< Transmit threshold control, n = see manual */
+#define DMA_OM_FTF     (1 << 20)   /*!< Flush transmit FIFO */
+#define DMA_OM_TSF     (1 << 21)   /*!< Transmit store and forward */
+#define DMA_OM_DFF     (1 << 24)   /*!< Disable flushing of received frames */
+#define DMA_OM_RSF     (1 << 25)   /*!< Receive store and forward */
+#define DMA_OM_DT      (1 << 26)   /*!< Disable Dropping of TCP/IP Checksum Error Frames */
+
+/*
+ * @brief DMA_INT_EN register bit defines
+ */
+#define DMA_IE_TIE     (1 << 0)        /*!< Transmit interrupt enable */
+#define DMA_IE_TSE     (1 << 1)        /*!< Transmit stopped enable */
+#define DMA_IE_TUE     (1 << 2)        /*!< Transmit buffer unavailable enable */
+#define DMA_IE_TJE     (1 << 3)        /*!< Transmit jabber timeout enable */
+#define DMA_IE_OVE     (1 << 4)        /*!< Overflow interrupt enable */
+#define DMA_IE_UNE     (1 << 5)        /*!< Underflow interrupt enable */
+#define DMA_IE_RIE     (1 << 6)        /*!< Receive interrupt enable */
+#define DMA_IE_RUE     (1 << 7)        /*!< Receive buffer unavailable enable */
+#define DMA_IE_RSE     (1 << 8)        /*!< Received stopped enable */
+#define DMA_IE_RWE     (1 << 9)        /*!< Receive watchdog timeout enable */
+#define DMA_IE_ETE     (1 << 10)   /*!< Early transmit interrupt enable */
+#define DMA_IE_FBE     (1 << 13)   /*!< Fatal bus error enable */
+#define DMA_IE_ERE     (1 << 14)   /*!< Early receive interrupt enable */
+#define DMA_IE_AIE     (1 << 15)   /*!< Abnormal interrupt summary enable */
+#define DMA_IE_NIE     (1 << 16)   /*!< Normal interrupt summary enable */
+
+/*
+ * @brief DMA_MFRM_BUFOF register bit defines
+ */
+#define DMA_MFRM_FMCMSK (0xFFFF)   /*!< Number of frames missed mask */
+#define DMA_MFRM_OC    (1 << 16)   /*!< Overflow bit for missed frame counter */
+#define DMA_MFRM_FMA(n) (((n) & 0x0FFE0000) >> 17) /*!< Number of frames missed by the application mask/shift */
+#define DMA_MFRM_OF    (1 << 28)   /*!< Overflow bit for FIFO overflow counter */
+
+/*
+ * @brief Common TRAN_DESC_T and TRAN_DESC_ENH_T CTRLSTAT field bit defines
+ */
+#define TDES_DB        (1 << 0)        /*!< Deferred Bit */
+#define TDES_UF        (1 << 1)        /*!< Underflow Error */
+#define TDES_ED        (1 << 2)        /*!< Excessive Deferral */
+#define TDES_CCMSK(n)  (((n) & 0x000000F0) >> 3)/*!< CC: Collision Count (Status field) mask and shift */
+#define TDES_VF        (1 << 7)        /*!< VLAN Frame */
+#define TDES_EC        (1 << 8)        /*!< Excessive Collision */
+#define TDES_LC        (1 << 9)        /*!< Late Collision */
+#define TDES_NC        (1 << 10)   /*!< No Carrier */
+#define TDES_LCAR      (1 << 11)   /*!< Loss of Carrier */
+#define TDES_IPE       (1 << 12)   /*!< IP Payload Error */
+#define TDES_FF        (1 << 13)   /*!< Frame Flushed */
+#define TDES_JT        (1 << 14)   /*!< Jabber Timeout */
+#define TDES_ES        (1 << 15)   /*!< Error Summary */
+#define TDES_IHE       (1 << 16)   /*!< IP Header Error */
+#define TDES_TTSS      (1 << 17)   /*!< Transmit Timestamp Status */
+#define TDES_OWN       (1UL << 31) /*!< Own Bit */
+
+/*
+ * @brief TRAN_DESC_ENH_T only CTRLSTAT field bit defines
+ */
+#define TDES_ENH_IC   (1UL << 30)  /*!< Interrupt on Completion, enhanced descriptor */
+#define TDES_ENH_LS   (1 << 29)        /*!< Last Segment, enhanced descriptor */
+#define TDES_ENH_FS   (1 << 28)        /*!< First Segment, enhanced descriptor */
+#define TDES_ENH_DC   (1 << 27)        /*!< Disable CRC, enhanced descriptor */
+#define TDES_ENH_DP   (1 << 26)        /*!< Disable Pad, enhanced descriptor */
+#define TDES_ENH_TTSE (1 << 25)        /*!< Transmit Timestamp Enable, enhanced descriptor */
+#define TDES_ENH_CIC(n) ((n) << 22)    /*!< Checksum Insertion Control, enhanced descriptor */
+#define TDES_ENH_TER  (1 << 21)        /*!< Transmit End of Ring, enhanced descriptor */
+#define TDES_ENH_TCH  (1 << 20)        /*!< Second Address Chained, enhanced descriptor */
+
+/*
+ * @brief TRAN_DESC_T only BSIZE field bit defines
+ */
+#define TDES_NORM_IC   (1UL << 31) /*!< Interrupt on Completion, normal descriptor */
+#define TDES_NORM_FS   (1 << 30)   /*!< First Segment, normal descriptor */
+#define TDES_NORM_LS   (1 << 29)   /*!< Last Segment, normal descriptor */
+#define TDES_NORM_CIC(n) ((n) << 27)   /*!< Checksum Insertion Control, normal descriptor */
+#define TDES_NORM_DC   (1 << 26)   /*!< Disable CRC, normal descriptor */
+#define TDES_NORM_TER  (1 << 25)   /*!< Transmit End of Ring, normal descriptor */
+#define TDES_NORM_TCH  (1 << 24)   /*!< Second Address Chained, normal descriptor */
+#define TDES_NORM_DP   (1 << 23)   /*!< Disable Pad, normal descriptor */
+#define TDES_NORM_TTSE (1 << 22)   /*!< Transmit Timestamp Enable, normal descriptor */
+#define TDES_NORM_BS2(n) (((n) & 0x3FF) << 11) /*!< Buffer 2 size, normal descriptor */
+#define TDES_NORM_BS1(n) (((n) & 0x3FF) << 0)  /*!< Buffer 1 size, normal descriptor */
+
+/*
+ * @brief TRAN_DESC_ENH_T only BSIZE field bit defines
+ */
+#define TDES_ENH_BS2(n) (((n) & 0xFFF) << 16)  /*!< Buffer 2 size, enhanced descriptor */
+#define TDES_ENH_BS1(n) (((n) & 0xFFF) << 0)   /*!< Buffer 1 size, enhanced descriptor */
+
+/*
+ * @brief Common REC_DESC_T and REC_DESC_ENH_T STATUS field bit defines
+ */
+#define RDES_ESA      (1 << 0)     /*!< Extended Status Available/Rx MAC Address */
+#define RDES_CE       (1 << 1)     /*!< CRC Error */
+#define RDES_DRE      (1 << 2)     /*!< Dribble Bit Error */
+#define RDES_RE       (1 << 3)     /*!< Receive Error */
+#define RDES_RWT      (1 << 4)     /*!< Receive Watchdog Timeout */
+#define RDES_FT       (1 << 5)     /*!< Frame Type */
+#define RDES_LC       (1 << 6)     /*!< Late Collision */
+#define RDES_TSA      (1 << 7)     /*!< Timestamp Available/IP Checksum Error (Type1) /Giant Frame */
+#define RDES_LS       (1 << 8)     /*!< Last Descriptor */
+#define RDES_FS       (1 << 9)     /*!< First Descriptor */
+#define RDES_VLAN     (1 << 10)        /*!< VLAN Tag */
+#define RDES_OE       (1 << 11)        /*!< Overflow Error */
+#define RDES_LE       (1 << 12)        /*!< Length Error */
+#define RDES_SAF      (1 << 13)        /*!< Source Address Filter Fail */
+#define RDES_DE       (1 << 14)        /*!< Descriptor Error */
+#define RDES_ES       (1 << 15)        /*!< ES: Error Summary */
+#define RDES_FLMSK(n) (((n) & 0x3FFF0000) >> 16)/*!< Frame Length mask and shift */
+#define RDES_AFM      (1 << 30)        /*!< Destination Address Filter Fail */
+#define RDES_OWN      (1UL << 31)  /*!< Own Bit */
+
+/*
+ * @brief Common REC_DESC_T and REC_DESC_ENH_T CTRL field bit defines
+ */
+#define RDES_DINT     (1UL << 31)  /*!< Disable interrupt on completion */
+
+/*
+ * @brief REC_DESC_T pnly CTRL field bit defines
+ */
+#define RDES_NORM_RER (1 << 25)        /*!< Receive End of Ring, normal descriptor */
+#define RDES_NORM_RCH (1 << 24)        /*!< Second Address Chained, normal descriptor */
+#define RDES_NORM_BS2(n) (((n) & 0x3FF) << 11) /*!< Buffer 2 size, normal descriptor */
+#define RDES_NORM_BS1(n) (((n) & 0x3FF) << 0)  /*!< Buffer 1 size, normal descriptor */
+
+/**
+ * @brief REC_DESC_ENH_T only CTRL field bit defines
+ */
+#define RDES_ENH_RER  (1 << 15)        /*!< Receive End of Ring, enhanced descriptor */
+#define RDES_ENH_RCH  (1 << 14)        /*!< Second Address Chained, enhanced descriptor */
+#define RDES_ENH_BS2(n) (((n) & 0xFFF) << 16)  /*!< Buffer 2 size, enhanced descriptor */
+#define RDES_ENH_BS1(n) (((n) & 0xFFF) << 0)   /*!< Buffer 1 size, enhanced descriptor */
+
+/*
+ * @brief REC_DESC_ENH_T only EXTSTAT field bit defines
+ */
+#define RDES_ENH_IPPL(n)  (((n) & 0x7) >> 2)   /*!< IP Payload Type mask and shift, enhanced descripto */
+#define RDES_ENH_IPHE     (1 << 3) /*!< IP Header Error, enhanced descripto */
+#define RDES_ENH_IPPLE    (1 << 4) /*!< IP Payload Error, enhanced descripto */
+#define RDES_ENH_IPCSB    (1 << 5) /*!< IP Checksum Bypassed, enhanced descripto */
+#define RDES_ENH_IPV4     (1 << 6) /*!< IPv4 Packet Received, enhanced descripto */
+#define RDES_ENH_IPV6     (1 << 7) /*!< IPv6 Packet Received, enhanced descripto */
+#define RDES_ENH_MTMSK(n) (((n) & 0xF) >> 8)   /*!< Message Type mask and shift, enhanced descripto */
+
+/*
+ * @brief Maximum size of an ethernet buffer
+ */
+#define EMAC_ETH_MAX_FLEN (1536)
+
+/**
+ * @brief Structure of a transmit descriptor (without timestamp)
+ */
+typedef struct {
+   __IO uint32_t CTRLSTAT;     /*!< TDES control and status word */
+   __IO uint32_t BSIZE;        /*!< Buffer 1/2 byte counts */
+   __IO uint32_t B1ADD;        /*!< Buffer 1 address */
+   __IO uint32_t B2ADD;        /*!< Buffer 2 or next descriptor address */
+} ENET_TXDESC_T;
+
+/**
+ * @brief Structure of a enhanced transmit descriptor (with timestamp)
+ */
+typedef struct {
+   __IO uint32_t CTRLSTAT;     /*!< TDES control and status word */
+   __IO uint32_t BSIZE;        /*!< Buffer 1/2 byte counts */
+   __IO uint32_t B1ADD;        /*!< Buffer 1 address */
+   __IO uint32_t B2ADD;        /*!< Buffer 2 or next descriptor address */
+   __IO uint32_t TDES4;        /*!< Reserved */
+   __IO uint32_t TDES5;        /*!< Reserved */
+   __IO uint32_t TTSL;         /*!< Timestamp value low */
+   __IO uint32_t TTSH;         /*!< Timestamp value high */
+} ENET_ENHTXDESC_T;
+
+/**
+ * @brief Structure of a receive descriptor (without timestamp)
+ */
+typedef struct {
+   __IO uint32_t STATUS;       /*!< RDES status word */
+   __IO uint32_t CTRL;         /*!< Buffer 1/2 byte counts and control */
+   __IO uint32_t B1ADD;        /*!< Buffer 1 address */
+   __IO uint32_t B2ADD;        /*!< Buffer 2 or next descriptor address */
+} ENET_RXDESC_T;
+
+/**
+ * @brief Structure of a enhanced receive descriptor (with timestamp)
+ */
+typedef struct {
+   __IO uint32_t STATUS;       /*!< RDES status word */
+   __IO uint32_t CTRL;         /*!< Buffer 1/2 byte counts */
+   __IO uint32_t B1ADD;        /*!< Buffer 1 address */
+   __IO uint32_t B2ADD;        /*!< Buffer 2 or next descriptor address */
+   __IO uint32_t EXTSTAT;      /*!< Extended Status */
+   __IO uint32_t RDES5;        /*!< Reserved */
+   __IO uint32_t RTSL;         /*!< Timestamp value low */
+   __IO uint32_t RTSH;         /*!< Timestamp value high */
+} ENET_ENHRXDESC_T;
+
+/**
+ * @brief  Resets the ethernet interface
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ * @note   Resets the ethernet interface. This should be called prior to
+ * Chip_ENET_Init with a small delay after this call.
+ */
+STATIC INLINE void Chip_ENET_Reset(LPC_ENET_T *pENET)
+{
+   /* This should be called prior to IP_ENET_Init. The MAC controller may
+      not be ready for a call to init right away so a small delay should
+      occur after this call. */
+   pENET->DMA_BUS_MODE |= DMA_BM_SWR;
+}
+
+/**
+ * @brief  Sets the address of the interface
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @param  macAddr : Pointer to the 6 bytes used for the MAC address
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_SetADDR(LPC_ENET_T *pENET, const uint8_t *macAddr)
+{
+   /* Save MAC address */
+   pENET->MAC_ADDR0_LOW = ((uint32_t) macAddr[3] << 24) |
+                          ((uint32_t) macAddr[2] << 16) | ((uint32_t) macAddr[1] << 8) |
+                          ((uint32_t) macAddr[0]);
+   pENET->MAC_ADDR0_HIGH = ((uint32_t) macAddr[5] << 8) |
+                           ((uint32_t) macAddr[4]);
+}
+
+/**
+ * @brief  Sets up the PHY link clock divider and PHY address
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @param  div     : Divider index, not a divider value, see user manual
+ * @param  addr    : PHY address, used with MII read and write
+ * @return Nothing
+ */
+void Chip_ENET_SetupMII(LPC_ENET_T *pENET, uint32_t div, uint8_t addr);
+
+/**
+ * @brief  Starts a PHY write via the MII
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @param  reg     : PHY register to write
+ * @param  data    : Data to write to PHY register
+ * @return Nothing
+ * @note   Start a PHY write operation. Does not block, requires calling
+ * IP_ENET_IsMIIBusy to determine when write is complete.
+ */
+void Chip_ENET_StartMIIWrite(LPC_ENET_T *pENET, uint8_t reg, uint16_t data);
+
+/**
+ * @brief  Starts a PHY read via the MII
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @param  reg     : PHY register to read
+ * @return Nothing
+ * @note   Start a PHY read operation. Does not block, requires calling
+ * IP_ENET_IsMIIBusy to determine when read is complete and calling
+ * IP_ENET_ReadMIIData to get the data.
+ */
+void Chip_ENET_StartMIIRead(LPC_ENET_T *pENET, uint8_t reg);
+
+/**
+ * @brief  Returns MII link (PHY) busy status
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Returns true if busy, otherwise false
+ */
+STATIC INLINE bool Chip_ENET_IsMIIBusy(LPC_ENET_T *pENET)
+{
+   return (pENET->MAC_MII_ADDR & MAC_MIIA_GB) ? true : false;
+}
+
+/**
+ * @brief  Returns the value read from the PHY
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Read value from PHY
+ */
+STATIC INLINE uint16_t Chip_ENET_ReadMIIData(LPC_ENET_T *pENET)
+{
+   return pENET->MAC_MII_DATA;
+}
+
+/**
+ * @brief  Enables ethernet transmit
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_TXEnable(LPC_ENET_T *pENET)
+{
+   pENET->MAC_CONFIG |= MAC_CFG_TE;
+   pENET->DMA_OP_MODE |= DMA_OM_ST;
+}
+
+/**
+ * @brief Disables ethernet transmit
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_TXDisable(LPC_ENET_T *pENET)
+{
+   pENET->MAC_CONFIG &= ~MAC_CFG_TE;
+}
+
+/**
+ * @brief  Enables ethernet packet reception
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_RXEnable(LPC_ENET_T *pENET)
+{
+   pENET->MAC_CONFIG |= MAC_CFG_RE;
+   pENET->DMA_OP_MODE |= DMA_OM_SR;
+}
+
+/**
+ * @brief  Disables ethernet packet reception
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_RXDisable(LPC_ENET_T *pENET)
+{
+   pENET->MAC_CONFIG &= ~MAC_CFG_RE;
+}
+
+/**
+ * @brief  Enable RMII ethernet operation
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ * @note   This function must be called to enable the internal
+ * RMII PHY, and must be called before calling any Ethernet
+ * functions.
+ */
+STATIC INLINE void Chip_ENET_RMIIEnable(LPC_ENET_T *pENET)
+{
+   LPC_CREG->CREG6 |= 0x4;
+}
+
+/**
+ * @brief  Enable MII ethernet operation
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ * @note   This function must be called to enable the
+ * MII PHY, and must be called before calling any Ethernet
+ * functions.
+ */
+STATIC INLINE void Chip_ENET_MIIEnable(LPC_ENET_T *pENET)
+{
+   LPC_CREG->CREG6 &= ~0x7;
+}
+
+/**
+ * @brief  Sets full or half duplex for the interface
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @param  full    : true to selected full duplex, false for half
+ * @return Nothing
+ */
+void Chip_ENET_SetDuplex(LPC_ENET_T *pENET, bool full);
+
+/**
+ * @brief  Sets speed for the interface
+ * @param  pENET       : The base of ENET peripheral on the chip
+ * @param  speed100    : true to select 100Mbps mode, false for 10Mbps
+ * @return Nothing
+ */
+void Chip_ENET_SetSpeed(LPC_ENET_T *pENET, bool speed100);
+
+/**
+ * @brief  Configures the initial ethernet descriptors
+ * @param  pENET       : The base of ENET peripheral on the chip
+ * @param  pTXDescs    : Pointer to TX descriptor list
+ * @param  pRXDescs    : Pointer to RX descriptor list
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_InitDescriptors(LPC_ENET_T *pENET,
+                                            ENET_ENHTXDESC_T *pTXDescs, ENET_ENHRXDESC_T *pRXDescs)
+{
+   /* Setup descriptor list base addresses */
+   pENET->DMA_TRANS_DES_ADDR = (uint32_t) pTXDescs;
+   pENET->DMA_REC_DES_ADDR = (uint32_t) pRXDescs;
+}
+
+/**
+ * @brief  Starts receive polling of RX descriptors
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_RXStart(LPC_ENET_T *pENET)
+{
+   /* Start receive polling */
+   pENET->DMA_REC_POLL_DEMAND = 1;
+}
+
+/**
+ * @brief  Starts transmit polling of TX descriptors
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_ENET_TXStart(LPC_ENET_T *pENET)
+{
+   /* Start transmit polling */
+   pENET->DMA_TRANS_POLL_DEMAND = 1;
+}
+
+/**
+ * @brief  Initialize ethernet interface
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @param  phyAddr : Address of the Phy [valid range 0 to 31]
+ * @return Nothing
+ * @note   Performs basic initialization of the ethernet interface in a default
+ * state. This is enough to place the interface in a usable state, but
+ * may require more setup outside this function.
+ */
+void Chip_ENET_Init(LPC_ENET_T *pENET, uint32_t phyAddr);
+
+/**
+ * @brief  De-initialize the ethernet interface
+ * @param  pENET   : The base of ENET peripheral on the chip
+ * @return Nothing
+ */
+void Chip_ENET_DeInit(LPC_ENET_T *pENET);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ENET_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/error.h ./lpc_chip_43xx/inc/error.h
--- a_qSC69Z/lpc_chip_43xx/inc/error.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/error.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,272 @@
+/*
+ * @brief Error code returned by Boot ROM drivers/library functions
+ *
+ *  This file contains unified error codes to be used across driver,
+ *  middleware, applications, hal and demo software.
+ *
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LPC_ERROR_H__
+#define __LPC_ERROR_H__
+
+/** Error code returned by Boot ROM drivers/library functions
+ *
+ *  Error codes are a 32-bit value with :
+ *      - The 16 MSB contains the peripheral code number
+ *      - The 16 LSB contains an error code number associated to that peripheral
+ *
+ */
+typedef enum
+{
+  /**\b 0x00000000*/ LPC_OK=0, /**< enum value returned on Success */
+  /**\b 0xFFFFFFFF*/ ERR_FAILED = -1, /**< enum value returned on general failure */
+  /**\b 0xFFFFFFFE*/ ERR_TIME_OUT = -2, /**< enum value returned on general timeout */
+  /**\b 0xFFFFFFFD*/ ERR_BUSY = -3,    /**< enum value returned when resource is busy */
+
+  /* ISP related errors */
+  ERR_ISP_BASE = 0x00000000,
+  /*0x00000001*/ ERR_ISP_INVALID_COMMAND = ERR_ISP_BASE + 1,
+  /*0x00000002*/ ERR_ISP_SRC_ADDR_ERROR, /* Source address not on word boundary */
+  /*0x00000003*/ ERR_ISP_DST_ADDR_ERROR, /* Destination address not on word or 256 byte boundary */
+  /*0x00000004*/ ERR_ISP_SRC_ADDR_NOT_MAPPED,
+  /*0x00000005*/ ERR_ISP_DST_ADDR_NOT_MAPPED,
+  /*0x00000006*/ ERR_ISP_COUNT_ERROR, /* Byte count is not multiple of 4 or is not a permitted value */
+  /*0x00000007*/ ERR_ISP_INVALID_SECTOR,
+  /*0x00000008*/ ERR_ISP_SECTOR_NOT_BLANK,
+  /*0x00000009*/ ERR_ISP_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION,
+  /*0x0000000A*/ ERR_ISP_COMPARE_ERROR,
+  /*0x0000000B*/ ERR_ISP_BUSY, /* Flash programming hardware interface is busy */
+  /*0x0000000C*/ ERR_ISP_PARAM_ERROR, /* Insufficient number of parameters */
+  /*0x0000000D*/ ERR_ISP_ADDR_ERROR, /* Address not on word boundary */
+  /*0x0000000E*/ ERR_ISP_ADDR_NOT_MAPPED,
+  /*0x0000000F*/ ERR_ISP_CMD_LOCKED, /* Command is locked */
+  /*0x00000010*/ ERR_ISP_INVALID_CODE, /* Unlock code is invalid */
+  /*0x00000011*/ ERR_ISP_INVALID_BAUD_RATE,
+  /*0x00000012*/ ERR_ISP_INVALID_STOP_BIT,
+  /*0x00000013*/ ERR_ISP_CODE_READ_PROTECTION_ENABLED,
+  /*0x00000014*/ ERR_ISP_INVALID_FLASH_UNIT,
+  /*0x00000015*/ ERR_ISP_USER_CODE_CHECKSUM,
+  /*0x00000016*/ ERR_ISP_SETTING_ACTIVE_PARTITION,
+  /*0x00000017*/ ERR_ISP_IRC_NO_POWER,
+  /*0x00000018*/ ERR_ISP_FLASH_NO_POWER,
+  /*0x00000019*/ ERR_ISP_EEPROM_NO_POWER,
+  /*0x0000001A*/ ERR_ISP_EEPROM_NO_CLOCK,
+  /*0x0000001B*/ ERR_ISP_FLASH_NO_CLOCK,
+  /*0x0000001C*/ ERR_ISP_REINVOKE_ISP_CONFIG,
+
+  /* ROM API related errors */
+  ERR_API_BASE = 0x00010000,
+  /**\b 0x00010001*/ ERR_API_INVALID_PARAMS = ERR_API_BASE + 1, /**< Invalid parameters*/
+  /**\b 0x00010002*/ ERR_API_INVALID_PARAM1, /**< PARAM1 is invalid */
+  /**\b 0x00010003*/ ERR_API_INVALID_PARAM2, /**< PARAM2 is invalid */
+  /**\b 0x00010004*/ ERR_API_INVALID_PARAM3, /**< PARAM3 is invalid */
+  /**\b 0x00010005*/ ERR_API_MOD_INIT, /**< API is called before module init */
+
+  /* SPIFI API related errors */
+  ERR_SPIFI_BASE = 0x00020000,
+  /*0x00020001*/ ERR_SPIFI_DEVICE_ERROR =ERR_SPIFI_BASE+1,
+  /*0x00020002*/ ERR_SPIFI_INTERNAL_ERROR,
+  /*0x00020003*/ ERR_SPIFI_TIMEOUT,
+  /*0x00020004*/ ERR_SPIFI_OPERAND_ERROR,
+  /*0x00020005*/ ERR_SPIFI_STATUS_PROBLEM,
+  /*0x00020006*/ ERR_SPIFI_UNKNOWN_EXT,
+  /*0x00020007*/ ERR_SPIFI_UNKNOWN_ID,
+  /*0x00020008*/ ERR_SPIFI_UNKNOWN_TYPE,
+  /*0x00020009*/ ERR_SPIFI_UNKNOWN_MFG,
+  /*0x0002000A*/ ERR_SPIFI_NO_DEVICE,
+  /*0x0002000B*/ ERR_SPIFI_ERASE_NEEDED,
+
+  SEC_AES_NO_ERROR=0,
+  /* Security API related errors */
+  ERR_SEC_AES_BASE = 0x00030000,
+  /*0x00030001*/ ERR_SEC_AES_WRONG_CMD=ERR_SEC_AES_BASE+1,
+  /*0x00030002*/ ERR_SEC_AES_NOT_SUPPORTED,
+  /*0x00030003*/ ERR_SEC_AES_KEY_ALREADY_PROGRAMMED,
+  /*0x00030004*/ ERR_SEC_AES_DMA_CHANNEL_CFG,
+  /*0x00030005*/ ERR_SEC_AES_DMA_MUX_CFG,
+  /*0x00030006*/ SEC_AES_DMA_BUSY,
+
+  /* USB device stack related errors */
+  ERR_USBD_BASE = 0x00040000,
+  /**\b 0x00040001*/ ERR_USBD_INVALID_REQ = ERR_USBD_BASE + 1, /**< invalid request */
+  /**\b 0x00040002*/ ERR_USBD_UNHANDLED, /**< Callback did not process the event */
+  /**\b 0x00040003*/ ERR_USBD_STALL,     /**< Stall the endpoint on which the call back is called */
+  /**\b 0x00040004*/ ERR_USBD_SEND_ZLP,  /**< Send ZLP packet on the endpoint on which the call back is called */
+  /**\b 0x00040005*/ ERR_USBD_SEND_DATA, /**< Send data packet on the endpoint on which the call back is called */
+  /**\b 0x00040006*/ ERR_USBD_BAD_DESC,  /**< Bad descriptor*/
+  /**\b 0x00040007*/ ERR_USBD_BAD_CFG_DESC,/**< Bad config descriptor*/
+  /**\b 0x00040008*/ ERR_USBD_BAD_INTF_DESC,/**< Bad interface descriptor*/
+  /**\b 0x00040009*/ ERR_USBD_BAD_EP_DESC,/**< Bad endpoint descriptor*/
+  /**\b 0x0004000a*/ ERR_USBD_BAD_MEM_BUF, /**< Bad alignment of buffer passed. */
+  /**\b 0x0004000b*/ ERR_USBD_TOO_MANY_CLASS_HDLR, /**< Too many class handlers. */
+
+  /* CGU  related errors */
+  ERR_CGU_BASE = 0x00050000,
+  /*0x00050001*/ ERR_CGU_NOT_IMPL=ERR_CGU_BASE+1,
+  /*0x00050002*/ ERR_CGU_INVALID_PARAM,
+  /*0x00050003*/ ERR_CGU_INVALID_SLICE,
+  /*0x00050004*/ ERR_CGU_OUTPUT_GEN,
+  /*0x00050005*/ ERR_CGU_DIV_SRC,
+  /*0x00050006*/ ERR_CGU_DIV_VAL,
+  /*0x00050007*/ ERR_CGU_SRC,
+
+  /*  I2C related errors   */
+  ERR_I2C_BASE = 0x00060000,
+  /*0x00060000*/ ERR_I2C_BUSY = ERR_I2C_BASE,
+  /*0x00060001*/ ERR_I2C_NAK,
+  /*0x00060002*/ ERR_I2C_BUFFER_OVERFLOW,
+  /*0x00060003*/ ERR_I2C_BYTE_COUNT_ERR,
+  /*0x00060004*/ ERR_I2C_LOSS_OF_ARBRITRATION,
+  /*0x00060005*/ ERR_I2C_SLAVE_NOT_ADDRESSED,
+  /*0x00060006*/ ERR_I2C_LOSS_OF_ARBRITRATION_NAK_BIT,
+  /*0x00060007*/ ERR_I2C_GENERAL_FAILURE,
+  /*0x00060008*/ ERR_I2C_REGS_SET_TO_DEFAULT,
+  /*0x00060009*/ ERR_I2C_TIMEOUT,
+  /*0x0006000A*/ ERR_I2C_BUFFER_UNDERFLOW,
+  /*0x0006000B*/ ERR_I2C_PARAM,
+
+   /* OTP  related errors */
+  ERR_OTP_BASE = 0x00070000,
+  /*0x00070001*/ ERR_OTP_WR_ENABLE_INVALID = ERR_OTP_BASE+1,
+  /*0x00070002*/ ERR_OTP_SOME_BITS_ALREADY_PROGRAMMED,
+  /*0x00070003*/ ERR_OTP_ALL_DATA_OR_MASK_ZERO,
+  /*0x00070004*/ ERR_OTP_WRITE_ACCESS_LOCKED,
+  /*0x00070005*/ ERR_OTP_READ_DATA_MISMATCH,
+  /*0x00070006*/ ERR_OTP_USB_ID_ENABLED,
+  /*0x00070007*/ ERR_OTP_ETH_MAC_ENABLED,
+  /*0x00070008*/ ERR_OTP_AES_KEYS_ENABLED,
+  /*0x00070009*/ ERR_OTP_ILLEGAL_BANK,
+
+  /*  UART related errors   */
+  ERR_UART_BASE = 0x00080000,
+  /*0x00080001*/ ERR_UART_RXD_BUSY = ERR_UART_BASE+1,   //UART rxd is busy
+  /*0x00080002*/ ERR_UART_TXD_BUSY,   //UART txd is busy
+  /*0x00080003*/ ERR_UART_OVERRUN_FRAME_PARITY_NOISE, //overrun err, frame err, parity err, RxNoise err
+  /*0x00080004*/ ERR_UART_UNDERRUN,    //underrun err
+  /*0x00080005*/ ERR_UART_PARAM,       //parameter is error
+  /*0x00080006*/ ERR_UART_BAUDRATE,    //baudrate setting is error
+
+  /*  CAN related errors   */
+  ERR_CAN_BASE = 0x00090000,
+  /*0x00090001*/ ERR_CAN_BAD_MEM_BUF = ERR_CAN_BASE+1,
+  /*0x00090002*/ ERR_CAN_INIT_FAIL,
+  /*0x00090003*/ ERR_CANOPEN_INIT_FAIL,
+
+  /* SPIFI Lite API related errors */
+  ERR_SPIFI_LITE_BASE = 0x000A0000,
+  /*0x000A0001*/ ERR_SPIFI_LITE_INVALID_ARGUMENTS = ERR_SPIFI_LITE_BASE+1,
+  /*0x000A0002*/ ERR_SPIFI_LITE_BUSY,
+  /*0x000A0003*/ ERR_SPIFI_LITE_MEMORY_MODE_ON,
+  /*0x000A0004*/ ERR_SPIFI_LITE_MEMORY_MODE_OFF,
+  /*0x000A0005*/ ERR_SPIFI_LITE_IN_DMA,
+  /*0x000A0006*/ ERR_SPIFI_LITE_NOT_IN_DMA,
+  /*0x000A0100*/ PENDING_SPIFI_LITE,
+
+  /* CLK related errors */
+  ERR_CLK_BASE = 0x000B0000,
+  /*0x000B0001*/ ERR_CLK_NOT_IMPL=ERR_CLK_BASE+1,
+  /*0x000B0002*/ ERR_CLK_INVALID_PARAM,
+  /*0x000B0003*/ ERR_CLK_INVALID_SLICE,
+  /*0x000B0004*/ ERR_CLK_OUTPUT_GEN,
+  /*0x000B0005*/ ERR_CLK_DIV_SRC,
+  /*0x000B0006*/ ERR_CLK_DIV_VAL,
+  /*0x000B0007*/ ERR_CLK_SRC,
+  /*0x000B0008*/ ERR_CLK_PLL_FIN_TOO_SMALL,
+  /*0x000B0009*/ ERR_CLK_PLL_FIN_TOO_LARGE,
+  /*0x000B000A*/ ERR_CLK_PLL_FOUT_TOO_SMALL,
+  /*0x000B000B*/ ERR_CLK_PLL_FOUT_TOO_LARGE,
+  /*0x000B000C*/ ERR_CLK_PLL_NO_SOLUTION,
+  /*0x000B000D*/ ERR_CLK_PLL_MIN_PCT,
+  /*0x000B000E*/ ERR_CLK_PLL_MAX_PCT,
+  /*0x000B000F*/ ERR_CLK_OSC_FREQ,
+  /*0x000B0010*/ ERR_CLK_CFG,
+  /*0x000B0011*/ ERR_CLK_TIMEOUT,
+  /*0x000B0012*/ ERR_CLK_BASE_OFF,
+  /*0x000B0013*/ ERR_CLK_OFF_DEADLOCK,
+
+  /*Power API*/
+  ERR_PWR_BASE = 0x000C0000,
+  /*0x000C0001*/  PWR_ERROR_ILLEGAL_MODE=ERR_PWR_BASE+1,
+  /*0x000C0002*/  PWR_ERROR_CLOCK_FREQ_TOO_HIGH,
+  /*0x000C0003*/  PWR_ERROR_INVALID_STATE,
+  /*0x000C0004*/  PWR_ERROR_INVALID_CFG,
+  /*0x000C0005*/  PWR_ERROR_PVT_DETECT,
+
+  /* DMA related errors */
+  ERR_DMA_BASE = 0x000D0000,
+  /*0x000D0001*/    ERR_DMA_ERROR_INT=ERR_DMA_BASE+1,
+  /*0x000D0002*/    ERR_DMA_CHANNEL_NUMBER,
+  /*0x000D0003*/    ERR_DMA_CHANNEL_DISABLED,
+  /*0x000D0004*/    ERR_DMA_BUSY,
+  /*0x000D0005*/    ERR_DMA_NOT_ALIGNMENT,
+  /*0x000D0006*/    ERR_DMA_PING_PONG_EN,
+  /*0x000D0007*/    ERR_DMA_CHANNEL_VALID_PENDING,
+  /*0x000D0008*/    ERR_DMA_PARAM,
+  /*0x000D0009*/    ERR_DMA_QUEUE_EMPTY,
+  /*0x000D000A*/    ERR_DMA_GENERAL,
+
+  /* SPI related errors */
+  ERR_SPI_BASE = 0x000E0000,
+  /*0x000E0000*/    ERR_SPI_BUSY=ERR_SPI_BASE,
+  /*0x000E0001*/    ERR_SPI_RXOVERRUN,
+  /*0x000E0002*/    ERR_SPI_TXUNDERRUN,
+  /*0x000E0003*/    ERR_SPI_SELNASSERT,
+  /*0x000E0004*/    ERR_SPI_SELNDEASSERT,
+  /*0x000E0005*/    ERR_SPI_CLKSTALL,
+  /*0x000E0006*/    ERR_SPI_PARAM,
+  /*0x000E0007*/    ERR_SPI_INVALID_LENGTH,
+
+  /* ADC related errors */
+  ERR_ADC_BASE = 0x000F0000,
+  /*0x000F0001*/    ERR_ADC_OVERRUN=ERR_ADC_BASE+1,
+  /*0x000F0002*/    ERR_ADC_INVALID_CHANNEL,
+  /*0x000F0003*/    ERR_ADC_INVALID_SEQUENCE,
+  /*0x000F0004*/    ERR_ADC_INVALID_SETUP,
+  /*0x000F0005*/    ERR_ADC_PARAM,
+  /*0x000F0006*/    ERR_ADC_INVALID_LENGTH,
+  /*0x000F0007*/    ERR_ADC_NO_POWER,
+
+  /* Debugger Mailbox related errors */
+  ERR_DM_BASE = 0x00100000,
+  /*0x00100001*/    ERR_DM_NOT_ENTERED=ERR_DM_BASE+1,
+  /*0x00100002*/    ERR_DM_UNKNOWN_CMD,
+  /*0x00100003*/    ERR_DM_COMM_FAIL
+
+} ErrorCode_t;
+
+#ifndef offsetof
+#define offsetof(s, m)   (int) &(((s *) 0)->m)
+#endif
+
+#define COMPILE_TIME_ASSERT(pred)    switch (0) { \
+   case 0: \
+   case pred:; }
+
+#endif /* __LPC_ERROR_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/evrt_18xx_43xx.h ./lpc_chip_43xx/inc/evrt_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/evrt_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/evrt_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,171 @@
+/*
+ * @brief LPC18xx/43xx event router driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __EVRT_18XX_43XX_H_
+#define __EVRT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup EVRT_18XX_43XX CHIP: LPC18xx/43xx Event router driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Event Router register structure
+ */
+typedef struct {                       /*!< EVENTROUTER Structure  */
+   __IO uint32_t HILO;                 /*!< Level configuration register */
+   __IO uint32_t EDGE;                 /*!< Edge configuration     */
+   __I  uint32_t RESERVED0[1012];
+   __O  uint32_t CLR_EN;               /*!< Event clear enable register */
+   __O  uint32_t SET_EN;               /*!< Event set enable register */
+   __I  uint32_t STATUS;               /*!< Status register        */
+   __I  uint32_t ENABLE;               /*!< Enable register        */
+   __O  uint32_t CLR_STAT;             /*!< Clear register         */
+   __O  uint32_t SET_STAT;             /*!< Set register           */
+} LPC_EVRT_T;
+
+/**
+ * @brief EVRT input sources
+ */
+typedef enum CHIP_EVRT_SRC {
+   EVRT_SRC_WAKEUP0,           /*!< WAKEUP0 event router source        */
+   EVRT_SRC_WAKEUP1,           /*!< WAKEUP1 event router source        */
+   EVRT_SRC_WAKEUP2,           /*!< WAKEUP2 event router source        */
+   EVRT_SRC_WAKEUP3,           /*!< WAKEUP3 event router source        */
+   EVRT_SRC_ATIMER,            /*!< Alarm timer event router source    */
+   EVRT_SRC_RTC,               /*!< RTC event router source            */
+   EVRT_SRC_BOD1,              /*!< BOD event router source            */
+   EVRT_SRC_WWDT,              /*!< WWDT event router source           */
+   EVRT_SRC_ETHERNET,          /*!< Ethernet event router source       */
+   EVRT_SRC_USB0,              /*!< USB0 event router source           */
+   EVRT_SRC_USB1,              /*!< USB1 event router source           */
+   EVRT_SRC_SDIO,              /*!< Reserved                           */
+   EVRT_SRC_CCAN,              /*!< C_CAN event router source          */
+   EVRT_SRC_COMBINE_TIMER2,    /*!< Combined timer 2 event router source   */
+   EVRT_SRC_COMBINE_TIMER6,    /*!< Combined timer 6 event router source   */
+   EVRT_SRC_QEI,               /*!< QEI event router source            */
+   EVRT_SRC_COMBINE_TIMER14,   /*!< Combined timer 14 event router source  */
+   EVRT_SRC_RESERVED1,         /*!< Reserved                           */
+   EVRT_SRC_RESERVED2,         /*!< Reserved                           */
+   EVRT_SRC_RESET              /*!< Reset event router source          */
+} CHIP_EVRT_SRC_T;
+
+/**
+ * @brief Macro for checking for a valid EVRT source
+ */
+#define PARAM_EVRT_SOURCE(n)    ((n == EVRT_SRC_WAKEUP0) || (n == EVRT_SRC_WAKEUP1)    \
+                                || (n == EVRT_SRC_WAKEUP2) || (n == EVRT_SRC_WAKEUP3) \
+                                || (n == EVRT_SRC_ATIMER) || (n == EVRT_SRC_RTC) \
+                                || (n == EVRT_SRC_BOD1) || (n == EVRT_SRC_WWDT) \
+                                || (n == EVRT_SRC_ETHERNET) || (n == EVRT_SRC_USB0) \
+                                || (n == EVRT_SRC_USB1) || (n == EVRT_SRC_CCAN) || (n == EVRT_SRC_SDIO) \
+                                || (n == EVRT_SRC_COMBINE_TIMER2) || (n == EVRT_SRC_COMBINE_TIMER6) \
+                                || (n == EVRT_SRC_QEI) || (n == EVRT_SRC_COMBINE_TIMER14) \
+                                || (n == EVRT_SRC_RESET)) \
+
+/**
+ * @brief EVRT input state detecting type
+ */
+typedef enum CHIP_EVRT_SRC_ACTIVE {
+   EVRT_SRC_ACTIVE_LOW_LEVEL,      /*!< Active low level       */
+   EVRT_SRC_ACTIVE_HIGH_LEVEL,     /*!< Active high level      */
+   EVRT_SRC_ACTIVE_FALLING_EDGE,   /*!< Active falling edge    */
+   EVRT_SRC_ACTIVE_RISING_EDGE     /*!< Active rising edge     */
+} CHIP_EVRT_SRC_ACTIVE_T;
+
+/**
+ * @brief Macro for checking for a valid EVRT state type
+ */
+#define PARAM_EVRT_SOURCE_ACTIVE_TYPE(n) ((n == EVRT_SRC_ACTIVE_LOW_LEVEL) || (n == EVRT_SRC_ACTIVE_HIGH_LEVEL)    \
+                                         || (n == EVRT_SRC_ACTIVE_FALLING_EDGE) || (n == EVRT_SRC_ACTIVE_RISING_EDGE))
+
+/**
+ * @brief  Initialize the EVRT
+ * @return Nothing
+ */
+void Chip_EVRT_Init (void);
+
+/**
+ * @brief  Set up the type of interrupt type for a source to EVRT
+ * @param  EVRT_Src    : EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @param  type        : EVRT type, should be one of CHIP_EVRT_SRC_ACTIVE_T type
+ * @return Nothing
+ */
+void Chip_EVRT_ConfigIntSrcActiveType(CHIP_EVRT_SRC_T EVRT_Src, CHIP_EVRT_SRC_ACTIVE_T type);
+
+/**
+ * @brief  Check if a source is sending interrupt to EVRT
+ * @param  EVRT_Src    : EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @return true if the interrupt from the source is pending, otherwise false
+ */
+IntStatus Chip_EVRT_IsSourceInterrupting(CHIP_EVRT_SRC_T EVRT_Src);
+
+/**
+ * @brief  Enable or disable interrupt sources to EVRT
+ * @param  EVRT_Src    : EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @param  state       : ENABLE or DISABLE to enable or disable event router source
+ * @return Nothing
+ */
+void Chip_EVRT_SetUpIntSrc(CHIP_EVRT_SRC_T EVRT_Src, FunctionalState state);
+
+/**
+ * @brief  De-initializes the EVRT peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EVRT_DeInit(void)
+{
+   LPC_EVRT->CLR_EN    = 0xFFFF;
+   LPC_EVRT->CLR_STAT  = 0xFFFF;
+}
+
+/**
+ * @brief  Clear pending interrupt EVRT source
+ * @param  EVRT_Src    : EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @return Nothing
+ */
+STATIC INLINE void Chip_EVRT_ClrPendIntSrc(CHIP_EVRT_SRC_T EVRT_Src)
+{
+   LPC_EVRT->CLR_STAT = (1 << (uint8_t) EVRT_Src);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __EVRT_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/fmc_18xx_43xx.h ./lpc_chip_43xx/inc/fmc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/fmc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/fmc_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,139 @@
+/*
+ * @brief LPC18xx/43xx FLASH Memory Controller (FMC) driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __FMC_18XX_43XX_H_
+#define __FMC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup FMC_18XX_43XX CHIP: LPC18xx/43xx FLASH Memory Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief FLASH Memory Controller Unit register block structure
+ */
+typedef struct {       /*!< FMC Structure */
+   __I  uint32_t  RESERVED1[8];
+   __IO uint32_t  FMSSTART;
+   __IO uint32_t  FMSSTOP;
+   __I  uint32_t  RESERVED2;
+   __I  uint32_t  FMSW[4];
+   __I  uint32_t  RESERVED3[1001];
+   __I  uint32_t  FMSTAT;
+   __I  uint32_t  RESERVED5;
+   __O  uint32_t  FMSTATCLR;
+   __I  uint32_t  RESERVED4[5];
+} LPC_FMC_T;
+
+/* Flash signature start and busy status bit */
+#define FMC_FLASHSIG_BUSY       (1UL << 17)
+
+/* Flash signature clear status bit */
+#define FMC_FLASHSIG_STAT       (1 << 2)
+
+/**
+ * @brief  Start computation of a signature for a FLASH memory range
+ * @param  bank    : FLASH bank, A = 0, B = 1
+ * @param  start   : Starting FLASH address for computation, must be aligned on 16 byte boundary
+ * @param  stop    : Ending FLASH address for computation, must be aligned on 16 byte boundary
+ * @return Nothing
+ * @note   Only bits 20..4 are used for the FLASH signature computation.
+ *         Use the Chip_FMC_IsSignatureBusy() function to determine when the
+ *         signature computation operation is complete and use the
+ *         Chip_FMC_GetSignature() function to get the computed signature.
+ */
+STATIC INLINE void Chip_FMC_ComputeSignature(uint8_t bank, uint32_t start, uint32_t stop)
+{
+   LPC_FMC[bank]->FMSSTART = (start >> 4);
+   LPC_FMC[bank]->FMSTATCLR = FMC_FLASHSIG_STAT;
+   LPC_FMC[bank]->FMSSTOP = (stop >> 4) | FMC_FLASHSIG_BUSY;
+}
+
+/**
+ * @brief  Start computation of a signature for a FLASH memory address and block count
+ * @param  bank    : FLASH bank, A = 0, B = 1
+ * @param  start   : Starting FLASH address for computation, must be aligned on 16 byte boundary
+ * @param  blocks  : Number of 16 byte blocks used for computation
+ * @return Nothing
+ * @note   Only bits 20..4 are used for the FLASH signature computation.
+ *         Use the Chip_FMC_IsSignatureBusy() function to determine when the
+ *         signature computation operation is complete and the
+ *         Chip_FMC_GetSignature() function to get the computed signature.
+ */
+STATIC INLINE void Chip_FMC_ComputeSignatureBlocks(uint8_t bank, uint32_t start, uint32_t blocks)
+{
+   Chip_FMC_ComputeSignature(bank, start, (start + (blocks * 16)));
+}
+
+/**
+ * @brief  Clear signature generation completion flag
+ * @param  bank    : FLASH bank, A = 0, B = 1
+ * @return Nothing
+ */
+STATIC INLINE void Chip_FMC_ClearSignatureBusy(uint8_t bank)
+{
+   LPC_FMC[bank]->FMSTATCLR = FMC_FLASHSIG_STAT;
+}
+
+/**
+ * @brief  Check for signature generation completion
+ * @param  bank    : FLASH bank, A = 0, B = 1
+ * @return true if the signature computation is running, false if finished
+ */
+STATIC INLINE bool Chip_FMC_IsSignatureBusy(uint8_t bank)
+{
+   return (bool) ((LPC_FMC[bank]->FMSTAT & FMC_FLASHSIG_STAT) == 0);
+}
+
+/**
+ * @brief  Returns the generated FLASH signature value
+ * @param  bank    : FLASH bank, A = 0, B = 1
+ * @param  index   : Signature index to get - use 0 to FMSW0, 1 to FMSW1, etc.
+ * @return the generated FLASH signature value
+ */
+STATIC INLINE uint32_t Chip_FMC_GetSignature(uint8_t bank, int index)
+{
+   return LPC_FMC[bank]->FMSW[index];
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __FMC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/fpu_init.h ./lpc_chip_43xx/inc/fpu_init.h
--- a_qSC69Z/lpc_chip_43xx/inc/fpu_init.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/fpu_init.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,52 @@
+/*
+ * @brief FPU init code
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __FPU_INIT_H_
+#define __FPU_INIT_H_
+
+/**
+ * @defgroup CHIP_FPU_CMX CHIP: FPU initialization
+ * @ingroup CHIP_Common
+ * Cortex FPU initialization
+ * @{
+ */
+
+/**
+ * @brief  Early initialization of the FPU
+ * @return Nothing
+ */
+void fpuInit(void);
+
+/**
+ * @}
+ */
+
+#endif /* __FPU_INIT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/gima_18xx_43xx.h ./lpc_chip_43xx/inc/gima_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/gima_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/gima_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,66 @@
+/*
+ * @brief LPC18xx/43xx GIMA driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GIMA_18XX_43XX_H_
+#define __GIMA_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GIMA_18XX_43XX CHIP: LPC18xx/43xx GIMA driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Global Input Multiplexer Array (GIMA) register block structure
+ */
+typedef struct {                       /*!< GIMA Structure */
+   __IO uint32_t  CAP0_IN[4][4];       /*!< Timer x CAP0_y capture input multiplexer (GIMA output ((x*4)+y)) */
+   __IO uint32_t  CTIN_IN[8];          /*!< SCT CTIN_x capture input multiplexer (GIMA output (16+x)) */
+   __IO uint32_t  ADCHS_TRIGGER_IN;    /*!< ADCHS trigger input multiplexer (GIMA output 24) */
+   __IO uint32_t  EVENTROUTER_13_IN;   /*!< Event router input 13 multiplexer (GIMA output 25) */
+   __IO uint32_t  EVENTROUTER_14_IN;   /*!< Event router input 14 multiplexer (GIMA output 26) */
+   __IO uint32_t  EVENTROUTER_16_IN;   /*!< Event router input 16 multiplexer (GIMA output 27) */
+   __IO uint32_t  ADCSTART0_IN;        /*!< ADC start0 input multiplexer (GIMA output 28) */
+   __IO uint32_t  ADCSTART1_IN;        /*!< ADC start1 input multiplexer (GIMA output 29) */
+} LPC_GIMA_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GIMA_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/gpdma_18xx_43xx.h ./lpc_chip_43xx/inc/gpdma_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/gpdma_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/gpdma_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,418 @@
+/*
+ * @brief LPC18xx/43xx General Purpose DMA driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights. NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPDMA_18XX_43XX_H_
+#define __GPDMA_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPDMA_18XX_43XX CHIP: LPC18xx/43xx General Purpose DMA driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Number of channels on GPDMA
+ */
+#define GPDMA_NUMBER_CHANNELS 8
+
+/**
+ * @brief GPDMA Channel register block structure
+ */
+typedef struct {
+   __IO uint32_t  SRCADDR;             /*!< DMA Channel Source Address Register */
+   __IO uint32_t  DESTADDR;            /*!< DMA Channel Destination Address Register */
+   __IO uint32_t  LLI;                 /*!< DMA Channel Linked List Item Register */
+   __IO uint32_t  CONTROL;             /*!< DMA Channel Control Register */
+   __IO uint32_t  CONFIG;              /*!< DMA Channel Configuration Register */
+   __I  uint32_t  RESERVED1[3];
+} GPDMA_CH_T;
+
+/**
+ * @brief GPDMA register block
+ */
+typedef struct {                       /*!< GPDMA Structure */
+   __I  uint32_t  INTSTAT;             /*!< DMA Interrupt Status Register */
+   __I  uint32_t  INTTCSTAT;           /*!< DMA Interrupt Terminal Count Request Status Register */
+   __O  uint32_t  INTTCCLEAR;          /*!< DMA Interrupt Terminal Count Request Clear Register */
+   __I  uint32_t  INTERRSTAT;          /*!< DMA Interrupt Error Status Register */
+   __O  uint32_t  INTERRCLR;           /*!< DMA Interrupt Error Clear Register */
+   __I  uint32_t  RAWINTTCSTAT;        /*!< DMA Raw Interrupt Terminal Count Status Register */
+   __I  uint32_t  RAWINTERRSTAT;       /*!< DMA Raw Error Interrupt Status Register */
+   __I  uint32_t  ENBLDCHNS;           /*!< DMA Enabled Channel Register */
+   __IO uint32_t  SOFTBREQ;            /*!< DMA Software Burst Request Register */
+   __IO uint32_t  SOFTSREQ;            /*!< DMA Software Single Request Register */
+   __IO uint32_t  SOFTLBREQ;           /*!< DMA Software Last Burst Request Register */
+   __IO uint32_t  SOFTLSREQ;           /*!< DMA Software Last Single Request Register */
+   __IO uint32_t  CONFIG;              /*!< DMA Configuration Register */
+   __IO uint32_t  SYNC;                /*!< DMA Synchronization Register */
+   __I  uint32_t  RESERVED0[50];
+   GPDMA_CH_T     CH[GPDMA_NUMBER_CHANNELS];
+} LPC_GPDMA_T;
+
+/**
+ * @brief Macro defines for DMA channel control registers
+ */
+#define GPDMA_DMACCxControl_TransferSize(n) (((n & 0xFFF) << 0))   /*!< Transfer size*/
+#define GPDMA_DMACCxControl_SBSize(n)       (((n & 0x07) << 12))   /*!< Source burst size*/
+#define GPDMA_DMACCxControl_DBSize(n)       (((n & 0x07) << 15))   /*!< Destination burst size*/
+#define GPDMA_DMACCxControl_SWidth(n)       (((n & 0x07) << 18))   /*!< Source transfer width*/
+#define GPDMA_DMACCxControl_DWidth(n)       (((n & 0x07) << 21))   /*!< Destination transfer width*/
+#define GPDMA_DMACCxControl_SI              ((1UL << 26))          /*!< Source increment*/
+#define GPDMA_DMACCxControl_DI              ((1UL << 27))          /*!< Destination increment*/
+#define GPDMA_DMACCxControl_SrcTransUseAHBMaster1   ((1UL << 24))  /*!< Source AHB master select in 18xx43xx*/
+#define GPDMA_DMACCxControl_DestTransUseAHBMaster1  ((1UL << 25))  /*!< Destination AHB master select in 18xx43xx*/
+#define GPDMA_DMACCxControl_Prot1           ((1UL << 28))          /*!< Indicates that the access is in user mode or privileged mode*/
+#define GPDMA_DMACCxControl_Prot2           ((1UL << 29))          /*!< Indicates that the access is bufferable or not bufferable*/
+#define GPDMA_DMACCxControl_Prot3           ((1UL << 30))          /*!< Indicates that the access is cacheable or not cacheable*/
+#define GPDMA_DMACCxControl_I               ((1UL << 31))          /*!< Terminal count interrupt enable bit */
+
+/**
+ * @brief Macro defines for DMA Configuration register
+ */
+#define GPDMA_DMACConfig_E              ((0x01))   /*!< DMA Controller enable*/
+#define GPDMA_DMACConfig_M              ((0x02))   /*!< AHB Master endianness configuration*/
+#define GPDMA_DMACConfig_BITMASK        ((0x03))
+
+/**
+ * @brief Macro defines for DMA Channel Configuration registers
+ */
+#define GPDMA_DMACCxConfig_E                    ((1UL << 0))           /*!< DMA control enable*/
+#define GPDMA_DMACCxConfig_SrcPeripheral(n)     (((n & 0x1F) << 1))        /*!< Source peripheral*/
+#define GPDMA_DMACCxConfig_DestPeripheral(n)    (((n & 0x1F) << 6))        /*!< Destination peripheral*/
+#define GPDMA_DMACCxConfig_TransferType(n)      (((n & 0x7) << 11))        /*!< This value indicates the type of transfer*/
+#define GPDMA_DMACCxConfig_IE                   ((1UL << 14))          /*!< Interrupt error mask*/
+#define GPDMA_DMACCxConfig_ITC                  ((1UL << 15))          /*!< Terminal count interrupt mask*/
+#define GPDMA_DMACCxConfig_L                    ((1UL << 16))          /*!< Lock*/
+#define GPDMA_DMACCxConfig_A                    ((1UL << 17))          /*!< Active*/
+#define GPDMA_DMACCxConfig_H                    ((1UL << 18))          /*!< Halt*/
+
+/**
+ * @brief GPDMA Interrupt Clear Status
+ */
+typedef enum {
+   GPDMA_STATCLR_INTTC,    /*!< GPDMA Interrupt Terminal Count Request Clear */
+   GPDMA_STATCLR_INTERR    /*!< GPDMA Interrupt Error Clear */
+} GPDMA_STATECLEAR_T;
+
+/**
+ * @brief GPDMA Type of Interrupt Status
+ */
+typedef enum {
+   GPDMA_STAT_INT,         /*!< GPDMA Interrupt Status */
+   GPDMA_STAT_INTTC,       /*!< GPDMA Interrupt Terminal Count Request Status */
+   GPDMA_STAT_INTERR,      /*!< GPDMA Interrupt Error Status */
+   GPDMA_STAT_RAWINTTC,    /*!< GPDMA Raw Interrupt Terminal Count Status */
+   GPDMA_STAT_RAWINTERR,   /*!< GPDMA Raw Error Interrupt Status */
+   GPDMA_STAT_ENABLED_CH   /*!< GPDMA Enabled Channel Status */
+} GPDMA_STATUS_T;
+
+/**
+ * @brief GPDMA Type of DMA controller
+ */
+typedef enum {
+   GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA              = ((0UL)),   /*!< Memory to memory - DMA control */
+   GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA              = ((1UL)),   /*!< Memory to peripheral - DMA control */
+   GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA              = ((2UL)),   /*!< Peripheral to memory - DMA control */
+   GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA              = ((3UL)),   /*!< Source peripheral to destination peripheral - DMA control */
+   GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL   = ((4UL)),   /*!< Source peripheral to destination peripheral - destination peripheral control */
+   GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL       = ((5UL)),   /*!< Memory to peripheral - peripheral control */
+   GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL       = ((6UL)),   /*!< Peripheral to memory - peripheral control */
+   GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL    = ((7UL))    /*!< Source peripheral to destination peripheral - source peripheral control */
+} GPDMA_FLOW_CONTROL_T;
+
+/**
+ * @brief GPDMA structure using for DMA configuration
+ */
+typedef struct {
+   uint32_t ChannelNum;    /*!< DMA channel number, should be in
+                            *  range from 0 to 7.
+                            *  Note: DMA channel 0 has the highest priority
+                            *  and DMA channel 7 the lowest priority.
+                            */
+   uint32_t TransferSize;  /*!< Length/Size of transfer */
+   uint32_t TransferWidth; /*!< Transfer width - used for TransferType is GPDMA_TRANSFERTYPE_M2M only */
+   uint32_t SrcAddr;       /*!< Physical Source Address, used in case TransferType is chosen as
+                            *   GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_M2P */
+   uint32_t DstAddr;       /*!< Physical Destination Address, used in case TransferType is chosen as
+                            *   GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_P2M */
+   uint32_t TransferType;  /*!< Transfer Type, should be one of the following:
+                            * - GPDMA_TRANSFERTYPE_M2M: Memory to memory - DMA control
+                            * - GPDMA_TRANSFERTYPE_M2P: Memory to peripheral - DMA control
+                            * - GPDMA_TRANSFERTYPE_P2M: Peripheral to memory - DMA control
+                            * - GPDMA_TRANSFERTYPE_P2P: Source peripheral to destination peripheral - DMA control
+                            */
+} GPDMA_CH_CFG_T;
+
+/**
+ * @brief GPDMA request connections
+ */
+#define GPDMA_CONN_MEMORY           ((0UL))            /**< MEMORY             */
+#define GPDMA_CONN_MAT0_0           ((1UL))            /**< MAT0.0             */
+#define GPDMA_CONN_UART0_Tx         ((2UL))            /**< UART0 Tx           */
+#define GPDMA_CONN_MAT0_1           ((3UL))            /**< MAT0.1             */
+#define GPDMA_CONN_UART0_Rx         ((4UL))            /**< UART0 Rx           */
+#define GPDMA_CONN_MAT1_0           ((5UL))            /**< MAT1.0             */
+#define GPDMA_CONN_UART1_Tx         ((6UL))            /**< UART1 Tx           */
+#define GPDMA_CONN_MAT1_1           ((7UL))            /**< MAT1.1             */
+#define GPDMA_CONN_UART1_Rx         ((8UL))            /**< UART1 Rx           */
+#define GPDMA_CONN_MAT2_0           ((9UL))            /**< MAT2.0             */
+#define GPDMA_CONN_UART2_Tx         ((10UL))       /**< UART2 Tx           */
+#define GPDMA_CONN_MAT2_1           ((11UL))       /**< MAT2.1             */
+#define GPDMA_CONN_UART2_Rx         ((12UL))       /**< UART2 Rx           */
+#define GPDMA_CONN_MAT3_0           ((13UL))       /**< MAT3.0             */
+#define GPDMA_CONN_UART3_Tx         ((14UL))       /**< UART3 Tx           */
+#define GPDMA_CONN_SCT_0            ((15UL))       /**< SCT timer channel 0*/
+#define GPDMA_CONN_MAT3_1           ((16UL))       /**< MAT3.1             */
+#define GPDMA_CONN_UART3_Rx         ((17UL))       /**< UART3 Rx           */
+#define GPDMA_CONN_SCT_1            ((18UL))       /**< SCT timer channel 1*/
+#define GPDMA_CONN_SSP0_Rx          ((19UL))       /**< SSP0 Rx            */
+#define GPDMA_CONN_I2S_Tx_Channel_0 ((20UL))       /**< I2S0 Tx on channel 0 */
+#define GPDMA_CONN_SSP0_Tx          ((21UL))       /**< SSP0 Tx            */
+#define GPDMA_CONN_I2S_Rx_Channel_1 ((22UL))       /**< I2S0 Rx on channel 0 */
+#define GPDMA_CONN_SSP1_Rx          ((23UL))       /**< SSP1 Rx            */
+#define GPDMA_CONN_SSP1_Tx          ((24UL))       /**< SSP1 Tx            */
+#define GPDMA_CONN_ADC_0            ((25UL))       /**< ADC 0              */
+#define GPDMA_CONN_ADC_1            ((26UL))       /**< ADC 1              */
+#define GPDMA_CONN_DAC              ((27UL))       /**< DAC                */
+#define GPDMA_CONN_I2S1_Tx_Channel_0 ((28UL))      /**< I2S1 Tx on channel 0 */
+#define GPDMA_CONN_I2S1_Rx_Channel_1 ((29UL))      /**< I2S1 Rx on channel 0 */
+
+/**
+ * @brief GPDMA Burst size in Source and Destination definitions
+ */
+#define GPDMA_BSIZE_1   ((0UL))    /*!< Burst size = 1 */
+#define GPDMA_BSIZE_4   ((1UL))    /*!< Burst size = 4 */
+#define GPDMA_BSIZE_8   ((2UL))    /*!< Burst size = 8 */
+#define GPDMA_BSIZE_16  ((3UL))    /*!< Burst size = 16 */
+#define GPDMA_BSIZE_32  ((4UL))    /*!< Burst size = 32 */
+#define GPDMA_BSIZE_64  ((5UL))    /*!< Burst size = 64 */
+#define GPDMA_BSIZE_128 ((6UL))    /*!< Burst size = 128 */
+#define GPDMA_BSIZE_256 ((7UL))    /*!< Burst size = 256 */
+
+/**
+ * @brief Width in Source transfer width and Destination transfer width definitions
+ */
+#define GPDMA_WIDTH_BYTE        ((0UL))    /*!< Width = 1 byte */
+#define GPDMA_WIDTH_HALFWORD    ((1UL))    /*!< Width = 2 bytes */
+#define GPDMA_WIDTH_WORD        ((2UL))    /*!< Width = 4 bytes */
+
+/**
+ * @brief Flow control definitions
+ */
+#define DMA_CONTROLLER 0       /*!< Flow control is DMA controller*/
+#define SRC_PER_CONTROLLER 1   /*!< Flow control is Source peripheral controller*/
+#define DST_PER_CONTROLLER 2   /*!< Flow control is Destination peripheral controller*/
+
+/**
+ * @brief DMA channel handle structure
+ */
+typedef struct {
+   FunctionalState ChannelStatus;  /*!< DMA channel status */
+} DMA_ChannelHandle_t;
+
+/**
+ * @brief Transfer Descriptor structure typedef
+ */
+typedef struct DMA_TransferDescriptor {
+   uint32_t src;   /*!< Source address */
+   uint32_t dst;   /*!< Destination address */
+   uint32_t lli;   /*!< Pointer to next descriptor structure */
+   uint32_t ctrl;  /*!< Control word that has transfer size, type etc. */
+} DMA_TransferDescriptor_t;
+
+/**
+ * @brief  Initialize the GPDMA
+ * @param  pGPDMA  : The base of GPDMA on the chip
+ * @return Nothing
+ */
+void Chip_GPDMA_Init(LPC_GPDMA_T *pGPDMA);
+
+/**
+ * @brief  Shutdown the GPDMA
+ * @param  pGPDMA  : The base of GPDMA on the chip
+ * @return Nothing
+ */
+void Chip_GPDMA_DeInit(LPC_GPDMA_T *pGPDMA);
+
+/**
+ * @brief  Initialize channel configuration strucutre
+ * @param  pGPDMA          : The base of GPDMA on the chip
+ * @param  GPDMACfg        : Pointer to configuration structure to be initialized
+ * @param  ChannelNum      : Channel used for transfer *must be obtained using Chip_GPDMA_GetFreeChannel()*
+ * @param  src             : Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the source
+ * @param  dst             : Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the destination
+ * @param  Size            : The number of DMA transfers
+ * @param  TransferType    : Select the transfer controller and the type of transfer. (See, #GPDMA_FLOW_CONTROL_T)
+ * @return ERROR on error, SUCCESS on success
+ */
+int Chip_GPDMA_InitChannelCfg(LPC_GPDMA_T *pGPDMA,
+                             GPDMA_CH_CFG_T *GPDMACfg,
+                             uint8_t  ChannelNum,
+                             uint32_t src,
+                             uint32_t dst,
+                             uint32_t Size,
+                             GPDMA_FLOW_CONTROL_T TransferType);
+
+/**
+ * @brief  Enable or Disable the GPDMA Channel
+ * @param  pGPDMA      : The base of GPDMA on the chip
+ * @param  channelNum  : The GPDMA channel : 0 - 7
+ * @param  NewState    : ENABLE to enable GPDMA or DISABLE to disable GPDMA
+ * @return Nothing
+ */
+void Chip_GPDMA_ChannelCmd(LPC_GPDMA_T *pGPDMA, uint8_t channelNum, FunctionalState NewState);
+
+/**
+ * @brief  Stop a stream DMA transfer
+ * @param  pGPDMA      : The base of GPDMA on the chip
+ * @param  ChannelNum  : Channel Number to be closed
+ * @return Nothing
+ */
+void Chip_GPDMA_Stop(LPC_GPDMA_T *pGPDMA, uint8_t ChannelNum);
+
+/**
+ * @brief  The GPDMA stream interrupt status checking
+ * @param  pGPDMA      : The base of GPDMA on the chip
+ * @param  ChannelNum  : Channel Number to be checked on interruption
+ * @return Status:
+ *              - SUCCESS  : DMA transfer success
+ *              - ERROR        : DMA transfer failed
+ */
+Status Chip_GPDMA_Interrupt(LPC_GPDMA_T *pGPDMA, uint8_t ChannelNum);
+
+/**
+ * @brief  Read the status from different registers according to the type
+ * @param  pGPDMA  : The base of GPDMA on the chip
+ * @param  type    : Status mode, should be:
+ *                     - GPDMA_STAT_INT        : GPDMA Interrupt Status
+ *                     - GPDMA_STAT_INTTC      : GPDMA Interrupt Terminal Count Request Status
+ *                     - GPDMA_STAT_INTERR     : GPDMA Interrupt Error Status
+ *                     - GPDMA_STAT_RAWINTTC   : GPDMA Raw Interrupt Terminal Count Status
+ *                     - GPDMA_STAT_RAWINTERR  : GPDMA Raw Error Interrupt Status
+ *                     - GPDMA_STAT_ENABLED_CH : GPDMA Enabled Channel Status
+ * @param  channel : The GPDMA channel : 0 - 7
+ * @return SET is interrupt is pending or RESET if not pending
+ */
+IntStatus Chip_GPDMA_IntGetStatus(LPC_GPDMA_T *pGPDMA, GPDMA_STATUS_T type, uint8_t channel);
+
+/**
+ * @brief  Clear the Interrupt Flag from different registers according to the type
+ * @param  pGPDMA  : The base of GPDMA on the chip
+ * @param  type    : Flag mode, should be:
+ *                     - GPDMA_STATCLR_INTTC   : GPDMA Interrupt Terminal Count Request
+ *                     - GPDMA_STATCLR_INTERR  : GPDMA Interrupt Error
+ * @param  channel : The GPDMA channel : 0 - 7
+ * @return Nothing
+ */
+void Chip_GPDMA_ClearIntPending(LPC_GPDMA_T *pGPDMA, GPDMA_STATECLEAR_T type, uint8_t channel);
+
+/**
+ * @brief  Get a free GPDMA channel for one DMA connection
+ * @param  pGPDMA                  : The base of GPDMA on the chip
+ * @param  PeripheralConnection_ID : Some chip fix each peripheral DMA connection on a specified channel ( have not used in 17xx/40xx )
+ * @return The channel number which is selected
+ */
+uint8_t Chip_GPDMA_GetFreeChannel(LPC_GPDMA_T *pGPDMA,
+                                 uint32_t PeripheralConnection_ID);
+
+/**
+ * @brief  Do a DMA transfer M2M, M2P,P2M or P2P
+ * @param  pGPDMA      : The base of GPDMA on the chip
+ * @param  ChannelNum  : Channel used for transfer
+ * @param  src         : Address of Memory or PeripheralConnection_ID which is the source
+ * @param  dst         : Address of Memory or PeripheralConnection_ID which is the destination
+ * @param  TransferType: Select the transfer controller and the type of transfer. Should be:
+ *                               - GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL
+ *                               - GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL
+ *                               - GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL
+ *                               - GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL
+ * @param  Size        : The number of DMA transfers
+ * @return ERROR on error, SUCCESS on success
+ */
+Status Chip_GPDMA_Transfer(LPC_GPDMA_T *pGPDMA,
+                          uint8_t ChannelNum,
+                          uint32_t src,
+                          uint32_t dst,
+                          GPDMA_FLOW_CONTROL_T TransferType,
+                          uint32_t Size);
+
+/**
+ * @brief  Do a DMA transfer using linked list of descriptors
+ * @param  pGPDMA          : The base of GPDMA on the chip
+ * @param  ChannelNum      : Channel used for transfer *must be obtained using Chip_GPDMA_GetFreeChannel()*
+ * @param  DMADescriptor   : First node in the linked list of descriptors
+ * @param  TransferType    : Select the transfer controller and the type of transfer. (See, #GPDMA_FLOW_CONTROL_T)
+ * @return ERROR on error, SUCCESS on success
+ */
+Status Chip_GPDMA_SGTransfer(LPC_GPDMA_T *pGPDMA,
+                            uint8_t ChannelNum,
+                            const DMA_TransferDescriptor_t *DMADescriptor,
+                            GPDMA_FLOW_CONTROL_T TransferType);
+
+/**
+ * @brief  Prepare a single DMA descriptor
+ * @param  pGPDMA          : The base of GPDMA on the chip
+ * @param  DMADescriptor   : DMA Descriptor to be initialized
+ * @param  src             : Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the source
+ * @param  dst             : Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the destination
+ * @param  Size            : The number of DMA transfers
+ * @param  TransferType    : Select the transfer controller and the type of transfer. (See, #GPDMA_FLOW_CONTROL_T)
+ * @param  NextDescriptor  : Pointer to next descriptor (0 if no more descriptors available)
+ * @return ERROR on error, SUCCESS on success
+ */
+Status Chip_GPDMA_PrepareDescriptor(LPC_GPDMA_T *pGPDMA,
+                                   DMA_TransferDescriptor_t *DMADescriptor,
+                                   uint32_t src,
+                                   uint32_t dst,
+                                   uint32_t Size,
+                                   GPDMA_FLOW_CONTROL_T TransferType,
+                                   const DMA_TransferDescriptor_t *NextDescriptor);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPDMA_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/gpio_18xx_43xx.h ./lpc_chip_43xx/inc/gpio_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/gpio_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/gpio_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,471 @@
+/*
+ * @brief LPC18xx/43xx GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPIO_18XX_43XX_H_
+#define __GPIO_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPIO_18XX_43XX CHIP: LPC18xx/43xx GPIO driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief  GPIO port register block structure
+ */
+typedef struct {               /*!< GPIO_PORT Structure */
+   __IO uint8_t B[128][32];    /*!< Offset 0x0000: Byte pin registers ports 0 to n; pins PIOn_0 to PIOn_31 */
+   __IO uint32_t W[32][32];    /*!< Offset 0x1000: Word pin registers port 0 to n */
+   __IO uint32_t DIR[32];      /*!< Offset 0x2000: Direction registers port n */
+   __IO uint32_t MASK[32];     /*!< Offset 0x2080: Mask register port n */
+   __IO uint32_t PIN[32];      /*!< Offset 0x2100: Portpin register port n */
+   __IO uint32_t MPIN[32];     /*!< Offset 0x2180: Masked port register port n */
+   __IO uint32_t SET[32];      /*!< Offset 0x2200: Write: Set register for port n Read: output bits for port n */
+   __O  uint32_t CLR[32];      /*!< Offset 0x2280: Clear port n */
+   __O  uint32_t NOT[32];      /*!< Offset 0x2300: Toggle port n */
+} LPC_GPIO_T;
+
+/**
+ * @brief  Initialize GPIO block
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @return Nothing
+ */
+void Chip_GPIO_Init(LPC_GPIO_T *pGPIO);
+
+/**
+ * @brief  De-Initialize GPIO block
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @return Nothing
+ */
+void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO);
+
+/**
+ * @brief  Set a GPIO port/bit state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO port to set
+ * @param  pin     : GPIO pin to set
+ * @param  setting : true for high, false for low
+ * @return Nothing
+ */
+STATIC INLINE void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
+{
+   pGPIO->B[port][pin] = setting;
+}
+
+/**
+ * @brief  Set a GPIO pin state via the GPIO byte register
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : GPIO pin to set
+ * @param  setting : true for high, false for low
+ * @return Nothing
+ * @note   This function replaces Chip_GPIO_WritePortBit()
+ */
+STATIC INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
+{
+   pGPIO->B[port][pin] = setting;
+}
+
+/**
+ * @brief  Read a GPIO state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO port to read
+ * @param  pin     : GPIO pin to read
+ * @return true of the GPIO is high, false if low
+ * @note   It is recommended to use the Chip_GPIO_GetPinState() function instead.
+ */
+STATIC INLINE bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
+{
+   return (bool) pGPIO->B[port][pin];
+}
+
+/**
+ * @brief  Get a GPIO pin state via the GPIO byte register
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : GPIO pin to get state for
+ * @return true if the GPIO is high, false if low
+ * @note   This function replaces Chip_GPIO_ReadPortBit()
+ */
+STATIC INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   return (bool) pGPIO->B[port][pin];
+}
+
+/**
+ * @brief  Set a GPIO direction
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO port to set
+ * @param  bit     : GPIO bit to set
+ * @param  setting : true for output, false for input
+ * @return Nothing
+ * @note   It is recommended to use the Chip_GPIO_SetPinDIROutput(),
+ * Chip_GPIO_SetPinDIRInput() or Chip_GPIO_SetPinDIR() functions instead
+ * of this function.
+ */
+void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit, bool setting);
+
+/**
+ * @brief  Set GPIO direction for a single GPIO pin to an output
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : GPIO pin to set direction on as output
+ * @return Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   pGPIO->DIR[port] |= 1UL << pin;
+}
+
+/**
+ * @brief  Set GPIO direction for a single GPIO pin to an input
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : GPIO pin to set direction on as input
+ * @return Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   pGPIO->DIR[port] &= ~(1UL << pin);
+}
+
+/**
+ * @brief  Set GPIO direction for a single GPIO pin
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : GPIO pin to set direction for
+ * @param  output  : true for output, false for input
+ * @return Nothing
+ */
+void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output);
+
+/**
+ * @brief  Read a GPIO direction (out or in)
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO port to read
+ * @param  bit     : GPIO bit to read
+ * @return true of the GPIO is an output, false if input
+ * @note   It is recommended to use the Chip_GPIO_GetPinDIR() function instead.
+ */
+STATIC INLINE bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
+{
+   return (bool) (((pGPIO->DIR[port]) >> bit) & 1);
+}
+
+/**
+ * @brief  Get GPIO direction for a single GPIO pin
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : GPIO pin to get direction for
+ * @return true if the GPIO is an output, false if input
+ */
+STATIC INLINE bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   return (bool) (((pGPIO->DIR[port]) >> pin) & 1);
+}
+
+/**
+ * @brief  Set Direction for a GPIO port
+ * @param  pGPIO       : The base of GPIO peripheral on the chip
+ * @param  portNum     : port Number
+ * @param  bitValue    : GPIO bit to set
+ * @param  out         : Direction value, 0 = input, !0 = output
+ * @return None
+ * @note   Bits set to '0' are not altered. It is recommended to use the
+ * Chip_GPIO_SetPortDIR() function instead.
+ */
+void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out);
+
+/**
+ * @brief  Set GPIO direction for a all selected GPIO pins to an output
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pinMask : GPIO pin mask to set direction on as output (bits 0..b for pins 0..n)
+ * @return Nothing
+ * @note   Sets multiple GPIO pins to the output direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
+{
+   pGPIO->DIR[port] |= pinMask;
+}
+
+/**
+ * @brief  Set GPIO direction for a all selected GPIO pins to an input
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pinMask : GPIO pin mask to set direction on as input (bits 0..b for pins 0..n)
+ * @return Nothing
+ * @note   Sets multiple GPIO pins to the input direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an input.
+ */
+STATIC INLINE void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
+{
+   pGPIO->DIR[port] &= ~pinMask;
+}
+
+/**
+ * @brief  Set GPIO direction for a all selected GPIO pins to an input or output
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pinMask : GPIO pin mask to set direction on (bits 0..b for pins 0..n)
+ * @param  outSet  : Direction value, false = set as inputs, true = set as outputs
+ * @return Nothing
+ * @note   Sets multiple GPIO pins to the input direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an input.
+ */
+void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask, bool outSet);
+
+/**
+ * @brief  Get GPIO direction for a all GPIO pins
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @return a bitfield containing the input and output states for each pin
+ * @note   For pins 0..n, a high state in a bit corresponds to an output state for the
+ * same pin, while a low  state corresponds to an input state.
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+   return pGPIO->DIR[port];
+}
+
+/**
+ * @brief  Set GPIO port mask value for GPIO masked read and write
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : port Number
+ * @param  mask    : Mask value for read and write (only low bits are enabled)
+ * @return Nothing
+ * @note   Controls which bits are set or unset when using the masked
+ * GPIO read and write functions. A low state indicates the pin is settable
+ * and readable via the masked write and read functions.
+ */
+STATIC INLINE void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
+{
+   pGPIO->MASK[port] = mask;
+}
+
+/**
+ * @brief  Get GPIO port mask value used for GPIO masked read and write
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : port Number
+ * @return Returns value set with the Chip_GPIO_SetPortMask() function.
+ * @note   A high bit in the return value indicates that that GPIO pin for the
+ * port cannot be set using the masked write function.
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+   return pGPIO->MASK[port];
+}
+
+/**
+ * @brief  Set all GPIO raw pin states (regardless of masking)
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  value   : Value to set all GPIO pin states (0..n) to
+ * @return Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
+{
+   pGPIO->PIN[port] = value;
+}
+
+/**
+ * @brief  Get all GPIO raw pin states (regardless of masking)
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @return Current (raw) state of all GPIO pins
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+   return pGPIO->PIN[port];
+}
+
+/**
+ * @brief  Set all GPIO pin states, but mask via the MASKP0 register
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  value   : Value to set all GPIO pin states (0..n) to
+ * @return Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
+{
+   pGPIO->MPIN[port] = value;
+}
+
+/**
+ * @brief  Get all GPIO pin statesm but mask via the MASKP0 register
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @return Current (masked) state of all GPIO pins
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+   return pGPIO->MPIN[port];
+}
+
+/**
+ * @brief  Set a GPIO port/bit to the high state
+ * @param  pGPIO       : The base of GPIO peripheral on the chip
+ * @param  portNum     : port number
+ * @param  bitValue    : bit(s) in the port to set high
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output. It is recommended to use the
+ * Chip_GPIO_SetPortOutHigh() function instead.
+ */
+STATIC INLINE void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
+{
+   pGPIO->SET[portNum] = bitValue;
+}
+
+/**
+ * @brief  Set selected GPIO output pins to the high state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pins    : pins (0..n) to set high
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+   pGPIO->SET[port] = pins;
+}
+
+/**
+ * @brief  Set an individual GPIO output pin to the high state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip'
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : pin number (0..n) to set high
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   pGPIO->SET[port] = (1 << pin);
+}
+
+/**
+ * @brief  Set a GPIO port/bit to the low state
+ * @param  pGPIO       : The base of GPIO peripheral on the chip
+ * @param  portNum     : port number
+ * @param  bitValue    : bit(s) in the port to set low
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
+{
+   pGPIO->CLR[portNum] = bitValue;
+}
+
+/**
+ * @brief  Set selected GPIO output pins to the low state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pins    : pins (0..n) to set low
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+   pGPIO->CLR[port] = pins;
+}
+
+/**
+ * @brief  Set an individual GPIO output pin to the low state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : pin number (0..n) to set low
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   pGPIO->CLR[port] = (1 << pin);
+}
+
+/**
+ * @brief  Toggle selected GPIO output pins to the opposite state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pins    : pins (0..n) to toggle
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+   pGPIO->NOT[port] = pins;
+}
+
+/**
+ * @brief  Toggle an individual GPIO output pin to the opposite state
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  port    : GPIO Port number where @a pin is located
+ * @param  pin     : pin number (0..n) to toggle
+ * @return None
+ * @note   Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+   pGPIO->NOT[port] = (1 << pin);
+}
+
+/**
+ * @brief  Read current bit states for the selected port
+ * @param  pGPIO   : The base of GPIO peripheral on the chip
+ * @param  portNum : port number to read
+ * @return Current value of GPIO port
+ * @note   The current states of the bits for the port are read, regardless of
+ * whether the GPIO port bits are input or output.
+ */
+STATIC INLINE uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
+{
+   return pGPIO->PIN[portNum];
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPIO_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h ./lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,205 @@
+/*
+ * @brief LPC18xx/43xx GPIO group driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPIOGROUP_18XX_43XX_H_
+#define __GPIOGROUP_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPIOGP_18XX_43XX CHIP: LPC18xx/43xx GPIO group driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief GPIO grouped interrupt register block structure
+ */
+typedef struct {                   /*!< GPIO_GROUP_INTn Structure */
+   __IO uint32_t  CTRL;            /*!< GPIO grouped interrupt control register */
+   __I  uint32_t  RESERVED0[7];
+   __IO uint32_t  PORT_POL[8];     /*!< GPIO grouped interrupt port polarity register */
+   __IO uint32_t  PORT_ENA[8];     /*!< GPIO grouped interrupt port m enable register */
+   uint32_t       RESERVED1[1000];
+} LPC_GPIOGROUPINT_T;
+
+/**
+ * LPC18xx/43xx GPIO group bit definitions
+ */
+#define GPIOGR_INT      (1 << 0)   /*!< GPIO interrupt pending/clear bit */
+#define GPIOGR_COMB     (1 << 1)   /*!< GPIO interrupt OR(0)/AND(1) mode bit */
+#define GPIOGR_TRIG     (1 << 2)   /*!< GPIO interrupt edge(0)/level(1) mode bit */
+
+/**
+ * @brief  Clear interrupt pending status for the selected group
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_ClearIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+   uint32_t temp;
+
+   temp = pGPIOGPINT[group].CTRL;
+   pGPIOGPINT[group].CTRL = temp | GPIOGR_INT;
+}
+
+/**
+ * @brief  Returns current GPIO group inetrrupt pending status
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @return true if the group interrupt is pending, otherwise false.
+ */
+STATIC INLINE bool Chip_GPIOGP_GetIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+   return (bool) ((pGPIOGPINT[group].CTRL & GPIOGR_INT) != 0);
+}
+
+/**
+ * @brief  Selected GPIO group functionality for trigger on any pin in group (OR mode)
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectOrMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+   pGPIOGPINT[group].CTRL &= ~GPIOGR_COMB;
+}
+
+/**
+ * @brief  Selected GPIO group functionality for trigger on all matching pins in group (AND mode)
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectAndMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+   pGPIOGPINT[group].CTRL |= GPIOGR_COMB;
+}
+
+/**
+ * @brief  Selected GPIO group functionality edge trigger mode
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectEdgeMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+   pGPIOGPINT[group].CTRL &= ~GPIOGR_TRIG;
+}
+
+/**
+ * @brief  Selected GPIO group functionality level trigger mode
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectLevelMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+   pGPIOGPINT[group].CTRL |= GPIOGR_TRIG;
+}
+
+/**
+ * @brief  Set selected pins for the group and port to low level trigger
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @param  port        : GPIO port number
+ * @param  pinMask     : Or'ed value of pins to select for low level (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectLowLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+                                             uint8_t group,
+                                             uint8_t port,
+                                             uint32_t pinMask)
+{
+   pGPIOGPINT[group].PORT_POL[port] &= ~pinMask;
+}
+
+/**
+ * @brief  Set selected pins for the group and port to high level trigger
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @param  port        : GPIO port number
+ * @param  pinMask     : Or'ed value of pins to select for high level (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectHighLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+                                              uint8_t group,
+                                              uint8_t port,
+                                              uint32_t pinMask)
+{
+   pGPIOGPINT[group].PORT_POL[port] |= pinMask;
+}
+
+/**
+ * @brief  Disabled selected pins for the group interrupt
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @param  port        : GPIO port number
+ * @param  pinMask     : Or'ed value of pins to disable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return None
+ * @note   Disabled pins do not contrinute to the group interrupt.
+ */
+STATIC INLINE void Chip_GPIOGP_DisableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+                                               uint8_t group,
+                                               uint8_t port,
+                                               uint32_t pinMask)
+{
+   pGPIOGPINT[group].PORT_ENA[port] &= ~pinMask;
+}
+
+/**
+ * @brief  Enable selected pins for the group interrupt
+ * @param  pGPIOGPINT  : Pointer to GPIO group register block
+ * @param  group       : GPIO group number
+ * @param  port        : GPIO port number
+ * @param  pinMask     : Or'ed value of pins to enable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return None
+ * @note   Enabled pins contribute to the group interrupt.
+ */
+STATIC INLINE void Chip_GPIOGP_EnableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+                                              uint8_t group,
+                                              uint8_t port,
+                                              uint32_t pinMask)
+{
+   pGPIOGPINT[group].PORT_ENA[port] |= pinMask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPIOGROUP_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/hsadc_18xx_43xx.h ./lpc_chip_43xx/inc/hsadc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/hsadc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/hsadc_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,575 @@
+/*
+ * @brief  LPC18xx/43xx High speed ADC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __HSADC_18XX_43XX_H_
+#define __HSADC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup HSADC_18XX_43XX CHIP:  LPC18xx/43xx High speed ADC driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief High speed ADC interrupt control structure
+ */
+typedef struct {
+   __O  uint32_t CLR_EN;           /*!< Interrupt clear mask */
+   __O  uint32_t SET_EN;           /*!< Interrupt set mask */
+   __I  uint32_t MASK;             /*!< Interrupt mask */
+   __I  uint32_t STATUS;           /*!< Interrupt status */
+   __O  uint32_t CLR_STAT;         /*!< Interrupt clear status */
+   __O  uint32_t SET_STAT;         /*!< Interrupt set status */
+   uint32_t RESERVED[2];
+} HSADCINTCTRL_T;
+
+/**
+ * @brief HSADC register block structure
+ */
+typedef struct {                   /*!< HSADC Structure */
+   __O  uint32_t FLUSH;            /*!< Flushes FIFO */
+   __IO uint32_t DMA_REQ;          /*!< Set or clear DMA write request */
+   __I  uint32_t FIFO_STS;         /*!< Indicates FIFO fill level status */
+   __IO uint32_t FIFO_CFG;         /*!< Configures FIFO fill level */
+   __O  uint32_t TRIGGER;          /*!< Enable software trigger to start descriptor processing */
+   __IO uint32_t DSCR_STS;         /*!< Indicates active descriptor table and descriptor entry */
+   __IO uint32_t POWER_DOWN;       /*!< Set or clear power down mode */
+   __IO uint32_t CONFIG;           /*!< Configures external trigger mode, store channel ID in FIFO and walk-up recovery time from power down */
+   __IO uint32_t THR[2];           /*!< Configures window comparator A or B levels */
+   __I  uint32_t LAST_SAMPLE[6];   /*!< Contains last converted sample of input M [M=0..5) and result of window comparator */
+   uint32_t RESERVED0[49];
+   __IO uint32_t ADC_SPEED;        /*!< ADC speed control */
+   __IO uint32_t POWER_CONTROL;    /*!< Configures ADC power vs. speed, DC-in biasing, output format and power gating */
+   uint32_t RESERVED1[61];
+   __I  uint32_t FIFO_OUTPUT[16];  /*!< FIFO output mapped to 16 consecutive address locations */
+   uint32_t RESERVED2[48];
+   __IO uint32_t DESCRIPTOR[2][8]; /*!< Table 0 and 1 descriptors */
+   uint32_t RESERVED3[752];
+   HSADCINTCTRL_T INTS[2];         /*!< Interrupt 0 and 1 control and status registers */
+} LPC_HSADC_T;
+
+#define HSADC_MAX_SAMPLEVAL 0xFFF
+
+/**
+ * @brief  Initialize the High speed ADC
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ */
+void Chip_HSADC_Init(LPC_HSADC_T *pHSADC);
+
+/**
+ * @brief  Shutdown HSADC
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ */
+void Chip_HSADC_DeInit(LPC_HSADC_T *pHSADC);
+
+/**
+ * @brief  Flush High speed ADC FIFO
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_FlushFIFO(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->FLUSH = 1;
+}
+
+/**
+ * @brief  Load a descriptor table from memory by requesting a DMA write
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ * @note   WHat is this used for?
+ */
+STATIC INLINE void Chip_HSADC_LoadDMADesc(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->DMA_REQ = 1;
+}
+
+/**
+ * @brief  Returns current HSADC FIFO fill level
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return FIFO level, 0 for empty, 1 to 15, or 16 for full
+ * @note   WHat is this used for?
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetFIFOLevel(LPC_HSADC_T *pHSADC)
+{
+   return pHSADC->FIFO_STS;
+}
+
+/**
+ * @brief  Sets up HSADC FIFO trip level and packing
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @param  trip    : HSADC FIFO trip point (1 to 15 samples)
+ * @param  packed  : true to pack samples, false for no packing
+ * @return Nothing
+ * @note   The FIFO trip point is used for the DMA or interrupt level.
+ *         Sample packging allows packing 2 samples into a single 32-bit
+ *         word.
+ */
+void Chip_HSADC_SetupFIFO(LPC_HSADC_T *pHSADC, uint8_t trip, bool packed);
+
+/**
+ * @brief  Starts a manual (software) trigger of HSADC descriptors
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_SWTrigger(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->TRIGGER = 1;
+}
+
+/**
+ * @brief  Set active table descriptor index and number
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @param  table   : Table index, 0 or 1
+ * @param  desc    : Descriptor index, 0 to 7
+ * @return Nothing
+ * @note   This function can be used to set active descriptor table and
+ *         active descriptor entry values. The new values will be updated
+ *         immediately. This should only be updated when descriptors are
+ *         not running (halted).
+ */
+STATIC INLINE void Chip_HSADC_SetActiveDescriptor(LPC_HSADC_T *pHSADC, uint8_t table, uint8_t desc)
+{
+   pHSADC->DSCR_STS = (uint32_t) ((desc << 1) | table);
+}
+
+/**
+ * @brief  Returns currently active descriptor index being processed
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return the current active descriptor index, 0 to 7
+ */
+STATIC INLINE uint8_t Chip_HSADC_GetActiveDescriptorIndex(LPC_HSADC_T *pHSADC)
+{
+   return (uint8_t) ((pHSADC->DSCR_STS >> 1) & 0x7);
+}
+
+/**
+ * @brief  Returns currently active descriptor table being processed
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return the current active descriptor table, 0 or 1
+ */
+STATIC INLINE uint8_t Chip_HSADC_GetActiveDescriptorTable(LPC_HSADC_T *pHSADC)
+{
+   return (uint8_t) (pHSADC->DSCR_STS & 1);
+}
+
+/**
+ * @brief  Enables ADC power down mode
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ * @note   In most cases, this function doesn't need to be used as
+ * the descriptors control power as needed.
+ */
+STATIC INLINE void Chip_HSADC_EnablePowerDownMode(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->POWER_DOWN = 1;
+}
+
+/**
+ * @brief  Disables ADC power down mode
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return Nothing
+ * @note   In most cases, this function doesn't need to be used as
+ * the descriptors control power as needed.
+ */
+STATIC INLINE void Chip_HSADC_DisablePowerDownMode(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->POWER_DOWN = 0;
+}
+
+/* HSADC trigger configuration mask types */
+typedef enum {
+   HSADC_CONFIG_TRIGGER_OFF = 0,               /*!< ADCHS triggers off */
+   HSADC_CONFIG_TRIGGER_SW = 1,                /*!< ADCHS software trigger only */
+   HSADC_CONFIG_TRIGGER_EXT = 2,               /*!< ADCHS external trigger only */
+   HSADC_CONFIG_TRIGGER_BOTH = 3               /*!< ADCHS both software and external triggers allowed */
+} HSADC_TRIGGER_MASK_T;
+
+/* HSADC trigger configuration mode types */
+typedef enum {
+   HSADC_CONFIG_TRIGGER_RISEEXT = (0 << 2),    /*!< ADCHS rising external trigger */
+   HSADC_CONFIG_TRIGGER_FALLEXT = (1 << 2),    /*!< ADCHS falling external trigger */
+   HSADC_CONFIG_TRIGGER_LOWEXT = (2 << 2),     /*!< ADCHS low external trigger */
+   HSADC_CONFIG_TRIGGER_HIGHEXT = (3 << 2)     /*!< ADCHS high external trigger */
+} HSADC_TRIGGER_MODE_T;
+
+/* HSADC trigger configuration sync types */
+typedef enum {
+   HSADC_CONFIG_TRIGGER_NOEXTSYNC = (0 << 4),  /*!< do not synchronize external trigger input */
+   HSADC_CONFIG_TRIGGER_EXTSYNC = (1 << 4),    /*!< synchronize external trigger input */
+} HSADC_TRIGGER_SYNC_T;
+
+/* HSADC trigger configuration channel ID */
+typedef enum {
+   HSADC_CHANNEL_ID_EN_NONE = (0 << 5),    /*!< do not add channel ID to FIFO output data */
+   HSADC_CHANNEL_ID_EN_ADD = (1 << 5),     /*!< add channel ID to FIFO output data */
+} HSADC_CHANNEL_ID_EN_T;
+
+/**
+ * @brief  Configure HSADC trigger source and recovery time
+ * @param  pHSADC          : The base of HSADC peripheral on the chip
+ * @param  mask            : HSADC trigger configuration mask type
+ * @param  mode            : HSADC trigger configuration mode type
+ * @param  sync            : HSADC trigger configuration sync type
+ * @param  chID            : HSADC trigger configuration channel ID enable
+ * @param  recoveryTime    : ADC recovery time (in HSADC clocks) from powerdown (255 max)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_ConfigureTrigger(LPC_HSADC_T *pHSADC,
+                                              HSADC_TRIGGER_MASK_T mask,
+                                              HSADC_TRIGGER_MODE_T mode,
+                                              HSADC_TRIGGER_SYNC_T sync,
+                                              HSADC_CHANNEL_ID_EN_T chID, uint16_t recoveryTime)
+{
+   pHSADC->CONFIG = (uint32_t) mask | (uint32_t) mode | (uint32_t) sync |
+                    (uint32_t) chID | (uint32_t) (recoveryTime << 6);
+}
+
+/**
+ * @brief  Set HSADC Threshold low value
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @param   thrnum : Threshold register value (0 for threshold register A, 1 for threshold register B)
+ * @param   value  : Threshold low data value (should be 12-bit value)
+ * @return None
+ */
+void Chip_HSADC_SetThrLowValue(LPC_HSADC_T *pHSADC, uint8_t thrnum, uint16_t value);
+
+/**
+ * @brief  Set HSADC Threshold high value
+ * @param  pHSADC      : The base of HSADC peripheral on the chip
+ * @param   thrnum      : Threshold register value (0 for threshold register A, 1 for threshold register B)
+ * @param   value       : Threshold high data value (should be 12-bit value)
+ * @return None
+ */
+void Chip_HSADC_SetThrHighValue(LPC_HSADC_T *pHSADC, uint8_t thrnum, uint16_t value);
+
+/** HSADC last sample registers bit fields */
+#define HSADC_LS_DONE                    (1 << 0)      /*!< Sample conversion complete bit */
+#define HSADC_LS_OVERRUN                 (1 << 1)      /*!< Sample overrun bit */
+#define HSADC_LS_RANGE_IN                (0 << 2)      /*!< Threshold range comparison is in range */
+#define HSADC_LS_RANGE_BELOW             (1 << 2)      /*!< Threshold range comparison is below range */
+#define HSADC_LS_RANGE_ABOVE             (2 << 2)      /*!< Threshold range comparison is above range */
+#define HSADC_LS_RANGE(val)              ((val) & 0xC) /*!< Mask for threshold crossing comparison result */
+#define HSADC_LS_CROSSING_NONE           (0 << 4)      /*!< No threshold crossing detected */
+#define HSADC_LS_CROSSING_DOWN           (1 << 4)      /*!< Downward threshold crossing detected */
+#define HSADC_LS_CROSSING_UP             (2 << 4)      /*!< Upward threshold crossing detected */
+#define HSADC_LS_CROSSING(val)           ((val) & 0x30)    /*!< Mask for threshold crossing comparison result */
+#define HSADC_LS_DATA(val)               ((val) >> 6)  /*!< Mask data value out of sample */
+
+/**
+ * @brief  Read a ADC last sample register
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  channel : Last sample register to read, 0-5
+ * @return Current raw value of the indexed last sample register
+ * @note   This function returns the raw value of the indexed last sample register
+ * and clears the sample's DONE and OVERRUN statuses if set. You can determine
+ * the overrun and datavalid status for the sample by masking the return value
+ * with HSADC_LS_DONE or HSADC_LS_OVERRUN. To get the data value for the sample,
+ * use the HSADC_LS_DATA(sample) macro. The threshold range and crossing results
+ * can be determined by using the HSADC_LS_RANGE(sample) and
+ * HSADC_LS_CROSSING(sample) macros and comparing the result against the
+ * HSADC_LS_RANGE_* or HSADC_LS_CROSSING_* definitions.<br>
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetLastSample(LPC_HSADC_T *pHSADC, uint8_t channel)
+{
+   return pHSADC->LAST_SAMPLE[channel];
+}
+
+/**
+ * @brief  Setup speed for a input channel
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  channel : Input to set, 0-5
+ * @param  speed   : Speed value to set (0xF, 0xE, or 0x0), see user manual
+ * @return Nothing
+ * @note   It is recommended not to use this function, as the values needed
+ * for this register will be setup with the Chip_HSADC_SetPowerSpeed() function.
+ */
+void Chip_HSADC_SetSpeed(LPC_HSADC_T *pHSADC, uint8_t channel, uint8_t speed);
+
+/**
+ * @brief  Setup (common) HSADC power and speed settings
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  comp2   : True sets up for 2's complement, false sets up for offset binary data format
+ * @return Nothing
+ * @note   This function sets up the HSADC current/power/speed settings that
+ * apply to all HSADC channels (inputs). Based on the HSADC clock rate, it will
+ * automatically setup the best current setting (CRS) and speed settings (DGEC)
+ * for all channels. (See user manual).<br>
+ * This function is also used to set the data format of the sampled data. It is
+ * recommended to call this function if the HSADC sample rate changes.
+ */
+void Chip_HSADC_SetPowerSpeed(LPC_HSADC_T *pHSADC, bool comp2);
+
+/* AC-DC coupling selection for vin_neg and vin_pos sides */
+typedef enum {
+   HSADC_CHANNEL_NODCBIAS = 0,     /*!< No DC bias */
+   HSADC_CHANNEL_DCBIAS = 1,       /*!< DC bias on vin_neg side */
+} HSADC_DCBIAS_T;
+
+/**
+ * @brief  Setup AC-DC coupling selection for a channel
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  channel : Input to set, 0-5
+ * @param  dcInNeg : AC-DC coupling selection on vin_neg side
+ * @param  dcInPos : AC-DC coupling selection on vin_pos side
+ * @return Nothing
+ * @note   This function sets up the HSADC current/power/speed settings that
+ * apply to all HSADC channels (inputs). Based on the HSADC clock rate, it will
+ * automatically setup the best current setting (CRS) and speed settings (DGEC)
+ * for all channels. (See user manual).<br>
+ * This function is also used to set the data format of the sampled data. It is
+ * recommended to call this function if the HSADC sample rate changes.
+ */
+void Chip_HSADC_SetACDCBias(LPC_HSADC_T *pHSADC, uint8_t channel,
+                           HSADC_DCBIAS_T dcInNeg, HSADC_DCBIAS_T dcInPos);
+
+/**
+ * @brief  Enable HSADC power control and band gap reference
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @return Nothing
+ * @note   This function enables both the HSADC power and band gap
+ * reference.
+ */
+STATIC INLINE void Chip_HSADC_EnablePower(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->POWER_CONTROL |= (1 << 17) | (1 << 18);
+}
+
+/**
+ * @brief  Disable HSADC power control and band gap reference
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @return Nothing
+ * @note   This function disables both the HSADC power and band gap
+ * reference.
+ */
+STATIC INLINE void Chip_HSADC_DisablePower(LPC_HSADC_T *pHSADC)
+{
+   pHSADC->POWER_CONTROL &= ~((1 << 17) | (1 << 18));
+}
+
+/** HSADC FIFO registers bit fields for unpacked sample in lower 16 bits */
+#define HSADC_FIFO_SAMPLE_MASK      (0xFFF)                    /*!< 12-bit sample mask (unpacked) */
+#define HSADC_FIFO_SAMPLE(val)      ((val) & 0xFFF)            /*!< Macro for stripping out unpacked sample data */
+#define HSADC_FIFO_CHAN_ID_MASK     (0x7000)               /*!< Channel ID mask */
+#define HSADC_FIFO_CHAN_ID(val)     (((val) >> 12) & 0x7)  /*!< Macro for stripping out sample data */
+#define HSADC_FIFO_EMPTY            (0x1 << 15)                /*!< FIFO empty (invalid sample) */
+#define HSADC_FIFO_SHIFTPACKED(val) ((val) >> 16)          /*!< Shifts the packed FIFO sample into the lower 16-bits of a word */
+#define HSADC_FIFO_PACKEDMASK       (1UL << 31)                /*!< Packed sample check mask */
+
+/**
+ * @brief  Reads the HSADC FIFO
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @return HSADC FIFO value
+ * @note   This function reads and pops the HSADC FIFO. The FIFO
+ * contents can be determined by using the HSADC_FIFO_* macros. If
+ * FIFO packing is enabled, this may contain 2 samples. Use the
+ * HSADC_FIFO_SHIFTPACKED macro to shift packed sample data into a
+ * variable that can be used with the HSADC_FIFO_* macros. Note that
+ * even if packing is enabled, the packed sample may not be valid.
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetFIFO(LPC_HSADC_T *pHSADC)
+{
+   return pHSADC->FIFO_OUTPUT[0];
+}
+
+/** HSADC descriptor registers bit fields and support macros */
+#define HSADC_DESC_CH(ch)           (ch)               /*!< Converter input channel */
+#define HSADC_DESC_HALT             (1 << 3)           /*!< Descriptor halt after conversion bit */
+#define HSADC_DESC_INT              (1 << 4)           /*!< Raise interrupt when ADC result is available bit */
+#define HSADC_DESC_POWERDOWN        (1 << 5)           /*!< Power down after this conversion bit */
+#define HSADC_DESC_BRANCH_NEXT      (0 << 6)           /*!< Continue with next descriptor */
+#define HSADC_DESC_BRANCH_FIRST     (1 << 6)           /*!< Branch to the first descriptor */
+#define HSADC_DESC_BRANCH_SWAP      (2 << 6)           /*!< Swap tables and branch to the first descriptor of the new table */
+#define HSADC_DESC_MATCH(val)       ((val) << 8)       /*!< Match value used to trigger a descriptor */
+#define HSADC_DESC_THRESH_NONE      (0 << 22)          /*!< No threshold detection performed */
+#define HSADC_DESC_THRESH_A         (1 << 22)          /*!< Use A threshold detection */
+#define HSADC_DESC_THRESH_B         (2 << 22)          /*!< Use B threshold detection */
+#define HSADC_DESC_RESET_TIMER      (1 << 24)          /*!< Reset descriptor timer */
+#define HSADC_DESC_UPDATE_TABLE     (1UL << 31)            /*!< Update table with all 8 descriptors of this table */
+
+/**
+ * @brief  Sets up a raw HSADC descriptor entry
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  table   : Descriptor table number, 0 or 1
+ * @param  descNo  : Descriptor number to setup, 0 to 7
+ * @param  desc    : Raw descriptor value (see notes)
+ * @return Nothing
+ * @note   This function sets up a descriptor table entry. To setup
+ * a descriptor entry, select a OR'ed combination of the HSADC_DESC_CH,
+ * HSADC_DESC_HALT, HSADC_DESC_INT, HSADC_DESC_POWERDOWN, one of
+ * HSADC_DESC_BRANCH_*, HSADC_DESC_MATCH, one of HSADC_DESC_THRESH_*, and
+ * HSADC_DESC_RESET_TIMER definitions.<br>
+ * Example for setting up a table 0, descriptor number 4 entry for input 0:<br>
+ * Chip_HSADC_SetupDescEntry(LPC_HSADC, 0, 4, (HSADC_DESC_CH(0) | HSADC_DESC_HALT |
+ *    HSADC_DESC_INT));
+ */
+STATIC INLINE void Chip_HSADC_SetupDescEntry(LPC_HSADC_T *pHSADC, uint8_t table,
+                                            uint8_t descNo, uint32_t desc)
+{
+   pHSADC->DESCRIPTOR[table][descNo] = desc;
+}
+
+/**
+ * @brief  Update all descriptors of a table
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  table   : Descriptor table number, 0 or 1
+ * @return Nothing
+ * @note   Updates descriptor table with all 8 descriptors. This
+ * function should be used after all descriptors are setup with
+ * the Chip_HSADC_SetupDescEntry() function.
+ */
+STATIC INLINE void Chip_HSADC_UpdateDescTable(LPC_HSADC_T *pHSADC, uint8_t table)
+{
+   pHSADC->DESCRIPTOR[table][0] |= HSADC_DESC_UPDATE_TABLE;
+}
+
+/* Interrupt selection for interrupt 0 set - these interrupts and statuses
+   should only be used with the interrupt 0 register set */
+#define HSADC_INT0_FIFO_FULL         (1 << 0)      /*!< number of samples in FIFO is more than FIFO_LEVEL */
+#define HSADC_INT0_FIFO_EMPTY        (1 << 1)      /*!< FIFO is empty */
+#define HSADC_INT0_FIFO_OVERFLOW     (1 << 2)      /*!< FIFO was full; conversion sample is not stored and lost */
+#define HSADC_INT0_DSCR_DONE         (1 << 3)      /*!< The descriptor INTERRUPT field was enabled and its sample is converted */
+#define HSADC_INT0_DSCR_ERROR        (1 << 4)      /*!< The ADC was not fully woken up when a sample was converted and the conversion results is unreliable */
+#define HSADC_INT0_ADC_OVF           (1 << 5)      /*!< Converted sample value was over range of the 12 bit output code */
+#define HSADC_INT0_ADC_UNF           (1 << 6)      /*!< Converted sample value was under range of the 12 bit output code */
+
+/* Interrupt selection for interrupt 1 set - these interrupts and statuses
+   should only be used with the interrupt 1 register set */
+#define HSADC_INT1_THCMP_BRANGE(ch)  (1 << ((ch * 5) + 0)) /*!< Input channel result below range */
+#define HSADC_INT1_THCMP_ARANGE(ch)  (1 << ((ch * 5) + 1)) /*!< Input channel result above range */
+#define HSADC_INT1_THCMP_DCROSS(ch)  (1 << ((ch * 5) + 2)) /*!< Input channel result downward threshold crossing detected */
+#define HSADC_INT1_THCMP_UCROSS(ch)  (1 << ((ch * 5) + 3)) /*!< Input channel result upward threshold crossing detected */
+#define HSADC_INT1_OVERRUN(ch)       (1 << ((ch * 5) + 4)) /*!< New conversion on channel completed and has overwritten the previous contents of register LAST_SAMPLE [0] before it has been read */
+
+/**
+ * @brief  Enable an interrupt for HSADC interrupt group 0 or 1
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  intGrp  : Interrupt group 0 or 1
+ * @param  intMask : Interrupts to enable, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_EnableInts(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t intMask)
+{
+   pHSADC->INTS[intGrp].SET_EN = intMask;
+}
+
+/**
+ * @brief  Disables an interrupt for HSADC interrupt group 0 or 1
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  intGrp  : Interrupt group 0 or 1
+ * @param  intMask : Interrupts to disable, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_DisableInts(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t intMask)
+{
+   pHSADC->INTS[intGrp].CLR_EN = intMask;
+}
+
+/**
+ * @brief  Returns enabled interrupt for HSADC interrupt group 0 or 1
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  intGrp  : Interrupt group 0 or 1
+ * @return enabled interrupts for the selected group
+ * @note   Mask the return value with a HSADC_INT0_* macro for group 0
+ * or HSADC_INT1_* values for group 1 to determine which interrupts are enabled.
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetEnabledInts(LPC_HSADC_T *pHSADC, uint8_t intGrp)
+{
+   return pHSADC->INTS[intGrp].MASK;
+}
+
+/**
+ * @brief  Returns status for HSADC interrupt group 0 or 1
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  intGrp  : Interrupt group 0 or 1
+ * @return interrupt (pending) status for the selected group
+ * @note   Mask the return value with a HSADC_INT0_* macro for group 0
+ * or HSADC_INT1_* values for group 1 to determine which statuses are active.
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetIntStatus(LPC_HSADC_T *pHSADC, uint8_t intGrp)
+{
+   return pHSADC->INTS[intGrp].STATUS;
+}
+
+/**
+ * @brief  Clear a status for HSADC interrupt group 0 or 1
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  intGrp  : Interrupt group 0 or 1
+ * @param  stsMask : Statuses to clear, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_ClearIntStatus(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t stsMask)
+{
+   pHSADC->INTS[intGrp].CLR_STAT = stsMask;
+}
+
+/**
+ * @brief  Sets a status for HSADC interrupt group 0 or 1
+ * @param  pHSADC  : The base of ADC peripheral on the chip
+ * @param  intGrp  : Interrupt group 0 or 1
+ * @param  stsMask : Statuses to set, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return Nothing
+ */
+STATIC INLINE void Chip_HSADC_SetIntStatus(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t stsMask)
+{
+   pHSADC->INTS[intGrp].SET_STAT = stsMask;
+}
+
+/**
+ * @brief  Returns the clock rate in Hz for the HSADC
+ * @param  pHSADC  : The base of HSADC peripheral on the chip
+ * @return clock rate in Hz for the HSADC
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetBaseClockRate(LPC_HSADC_T *pHSADC)
+{
+   (void) pHSADC;
+
+   /* Return computed sample rate for the high speed ADC peripheral */
+   return Chip_Clock_GetRate(CLK_ADCHS);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HSADC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/i2c_18xx_43xx.h ./lpc_chip_43xx/inc/i2c_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/i2c_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/i2c_18xx_43xx.h	2018-01-19 23:55:10.968318450 -0300
@@ -0,0 +1,400 @@
+/*
+ * @brief LPC18xx/43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2C_18XX_43XX_H_
+#define __I2C_18XX_43XX_H_
+#include "i2c_common_18xx_43xx.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup I2C_18XX_43XX
+ * @{
+ */
+
+/**
+ * @brief  Return values for SLAVE handler
+ * @note
+ * Chip drivers will usally be designed to match their events with this value
+ */
+#define RET_SLAVE_TX    6  /**< Return value, when 1 byte TX'd successfully */
+#define RET_SLAVE_RX    5  /**< Return value, when 1 byte RX'd successfully */
+#define RET_SLAVE_IDLE  2  /**< Return value, when slave enter idle mode */
+#define RET_SLAVE_BUSY  0  /**< Return value, when slave is busy */
+
+/**
+ * @brief I2C state handle return values
+ */
+#define I2C_STA_STO_RECV            0x20
+
+/*
+ * @brief I2C return status code definitions
+ */
+#define I2C_I2STAT_NO_INF                       ((0xF8))/*!< No relevant information */
+#define I2C_I2STAT_BUS_ERROR                    ((0x00))/*!< Bus Error */
+
+/*
+ * @brief I2C status values
+ */
+#define I2C_SETUP_STATUS_ARBF   (1 << 8)   /**< Arbitration false */
+#define I2C_SETUP_STATUS_NOACKF (1 << 9)   /**< No ACK returned */
+#define I2C_SETUP_STATUS_DONE   (1 << 10)  /**< Status DONE */
+
+/*
+ * @brief I2C state handle return values
+ */
+#define I2C_OK                      0x00
+#define I2C_BYTE_SENT               0x01
+#define I2C_BYTE_RECV               0x02
+#define I2C_LAST_BYTE_RECV          0x04
+#define I2C_SEND_END                0x08
+#define I2C_RECV_END                0x10
+#define I2C_STA_STO_RECV            0x20
+
+#define I2C_ERR                     (0x10000000)
+#define I2C_NAK_RECV                (0x10000000 | 0x01)
+
+#define I2C_CheckError(ErrorCode)   (ErrorCode & 0x10000000)
+
+/*
+ * @brief I2C monitor control configuration defines
+ */
+#define I2C_MONITOR_CFG_SCL_OUTPUT  I2C_I2MMCTRL_ENA_SCL       /**< SCL output enable */
+#define I2C_MONITOR_CFG_MATCHALL    I2C_I2MMCTRL_MATCH_ALL     /**< Select interrupt register match */
+
+/**
+ * @brief  I2C Slave Identifiers
+ */
+typedef enum {
+   I2C_SLAVE_GENERAL,  /**< Slave ID for general calls */
+   I2C_SLAVE_0,        /**< Slave ID fo Slave Address 0 */
+   I2C_SLAVE_1,        /**< Slave ID fo Slave Address 1 */
+   I2C_SLAVE_2,        /**< Slave ID fo Slave Address 2 */
+   I2C_SLAVE_3,        /**< Slave ID fo Slave Address 3 */
+   I2C_SLAVE_NUM_INTERFACE /**< Number of slave interfaces */
+} I2C_SLAVE_ID;
+
+/**
+ * @brief  I2C transfer status
+ */
+typedef enum {
+   I2C_STATUS_DONE,    /**< Transfer done successfully */
+   I2C_STATUS_NAK,     /**< NAK received during transfer */
+   I2C_STATUS_ARBLOST, /**< Aribitration lost during transfer */
+   I2C_STATUS_BUSERR,  /**< Bus error in I2C transfer */
+   I2C_STATUS_BUSY,    /**< I2C is busy doing transfer */
+   I2C_STATUS_SLAVENAK,/**< NAK received after SLA+W or SLA+R */
+} I2C_STATUS_T;
+
+/**
+ * @brief Master transfer data structure definitions
+ */
+typedef struct {
+   uint8_t slaveAddr;      /**< 7-bit I2C Slave address */
+   const uint8_t *txBuff;  /**< Pointer to array of bytes to be transmitted */
+   int     txSz;           /**< Number of bytes in transmit array,
+                              if 0 only receive transfer will be carried on */
+   uint8_t *rxBuff;        /**< Pointer memory where bytes received from I2C be stored */
+   int     rxSz;           /**< Number of bytes to received,
+                              if 0 only transmission we be carried on */
+   I2C_STATUS_T status;    /**< Status of the current I2C transfer */
+} I2C_XFER_T;
+
+/**
+ * @brief  I2C interface IDs
+ * @note
+ * All Chip functions will take this as the first parameter,
+ * I2C_NUM_INTERFACE must never be used for calling any Chip
+ * functions, it is only used to find the number of interfaces
+ * available in the Chip.
+ */
+typedef enum I2C_ID {
+   I2C0,               /**< ID I2C0 */
+   I2C1,               /**< ID I2C1 */
+   I2C_NUM_INTERFACE   /**< Number of I2C interfaces in the chip */
+} I2C_ID_T;
+
+/**
+ * @brief  I2C master events
+ */
+typedef enum {
+   I2C_EVENT_WAIT = 1, /**< I2C Wait event */
+   I2C_EVENT_DONE,     /**< Done event that wakes up Wait event */
+   I2C_EVENT_LOCK,     /**< Re-entrency lock event for I2C transfer */
+   I2C_EVENT_UNLOCK,   /**< Re-entrency unlock event for I2C transfer */
+   I2C_EVENT_SLAVE_RX, /**< Slave receive event */
+   I2C_EVENT_SLAVE_TX, /**< Slave transmit event */
+} I2C_EVENT_T;
+
+/**
+ * @brief  Event handler function type
+ */
+typedef void (*I2C_EVENTHANDLER_T)(I2C_ID_T, I2C_EVENT_T);
+
+/**
+ * @brief  Initializes the LPC_I2C peripheral with specified parameter.
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return Nothing
+ */
+void Chip_I2C_Init(I2C_ID_T id);
+
+/**
+ * @brief  De-initializes the I2C peripheral registers to their default reset values
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return Nothing
+ */
+void Chip_I2C_DeInit(I2C_ID_T id);
+
+/**
+ * @brief  Set up clock rate for LPC_I2C peripheral.
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  clockrate   : Target clock rate value to initialized I2C peripheral (Hz)
+ * @return Nothing
+ * @note
+ * Parameter @a clockrate for I2C0 should be from 1000 up to 1000000
+ * (1 KHz to 1 MHz), as I2C0 support Fast Mode Plus. If the @a clockrate
+ * is more than 400 KHz (Fast Plus Mode) Board_I2C_EnableFastPlus()
+ * must be called prior to calling this function.
+ */
+void Chip_I2C_SetClockRate(I2C_ID_T id, uint32_t clockrate);
+
+/**
+ * @brief  Get current clock rate for LPC_I2C peripheral.
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return The current I2C peripheral clock rate
+ */
+uint32_t Chip_I2C_GetClockRate(I2C_ID_T id);
+
+/**
+ * @brief  Transmit and Receive data in master mode
+ * @param  id      : I2C peripheral selected (I2C0, I2C1 etc)
+ * @param  xfer    : Pointer to a I2C_XFER_T structure see notes below
+ * @return
+ * Any of #I2C_STATUS_T values, xfer->txSz will have number of bytes
+ * not sent due to error, xfer->rxSz will have the number of bytes yet
+ * to be received.
+ * @note
+ * The parameter @a xfer should have its member @a slaveAddr initialized
+ * to the 7-Bit slave address to which the master will do the xfer, Bit0
+ * to bit6 should have the address and Bit8 is ignored. During the transfer
+ * no code (like event handler) must change the content of the memory
+ * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
+ * initialized to the memory from which the I2C must pick the data to be
+ * transfered to slave and the number of bytes to send respectively, similarly
+ * @a rxBuff and @a rxSz must have pointer to memroy where data received
+ * from slave be stored and the number of data to get from slave respectilvely.
+ */
+int Chip_I2C_MasterTransfer(I2C_ID_T id, I2C_XFER_T *xfer);
+
+/**
+ * @brief  Transmit data to I2C slave using I2C Master mode
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 .. etc)
+ * @param  slaveAddr   : Slave address to which the data be written
+ * @param  buff        : Pointer to buffer having the array of data
+ * @param  len         : Number of bytes to be transfered from @a buff
+ * @return Number of bytes successfully transfered
+ */
+int Chip_I2C_MasterSend(I2C_ID_T id, uint8_t slaveAddr, const uint8_t *buff, uint8_t len);
+
+/**
+ * @brief  Transfer a command to slave and receive data from slave after a repeated start
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  slaveAddr   : Slave address of the I2C device
+ * @param  cmd         : Command (Address/Register) to be written
+ * @param  buff        : Pointer to memory that will hold the data received
+ * @param  len         : Number of bytes to receive
+ * @return Number of bytes successfully received
+ */
+int Chip_I2C_MasterCmdRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t cmd, uint8_t *buff, int len);
+
+/**
+ * @brief  Get pointer to current function handling the events
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return Pointer to function handing events of I2C
+ */
+I2C_EVENTHANDLER_T Chip_I2C_GetMasterEventHandler(I2C_ID_T id);
+
+/**
+ * @brief  Set function that must handle I2C events
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  event       : Pointer to function that will handle the event (Should not be NULL)
+ * @return 1 when successful, 0 when a transfer is on going with its own event handler
+ */
+int Chip_I2C_SetMasterEventHandler(I2C_ID_T id, I2C_EVENTHANDLER_T event);
+
+/**
+ * @brief  Set function that must handle I2C events
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  slaveAddr   : Slave address from which data be read
+ * @param  buff        : Pointer to memory where data read be stored
+ * @param  len         : Number of bytes to read from slave
+ * @return Number of bytes read successfully
+ */
+int Chip_I2C_MasterRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t *buff, int len);
+
+/**
+ * @brief  Default event handler for polling operation
+ * @param  id      : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  event   : Event ID of the event that called the function
+ * @return Nothing
+ */
+void Chip_I2C_EventHandlerPolling(I2C_ID_T id, I2C_EVENT_T event);
+
+/**
+ * @brief  Default event handler for interrupt base operation
+ * @param  id      : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  event   : Event ID of the event that called the function
+ * @return Nothing
+ */
+void Chip_I2C_EventHandler(I2C_ID_T id, I2C_EVENT_T event);
+
+/**
+ * @brief  I2C Master transfer state change handler
+ * @param  id      : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return Nothing
+ * @note   Usually called from the appropriate Interrupt handler
+ */
+void Chip_I2C_MasterStateHandler(I2C_ID_T id);
+
+/**
+ * @brief  Disable I2C peripheral's operation
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return Nothing
+ */
+void Chip_I2C_Disable(I2C_ID_T id);
+
+/**
+ * @brief  Checks if master xfer in progress
+ * @param  id      : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return 1 if master xfer in progress 0 otherwise
+ * @note
+ * This API is generally used in interrupt handler
+ * of the application to decide whether to call
+ * master state handler or to call slave state handler
+ */
+int Chip_I2C_IsMasterActive(I2C_ID_T id);
+
+/**
+ * @brief  Setup a slave I2C device
+ * @param  id          : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param  sid         : I2C Slave peripheral ID (I2C_SLAVE_0, I2C_SLAVE_1 etc)
+ * @param  xfer        : Pointer to transfer structure (see note below for more info)
+ * @param  event       : Event handler for slave transfers
+ * @param  addrMask    : Address mask to use along with slave address (see notes below for more info)
+ * @return Nothing
+ * @note
+ * Parameter @a xfer should point to a valid I2C_XFER_T structure object
+ * and must have @a slaveAddr initialized with 7bit Slave address (From Bit1 to Bit7),
+ * Bit0 when set enables general call handling, @a slaveAddr along with @a addrMask will
+ * be used to match the slave address. @a rxBuff and @a txBuff must point to valid buffers
+ * where slave can receive or send the data from, size of which will be provided by
+ * @a rxSz and @a txSz respectively. Function pointed to by @a event will be called
+ * for the following events #I2C_EVENT_SLAVE_RX (One byte of data received successfully
+ * from the master and stored inside memory pointed by xfer->rxBuff, incremented
+ * the pointer and decremented the @a xfer->rxSz), #I2C_EVENT_SLAVE_TX (One byte of
+ * data from xfer->txBuff was sent to master successfully, incremented the pointer
+ * and decremented xfer->txSz), #I2C_EVENT_DONE (Master is done doing its transfers
+ * with the slave).<br>
+ * <br>Bit-0 of the parameter @a addrMask is reserved and should always be 0. Any bit (BIT1
+ * to BIT7) set in @a addrMask will make the corresponding bit in *xfer->slaveAddr* as
+ * don't care. Thit is, if *xfer->slaveAddr* is (0x10 << 1) and @a addrMask is (0x03 << 1) then
+ * 0x10, 0x11, 0x12, 0x13 will all be considered as valid slave addresses for the registered
+ * slave. Upon receving any event *xfer->slaveAddr* (BIT1 to BIT7) will hold the actual
+ * address which was received from master.<br>
+ * <br><b>General Call Handling</b><br>
+ * Slave can receive data from master using general call address (0x00). General call
+ * handling must be setup as given below
+ *      - Call Chip_I2C_SlaveSetup() with argument @a sid as I2C_SLAVE_GENERAL
+ *          - xfer->slaveAddr ignored, argument @a addrMask ignored
+ *          - function provided by @a event will registered to be called when slave received data using addr 0x00
+ *          - xfer->rxBuff and xfer->rxSz should be valid in argument @a xfer
+ *      - To handle General Call only (No other slaves are configured)
+ *          - Call Chip_I2C_SlaveSetup() with sid as I2C_SLAVE_X (X=0,1,2,3)
+ *          - setup @a xfer with slaveAddr member set to 0, @a event is ignored hence can be NULL
+ *          - provide @a addrMask (typically 0, if not you better be knowing what you are doing)
+ *      - To handler General Call when other slave is active
+ *          - Call Chip_I2C_SlaveSetup() with sid as I2C_SLAVE_X (X=0,1,2,3)
+ *          - setup @a xfer with slaveAddr member set to 7-Bit Slave address [from Bit1 to 7]
+ *          - Set Bit0 of @a xfer->slaveAddr as 1
+ *          - Provide appropriate @a addrMask
+ *          - Argument @a event must point to function, that handles events from actual slaveAddress and not the GC
+ * @warning
+ * If the slave has only one byte in its txBuff, once that byte is transfered to master the event handler
+ * will be called for event #I2C_EVENT_DONE. If the master attempts to read more bytes in the same transfer
+ * then the slave hardware will send 0xFF to master till the end of transfer, event handler will not be
+ * called to notify this. For more info see section below<br>
+ * <br><b> Last data handling in slave </b><br>
+ * If the user wants to implement a slave which will read a byte from a specific location over and over
+ * again whenever master reads the slave. If the user initializes the xfer->txBuff as the location to read
+ * the byte from and xfer->txSz as 1, then say, if master reads one byte; slave will send the byte read from
+ * xfer->txBuff and will call the event handler with #I2C_EVENT_DONE. If the master attempts to read another
+ * byte instead of sending the byte read from xfer->txBuff the slave hardware will send 0xFF and no event will
+ * occur. To handle this issue, slave should set xfer->txSz to 2, in which case when master reads the byte
+ * event handler will be called with #I2C_EVENT_SLAVE_TX, in which the slave implementation can reset the buffer
+ * and size back to original location (i.e, xfer->txBuff--, xfer->txSz++), if the master reads another byte
+ * in the same transfer, byte read from xfer->txBuff will be sent and #I2C_EVENT_SLAVE_TX will be called again, and
+ * the process repeats.
+ */
+void Chip_I2C_SlaveSetup(I2C_ID_T id,
+                        I2C_SLAVE_ID sid,
+                        I2C_XFER_T *xfer,
+                        I2C_EVENTHANDLER_T event,
+                        uint8_t addrMask);
+
+/**
+ * @brief  I2C Slave event handler
+ * @param  id      : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return Nothing
+ */
+void Chip_I2C_SlaveStateHandler(I2C_ID_T id);
+
+/**
+ * @brief  I2C peripheral state change checking
+ * @param  id      : I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return 1 if I2C peripheral @a id has changed its state,
+ *          0 if there is no state change
+ * @note
+ * This function must be used by the application when
+ * the polling has to be done based on state change.
+ */
+int Chip_I2C_IsStateChanged(I2C_ID_T id);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/i2c_common_18xx_43xx.h ./lpc_chip_43xx/inc/i2c_common_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/i2c_common_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/i2c_common_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,200 @@
+/*
+ * @brief LPC18xx_43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2C_COMMON_18XX_43XX_H_
+#define __I2C_COMMON_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2C_18XX_43XX CHIP: LPC18xx_43xx I2C driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief I2C register block structure
+ */
+typedef struct {               /* I2C0 Structure         */
+   __IO uint32_t CONSET;       /*!< I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register. */
+   __I  uint32_t STAT;         /*!< I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed. */
+   __IO uint32_t DAT;          /*!< I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register. */
+   __IO uint32_t ADR0;         /*!< I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+   __IO uint32_t SCLH;         /*!< SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock. */
+   __IO uint32_t SCLL;         /*!< SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode. */
+   __O  uint32_t CONCLR;       /*!< I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register. */
+   __IO uint32_t MMCTRL;       /*!< Monitor mode control register. */
+   __IO uint32_t ADR1;         /*!< I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+   __IO uint32_t ADR2;         /*!< I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+   __IO uint32_t ADR3;         /*!< I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+   __I  uint32_t DATA_BUFFER;  /*!< Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus. */
+   __IO uint32_t MASK[4];      /*!< I2C Slave address mask register */
+} LPC_I2C_T;
+
+/*
+ * @brief I2C Control Set register description
+ */
+#define I2C_I2CONSET_AA             ((0x04))/*!< Assert acknowledge flag */
+#define I2C_I2CONSET_SI             ((0x08))/*!< I2C interrupt flag */
+#define I2C_I2CONSET_STO            ((0x10))/*!< STOP flag */
+#define I2C_I2CONSET_STA            ((0x20))/*!< START flag */
+#define I2C_I2CONSET_I2EN           ((0x40))/*!< I2C interface enable */
+
+/*
+ * @brief I2C Control Clear register description
+ */
+#define I2C_I2CONCLR_AAC            ((1 << 2)) /*!< Assert acknowledge Clear bit */
+#define I2C_I2CONCLR_SIC            ((1 << 3)) /*!< I2C interrupt Clear bit */
+#define I2C_I2CONCLR_STOC           ((1 << 4)) /*!< I2C STOP Clear bit */
+#define I2C_I2CONCLR_STAC           ((1 << 5)) /*!< START flag Clear bit */
+#define I2C_I2CONCLR_I2ENC          ((1 << 6)) /*!< I2C interface Disable bit */
+
+/*
+ * @brief  I2C Common Control register description
+ */
+#define I2C_CON_AA            (1UL << 2)   /*!< Assert acknowledge bit */
+#define I2C_CON_SI            (1UL << 3)   /*!< I2C interrupt bit */
+#define I2C_CON_STO           (1UL << 4)   /*!< I2C STOP bit */
+#define I2C_CON_STA           (1UL << 5)   /*!< START flag bit */
+#define I2C_CON_I2EN          (1UL << 6)   /*!< I2C interface bit */
+
+/*
+ * @brief I2C Status Code definition (I2C Status register)
+ */
+#define I2C_STAT_CODE_BITMASK       ((0xF8))/*!< Return Code mask in I2C status register */
+#define I2C_STAT_CODE_ERROR         ((0xFF))/*!< Return Code error mask in I2C status register */
+
+/*
+ * @brief I2C Master transmit mode
+ */
+#define I2C_I2STAT_M_TX_START                   ((0x08))/*!< A start condition has been transmitted */
+#define I2C_I2STAT_M_TX_RESTART                 ((0x10))/*!< A repeat start condition has been transmitted */
+#define I2C_I2STAT_M_TX_SLAW_ACK                ((0x18))/*!< SLA+W has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_TX_SLAW_NACK               ((0x20))/*!< SLA+W has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_TX_DAT_ACK                 ((0x28))/*!< Data has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_TX_DAT_NACK                ((0x30))/*!< Data has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_TX_ARB_LOST                ((0x38))/*!< Arbitration lost in SLA+R/W or Data bytes */
+
+/*
+ * @brief I2C Master receive mode
+ */
+#define I2C_I2STAT_M_RX_START                   ((0x08))/*!< A start condition has been transmitted */
+#define I2C_I2STAT_M_RX_RESTART                 ((0x10))/*!< A repeat start condition has been transmitted */
+#define I2C_I2STAT_M_RX_ARB_LOST                ((0x38))/*!< Arbitration lost */
+#define I2C_I2STAT_M_RX_SLAR_ACK                ((0x40))/*!< SLA+R has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_RX_SLAR_NACK               ((0x48))/*!< SLA+R has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_RX_DAT_ACK                 ((0x50))/*!< Data has been received, ACK has been returned */
+#define I2C_I2STAT_M_RX_DAT_NACK                ((0x58))/*!< Data has been received, NACK has been returned */
+
+/*
+ * @brief I2C Slave receive mode
+ */
+#define I2C_I2STAT_S_RX_SLAW_ACK                ((0x60))/*!< Own slave address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_ARB_LOST_M_SLA          ((0x68))/*!< Arbitration lost in SLA+R/W as master */
+// #define I2C_I2STAT_S_RX_SLAW_ACK                ((0x68)) /*!< Own SLA+W has been received, ACK returned */
+#define I2C_I2STAT_S_RX_GENCALL_ACK             ((0x70))/*!< General call address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL      ((0x78))/*!< Arbitration lost in SLA+R/W (GENERAL CALL) as master */
+// #define I2C_I2STAT_S_RX_GENCALL_ACK             ((0x78)) /*!< General call address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK         ((0x80))/*!< Previously addressed with own SLA; Data has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK        ((0x88))/*!< Previously addressed with own SLA;Data has been received and NOT ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK     ((0x90))/*!< Previously addressed with General Call; Data has been received and ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK    ((0x98))/*!< Previously addressed with General Call; Data has been received and NOT ACK has been returned */
+#define I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX   ((0xA0))/*!< A STOP condition or repeated START condition has been received while still addressed as SLV/REC (Slave Receive) or
+                                                          SLV/TRX (Slave Transmit) */
+
+/*
+ * @brief I2C Slave transmit mode
+ */
+#define I2C_I2STAT_S_TX_SLAR_ACK                ((0xA8))/*!< Own SLA+R has been received, ACK has been returned */
+#define I2C_I2STAT_S_TX_ARB_LOST_M_SLA          ((0xB0))/*!< Arbitration lost in SLA+R/W as master */
+// #define I2C_I2STAT_S_TX_SLAR_ACK                ((0xB0)) /*!< Own SLA+R has been received, ACK has been returned */
+#define I2C_I2STAT_S_TX_DAT_ACK                 ((0xB8))/*!< Data has been transmitted, ACK has been received */
+#define I2C_I2STAT_S_TX_DAT_NACK                ((0xC0))/*!< Data has been transmitted, NACK has been received */
+#define I2C_I2STAT_S_TX_LAST_DAT_ACK            ((0xC8))/*!< Last data byte in I2DAT has been transmitted (AA = 0); ACK has been received */
+#define I2C_SLAVE_TIME_OUT                      0x10000000UL/*!< Time out in case of using I2C slave mode */
+
+/*
+ * @brief I2C Data register definition
+ */
+#define I2C_I2DAT_BITMASK           ((0xFF))/*!< Mask for I2DAT register */
+#define I2C_I2DAT_IDLE_CHAR         (0xFF) /*!< Idle data value will be send out in slave mode in case of the actual expecting data requested from the master is greater than
+                                                its sending data length that can be supported */
+
+/*
+ * @brief I2C Monitor mode control register description
+ */
+#define I2C_I2MMCTRL_MM_ENA         ((1 << 0))         /**< Monitor mode enable */
+#define I2C_I2MMCTRL_ENA_SCL        ((1 << 1))         /**< SCL output enable */
+#define I2C_I2MMCTRL_MATCH_ALL      ((1 << 2))         /**< Select interrupt register match */
+#define I2C_I2MMCTRL_BITMASK        ((0x07))       /**< Mask for I2MMCTRL register */
+
+/*
+ * @brief I2C Data buffer register description
+ */
+#define I2DATA_BUFFER_BITMASK       ((0xFF))/*!< I2C Data buffer register bit mask */
+
+/*
+ * @brief I2C Slave Address registers definition
+ */
+#define I2C_I2ADR_GC                ((1 << 0)) /*!< General Call enable bit */
+#define I2C_I2ADR_BITMASK           ((0xFF))/*!< I2C Slave Address registers bit mask */
+
+/*
+ * @brief I2C Mask Register definition
+ */
+#define I2C_I2MASK_MASK(n)          ((n & 0xFE))/*!< I2C Mask Register mask field */
+
+/*
+ * @brief I2C SCL HIGH duty cycle Register definition
+ */
+#define I2C_I2SCLH_BITMASK          ((0xFFFF)) /*!< I2C SCL HIGH duty cycle Register bit mask */
+
+/*
+ * @brief I2C SCL LOW duty cycle Register definition
+ */
+#define I2C_I2SCLL_BITMASK          ((0xFFFF)) /*!< I2C SCL LOW duty cycle Register bit mask */
+
+/*
+ * @brief I2C monitor control configuration defines
+ */
+#define I2C_MONITOR_CFG_SCL_OUTPUT  I2C_I2MMCTRL_ENA_SCL       /**< SCL output enable */
+#define I2C_MONITOR_CFG_MATCHALL    I2C_I2MMCTRL_MATCH_ALL     /**< Select interrupt register match */
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_COMMON_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/i2cm_18xx_43xx.h ./lpc_chip_43xx/inc/i2cm_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/i2cm_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/i2cm_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,419 @@
+/*
+ * @brief LPC18xx/43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2CM_18XX_43XX_H_
+#define __I2CM_18XX_43XX_H_
+
+#include "i2c_common_18xx_43xx.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2CM_18XX_43XX CHIP: LPC18xx/43xx I2C master-only driver
+ * @ingroup I2C_18XX_43XX
+ * This driver only works in master mode. To describe the I2C transactions
+ * following symbols are used in driver documentation.
+ *
+ * Key to symbols
+ * ==============
+ * S     (1 bit) : Start bit
+ * P     (1 bit) : Stop bit
+ * Rd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.
+ * A, NA (1 bit) : Acknowledge and Not-Acknowledge bit.
+ * Addr  (7 bits): I2C 7 bit address. Note that this can be expanded as usual to
+ *                 get a 10 bit I2C address.
+ * Data  (8 bits): A plain data byte. Sometimes, I write DataLow, DataHigh
+ *                 for 16 bit data.
+ * [..]: Data sent by I2C device, as opposed to data sent by the host adapter.
+ * @{
+ */
+
+/** I2CM_18XX_43XX_OPTIONS_TYPES I2C master transfer options
+ * @{
+ */
+
+/** Ignore NACK during data transfer. By default transfer is aborted. */
+#define I2CM_XFER_OPTION_IGNORE_NACK     0x01
+/** ACK last byte received. By default we NACK last byte we receive per I2C spec. */
+#define I2CM_XFER_OPTION_LAST_RX_ACK     0x02
+
+/**
+ * @}
+ */
+
+/** I2CM_18XX_43XX_STATUS_TYPES I2C master transfer status types
+ * @{
+ */
+
+#define I2CM_STATUS_OK              0x00       /*!< Requested Request was executed successfully. */
+#define I2CM_STATUS_ERROR           0x01       /*!< Unknown error condition. */
+#define I2CM_STATUS_NAK             0x02       /*!< No acknowledgement received from slave. */
+#define I2CM_STATUS_BUS_ERROR       0x03       /*!< I2C bus error */
+#define I2CM_STATUS_SLAVE_NAK       0x04       /*!< No device responded for given slave address during SLA+W or SLA+R */
+#define I2CM_STATUS_ARBLOST         0x05       /*!< Arbitration lost. */
+#define I2CM_STATUS_BUSY            0xFF       /*!< I2C transmitter is busy. */
+
+/**
+ * @}
+ */
+
+/**
+ * @brief Master transfer data structure definitions
+ */
+typedef struct {
+   uint8_t slaveAddr;      /*!< 7-bit I2C Slave address */
+   uint8_t options;        /*!< Options for transfer*/
+   uint16_t status;        /*!< Status of the current I2C transfer */
+   uint16_t txSz;          /*!< Number of bytes in transmit array,
+                              if 0 only receive transfer will be carried on */
+   uint16_t rxSz;          /*!< Number of bytes to received,
+                              if 0 only transmission we be carried on */
+   const uint8_t *txBuff;  /*!< Pointer to array of bytes to be transmitted */
+   uint8_t *rxBuff;        /*!< Pointer memory where bytes received from I2C be stored */
+} I2CM_XFER_T;
+
+/**
+ * @brief  Initialize I2C Interface
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function enables the I2C clock.
+ */
+void Chip_I2CM_Init(LPC_I2C_T *pI2C);
+
+/**
+ * @brief  Shutdown I2C Interface
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function disables the I2C clock.
+ */
+void Chip_I2CM_DeInit(LPC_I2C_T *pI2C);
+
+/**
+ * @brief  Sets HIGH and LOW duty cycle registers
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  sclH    : Number of I2C_PCLK cycles for the SCL HIGH time.
+ * @param  sclL    : Number of I2C_PCLK cycles for the SCL LOW time.
+ * @return Nothing
+ * @note   The frequency is determined by the following formula (I2C_PCLK
+ *          is the frequency of the peripheral I2C clock): <br>
+ *              I2C_bitFrequency = (I2C_PCLK)/(sclH + sclL);
+ */
+static INLINE void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL)
+{
+   pI2C->SCLH = (uint32_t) sclH;
+   pI2C->SCLL = (uint32_t) sclL;
+}
+
+/**
+ * @brief  Set up bus speed for LPC_I2C controller
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  busSpeed    : I2C bus clock rate
+ * @return Nothing
+ * @note   Per I2C specification the busSpeed should be
+ *          @li 100000 for Standard mode
+ *          @li 400000 for Fast mode
+ *          @li 1000000 for Fast mode plus
+ *          IOCON registers corresponding to I2C pads should be updated
+ *          according to the bus mode.
+ */
+void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed);
+
+/**
+ * @brief  Transmit START or Repeat-START signal on I2C bus
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function sets the controller to transmit START condition when
+ *          the bus becomes free.
+ */
+static INLINE void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
+{
+   pI2C->CONSET = I2C_CON_I2EN | I2C_CON_STA;
+}
+
+/**
+ * @brief  Reset I2C controller state
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function clears all control/status flags.
+ */
+static INLINE void Chip_I2CM_ResetControl(LPC_I2C_T *pI2C)
+{
+   /* Reset STA, AA and SI. Stop flag should not be cleared as it is a reserved bit */
+   pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA | I2C_CON_AA;
+
+}
+
+/**
+ * @brief  Transmit a single data byte through the I2C peripheral
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  data    : Byte to transmit
+ * @return Nothing
+ * @note   This function attempts to place a byte into the UART transmit
+ *         FIFO or transmit hold register regard regardless of UART state
+ *
+ */
+static INLINE void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
+{
+   pI2C->DAT = (uint32_t) data;
+}
+
+/**
+ * @brief  Read a single byte data from the I2C peripheral
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return A single byte of data read
+ * @note   This function reads a byte from the I2C receive hold register
+ *         regardless of I2C state. The I2C status should be read first prior
+ *         to using this function.
+ */
+static INLINE uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
+{
+   return (uint8_t) (pI2C->DAT & I2C_I2DAT_BITMASK);
+}
+
+/**
+ * @brief  Generate NACK after receiving next byte
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function sets the controller to NACK after receiving next
+ *          byte from slave transmitter. Used before receiving last byte.
+ */
+static INLINE void Chip_I2CM_NackNextByte(LPC_I2C_T *pI2C)
+{
+   pI2C->CONCLR = I2C_CON_AA;
+}
+
+/**
+ * @brief  Transmit STOP signal on I2C bus
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function sets the controller to transmit STOP condition.
+ */
+static INLINE void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
+{
+   pI2C->CONSET = I2C_CON_STO;
+}
+
+/**
+ * @brief  Force start I2C transmit
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function forces I2C state machine to start transmitting.
+ *         If an uncontrolled source generates a superfluous START or masks
+ *          a STOP condition, then the I2C-bus stays busy indefinitely. If
+ *          the STA flag is set and bus access is not obtained within a
+ *          reasonable amount of time, then a forced access to the I2C-bus is
+ *          possible. This is achieved by setting the STO flag while the STA
+ *          flag is still set. No STOP condition is transmitted.
+ */
+static INLINE void Chip_I2CM_ForceStart(LPC_I2C_T *pI2C)
+{
+   /* check if we are pending on start */
+   if (pI2C->CONSET & I2C_CON_STA) {
+       pI2C->CONSET = I2C_CON_STO;
+   }
+   else {
+       Chip_I2CM_SendStart(pI2C);
+   }
+}
+
+/**
+ * @brief  Transmit STOP+START signal on I2C bus
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note   This function sets the controller to transmit STOP condition
+ *          followed by a START condition.
+ */
+static INLINE void Chip_I2CM_SendStartAfterStop(LPC_I2C_T *pI2C)
+{
+   pI2C->CONSET = I2C_CON_STO | I2C_CON_STA;
+}
+
+/**
+ * @brief  Check if I2C controller state changed
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Returns 0 if state didn't change
+ * @note
+ */
+static INLINE uint32_t Chip_I2CM_StateChanged(LPC_I2C_T *pI2C)
+{
+   return pI2C->CONSET & I2C_CON_SI;
+}
+
+/**
+ * @brief  Clear state change interrupt flag
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note
+ */
+static INLINE void Chip_I2CM_ClearSI(LPC_I2C_T *pI2C)
+{
+   /* Stop flag should not be cleared as it is a reserved bit */
+   pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA;
+}
+
+/**
+ * @brief  Check if I2C bus is free per our controller
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Returns 0 if busy else a non-zero value.
+ * @note   I2C controller clears STO bit when it sees STOP
+ *          condition after a START condition on the bus.
+ */
+static INLINE uint32_t Chip_I2CM_BusFree(LPC_I2C_T *pI2C)
+{
+   return !(pI2C->CONSET & I2C_CON_STO);
+}
+
+/**
+ * @brief  Get current state of the I2C controller
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Returns 0 if busy else a non-zero value.
+ * @note   I2C controller clears STO bit when it sees STOP
+ *          condition after a START condition on the bus.
+ */
+static INLINE uint32_t Chip_I2CM_GetCurState(LPC_I2C_T *pI2C)
+{
+   return pI2C->STAT & I2C_STAT_CODE_BITMASK;
+}
+
+/**
+ * @brief  Disable I2C interface
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @return Nothing
+ * @note
+ */
+static INLINE void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
+{
+   pI2C->CONCLR = I2C_CON_I2EN;
+}
+
+/**
+ * @brief  Transfer state change handler handler
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  xfer    : Pointer to a I2CM_XFER_T structure see notes below
+ * @return Returns non-zero value on completion of transfer. The @a status
+ *         member of @a xfer structure contains the current status of the
+ *         transfer at the end of the call.
+ * @note
+ * The parameter @a xfer should be same as the one passed to Chip_I2CM_Xfer()
+ * routine.
+ */
+uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief  Transmit and Receive data in master mode
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  xfer    : Pointer to a I2CM_XFER_T structure see notes below
+ * @return Nothing.
+ * @note
+ * The parameter @a xfer should have its member @a slaveAddr initialized
+ * to the 7-Bit slave address to which the master will do the xfer, Bit0
+ * to bit6 should have the address and Bit8 is ignored. During the transfer
+ * no code (like event handler) must change the content of the memory
+ * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
+ * initialized to the memory from which the I2C must pick the data to be
+ * transferred to slave and the number of bytes to send respectively, similarly
+ * @a rxBuff and @a rxSz must have pointer to memory where data received
+ * from slave be stored and the number of data to get from slave respectively.
+ * Following types of transfers are possible:
+ * - Write-only transfer: When @a rxSz member of @a xfer is set to 0.
+ *
+ *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A] P
+ *
+ *      - If I2CM_XFER_OPTION_IGNORE_NACK is set in @a options member
+ *
+ *          S Addr Wr [A] txBuff0 [A or NA] ... txBuffN [A or NA] P
+ *
+ * - Read-only transfer: When @a txSz member of @a xfer is set to 0.
+ *
+ *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
+ *
+ *      - If I2CM_XFER_OPTION_LAST_RX_ACK is set in @a options member
+ *
+ *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] A P
+ *
+ * - Read-Write transfer: When @a rxSz and @ txSz members of @a xfer are non-zero.
+ *
+ *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A]
+ *              S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
+ *
+ */
+void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief  Transmit and Receive data in master mode
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  xfer    : Pointer to a I2CM_XFER_T structure see notes below
+ * @return Returns non-zero value on successful completion of transfer.
+ * @note
+ * This function operates same as Chip_I2CM_Xfer(), but is a blocking call.
+ */
+uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief  Write given buffer of data to I2C interface
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  buff    : Pointer to buffer to be transmitted
+ * @param  len     : Length of the buffer
+ * @return Returns number of bytes written.
+ * @note   This function is a blocking call. The function generates
+ *          START/repeat-START condition on bus and starts transmitting
+ *          data until transfer finishes or a NACK is received. No
+ *          STOP condition is transmitted on the bus.
+ *
+ *          S Data0 [A] Data1 [A] ... DataN [A]
+ */
+uint32_t Chip_I2CM_Write(LPC_I2C_T *pI2C, const uint8_t *buff, uint32_t len);
+
+/**
+ * @brief  Read data from I2C slave to given buffer
+ * @param  pI2C    : Pointer to selected I2C peripheral
+ * @param  buff    :   Pointer to buffer for data received from I2C slave
+ * @param  len     : Length of the buffer
+ * @return Returns number of bytes read.
+ * @note   This function is a blocking call. The function generates
+ *          START/repeat-START condition on bus and starts reading
+ *          data until requested number of bytes are read. No
+ *          STOP condition is transmitted on the bus.
+ *
+ *          S [Data0] A [Data1] A ... [DataN] A
+ */
+uint32_t Chip_I2CM_Read(LPC_I2C_T *pI2C, uint8_t *buff, uint32_t len);
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/i2s_18xx_43xx.h ./lpc_chip_43xx/inc/i2s_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/i2s_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/i2s_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,560 @@
+/*
+ * @brief LPC18xx/43xx I2S driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2S_18XX_43XX_H_
+#define __I2S_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2S_18XX_43XX CHIP: LPC18xx/43xx I2S driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief I2S DMA request channel define
+ */
+typedef enum {
+   I2S_DMA_REQUEST_CHANNEL_1,  /*!< DMA request channel 1 */
+   I2S_DMA_REQUEST_CHANNEL_2,  /*!< DMA request channel 2 */
+   I2S_DMA_REQUEST_CHANNEL_NUM,/*!< The number of DMA request channels */
+} I2S_DMA_CHANNEL_T;
+
+/**
+ * @brief I2S register block structure
+ */
+typedef struct {               /*!< I2S Structure */
+   __IO uint32_t DAO;          /*!< I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel */
+   __IO uint32_t DAI;          /*!< I2S Digital Audio Input Register. Contains control bits for the I2S receive channel */
+   __O uint32_t TXFIFO;        /*!< I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO */
+   __I uint32_t RXFIFO;        /*!< I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO */
+   __I uint32_t STATE;         /*!< I2S Status Feedback Register. Contains status information about the I2S interface */
+   __IO uint32_t DMA[I2S_DMA_REQUEST_CHANNEL_NUM]; /*!< I2S DMA Configuration Registers. Contains control information for DMA request channels */
+   __IO uint32_t IRQ;          /*!< I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated */
+   __IO uint32_t TXRATE;       /*!< I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK */
+   __IO uint32_t RXRATE;       /*!< I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK */
+   __IO uint32_t TXBITRATE;    /*!< I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock */
+   __IO uint32_t RXBITRATE;    /*!< I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock */
+   __IO uint32_t TXMODE;       /*!< I2S Transmit mode control */
+   __IO uint32_t RXMODE;       /*!< I2S Receive mode control */
+} LPC_I2S_T;
+
+/*
+ * @brief I2S configuration parameter defines
+ */
+/* I2S Wordwidth bit */
+#define I2S_WORDWIDTH_8     (0UL << 0) /*!< 8 bit Word */
+#define I2S_WORDWIDTH_16    (1UL << 0) /*!< 16 bit word */
+#define I2S_WORDWIDTH_32    (3UL << 0) /*!< 32 bit word */
+
+/* I2S Channel bit */
+#define I2S_STEREO          (0UL << 2) /*!< Stereo audio */
+#define I2S_MONO            (1UL << 2) /*!< Mono audio */
+
+/* I2S Master/Slave mode bit */
+#define I2S_MASTER_MODE     (0UL << 5) /*!< I2S in master mode */
+#define I2S_SLAVE_MODE      (1UL << 5) /*!< I2S in slave mode */
+
+/* I2S Stop bit */
+#define I2S_STOP_ENABLE     (0UL << 3) /*!< I2S stop enable mask */
+#define I2S_STOP_DISABLE    (1UL << 3) /*!< I2S stop disable mask */
+
+/* I2S Reset bit */
+#define I2S_RESET_ENABLE    (1UL << 4) /*!< I2S reset enable mask */
+#define I2S_RESET_DISABLE   (0UL << 4) /*!< I2S reset disable mask */
+
+/* I2S Mute bit */
+#define I2S_MUTE_ENABLE     (1UL << 15)    /*!< I2S mute enable mask */
+#define I2S_MUTE_DISABLE    (0UL << 15)    /*!< I2S mute disbale mask */
+
+/*
+ * @brief Macro defines for DAO-Digital Audio Output register
+ */
+/* I2S wordwide - the number of bytes in data*/
+#define I2S_DAO_WORDWIDTH_8     ((uint32_t) (0))   /*!< DAO 8 bit  */
+#define I2S_DAO_WORDWIDTH_16    ((uint32_t) (1))   /*!< DAO 16 bit */
+#define I2S_DAO_WORDWIDTH_32    ((uint32_t) (3))   /*!< DAO 32 bit */
+#define I2S_DAO_WORDWIDTH_MASK  ((uint32_t) (3))
+
+/* I2S control mono or stereo format */
+#define I2S_DAO_MONO            ((uint32_t) (1 << 2))  /*!< DAO mono audio mask */
+
+/* I2S control stop mode */
+#define I2S_DAO_STOP            ((uint32_t) (1 << 3))  /*!< DAO stop mask */
+
+/* I2S control reset mode */
+#define I2S_DAO_RESET           ((uint32_t) (1 << 4))  /*!< DAO reset mask */
+
+/* I2S control master/slave mode */
+#define I2S_DAO_SLAVE           ((uint32_t) (1 << 5))  /*!< DAO slave mode mask */
+
+/* I2S word select half period minus one */
+#define I2S_DAO_WS_HALFPERIOD(n)    ((uint32_t) (((n) & 0x1FF) << 6))  /*!< DAO Word select set macro */
+#define I2S_DAO_WS_HALFPERIOD_MASK  ((uint32_t) ((0x1FF) << 6))        /*!< DAO Word select mask */
+
+/* I2S control mute mode */
+#define I2S_DAO_MUTE            ((uint32_t) (1 << 15)) /*!< DAO mute mask */
+
+/*
+ * @brief Macro defines for DAI-Digital Audio Input register
+ */
+/* I2S wordwide - the number of bytes in data*/
+#define I2S_DAI_WORDWIDTH_8     ((uint32_t) (0))   /*!< DAI 8 bit  */
+#define I2S_DAI_WORDWIDTH_16    ((uint32_t) (1))   /*!< DAI 16 bit */
+#define I2S_DAI_WORDWIDTH_32    ((uint32_t) (3))   /*!< DAI 32 bit */
+#define I2S_DAI_WORDWIDTH_MASK  ((uint32_t) (3))   /*!< DAI word wide mask */
+
+/* I2S control mono or stereo format */
+#define I2S_DAI_MONO            ((uint32_t) (1 << 2))  /*!< DAI mono mode mask */
+
+/* I2S control stop mode */
+#define I2S_DAI_STOP            ((uint32_t) (1 << 3))  /*!< DAI stop bit mask */
+
+/* I2S control reset mode */
+#define I2S_DAI_RESET           ((uint32_t) (1 << 4))  /*!< DAI reset bit mask */
+
+/* I2S control master/slave mode */
+#define I2S_DAI_SLAVE           ((uint32_t) (1 << 5))  /*!< DAI slave mode mask */
+
+/* I2S word select half period minus one (9 bits)*/
+#define I2S_DAI_WS_HALFPERIOD(n)    ((uint32_t) (((n) & 0x1FF) << 6))  /*!< DAI Word select set macro */
+#define I2S_DAI_WS_HALFPERIOD_MASK  ((uint32_t) ((0x1FF) << 6))        /*!< DAI Word select mask */
+
+/*
+ * @brief Macro defines for STAT register (Status Feedback register)
+ */
+#define I2S_STATE_IRQ       ((uint32_t) (1))/*!< I2S Status Receive or Transmit Interrupt */
+#define I2S_STATE_DMA1      ((uint32_t) (1 << 1))  /*!< I2S Status Receive or Transmit DMA1 */
+#define I2S_STATE_DMA2      ((uint32_t) (1 << 2))  /*!< I2S Status Receive or Transmit DMA2 */
+#define I2S_STATE_RX_LEVEL(n)   ((uint32_t) ((n & 1F) << 8))/*!< I2S Status Current level of the Receive FIFO (5 bits)*/
+#define I2S_STATE_TX_LEVEL(n)   ((uint32_t) ((n & 1F) << 16))  /*!< I2S Status Current level of the Transmit FIFO (5 bits)*/
+
+/*
+ * @brief Macro defines for DMA1 register (DMA1 Configuration register)
+ */
+#define I2S_DMA1_RX_ENABLE      ((uint32_t) (1))/*!< I2S control DMA1 for I2S receive */
+#define I2S_DMA1_TX_ENABLE      ((uint32_t) (1 << 1))  /*!< I2S control DMA1 for I2S transmit */
+#define I2S_DMA1_RX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 8)) /*!< I2S set FIFO level that trigger a receive DMA request on DMA1 */
+#define I2S_DMA1_TX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 16))    /*!< I2S set FIFO level that trigger a transmit DMA request on DMA1 */
+
+/*
+ * @brief Macro defines for DMA2 register (DMA2 Configuration register)
+ */
+#define I2S_DMA2_RX_ENABLE      ((uint32_t) (1))/*!< I2S control DMA2 for I2S receive */
+#define I2S_DMA2_TX_ENABLE      ((uint32_t) (1 << 1))  /*!< I2S control DMA1 for I2S transmit */
+#define I2S_DMA2_RX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 8)) /*!< I2S set FIFO level that trigger a receive DMA request on DMA1 */
+#define I2S_DMA2_TX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 16))    /*!< I2S set FIFO level that trigger a transmit DMA request on DMA1 */
+
+/*
+ * @brief Macro defines for IRQ register (Interrupt Request Control register)
+ */
+
+#define I2S_IRQ_RX_ENABLE       ((uint32_t) (1))/*!< I2S control I2S receive interrupt */
+#define I2S_IRQ_TX_ENABLE       ((uint32_t) (1 << 1))  /*!< I2S control I2S transmit interrupt */
+#define I2S_IRQ_RX_DEPTH(n)     ((uint32_t) ((n & 0x0F) << 8)) /*!< I2S set the FIFO level on which to create an irq request */
+#define I2S_IRQ_RX_DEPTH_MASK   ((uint32_t) ((0x0F) << 8))
+#define I2S_IRQ_TX_DEPTH(n)     ((uint32_t) ((n & 0x0F) << 16))    /*!< I2S set the FIFO level on which to create an irq request */
+#define I2S_IRQ_TX_DEPTH_MASK   ((uint32_t) ((0x0F) << 16))
+
+/*
+ * @brief Macro defines for TXRATE/RXRATE register (Transmit/Receive Clock Rate register)
+ */
+#define I2S_TXRATE_Y_DIVIDER(n) ((uint32_t) (n & 0xFF))    /*!< I2S Transmit MCLK rate denominator */
+#define I2S_TXRATE_X_DIVIDER(n) ((uint32_t) ((n & 0xFF) << 8)) /*!< I2S Transmit MCLK rate denominator */
+#define I2S_RXRATE_Y_DIVIDER(n) ((uint32_t) (n & 0xFF))    /*!< I2S Receive MCLK rate denominator */
+#define I2S_RXRATE_X_DIVIDER(n) ((uint32_t) ((n & 0xFF) << 8)) /*!< I2S Receive MCLK rate denominator */
+
+/*
+ * @brief Macro defines for TXBITRATE & RXBITRATE register (Transmit/Receive Bit Rate register)
+ */
+#define I2S_TXBITRATE(n)    ((uint32_t) (n & 0x3F))
+#define I2S_RXBITRATE(n)    ((uint32_t) (n & 0x3F))
+
+/*
+ * @brief Macro defines for TXMODE/RXMODE register (Transmit/Receive Mode Control register)
+ */
+#define I2S_TXMODE_CLKSEL(n)    ((uint32_t) (n & 0x03))    /*!< I2S Transmit select clock source (2 bits)*/
+#define I2S_TXMODE_4PIN_ENABLE  ((uint32_t) (1 << 2))  /*!< I2S Transmit control 4-pin mode */
+#define I2S_TXMODE_MCENA        ((uint32_t) (1 << 3))  /*!< I2S Transmit control the TX_MCLK output */
+#define I2S_RXMODE_CLKSEL(n)    ((uint32_t) (n & 0x03))    /*!< I2S Receive select clock source */
+#define I2S_RXMODE_4PIN_ENABLE  ((uint32_t) (1 << 2))  /*!< I2S Receive control 4-pin mode */
+#define I2S_RXMODE_MCENA        ((uint32_t) (1 << 3))  /*!< I2S Receive control the TX_MCLK output */
+
+/**
+ * @brief I2S Audio Format Structure
+ */
+typedef struct {
+   uint32_t SampleRate;    /*!< Sample Rate */
+   uint8_t ChannelNumber;  /*!< Channel Number - 1 is mono, 2 is stereo */
+   uint8_t WordWidth;      /*!< Word Width - 8, 16 or 32 bits */
+} I2S_AUDIO_FORMAT_T;
+
+/**
+ * @brief  Initialize for I2S
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ */
+void Chip_I2S_Init(LPC_I2S_T *pI2S);
+
+/**
+ * @brief  Shutdown I2S
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ * @note   Reset all relative registers (DMA, transmit/receive control, interrupt) to default value
+ */
+void Chip_I2S_DeInit(LPC_I2S_T *pI2S);
+
+/**
+ * @brief  Send a 32-bit data to TXFIFO for transmition
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @param  data    : Data to be transmited
+ * @return Nothing
+ * @note   The function writes to TXFIFO without checking any condition.
+ */
+STATIC INLINE void Chip_I2S_Send(LPC_I2S_T *pI2S, uint32_t data)
+{
+   pI2S->TXFIFO = data;
+}
+
+/**
+ * @brief  Get received data from RXFIFO
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Data received in RXFIFO
+ * @note   The function reads from RXFIFO without checking any condition.
+ */
+STATIC INLINE uint32_t Chip_I2S_Receive(LPC_I2S_T *pI2S)
+{
+   return pI2S->RXFIFO;
+}
+
+/**
+ * @brief  Start transmit data
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_I2S_TxStart(LPC_I2S_T *pI2S)
+{
+   pI2S->DAO &= ~(I2S_DAO_RESET | I2S_DAO_STOP | I2S_DAO_MUTE);
+}
+
+/**
+ * @brief  Start receive data
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_I2S_RxStart(LPC_I2S_T *pI2S)
+{
+   pI2S->DAI &= ~(I2S_DAI_RESET | I2S_DAI_STOP);
+}
+
+/**
+ * @brief  Disables accesses on FIFOs, places the transmit channel in mute mode
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_I2S_TxPause(LPC_I2S_T *pI2S)
+{
+   pI2S->DAO |= I2S_DAO_STOP;
+}
+
+/**
+ * @brief  Disables accesses on FIFOs, places the transmit channel in mute mode
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_I2S_RxPause(LPC_I2S_T *pI2S)
+{
+   pI2S->DAI |= I2S_DAI_STOP;
+}
+
+/**
+ * @brief  Mute the Transmit channel
+ * @param  pI2S        : The base of I2S peripheral on the chip
+ * @return Nothing
+ * @note   The data output from I2S transmit channel is always zeroes
+ */
+STATIC INLINE void Chip_I2S_EnableMute(LPC_I2S_T *pI2S)
+{
+   pI2S->DAO |= I2S_DAO_MUTE;
+}
+
+/**
+ * @brief  Un-Mute the I2S channel
+ * @param  pI2S        : The base of I2S peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_I2S_DisableMute(LPC_I2S_T *pI2S)
+{
+   pI2S->DAO &= ~I2S_DAO_MUTE;
+}
+
+/**
+ * @brief  Stop I2S asynchronously
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ * @note   Pause, resets the transmit channel and FIFO asynchronously
+ */
+STATIC INLINE void Chip_I2S_TxStop(LPC_I2S_T *pI2S)
+{
+   pI2S->DAO &= ~I2S_DAO_MUTE;
+   pI2S->DAO |= I2S_DAO_STOP | I2S_DAO_RESET;
+}
+
+/**
+ * @brief  Stop I2S asynchronously
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ * @note   Pause, resets the transmit channel and FIFO asynchronously
+ */
+STATIC INLINE void Chip_I2S_RxStop(LPC_I2S_T *pI2S)
+{
+   pI2S->DAI |= I2S_DAI_STOP | I2S_DAI_RESET;
+}
+
+/**
+ * @brief  Sets the I2S receive channel in slave mode
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ * @note   4 pin mode must be enabled on appropriate channel.
+ * Must be called after each Chip_I2S_TxModeConfig call if
+ * slave mode is needed.
+ */
+STATIC INLINE void Chip_I2S_RxSlave(LPC_I2S_T *pI2S)
+{
+   pI2S->DAI |= I2S_SLAVE_MODE;
+}
+
+/**
+ * @brief  Sets the I2S transmit channel in slave mode
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Nothing
+ * @note   4 pin mode must be enabled on appropriate channel.
+ * Must be called after each Chip_I2S_TxModeConfig call if
+ * slave mode is needed.
+ */
+STATIC INLINE void Chip_I2S_TxSlave(LPC_I2S_T *pI2S)
+{
+   pI2S->DAO |= I2S_SLAVE_MODE;
+}
+
+/**
+ * @brief  Set the I2S transmit mode
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @param  clksel  : Clock source selection for the receive bit clock divider
+ * @param  fpin    : Receive 4-pin mode selection
+ * @param  mcena   : Enable for the RX_MCLK output
+ * @return Nothing
+ * @note   In addition to master and slave modes, which are independently configurable for
+ * the transmitter and the receiver, several different clock sources are possible,
+ * including variations that share the clock and/or WS between the transmitter and
+ * receiver. It also allows using I2S with fewer pins, typically four.
+ */
+STATIC INLINE void Chip_I2S_TxModeConfig(LPC_I2S_T *pI2S,
+                                        uint32_t clksel,
+                                        uint32_t fpin,
+                                        uint32_t mcena)
+{
+   pI2S->TXMODE = clksel | fpin | mcena;
+}
+
+/**
+ * @brief  Set the I2S receive mode
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @param  clksel  : Clock source selection for the receive bit clock divider
+ * @param  fpin    : Receive 4-pin mode selection
+ * @param  mcena   : Enable for the RX_MCLK output
+ * @return Nothing
+ * @note   In addition to master and slave modes, which are independently configurable for
+ * the transmitter and the receiver, several different clock sources are possible,
+ * including variations that share the clock and/or WS between the transmitter and
+ * receiver. It also allows using I2S with fewer pins, typically four.
+ */
+STATIC INLINE void Chip_I2S_RxModeConfig(LPC_I2S_T *pI2S,
+                                        uint32_t clksel,
+                                        uint32_t fpin,
+                                        uint32_t mcena)
+{
+   pI2S->RXMODE = clksel | fpin | mcena;
+}
+
+/**
+ * @brief  Get the current level of the Transmit FIFO
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Current level of the Transmit FIFO
+ */
+STATIC INLINE uint8_t Chip_I2S_GetTxLevel(LPC_I2S_T *pI2S)
+{
+   return (pI2S->STATE >> 16) & 0xF;
+}
+
+/**
+ * @brief  Get the current level of the Receive FIFO
+ * @param  pI2S    : The base of I2S peripheral on the chip
+ * @return Current level of the Receive FIFO
+ */
+STATIC INLINE uint8_t Chip_I2S_GetRxLevel(LPC_I2S_T *pI2S)
+{
+   return (pI2S->STATE >> 8) & 0xF;
+}
+
+/**
+ * @brief  Set the clock frequency for I2S interface
+ * @param  pI2S            : The base of I2S peripheral on the chip
+ * @param  div : Clock divider. This value plus one is used to divide MCLK to produce the clock frequency for I2S interface
+ * @return Nothing
+ * @note   The value depends on the audio sample rate desired and the data size and format(stereo/mono) used.
+ * For example, a 48 kHz sample rate for 16-bit stereo data requires a bit rate of 48 000 x 16 x 2 = 1.536 MHz. So the mclk_divider should be MCLK/1.536 MHz
+ */
+STATIC INLINE void Chip_I2S_SetTxBitRate(LPC_I2S_T *pI2S, uint32_t div)
+{
+   pI2S->TXBITRATE = div;
+}
+
+/**
+ * @brief  Set the clock frequency for I2S interface
+ * @param  pI2S            : The base of I2S peripheral on the chip
+ * @param  div : Clock divider. This value plus one is used to divide MCLK to produce the clock frequency for I2S interface
+ * @return Nothing
+ * @note   The value depends on the audio sample rate desired and the data size and format(stereo/mono) used.
+ * For example, a 48 kHz sample rate for 16-bit stereo data requires a bit rate of 48 000 x 16 x 2 = 1.536 MHz. So the mclk_divider should be MCLK/1.536 MHz
+ */
+STATIC INLINE void Chip_I2S_SetRxBitRate(LPC_I2S_T *pI2S, uint32_t div)
+{
+   pI2S->RXBITRATE = div;
+}
+
+/**
+ * @brief  Set the MCLK rate by using a fractional rate generator, dividing down the frequency of PCLK
+ * @param  pI2S        : The base of I2S peripheral on the chip
+ * @param  xDiv    : I2S transmit MCLK rate numerator
+ * @param  yDiv    : I2S transmit MCLK rate denominator
+ * @return Nothing
+ * @note   Values of the numerator (X) and the denominator (Y) must be chosen to
+ * produce a frequency twice that desired for the transmitter MCLK, which
+ * must be an integer multiple of the transmitter bit clock rate.
+ * The equation for the fractional rate generator is:
+ * MCLK = PCLK * (X/Y) /2
+ * Note: If the value of X or Y is 0, then no clock is generated. Also, the value of Y must be
+ * greater than or equal to X.
+ */
+STATIC INLINE void Chip_I2S_SetTxXYDivider(LPC_I2S_T *pI2S, uint8_t xDiv, uint8_t yDiv)
+{
+   pI2S->TXRATE = yDiv | (xDiv << 8);
+}
+
+/**
+ * @brief  Set the MCLK rate by using a fractional rate generator, dividing down the frequency of PCLK
+ * @param  pI2S        : The base of I2S peripheral on the chip
+ * @param  xDiv    : I2S transmit MCLK rate numerator
+ * @param  yDiv    : I2S transmit MCLK rate denominator
+ * @return Nothing
+ * @note   Values of the numerator (X) and the denominator (Y) must be chosen to
+ * produce a frequency twice that desired for the transmitter MCLK, which
+ * must be an integer multiple of the transmitter bit clock rate.
+ * The equation for the fractional rate generator is:
+ * MCLK = PCLK * (X/Y) /2
+ * Note: If the value of X or Y is 0, then no clock is generated. Also, the value of Y must be
+ * greater than or equal to X.
+ */
+STATIC INLINE void Chip_I2S_SetRxXYDivider(LPC_I2S_T *pI2S, uint8_t xDiv, uint8_t yDiv)
+{
+   pI2S->RXRATE = yDiv | (xDiv << 8);
+}
+
+/**
+ * @brief   Configure I2S for Audio Format input
+ * @param  pI2S            : The base I2S peripheral on the chip
+ * @param  format  : Audio Format
+ * @return SUCCESS or ERROR
+ */
+Status Chip_I2S_TxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format);
+
+/**
+ * @brief   Configure I2S for Audio Format input
+ * @param  pI2S            : The base I2S peripheral on the chip
+ * @param  format  : Audio Format
+ * @return SUCCESS or ERROR
+ */
+Status Chip_I2S_RxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format);
+
+/**
+ * @brief   Enable/Disable Interrupt with a specific FIFO depth
+ * @param  pI2S            : The base I2S peripheral on the chip
+ * @param  newState        : ENABLE or DISABLE interrupt
+ * @param  depth       : FIFO level creating an irq request
+ * @return Nothing
+ */
+void Chip_I2S_Int_TxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth);
+
+/**
+ * @brief   Enable/Disable Interrupt with a specific FIFO depth
+ * @param  pI2S            : The base I2S peripheral on the chip
+ * @param  newState        : ENABLE or DISABLE interrupt
+ * @param  depth       : FIFO level creating an irq request
+ * @return Nothing
+ */
+void Chip_I2S_Int_RxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth);
+
+/**
+ * @brief   Enable/Disable DMA with a specific FIFO depth
+ * @param  pI2S            : The base I2S peripheral on the chip
+ * @param  dmaNum          : Should be
+ *                             - I2S_DMA_REQUEST_CHANNEL_1 : Using DMA1
+ *                             - I2S_DMA_REQUEST_CHANNEL_2 : Using DMA2
+ * @param  newState        : ENABLE or DISABLE interrupt
+ * @param  depth       : FIFO level creating an irq request
+ * @return Nothing
+ */
+void Chip_I2S_DMA_TxCmd(LPC_I2S_T *pI2S, I2S_DMA_CHANNEL_T dmaNum, FunctionalState newState, uint8_t depth);
+
+/**
+ * @brief   Enable/Disable DMA with a specific FIFO depth
+ * @param  pI2S            : The base I2S peripheral on the chip
+ * @param  dmaNum          : Should be
+ *                             - I2S_DMA_REQUEST_CHANNEL_1 : Using DMA1
+ *                             - I2S_DMA_REQUEST_CHANNEL_2 : Using DMA2
+ * @param  newState        : ENABLE or DISABLE interrupt
+ * @param  depth       : FIFO level creating an irq request
+ * @return Nothing
+ */
+void Chip_I2S_DMA_RxCmd(LPC_I2S_T *pI2S, I2S_DMA_CHANNEL_T dmaNum, FunctionalState newState, uint8_t depth);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2S_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/iap_18xx_43xx.h ./lpc_chip_43xx/inc/iap_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/iap_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/iap_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,197 @@
+/*
+ * @brief Common IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __IAP_H_
+#define __IAP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup IAP_18XX_43XX CHIP: LPC18xx/43xx Flash IAP driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/* IAP command definitions */
+#define IAP_PREWRRITE_CMD           50 /*!< Prepare sector for write operation command */
+#define IAP_WRISECTOR_CMD           51 /*!< Write Sector command */
+#define IAP_ERSSECTOR_CMD           52 /*!< Erase Sector command */
+#define IAP_BLANK_CHECK_SECTOR_CMD  53 /*!< Blank check sector */
+#define IAP_REPID_CMD               54 /*!< Read PartID command */
+#define IAP_READ_BOOT_CODE_CMD      55 /*!< Read Boot code version */
+#define IAP_COMPARE_CMD             56 /*!< Compare two RAM address locations */
+#define IAP_REINVOKE_ISP_CMD        57 /*!< Reinvoke ISP */
+#define IAP_READ_UID_CMD            58 /*!< Read UID */
+#define IAP_ERASE_PAGE_CMD          59 /*!< Erase page */
+#define IAP_SET_BOOT_FLASH          60 /*!< Set active boot flash bank */
+#define IAP_EEPROM_WRITE            61 /*!< EEPROM Write command */
+#define IAP_EEPROM_READ             62 /*!< EEPROM READ command */
+
+/* IAP response definitions */
+#define IAP_CMD_SUCCESS             0  /*!< Command is executed successfully */
+#define IAP_INVALID_COMMAND         1  /*!< Invalid command */
+#define IAP_SRC_ADDR_ERROR          2  /*!< Source address is not on word boundary */
+#define IAP_DST_ADDR_ERROR          3  /*!< Destination address is not on a correct boundary */
+#define IAP_SRC_ADDR_NOT_MAPPED     4  /*!< Source address is not mapped in the memory map */
+#define IAP_DST_ADDR_NOT_MAPPED     5  /*!< Destination address is not mapped in the memory map */
+#define IAP_COUNT_ERROR             6  /*!< Byte count is not multiple of 4 or is not a permitted value */
+#define IAP_INVALID_SECTOR          7  /*!< Sector number is invalid or end sector number is greater than start sector number */
+#define IAP_SECTOR_NOT_BLANK        8  /*!< Sector is not blank */
+#define IAP_SECTOR_NOT_PREPARED     9  /*!< Command to prepare sector for write operation was not executed */
+#define IAP_COMPARE_ERROR           10 /*!< Source and destination data not equal */
+#define IAP_BUSY                    11 /*!< Flash programming hardware interface is busy */
+#define IAP_PARAM_ERROR             12 /*!< nsufficient number of parameters or invalid parameter */
+#define IAP_ADDR_ERROR              13 /*!< Address is not on word boundary */
+#define IAP_ADDR_NOT_MAPPED         14 /*!< Address is not mapped in the memory map */
+#define IAP_CMD_LOCKED              15 /*!< Command is locked */
+#define IAP_INVALID_CODE            16 /*!< Unlock code is invalid */
+#define IAP_INVALID_BAUD_RATE       17 /*!< Invalid baud rate setting */
+#define IAP_INVALID_STOP_BIT        18 /*!< Invalid stop bit setting */
+#define IAP_CRP_ENABLED             19 /*!< Code read protection enabled */
+
+/* IAP_ENTRY API function type */
+typedef void (*IAP_ENTRY_T)(unsigned int[5], unsigned int[4]);
+
+/**
+ * @brief  Prepare sector for write operation
+ * @param  strSector   : Start sector number
+ * @param  endSector   : End sector number
+ * @param  bankNum     : Flash Bank number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   This command must be executed before executing "Copy RAM to flash"
+ *         or "Erase Sector" command.
+ *         The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector, uint8_t bankNum);
+
+/**
+ * @brief  Copy RAM to flash
+ * @param  dstAdd      : Destination flash address where data bytes are to be written
+ * @param  srcAdd      : Source flash address where data bytes are to be read
+ * @param  byteswrt    : Number of bytes to be written
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   The addresses should be a 256 byte boundary and the number of bytes
+ *         should be 256 | 512 | 1024 | 4096
+ */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
+
+/**
+ * @brief  Erase sector
+ * @param  strSector   : Start sector number
+ * @param  endSector   : End sector number
+ * @param  bankNum     : Flash Bank number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector, uint8_t bankNum);
+
+/**
+ * @brief Blank check a sector or multiples sector of on-chip flash memory
+ * @param  strSector   : Start sector number
+ * @param  endSector   : End sector number
+ * @param  bankNum     : Flash Bank number
+ * @return Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
+ * @note   The end sector must be greater than or equal to start sector number
+ */
+// FIXME - There are two return value (result[0] & result[1]
+// Result0:Offset of the first non blank word location if the Status Code is
+// SECTOR_NOT_BLANK.
+// Result1:Contents of non blank word location.
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector, uint8_t bankNum);
+
+/**
+ * @brief  Read part identification number
+ * @return Part identification number
+ */
+uint32_t Chip_IAP_ReadPID(void);
+
+/**
+ * @brief  Read boot code version number
+ * @return Boot code version number
+ */
+uint8_t Chip_IAP_ReadBootCode(void);
+
+/**
+ * @brief  Compare the memory contents at two locations
+ * @param  dstAdd      : Destination of the RAM address of data bytes to be compared
+ * @param  srcAdd      : Source of the RAM address of data bytes to be compared
+ * @param  bytescmp    : Number of bytes to be compared
+ * @return Offset of the first mismatch of the status code is COMPARE_ERROR
+ * @note   The addresses should be a word boundary and number of bytes should be
+ *         a multiply of 4
+ */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
+
+/**
+ * @brief  IAP reinvoke ISP to invoke the bootloader in ISP mode
+ * @return none
+ */
+uint8_t Chip_IAP_ReinvokeISP(void);
+
+/**
+ * @brief  Read the unique ID
+ * @return Status code to indicate the command is executed successfully or not
+ */
+uint32_t Chip_IAP_ReadUID(void);
+
+/**
+ * @brief  Erase a page or multiple papers of on-chip flash memory
+ * @param  strPage : Start page number
+ * @param  endPage : End page number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   The page number must be greater than or equal to start page number
+ */
+// FIXME - There are four return value
+// Result0:The first 32-bit word (at the lowest address)
+// Result1:The second 32-bit word.
+// Result2:The third 32-bit word.
+// Result3:The fourth 32-bit word.
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
+
+/**
+ * @brief  Set active boot flash bank
+ * @param  bankNum : Flash bank number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   Enable booting from the indicated flash unit by inserting a valid
+ *                 signature and invalidating the other flash unit
+ */
+uint8_t Chip_IAP_SetBootFlashBank(uint8_t bankNum);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __IAP_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/iap.h ./lpc_chip_43xx/inc/iap.h
--- a_qSC69Z/lpc_chip_43xx/inc/iap.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/iap.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,184 @@
+/*
+ * @brief Common IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __IAP_H_
+#define __IAP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup COMMON_IAP CHIP: Common Chip ISP/IAP commands and return codes
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/* IAP command definitions */
+#define IAP_PREWRRITE_CMD           50 /*!< Prepare sector for write operation command */
+#define IAP_WRISECTOR_CMD           51 /*!< Write Sector command */
+#define IAP_ERSSECTOR_CMD           52 /*!< Erase Sector command */
+#define IAP_BLANK_CHECK_SECTOR_CMD  53 /*!< Blank check sector */
+#define IAP_REPID_CMD               54 /*!< Read PartID command */
+#define IAP_READ_BOOT_CODE_CMD      55 /*!< Read Boot code version */
+#define IAP_COMPARE_CMD             56 /*!< Compare two RAM address locations */
+#define IAP_REINVOKE_ISP_CMD        57 /*!< Reinvoke ISP */
+#define IAP_READ_UID_CMD            58 /*!< Read UID */
+#define IAP_ERASE_PAGE_CMD          59 /*!< Erase page */
+#define IAP_EEPROM_WRITE            61 /*!< EEPROM Write command */
+#define IAP_EEPROM_READ             62 /*!< EEPROM READ command */
+
+/* IAP response definitions */
+#define IAP_CMD_SUCCESS             0  /*!< Command is executed successfully */
+#define IAP_INVALID_COMMAND         1  /*!< Invalid command */
+#define IAP_SRC_ADDR_ERROR          2  /*!< Source address is not on word boundary */
+#define IAP_DST_ADDR_ERROR          3  /*!< Destination address is not on a correct boundary */
+#define IAP_SRC_ADDR_NOT_MAPPED     4  /*!< Source address is not mapped in the memory map */
+#define IAP_DST_ADDR_NOT_MAPPED     5  /*!< Destination address is not mapped in the memory map */
+#define IAP_COUNT_ERROR             6  /*!< Byte count is not multiple of 4 or is not a permitted value */
+#define IAP_INVALID_SECTOR          7  /*!< Sector number is invalid or end sector number is greater than start sector number */
+#define IAP_SECTOR_NOT_BLANK        8  /*!< Sector is not blank */
+#define IAP_SECTOR_NOT_PREPARED     9  /*!< Command to prepare sector for write operation was not executed */
+#define IAP_COMPARE_ERROR           10 /*!< Source and destination data not equal */
+#define IAP_BUSY                    11 /*!< Flash programming hardware interface is busy */
+#define IAP_PARAM_ERROR             12 /*!< nsufficient number of parameters or invalid parameter */
+#define IAP_ADDR_ERROR              13 /*!< Address is not on word boundary */
+#define IAP_ADDR_NOT_MAPPED         14 /*!< Address is not mapped in the memory map */
+#define IAP_CMD_LOCKED              15 /*!< Command is locked */
+#define IAP_INVALID_CODE            16 /*!< Unlock code is invalid */
+#define IAP_INVALID_BAUD_RATE       17 /*!< Invalid baud rate setting */
+#define IAP_INVALID_STOP_BIT        18 /*!< Invalid stop bit setting */
+#define IAP_CRP_ENABLED             19 /*!< Code read protection enabled */
+
+/* IAP_ENTRY API function type */
+typedef void (*IAP_ENTRY_T)(unsigned int[], unsigned int[]);
+
+/**
+ * @brief  Prepare sector for write operation
+ * @param  strSector   : Start sector number
+ * @param  endSector   : End sector number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   This command must be executed before executing "Copy RAM to flash"
+ *         or "Erase Sector" command.
+ *         The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief  Copy RAM to flash
+ * @param  dstAdd      : Destination FLASH address where data bytes are to be written
+ * @param  srcAdd      : Source RAM address where data bytes are to be read
+ * @param  byteswrt    : Number of bytes to be written
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   The addresses should be a 256 byte boundary and the number of bytes
+ *         should be 256 | 512 | 1024 | 4096
+ */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
+
+/**
+ * @brief  Erase sector
+ * @param  strSector   : Start sector number
+ * @param  endSector   : End sector number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief Blank check a sector or multiples sector of on-chip flash memory
+ * @param  strSector   : Start sector number
+ * @param  endSector   : End sector number
+ * @return Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
+ * @note   The end sector must be greater than or equal to start sector number
+ */
+// FIXME - There are two return value (result[0] & result[1]
+// Result0:Offset of the first non blank word location if the Status Code is
+// SECTOR_NOT_BLANK.
+// Result1:Contents of non blank word location.
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief  Read part identification number
+ * @return Part identification number
+ */
+uint32_t Chip_IAP_ReadPID(void);
+
+/**
+ * @brief  Read boot code version number
+ * @return Boot code version number
+ */
+uint32_t Chip_IAP_ReadBootCode(void);
+
+/**
+ * @brief  Compare the memory contents at two locations
+ * @param  dstAdd      : Destination of the RAM address of data bytes to be compared
+ * @param  srcAdd      : Source of the RAM address of data bytes to be compared
+ * @param  bytescmp    : Number of bytes to be compared
+ * @return Offset of the first mismatch of the status code is COMPARE_ERROR
+ * @note   The addresses should be a word boundary and number of bytes should be
+ *         a multiply of 4
+ */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
+
+/**
+ * @brief  IAP reinvoke ISP to invoke the bootloader in ISP mode
+ * @return none
+ */
+uint8_t Chip_IAP_ReinvokeISP(void);
+
+/**
+ * @brief  Read the unique ID
+ * @return Status code to indicate the command is executed successfully or not
+ */
+uint32_t Chip_IAP_ReadUID(uint32_t* uid);
+
+/**
+ * @brief  Erase a page or multiple papers of on-chip flash memory
+ * @param  strPage : Start page number
+ * @param  endPage : End page number
+ * @return Status code to indicate the command is executed successfully or not
+ * @note   The page number must be greater than or equal to start page number
+ */
+// FIXME - There are four return value
+// Result0:The first 32-bit word (at the lowest address)
+// Result1:The second 32-bit word.
+// Result2:The third 32-bit word.
+// Result3:The fourth 32-bit word.
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __IAP_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/lcd_18xx_43xx.h ./lpc_chip_43xx/inc/lcd_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/lcd_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/lcd_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,383 @@
+/*
+ * @brief LPC18xx/43xx LCD chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LCD_18XX_43XX_H_
+#define __LCD_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup LCD_18XX_43XX CHIP: LPC18xx/43xx LCD driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief LCD Controller register block structure
+ */
+typedef struct {               /*!< LCD Structure          */
+   __IO uint32_t  TIMH;        /*!< Horizontal Timing Control register */
+   __IO uint32_t  TIMV;        /*!< Vertical Timing Control register */
+   __IO uint32_t  POL;         /*!< Clock and Signal Polarity Control register */
+   __IO uint32_t  LE;          /*!< Line End Control register */
+   __IO uint32_t  UPBASE;      /*!< Upper Panel Frame Base Address register */
+   __IO uint32_t  LPBASE;      /*!< Lower Panel Frame Base Address register */
+   __IO uint32_t  CTRL;        /*!< LCD Control register   */
+   __IO uint32_t  INTMSK;      /*!< Interrupt Mask register */
+   __I  uint32_t  INTRAW;      /*!< Raw Interrupt Status register */
+   __I  uint32_t  INTSTAT;     /*!< Masked Interrupt Status register */
+   __O  uint32_t  INTCLR;      /*!< Interrupt Clear register */
+   __I  uint32_t  UPCURR;      /*!< Upper Panel Current Address Value register */
+   __I  uint32_t  LPCURR;      /*!< Lower Panel Current Address Value register */
+   __I  uint32_t  RESERVED0[115];
+   __IO uint16_t PAL[256];     /*!< 256x16-bit Color Palette registers */
+   __I  uint32_t  RESERVED1[256];
+   __IO uint32_t CRSR_IMG[256];/*!< Cursor Image registers */
+   __IO uint32_t  CRSR_CTRL;   /*!< Cursor Control register */
+   __IO uint32_t  CRSR_CFG;    /*!< Cursor Configuration register */
+   __IO uint32_t  CRSR_PAL0;   /*!< Cursor Palette register 0 */
+   __IO uint32_t  CRSR_PAL1;   /*!< Cursor Palette register 1 */
+   __IO uint32_t  CRSR_XY;     /*!< Cursor XY Position register */
+   __IO uint32_t  CRSR_CLIP;   /*!< Cursor Clip Position register */
+   __I  uint32_t  RESERVED2[2];
+   __IO uint32_t  CRSR_INTMSK; /*!< Cursor Interrupt Mask register */
+   __O  uint32_t  CRSR_INTCLR; /*!< Cursor Interrupt Clear register */
+   __I  uint32_t  CRSR_INTRAW; /*!< Cursor Raw Interrupt Status register */
+   __I  uint32_t  CRSR_INTSTAT;/*!< Cursor Masked Interrupt Status register */
+} LPC_LCD_T;
+
+/**
+ * @brief LCD Palette entry format
+ */
+typedef struct {
+   uint32_t Rl : 5;
+   uint32_t Gl : 5;
+   uint32_t Bl : 5;
+   uint32_t Il : 1;
+   uint32_t Ru : 5;
+   uint32_t Gu : 5;
+   uint32_t Bu : 5;
+   uint32_t Iu : 1;
+} LCD_PALETTE_ENTRY_T;
+
+/**
+ * @brief LCD Panel type
+ */
+typedef enum {
+   LCD_TFT = 0x02,     /*!< standard TFT */
+   LCD_MONO_4 = 0x01,  /*!< 4-bit STN mono */
+   LCD_MONO_8 = 0x05,  /*!< 8-bit STN mono */
+   LCD_CSTN = 0x00     /*!< color STN */
+} LCD_PANEL_OPT_T;
+
+/**
+ * @brief LCD Color Format
+ */
+typedef enum {
+   LCD_COLOR_FORMAT_RGB = 0,
+   LCD_COLOR_FORMAT_BGR
+} LCD_COLOR_FORMAT_OPT_T;
+
+/** LCD Interrupt control mask register bits */
+#define LCD_INTMSK_FUFIM   0x2 /*!< FIFO underflow interrupt enable */
+#define LCD_INTMSK_LNBUIM  0x4 /*!< LCD next base address update interrupt enable */
+#define LCD_INTMSK_VCOMPIM 0x8 /*!< Vertical compare interrupt enable */
+#define LCD_INTMSK_BERIM   0x10    /*!< AHB master error interrupt enable */
+
+#define CLCDC_LCDCTRL_ENABLE    _BIT(0)        /*!< LCD control enable bit */
+#define CLCDC_LCDCTRL_PWR       _BIT(11)   /*!< LCD control power enable bit */
+
+/**
+ * @brief A structure for LCD Configuration
+ */
+typedef struct {
+   uint8_t  HBP;   /*!< Horizontal back porch in clocks */
+   uint8_t  HFP;   /*!< Horizontal front porch in clocks */
+   uint8_t  HSW;   /*!< HSYNC pulse width in clocks */
+   uint16_t PPL;   /*!< Pixels per line */
+   uint8_t  VBP;   /*!< Vertical back porch in clocks */
+   uint8_t  VFP;   /*!< Vertical front porch in clocks */
+   uint8_t  VSW;   /*!< VSYNC pulse width in clocks */
+   uint16_t LPP;   /*!< Lines per panel */
+   uint8_t  IOE;   /*!< Invert output enable, 1 = invert */
+   uint8_t  IPC;   /*!< Invert panel clock, 1 = invert */
+   uint8_t  IHS;   /*!< Invert HSYNC, 1 = invert */
+   uint8_t  IVS;   /*!< Invert VSYNC, 1 = invert */
+   uint8_t  ACB;   /*!< AC bias frequency in clocks (not used) */
+   uint8_t  BPP;   /*!< Maximum bits per pixel the display supports */
+   LCD_PANEL_OPT_T  LCD;   /*!< LCD panel type */
+   LCD_COLOR_FORMAT_OPT_T  color_format;   /*!<BGR or RGB */
+   uint8_t  Dual;  /*!< Dual panel, 1 = dual panel display */
+} LCD_CONFIG_T;
+
+/**
+ * @brief LCD Cursor Size
+ */
+typedef enum {
+   LCD_CURSOR_32x32 = 0,
+   LCD_CURSOR_64x64
+} LCD_CURSOR_SIZE_OPT_T;
+
+/**
+ * @brief  Initialize the LCD controller
+ * @param  pLCD                : The base of LCD peripheral on the chip
+ * @param  LCD_ConfigStruct    : Pointer to LCD configuration
+ * @return  LCD_FUNC_OK is executed successfully or LCD_FUNC_ERR on error
+ */
+void Chip_LCD_Init(LPC_LCD_T *pLCD, LCD_CONFIG_T *LCD_ConfigStruct);
+
+/**
+ * @brief  Shutdown the LCD controller
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @return  Nothing
+ */
+void Chip_LCD_DeInit(LPC_LCD_T *pLCD);
+
+/**
+ * @brief  Power-on the LCD Panel (power pin)
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_PowerOn(LPC_LCD_T *pLCD)
+{
+   volatile int i;
+   pLCD->CTRL |= CLCDC_LCDCTRL_PWR;
+   for (i = 0; i < 1000000; i++) {}
+   pLCD->CTRL |= CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief  Power-off the LCD Panel (power pin)
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_PowerOff(LPC_LCD_T *pLCD)
+{
+   volatile int i;
+   pLCD->CTRL &= ~CLCDC_LCDCTRL_PWR;
+   for (i = 0; i < 1000000; i++) {}
+   pLCD->CTRL &= ~CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief  Enable/Disable the LCD Controller
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Enable(LPC_LCD_T *pLCD)
+{
+   pLCD->CTRL |= CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief  Enable/Disable the LCD Controller
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Disable(LPC_LCD_T *pLCD)
+{
+   pLCD->CTRL &= ~CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief  Set LCD Upper Panel Frame Buffer for Single Panel or Upper Panel Frame
+ *         Buffer for Dual Panel
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  buffer  : address of buffer
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_SetUPFrameBuffer(LPC_LCD_T *pLCD, void *buffer)
+{
+   pLCD->UPBASE = (uint32_t) buffer;
+}
+
+/**
+ * @brief  Set LCD Lower Panel Frame Buffer for Dual Panel
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  buffer  : address of buffer
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_SetLPFrameBuffer(LPC_LCD_T *pLCD, void *buffer)
+{
+   pLCD->LPBASE = (uint32_t) buffer;
+}
+
+/**
+ * @brief  Configure Cursor
+ * @param  pLCD        : The base of LCD peripheral on the chip
+ * @param  cursor_size : specify size of cursor
+ *                  - LCD_CURSOR_32x32 :cursor size is 32x32 pixels
+ *                  - LCD_CURSOR_64x64 :cursor size is 64x64 pixels
+ * @param  sync        : cursor sync mode
+ *                  - TRUE :cursor sync to the frame sync pulse
+ *                  - FALSE    :cursor async mode
+ * @return None
+ */
+void Chip_LCD_Cursor_Config(LPC_LCD_T *pLCD, LCD_CURSOR_SIZE_OPT_T cursor_size, bool sync);
+
+/**
+ * @brief  Enable Cursor
+ * @param  pLCD        : The base of LCD peripheral on the chip
+ * @param  cursor_num  : specify number of cursor is going to be written
+ *                         this param must < 4
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Cursor_Enable(LPC_LCD_T *pLCD, uint8_t cursor_num)
+{
+   pLCD->CRSR_CTRL = (cursor_num << 4) | 1;
+}
+
+/**
+ * @brief  Disable Cursor
+ * @param  pLCD        : The base of LCD peripheral on the chip
+ * @param  cursor_num  : specify number of cursor is going to be written
+ *                         this param must < 4
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Cursor_Disable(LPC_LCD_T *pLCD, uint8_t cursor_num)
+{
+   pLCD->CRSR_CTRL = (cursor_num << 4);
+}
+
+/**
+ * @brief  Load Cursor Palette
+ * @param  pLCD            : The base of LCD peripheral on the chip
+ * @param  palette_color   : cursor palette 0 value
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Cursor_LoadPalette0(LPC_LCD_T *pLCD, uint32_t palette_color)
+{
+   /* 7:0 - Red
+      15:8 - Green
+      23:16 - Blue
+      31:24 - Not used*/
+   pLCD->CRSR_PAL0 = (uint32_t) palette_color;
+}
+
+/**
+ * @brief  Load Cursor Palette
+ * @param  pLCD            : The base of LCD peripheral on the chip
+ * @param  palette_color   : cursor palette 1 value
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Cursor_LoadPalette1(LPC_LCD_T *pLCD, uint32_t palette_color)
+{
+   /* 7:0 - Red
+          15:8 - Green
+          23:16 - Blue
+          31:24 - Not used*/
+   pLCD->CRSR_PAL1 = (uint32_t) palette_color;
+}
+
+/**
+ * @brief  Set Cursor Position
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  x       : horizontal position
+ * @param  y       : vertical position
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Cursor_SetPos(LPC_LCD_T *pLCD, uint16_t x, uint16_t y)
+{
+   pLCD->CRSR_XY = (x & 0x3FF) | ((y & 0x3FF) << 16);
+}
+
+/**
+ * @brief  Set Cursor Clipping Position
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  x       : horizontal position, should be in range: 0..63
+ * @param  y       : vertical position, should be in range: 0..63
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_Cursor_SetClip(LPC_LCD_T *pLCD, uint16_t x, uint16_t y)
+{
+   pLCD->CRSR_CLIP = (x & 0x3F) | ((y & 0x3F) << 8);
+}
+
+/**
+ * @brief  Enable Controller Interrupt
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  ints    : OR'ed interrupt bits to enable
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_EnableInts(LPC_LCD_T *pLCD, uint32_t ints)
+{
+   pLCD->INTMSK = ints;
+}
+
+/**
+ * @brief  Disable Controller Interrupt
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  ints    : OR'ed interrupt bits to disable
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_DisableInts(LPC_LCD_T *pLCD, uint32_t ints)
+{
+   pLCD->INTMSK = pLCD->INTMSK & ~(ints);
+}
+
+/**
+ * @brief  Clear Controller Interrupt
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  ints    : OR'ed interrupt bits to clear
+ * @return None
+ */
+STATIC INLINE void Chip_LCD_ClearInts(LPC_LCD_T *pLCD, uint32_t ints)
+{
+   pLCD->INTCLR = pLCD->INTMSK & (ints);
+}
+
+/**
+ * @brief  Write Cursor Image into Internal Cursor Image Buffer
+ * @param  pLCD        : The base of LCD peripheral on the chip
+ * @param  cursor_num  : Cursor index
+ * @param  Image       : Pointer to image data
+ * @return None
+ */
+void Chip_LCD_Cursor_WriteImage(LPC_LCD_T *pLCD, uint8_t cursor_num, void *Image);
+
+/**
+ * @brief  Load LCD Palette
+ * @param  pLCD    : The base of LCD peripheral on the chip
+ * @param  palette : Address of palette table to load
+ * @return None
+ */
+void Chip_LCD_LoadPalette(LPC_LCD_T *pLCD, void *palette);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* __LCD_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/lpc_types.h ./lpc_chip_43xx/inc/lpc_types.h
--- a_qSC69Z/lpc_chip_43xx/inc/lpc_types.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/lpc_types.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,216 @@
+/*
+ * @brief Common types used in LPC functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LPC_TYPES_H_
+#define __LPC_TYPES_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/** @defgroup LPC_Types CHIP: LPC Common Types
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/** @defgroup LPC_Types_Public_Types LPC Public Types
+ * @{
+ */
+
+/**
+ * @brief Boolean Type definition
+ */
+typedef enum {FALSE = 0, TRUE = !FALSE} Bool;
+
+/**
+ * @brief Boolean Type definition
+ */
+#if !defined(__cplusplus)
+// typedef enum {false = 0, true = !false} bool;
+#endif
+
+/**
+ * @brief Flag Status and Interrupt Flag Status type definition
+ */
+typedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
+#define PARAM_SETSTATE(State) ((State == RESET) || (State == SET))
+
+/**
+ * @brief Functional State Definition
+ */
+typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+#define PARAM_FUNCTIONALSTATE(State) ((State == DISABLE) || (State == ENABLE))
+
+/**
+ * @ Status type definition
+ */
+typedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
+
+/**
+ * Read/Write transfer type mode (Block or non-block)
+ */
+typedef enum {
+   NONE_BLOCKING = 0,      /**< None Blocking type */
+   BLOCKING,               /**< Blocking type */
+} TRANSFER_BLOCK_T;
+
+/** Pointer to Function returning Void (any number of parameters) */
+typedef void (*PFV)();
+
+/** Pointer to Function returning int32_t (any number of parameters) */
+typedef int32_t (*PFI)();
+
+/**
+ * @}
+ */
+
+/** @defgroup LPC_Types_Public_Macros  LPC Public Macros
+ * @{
+ */
+
+/* _BIT(n) sets the bit at position "n"
+ * _BIT(n) is intended to be used in "OR" and "AND" expressions:
+ * e.g., "(_BIT(3) | _BIT(7))".
+ */
+#undef _BIT
+/* Set bit macro */
+#define _BIT(n) (1 << (n))
+
+/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
+ * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
+ * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
+ */
+#undef _SBF
+/* Set bit field macro */
+#define _SBF(f, v) ((v) << (f))
+
+/* _BITMASK constructs a symbol with 'field_width' least significant
+ * bits set.
+ * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
+ * The symbol is intended to be used to limit the bit field width
+ * thusly:
+ * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
+ * If "any_expression" results in a value that is larger than can be
+ * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
+ * used with the _SBF example above, the example would be written:
+ * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
+ * This ensures that the value written to a_reg is no wider than
+ * 16 bits, and makes the code easier to read and understand.
+ */
+#undef _BITMASK
+/* Bitmask creation macro */
+#define _BITMASK(field_width) ( _BIT(field_width) - 1)
+
+/* NULL pointer */
+#ifndef NULL
+#define NULL ((void *) 0)
+#endif
+
+/* Number of elements in an array */
+#define NELEMENTS(array)  (sizeof(array) / sizeof(array[0]))
+
+/* Static data/function define */
+#define STATIC static
+/* External data/function define */
+#define EXTERN extern
+
+#if !defined(MAX)
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+#if !defined(MIN)
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+/**
+ * @}
+ */
+
+/* Old Type Definition compatibility */
+/** @addtogroup LPC_Types_Public_Types
+ * @{
+ */
+
+/** LPC type for character type */
+typedef char CHAR;
+
+/** LPC type for 8 bit unsigned value */
+typedef uint8_t UNS_8;
+
+/** LPC type for 8 bit signed value */
+typedef int8_t INT_8;
+
+/** LPC type for 16 bit unsigned value */
+typedef uint16_t UNS_16;
+
+/** LPC type for 16 bit signed value */
+typedef int16_t INT_16;
+
+/** LPC type for 32 bit unsigned value */
+typedef uint32_t UNS_32;
+
+/** LPC type for 32 bit signed value */
+typedef int32_t INT_32;
+
+/** LPC type for 64 bit signed value */
+typedef int64_t INT_64;
+
+/** LPC type for 64 bit unsigned value */
+typedef uint64_t UNS_64;
+
+#ifdef __CODE_RED
+#define BOOL_32 bool
+#define BOOL_16 bool
+#define BOOL_8  bool
+#else
+/** 32 bit boolean type */
+typedef bool BOOL_32;
+
+/** 16 bit boolean type */
+typedef bool BOOL_16;
+
+/** 8 bit boolean type */
+typedef bool BOOL_8;
+#endif
+
+#ifdef __CC_ARM
+#define INLINE  __inline
+#else
+#define INLINE inline
+#endif
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#endif /* __LPC_TYPES_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/mcpwm_18xx_43xx.h ./lpc_chip_43xx/inc/mcpwm_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/mcpwm_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/mcpwm_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,80 @@
+/*
+ * @brief LPC18xx/43xx Motor Control PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __MCPWM_18XX_43XX_H_
+#define __MCPWM_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup MCPWM_18XX_43XX CHIP: LPC18xx/43xx Motor Control PWM driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Motor Control PWM register block structure
+ */
+typedef struct {                   /*!< MCPWM Structure        */
+   __I  uint32_t  CON;             /*!< PWM Control read address */
+   __O  uint32_t  CON_SET;         /*!< PWM Control set address */
+   __O  uint32_t  CON_CLR;         /*!< PWM Control clear address */
+   __I  uint32_t  CAPCON;          /*!< Capture Control read address */
+   __O  uint32_t  CAPCON_SET;      /*!< Capture Control set address */
+   __O  uint32_t  CAPCON_CLR;      /*!< Event Control clear address */
+   __IO uint32_t TC[3];            /*!< Timer Counter register */
+   __IO uint32_t LIM[3];           /*!< Limit register         */
+   __IO uint32_t MAT[3];           /*!< Match register         */
+   __IO uint32_t  DT;              /*!< Dead time register     */
+   __IO uint32_t  CCP;             /*!< Communication Pattern register */
+   __I  uint32_t CAP[3];           /*!< Capture register       */
+   __I  uint32_t  INTEN;           /*!< Interrupt Enable read address */
+   __O  uint32_t  INTEN_SET;       /*!< Interrupt Enable set address */
+   __O  uint32_t  INTEN_CLR;       /*!< Interrupt Enable clear address */
+   __I  uint32_t  CNTCON;          /*!< Count Control read address */
+   __O  uint32_t  CNTCON_SET;      /*!< Count Control set address */
+   __O  uint32_t  CNTCON_CLR;      /*!< Count Control clear address */
+   __I  uint32_t  INTF;            /*!< Interrupt flags read address */
+   __O  uint32_t  INTF_SET;        /*!< Interrupt flags set address */
+   __O  uint32_t  INTF_CLR;        /*!< Interrupt flags clear address */
+   __O  uint32_t  CAP_CLR;         /*!< Capture clear address  */
+} LPC_MCPWM_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MCPWM_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/otp_18xx_43xx.h ./lpc_chip_43xx/inc/otp_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/otp_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/otp_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,144 @@
+/*
+ * @brief LPC18xx/43xx OTP Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __OTP_18XX_43XX_H_
+#define __OTP_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup OTP_18XX_43XX CHIP: LPC18xx/43xx OTP Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief  OTP Register block
+ */
+typedef struct {
+   __IO uint32_t OTP0_0;               /*!< (@ 0x40045000) OTP content */
+   __IO uint32_t OTP0_1;               /*!< (@ 0x40045004) OTP content */
+   __IO uint32_t OTP0_2;               /*!< (@ 0x40045008) OTP content */
+   __IO uint32_t OTP0_3;               /*!< (@ 0x4004500C) OTP content */
+   __IO uint32_t OTP1_0;               /*!< (@ 0x40045010) OTP content */
+   __IO uint32_t OTP1_1;               /*!< (@ 0x40045014) OTP content */
+   __IO uint32_t OTP1_2;               /*!< (@ 0x40045018) OTP content */
+   __IO uint32_t OTP1_3;               /*!< (@ 0x4004501C) OTP content */
+   __IO uint32_t OTP2_0;               /*!< (@ 0x40045020) OTP content */
+   __IO uint32_t OTP2_1;               /*!< (@ 0x40045024) OTP content */
+   __IO uint32_t OTP2_2;               /*!< (@ 0x40045028) OTP content */
+   __IO uint32_t OTP2_3;               /*!< (@ 0x4004502C) OTP content */
+   __IO uint32_t OTP3_0;               /*!< (@ 0x40045030) OTP content */
+   __IO uint32_t OTP3_1;               /*!< (@ 0x40045034) OTP content */
+   __IO uint32_t OTP3_2;               /*!< (@ 0x40045038) OTP content */
+   __IO uint32_t OTP3_3;               /*!< (@ 0x4004503C) OTP content */
+} LPC_OTP_T;
+
+/**
+ * @brief  OTP Boot Source selection used in Chip driver
+ */
+typedef enum CHIP_OTP_BOOT_SRC {
+   CHIP_OTP_BOOTSRC_PINS,      /*!< Boot source - External pins */
+   CHIP_OTP_BOOTSRC_UART0,     /*!< Boot source - UART0 */
+   CHIP_OTP_BOOTSRC_SPIFI,     /*!< Boot source - EMC 8-bit memory */
+   CHIP_OTP_BOOTSRC_EMC8,      /*!< Boot source - EMC 16-bit memory */
+   CHIP_OTP_BOOTSRC_EMC16,     /*!< Boot source - EMC 32-bit memory */
+   CHIP_OTP_BOOTSRC_EMC32,     /*!< Boot source - EMC 32-bit memory */
+   CHIP_OTP_BOOTSRC_USB0,      /*!< Boot source - DFU USB0 boot */
+   CHIP_OTP_BOOTSRC_USB1,      /*!< Boot source - DFU USB1 boot */
+   CHIP_OTP_BOOTSRC_SPI,       /*!< Boot source - SPI boot */
+   CHIP_OTP_BOOTSRC_UART3      /*!< Boot source - UART3 */
+} CHIP_OTP_BOOT_SRC_T;
+
+/**
+ * @brief  Initialize for OTP Controller functions
+ * @return  Status of Otp_Init function
+ * This function will initialise all the OTP driver function pointers
+ * and call the ROM OTP Initialisation function.
+ */
+uint32_t Chip_OTP_Init(void);
+
+/**
+ * @brief  Program boot source in OTP Controller
+ * @param  BootSrc : Boot Source enum value
+ * @return Status
+ */
+uint32_t Chip_OTP_ProgBootSrc(CHIP_OTP_BOOT_SRC_T BootSrc);
+
+/**
+ * @brief  Program the JTAG bit in OTP Controller
+ * @return Status
+ */
+uint32_t Chip_OTP_ProgJTAGDis(void);
+
+/**
+ * @brief  Program USB ID in OTP Controller
+ * @param  ProductID   : USB Product ID
+ * @param  VendorID    : USB Vendor ID
+ * @return Status
+ */
+uint32_t Chip_OTP_ProgUSBID(uint32_t ProductID, uint32_t VendorID);
+
+/**
+ * @brief  Program OTP GP Word memory
+ * @param   WordNum     : Word Number (Select word 0 or word 1 or word 2)
+ * @param  Data        : Data value
+ * @param  Mask        : Mask value
+ * @return Status
+ * This function available in devices which are not AES capable
+ */
+uint32_t Chip_OTP_ProgGPWord(uint32_t WordNum, uint32_t Data, uint32_t Mask);
+
+/**
+ * @brief  Program AES Key
+ * @param   KeyNum      : Key Number (Select 0 or 1)
+ * @param  key         : Pointer to AES Key (16 bytes required)
+ * @return Status
+ * This function available in devices which are AES capable
+ */
+uint32_t Chip_OTP_ProgKey(uint32_t KeyNum, uint8_t *key);
+
+/**
+ * @brief  Generate Random Number using HW Random Number Generator
+ * @return Random Number value
+ */
+uint32_t Chip_OTP_GenRand(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __OTP_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/pinint_18xx_43xx.h ./lpc_chip_43xx/inc/pinint_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/pinint_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/pinint_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,252 @@
+/*
+ * @brief LPC18xx/43xx Pin Interrupt and Pattern Match Registers and driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PININT_18XX_43XX_H_
+#define __PININT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PININT_18XX_43XX CHIP: LPC18xx/43xx Pin Interrupt and Pattern Match driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief LPC18xx/43xx Pin Interrupt and Pattern Match register block structure
+ */
+typedef struct {           /*!< PIN_INT Structure */
+   __IO uint32_t ISEL;     /*!< Pin Interrupt Mode register */
+   __IO uint32_t IENR;     /*!< Pin Interrupt Enable (Rising) register */
+   __IO uint32_t SIENR;    /*!< Set Pin Interrupt Enable (Rising) register */
+   __IO uint32_t CIENR;    /*!< Clear Pin Interrupt Enable (Rising) register */
+   __IO uint32_t IENF;     /*!< Pin Interrupt Enable Falling Edge / Active Level register */
+   __IO uint32_t SIENF;    /*!< Set Pin Interrupt Enable Falling Edge / Active Level register */
+   __IO uint32_t CIENF;    /*!< Clear Pin Interrupt Enable Falling Edge / Active Level address */
+   __IO uint32_t RISE;     /*!< Pin Interrupt Rising Edge register */
+   __IO uint32_t FALL;     /*!< Pin Interrupt Falling Edge register */
+   __IO uint32_t IST;      /*!< Pin Interrupt Status register */
+} LPC_PIN_INT_T;
+
+
+/**
+ * LPC18xx/43xx Pin Interrupt channel values
+ */
+#define PININTCH0         (1 << 0)
+#define PININTCH1         (1 << 1)
+#define PININTCH2         (1 << 2)
+#define PININTCH3         (1 << 3)
+#define PININTCH4         (1 << 4)
+#define PININTCH5         (1 << 5)
+#define PININTCH6         (1 << 6)
+#define PININTCH7         (1 << 7)
+#define PININTCH(ch)      (1 << (ch))
+
+/**
+ * @brief  Initialize Pin interrupt block
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return Nothing
+ * @note   This function should be used after the Chip_GPIO_Init() function.
+ */
+STATIC INLINE void Chip_PININT_Init(LPC_PIN_INT_T *pPININT) {}
+
+/**
+ * @brief  De-Initialize Pin interrupt block
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT) {}
+
+/**
+ * @brief  Configure the pins as edge sensitive in Pin interrupt block
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->ISEL &= ~pins;
+}
+
+/**
+ * @brief  Configure the pins as level sensitive in Pin interrupt block
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->ISEL |= pins;
+}
+
+/**
+ * @brief  Return current PININT rising edge or high level interrupt enable state
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return A bifield containing the high edge/level interrupt enables for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the high edge/level interrupt is disabled, while a 1
+ * means it's enabled.
+ */
+STATIC INLINE uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
+{
+   return pPININT->IENR;
+}
+
+/**
+ * @brief  Enable high edge/level PININT interrupts for pins
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins to enable (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->SIENR = pins;
+}
+
+/**
+ * @brief  Disable high edge/level PININT interrupts for pins
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins to disable (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->CIENR = pins;
+}
+
+/**
+ * @brief  Return current PININT falling edge or low level interrupt enable state
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return A bifield containing the low edge/level interrupt enables for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the low edge/level interrupt is disabled, while a 1
+ * means it's enabled.
+ */
+STATIC INLINE uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
+{
+   return pPININT->IENF;
+}
+
+/**
+ * @brief  Enable low edge/level PININT interrupts for pins
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins to enable (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->SIENF = pins;
+}
+
+/**
+ * @brief  Disable low edge/level PININT interrupts for pins
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins to disable (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->CIENF = pins;
+}
+
+/**
+ * @brief  Return pin states that have a detected latched high edge (RISE) state
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return PININT states (bit n = high) with a latched rise state detected
+ */
+STATIC INLINE uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
+{
+   return pPININT->RISE;
+}
+
+/**
+ * @brief  Clears pin states that had a latched high edge (RISE) state
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins with latched states to clear
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->RISE = pins;
+}
+
+/**
+ * @brief  Return pin states that have a detected latched falling edge (FALL) state
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return PININT states (bit n = high) with a latched rise state detected
+ */
+STATIC INLINE uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
+{
+   return pPININT->FALL;
+}
+
+/**
+ * @brief  Clears pin states that had a latched falling edge (FALL) state
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pins with latched states to clear
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->FALL = pins;
+}
+
+/**
+ * @brief  Get interrupt status from Pin interrupt block
+ * @param  pPININT : The base address of Pin interrupt block
+ * @return Interrupt status (bit n for PININTn = high means interrupt ie pending)
+ */
+STATIC INLINE uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
+{
+   return pPININT->IST;
+}
+
+/**
+ * @brief  Clear interrupt status in Pin interrupt block
+ * @param  pPININT : The base address of Pin interrupt block
+ * @param  pins    : Pin interrupts to clear (ORed value of PININTCH*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+   pPININT->IST = pins;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PININT_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/pmc_18xx_43xx.h ./lpc_chip_43xx/inc/pmc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/pmc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/pmc_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,99 @@
+/*
+ * @brief LPC18xx/43xx Power Management Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PMC_18XX_43XX_H_
+#define __PMC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PMC_18XX_43XX CHIP: LPC18xx/43xx Power Management Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Power Management Controller register block structure
+ */
+typedef struct {                       /*!< PMC Structure          */
+   __IO uint32_t  PD0_SLEEP0_HW_ENA;   /*!< Hardware sleep event enable register */
+   __I  uint32_t  RESERVED0[6];
+   __IO uint32_t  PD0_SLEEP0_MODE;     /*!< Sleep power mode register */
+} LPC_PMC_T;
+
+/**
+ * @brief Power Management Controller power modes
+ * Setting this mode will not make IO loose the state
+ */
+#define PMC_PWR_DEEP_SLEEP_MODE         0x3000AA
+#define PMC_PWR_POWER_DOWN_MODE         0x30FCBA
+#define PMC_PWR_DEEP_POWER_DOWN_MODE    0x30FF7F
+
+/**
+ * @brief Power Management Controller power modes (IO powerdown)
+ * Setting this mode will make the IO loose the state
+ */
+#define PMC_PWR_DEEP_SLEEP_MODE_NO_IO         0x3F00AA
+#define PMC_PWR_POWER_DOWN_MODE_NO_IO         0x3FFCBA
+#define PMC_PWR_DEEP_POWER_DOWN_MODE_NO_IO    0x3FFF7F
+
+/*
+ * @brief PMC power states
+ */
+typedef enum {
+   PMC_DeepSleep = PMC_PWR_DEEP_SLEEP_MODE,            /*!< Deep sleep state */
+   PMC_PowerDown = PMC_PWR_POWER_DOWN_MODE,            /*!< Power Down state */
+   PMC_DeepPowerDown = PMC_PWR_DEEP_POWER_DOWN_MODE,   /*!< Power Down state */
+} CHIP_PMC_PWR_STATE_T;
+
+/**
+ * @brief  Set to sleep power state
+ * @return Nothing
+ */
+void Chip_PMC_Sleep(void);
+
+/**
+ * @brief  Set to sleep power mode
+ * @param  PwrState    : Power State as specified in /a CHIP_PMC_PWR_STATE_T enum
+ * @return Nothing
+ */
+void Chip_PMC_Set_PwrState(CHIP_PMC_PWR_STATE_T PwrState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PMC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/qei_18xx_43xx.h ./lpc_chip_43xx/inc/qei_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/qei_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/qei_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,86 @@
+/*
+ * @brief LPC18xx/43xx Quadrature Encoder Interface driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __QEI_18XX_43XX_H_
+#define __QEI_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup QEI_18XX_43XX CHIP: LPC18xx/43xx Quadrature Encoder Interface driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Quadrature Encoder Interface register block structure
+ */
+typedef struct {               /*!< QEI Structure          */
+   __O  uint32_t  CON;         /*!< Control register       */
+   __I  uint32_t  STAT;        /*!< Encoder status register */
+   __IO uint32_t  CONF;        /*!< Configuration register */
+   __I  uint32_t  POS;         /*!< Position register      */
+   __IO uint32_t  MAXPOS;      /*!< Maximum position register */
+   __IO uint32_t  CMPOS0;      /*!< position compare register 0 */
+   __IO uint32_t  CMPOS1;      /*!< position compare register 1 */
+   __IO uint32_t  CMPOS2;      /*!< position compare register 2 */
+   __I  uint32_t  INXCNT;      /*!< Index count register   */
+   __IO uint32_t  INXCMP0;     /*!< Index compare register 0 */
+   __IO uint32_t  LOAD;        /*!< Velocity timer reload register */
+   __I  uint32_t  TIME;        /*!< Velocity timer register */
+   __I  uint32_t  VEL;         /*!< Velocity counter register */
+   __I  uint32_t  CAP;         /*!< Velocity capture register */
+   __IO uint32_t  VELCOMP;     /*!< Velocity compare register */
+   __IO uint32_t  FILTERPHA;   /*!< Digital filter register on input phase A (QEI_A) */
+   __IO uint32_t  FILTERPHB;   /*!< Digital filter register on input phase B (QEI_B) */
+   __IO uint32_t  FILTERINX;   /*!< Digital filter register on input index (QEI_IDX) */
+   __IO uint32_t  WINDOW;      /*!< Index acceptance window register */
+   __IO uint32_t  INXCMP1;     /*!< Index compare register 1 */
+   __IO uint32_t  INXCMP2;     /*!< Index compare register 2 */
+   __I  uint32_t  RESERVED0[993];
+   __O  uint32_t  IEC;         /*!< Interrupt enable clear register */
+   __O  uint32_t  IES;         /*!< Interrupt enable set register */
+   __I  uint32_t  INTSTAT;     /*!< Interrupt status register */
+   __I  uint32_t  IE;          /*!< Interrupt enable register */
+   __O  uint32_t  CLR;         /*!< Interrupt status clear register */
+   __O  uint32_t  SET;         /*!< Interrupt status set register */
+} LPC_QEI_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __QEI_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/rgu_18xx_43xx.h ./lpc_chip_43xx/inc/rgu_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/rgu_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/rgu_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,158 @@
+/*
+ * @brief LPC18xx/43xx Reset Generator Unit driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RGU_18XX_43XX_H_
+#define __RGU_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RGU_18XX_43XX CHIP: LPC18xx/43xx Reset Generator Unit (RGU) driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief RGU reset enumerations
+ */
+typedef enum CHIP_RGU_RST {
+   RGU_CORE_RST,
+   RGU_PERIPH_RST,
+   RGU_MASTER_RST,
+   RGU_WWDT_RST = 4,
+   RGU_CREG_RST,
+   RGU_BUS_RST = 8,
+   RGU_SCU_RST,
+   RGU_M0SUB_RST = 12,
+   RGU_M3_RST,
+   RGU_LCD_RST = 16,
+   RGU_USB0_RST,
+   RGU_USB1_RST,
+   RGU_DMA_RST,
+   RGU_SDIO_RST,
+   RGU_EMC_RST,
+   RGU_ETHERNET_RST,
+   RGU_FLASHA_RST = 25,
+   RGU_EEPROM_RST = 27,
+   RGU_GPIO_RST,
+   RGU_FLASHB_RST,
+   RGU_TIMER0_RST = 32,
+   RGU_TIMER1_RST,
+   RGU_TIMER2_RST,
+   RGU_TIMER3_RST,
+   RGU_RITIMER_RST,
+   RGU_SCT_RST,
+   RGU_MOTOCONPWM_RST,
+   RGU_QEI_RST,
+   RGU_ADC0_RST,
+   RGU_ADC1_RST,
+   RGU_DAC_RST,
+   RGU_UART0_RST = 44,
+   RGU_UART1_RST,
+   RGU_UART2_RST,
+   RGU_UART3_RST,
+   RGU_I2C0_RST,
+   RGU_I2C1_RST,
+   RGU_SSP0_RST,
+   RGU_SSP1_RST,
+   RGU_I2S_RST,
+   RGU_SPIFI_RST,
+   RGU_CAN1_RST,
+   RGU_CAN0_RST,
+#ifdef CHIP_LPC43XX
+   RGU_M0APP_RST,
+   RGU_SGPIO_RST,
+   RGU_SPI_RST,
+   RGU_ADCHS_RST = 60,
+#endif
+   RGU_LAST_RST = 63,
+} CHIP_RGU_RST_T;
+
+/**
+ * @brief RGU register structure
+ */
+typedef struct {                           /*!< RGU Structure          */
+   __I  uint32_t  RESERVED0[64];
+   __O  uint32_t  RESET_CTRL[2];           /*!< Reset control register 0,1 */
+   __I  uint32_t  RESERVED1[2];
+   __IO uint32_t  RESET_STATUS[4];         /*!< Reset status register 0 to 3 */
+   __I  uint32_t  RESERVED2[12];
+   __I  uint32_t  RESET_ACTIVE_STATUS[2];  /*!< Reset active status register 0, 1 */
+   __I  uint32_t  RESERVED3[170];
+   __IO uint32_t  RESET_EXT_STAT[RGU_LAST_RST + 1];/*!< Reset external status registers */
+} LPC_RGU_T;
+
+/**
+ * @brief  Trigger a peripheral reset for the selected peripheral
+ * @param  ResetNumber : Peripheral reset number to trigger
+ * @return Nothing
+ */
+STATIC INLINE void Chip_RGU_TriggerReset(CHIP_RGU_RST_T ResetNumber)
+{
+   LPC_RGU->RESET_CTRL[ResetNumber >> 5] = 1 << (ResetNumber & 31);
+   /* Reset will auto clear after 1 clock cycle */
+}
+
+/**
+ * @brief  Checks the reset status of a peripheral
+ * @param  ResetNumber : Peripheral reset number to trigger
+ * @return true if the periperal is still being reset
+ */
+STATIC INLINE bool Chip_RGU_InReset(CHIP_RGU_RST_T ResetNumber)
+{
+   return !(LPC_RGU->RESET_ACTIVE_STATUS[ResetNumber >> 5] & (1 << (ResetNumber & 31)));
+}
+
+/**
+ * @brief  Clears reset for the selected peripheral
+ * @param  ResetNumber : Peripheral reset number to trigger (RGU_M0SUB_RST or RGU_M0APP_RST)
+ * @return Nothing
+ * @note
+ * Almost all peripherals will auto clear the reset bit. Only a few peripherals
+ * like the Cortex M0 Core in LPC43xx will not auto clear the reset and require
+ * this function to clear the reset bit. This function clears all reset bits in
+ * a reset register.
+ */
+STATIC INLINE void Chip_RGU_ClearReset(CHIP_RGU_RST_T ResetNumber)
+{
+   LPC_RGU->RESET_CTRL[ResetNumber >> 5] = 0;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RGU_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/ring_buffer.h ./lpc_chip_43xx/inc/ring_buffer.h
--- a_qSC69Z/lpc_chip_43xx/inc/ring_buffer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/ring_buffer.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,188 @@
+/*
+ * @brief Common ring buffer support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RING_BUFFER_H_
+#define __RING_BUFFER_H_
+
+#include "lpc_types.h"
+
+/** @defgroup Ring_Buffer CHIP: Simple ring buffer implementation
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief Ring buffer structure
+ */
+typedef struct {
+   void *data;
+   int count;
+   int itemSz;
+   uint32_t head;
+   uint32_t tail;
+} RINGBUFF_T;
+
+/**
+ * @def        RB_VHEAD(rb)
+ * volatile typecasted head index
+ */
+#define RB_VHEAD(rb)              (*(volatile uint32_t *) &(rb)->head)
+
+/**
+ * @def        RB_VTAIL(rb)
+ * volatile typecasted tail index
+ */
+#define RB_VTAIL(rb)              (*(volatile uint32_t *) &(rb)->tail)
+
+/**
+ * @brief  Initialize ring buffer
+ * @param  RingBuff    : Pointer to ring buffer to initialize
+ * @param  buffer      : Pointer to buffer to associate with RingBuff
+ * @param  itemSize    : Size of each buffer item size
+ * @param  count       : Size of ring buffer
+ * @note   Memory pointed by @a buffer must have correct alignment of
+ *             @a itemSize, and @a count must be a power of 2 and must at
+ *             least be 2 or greater.
+ * @return Nothing
+ */
+int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count);
+
+/**
+ * @brief  Resets the ring buffer to empty
+ * @param  RingBuff    : Pointer to ring buffer
+ * @return Nothing
+ */
+STATIC INLINE void RingBuffer_Flush(RINGBUFF_T *RingBuff)
+{
+   RingBuff->head = RingBuff->tail = 0;
+}
+
+/**
+ * @brief  Return size the ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @return Size of the ring buffer in bytes
+ */
+STATIC INLINE int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
+{
+   return RingBuff->count;
+}
+
+/**
+ * @brief  Return number of items in the ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @return Number of items in the ring buffer
+ */
+STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
+{
+   return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
+}
+
+/**
+ * @brief  Return number of free items in the ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @return Number of free items in the ring buffer
+ */
+STATIC INLINE int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
+{
+   return RingBuff->count - RingBuffer_GetCount(RingBuff);
+}
+
+/**
+ * @brief  Return number of items in the ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @return 1 if the ring buffer is full, otherwise 0
+ */
+STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
+{
+   return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
+}
+
+/**
+ * @brief  Return empty status of ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @return 1 if the ring buffer is empty, otherwise 0
+ */
+STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
+{
+   return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
+}
+
+/**
+ * @brief  Insert a single item into ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @param  data        : pointer to item
+ * @return 1 when successfully inserted,
+ *         0 on error (Buffer not initialized using
+ *         RingBuffer_Init() or attempted to insert
+ *         when buffer is full)
+ */
+int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data);
+
+/**
+ * @brief  Insert an array of items into ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @param  data        : Pointer to first element of the item array
+ * @param  num         : Number of items in the array
+ * @return number of items successfully inserted,
+ *         0 on error (Buffer not initialized using
+ *         RingBuffer_Init() or attempted to insert
+ *         when buffer is full)
+ */
+int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num);
+
+/**
+ * @brief  Pop an item from the ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @param  data        : Pointer to memory where popped item be stored
+ * @return 1 when item popped successfuly onto @a data,
+ *             0 When error (Buffer not initialized using
+ *             RingBuffer_Init() or attempted to pop item when
+ *             the buffer is empty)
+ */
+int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data);
+
+/**
+ * @brief  Pop an array of items from the ring buffer
+ * @param  RingBuff    : Pointer to ring buffer
+ * @param  data        : Pointer to memory where popped items be stored
+ * @param  num         : Max number of items array @a data can hold
+ * @return Number of items popped onto @a data,
+ *             0 on error (Buffer not initialized using RingBuffer_Init()
+ *             or attempted to pop when the buffer is empty)
+ */
+int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num);
+
+
+/**
+ * @}
+ */
+
+#endif /* __RING_BUFFER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/ritimer_18xx_43xx.h ./lpc_chip_43xx/inc/ritimer_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/ritimer_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/ritimer_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,189 @@
+/*
+ * @brief LPC18xx/43xx RITimer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RITIMER_18XX_43XX_H_
+#define __RITIMER_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RITIMER_18XX_43XX CHIP: LPC18xx/43xx Repetitive Interrupt Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Repetitive Interrupt Timer register block structure
+ */
+typedef struct {               /*!< RITIMER Structure      */
+   __IO uint32_t  COMPVAL;     /*!< Compare register       */
+   __IO uint32_t  MASK;        /*!< Mask register. This register holds the 32-bit mask value. A 1 written to any bit will force a compare on the corresponding bit of the counter and compare register. */
+   __IO uint32_t  CTRL;        /*!< Control register.      */
+   __IO uint32_t  COUNTER;     /*!< 32-bit counter         */
+} LPC_RITIMER_T;
+
+/*
+ * @brief RITIMER register support bitfields and mask
+ */
+
+/*
+ * RIT control register
+ */
+/**    Set by H/W when the counter value equals the masked compare value */
+#define RIT_CTRL_INT    ((uint32_t) (1))
+/** Set timer enable clear to 0 when the counter value equals the masked compare value  */
+#define RIT_CTRL_ENCLR  ((uint32_t) _BIT(1))
+/** Set timer enable on debug */
+#define RIT_CTRL_ENBR   ((uint32_t) _BIT(2))
+/** Set timer enable */
+#define RIT_CTRL_TEN    ((uint32_t) _BIT(3))
+
+/**
+ * @brief  Initialize the RIT
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return None
+ */
+void Chip_RIT_Init(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief  Shutdown the RIT
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return None
+ */
+void Chip_RIT_DeInit(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief  Enable Timer
+ * @param  pRITimer        : RITimer peripheral selected
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_Enable(LPC_RITIMER_T *pRITimer)
+{
+   pRITimer->CTRL |= RIT_CTRL_TEN;
+}
+
+/**
+ * @brief  Disable Timer
+ * @param  pRITimer        : RITimer peripheral selected
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_Disable(LPC_RITIMER_T *pRITimer)
+{
+   pRITimer->CTRL &= ~RIT_CTRL_TEN;
+}
+
+/**
+ * @brief  Enable timer debug
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_TimerDebugEnable(LPC_RITIMER_T *pRITimer)
+{
+   pRITimer->CTRL |= RIT_CTRL_ENBR;
+}
+
+/**
+ * @brief  Disable timer debug
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_TimerDebugDisable(LPC_RITIMER_T *pRITimer)
+{
+   pRITimer->CTRL &= ~RIT_CTRL_ENBR;
+}
+
+/**
+ * @brief  Check whether interrupt flag is set or not
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return Current interrupt status, either ET or UNSET
+ */
+IntStatus Chip_RIT_GetIntStatus(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief  Set a tick value for the interrupt to time out
+ * @param  pRITimer    : RITimer peripheral selected
+ * @param  val         : value (in ticks) of the interrupt to be set
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_SetCOMPVAL(LPC_RITIMER_T *pRITimer, uint32_t val)
+{
+   pRITimer->COMPVAL = val;
+}
+
+/**
+ * @brief  Enables or clears the RIT or interrupt
+ * @param  pRITimer    : RITimer peripheral selected
+ * @param  val         : RIT to be set, one or more RIT_CTRL_* values
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_EnableCTRL(LPC_RITIMER_T *pRITimer, uint32_t val)
+{
+   pRITimer->CTRL |= val;
+}
+
+/**
+ * @brief  Clears the RIT interrupt
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return None
+ */
+STATIC INLINE void Chip_RIT_ClearInt(LPC_RITIMER_T *pRITimer)
+{
+   pRITimer->CTRL |= RIT_CTRL_INT;
+}
+
+/**
+ * @brief  Returns the current RIT Counter value
+ * @param  pRITimer    : RITimer peripheral selected
+ * @return the current timer counter value
+ */
+STATIC INLINE uint32_t Chip_RIT_GetCounter(LPC_RITIMER_T *pRITimer)
+{
+   return pRITimer->COUNTER;
+}
+
+/**
+ * @brief  Set timer interval value
+ * @param  pRITimer        : RITimer peripheral selected
+ * @param  time_interval   : timer interval value (ms)
+ * @return None
+ */
+void Chip_RIT_SetTimerInterval(LPC_RITIMER_T *pRITimer, uint32_t time_interval);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RITIMER_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/romapi_18xx_43xx.h ./lpc_chip_43xx/inc/romapi_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/romapi_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/romapi_18xx_43xx.h	2018-01-19 23:55:10.972318521 -0300
@@ -0,0 +1,128 @@
+/*
+ * @brief LPC18xx_43xx ROM API declarations and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ROMAPI_18XX_43XX_H_
+#define __ROMAPI_18XX_43XX_H_
+
+#include "iap_18xx_43xx.h"
+#include "error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ROMAPI_18XX_43XX CHIP: LPC18xx_43xx ROM API declarations and functions
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief LPC18XX_43XX OTP API structure
+ */
+typedef struct {
+   uint32_t (*Init)(void);                 /*!< Initializes OTP controller. */
+   uint32_t (*ProgBootSrc)(CHIP_OTP_BOOT_SRC_T BootSrc);
+   uint32_t (*ProgJTAGDis)(void);
+   uint32_t (*ProgUSBID)(uint32_t ProductID, uint32_t VendorID);
+   uint32_t reserved01;
+   uint32_t reserved02;
+   uint32_t reserved03;
+   uint32_t reserved04;
+   uint32_t (*ProgGP0)(uint32_t data, uint32_t mask);
+   uint32_t (*ProgGP1)(uint32_t data, uint32_t mask);
+   uint32_t (*ProgGP2)(uint32_t data, uint32_t mask);
+   uint32_t (*ProgKey1)(uint8_t *key);
+   uint32_t (*ProgKey2)(uint8_t *key);
+   uint32_t (*GenRand)(void);
+} OTP_API_T;
+
+/**
+ * @brief LPC18XX_43XX AES API structure
+ */
+typedef struct {
+   uint32_t (*Init)(void);
+   uint32_t (*SetMode)(uint32_t mode);
+   uint32_t (*LoadKey1)(void);
+   uint32_t (*LoadKey2)(void);
+   uint32_t (*LoadKeyRNG)(void);
+   uint32_t (*LoadKeySW)(uint8_t *pKey);
+   uint32_t (*LoadIV_SW)(uint8_t *pVector);
+   uint32_t (*LoadIV_IC)(void);
+   uint32_t (*Operate)(uint8_t *pOutput, uint8_t *pInput, uint32_t size);
+   uint32_t (*ProgramKey1)(uint8_t *pKey);
+   uint32_t (*ProgramKey2)(uint8_t *pKey);
+} AES_API_T;
+
+/**
+ * @brief LPC18XX High level ROM API structure
+ */
+typedef struct {
+   void(*const iap_entry) (uint32_t *, uint32_t *);    /*!< IAP API entry function available on Flash parts only*/
+   const OTP_API_T *pOtp;
+   const AES_API_T *pAes;
+   uint32_t reserved[3];
+   const uint32_t spifiApiBase;            /*!< SPIFI API function table base address*/
+   const uint32_t usbdApiBase;             /*!< USBD API function table base address*/
+   const uint32_t endMarker;               /*!< API table end marker = 0x87654321 */
+
+} LPC_ROM_API_T;
+
+/* Pointer to ROM API function address */
+#define LPC_ROM_API_BASE_LOC    0x10400100
+#define LPC_ROM_API ((LPC_ROM_API_T *) LPC_ROM_API_BASE)
+
+/* Pointer to ROM IAP entry functions */
+#define IAP_ENTRY_LOCATION        (*((uint32_t *) 0x10400100))
+
+/**
+ * @brief IAP flash bank definitions
+ */
+#define IAP_FLASH_BANK_A                        0
+#define IAP_FLASH_BANK_B                        1
+
+/**
+ * @}
+ */
+
+static INLINE void iap_entry(unsigned int cmd_param[], unsigned int status_result[])
+{
+   ((IAP_ENTRY_T) IAP_ENTRY_LOCATION)(cmd_param, status_result);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ROMAPI_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/rtc_18xx_43xx.h ./lpc_chip_43xx/inc/rtc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/rtc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/rtc_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,638 @@
+/*
+ * @brief LPC18xx/43xx RTC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RTC_18XX_43XX_H_
+#define __RTC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RTC_18XX_43XX CHIP: LPC18xx/43xx Real Time Clock driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define RTC_EV_SUPPORT      1              /* Event Monitor/Recorder support */
+
+/**
+ * @brief RTC time type option
+ */
+typedef enum {
+   RTC_TIMETYPE_SECOND,        /*!< Second */
+   RTC_TIMETYPE_MINUTE,        /*!< Month */
+   RTC_TIMETYPE_HOUR,          /*!< Hour */
+   RTC_TIMETYPE_DAYOFMONTH,    /*!< Day of month */
+   RTC_TIMETYPE_DAYOFWEEK,     /*!< Day of week */
+   RTC_TIMETYPE_DAYOFYEAR,     /*!< Day of year */
+   RTC_TIMETYPE_MONTH,         /*!< Month */
+   RTC_TIMETYPE_YEAR,          /*!< Year */
+   RTC_TIMETYPE_LAST
+} RTC_TIMEINDEX_T;
+
+#if RTC_EV_SUPPORT
+/**
+ * @brief Event Channel Identifier definitions
+ */
+typedef enum {
+   RTC_EV_CHANNEL_1 = 0,
+   RTC_EV_CHANNEL_2,
+   RTC_EV_CHANNEL_3,
+   RTC_EV_CHANNEL_NUM,
+} RTC_EV_CHANNEL_T;
+#endif /*RTC_EV_SUPPORT*/
+
+/**
+ * @brief Real Time Clock register block structure
+ */
+typedef struct {                           /*!< RTC Structure          */
+   __IO uint32_t  ILR;                     /*!< Interrupt Location Register */
+   __I  uint32_t  RESERVED0;
+   __IO uint32_t  CCR;                     /*!< Clock Control Register */
+   __IO uint32_t  CIIR;                    /*!< Counter Increment Interrupt Register */
+   __IO uint32_t  AMR;                     /*!< Alarm Mask Register    */
+   __I  uint32_t  CTIME[3];                /*!< Consolidated Time Register 0,1,2 */
+   __IO uint32_t  TIME[RTC_TIMETYPE_LAST]; /*!< Timer field registers */
+   __IO uint32_t  CALIBRATION;             /*!< Calibration Value Register */
+   __I  uint32_t  RESERVED1[7];
+   __IO uint32_t  ALRM[RTC_TIMETYPE_LAST]; /*!< Alarm field registers */
+#if RTC_EV_SUPPORT
+   __IO uint32_t ERSTATUS;                 /*!< Event Monitor/Recorder Status register*/
+   __IO uint32_t ERCONTROL;                /*!< Event Monitor/Recorder Control register*/
+   __I  uint32_t ERCOUNTERS;               /*!< Event Monitor/Recorder Counters register*/
+   __I  uint32_t RESERVED2;
+   __I  uint32_t ERFIRSTSTAMP[RTC_EV_CHANNEL_NUM];         /*!<Event Monitor/Recorder First Stamp registers*/
+   __I  uint32_t RESERVED3;
+   __I  uint32_t ERLASTSTAMP[RTC_EV_CHANNEL_NUM];          /*!<Event Monitor/Recorder Last Stamp registers*/
+#endif /*RTC_EV_SUPPORT*/
+} LPC_RTC_T;
+
+/**
+ * @brief Register File register block structure
+ */
+typedef struct {
+   __IO uint32_t REGFILE[64];  /*!< General purpose storage register */
+} LPC_REGFILE_T;
+
+/*
+ * @brief ILR register definitions
+ */
+/** ILR register mask */
+#define RTC_ILR_BITMASK         ((0x00000003))
+/** Bit inform the source interrupt is counter increment*/
+#define RTC_IRL_RTCCIF          ((1 << 0))
+/** Bit inform the source interrupt is alarm match*/
+#define RTC_IRL_RTCALF          ((1 << 1))
+
+/*
+ * @brief CCR register definitions
+ */
+/** CCR register mask */
+#define RTC_CCR_BITMASK         ((0x00000013))
+/** Clock enable */
+#define RTC_CCR_CLKEN           ((1 << 0))
+/** Clock reset */
+#define RTC_CCR_CTCRST          ((1 << 1))
+/** Calibration counter enable */
+#define RTC_CCR_CCALEN          ((1 << 4))
+
+/*
+ * @brief CIIR and AMR register definitions
+ */
+/** Counter Increment Interrupt bit for second */
+#define RTC_AMR_CIIR_IMSEC          ((1 << 0))
+/** Counter Increment Interrupt bit for minute */
+#define RTC_AMR_CIIR_IMMIN          ((1 << 1))
+/** Counter Increment Interrupt bit for hour */
+#define RTC_AMR_CIIR_IMHOUR         ((1 << 2))
+/** Counter Increment Interrupt bit for day of month */
+#define RTC_AMR_CIIR_IMDOM          ((1 << 3))
+/** Counter Increment Interrupt bit for day of week */
+#define RTC_AMR_CIIR_IMDOW          ((1 << 4))
+/** Counter Increment Interrupt bit for day of year */
+#define RTC_AMR_CIIR_IMDOY          ((1 << 5))
+/** Counter Increment Interrupt bit for month */
+#define RTC_AMR_CIIR_IMMON          ((1 << 6))
+/** Counter Increment Interrupt bit for year */
+#define RTC_AMR_CIIR_IMYEAR         ((1 << 7))
+/** CIIR bit mask */
+#define RTC_AMR_CIIR_BITMASK        ((0xFF))
+
+/*
+ * @brief RTC_AUX register definitions
+ */
+/** RTC Oscillator Fail detect flag */
+#define RTC_AUX_RTC_OSCF        ((1 << 4))
+
+/*
+ * @brief RTC_AUXEN register definitions
+ */
+/** Oscillator Fail Detect interrupt enable*/
+#define RTC_AUXEN_RTC_OSCFEN    ((1 << 4))
+
+/*
+ * @brief Consolidated Time Register 0 definitions
+ */
+#define RTC_CTIME0_SECONDS_MASK     ((0x3F))
+#define RTC_CTIME0_MINUTES_MASK     ((0x3F00))
+#define RTC_CTIME0_HOURS_MASK       ((0x1F0000))
+#define RTC_CTIME0_DOW_MASK         ((0x7000000))
+
+/*
+ * @brief Consolidated Time Register 1 definitions
+ */
+#define RTC_CTIME1_DOM_MASK         ((0x1F))
+#define RTC_CTIME1_MONTH_MASK       ((0xF00))
+#define RTC_CTIME1_YEAR_MASK        ((0xFFF0000))
+
+/*
+ * @brief Consolidated Time Register 2 definitions
+ */
+#define RTC_CTIME2_DOY_MASK         ((0xFFF))
+
+/*
+ * @brief Time Counter Group and Alarm register group
+ */
+/** SEC register mask */
+#define RTC_SEC_MASK            (0x0000003F)
+/** MIN register mask */
+#define RTC_MIN_MASK            (0x0000003F)
+/** HOUR register mask */
+#define RTC_HOUR_MASK           (0x0000001F)
+/** DOM register mask */
+#define RTC_DOM_MASK            (0x0000001F)
+/** DOW register mask */
+#define RTC_DOW_MASK            (0x00000007)
+/** DOY register mask */
+#define RTC_DOY_MASK            (0x000001FF)
+/** MONTH register mask */
+#define RTC_MONTH_MASK          (0x0000000F)
+/** YEAR register mask */
+#define RTC_YEAR_MASK           (0x00000FFF)
+
+#define RTC_SECOND_MAX      59 /*!< Maximum value of second */
+#define RTC_MINUTE_MAX      59 /*!< Maximum value of minute*/
+#define RTC_HOUR_MAX        23 /*!< Maximum value of hour*/
+#define RTC_MONTH_MIN       1  /*!< Minimum value of month*/
+#define RTC_MONTH_MAX       12 /*!< Maximum value of month*/
+#define RTC_DAYOFMONTH_MIN  1  /*!< Minimum value of day of month*/
+#define RTC_DAYOFMONTH_MAX  31 /*!< Maximum value of day of month*/
+#define RTC_DAYOFWEEK_MAX   6  /*!< Maximum value of day of week*/
+#define RTC_DAYOFYEAR_MIN   1  /*!< Minimum value of day of year*/
+#define RTC_DAYOFYEAR_MAX   366    /*!< Maximum value of day of year*/
+#define RTC_YEAR_MAX        4095/*!< Maximum value of year*/
+
+/*
+ * @brief Calibration register
+ */
+/** Calibration value */
+#define RTC_CALIBRATION_CALVAL_MASK     ((0x1FFFF))
+/** Calibration direction */
+#define RTC_CALIBRATION_LIBDIR          ((1 << 17))
+/** Calibration max value */
+#define RTC_CALIBRATION_MAX             ((0x20000))
+/** Calibration definitions */
+#define RTC_CALIB_DIR_FORWARD           ((uint8_t) (0))
+#define RTC_CALIB_DIR_BACKWARD          ((uint8_t) (1))
+
+#if RTC_EV_SUPPORT
+/*
+ * @brief Event Monitor/Recorder Control register
+ */
+/**  Event Monitor/Recorder Control register mask */
+#define RTC_ERCTRL_BITMASK          ((uint32_t) 0xC0F03C0F)
+/** Enable event interrupt and wakeup */
+#define RTC_ERCTRL_INTWAKE_EN       ((uint32_t) (1 << 0))
+/** Enables automatically clearing the RTC general purpose registers when an event occurs*/
+#define RTC_ERCTRL_GPCLEAR_EN       ((uint32_t) (1 << 1))
+/** Select polarity for a channel event on the input pin.*/
+#define RTC_ERCTRL_POL_NEGATIVE     (0)        /* Event as positive edge */
+#define RTC_ERCTRL_POL_POSITIVE     ((uint32_t) (1 << 2))  /* Event as negative edge */
+/** Enable event input.*/
+#define RTC_ERCTRL_INPUT_EN         ((uint32_t) (1 << 3))
+/** Configure a specific channel */
+#define RTC_ERCTRL_CHANNEL_CONFIG_BITMASK(ch)   ((uint32_t) (0x0F << (10 * ch)))
+#define RTC_ERCTRL_CHANNEL_CONFIG(ch, flag) ((uint32_t) (flag << (10 * ch)))
+
+/** Enable Event Monitor/Recorder and select its operating frequency.*/
+#define RTC_ERCTRL_MODE_MASK                (((uint32_t) 3) << 30)
+#define RTC_ERCTRL_MODE_CLK_DISABLE         (((uint32_t) 0) << 30)
+#define RTC_ERCTRL_MODE_16HZ                (((uint32_t) 1) << 30)
+#define RTC_ERCTRL_MODE_64HZ                (((uint32_t) 2) << 30)
+#define RTC_ERCTRL_MODE_1KHZ                (((uint32_t) 3) << 30)
+#define RTC_ERCTRL_MODE(n)                  (((uint32_t) n) << 30)
+
+/*
+ * @brief Event Monitor/Recorder Status register
+ */
+/** Event Flag for a specific channel */
+#define RTC_ERSTATUS_CHANNEL_EV(ch)               ((uint32_t) (1 << ch))       /* At least 1 event has occurred on a specific channel */
+/** General purpose registers have been asynchronous cleared. */
+#define RTC_ERSTATUS_GPCLEARED            ((uint32_t) (1 << 3))
+/** An interrupt/wakeup request is pending.*/
+#define RTC_ERSTATUS_WAKEUP            ((uint32_t) (((uint32_t) 1) << 31))
+
+/*
+ * @brief Event Monitor/Recorder Counter register
+ */
+/** Value of the counter for Events occurred on a specific channel */
+#define RTC_ER_COUNTER(ch, n)            ((uint32_t) ((n >> (8 * ch)) & 0x07))
+
+/*
+ * @brief Event Monitor/Recorder TimeStamp register
+ */
+#define RTC_ER_TIMESTAMP_SEC(n)             ((uint32_t) (n & 0x3F))
+#define RTC_ER_TIMESTAMP_MIN(n)             ((uint32_t) ((n >> 6) & 0x3F))
+#define RTC_ER_TIMESTAMP_HOUR(n)            ((uint32_t) ((n >> 12) & 0x1F))
+#define RTC_ER_TIMESTAMP_DOY(n)             ((uint32_t) ((n >> 17) & 0x1FF))
+
+/**
+ * @brief Event Monitor/Recorder Mode definition
+ */
+typedef enum IP_RTC_EV_MODE {
+   RTC_EV_MODE_DISABLE = 0,        /*!< Event Monitor/Recoder is disabled */
+   RTC_EV_MODE_ENABLE_16HZ =  1,   /*!< Event Monitor/Recoder is enabled and use 16Hz sample clock for event input */
+   RTC_EV_MODE_ENABLE_64HZ = 2,    /*!< Event Monitor/Recoder is enabled and use 64Hz sample clock for event input */
+   RTC_EV_MODE_ENABLE_1KHZ = 3,    /*!< Event Monitor/Recoder is enabled and use 1kHz sample clock for event input */
+   RTC_EV_MODE_LAST,
+} RTC_EV_MODE_T;
+
+/**
+ * @brief Event Monitor/Recorder Timestamp structure
+ */
+typedef struct {
+   uint8_t     sec;        /*!<   Second */
+   uint8_t     min;        /*!<   Minute */
+   uint8_t     hour;       /*!<   Hour */
+   uint16_t    dayofyear;  /*!<   Day of year */
+} RTC_EV_TIMESTAMP_T;
+
+#endif /*RTC_EV_SUPPORT*/
+
+/**
+ * @brief RTC enumeration
+ */
+
+/** @brief RTC interrupt source */
+typedef enum {
+   RTC_INT_COUNTER_INCREASE = RTC_IRL_RTCCIF,  /*!<  Counter Increment Interrupt */
+   RTC_INT_ALARM = RTC_IRL_RTCALF              /*!< The alarm interrupt */
+} RTC_INT_OPT_T;
+
+typedef struct {
+   uint32_t time[RTC_TIMETYPE_LAST];
+} RTC_TIME_T;
+
+/**
+ * @brief  Reset clock tick counter in the RTC peripheral
+ * @param  pRTC    : RTC peripheral selected
+ * @return None
+ */
+void Chip_RTC_ResetClockTickCounter(LPC_RTC_T *pRTC);
+
+/**
+ * @brief  Start/Stop RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  NewState    : New State of this function, should be:
+ *                         - ENABLE    :The time counters are enabled
+ *                         - DISABLE   :The time counters are disabled
+ * @return None
+ */
+void Chip_RTC_Enable(LPC_RTC_T *pRTC, FunctionalState NewState);
+
+/**
+ * @brief  Enable/Disable Counter increment interrupt for a time type in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  cntrMask    : Or'ed bit values for time types (RTC_AMR_CIIR_IM*)
+ * @param  NewState    : ENABLE or DISABLE
+ * @return None
+ */
+void Chip_RTC_CntIncrIntConfig(LPC_RTC_T *pRTC, uint32_t cntrMask, FunctionalState NewState);
+
+/**
+ * @brief  Enable/Disable Alarm interrupt for a time type in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  alarmMask   : Or'ed bit values for ALARM types (RTC_AMR_CIIR_IM*)
+ * @param  NewState    : ENABLE or DISABLE
+ * @return None
+ */
+void Chip_RTC_AlarmIntConfig(LPC_RTC_T *pRTC, uint32_t alarmMask, FunctionalState NewState);
+
+/**
+ * @brief  Set current time value for a time type in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  Timetype    : time field index type to set
+ * @param  TimeValue   : Value to palce in time field
+ * @return None
+ */
+STATIC INLINE void Chip_RTC_SetTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype, uint32_t TimeValue)
+{
+   pRTC->TIME[Timetype] = TimeValue;
+}
+
+/**
+ * @brief  Get current time value for a type time type
+ * @param  pRTC        : RTC peripheral selected
+ * @param  Timetype    : Time field index type to get
+ * @return Value of time field according to specified time type
+ */
+STATIC INLINE uint32_t Chip_RTC_GetTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype)
+{
+   return pRTC->TIME[Timetype];
+}
+
+/**
+ * @brief  Set full time in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  pFullTime   : Pointer to full time data
+ * @return None
+ */
+void Chip_RTC_SetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief  Get full time from the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  pFullTime   : Pointer to full time record to fill
+ * @return None
+ */
+void Chip_RTC_GetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief  Set alarm time value for a time type
+ * @param  pRTC        : RTC peripheral selected
+ * @param  Timetype    : Time index field to set
+ * @param  ALValue     : Alarm time value to set
+ * @return None
+ */
+STATIC INLINE void Chip_RTC_SetAlarmTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype, uint32_t ALValue)
+{
+   pRTC->ALRM[Timetype] = ALValue;
+}
+
+/**
+ * @brief  Get alarm time value for a time type
+ * @param  pRTC        : RTC peripheral selected
+ * @param  Timetype    : Time index field to get
+ * @return Value of Alarm time according to specified time type
+ */
+STATIC INLINE uint32_t Chip_RTC_GetAlarmTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype)
+{
+   return pRTC->ALRM[Timetype];
+}
+
+/**
+ * @brief  Set full alarm time in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  pFullTime   : Pointer to full time record to set alarm
+ * @return None
+ */
+void Chip_RTC_SetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief  Get full alarm time in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  pFullTime   : Pointer to full time record to fill
+ * @return None
+ */
+void Chip_RTC_GetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief  Write value to General purpose registers
+ * @param  pRegFile    : RegFile peripheral selected
+ * @param  index       : General purpose register index
+ * @param  value       : Value to write
+ * @return None
+ * @note   These General purpose registers can be used to store important
+ * information when the main power supply is off. The value in these
+ * registers is not affected by chip reset. These registers are
+ * powered in the RTC power domain.
+ */
+STATIC INLINE void Chip_REGFILE_Write(LPC_REGFILE_T *pRegFile, uint8_t index, uint32_t value)
+{
+   pRegFile->REGFILE[index] = value;
+}
+
+/**
+ * @brief  Read value from General purpose registers
+ * @param  pRegFile    : RegFile peripheral selected
+ * @param  index       : General purpose register index
+ * @return Read Value
+ * @note   These General purpose registers can be used to store important
+ * information when the main power supply is off. The value in these
+ * registers is not affected by chip reset. These registers are
+ * powered in the RTC power domain.
+ */
+STATIC INLINE uint32_t Chip_REGFILE_Read(LPC_REGFILE_T *pRegFile, uint8_t index)
+{
+   return pRegFile->REGFILE[index];
+}
+
+/**
+ * @brief  Enable/Disable calibration counter in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  NewState    : New State of this function, should be:
+ *                         - ENABLE    :The calibration counter is enabled and counting
+ *                         - DISABLE   :The calibration counter is disabled and reset to zero
+ * @return None
+ */
+void Chip_RTC_CalibCounterCmd(LPC_RTC_T *pRTC, FunctionalState NewState);
+
+/**
+ * @brief  Configures Calibration in the RTC peripheral
+ * @param  pRTC        : RTC peripheral selected
+ * @param  CalibValue  : Calibration value, should be in range from 0 to 131,072
+ * @param  CalibDir    : Calibration Direction, should be:
+ *                         - RTC_CALIB_DIR_FORWARD     :Forward calibration
+ *                         - RTC_CALIB_DIR_BACKWARD    :Backward calibration
+ * @return None
+ */
+STATIC INLINE void Chip_RTC_CalibConfig(LPC_RTC_T *pRTC, uint32_t CalibValue, uint8_t CalibDir)
+{
+   pRTC->CALIBRATION = ((CalibValue - 1) & RTC_CALIBRATION_CALVAL_MASK)
+                       | ((CalibDir == RTC_CALIB_DIR_BACKWARD) ? RTC_CALIBRATION_LIBDIR : 0);
+}
+
+/**
+ * @brief  Clear specified Location interrupt pending in the RTC peripheral
+ * @param  pRTC    : RTC peripheral selected
+ * @param  IntType : Interrupt location type, should be:
+ *                     - RTC_INT_COUNTER_INCREASE  :Clear Counter Increment Interrupt pending.
+ *                     - RTC_INT_ALARM             :Clear alarm interrupt pending
+ * @return None
+ */
+STATIC INLINE void Chip_RTC_ClearIntPending(LPC_RTC_T *pRTC, uint32_t IntType)
+{
+   pRTC->ILR = IntType;
+}
+
+/**
+ * @brief  Check whether if specified location interrupt in the RTC peripheral is set or not
+ * @param  pRTC    : RTC peripheral selected
+ * @param  IntType : Interrupt location type, should be:
+ *                     - RTC_INT_COUNTER_INCREASE: Counter Increment Interrupt block generated an interrupt.
+ *                     - RTC_INT_ALARM: Alarm generated an interrupt.
+ * @return New state of specified Location interrupt in RTC peripheral, SET OR RESET
+ */
+STATIC INLINE IntStatus Chip_RTC_GetIntPending(LPC_RTC_T *pRTC, uint32_t IntType)
+{
+   return (pRTC->ILR & IntType) ? SET : RESET;
+}
+
+#if RTC_EV_SUPPORT
+
+/**
+ * @brief  Configure a specific event channel
+ * @param  pRTC    : RTC peripheral selected
+ * @param  ch      : Channel number
+ * @param  flag    : Configuration flag
+ * @return None
+ * @note   flag is or-ed bit value of RTC_ERCTRL_INTWAKE_EN,RTC_ERCTRL_GPCLEAR_EN,
+ *       RTC_ERCTRL_POL_POSITIVE and RTC_ERCTRL_INPUT_EN.
+ */
+STATIC INLINE void Chip_RTC_EV_Config(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, uint32_t flag)
+{
+   uint32_t temp;
+
+   temp = pRTC->ERCONTROL & (~(RTC_ERCTRL_CHANNEL_CONFIG_BITMASK(ch))) & RTC_ERCTRL_BITMASK;
+   pRTC->ERCONTROL = temp | (RTC_ERCTRL_CHANNEL_CONFIG(ch, flag) & RTC_ERCTRL_BITMASK);
+}
+
+/**
+ * @brief  Enable/Disable and select clock frequency for Event Monitor/Recorder
+ * @param  pRTC    : RTC peripheral selected
+ * @param  mode    : selected mode
+ * @return None
+ */
+STATIC INLINE void Chip_RTC_EV_SetMode(LPC_RTC_T *pRTC, RTC_EV_MODE_T mode)
+{
+   uint32_t temp;
+
+   temp = pRTC->ERCONTROL & (~RTC_ERCTRL_MODE_MASK) & RTC_ERCTRL_BITMASK;
+   pRTC->ERCONTROL = temp | RTC_ERCTRL_MODE(mode);
+}
+
+/**
+ * @brief  Get Event Monitor/Recorder Status
+ * @param  pRTC    : RTC peripheral selected
+ * @return Or-ed bit value of RTC_ERSTATUS_GPCLEARED and RTC_ERSTATUS_WAKEUP
+ */
+STATIC INLINE uint8_t Chip_RTC_EV_GetStatus(LPC_RTC_T *pRTC)
+{
+   return pRTC->ERSTATUS & (RTC_ERSTATUS_GPCLEARED | RTC_ERSTATUS_WAKEUP);
+}
+
+/**
+ * @brief  Clear Event Monitor/Recorder Status
+ * @param  pRTC    : RTC peripheral selected
+ * @param  flag    : Or-ed bit value of RTC_ERSTATUS_GPCLEARED and RTC_ERSTATUS_WAKEUP
+ * @return Nothing
+ */
+STATIC INLINE void Chip_RTC_EV_ClearStatus(LPC_RTC_T *pRTC, uint32_t flag)
+{
+   pRTC->ERSTATUS = flag & (RTC_ERSTATUS_GPCLEARED | RTC_ERSTATUS_WAKEUP);
+}
+
+/**
+ * @brief  Get status of a specific event channel
+ * @param  pRTC    : RTC peripheral selected
+ * @param  ch      : Channel number
+ * @return SET (At least 1 event occurred on the channel), RESET: no event occured.
+ */
+STATIC INLINE FlagStatus Chip_RTC_EV_GetChannelStatus(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch)
+{
+   return (pRTC->ERSTATUS & RTC_ERSTATUS_CHANNEL_EV(ch)) ? SET : RESET;
+}
+
+/**
+ * @brief  Clear status of a specific event channel
+ * @param  pRTC    : RTC peripheral selected
+ * @param  ch      : Channel number
+ * @return Nothing.
+ */
+STATIC INLINE void Chip_RTC_EV_ClearChannelStatus(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch)
+{
+   pRTC->ERSTATUS = RTC_ERSTATUS_CHANNEL_EV(ch);
+}
+
+/**
+ * @brief  Get counter value of a specific event channel
+ * @param  pRTC    : RTC peripheral selected
+ * @param  ch      : Channel number
+ * @return counter value
+ */
+STATIC INLINE uint8_t Chip_RTC_EV_GetCounter(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch)
+{
+   return RTC_ER_COUNTER(ch, pRTC->ERCOUNTERS);
+}
+
+/**
+ * @brief  Get first time stamp of a specific event channel
+ * @param  pRTC        : RTC peripheral selected
+ * @param  ch          : Channel number
+ * @param  pTimeStamp  : pointer to Timestamp buffer
+ * @return Nothing.
+ */
+void Chip_RTC_EV_GetFirstTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp);
+
+/**
+ * @brief  Get last time stamp of a specific event channel
+ * @param  pRTC        : RTC peripheral selected
+ * @param  ch          : Channel number
+ * @param  pTimeStamp  : pointer to Timestamp buffer
+ * @return Nothing.
+ */
+void Chip_RTC_EV_GetLastTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp);
+
+#endif /*RTC_EV_SUPPORT*/
+
+/**
+ * @brief  Initialize the RTC peripheral
+ * @param  pRTC    : RTC peripheral selected
+ * @return None
+ */
+void Chip_RTC_Init(LPC_RTC_T *pRTC);
+
+/**
+ * @brief  De-initialize the RTC peripheral
+ * @param  pRTC    : RTC peripheral selected
+ * @return None
+ */
+void Chip_RTC_DeInit(LPC_RTC_T *pRTC);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RTC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sct_18xx_43xx.h ./lpc_chip_43xx/inc/sct_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/sct_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sct_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,423 @@
+/*
+ * @brief LPC18xx/43xx State Configurable Timer (SCT) driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCT_18XX_43XX_H_
+#define __SCT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCT_18XX_43XX CHIP: LPC18xx/43xx State Configurable Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/*
+ * @brief SCT Module configuration
+ */
+#define CONFIG_SCT_nEV   (16)          /*!< Number of events */
+#define CONFIG_SCT_nRG   (16)          /*!< Number of match/compare registers */
+#define CONFIG_SCT_nOU   (16)          /*!< Number of outputs */
+
+/**
+ * @brief State Configurable Timer register block structure
+ */
+typedef struct {
+   __IO  uint32_t CONFIG;              /*!< Configuration Register */
+   union {
+       __IO uint32_t CTRL_U;           /*!< Control Register */
+       struct {
+           __IO uint16_t CTRL_L;       /*!< Low control register */
+           __IO uint16_t CTRL_H;       /*!< High control register */
+       };
+
+   };
+
+   __IO uint16_t LIMIT_L;              /*!< limit register for counter L */
+   __IO uint16_t LIMIT_H;              /*!< limit register for counter H */
+   __IO uint16_t HALT_L;               /*!< halt register for counter L */
+   __IO uint16_t HALT_H;               /*!< halt register for counter H */
+   __IO uint16_t STOP_L;               /*!< stop register for counter L */
+   __IO uint16_t STOP_H;               /*!< stop register for counter H */
+   __IO uint16_t START_L;              /*!< start register for counter L */
+   __IO uint16_t START_H;              /*!< start register for counter H */
+   uint32_t RESERVED1[10];             /*!< 0x03C reserved */
+   union {
+       __IO uint32_t COUNT_U;          /*!< counter register */
+       struct {
+           __IO uint16_t COUNT_L;      /*!< counter register for counter L */
+           __IO uint16_t COUNT_H;      /*!< counter register for counter H */
+       };
+
+   };
+
+   __IO uint16_t STATE_L;              /*!< state register for counter L */
+   __IO uint16_t STATE_H;              /*!< state register for counter H */
+   __I  uint32_t INPUT;                /*!< input register */
+   __IO uint16_t REGMODE_L;            /*!< match - capture registers mode register L */
+   __IO uint16_t REGMODE_H;            /*!< match - capture registers mode register H */
+   __IO uint32_t OUTPUT;               /*!< output register */
+   __IO uint32_t OUTPUTDIRCTRL;        /*!< output counter direction Control Register */
+   __IO uint32_t RES;                  /*!< conflict resolution register */
+   __IO uint32_t DMA0REQUEST;          /*!< DMA0 Request Register */
+   __IO uint32_t DMA1REQUEST;          /*!< DMA1 Request Register */
+   uint32_t RESERVED2[35];
+   __IO uint32_t EVEN;                 /*!< event enable register */
+   __IO uint32_t EVFLAG;               /*!< event flag register */
+   __IO uint32_t CONEN;                /*!< conflict enable register */
+   __IO uint32_t CONFLAG;              /*!< conflict flag register */
+   union {
+       __IO union {                    /*!< ... Match / Capture value */
+           uint32_t U;                 /*!<       SCTMATCH[i].U  Unified 32-bit register */
+           struct {
+               uint16_t L;             /*!<       SCTMATCH[i].L  Access to L value */
+               uint16_t H;             /*!<       SCTMATCH[i].H  Access to H value */
+           };
+
+       } MATCH[CONFIG_SCT_nRG];
+
+       __I union {
+           uint32_t U;                 /*!<       SCTCAP[i].U  Unified 32-bit register */
+           struct {
+               uint16_t L;             /*!<       SCTCAP[i].L  Access to L value */
+               uint16_t H;             /*!<       SCTCAP[i].H  Access to H value */
+           };
+
+       } CAP[CONFIG_SCT_nRG];
+
+   };
+
+   uint32_t RESERVED3[32 - CONFIG_SCT_nRG];        /*!< ...-0x17C reserved */
+   union {
+       __IO uint16_t MATCH_L[CONFIG_SCT_nRG];      /*!< 0x180-... Match Value L counter */
+       __I  uint16_t CAP_L[CONFIG_SCT_nRG];        /*!< 0x180-... Capture Value L counter */
+   };
+
+   uint16_t RESERVED4[32 - CONFIG_SCT_nRG];        /*!< ...-0x1BE reserved */
+   union {
+       __IO uint16_t MATCH_H[CONFIG_SCT_nRG];      /*!< 0x1C0-... Match Value H counter */
+       __I  uint16_t CAP_H[CONFIG_SCT_nRG];        /*!< 0x1C0-... Capture Value H counter */
+   };
+
+   uint16_t RESERVED5[32 - CONFIG_SCT_nRG];        /*!< ...-0x1FE reserved */
+   union {
+       __IO union {                    /*!< 0x200-... Match Reload / Capture Control value */
+           uint32_t U;                 /*!<       SCTMATCHREL[i].U  Unified 32-bit register */
+           struct {
+               uint16_t L;             /*!<       SCTMATCHREL[i].L  Access to L value */
+               uint16_t H;             /*!<       SCTMATCHREL[i].H  Access to H value */
+           };
+
+       } MATCHREL[CONFIG_SCT_nRG];
+
+       __IO union {
+           uint32_t U;                 /*!<       SCTCAPCTRL[i].U  Unified 32-bit register */
+           struct {
+               uint16_t L;             /*!<       SCTCAPCTRL[i].L  Access to L value */
+               uint16_t H;             /*!<       SCTCAPCTRL[i].H  Access to H value */
+           };
+
+       } CAPCTRL[CONFIG_SCT_nRG];
+
+   };
+
+   uint32_t RESERVED6[32 - CONFIG_SCT_nRG];        /*!< ...-0x27C reserved */
+   union {
+       __IO uint16_t MATCHREL_L[CONFIG_SCT_nRG];   /*!< 0x280-... Match Reload value L counter */
+       __IO uint16_t CAPCTRL_L[CONFIG_SCT_nRG];    /*!< 0x280-... Capture Control value L counter */
+   };
+
+   uint16_t RESERVED7[32 - CONFIG_SCT_nRG];        /*!< ...-0x2BE reserved */
+   union {
+       __IO uint16_t MATCHREL_H[CONFIG_SCT_nRG];   /*!< 0x2C0-... Match Reload value H counter */
+       __IO uint16_t CAPCTRL_H[CONFIG_SCT_nRG];    /*!< 0x2C0-... Capture Control value H counter */
+   };
+
+   uint16_t RESERVED8[32 - CONFIG_SCT_nRG];        /*!< ...-0x2FE reserved */
+   __IO struct {                       /*!< 0x300-0x3FC  SCTEVENT[i].STATE / SCTEVENT[i].CTRL*/
+       uint32_t STATE;                 /*!< Event State Register */
+       uint32_t CTRL;                  /*!< Event Control Register */
+   } EVENT[CONFIG_SCT_nEV];
+
+   uint32_t RESERVED9[128 - 2 * CONFIG_SCT_nEV];   /*!< ...-0x4FC reserved */
+   __IO struct {                       /*!< 0x500-0x57C  SCTOUT[i].SET / SCTOUT[i].CLR */
+       uint32_t SET;                   /*!< Output n Set Register */
+       uint32_t CLR;                   /*!< Output n Clear Register */
+   } OUT[CONFIG_SCT_nOU];
+
+   uint32_t RESERVED10[191 - 2 * CONFIG_SCT_nOU];  /*!< ...-0x7F8 reserved */
+   __I  uint32_t MODULECONTENT;        /*!< 0x7FC Module Content */
+} LPC_SCT_T;
+
+/*
+ * @brief Macro defines for SCT configuration register
+ */
+#define SCT_CONFIG_16BIT_COUNTER        0x00000000 /*!< Operate as 2 16-bit counters */
+#define SCT_CONFIG_32BIT_COUNTER        0x00000001 /*!< Operate as 1 32-bit counter */
+
+#define SCT_CONFIG_CLKMODE_BUSCLK       (0x0 << 1) /*!< Bus clock */
+#define SCT_CONFIG_CLKMODE_SCTCLK       (0x1 << 1) /*!< SCT clock */
+#define SCT_CONFIG_CLKMODE_INCLK        (0x2 << 1) /*!< Input clock selected in CLKSEL field */
+#define SCT_CONFIG_CLKMODE_INEDGECLK    (0x3 << 1) /*!< Input clock edge selected in CLKSEL field */
+
+#define SCT_CONFIG_NORELOADL_U          (0x1 << 7) /*!< Operate as 1 32-bit counter */
+#define SCT_CONFIG_NORELOADH            (0x1 << 8) /*!< Operate as 1 32-bit counter */
+#define SCT_CONFIG_AUTOLIMIT_L          (0x1 << 17) /*!< Limits counter(L) based on MATCH0 */
+#define SCT_CONFIG_AUTOLIMIT_H          (0x1 << 18) /*!< Limits counter(L) based on MATCH0 */
+
+/*
+ * @brief Macro defines for SCT control register
+ */
+#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0          /*!< Direction for low or unified counter */
+#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
+
+#define SCT_CTRL_STOP_L                 (1 << 1)               /*!< Stop low counter */
+#define SCT_CTRL_HALT_L                 (1 << 2)               /*!< Halt low counter */
+#define SCT_CTRL_CLRCTR_L               (1 << 3)               /*!< Clear low or unified counter */
+#define SCT_CTRL_BIDIR_L(x)             (((x) & 0x01) << 4)        /*!< Bidirectional bit */
+#define SCT_CTRL_PRE_L(x)               (((x) & 0xFF) << 5)        /*!< Prescale clock for low or unified counter */
+
+#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0          /*!< Direction for high counter */
+#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
+#define SCT_CTRL_STOP_H                 (1 << 17)              /*!< Stop high counter */
+#define SCT_CTRL_HALT_H                 (1 << 18)              /*!< Halt high counter */
+#define SCT_CTRL_CLRCTR_H               (1 << 19)              /*!< Clear high counter */
+#define SCT_CTRL_BIDIR_H(x)             (((x) & 0x01) << 20)
+#define SCT_CTRL_PRE_H(x)               (((x) & 0xFF) << 21)   /*!< Prescale clock for high counter */
+
+/*
+ * @brief Macro defines for SCT Conflict resolution register
+ */
+#define SCT_RES_NOCHANGE                (0)
+#define SCT_RES_SET_OUTPUT              (1)
+#define SCT_RES_CLEAR_OUTPUT            (2)
+#define SCT_RES_TOGGLE_OUTPUT           (3)
+
+/**
+ * SCT Match register values enum
+ */
+typedef enum CHIP_SCT_MATCH_REG {
+   SCT_MATCH_0 = 0,    /*!< SCT Match register 0 */
+   SCT_MATCH_1 = 1,    /*!< SCT Match register 1 */
+   SCT_MATCH_2 = 2,    /*!< SCT Match register 2 */
+   SCT_MATCH_3 = 3,    /*!< SCT Match register 3 */
+   SCT_MATCH_4 = 4     /*!< SCT Match register 4 */
+} CHIP_SCT_MATCH_REG_T;
+
+/**
+ * SCT Event values enum
+ */
+typedef enum CHIP_SCT_EVENT {
+   SCT_EVT_0  = (1 << 0),  /*!< Event 0 */
+   SCT_EVT_1  = (1 << 1),  /*!< Event 1 */
+   SCT_EVT_2  = (1 << 2),  /*!< Event 2 */
+   SCT_EVT_3  = (1 << 3),  /*!< Event 3 */
+   SCT_EVT_4  = (1 << 4)   /*!< Event 4 */
+} CHIP_SCT_EVENT_T;
+
+/**
+ * @brief  Configures the State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  value   : The 32-bit CONFIG register value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t value)
+{
+   pSCT->CONFIG = value;
+}
+
+/**
+ * @brief  Set or Clear the Control register
+ * @param  pSCT            : Pointer to SCT register block
+ * @param  value           : SCT Control register value
+ * @param  ena             : ENABLE - To set the fields specified by value
+ *                          : DISABLE - To clear the field specified by value
+ * @return Nothing
+ * Set or clear the control register bits as specified by the \a value
+ * parameter. If \a ena is set to ENABLE, the mentioned register fields
+ * will be set. If \a ena is set to DISABLE, the mentioned register
+ * fields will be cleared
+ */
+void Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena);
+
+/**
+ * @brief  Set the conflict resolution
+ * @param  pSCT            : Pointer to SCT register block
+ * @param  outnum          : Output number
+ * @param  value           : Output value
+ *                          - SCT_RES_NOCHANGE     :No change
+ *                         - SCT_RES_SET_OUTPUT    :Set output
+ *                         - SCT_RES_CLEAR_OUTPUT  :Clear output
+ *                         - SCT_RES_TOGGLE_OUTPUT :Toggle output
+ *                          : SCT_RES_NOCHANGE
+ *                          : DISABLE - To clear the field specified by value
+ * @return Nothing
+ * Set conflict resolution for the output \a outnum
+ */
+void Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value);
+
+/**
+ * @brief  Set unified count value in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  count   : The 32-bit count value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count)
+{
+   pSCT->COUNT_U = count;
+}
+
+/**
+ * @brief  Set lower count value in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  count   : The 16-bit count value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count)
+{
+   pSCT->COUNT_L = count;
+}
+
+/**
+ * @brief  Set higher count value in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  count   : The 16-bit count value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count)
+{
+   pSCT->COUNT_H = count;
+}
+
+/**
+ * @brief  Set unified match count value in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  n       : Match register value
+ * @param  value   : The 32-bit match count value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
+{
+   pSCT->MATCH[n].U = value;
+}
+
+/**
+ * @brief  Set control register in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  value   : Value (ORed value of SCT_CTRL_* bits)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value)
+{
+   pSCT->CTRL_U |= value;
+}
+
+/**
+ * @brief  Clear control register in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  value   : Value (ORed value of SCT_CTRL_* bits)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value)
+{
+   pSCT->CTRL_U &= ~(value);
+}
+
+/**
+ * @brief  Set unified match reload count value in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  n       : Match register value
+ * @param  value   : The 32-bit match count reload value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
+{
+   pSCT->MATCHREL[n].U = value;
+}
+
+/**
+ * @brief  Enable the interrupt for the specified event in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  evt     : Event value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
+{
+   pSCT->EVEN |= evt;
+}
+
+/**
+ * @brief  Disable the interrupt for the specified event in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  evt     : Event value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
+{
+   pSCT->EVEN &= ~(evt);
+}
+
+/**
+ * @brief  Clear the specified event flag in State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  evt     : Event value
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
+{
+   pSCT->EVFLAG |= evt;
+}
+
+/**
+ * @brief  Initializes the State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @return Nothing
+ */
+void Chip_SCT_Init(LPC_SCT_T *pSCT);
+
+/**
+ * @brief  Deinitializes the State Configurable Timer
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @return Nothing
+ */
+void Chip_SCT_DeInit(LPC_SCT_T *pSCT);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#endif /* __SCT_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h ./lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,178 @@
+/*
+ * @brief LPC18xx_43xx State Configurable Timer (SCT/PWM) Chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCT_PWM_18XX_43XX_H_
+#define __SCT_PWM_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCT_PWM_18XX_43XX CHIP: LPC18XX_43XX State Configurable Timer PWM driver
+ *
+ * For more information on how to use the driver please visit the FAQ page at
+ * <a href="http://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen">
+ * www.lpcware.com</a>
+ *
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief  Get number of ticks per PWM cycle
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @return Number ot ticks that will be counted per cycle
+ * @note   Return value of this function will be vaild only
+ *          after calling Chip_SCTPWM_SetRate()
+ */
+STATIC INLINE uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
+{
+   return pSCT->MATCHREL[0].U;
+}
+
+/**
+ * @brief  Converts a percentage to ticks
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  percent : Percentage to convert (0 - 100)
+ * @return Number ot ticks corresponding to given percentage
+ * @note   Do not use this function when using very low
+ *          pwm rate (like 100Hz or less), on a chip that has
+ *          very high frequency as the calculation might
+ *          cause integer overflow
+ */
+STATIC INLINE uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
+{
+   return (Chip_SCTPWM_GetTicksPerCycle(pSCT) * percent) / 100;
+}
+
+/**
+ * @brief  Get number of ticks on per PWM cycle
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  index   : Index of the PWM 1 to N (see notes)
+ * @return Number ot ticks for which the output will be ON per cycle
+ * @note   @a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum.
+ */
+STATIC INLINE uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
+{
+   return pSCT->MATCHREL[index].U;
+}
+
+/**
+ * @brief  Get number of ticks on per PWM cycle
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  index   : Index of the PWM 1 to N (see notes)
+ * @param  ticks   : Number of ticks the output should say ON
+ * @return None
+ * @note   @a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum. The new duty cycle will be effective only
+ *          after completion of current PWM cycle.
+ */
+STATIC INLINE void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
+{
+   Chip_SCT_SetMatchReload(pSCT, (CHIP_SCT_MATCH_REG_T)index, ticks);
+}
+
+/**
+ * @brief  Initialize the SCT/PWM clock and reset
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
+{
+   Chip_SCT_Init(pSCT);
+}
+
+/**
+ * @brief  Start the SCT PWM
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @return None
+ * @note   This function must be called after all the
+ *             configuration is completed. Do not call Chip_SCTPWM_SetRate()
+ *             or Chip_SCTPWM_SetOutPin() after the SCT/PWM is started. Use
+ *             Chip_SCTPWM_Stop() to stop the SCT/PWM before reconfiguring,
+ *             Chip_SCTPWM_SetDutyCycle() can be called when the SCT/PWM is
+ *             running to change the DutyCycle.
+ */
+STATIC INLINE void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
+{
+   Chip_SCT_ClearControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
+}
+
+/**
+ * @brief  Stop the SCT PWM
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
+{
+   /* Stop SCT */
+   Chip_SCT_SetControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
+
+   /* Clear the counter */
+   Chip_SCT_SetControl(pSCT, SCT_CTRL_CLRCTR_L | SCT_CTRL_CLRCTR_H);
+}
+
+/**
+ * @brief  Sets the frequency of the generated PWM wave
+ * @param  pSCT    : The base of SCT peripheral on the chip
+ * @param  freq    : Frequency in Hz
+ * @return None
+ */
+void Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq);
+
+/**
+ * @brief  Setup the OUTPUT pin and associate it with an index
+ * @param  pSCT    : The base of the SCT peripheral on the chip
+ * @param  index   : Index of PWM 1 to N (see notes)
+ * @param  pin     : COUT pin to be associated with the index
+ * @return None
+ * @note   @a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum.
+ */
+void Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#endif /* __SCT_PWM_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/scu_18xx_43xx.h ./lpc_chip_43xx/inc/scu_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/scu_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/scu_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,247 @@
+/*
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCU_18XX_43XX_H_
+#define __SCU_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCU_18XX_43XX CHIP: LPC18xx/43xx SCU Driver (configures pin functions)
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+
+/**
+ * @brief Array of pin definitions passed to Chip_SCU_SetPinMuxing() must be in this format
+ */
+typedef struct {
+   uint8_t pingrp;     /* Pin group */
+   uint8_t pinnum;     /* Pin number */
+   uint16_t modefunc;  /* Pin mode and function for SCU */
+} PINMUX_GRP_T;
+
+/**
+ * @brief System Control Unit register block
+ */
+typedef struct {
+   __IO uint32_t  SFSP[16][32];
+   __I  uint32_t  RESERVED0[256];
+   __IO uint32_t  SFSCLK[4];           /*!< Pin configuration register for pins CLK0-3 */
+   __I  uint32_t  RESERVED16[28];
+   __IO uint32_t  SFSUSB;              /*!< Pin configuration register for USB */
+   __IO uint32_t  SFSI2C0;             /*!< Pin configuration register for I2C0-bus pins */
+   __IO uint32_t  ENAIO[3];            /*!< Analog function select registerS */
+   __I  uint32_t  RESERVED17[27];
+   __IO uint32_t  EMCDELAYCLK;         /*!< EMC clock delay register */
+   __I  uint32_t  RESERVED18[63];
+   __IO uint32_t  PINTSEL[2];          /*!< Pin interrupt select register for pin int 0 to 3 index 0, 4 to 7 index 1. */
+} LPC_SCU_T;
+
+/**
+ * SCU function and mode selection definitions
+ * See the User Manual for specific modes and functions supoprted by the
+ * various LPC18xx/43xx devices. Functionality can vary per device.
+ */
+#define SCU_MODE_PULLUP            (0x0 << 3)      /*!< Enable pull-up resistor at pad */
+#define SCU_MODE_REPEATER          (0x1 << 3)      /*!< Enable pull-down and pull-up resistor at resistor at pad (repeater mode) */
+#define SCU_MODE_INACT             (0x2 << 3)      /*!< Disable pull-down and pull-up resistor at resistor at pad */
+#define SCU_MODE_PULLDOWN          (0x3 << 3)      /*!< Enable pull-down resistor at pad */
+#define SCU_MODE_HIGHSPEEDSLEW_EN  (0x1 << 5)      /*!< Enable high-speed slew */
+#define SCU_MODE_INBUFF_EN         (0x1 << 6)      /*!< Enable Input buffer */
+#define SCU_MODE_ZIF_DIS           (0x1 << 7)      /*!< Disable input glitch filter */
+#define SCU_MODE_4MA_DRIVESTR      (0x0 << 8)      /*!< Normal drive: 4mA drive strength */
+#define SCU_MODE_8MA_DRIVESTR      (0x1 << 8)      /*!< Medium drive: 8mA drive strength */
+#define SCU_MODE_14MA_DRIVESTR     (0x2 << 8)      /*!< High drive: 14mA drive strength */
+#define SCU_MODE_20MA_DRIVESTR     (0x3 << 8)      /*!< Ultra high- drive: 20mA drive strength */
+#define SCU_MODE_FUNC0             0x0             /*!< Selects pin function 0 */
+#define SCU_MODE_FUNC1             0x1             /*!< Selects pin function 1 */
+#define SCU_MODE_FUNC2             0x2             /*!< Selects pin function 2 */
+#define SCU_MODE_FUNC3             0x3             /*!< Selects pin function 3 */
+#define SCU_MODE_FUNC4             0x4             /*!< Selects pin function 4 */
+#define SCU_MODE_FUNC5             0x5             /*!< Selects pin function 5 */
+#define SCU_MODE_FUNC6             0x6             /*!< Selects pin function 6 */
+#define SCU_MODE_FUNC7             0x7             /*!< Selects pin function 7 */
+#define SCU_PINIO_FAST             (SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS)
+
+/**
+ * SCU function and mode selection definitions (old)
+ * For backwards compatibility.
+ */
+#define MD_PUP                     (0x0 << 3)      /** Enable pull-up resistor at pad */
+#define MD_BUK                     (0x1 << 3)      /** Enable pull-down and pull-up resistor at resistor at pad (repeater mode) */
+#define MD_PLN                     (0x2 << 3)      /** Disable pull-down and pull-up resistor at resistor at pad */
+#define MD_PDN                     (0x3 << 3)      /** Enable pull-down resistor at pad */
+#define MD_EHS                     (0x1 << 5)      /** Enable fast slew rate */
+#define MD_EZI                     (0x1 << 6)      /** Input buffer enable */
+#define MD_ZI                      (0x1 << 7)      /** Disable input glitch filter */
+#define MD_EHD0                        (0x1 << 8)      /** EHD driver strength low bit */
+#define MD_EHD1                        (0x1 << 8)      /** EHD driver strength high bit */
+#define MD_PLN_FAST                    (MD_PLN | MD_EZI | MD_ZI | MD_EHS)
+#define I2C0_STANDARD_FAST_MODE        (1 << 3 | 1 << 11)  /** Pin configuration for STANDARD/FAST mode I2C */
+#define I2C0_FAST_MODE_PLUS            (2 << 1 | 1 << 3 | 1 << 7 | 1 << 10 | 1 << 11)  /** Pin configuration for Fast-mode Plus I2C */
+#define FUNC0                      0x0             /** Pin function 0 */
+#define FUNC1                      0x1             /** Pin function 1 */
+#define FUNC2                      0x2             /** Pin function 2 */
+#define FUNC3                      0x3             /** Pin function 3 */
+#define FUNC4                      0x4             /** Pin function 4 */
+#define FUNC5                      0x5             /** Pin function 5 */
+#define FUNC6                      0x6             /** Pin function 6 */
+#define FUNC7                      0x7             /** Pin function 7 */
+
+#define PORT_OFFSET                    0x80            /** Port offset definition */
+#define PIN_OFFSET                 0x04            /** Pin offset definition */
+
+/** Returns the SFSP register address in the SCU for a pin and port, recommend using (*(volatile int *) &LPC_SCU->SFSP[po][pi];) */
+#define LPC_SCU_PIN(LPC_SCU_BASE, po, pi) (*(volatile int *) ((LPC_SCU_BASE) + ((po) * 0x80) + ((pi) * 0x4))
+
+/** Returns the address in the SCU for a SFSCLK clock register, recommend using (*(volatile int *) &LPC_SCU->SFSCLK[c];) */
+#define LPC_SCU_CLK(LPC_SCU_BASE, c) (*(volatile int *) ((LPC_SCU_BASE) +0xC00 + ((c) * 0x4)))
+
+/**
+ * @brief  Sets I/O Control pin mux
+ * @param  port        : Port number, should be: 0..15
+ * @param  pin         : Pin number, should be: 0..31
+ * @param  modefunc    : OR'ed values or type SCU_MODE_*
+ * @return Nothing
+ * @note   Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
+ * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
+ */
+STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
+{
+   LPC_SCU->SFSP[port][pin] = modefunc;
+}
+
+/**
+ * @brief  Configure pin function
+ * @param  port    : Port number, should be: 0..15
+ * @param  pin     : Pin number, should be: 0..31
+ * @param  mode    : OR'ed values or type SCU_MODE_*
+ * @param  func    : Pin function, value of type SCU_MODE_FUNC0 to SCU_MODE_FUNC7
+ * @return Nothing
+ * @note   Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
+ * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
+ */
+STATIC INLINE void Chip_SCU_PinMux(uint8_t port, uint8_t pin, uint16_t mode, uint8_t func)
+{
+   Chip_SCU_PinMuxSet(port, pin, (mode | (uint16_t) func));
+}
+
+/**
+ * @brief  Configure clock pin function (pins SFSCLKx)
+ * @param  clknum  : Clock pin number, should be: 0..3
+ * @param  modefunc    : OR'ed values or type SCU_MODE_*
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_ClockPinMuxSet(uint8_t clknum, uint16_t modefunc)
+{
+   LPC_SCU->SFSCLK[clknum] = (uint32_t) modefunc;
+}
+
+/**
+ * @brief  Configure clock pin function (pins SFSCLKx)
+ * @param  clknum  : Clock pin number, should be: 0..3
+ * @param  mode    : OR'ed values or type SCU_MODE_*
+ * @param  func    : Pin function, value of type SCU_MODE_FUNC0 to SCU_MODE_FUNC7
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_ClockPinMux(uint8_t clknum, uint16_t mode, uint8_t func)
+{
+   LPC_SCU->SFSCLK[clknum] = ((uint32_t) mode | (uint32_t) func);
+}
+
+/**
+ * @brief  GPIO Interrupt Pin Select
+ * @param  PortSel : GPIO PINTSEL interrupt, should be: 0 to 7
+ * @param  PortNum : GPIO port number interrupt, should be: 0 to 7
+ * @param  PinNum  : GPIO pin number Interrupt , should be: 0 to 31
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_GPIOIntPinSel(uint8_t PortSel, uint8_t PortNum, uint8_t PinNum)
+{
+   int32_t of = (PortSel & 3) << 3;
+   uint32_t val = (((PortNum & 0x7) << 5) | (PinNum & 0x1F)) << of;
+   LPC_SCU->PINTSEL[PortSel >> 2] = (LPC_SCU->PINTSEL[PortSel >> 2] & ~(0xFF << of)) | val;
+}
+
+/**
+ * @brief  I2C Pin Configuration
+ * @param  I2C0Mode    : I2C0 mode, should be:
+ *                  - I2C0_STANDARD_FAST_MODE: Standard/Fast mode transmit
+ *                  - I2C0_FAST_MODE_PLUS: Fast-mode Plus transmit
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_I2C0PinConfig(uint32_t I2C0Mode)
+{
+   LPC_SCU->SFSI2C0 = I2C0Mode;
+}
+
+/**
+ * @brief  ADC Pin Configuration
+ * @param  ADC_ID  : ADC number
+ * @param  channel : ADC channel
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_ADC_Channel_Config(uint32_t ADC_ID, uint8_t channel)
+{
+   LPC_SCU->ENAIO[ADC_ID] |= 1UL << channel;
+}
+
+/**
+ * @brief  DAC Pin Configuration
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_DAC_Analog_Config(void)
+{
+   /*Enable analog function DAC on pin P4_4*/
+   LPC_SCU->ENAIO[2] |= 1;
+}
+
+/**
+ * @brief  Set all I/O Control pin muxing
+ * @param  pinArray    : Pointer to array of pin mux selections
+ * @param  arrayLength : Number of entries in pinArray
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
+{
+   uint32_t ix;
+   for (ix = 0; ix < arrayLength; ix++ ) {
+       Chip_SCU_PinMuxSet(pinArray[ix].pingrp, pinArray[ix].pinnum, pinArray[ix].modefunc);
+   }
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SCU_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sdif_18xx_43xx.h ./lpc_chip_43xx/inc/sdif_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/sdif_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sdif_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,479 @@
+/*
+ * @brief LPC18xx/43xx SD/SDIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDIF_18XX_43XX_H_
+#define __SDIF_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SDIF_18XX_43XX CHIP: LPC18xx/43xx SD/SDIO driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief SD/MMC & SDIO register block structure
+ */
+typedef struct {               /*!< SDMMC Structure        */
+   __IO uint32_t  CTRL;        /*!< Control Register       */
+   __IO uint32_t  PWREN;       /*!< Power Enable Register  */
+   __IO uint32_t  CLKDIV;      /*!< Clock Divider Register */
+   __IO uint32_t  CLKSRC;      /*!< SD Clock Source Register */
+   __IO uint32_t  CLKENA;      /*!< Clock Enable Register  */
+   __IO uint32_t  TMOUT;       /*!< Timeout Register       */
+   __IO uint32_t  CTYPE;       /*!< Card Type Register     */
+   __IO uint32_t  BLKSIZ;      /*!< Block Size Register    */
+   __IO uint32_t  BYTCNT;      /*!< Byte Count Register    */
+   __IO uint32_t  INTMASK;     /*!< Interrupt Mask Register */
+   __IO uint32_t  CMDARG;      /*!< Command Argument Register */
+   __IO uint32_t  CMD;         /*!< Command Register       */
+   __I  uint32_t  RESP0;       /*!< Response Register 0    */
+   __I  uint32_t  RESP1;       /*!< Response Register 1    */
+   __I  uint32_t  RESP2;       /*!< Response Register 2    */
+   __I  uint32_t  RESP3;       /*!< Response Register 3    */
+   __I  uint32_t  MINTSTS;     /*!< Masked Interrupt Status Register */
+   __IO uint32_t  RINTSTS;     /*!< Raw Interrupt Status Register */
+   __I  uint32_t  STATUS;      /*!< Status Register        */
+   __IO uint32_t  FIFOTH;      /*!< FIFO Threshold Watermark Register */
+   __I  uint32_t  CDETECT;     /*!< Card Detect Register   */
+   __I  uint32_t  WRTPRT;      /*!< Write Protect Register */
+   __IO uint32_t  GPIO;        /*!< General Purpose Input/Output Register */
+   __I  uint32_t  TCBCNT;      /*!< Transferred CIU Card Byte Count Register */
+   __I  uint32_t  TBBCNT;      /*!< Transferred Host to BIU-FIFO Byte Count Register */
+   __IO uint32_t  DEBNCE;      /*!< Debounce Count Register */
+   __IO uint32_t  USRID;       /*!< User ID Register       */
+   __I  uint32_t  VERID;       /*!< Version ID Register    */
+   __I  uint32_t  RESERVED0;
+   __IO uint32_t  UHS_REG;     /*!< UHS-1 Register         */
+   __IO uint32_t  RST_N;       /*!< Hardware Reset         */
+   __I  uint32_t  RESERVED1;
+   __IO uint32_t  BMOD;        /*!< Bus Mode Register      */
+   __O  uint32_t  PLDMND;      /*!< Poll Demand Register   */
+   __IO uint32_t  DBADDR;      /*!< Descriptor List Base Address Register */
+   __IO uint32_t  IDSTS;       /*!< Internal DMAC Status Register */
+   __IO uint32_t  IDINTEN;     /*!< Internal DMAC Interrupt Enable Register */
+   __I  uint32_t  DSCADDR;     /*!< Current Host Descriptor Address Register */
+   __I  uint32_t  BUFADDR;     /*!< Current Buffer Descriptor Address Register */
+} LPC_SDMMC_T;
+
+/** @brief  SDIO DMA descriptor control (des0) register defines
+ */
+#define MCI_DMADES0_OWN         (1UL << 31)        /*!< DMA owns descriptor bit */
+#define MCI_DMADES0_CES         (1 << 30)      /*!< Card Error Summary bit */
+#define MCI_DMADES0_ER          (1 << 5)       /*!< End of descriptopr ring bit */
+#define MCI_DMADES0_CH          (1 << 4)       /*!< Second address chained bit */
+#define MCI_DMADES0_FS          (1 << 3)       /*!< First descriptor bit */
+#define MCI_DMADES0_LD          (1 << 2)       /*!< Last descriptor bit */
+#define MCI_DMADES0_DIC         (1 << 1)       /*!< Disable interrupt on completion bit */
+
+/** @brief  SDIO DMA descriptor size (des1) register defines
+ */
+#define MCI_DMADES1_BS1(x)      (x)                /*!< Size of buffer 1 */
+#define MCI_DMADES1_BS2(x)      ((x) << 13)        /*!< Size of buffer 2 */
+#define MCI_DMADES1_MAXTR       4096           /*!< Max transfer size per buffer */
+
+/** @brief  SDIO control register defines
+ */
+#define MCI_CTRL_USE_INT_DMAC   (1 << 25)      /*!< Use internal DMA */
+#define MCI_CTRL_CARDV_MASK     (0x7 << 16)        /*!< SD_VOLT[2:0} pins output state mask */
+#define MCI_CTRL_CEATA_INT_EN   (1 << 11)      /*!< Enable CE-ATA interrupts */
+#define MCI_CTRL_SEND_AS_CCSD   (1 << 10)      /*!< Send auto-stop */
+#define MCI_CTRL_SEND_CCSD      (1 << 9)       /*!< Send CCSD */
+#define MCI_CTRL_ABRT_READ_DATA (1 << 8)       /*!< Abort read data */
+#define MCI_CTRL_SEND_IRQ_RESP  (1 << 7)       /*!< Send auto-IRQ response */
+#define MCI_CTRL_READ_WAIT      (1 << 6)       /*!< Assert read-wait for SDIO */
+#define MCI_CTRL_INT_ENABLE     (1 << 4)       /*!< Global interrupt enable */
+#define MCI_CTRL_DMA_RESET      (1 << 2)       /*!< Reset internal DMA */
+#define MCI_CTRL_FIFO_RESET     (1 << 1)       /*!< Reset data FIFO pointers */
+#define MCI_CTRL_RESET          (1 << 0)       /*!< Reset controller */
+
+/** @brief SDIO Power Enable register defines
+ */
+#define MCI_POWER_ENABLE        0x1                /*!< Enable slot power signal (SD_POW) */
+
+/** @brief SDIO Clock divider register defines
+ */
+#define MCI_CLOCK_DIVIDER(dn, d2) ((d2) << ((dn) * 8)) /*!< Set cklock divider */
+
+/** @brief SDIO Clock source register defines
+ */
+#define MCI_CLKSRC_CLKDIV0      0
+#define MCI_CLKSRC_CLKDIV1      1
+#define MCI_CLKSRC_CLKDIV2      2
+#define MCI_CLKSRC_CLKDIV3      3
+#define MCI_CLK_SOURCE(clksrc)  (clksrc)       /*!< Set cklock divider source */
+
+/** @brief SDIO Clock Enable register defines
+ */
+#define MCI_CLKEN_LOW_PWR       (1 << 16)      /*!< Enable clock idle for slot */
+#define MCI_CLKEN_ENABLE        (1 << 0)       /*!< Enable slot clock */
+
+/** @brief SDIO time-out register defines
+ */
+#define MCI_TMOUT_DATA(clks)    ((clks) << 8)  /*!< Data timeout clocks */
+#define MCI_TMOUT_DATA_MSK      0xFFFFFF00
+#define MCI_TMOUT_RESP(clks)    ((clks) & 0xFF)    /*!< Response timeout clocks */
+#define MCI_TMOUT_RESP_MSK      0xFF
+
+/** @brief SDIO card-type register defines
+ */
+#define MCI_CTYPE_8BIT          (1 << 16)      /*!< Enable 4-bit mode */
+#define MCI_CTYPE_4BIT          (1 << 0)       /*!< Enable 8-bit mode */
+
+/** @brief SDIO Interrupt status & mask register defines
+ */
+#define MCI_INT_SDIO            (1 << 16)      /*!< SDIO interrupt */
+#define MCI_INT_EBE             (1 << 15)      /*!< End-bit error */
+#define MCI_INT_ACD             (1 << 14)      /*!< Auto command done */
+#define MCI_INT_SBE             (1 << 13)      /*!< Start bit error */
+#define MCI_INT_HLE             (1 << 12)      /*!< Hardware locked error */
+#define MCI_INT_FRUN            (1 << 11)      /*!< FIFO overrun/underrun error */
+#define MCI_INT_HTO             (1 << 10)      /*!< Host data starvation error */
+#define MCI_INT_DTO             (1 << 9)       /*!< Data timeout error */
+#define MCI_INT_RTO             (1 << 8)       /*!< Response timeout error */
+#define MCI_INT_DCRC            (1 << 7)       /*!< Data CRC error */
+#define MCI_INT_RCRC            (1 << 6)       /*!< Response CRC error */
+#define MCI_INT_RXDR            (1 << 5)       /*!< RX data ready */
+#define MCI_INT_TXDR            (1 << 4)       /*!< TX data needed */
+#define MCI_INT_DATA_OVER       (1 << 3)       /*!< Data transfer over */
+#define MCI_INT_CMD_DONE        (1 << 2)       /*!< Command done */
+#define MCI_INT_RESP_ERR        (1 << 1)       /*!< Command response error */
+#define MCI_INT_CD              (1 << 0)       /*!< Card detect */
+
+/** @brief SDIO Command register defines
+ */
+#define MCI_CMD_START           (1UL << 31)        /*!< Start command */
+#define MCI_CMD_VOLT_SWITCH     (1 << 28)      /*!< Voltage switch bit */
+#define MCI_CMD_BOOT_MODE       (1 << 27)      /*!< Boot mode */
+#define MCI_CMD_DISABLE_BOOT    (1 << 26)      /*!< Disable boot */
+#define MCI_CMD_EXPECT_BOOT_ACK (1 << 25)      /*!< Expect boot ack */
+#define MCI_CMD_ENABLE_BOOT     (1 << 24)      /*!< Enable boot */
+#define MCI_CMD_CCS_EXP         (1 << 23)      /*!< CCS expected */
+#define MCI_CMD_CEATA_RD        (1 << 22)      /*!< CE-ATA read in progress */
+#define MCI_CMD_UPD_CLK         (1 << 21)      /*!< Update clock register only */
+#define MCI_CMD_INIT            (1 << 15)      /*!< Send init sequence */
+#define MCI_CMD_STOP            (1 << 14)      /*!< Stop/abort command */
+#define MCI_CMD_PRV_DAT_WAIT    (1 << 13)      /*!< Wait before send */
+#define MCI_CMD_SEND_STOP       (1 << 12)      /*!< Send auto-stop */
+#define MCI_CMD_STRM_MODE       (1 << 11)      /*!< Stream transfer mode */
+#define MCI_CMD_DAT_WR          (1 << 10)      /*!< Read(0)/Write(1) selection */
+#define MCI_CMD_DAT_EXP         (1 << 9)       /*!< Data expected */
+#define MCI_CMD_RESP_CRC        (1 << 8)       /*!< Check response CRC */
+#define MCI_CMD_RESP_LONG       (1 << 7)       /*!< Response length */
+#define MCI_CMD_RESP_EXP        (1 << 6)       /*!< Response expected */
+#define MCI_CMD_INDX(n)         ((n) & 0x1F)
+
+/** @brief SDIO status register definess
+ */
+#define MCI_STS_GET_FCNT(x)     (((x) >> 17) & 0x1FF)
+
+/** @brief SDIO FIFO threshold defines
+ */
+#define MCI_FIFOTH_TX_WM(x)     ((x) & 0xFFF)
+#define MCI_FIFOTH_RX_WM(x)     (((x) & 0xFFF) << 16)
+#define MCI_FIFOTH_DMA_MTS_1    (0UL << 28)
+#define MCI_FIFOTH_DMA_MTS_4    (1UL << 28)
+#define MCI_FIFOTH_DMA_MTS_8    (2UL << 28)
+#define MCI_FIFOTH_DMA_MTS_16   (3UL << 28)
+#define MCI_FIFOTH_DMA_MTS_32   (4UL << 28)
+#define MCI_FIFOTH_DMA_MTS_64   (5UL << 28)
+#define MCI_FIFOTH_DMA_MTS_128  (6UL << 28)
+#define MCI_FIFOTH_DMA_MTS_256  (7UL << 28)
+
+/** @brief Bus mode register defines
+ */
+#define MCI_BMOD_PBL1           (0 << 8)       /*!< Burst length = 1 */
+#define MCI_BMOD_PBL4           (1 << 8)       /*!< Burst length = 4 */
+#define MCI_BMOD_PBL8           (2 << 8)       /*!< Burst length = 8 */
+#define MCI_BMOD_PBL16          (3 << 8)       /*!< Burst length = 16 */
+#define MCI_BMOD_PBL32          (4 << 8)       /*!< Burst length = 32 */
+#define MCI_BMOD_PBL64          (5 << 8)       /*!< Burst length = 64 */
+#define MCI_BMOD_PBL128         (6 << 8)       /*!< Burst length = 128 */
+#define MCI_BMOD_PBL256         (7 << 8)       /*!< Burst length = 256 */
+#define MCI_BMOD_DE             (1 << 7)       /*!< Enable internal DMAC */
+#define MCI_BMOD_DSL(len)       ((len) << 2)   /*!< Descriptor skip length */
+#define MCI_BMOD_FB             (1 << 1)       /*!< Fixed bursts */
+#define MCI_BMOD_SWR            (1 << 0)       /*!< Software reset of internal registers */
+
+/** @brief Commonly used definitions
+ */
+#define SD_FIFO_SZ              32             /*!< Size of SDIO FIFOs (32-bit wide) */
+
+/** Function prototype for SD interface IRQ callback */
+typedef uint32_t (*MCI_IRQ_CB_FUNC_T)(uint32_t);
+
+/** Function prototype for SD detect and write protect status check */
+typedef int32_t (*PSCHECK_FUNC_T)(void);
+
+/** Function prototype for SD slot power enable or slot reset */
+typedef void (*PS_POWER_FUNC_T)(int32_t enable);
+
+/** @brief  SDIO chained DMA descriptor
+ */
+typedef struct {
+   volatile uint32_t des0;                     /*!< Control and status */
+   volatile uint32_t des1;                     /*!< Buffer size(s) */
+   volatile uint32_t des2;                     /*!< Buffer address pointer 1 */
+   volatile uint32_t des3;                     /*!< Buffer address pointer 2 */
+} pSDMMC_DMA_T;
+
+/** @brief  SDIO device type
+ */
+typedef struct _sdif_device {
+   /* MCI_IRQ_CB_FUNC_T irq_cb; */
+   pSDMMC_DMA_T mci_dma_dd[1 + (0x10000 / MCI_DMADES1_MAXTR)];
+   /* uint32_t sdio_clk_rate; */
+   /* uint32_t sdif_slot_clk_rate; */
+   /* int32_t clock_enabled; */
+} sdif_device;
+
+/** @brief Setup options for the SDIO driver
+ */
+#define US_TIMEOUT            1000000      /*!< give 1 atleast 1 sec for the card to respond */
+#define MS_ACQUIRE_DELAY      (10)         /*!< inter-command acquire oper condition delay in msec*/
+#define INIT_OP_RETRIES       50           /*!< initial OP_COND retries */
+#define SET_OP_RETRIES        1000         /*!< set OP_COND retries */
+#define SDIO_BUS_WIDTH        4                /*!< Max bus width supported */
+#define SD_MMC_ENUM_CLOCK       400000     /*!< Typical enumeration clock rate */
+#define MMC_MAX_CLOCK           20000000   /*!< Max MMC clock rate */
+#define MMC_LOW_BUS_MAX_CLOCK   26000000   /*!< Type 0 MMC card max clock rate */
+#define MMC_HIGH_BUS_MAX_CLOCK  52000000   /*!< Type 1 MMC card max clock rate */
+#define SD_MAX_CLOCK            25000000   /*!< Max SD clock rate */
+
+/**
+ * @brief  Set block size for the transfer
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  bytes   : block size in bytes
+ * @return None
+ */
+STATIC INLINE void Chip_SDIF_SetBlkSize(LPC_SDMMC_T *pSDMMC, uint32_t bytes)
+{
+   pSDMMC->BLKSIZ = bytes;
+}
+
+/**
+ * @brief  Reset card in slot
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  reset   : Sets SD_RST to passed state
+ * @return None
+ * @note   Reset card in slot, must manually de-assert reset after assertion
+ * (Uses SD_RST pin, set per reset parameter state)
+ */
+STATIC INLINE void Chip_SDIF_Reset(LPC_SDMMC_T *pSDMMC, int32_t reset)
+{
+   if (reset) {
+       pSDMMC->RST_N = 1;
+   }
+   else {
+       pSDMMC->RST_N = 0;
+   }
+}
+
+/**
+ * @brief  Detect if an SD card is inserted
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return Returns 0 if a card is detected, otherwise 1
+ * @note   Detect if an SD card is inserted
+ * (uses SD_CD pin, returns 0 on card detect)
+ */
+STATIC INLINE int32_t Chip_SDIF_CardNDetect(LPC_SDMMC_T *pSDMMC)
+{
+   return (pSDMMC->CDETECT & 1);
+}
+
+/**
+ * @brief  Detect if write protect is enabled
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return Returns 1 if card is write protected, otherwise 0
+ * @note   Detect if write protect is enabled
+ * (uses SD_WP pin, returns 1 if card is write protected)
+ */
+STATIC INLINE int32_t Chip_SDIF_CardWpOn(LPC_SDMMC_T *pSDMMC)
+{
+   return (pSDMMC->WRTPRT & 1);
+}
+
+/**
+ * @brief  Disable slot power
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return None
+ * @note   Uses SD_POW pin, set to low.
+ */
+STATIC INLINE void Chip_SDIF_PowerOff(LPC_SDMMC_T *pSDMMC)
+{
+   pSDMMC->PWREN = 0;
+}
+
+/**
+ * @brief  Enable slot power
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return None
+ * @note   Uses SD_POW pin, set to high.
+ */
+STATIC INLINE void Chip_SDIF_PowerOn(LPC_SDMMC_T *pSDMMC)
+{
+   pSDMMC->PWREN = 1;
+}
+
+/**
+ * @brief  Function to set card type
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  ctype   : card type
+ * @return None
+ */
+STATIC INLINE void Chip_SDIF_SetCardType(LPC_SDMMC_T *pSDMMC, uint32_t ctype)
+{
+   pSDMMC->CTYPE = ctype;
+}
+
+/**
+ * @brief  Returns the raw SD interface interrupt status
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return Current pending interrupt status of Or'ed values MCI_INT_*
+ */
+STATIC INLINE uint32_t Chip_SDIF_GetIntStatus(LPC_SDMMC_T *pSDMMC)
+{
+   return pSDMMC->RINTSTS;
+}
+
+/**
+ * @brief  Clears the raw SD interface interrupt status
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  iVal    : Interrupts to be cleared, Or'ed values MCI_INT_*
+ * @return None
+ */
+STATIC INLINE void Chip_SDIF_ClrIntStatus(LPC_SDMMC_T *pSDMMC, uint32_t iVal)
+{
+   pSDMMC->RINTSTS = iVal;
+}
+
+/**
+ * @brief  Sets the SD interface interrupt mask
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  iVal    : Interrupts to enable, Or'ed values MCI_INT_*
+ * @return None
+ */
+STATIC INLINE void Chip_SDIF_SetIntMask(LPC_SDMMC_T *pSDMMC, uint32_t iVal)
+{
+   pSDMMC->INTMASK = iVal;
+}
+
+/**
+ * @brief  Set block size and byte count for transfer
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  blk_size: block size and byte count in bytes
+ * @return None
+ */
+STATIC INLINE void Chip_SDIF_SetBlkSizeByteCnt(LPC_SDMMC_T *pSDMMC, uint32_t blk_size)
+{
+   pSDMMC->BLKSIZ = blk_size;
+   pSDMMC->BYTCNT = blk_size;
+}
+
+/**
+ * @brief  Set byte count for transfer
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  bytes   : block size and byte count in bytes
+ * @return None
+ */
+STATIC INLINE void Chip_SDIF_SetByteCnt(LPC_SDMMC_T *pSDMMC, uint32_t bytes)
+{
+   pSDMMC->BYTCNT = bytes;
+}
+
+/**
+ * @brief  Initializes the SD/MMC card controller
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return None
+ */
+void Chip_SDIF_Init(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Shutdown the SD/MMC card controller
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return None
+ */
+void Chip_SDIF_DeInit(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Function to send command to Card interface unit (CIU)
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  cmd     : Command with all flags set
+ * @param  arg     : Argument for the command
+ * @return TRUE on times-out, otherwise FALSE
+ */
+int32_t Chip_SDIF_SendCmd(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg);
+
+/**
+ * @brief  Read the response from the last command
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  resp    : Pointer to response array to fill
+ * @return None
+ */
+void Chip_SDIF_GetResponse(LPC_SDMMC_T *pSDMMC, uint32_t *resp);
+
+/**
+ * @brief  Sets the SD bus clock speed
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  clk_rate    : Input clock rate into the IP block
+ * @param  speed       : Desired clock speed to the card
+ * @return None
+ */
+void Chip_SDIF_SetClock(LPC_SDMMC_T *pSDMMC, uint32_t clk_rate, uint32_t speed);
+
+/**
+ * @brief  Function to clear interrupt & FIFOs
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return None
+ */
+void Chip_SDIF_SetClearIntFifo(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Setup DMA descriptors
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @param  psdif_dev   : SD interface device
+ * @param  addr        : Address of buffer (source or destination)
+ * @param  size        : size of buffer in bytes (64K max)
+ * @return None
+ */
+void Chip_SDIF_DmaSetup(LPC_SDMMC_T *pSDMMC, sdif_device *psdif_dev, uint32_t addr, uint32_t size);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDIF_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sdio_18xx_43xx.h ./lpc_chip_43xx/inc/sdio_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/sdio_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sdio_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,278 @@
+/*
+ * @brief LPC18xx/43xx SD/MMC card driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDIO_18XX_43XX_H_
+#define __SDIO_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SDIO_18XX_43XX CHIP: LPC18xx/43xx SDIO Card driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/** @brief SDIO Driver events */
+enum SDIO_EVENT
+{
+   SDIO_START_COMMAND,  /**! SDIO driver is about to start a command transfer */
+   SDIO_START_DATA,     /**! SDIO driver is about to start a data transfer */
+   SDIO_WAIT_DELAY,     /**! SDIO driver needs to wait for given milli seconds */
+   SDIO_WAIT_COMMAND,   /**! SDIO driver is waiting for a command to complete */
+   SDIO_WAIT_DATA,      /**! SDIO driver is waiting for data transfer to complete */
+
+   SDIO_CARD_DETECT,    /**! SDIO driver has detected a card */
+   SDIO_CMD_ERR,        /**! Error in command transfer */
+   SDIO_CMD_DONE,       /**! Command transfer successful */
+   SDIO_DATA_ERR,       /**! Data transfer error */
+   SDIO_DATA_DONE,      /**! Data transfer successful */
+   SDIO_CARD_INT,       /**! SDIO Card interrupt (from a function) */
+};
+
+/** @brief SDIO Command Responses */
+#define SDIO_CMD_RESP_R1     (1UL << 6)
+#define SDIO_CMD_RESP_R2     (3UL << 6)
+#define SDIO_CMD_RESP_R3     (1UL << 6)
+#define SDIO_CMD_RESP_R4     (1UL << 6)
+#define SDIO_CMD_RESP_R5     (1UL << 6)
+#define SDIO_CMD_RESP_R6     (1UL << 6)
+
+/** @brief SDIO Command misc options */
+#define SDIO_CMD_CRC         (1UL << 8)  /**! Response must have a valid CRC */
+#define SDIO_CMD_DATA        (1UL << 9)  /**! Command is a data transfer command */
+
+/** @brief List of commands */
+#define CMD0            (0 | (1 << 15))
+#define CMD5            (5 | SDIO_CMD_RESP_R4)
+#define CMD3            (3 | SDIO_CMD_RESP_R6)
+#define CMD7            (7 | SDIO_CMD_RESP_R1)
+#define CMD52           (52 | SDIO_CMD_RESP_R5 | SDIO_CMD_CRC)
+#define CMD53           (53 | SDIO_CMD_RESP_R5 | SDIO_CMD_DATA | SDIO_CMD_CRC)
+
+/** @brief SDIO Error numbers */
+#define SDIO_ERROR           -1 /**! General SDIO Error */
+#define SDIO_ERR_FNUM        -2 /**! Error getting Number of functions supported */
+#define SDIO_ERR_READWRITE   -3 /**! Error when performing Read/write of data */
+#define SDIO_ERR_VOLT        -4 /**! Error Reading or setting up the voltage to 3v3 */
+#define SDIO_ERR_RCA         -5 /**! Error during RCA phase */
+#define SDIO_ERR_INVFUNC     -6 /**! Invalid function argument */
+#define SDIO_ERR_INVARG      -7 /**! Invalid argument supplied to function */
+
+#define SDIO_VOLT_3_3    0x00100000UL  /* for CMD5 */
+
+/* SDIO Data transfer modes */
+/** @brief  Block mode transfer flag
+ *
+ * When this flag is specified in a transfer the data will be transfered in blocks if not
+ * it will be transfered in bytes. See SDIO_Card_DataRead(), SDIO_Card_DataWrite()
+ * for more information.
+ */
+#define SDIO_MODE_BLOCK       (1UL << 27)
+
+/** @brief Buffer mode transfer flag
+ *
+ * Default mode for SDIO_Card_ReadData() and SDIO_Card_WriteData() is FIFO mode
+ * in FIFO mode all the given data will be written to or read from the same
+ * register address in the function. This flag will set the transfers to BUFFER
+ * mode; in BUFFER mode read first byte will be read from the given source address
+ * and the next byte will be read from the next source address (i.e src_addr + 1),
+ * and so on, in BUFFER mode write first byte will be written to dest_addr, next
+ * byte will be written to dest_addr + 1 and so on.
+ */
+#define SDIO_MODE_BUFFER      (1UL << 26)
+
+/* ---- SDIO Internal map ---- */
+#define SDIO_AREA_CIA          0           /* function 0 */
+
+/* ---- Card Capability(0x08) register ---- */
+#define SDIO_CCCR_LSC          0x40u       /* card is low-speed cards */
+#define SDIO_CCCR_4BLS         0x80u       /* 4-bit support for low-speed cards */
+
+#define SDIO_POWER_INIT  1
+
+#define SDIO_CLK_HISPEED            33000000UL    /* High-Speed Clock  */
+#define SDIO_CLK_FULLSPEED          16000000UL    /* Full-Speed Clock  */
+#define SDIO_CLK_LOWSPEED           400000        /* Low-Speed Clock   */
+
+/**
+ * @brief  Initialize the SDIO card
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  freq        : Initial frequency to use during the enumeration
+ * @return 0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ */
+int SDIO_Card_Init(LPC_SDMMC_T *pSDMMC, uint32_t freq);
+
+/**
+ * @brief  Write 8-Bit register from SDIO register space
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @param  addr        : Address of the register to read
+ * @param  data        : 8-bit data be written
+ * @return 0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ * @note SDIO_Setup_Callback() function must be called to setup the call backs before
+ * calling  this API.
+ */
+int SDIO_Write_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t data);
+
+/**
+ * @brief  Write 8-Bit register from SDIO register space and read the register back
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @param  addr        : Address of the register to read
+ * @param  data        : Pointer to memory where the 8-bit data be stored
+ * @return 0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ * @note   @a data must have the value to be written stored in it when the function is called
+ */
+int SDIO_WriteRead_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data);
+
+/**
+ * @brief  Read an 8-Bit register from SDIO register space
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @param  addr        : Address of the register to read
+ * @param  data        : Pointer to memory where the 8-bit data be stored
+ * @return 0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ */
+int SDIO_Read_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data);
+
+/**
+ * @brief  Setup SDIO wait and wakeup callbacks
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  wake_evt    : Wakeup event call-back handler
+ * @param  wait_evt    : Wait event call-back handler
+ * @return Nothing
+ * @note   @a wake_evt and @a wait_evt should always be non-null function pointers
+ * This function must be called before calling SDIO_Card_Init() function
+ */
+void SDIO_Setup_Callback(LPC_SDMMC_T *pSDMMC,
+   void (*wake_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg),
+   uint32_t (*wait_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg));
+
+/**
+ * @brief  SDIO Event handler [Should be called from SDIO interrupt handler]
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @return Nothing
+ */
+void SDIO_Handler(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Sends a command to the SDIO Card [Example CMD52]
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  cmd         : Command to be sent along with any flags
+ * @param  arg         : Argument for the command
+ * @return 0 on Success; Non-Zero on failure
+ */
+uint32_t SDIO_Send_Command(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg);
+
+/**
+ * @brief  Gets the block size of a given function
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @return Block size of the given function
+ * @sa     SDIO_Card_SetBlockSize()
+ * @note   If the return value is 0 then bock size is not set using
+ * SDIO_Card_SetBlockSize(), or given @a func is not valid or the
+ * card does not support block data transfers.
+ */
+uint32_t SDIO_Card_GetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func);
+
+/**
+ * @brief  Sets the block size of a given function
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @param  blkSize     : Block size to set
+ * @return 0 on success; Non-Zero on failure
+ * @sa     SDIO_Card_GetBlockSize()
+ * @note   After setting block size using this API, if
+ * SDIO_Card_GetBlockSize() returns 0 for a valid function then the card
+ * does not support block transfers.
+ */
+int SDIO_Card_SetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t blkSize);
+
+/**
+ * @brief  Writes stream or block of data to the SDIO card [Using CMD53]
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @param  dest_addr   : Address where the data to be written (inside @a func register space)
+ * @param  src_addr    : Buffer from which data to be taken
+ * @param  size        : Number of Bytes/Blocks to be transfered [Must be in the range 1 to 512]
+ * @param  flags       : Or-ed value of #SDIO_MODE_BLOCK, #SDIO_MODE_BUFFER
+ * @return 0 on success; Non-Zero on failure
+ * @note   When #SDIO_MODE_BLOCK is set in @a flags the size is number of blocks, so
+ * the number of bytes transferd will be @a size * "block size" [See SDIO_Card_GetBlockSize() and
+ * SDIO_Card_SetBlockSize() for more information]
+ */
+int SDIO_Card_WriteData(LPC_SDMMC_T *pSDMMC, uint32_t func,
+   uint32_t dest_addr, const uint8_t *src_addr,
+   uint32_t size, uint32_t flags);
+
+/**
+ * @brief  Reads stream or block of data from the SDIO card [Using CMD53]
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @param  dest_addr   : memory where the data to be read into
+ * @param  src_addr    : Register address from which data to be read  (inside @a func register space)
+ * @param  size        : Number of Bytes/Blocks to be transfered [Must be in the range 1 to 512]
+ * @param  flags       : Or-ed value of #SDIO_MODE_BLOCK, #SDIO_MODE_BUFFER
+ * @return 0 on success; Non-Zero on failure
+ * @note   When #SDIO_MODE_BLOCK is set in @a flags the size is number of blocks, so
+ * the number of bytes transferd will be @a size * "block size" [See SDIO_Card_GetBlockSize() and
+ * SDIO_Card_SetBlockSize() for more information]
+ */
+int SDIO_Card_ReadData(LPC_SDMMC_T *pSDMMC, uint32_t func,
+   uint8_t *dest_addr, uint32_t src_addr,
+   uint32_t size, uint32_t flags);
+
+/**
+ * @brief  Disable SDIO interrupt for a given function
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @return 0 - on success; Non zero on failure
+ */
+int SDIO_Card_DisableInt(LPC_SDMMC_T *pSDMMC, uint32_t func);
+
+/**
+ * @brief  Enable SDIO interrupt for a given function
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  func        : function number [0 to 7] [0 = CIA function]
+ * @return 0 - on success; Non zero on failure
+ */
+int SDIO_Card_EnableInt(LPC_SDMMC_T *pSDMMC, uint32_t func);
+
+/**
+ * @}
+ */
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDIO_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sdmmc_18xx_43xx.h ./lpc_chip_43xx/inc/sdmmc_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/sdmmc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sdmmc_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,151 @@
+/*
+ * @brief LPC18xx/43xx SD/MMC card driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDMMC_18XX_43XX_H_
+#define __SDMMC_18XX_43XX_H_
+
+#include "sdmmc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SDMMC_18XX_43XX CHIP: LPC18xx/43xx SD/MMC driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define CMD_MASK_RESP       (0x3UL << 28)
+#define CMD_RESP(r)         (((r) & 0x3) << 28)
+#define CMD_RESP_R0         (0 << 28)
+#define CMD_RESP_R1         (1 << 28)
+#define CMD_RESP_R2         (2 << 28)
+#define CMD_RESP_R3         (3 << 28)
+#define CMD_BIT_AUTO_STOP   (1 << 24)
+#define CMD_BIT_APP         (1 << 23)
+#define CMD_BIT_INIT        (1 << 22)
+#define CMD_BIT_BUSY        (1 << 21)
+#define CMD_BIT_LS          (1 << 20)  /* Low speed, used during acquire */
+#define CMD_BIT_DATA        (1 << 19)
+#define CMD_BIT_WRITE       (1 << 18)
+#define CMD_BIT_STREAM      (1 << 17)
+#define CMD_MASK_CMD        (0xff)
+#define CMD_SHIFT_CMD       (0)
+
+#define CMD(c, r)        ( ((c) &  CMD_MASK_CMD) | CMD_RESP((r)) )
+
+#define CMD_IDLE            CMD(MMC_GO_IDLE_STATE, 0) | CMD_BIT_LS    | CMD_BIT_INIT
+#define CMD_SD_OP_COND      CMD(SD_APP_OP_COND, 1)      | CMD_BIT_LS | CMD_BIT_APP
+#define CMD_SD_SEND_IF_COND CMD(SD_CMD8, 1)      | CMD_BIT_LS
+#define CMD_MMC_OP_COND     CMD(MMC_SEND_OP_COND, 3)    | CMD_BIT_LS | CMD_BIT_INIT
+#define CMD_ALL_SEND_CID    CMD(MMC_ALL_SEND_CID, 2)    | CMD_BIT_LS
+#define CMD_MMC_SET_RCA     CMD(MMC_SET_RELATIVE_ADDR, 1) | CMD_BIT_LS
+#define CMD_SD_SEND_RCA     CMD(SD_SEND_RELATIVE_ADDR, 1) | CMD_BIT_LS
+#define CMD_SEND_CSD        CMD(MMC_SEND_CSD, 2) | CMD_BIT_LS
+#define CMD_SEND_EXT_CSD    CMD(MMC_SEND_EXT_CSD, 1) | CMD_BIT_LS | CMD_BIT_DATA
+#define CMD_DESELECT_CARD   CMD(MMC_SELECT_CARD, 0)
+#define CMD_SELECT_CARD     CMD(MMC_SELECT_CARD, 1)
+#define CMD_SET_BLOCKLEN    CMD(MMC_SET_BLOCKLEN, 1)
+#define CMD_SEND_STATUS     CMD(MMC_SEND_STATUS, 1)
+#define CMD_READ_SINGLE     CMD(MMC_READ_SINGLE_BLOCK, 1) | CMD_BIT_DATA
+#define CMD_READ_MULTIPLE   CMD(MMC_READ_MULTIPLE_BLOCK, 1) | CMD_BIT_DATA | CMD_BIT_AUTO_STOP
+#define CMD_SD_SET_WIDTH    CMD(SD_APP_SET_BUS_WIDTH, 1) | CMD_BIT_APP
+#define CMD_STOP            CMD(MMC_STOP_TRANSMISSION, 1) | CMD_BIT_BUSY
+#define CMD_WRITE_SINGLE    CMD(MMC_WRITE_BLOCK, 1) | CMD_BIT_DATA | CMD_BIT_WRITE
+#define CMD_WRITE_MULTIPLE  CMD(MMC_WRITE_MULTIPLE_BLOCK, 1) | CMD_BIT_DATA | CMD_BIT_WRITE | CMD_BIT_AUTO_STOP
+
+/* Card specific setup data */
+typedef struct _mci_card_struct {
+   sdif_device sdif_dev;
+   SDMMC_CARD_T card_info;
+} mci_card_struct;
+
+/**
+ * @brief  Get card's current state (idle, transfer, program, etc.)
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return Current SD card transfer state
+ */
+int32_t Chip_SDMMC_GetState(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Function to enumerate the SD/MMC/SDHC/MMC+ cards
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  pcardinfo   : Pointer to pre-allocated card info structure
+ * @return 1 if a card is acquired, otherwise 0
+ */
+uint32_t Chip_SDMMC_Acquire(LPC_SDMMC_T *pSDMMC, mci_card_struct *pcardinfo);
+
+/**
+ * @brief  Get the device size of SD/MMC card (after enumeration)
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return Card size in number of bytes (capacity)
+ */
+uint64_t Chip_SDMMC_GetDeviceSize(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Get the number of device blocks of SD/MMC card (after enumeration)
+ * Since Chip_SDMMC_GetDeviceSize is limited to 32 bits cards with greater than
+ * 2 GBytes of data will not be correct, in such cases users can use this function
+ * to get the size of the card in blocks.
+ * @param  pSDMMC  : SDMMC peripheral selected
+ * @return Number of 512 bytes blocks in the card
+ */
+int32_t Chip_SDMMC_GetDeviceBlocks(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief  Performs the read of data from the SD/MMC card
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  buffer      : Pointer to data buffer to copy to
+ * @param  start_block : Start block number
+ * @param  num_blocks  : Number of block to read
+ * @return Bytes read, or 0 on error
+ */
+int32_t Chip_SDMMC_ReadBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks);
+
+/**
+ * @brief  Performs write of data to the SD/MMC card
+ * @param  pSDMMC      : SDMMC peripheral selected
+ * @param  buffer      : Pointer to data buffer to copy to
+ * @param  start_block : Start block number
+ * @param  num_blocks  : Number of block to write
+ * @return Number of bytes actually written, or 0 on error
+ */
+int32_t Chip_SDMMC_WriteBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDMMC_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sdmmc.h ./lpc_chip_43xx/inc/sdmmc.h
--- a_qSC69Z/lpc_chip_43xx/inc/sdmmc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sdmmc.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,450 @@
+/*
+ * @brief    Common definitions used in SD/MMC cards
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDMMC_H
+#define __SDMMC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CHIP_SDMMC_Definitions CHIP: Common SD/MMC definitions
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief OCR Register definitions
+ */
+/** Support voltage range 2.0-2.1 (this bit is reserved in SDC)*/
+#define SDC_OCR_20_21               (((uint32_t) 1) << 8)
+/** Support voltage range 2.1-2.2 (this bit is reserved in SDC)*/
+#define SDC_OCR_21_22               (((uint32_t) 1) << 9)
+/** Support voltage range 2.2-2.3 (this bit is reserved in SDC)*/
+#define SDC_OCR_22_23               (((uint32_t) 1) << 10)
+/** Support voltage range 2.3-2.4 (this bit is reserved in SDC)*/
+#define SDC_OCR_23_24               (((uint32_t) 1) << 11)
+/** Support voltage range 2.4-2.5 (this bit is reserved in SDC)*/
+#define SDC_OCR_24_25               (((uint32_t) 1) << 12)
+/** Support voltage range 2.5-2.6 (this bit is reserved in SDC)*/
+#define SDC_OCR_25_26               (((uint32_t) 1) << 13)
+/** Support voltage range 2.6-2.7 (this bit is reserved in SDC)*/
+#define SDC_OCR_26_27               (((uint32_t) 1) << 14)
+/** Support voltage range 2.7-2.8 */
+#define SDC_OCR_27_28               (((uint32_t) 1) << 15)
+/** Support voltage range 2.8-2.9*/
+#define SDC_OCR_28_29               (((uint32_t) 1) << 16)
+/** Support voltage range 2.9-3.0 */
+#define SDC_OCR_29_30               (((uint32_t) 1) << 17)
+/** Support voltage range 3.0-3.1 */
+#define SDC_OCR_30_31               (((uint32_t) 1) << 18)
+/** Support voltage range 3.1-3.2 */
+#define SDC_OCR_31_32               (((uint32_t) 1) << 19)
+/** Support voltage range 3.2-3.3 */
+#define SDC_OCR_32_33               (((uint32_t) 1) << 20)
+/** Support voltage range 3.3-3.4 */
+#define SDC_OCR_33_34               (((uint32_t) 1) << 21)
+/** Support voltage range 3.4-3.5 */
+#define SDC_OCR_34_35               (((uint32_t) 1) << 22)
+/** Support voltage range 3.5-3.6 */
+#define SDC_OCR_35_36               (((uint32_t) 1) << 23)
+/** Support voltage range 2.7-3.6 */
+#define SDC_OCR_27_36               ((uint32_t) 0x00FF8000)
+/** Card Capacity Status (CCS). (this bit is reserved in MMC) */
+#define SDC_OCR_HC_CCS              (((uint32_t) 1) << 30)
+/** Card power up status bit */
+#define SDC_OCR_IDLE                (((uint32_t) 1) << 31)
+#define SDC_OCR_BUSY                (((uint32_t) 0) << 31)
+
+/* SD/MMC commands - this matrix shows the command, response types, and
+   supported card type for that command.
+   Command                 Number Resp  SD  MMC
+   ----------------------- ------ ----- --- ---
+   Reset (go idle)         CMD0   NA    x   x
+   Send op condition       CMD1   R3        x
+   All send CID            CMD2   R2    x   x
+   Send relative address   CMD3   R1        x
+   Send relative address   CMD3   R6    x
+   Program DSR             CMD4   NA        x
+   Select/deselect card    CMD7   R1b       x
+   Select/deselect card    CMD7   R1    x
+   Send CSD                CMD9   R2    x   x
+   Send CID                CMD10  R2    x   x
+   Read data until stop    CMD11  R1    x   x
+   Stop transmission       CMD12  R1/b  x   x
+   Send status             CMD13  R1    x   x
+   Go inactive state       CMD15  NA    x   x
+   Set block length        CMD16  R1    x   x
+   Read single block       CMD17  R1    x   x
+   Read multiple blocks    CMD18  R1    x   x
+   Write data until stop   CMD20  R1        x
+   Setblock count          CMD23  R1        x
+   Write single block      CMD24  R1    x   x
+   Write multiple blocks   CMD25  R1    x   x
+   Program CID             CMD26  R1        x
+   Program CSD             CMD27  R1    x   x
+   Set write protection    CMD28  R1b   x   x
+   Clear write protection  CMD29  R1b   x   x
+   Send write protection   CMD30  R1    x   x
+   Erase block start       CMD32  R1    x
+   Erase block end         CMD33  R1    x
+   Erase block start       CMD35  R1        x
+   Erase block end         CMD36  R1        x
+   Erase blocks            CMD38  R1b       x
+   Fast IO                 CMD39  R4        x
+   Go IRQ state            CMD40  R5        x
+   Lock/unlock             CMD42  R1b       x
+   Application command     CMD55  R1        x
+   General command         CMD56  R1b       x
+
+ *** SD card application commands - these must be preceded with ***
+ *** MMC CMD55 application specific command first               ***
+   Set bus width           ACMD6  R1    x
+   Send SD status          ACMD13 R1    x
+   Send number WR blocks   ACMD22 R1    x
+   Set WR block erase cnt  ACMD23 R1    x
+   Send op condition       ACMD41 R3    x
+   Set clear card detect   ACMD42 R1    x
+   Send CSR                ACMD51 R1    x */
+
+/**
+ * @brief  SD/MMC application specific commands for SD cards only - these
+ * must be preceded by the SDMMC CMD55 to work correctly
+ */
+typedef enum {
+   SD_SET_BUS_WIDTH,       /*!< Set the SD bus width */
+   SD_SEND_STATUS,         /*!< Send the SD card status */
+   SD_SEND_WR_BLOCKS,      /*!< Send the number of written clocks */
+   SD_SET_ERASE_COUNT,     /*!< Set the number of blocks to pre-erase */
+   SD_SENDOP_COND,         /*!< Send the OCR register (init) */
+   SD_CLEAR_CARD_DET,      /*!< Set or clear the 50K detect pullup */
+   SD_SEND_SCR,            /*!< Send the SD configuration register */
+   SD_INVALID_APP_CMD      /*!< Invalid SD application command */
+} SD_APP_CMD_T;
+
+/**
+ * @brief  Possible SDMMC response types
+ */
+typedef enum {
+   SDMMC_RESPONSE_R1,      /*!< Typical status */
+   SDMMC_RESPONSE_R1B,     /*!< Typical status with busy */
+   SDMMC_RESPONSE_R2,      /*!< CID/CSD registers (CMD2 and CMD10) */
+   SDMMC_RESPONSE_R3,      /*!< OCR register (CMD1, ACMD41) */
+   SDMMC_RESPONSE_R4,      /*!< Fast IO response word */
+   SDMMC_RESPONSE_R5,      /*!< Go IRQ state response word */
+   SDMMC_RESPONSE_R6,      /*!< Published RCA response */
+   SDMMC_RESPONSE_NONE     /*!< No response expected */
+} SDMMC_RESPONSE_T;
+
+/**
+ * @brief  Possible SDMMC card state types
+ */
+typedef enum {
+   SDMMC_IDLE_ST = 0,  /*!< Idle state */
+   SDMMC_READY_ST,     /*!< Ready state */
+   SDMMC_IDENT_ST,     /*!< Identification State */
+   SDMMC_STBY_ST,      /*!< standby state */
+   SDMMC_TRAN_ST,      /*!< transfer state */
+   SDMMC_DATA_ST,      /*!< Sending-data State */
+   SDMMC_RCV_ST,       /*!< Receive-data State */
+   SDMMC_PRG_ST,       /*!< Programming State */
+   SDMMC_DIS_ST        /*!< Disconnect State */
+} SDMMC_STATE_T;
+
+/* Function prototype for event setup function */
+typedef void (*SDMMC_EVSETUP_FUNC_T)(void *);
+
+/* Function prototype for wait for event function */
+typedef uint32_t (*SDMMC_EVWAIT_FUNC_T)(void);
+
+/* Function prototype for milliSecond delay function */
+typedef void (*SDMMC_MSDELAY_FUNC_T)(uint32_t);
+
+/**
+ * @brief SD/MMC Card specific setup data structure
+ */
+typedef struct {
+   uint32_t response[4];                       /*!< Most recent response */
+   uint32_t cid[4];                            /*!< CID of acquired card  */
+   uint32_t csd[4];                            /*!< CSD of acquired card */
+   uint32_t ext_csd[512 / 4];                  /*!< Ext CSD */
+   uint32_t card_type;                         /*!< Card Type */
+   uint16_t rca;                               /*!< Relative address assigned to card */
+   uint32_t speed;                             /*!< Speed */
+   uint32_t block_len;                         /*!< Card sector size */
+   uint64_t device_size;                       /*!< Device Size */
+   uint32_t blocknr;                           /*!< Block Number */
+   uint32_t clk_rate;                          /*! Clock rate */
+   SDMMC_EVSETUP_FUNC_T evsetup_cb;            /*!< Function to setup event information */
+   SDMMC_EVWAIT_FUNC_T waitfunc_cb;            /*!< Function to wait for event */
+   SDMMC_MSDELAY_FUNC_T msdelay_func;          /*!< Function to sleep in ms */
+} SDMMC_CARD_T;
+
+/**
+ * @brief SD/MMC commands, arguments and responses
+ * Standard SD/MMC commands (3.1)       type  argument     response
+ */
+/* class 1 */
+#define MMC_GO_IDLE_STATE         0        /* bc                          */
+#define MMC_SEND_OP_COND          1        /* bcr  [31:0]  OCR        R3  */
+#define MMC_ALL_SEND_CID          2        /* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3        /* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4        /* bc   [31:16] RCA            */
+#define MMC_SELECT_CARD           7        /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_EXT_CSD          8        /* bc                      R1  */
+#define MMC_SEND_CSD              9        /* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10        /* ac   [31:16] RCA        R2  */
+#define MMC_STOP_TRANSMISSION    12        /* ac                      R1b */
+#define MMC_SEND_STATUS          13        /* ac   [31:16] RCA        R1  */
+#define MMC_GO_INACTIVE_STATE    15        /* ac   [31:16] RCA            */
+
+/* class 2 */
+#define MMC_SET_BLOCKLEN         16        /* ac   [31:0]  block len  R1  */
+#define MMC_READ_SINGLE_BLOCK    17        /* adtc [31:0]  data addr  R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18        /* adtc [31:0]  data addr  R1  */
+
+/* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20        /* adtc [31:0]  data addr  R1  */
+
+/* class 4 */
+#define MMC_SET_BLOCK_COUNT      23        /* adtc [31:0]  data addr  R1  */
+#define MMC_WRITE_BLOCK          24        /* adtc [31:0]  data addr  R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25        /* adtc                    R1  */
+#define MMC_PROGRAM_CID          26        /* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27        /* adtc                    R1  */
+
+/* class 6 */
+#define MMC_SET_WRITE_PROT       28        /* ac   [31:0]  data addr  R1b */
+#define MMC_CLR_WRITE_PROT       29        /* ac   [31:0]  data addr  R1b */
+#define MMC_SEND_WRITE_PROT      30        /* adtc [31:0]  wpdata addr R1  */
+
+/* class 5 */
+#define MMC_ERASE_GROUP_START    35        /* ac   [31:0]  data addr  R1  */
+#define MMC_ERASE_GROUP_END      36        /* ac   [31:0]  data addr  R1  */
+#define MMC_ERASE                37        /* ac                      R1b */
+#define SD_ERASE_WR_BLK_START    32        /* ac   [31:0]  data addr  R1  */
+#define SD_ERASE_WR_BLK_END      33        /* ac   [31:0]  data addr  R1  */
+#define SD_ERASE                 38        /* ac                      R1b */
+
+/* class 9 */
+#define MMC_FAST_IO              39        /* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40        /* bcr                     R5  */
+
+/* class 7 */
+#define MMC_LOCK_UNLOCK          42        /* adtc                    R1b */
+
+/* class 8 */
+#define MMC_APP_CMD              55        /* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56        /* adtc [0]     RD/WR      R1b */
+
+/* SD commands                           type  argument     response */
+/* class 8 */
+/* This is basically the same command as for MMC with some quirks. */
+#define SD_SEND_RELATIVE_ADDR     3        /* ac                      R6  */
+#define SD_CMD8                   8        /* bcr  [31:0]  OCR        R3  */
+
+/* Application commands */
+#define SD_APP_SET_BUS_WIDTH      6        /* ac   [1:0]   bus width  R1   */
+#define SD_APP_OP_COND           41        /* bcr  [31:0]  OCR        R1 (R4)  */
+#define SD_APP_SEND_SCR          51        /* adtc                    R1   */
+
+/**
+ * @brief MMC status in R1<br>
+ * Type<br>
+ *   e : error bit<br>
+ *   s : status bit<br>
+ *   r : detected and set for the actual command response<br>
+ *   x : detected and set during command execution. the host must poll
+ *       the card by sending status command in order to read these bits.
+ * Clear condition<br>
+ *   a : according to the card state<br>
+ *   b : always related to the previous command. Reception of
+ *       a valid command will clear it (with a delay of one command)<br>
+ *   c : clear by read<br>
+ */
+
+#define R1_OUT_OF_RANGE         (1UL << 31)    /* er, c */
+#define R1_ADDRESS_ERROR        (1 << 30)  /* erx, c */
+#define R1_BLOCK_LEN_ERROR      (1 << 29)  /* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)  /* er, c */
+#define R1_ERASE_PARAM          (1 << 27)  /* ex, c */
+#define R1_WP_VIOLATION         (1 << 26)  /* erx, c */
+#define R1_CARD_IS_LOCKED       (1 << 25)  /* sx, a */
+#define R1_LOCK_UNLOCK_FAILED   (1 << 24)  /* erx, c */
+#define R1_COM_CRC_ERROR        (1 << 23)  /* er, b */
+#define R1_ILLEGAL_COMMAND      (1 << 22)  /* er, b */
+#define R1_CARD_ECC_FAILED      (1 << 21)  /* ex, c */
+#define R1_CC_ERROR             (1 << 20)  /* erx, c */
+#define R1_ERROR                (1 << 19)  /* erx, c */
+#define R1_UNDERRUN             (1 << 18)  /* ex, c */
+#define R1_OVERRUN              (1 << 17)  /* ex, c */
+#define R1_CID_CSD_OVERWRITE    (1 << 16)  /* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP        (1 << 15)  /* sx, c */
+#define R1_CARD_ECC_DISABLED    (1 << 14)  /* sx, a */
+#define R1_ERASE_RESET          (1 << 13)  /* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)     ((x & 0x00001E00) >> 9)    /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA       (1 << 8)   /* sx, a */
+#define R1_APP_CMD              (1 << 5)   /* sr, c */
+
+/**
+ * @brief SD/MMC card OCR register bits
+ */
+#define OCR_ALL_READY           (1UL << 31)    /* Card Power up status bit */
+#define OCR_HC_CCS              (1 << 30)  /* High capacity card */
+#define OCR_VOLTAGE_RANGE_MSK   (0x00FF8000)
+
+#define SD_SEND_IF_ARG          0x000001AA
+#define SD_SEND_IF_ECHO_MSK     0x000000FF
+#define SD_SEND_IF_RESP         0x000000AA
+
+/**
+ * @brief R3 response definitions
+ */
+#define CMDRESP_R3_OCR_VAL(n)           (((uint32_t) n) & 0xFFFFFF)
+#define CMDRESP_R3_S18A                 (((uint32_t) 1 ) << 24)
+#define CMDRESP_R3_HC_CCS               (((uint32_t) 1 ) << 30)
+#define CMDRESP_R3_INIT_COMPLETE        (((uint32_t) 1 ) << 31)
+
+/**
+ * @brief R6 response definitions
+ */
+#define CMDRESP_R6_RCA_VAL(n)           (((uint32_t) (n >> 16)) & 0xFFFF)
+#define CMDRESP_R6_CARD_STATUS(n)       (((uint32_t) (n & 0x1FFF)) | \
+                                        ((n & (1 << 13)) ? (1 << 19) : 0) | \
+                                        ((n & (1 << 14)) ? (1 << 22) : 0) | \
+                                        ((n & (1 << 15)) ? (1 << 23) : 0))
+
+/**
+ * @brief R7 response definitions
+ */
+/** Echo-back of check-pattern */
+#define CMDRESP_R7_CHECK_PATTERN(n)     (((uint32_t) n ) & 0xFF)
+/** Voltage accepted */
+#define CMDRESP_R7_VOLTAGE_ACCEPTED     (((uint32_t) 1 ) << 8)
+
+/**
+ * @brief CMD3 command definitions
+ */
+/** Card Address */
+#define CMD3_RCA(n)         (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief CMD7 command definitions
+ */
+/** Card Address */
+#define CMD7_RCA(n)         (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief CMD8 command definitions
+ */
+/** Check pattern */
+#define CMD8_CHECKPATTERN(n)            (((uint32_t) (n & 0xFF) ) << 0)
+/** Recommended pattern */
+#define CMD8_DEF_PATTERN                    (0xAA)
+/** Voltage supplied.*/
+#define CMD8_VOLTAGESUPPLIED_27_36     (((uint32_t) 1 ) << 8)
+
+/**
+ * @brief CMD9 command definitions
+ */
+#define CMD9_RCA(n)         (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief CMD13 command definitions
+ */
+#define CMD13_RCA(n)            (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief APP_CMD command definitions
+ */
+#define CMD55_RCA(n)            (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief ACMD41 command definitions
+ */
+#define ACMD41_OCR(n)                   (((uint32_t) n) & 0xFFFFFF)
+#define ACMD41_S18R                     (((uint32_t) 1 ) << 24)
+#define ACMD41_XPC                      (((uint32_t) 1 ) << 28)
+#define ACMD41_HCS                      (((uint32_t) 1 ) << 30)
+
+/**
+ * @brief ACMD6 command definitions
+ */
+#define ACMD6_BUS_WIDTH(n)              ((uint32_t) n & 0x03)
+#define ACMD6_BUS_WIDTH_1               (0)
+#define ACMD6_BUS_WIDTH_4               (2)
+
+/** @brief Card type defines
+ */
+#define CARD_TYPE_SD    (1 << 0)
+#define CARD_TYPE_4BIT  (1 << 1)
+#define CARD_TYPE_8BIT  (1 << 2)
+#define CARD_TYPE_HC    (OCR_HC_CCS)/*!< high capacity card > 2GB */
+
+/**
+ * @brief SD/MMC sector size in bytes
+ */
+#define MMC_SECTOR_SIZE     512
+
+/**
+ * @brief Typical enumeration clock rate
+ */
+#define SD_MMC_ENUM_CLOCK       400000
+
+/**
+ * @brief Max MMC clock rate
+ */
+#define MMC_MAX_CLOCK           20000000
+
+/**
+ * @brief Type 0 MMC card max clock rate
+ */
+#define MMC_LOW_BUS_MAX_CLOCK   26000000
+
+/**
+ * @brief Type 1 MMC card max clock rate
+ */
+#define MMC_HIGH_BUS_MAX_CLOCK  52000000
+
+/**
+ * @brief Max SD clock rate
+ */
+#define SD_MAX_CLOCK            25000000
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* __SDMMC_H */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sgpio_18xx_43xx.h ./lpc_chip_43xx/inc/sgpio_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/sgpio_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sgpio_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,108 @@
+/*
+ * @brief LPC43xx Serial GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SGPIO_43XX_H_
+#define __SGPIO_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SGPIO_43XX CHIP: LPC43xx Serial GPIO driver
+ * @ingroup LPC_CHIP_18XX_43XX_Drivers
+ * This module is present in LPC43xx MCUs only.
+ * @{
+ */
+
+#if defined(CHIP_LPC43XX)
+
+/**
+ * @brief Serial GPIO register block structure
+ */
+typedef struct {                       /*!< SGPIO Structure        */
+   __IO uint32_t  OUT_MUX_CFG[16];     /*!< Pin multiplexer configurationregisters. */
+   __IO uint32_t  SGPIO_MUX_CFG[16];   /*!< SGPIO multiplexer configuration registers. */
+   __IO uint32_t  SLICE_MUX_CFG[16];   /*!< Slice multiplexer configuration registers. */
+   __IO uint32_t  REG[16];             /*!< Slice data registers. Eachtime COUNT0 reaches 0x0 the register shifts loading bit 31 withdata captured from DIN(n). DOUT(n) is set to REG(0) */
+   __IO uint32_t  REG_SS[16];          /*!< Slice data shadow registers. Each time POSreaches 0x0 the contents of REG_SS is exchanged with the contentof REG */
+   __IO uint32_t  PRESET[16];          /*!< Reload valueof COUNT0, loaded when COUNT0 reaches 0x0 */
+   __IO uint32_t  COUNT[16];           /*!< Down counter, counts down each clock cycle. */
+   __IO uint32_t  POS[16];             /*!< Each time COUNT0 reaches 0x0 */
+   __IO uint32_t  MASK_A;              /*!< Mask for pattern match function of slice A */
+   __IO uint32_t  MASK_H;              /*!< Mask for pattern match function of slice H */
+   __IO uint32_t  MASK_I;              /*!< Mask for pattern match function of slice I */
+   __IO uint32_t  MASK_P;              /*!< Mask for pattern match function of slice P */
+   __I  uint32_t  GPIO_INREG;          /*!< GPIO input status register */
+   __IO uint32_t  GPIO_OUTREG;         /*!< GPIO output control register */
+   __IO uint32_t  GPIO_OENREG;         /*!< GPIO OE control register */
+   __IO uint32_t  CTRL_ENABLED;        /*!< Enables the slice COUNT counter */
+   __IO uint32_t  CTRL_DISABLED;       /*!< Disables the slice COUNT counter */
+   __I  uint32_t  RESERVED0[823];
+   __O  uint32_t  CLR_EN_0;            /*!< Shift clock interrupt clear mask */
+   __O  uint32_t  SET_EN_0;            /*!< Shift clock interrupt set mask */
+   __I  uint32_t  ENABLE_0;            /*!< Shift clock interrupt enable */
+   __I  uint32_t  STATUS_0;            /*!< Shift clock interrupt status */
+   __O  uint32_t  CTR_STATUS_0;        /*!< Shift clock interrupt clear status */
+   __O  uint32_t  SET_STATUS_0;        /*!< Shift clock interrupt set status */
+   __I  uint32_t  RESERVED1[2];
+   __O  uint32_t  CLR_EN_1;            /*!< Capture clock interrupt clear mask */
+   __O  uint32_t  SET_EN_1;            /*!< Capture clock interrupt set mask */
+   __I  uint32_t  ENABLE_1;            /*!< Capture clock interrupt enable */
+   __I  uint32_t  STATUS_1;            /*!< Capture clock interrupt status */
+   __O  uint32_t  CTR_STATUS_1;        /*!< Capture clock interrupt clear status */
+   __O  uint32_t  SET_STATUS_1;        /*!< Capture clock interrupt set status */
+   __I  uint32_t  RESERVED2[2];
+   __O  uint32_t  CLR_EN_2;            /*!< Pattern match interrupt clear mask */
+   __O  uint32_t  SET_EN_2;            /*!< Pattern match interrupt set mask */
+   __I  uint32_t  ENABLE_2;            /*!< Pattern match interrupt enable */
+   __I  uint32_t  STATUS_2;            /*!< Pattern match interrupt status */
+   __O  uint32_t  CTR_STATUS_2;        /*!< Pattern match interrupt clear status */
+   __O  uint32_t  SET_STATUS_2;        /*!< Pattern match interrupt set status */
+   __I  uint32_t  RESERVED3[2];
+   __O  uint32_t  CLR_EN_3;            /*!< Input interrupt clear mask */
+   __O  uint32_t  SET_EN_3;            /*!< Input bit match interrupt set mask */
+   __I  uint32_t  ENABLE_3;            /*!< Input bit match interrupt enable */
+   __I  uint32_t  STATUS_3;            /*!< Input bit match interrupt status */
+   __O  uint32_t  CTR_STATUS_3;        /*!< Input bit match interrupt clear status */
+   __O  uint32_t  SET_STATUS_3;        /*!< Shift clock interrupt set status */
+} LPC_SGPIO_T;
+
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SGPIO_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/spi_18xx_43xx.h ./lpc_chip_43xx/inc/spi_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/spi_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/spi_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,416 @@
+/*
+ * @brief LPC43xx SPI driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SPI_43XX_H_
+#define __SPI_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SPI_43XX CHIP: LPC43xx SPI driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * This module is present in LPC43xx MCUs only.
+ * @{
+ */
+#if defined(CHIP_LPC43XX)
+
+/**
+ * @brief SPI register block structure
+ */
+typedef struct {                   /*!< SPI Structure          */
+   __IO uint32_t  CR;              /*!< SPI Control Register. This register controls the operation of the SPI. */
+   __I  uint32_t  SR;              /*!< SPI Status Register. This register shows the status of the SPI. */
+   __IO uint32_t  DR;              /*!< SPI Data Register. This bi-directional register provides the transmit and receive data for the SPI. Transmit data is provided to the SPI0 by writing to this register. Data received by the SPI0 can be read from this register. */
+   __IO uint32_t  CCR;             /*!< SPI Clock Counter Register. This register controls the frequency of a master's SCK0. */
+   __I  uint32_t  RESERVED0[3];
+   __IO uint32_t  INT;             /*!< SPI Interrupt Flag. This register contains the interrupt flag for the SPI interface. */
+} LPC_SPI_T;
+
+/*
+ * Macro defines for SPI Control register
+ */
+/* SPI CFG Register BitMask */
+#define SPI_CR_BITMASK       ((uint32_t) 0xFFC)
+/** Enable of controlling the number of bits per transfer  */
+#define SPI_CR_BIT_EN         ((uint32_t) (1 << 2))
+/** Mask of field of bit controlling */
+#define SPI_CR_BITS_MASK      ((uint32_t) 0xF00)
+/** Set the number of bits per a transfer */
+#define SPI_CR_BITS(n)        ((uint32_t) ((n << 8) & 0xF00))  /* n is in range 8-16 */
+/** SPI Clock Phase Select*/
+#define SPI_CR_CPHA_FIRST     ((uint32_t) (0)) /*Capture data on the first edge, Change data on the following edge*/
+#define SPI_CR_CPHA_SECOND    ((uint32_t) (1 << 3))    /*Change data on the first edge, Capture data on the following edge*/
+/** SPI Clock Polarity Select*/
+#define SPI_CR_CPOL_LO        ((uint32_t) (0)) /* The rest state of the clock (between frames) is low.*/
+#define SPI_CR_CPOL_HI        ((uint32_t) (1 << 4))    /* The rest state of the clock (between frames) is high.*/
+/** SPI Slave Mode Select */
+#define SPI_CR_SLAVE_EN       ((uint32_t) 0)
+/** SPI Master Mode Select */
+#define SPI_CR_MASTER_EN      ((uint32_t) (1 << 5))
+/** SPI MSB First mode enable */
+#define SPI_CR_MSB_FIRST_EN   ((uint32_t) 0)   /*Data will be transmitted and received in standard order (MSB first).*/
+/** SPI LSB First mode enable */
+#define SPI_CR_LSB_FIRST_EN   ((uint32_t) (1 << 6))    /*Data will be transmitted and received in reverse order (LSB first).*/
+/** SPI interrupt enable */
+#define SPI_CR_INT_EN         ((uint32_t) (1 << 7))
+
+/*
+ * Macro defines for SPI Status register
+ */
+/** SPI STAT Register BitMask */
+#define SPI_SR_BITMASK        ((uint32_t) 0xF8)
+/** Slave abort Flag */
+#define SPI_SR_ABRT           ((uint32_t) (1 << 3))    /* When 1, this bit indicates that a slave abort has occurred. */
+/* Mode fault Flag */
+#define SPI_SR_MODF           ((uint32_t) (1 << 4))    /* when 1, this bit indicates that a Mode fault error has occurred. */
+/** Read overrun flag*/
+#define SPI_SR_ROVR           ((uint32_t) (1 << 5))    /* When 1, this bit indicates that a read overrun has occurred. */
+/** Write collision flag. */
+#define SPI_SR_WCOL           ((uint32_t) (1 << 6))    /* When 1, this bit indicates that a write collision has occurred.. */
+/** SPI transfer complete flag. */
+#define SPI_SR_SPIF           ((uint32_t) (1 << 7))        /* When 1, this bit indicates when a SPI data transfer is complete.. */
+/** SPI error flag */
+#define SPI_SR_ERROR          (SPI_SR_ABRT | SPI_SR_MODF | SPI_SR_ROVR | SPI_SR_WCOL)
+/*
+ * Macro defines for SPI Test Control Register register
+ */
+/*Enable SPI Test Mode */
+#define SPI_TCR_TEST(n)       ((uint32_t) ((n & 0x3F) << 1))
+
+/*
+ * Macro defines for SPI Interrupt register
+ */
+/** SPI interrupt flag */
+#define SPI_INT_SPIF          ((uint32_t) (1 << 0))
+
+/**
+ * Macro defines for SPI Data register
+ */
+/** Receiver Data  */
+#define SPI_DR_DATA(n)        ((uint32_t) ((n) & 0xFFFF))
+
+/** @brief SPI Mode*/
+typedef enum {
+   SPI_MODE_MASTER = SPI_CR_MASTER_EN,         /* Master Mode */
+   SPI_MODE_SLAVE = SPI_CR_SLAVE_EN,           /* Slave Mode */
+} SPI_MODE_T;
+
+/** @brief SPI Clock Mode*/
+typedef enum {
+   SPI_CLOCK_CPHA0_CPOL0 = SPI_CR_CPOL_LO | SPI_CR_CPHA_FIRST,     /**< CPHA = 0, CPOL = 0 */
+   SPI_CLOCK_CPHA0_CPOL1 = SPI_CR_CPOL_HI | SPI_CR_CPHA_FIRST,     /**< CPHA = 0, CPOL = 1 */
+   SPI_CLOCK_CPHA1_CPOL0 = SPI_CR_CPOL_LO | SPI_CR_CPHA_SECOND,    /**< CPHA = 1, CPOL = 0 */
+   SPI_CLOCK_CPHA1_CPOL1 = SPI_CR_CPOL_HI | SPI_CR_CPHA_SECOND,    /**< CPHA = 1, CPOL = 1 */
+   SPI_CLOCK_MODE0 = SPI_CLOCK_CPHA0_CPOL0,/**< alias */
+   SPI_CLOCK_MODE1 = SPI_CLOCK_CPHA1_CPOL0,/**< alias */
+   SPI_CLOCK_MODE2 = SPI_CLOCK_CPHA0_CPOL1,/**< alias */
+   SPI_CLOCK_MODE3 = SPI_CLOCK_CPHA1_CPOL1,/**< alias */
+} SPI_CLOCK_MODE_T;
+
+/** @brief SPI Data Order Mode*/
+typedef enum {
+   SPI_DATA_MSB_FIRST = SPI_CR_MSB_FIRST_EN,           /* Standard Order */
+   SPI_DATA_LSB_FIRST = SPI_CR_LSB_FIRST_EN,           /* Reverse Order */
+} SPI_DATA_ORDER_T;
+
+/*
+ * @brief Number of bits per frame
+ */
+typedef enum {
+   SPI_BITS_8 = SPI_CR_BITS(8),        /**< 8 bits/frame */
+   SPI_BITS_9 = SPI_CR_BITS(9),        /**< 9 bits/frame */
+   SPI_BITS_10 = SPI_CR_BITS(10),      /**< 10 bits/frame */
+   SPI_BITS_11 = SPI_CR_BITS(11),      /**< 11 bits/frame */
+   SPI_BITS_12 = SPI_CR_BITS(12),      /**< 12 bits/frame */
+   SPI_BITS_13 = SPI_CR_BITS(13),      /**< 13 bits/frame */
+   SPI_BITS_14 = SPI_CR_BITS(14),      /**< 14 bits/frame */
+   SPI_BITS_15 = SPI_CR_BITS(15),      /**< 15 bits/frame */
+   SPI_BITS_16 = SPI_CR_BITS(16),      /**< 16 bits/frame */
+} SPI_BITS_T;
+
+/** SPI callback function type*/
+typedef void (*SPI_CALLBACK_T)(void);
+/*
+ * @brief SPI config format
+ */
+typedef struct {
+   SPI_BITS_T bits;                        /*!< bits/frame */
+   SPI_CLOCK_MODE_T clockMode; /*!< Format config: clock phase/polarity */
+   SPI_DATA_ORDER_T dataOrder; /*!< Data order (MSB first/LSB first) */
+} SPI_CONFIG_FORMAT_T;
+
+/*
+ * @brief SPI data setup structure
+ */
+typedef struct {
+   uint8_t      *pTxData;                  /*!< Pointer to transmit data */
+   uint8_t      *pRxData;                  /*!< Pointer to receive data */
+   uint32_t  cnt;                          /*!< Transfer counter */
+   uint32_t  length;                       /*!< Length of transfer data */
+   SPI_CALLBACK_T    fnBefFrame;               /*!< Function to call before sending frame */
+   SPI_CALLBACK_T    fnAftFrame;               /*!< Function to call after sending frame */
+   SPI_CALLBACK_T    fnBefTransfer;            /*!< Function to call before starting a transfer */
+   SPI_CALLBACK_T    fnAftTransfer;            /*!< Function to call after a transfer complete */
+} SPI_DATA_SETUP_T;
+
+/**
+ * @brief  Get the current status of SPI controller
+ * @return SPI controller status (Or-ed value of SPI_SR_*)
+ */
+STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
+{
+   return pSPI->SR;
+}
+
+/**
+ * @brief  Send SPI 16-bit data
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @param  data    : Transmit Data
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SPI_SendFrame(LPC_SPI_T *pSPI, uint16_t data)
+{
+   pSPI->DR = SPI_DR_DATA(data);
+}
+
+/**
+ * @brief  Get received SPI data
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @return receive data
+ */
+STATIC INLINE uint16_t Chip_SPI_ReceiveFrame(LPC_SPI_T *pSPI)
+{
+   return SPI_DR_DATA(pSPI->DR);
+}
+
+/**
+ * @brief  Set up output clocks per bit for SPI bus
+ * @param  pSPI        : The base of SPI peripheral on the chip
+ * @param  counter : the number of SPI peripheral clock cycles that make up an SPI clock
+ * @return  Nothing
+ * @note   The counter must be an even number greater than or equal to 8. <br>
+ *     The SPI SCK rate = PCLK_SPI / counter.
+ */
+STATIC INLINE void Chip_SPI_SetClockCounter(LPC_SPI_T *pSPI, uint32_t counter)
+{
+   pSPI->CCR = counter;
+}
+
+/**
+ * @brief   Set up the SPI frame format
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  format          : Pointer to Frame format structure
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SPI_SetFormat(LPC_SPI_T *pSPI, SPI_CONFIG_FORMAT_T *format)
+{
+   pSPI->CR = (pSPI->CR & (~0xF1C)) | SPI_CR_BIT_EN | format->bits | format->clockMode | format->dataOrder;
+}
+
+/**
+ * @brief  Get the number of bits transferred in each frame
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @return  the number of bits transferred in each frame
+ */
+STATIC INLINE SPI_BITS_T Chip_SPI_GetDataSize(LPC_SPI_T *pSPI)
+{
+   return (pSPI->CR & SPI_CR_BIT_EN) ? ((SPI_BITS_T) (pSPI->CR & SPI_CR_BITS_MASK)) : SPI_BITS_8;
+}
+
+/**
+ * @brief  Get the current CPHA & CPOL setting
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @return CPHA & CPOL setting
+ */
+STATIC INLINE SPI_CLOCK_MODE_T Chip_SPI_GetClockMode(LPC_SPI_T *pSPI)
+{
+   return (SPI_CLOCK_MODE_T) (pSPI->CR & (3 << 3));
+}
+
+/**
+ * @brief  Set the SPI working as master or slave mode
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @return  Operating mode
+ */
+STATIC INLINE SPI_MODE_T Chip_SPI_GetMode(LPC_SPI_T *pSPI)
+{
+   return (SPI_MODE_T) (pSPI->CR & (1 << 5));
+}
+
+/**
+ * @brief   Set the SPI operating modes, master or slave
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  mode        : master mode/slave mode
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SPI_SetMode(LPC_SPI_T *pSPI, SPI_MODE_T mode)
+{
+   pSPI->CR = (pSPI->CR & (~(1 << 5))) | mode;
+}
+
+/**
+ * @brief   Set the clock frequency for SPI interface
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  bitRate     : The SPI bit rate
+ * @return Nothing
+ */
+void Chip_SPI_SetBitRate(LPC_SPI_T *pSPI, uint32_t bitRate);
+
+/**
+ * @brief   Enable SPI interrupt
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SPI_Int_Enable(LPC_SPI_T *pSPI)
+{
+   pSPI->CR |= SPI_CR_INT_EN;
+}
+
+/**
+ * @brief   Disable SPI interrupt
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SPI_Int_Disable(LPC_SPI_T *pSPI)
+{
+   pSPI->CR &= ~SPI_CR_INT_EN;
+}
+
+/**
+ * @brief  Get the interrupt status
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @return SPI interrupt Status (Or-ed bit value of SPI_INT_*)
+ */
+STATIC INLINE uint32_t Chip_SPI_Int_GetStatus(LPC_SPI_T *pSPI)
+{
+   return pSPI->INT;
+}
+
+/**
+ * @brief  Clear the interrupt status
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @param  mask    : SPI interrupt mask (Or-ed bit value of SPI_INT_*)
+ * @return Nothing
+ */
+STATIC INLINE void Chip_SPI_Int_ClearStatus(LPC_SPI_T *pSPI, uint32_t mask)
+{
+   pSPI->INT = mask;
+}
+
+/**
+ * @brief   Initialize the SPI
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @return Nothing
+ */
+void Chip_SPI_Init(LPC_SPI_T *pSPI);
+
+/**
+ * @brief  Deinitialise the SPI
+ * @param  pSPI    : The base of SPI peripheral on the chip
+ * @return Nothing
+ * @note   The SPI controller is disabled
+ */
+void Chip_SPI_DeInit(LPC_SPI_T *pSPI);
+
+/**
+ * @brief   Clean all data in RX FIFO of SPI
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @return Nothing
+ */
+void Chip_SPI_Int_FlushData(LPC_SPI_T *pSPI);
+
+/**
+ * @brief   SPI Interrupt Read/Write with 8-bit frame width
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  xf_setup        : Pointer to a SPI_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data    configuration
+ * @return SUCCESS or ERROR
+ */
+Status Chip_SPI_Int_RWFrames8Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SPI Interrupt Read/Write with 16-bit frame width
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  xf_setup        : Pointer to a SPI_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data    configuration
+ * @return SUCCESS or ERROR
+ */
+Status Chip_SPI_Int_RWFrames16Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SPI Polling Read/Write in blocking mode
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  pXfSetup        : Pointer to a SPI_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data    configuration
+ * @return Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. It starts with writing phase and after that,
+ * a reading phase is generated to read any data available in RX_FIFO. All needed information is prepared
+ * through xf_setup param.
+ */
+uint32_t Chip_SPI_RWFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup);
+
+/**
+ * @brief   SPI Polling Write in blocking mode
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  buffer          : Buffer address
+ * @param  buffer_len      : Buffer length
+ * @return Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a writing operation will send
+ * the needed data. After that, a dummy reading operation is generated to clear data buffer
+ */
+uint32_t Chip_SPI_WriteFrames_Blocking(LPC_SPI_T *pSPI, uint8_t *buffer, uint32_t buffer_len);
+
+/**
+ * @brief   SPI Polling Read in blocking mode
+ * @param  pSPI            : The base SPI peripheral on the chip
+ * @param  buffer          : Buffer address
+ * @param  buffer_len      : The length of buffer
+ * @return Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a dummy writing operation is generated
+ * to clear data buffer. After that, a reading operation will receive the needed data
+ */
+uint32_t Chip_SPI_ReadFrames_Blocking(LPC_SPI_T *pSPI, uint8_t *buffer, uint32_t buffer_len);
+
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SPI_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/ssp_18xx_43xx.h ./lpc_chip_43xx/inc/ssp_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/ssp_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/ssp_18xx_43xx.h	2018-01-19 23:55:10.976318592 -0300
@@ -0,0 +1,598 @@
+/*
+ * @brief LPC18xx/43xx SSP driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SSP_18XX_43XX_H_
+#define __SSP_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SSP_18XX_43XX CHIP: LPC18xx/43xx SSP driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief SSP register block structure
+ */
+typedef struct {           /*!< SSPn Structure         */
+   __IO uint32_t CR0;      /*!< Control Register 0. Selects the serial clock rate, bus type, and data size. */
+   __IO uint32_t CR1;      /*!< Control Register 1. Selects master/slave and other modes. */
+   __IO uint32_t DR;       /*!< Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO. */
+   __I  uint32_t SR;       /*!< Status Register        */
+   __IO uint32_t CPSR;     /*!< Clock Prescale Register */
+   __IO uint32_t IMSC;     /*!< Interrupt Mask Set and Clear Register */
+   __I  uint32_t RIS;      /*!< Raw Interrupt Status Register */
+   __I  uint32_t MIS;      /*!< Masked Interrupt Status Register */
+   __O  uint32_t ICR;      /*!< SSPICR Interrupt Clear Register */
+   __IO uint32_t DMACR;    /*!< SSPn DMA control register */
+} LPC_SSP_T;
+
+/**
+ * Macro defines for CR0 register
+ */
+
+/** SSP data size select, must be 4 bits to 16 bits */
+#define SSP_CR0_DSS(n)          ((uint32_t) ((n) & 0xF))
+/** SSP control 0 Motorola SPI mode */
+#define SSP_CR0_FRF_SPI         ((uint32_t) (0 << 4))
+/** SSP control 0 TI synchronous serial mode */
+#define SSP_CR0_FRF_TI          ((uint32_t) (1 << 4))
+/** SSP control 0 National Micro-wire mode */
+#define SSP_CR0_FRF_MICROWIRE   ((uint32_t) (2 << 4))
+/** SPI clock polarity bit (used in SPI mode only), (1) = maintains the
+   bus clock high between frames, (0) = low */
+#define SSP_CR0_CPOL_LO     ((uint32_t) (0))
+#define SSP_CR0_CPOL_HI     ((uint32_t) (1 << 6))
+/** SPI clock out phase bit (used in SPI mode only), (1) = captures data
+   on the second clock transition of the frame, (0) = first */
+#define SSP_CR0_CPHA_FIRST  ((uint32_t) (0))
+#define SSP_CR0_CPHA_SECOND ((uint32_t) (1 << 7))
+/** SSP serial clock rate value load macro, divider rate is
+   PERIPH_CLK / (cpsr * (SCR + 1)) */
+#define SSP_CR0_SCR(n)      ((uint32_t) ((n & 0xFF) << 8))
+/** SSP CR0 bit mask */
+#define SSP_CR0_BITMASK     ((uint32_t) (0xFFFF))
+/** SSP CR0 bit mask */
+#define SSP_CR0_BITMASK     ((uint32_t) (0xFFFF))
+/** SSP serial clock rate value load macro, divider rate is
+   PERIPH_CLK / (cpsr * (SCR + 1)) */
+#define SSP_CR0_SCR(n)      ((uint32_t) ((n & 0xFF) << 8))
+
+/**
+ * Macro defines for CR1 register
+ */
+
+/** SSP control 1 loopback mode enable bit */
+#define SSP_CR1_LBM_EN      ((uint32_t) (1 << 0))
+/** SSP control 1 enable bit */
+#define SSP_CR1_SSP_EN      ((uint32_t) (1 << 1))
+/** SSP control 1 slave enable */
+#define SSP_CR1_SLAVE_EN    ((uint32_t) (1 << 2))
+#define SSP_CR1_MASTER_EN   ((uint32_t) (0))
+/** SSP control 1 slave out disable bit, disables transmit line in slave
+   mode */
+#define SSP_CR1_SO_DISABLE  ((uint32_t) (1 << 3))
+/** SSP CR1 bit mask */
+#define SSP_CR1_BITMASK     ((uint32_t) (0x0F))
+
+/** SSP CPSR bit mask */
+#define SSP_CPSR_BITMASK    ((uint32_t) (0xFF))
+/**
+ * Macro defines for DR register
+ */
+
+/** SSP data bit mask */
+#define SSP_DR_BITMASK(n)   ((n) & 0xFFFF)
+
+/**
+ * Macro defines for SR register
+ */
+
+/** SSP SR bit mask */
+#define SSP_SR_BITMASK  ((uint32_t) (0x1F))
+
+/** ICR bit mask */
+#define SSP_ICR_BITMASK ((uint32_t) (0x03))
+
+/**
+ * @brief SSP Type of Status
+ */
+typedef enum _SSP_STATUS {
+   SSP_STAT_TFE = ((uint32_t)(1 << 0)),/**< TX FIFO Empty */
+   SSP_STAT_TNF = ((uint32_t)(1 << 1)),/**< TX FIFO not full */
+   SSP_STAT_RNE = ((uint32_t)(1 << 2)),/**< RX FIFO not empty */
+   SSP_STAT_RFF = ((uint32_t)(1 << 3)),/**< RX FIFO full */
+   SSP_STAT_BSY = ((uint32_t)(1 << 4)),/**< SSP Busy */
+} SSP_STATUS_T;
+
+/**
+ * @brief SSP Type of Interrupt Mask
+ */
+typedef enum _SSP_INTMASK {
+   SSP_RORIM = ((uint32_t)(1 << 0)),   /**< Overun */
+   SSP_RTIM = ((uint32_t)(1 << 1)),/**< TimeOut */
+   SSP_RXIM = ((uint32_t)(1 << 2)),/**< Rx FIFO is at least half full */
+   SSP_TXIM = ((uint32_t)(1 << 3)),/**< Tx FIFO is at least half empty */
+   SSP_INT_MASK_BITMASK = ((uint32_t)(0xF)),
+} SSP_INTMASK_T;
+
+/**
+ * @brief SSP Type of Mask Interrupt Status
+ */
+typedef enum _SSP_MASKINTSTATUS {
+   SSP_RORMIS = ((uint32_t)(1 << 0)),  /**< Overun */
+   SSP_RTMIS = ((uint32_t)(1 << 1)),   /**< TimeOut */
+   SSP_RXMIS = ((uint32_t)(1 << 2)),   /**< Rx FIFO is at least half full */
+   SSP_TXMIS = ((uint32_t)(1 << 3)),   /**< Tx FIFO is at least half empty */
+   SSP_MASK_INT_STAT_BITMASK = ((uint32_t)(0xF)),
+} SSP_MASKINTSTATUS_T;
+
+/**
+ * @brief SSP Type of Raw Interrupt Status
+ */
+typedef enum _SSP_RAWINTSTATUS {
+   SSP_RORRIS = ((uint32_t)(1 << 0)),  /**< Overun */
+   SSP_RTRIS = ((uint32_t)(1 << 1)),   /**< TimeOut */
+   SSP_RXRIS = ((uint32_t)(1 << 2)),   /**< Rx FIFO is at least half full */
+   SSP_TXRIS = ((uint32_t)(1 << 3)),   /**< Tx FIFO is at least half empty */
+   SSP_RAW_INT_STAT_BITMASK = ((uint32_t)(0xF)),
+} SSP_RAWINTSTATUS_T;
+
+typedef enum _SSP_INTCLEAR {
+   SSP_RORIC = 0x0,
+   SSP_RTIC = 0x1,
+   SSP_INT_CLEAR_BITMASK = 0x3,
+} SSP_INTCLEAR_T;
+
+typedef enum _SSP_DMA {
+   SSP_DMA_RX = (1u),  /**< DMA RX Enable */
+   SSP_DMA_TX = (1u << 1), /**< DMA TX Enable */
+   SSP_DMA_BITMASK = ((uint32_t)(0x3)),
+} SSP_DMA_T;
+
+/*
+ * @brief SSP clock format
+ */
+typedef enum CHIP_SSP_CLOCK_FORMAT {
+   SSP_CLOCK_CPHA0_CPOL0 = (0 << 6),       /**< CPHA = 0, CPOL = 0 */
+   SSP_CLOCK_CPHA0_CPOL1 = (1u << 6),      /**< CPHA = 0, CPOL = 1 */
+   SSP_CLOCK_CPHA1_CPOL0 = (2u << 6),      /**< CPHA = 1, CPOL = 0 */
+   SSP_CLOCK_CPHA1_CPOL1 = (3u << 6),      /**< CPHA = 1, CPOL = 1 */
+   SSP_CLOCK_MODE0 = SSP_CLOCK_CPHA0_CPOL0,/**< alias */
+   SSP_CLOCK_MODE1 = SSP_CLOCK_CPHA1_CPOL0,/**< alias */
+   SSP_CLOCK_MODE2 = SSP_CLOCK_CPHA0_CPOL1,/**< alias */
+   SSP_CLOCK_MODE3 = SSP_CLOCK_CPHA1_CPOL1,/**< alias */
+} CHIP_SSP_CLOCK_MODE_T;
+
+/*
+ * @brief SSP frame format
+ */
+typedef enum CHIP_SSP_FRAME_FORMAT {
+   SSP_FRAMEFORMAT_SPI = (0 << 4),         /**< Frame format: SPI */
+   CHIP_SSP_FRAME_FORMAT_TI = (1u << 4),           /**< Frame format: TI SSI */
+   SSP_FRAMEFORMAT_MICROWIRE = (2u << 4),  /**< Frame format: Microwire */
+} CHIP_SSP_FRAME_FORMAT_T;
+
+/*
+ * @brief Number of bits per frame
+ */
+typedef enum CHIP_SSP_BITS {
+   SSP_BITS_4 = (3u << 0),     /*!< 4 bits/frame */
+   SSP_BITS_5 = (4u << 0),     /*!< 5 bits/frame */
+   SSP_BITS_6 = (5u << 0),     /*!< 6 bits/frame */
+   SSP_BITS_7 = (6u << 0),     /*!< 7 bits/frame */
+   SSP_BITS_8 = (7u << 0),     /*!< 8 bits/frame */
+   SSP_BITS_9 = (8u << 0),     /*!< 9 bits/frame */
+   SSP_BITS_10 = (9u << 0),    /*!< 10 bits/frame */
+   SSP_BITS_11 = (10u << 0),   /*!< 11 bits/frame */
+   SSP_BITS_12 = (11u << 0),   /*!< 12 bits/frame */
+   SSP_BITS_13 = (12u << 0),   /*!< 13 bits/frame */
+   SSP_BITS_14 = (13u << 0),   /*!< 14 bits/frame */
+   SSP_BITS_15 = (14u << 0),   /*!< 15 bits/frame */
+   SSP_BITS_16 = (15u << 0),   /*!< 16 bits/frame */
+} CHIP_SSP_BITS_T;
+
+/*
+ * @brief SSP config format
+ */
+typedef struct SSP_ConfigFormat {
+   CHIP_SSP_BITS_T bits;                   /*!< Format config: bits/frame */
+   CHIP_SSP_CLOCK_MODE_T clockMode;    /*!< Format config: clock phase/polarity */
+   CHIP_SSP_FRAME_FORMAT_T frameFormat;    /*!< Format config: SPI/TI/Microwire */
+} SSP_ConfigFormat;
+
+/**
+ * @brief  Enable SSP operation
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_Enable(LPC_SSP_T *pSSP)
+{
+   pSSP->CR1 |= SSP_CR1_SSP_EN;
+}
+
+/**
+ * @brief  Disable SSP operation
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_Disable(LPC_SSP_T *pSSP)
+{
+   pSSP->CR1 &= (~SSP_CR1_SSP_EN) & SSP_CR1_BITMASK;
+}
+
+/**
+ * @brief  Enable loopback mode
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @return  Nothing
+ * @note   Serial input is taken from the serial output (MOSI or MISO) rather
+ * than the serial input pin
+ */
+STATIC INLINE void Chip_SSP_EnableLoopBack(LPC_SSP_T *pSSP)
+{
+   pSSP->CR1 |= SSP_CR1_LBM_EN;
+}
+
+/**
+ * @brief  Disable loopback mode
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @return  Nothing
+ * @note   Serial input is taken from the serial output (MOSI or MISO) rather
+ * than the serial input pin
+ */
+STATIC INLINE void Chip_SSP_DisableLoopBack(LPC_SSP_T *pSSP)
+{
+   pSSP->CR1 &= (~SSP_CR1_LBM_EN) & SSP_CR1_BITMASK;
+}
+
+/**
+ * @brief  Get the current status of SSP controller
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @param  Stat    : Type of status, should be :
+ *                     - SSP_STAT_TFE
+ *                     - SSP_STAT_TNF
+ *                     - SSP_STAT_RNE
+ *                     - SSP_STAT_RFF
+ *                     - SSP_STAT_BSY
+ * @return  SSP controller status, SET or RESET
+ */
+STATIC INLINE FlagStatus Chip_SSP_GetStatus(LPC_SSP_T *pSSP, SSP_STATUS_T Stat)
+{
+   return (pSSP->SR & Stat) ? SET : RESET;
+}
+
+/**
+ * @brief  Get the masked interrupt status
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @return  SSP Masked Interrupt Status Register value
+ * @note   The return value contains a 1 for each interrupt condition that is asserted and enabled (masked)
+ */
+STATIC INLINE uint32_t Chip_SSP_GetIntStatus(LPC_SSP_T *pSSP)
+{
+   return pSSP->MIS;
+}
+
+/**
+ * @brief  Get the raw interrupt status
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @param  RawInt  : Interrupt condition to be get status, shoud be :
+ *                     - SSP_RORRIS
+ *                     - SSP_RTRIS
+ *                     - SSP_RXRIS
+ *                     - SSP_TXRIS
+ * @return  Raw interrupt status corresponding to interrupt condition , SET or RESET
+ * @note   Get the status of each interrupt condition ,regardless of whether or not the interrupt is enabled
+ */
+STATIC INLINE IntStatus Chip_SSP_GetRawIntStatus(LPC_SSP_T *pSSP, SSP_RAWINTSTATUS_T RawInt)
+{
+   return (pSSP->RIS & RawInt) ? SET : RESET;
+}
+
+/**
+ * @brief  Get the number of bits transferred in each frame
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @return  the number of bits transferred in each frame minus one
+ * @note   The return value is 0x03 -> 0xF corresponding to 4bit -> 16bit transfer
+ */
+STATIC INLINE uint8_t Chip_SSP_GetDataSize(LPC_SSP_T *pSSP)
+{
+   return SSP_CR0_DSS(pSSP->CR0);
+}
+
+/**
+ * @brief  Clear the corresponding interrupt condition(s) in the SSP controller
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @param  IntClear: Type of cleared interrupt, should be :
+ *                     - SSP_RORIC
+ *                     - SSP_RTIC
+ * @return  Nothing
+ * @note   Software can clear one or more interrupt condition(s) in the SSP controller
+ */
+STATIC INLINE void Chip_SSP_ClearIntPending(LPC_SSP_T *pSSP, SSP_INTCLEAR_T IntClear)
+{
+   pSSP->ICR = IntClear;
+}
+
+/**
+ * @brief  Enable interrupt for the SSP
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_Int_Enable(LPC_SSP_T *pSSP)
+{
+   pSSP->IMSC |= SSP_TXIM;
+}
+
+/**
+ * @brief  Disable interrupt for the SSP
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_Int_Disable(LPC_SSP_T *pSSP)
+{
+   pSSP->IMSC &= (~SSP_TXIM);
+}
+
+/**
+ * @brief  Get received SSP data
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @return  SSP 16-bit data received
+ */
+STATIC INLINE uint16_t Chip_SSP_ReceiveFrame(LPC_SSP_T *pSSP)
+{
+   return (uint16_t) (SSP_DR_BITMASK(pSSP->DR));
+}
+
+/**
+ * @brief  Send SSP 16-bit data
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @param  tx_data : SSP 16-bit data to be transmited
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_SendFrame(LPC_SSP_T *pSSP, uint16_t tx_data)
+{
+   pSSP->DR = SSP_DR_BITMASK(tx_data);
+}
+
+/**
+ * @brief  Set up output clocks per bit for SSP bus
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @param  clk_rate    fs: The number of prescaler-output clocks per bit on the bus, minus one
+ * @param  prescale    : The factor by which the Prescaler divides the SSP peripheral clock PCLK
+ * @return  Nothing
+ * @note   The bit frequency is PCLK / (prescale x[clk_rate+1])
+ */
+void Chip_SSP_SetClockRate(LPC_SSP_T *pSSP, uint32_t clk_rate, uint32_t prescale);
+
+/**
+ * @brief  Set up the SSP frame format
+ * @param  pSSP        : The base of SSP peripheral on the chip
+ * @param  bits        : The number of bits transferred in each frame, should be SSP_BITS_4 to SSP_BITS_16
+ * @param  frameFormat : Frame format, should be :
+ *                         - SSP_FRAMEFORMAT_SPI
+ *                         - SSP_FRAME_FORMAT_TI
+ *                         - SSP_FRAMEFORMAT_MICROWIRE
+ * @param  clockMode   : Select Clock polarity and Clock phase, should be :
+ *                         - SSP_CLOCK_CPHA0_CPOL0
+ *                         - SSP_CLOCK_CPHA0_CPOL1
+ *                         - SSP_CLOCK_CPHA1_CPOL0
+ *                         - SSP_CLOCK_CPHA1_CPOL1
+ * @return  Nothing
+ * @note   Note: The clockFormat is only used in SPI mode
+ */
+STATIC INLINE void Chip_SSP_SetFormat(LPC_SSP_T *pSSP, uint32_t bits, uint32_t frameFormat, uint32_t clockMode)
+{
+   pSSP->CR0 = (pSSP->CR0 & ~0xFF) | bits | frameFormat | clockMode;
+}
+
+/**
+ * @brief  Set the SSP working as master or slave mode
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @param  mode    : Operating mode, should be
+ *                     - SSP_MODE_MASTER
+ *                     - SSP_MODE_SLAVE
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_Set_Mode(LPC_SSP_T *pSSP, uint32_t mode)
+{
+   pSSP->CR1 = (pSSP->CR1 & ~(1 << 2)) | mode;
+}
+
+/**
+ * @brief  Enable DMA for SSP
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_DMA_Enable(LPC_SSP_T *pSSP)
+{
+   pSSP->DMACR |= SSP_DMA_BITMASK;
+}
+
+/**
+ * @brief  Disable DMA for SSP
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @return  Nothing
+ */
+STATIC INLINE void Chip_SSP_DMA_Disable(LPC_SSP_T *pSSP)
+{
+   pSSP->DMACR &= ~SSP_DMA_BITMASK;
+}
+
+/*
+ * @brief SSP mode
+ */
+typedef enum CHIP_SSP_MODE {
+   SSP_MODE_MASTER = (0 << 2), /**< Master mode */
+   SSP_MODE_SLAVE = (1u << 2), /**< Slave mode */
+} CHIP_SSP_MODE_T;
+
+/*
+ * @brief SPI address
+ */
+typedef struct {
+   uint8_t port;   /*!< Port Number */
+   uint8_t pin;    /*!< Pin number */
+} SPI_Address_t;
+
+/*
+ * @brief SSP data setup structure
+ */
+typedef struct {
+   void      *tx_data; /*!< Pointer to transmit data */
+   uint32_t  tx_cnt;   /*!< Transmit counter */
+   void      *rx_data; /*!< Pointer to transmit data */
+   uint32_t  rx_cnt;   /*!< Receive counter */
+   uint32_t  length;   /*!< Length of transfer data */
+} Chip_SSP_DATA_SETUP_T;
+
+/** SSP configuration parameter defines */
+/** Clock phase control bit */
+#define SSP_CPHA_FIRST          SSP_CR0_CPHA_FIRST
+#define SSP_CPHA_SECOND         SSP_CR0_CPHA_SECOND
+
+/** Clock polarity control bit */
+/* There's no bug here!!!
+ * - If bit[6] in SSPnCR0 is 0: SSP controller maintains the bus clock low between frames.
+ * That means the active clock is in HI state.
+ * - If bit[6] in SSPnCR0 is 1 (SSP_CR0_CPOL_HI): SSP controller maintains the bus clock
+ * high between frames. That means the active clock is in LO state.
+ */
+#define SSP_CPOL_HI             SSP_CR0_CPOL_LO
+#define SSP_CPOL_LO             SSP_CR0_CPOL_HI
+
+/** SSP master mode enable */
+#define SSP_SLAVE_MODE          SSP_CR1_SLAVE_EN
+#define SSP_MASTER_MODE         SSP_CR1_MASTER_EN
+
+/**
+ * @brief   Clean all data in RX FIFO of SSP
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @return Nothing
+ */
+void Chip_SSP_Int_FlushData(LPC_SSP_T *pSSP);
+
+/**
+ * @brief   SSP Interrupt Read/Write with 8-bit frame width
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  xf_setup        : Pointer to a SSP_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data    configuration
+ * @return SUCCESS or ERROR
+ */
+Status Chip_SSP_Int_RWFrames8Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SSP Interrupt Read/Write with 16-bit frame width
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  xf_setup        : Pointer to a SSP_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data    configuration
+ * @return SUCCESS or ERROR
+ */
+Status Chip_SSP_Int_RWFrames16Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SSP Polling Read/Write in blocking mode
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  xf_setup        : Pointer to a SSP_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data    configuration
+ * @return Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. It starts with writing phase and after that,
+ * a reading phase is generated to read any data available in RX_FIFO. All needed information is prepared
+ * through xf_setup param.
+ */
+uint32_t Chip_SSP_RWFrames_Blocking(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SSP Polling Write in blocking mode
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  buffer          : Buffer address
+ * @param  buffer_len      : Buffer length
+ * @return Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a writing operation will send
+ * the needed data. After that, a dummy reading operation is generated to clear data buffer
+ */
+uint32_t Chip_SSP_WriteFrames_Blocking(LPC_SSP_T *pSSP, const uint8_t *buffer, uint32_t buffer_len);
+
+/**
+ * @brief   SSP Polling Read in blocking mode
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  buffer          : Buffer address
+ * @param  buffer_len      : The length of buffer
+ * @return Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a dummy writing operation is generated
+ * to clear data buffer. After that, a reading operation will receive the needed data
+ */
+uint32_t Chip_SSP_ReadFrames_Blocking(LPC_SSP_T *pSSP, uint8_t *buffer, uint32_t buffer_len);
+
+/**
+ * @brief   Initialize the SSP
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @return Nothing
+ */
+void Chip_SSP_Init(LPC_SSP_T *pSSP);
+
+/**
+ * @brief  Deinitialise the SSP
+ * @param  pSSP    : The base of SSP peripheral on the chip
+ * @return Nothing
+ * @note   The SSP controller is disabled
+ */
+void Chip_SSP_DeInit(LPC_SSP_T *pSSP);
+
+/**
+ * @brief   Set the SSP operating modes, master or slave
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  master          : 1 to set master, 0 to set slave
+ * @return Nothing
+ */
+void Chip_SSP_SetMaster(LPC_SSP_T *pSSP, bool master);
+
+/**
+ * @brief   Set the clock frequency for SSP interface
+ * @param  pSSP            : The base SSP peripheral on the chip
+ * @param  bitRate     : The SSP bit rate
+ * @return Nothing
+ */
+void Chip_SSP_SetBitRate(LPC_SSP_T *pSSP, uint32_t bitRate);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SSP_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/stopwatch.h ./lpc_chip_43xx/inc/stopwatch.h
--- a_qSC69Z/lpc_chip_43xx/inc/stopwatch.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/stopwatch.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,137 @@
+/*
+ * @brief Common stopwatch support
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __STOPWATCH_H_
+#define __STOPWATCH_H_
+
+#include "cmsis.h"
+
+/** @defgroup Stop_Watch CHIP: Stopwatch primitives.
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief  Initialize stopwatch
+ * @return Nothing
+ */
+void StopWatch_Init(void);
+
+/**
+ * @brief  Start a stopwatch
+ * @return Current cycle count
+ */
+uint32_t StopWatch_Start(void);
+
+/**
+ * @brief      Returns number of ticks elapsed since stopwatch was started
+ * @param      startTime   : Time returned by StopWatch_Start().
+ * @return     Number of ticks elapsed since stopwatch was started
+ */
+STATIC INLINE uint32_t StopWatch_Elapsed(uint32_t startTime)
+{
+   return StopWatch_Start() - startTime;
+}
+
+/**
+ * @brief  Returns number of ticks per second of the stopwatch timer
+ * @return Number of ticks per second of the stopwatch timer
+ */
+uint32_t StopWatch_TicksPerSecond(void);
+
+/**
+ * @brief  Converts from stopwatch ticks to mS.
+ * @param  ticks   : Duration in ticks to convert to mS.
+ * @return Number of mS in given number of ticks
+ */
+uint32_t StopWatch_TicksToMs(uint32_t ticks);
+
+/**
+ * @brief  Converts from stopwatch ticks to uS.
+ * @param  ticks   : Duration in ticks to convert to uS.
+ * @return Number of uS in given number of ticks
+ */
+uint32_t StopWatch_TicksToUs(uint32_t ticks);
+
+/**
+ * @brief  Converts from mS to stopwatch ticks.
+ * @param  mS  : Duration in mS to convert to ticks.
+ * @return Number of ticks in given number of mS
+ */
+uint32_t StopWatch_MsToTicks(uint32_t mS);
+
+/**
+ * @brief  Converts from uS to stopwatch ticks.
+ * @param  uS  : Duration in uS to convert to ticks.
+ * @return Number of ticks in given number of uS
+ */
+uint32_t StopWatch_UsToTicks(uint32_t uS);
+
+/**
+ * @brief  Delays the given number of ticks using stopwatch primitives
+ * @param  ticks   : Number of ticks to delay
+ * @return Nothing
+ */
+STATIC INLINE void StopWatch_DelayTicks(uint32_t ticks)
+{
+   uint32_t startTime = StopWatch_Start();
+   while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @brief  Delays the given number of mS using stopwatch primitives
+ * @param  mS  : Number of mS to delay
+ * @return Nothing
+ */
+STATIC INLINE void StopWatch_DelayMs(uint32_t mS)
+{
+   uint32_t ticks = StopWatch_MsToTicks(mS);
+   uint32_t startTime = StopWatch_Start();
+   while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @brief  Delays the given number of uS using stopwatch primitives
+ * @param  uS  : Number of uS to delay
+ * @return Nothing
+ */
+STATIC INLINE void StopWatch_DelayUs(uint32_t uS)
+{
+   uint32_t ticks = StopWatch_UsToTicks(uS);
+   uint32_t startTime = StopWatch_Start();
+   while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @}
+ */
+
+#endif /* __STOPWATCH_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/sys_config.h ./lpc_chip_43xx/inc/sys_config.h
--- a_qSC69Z/lpc_chip_43xx/inc/sys_config.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/sys_config.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,36 @@
+/*
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SYS_CONFIG_H_
+#define __SYS_CONFIG_H_
+
+/* LPC43xx chip family */
+#define CHIP_LPC43XX
+
+#endif /* __SYS_CONFIG_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/timer_18xx_43xx.h ./lpc_chip_43xx/inc/timer_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/timer_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/timer_18xx_43xx.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,445 @@
+/*
+ * @brief LPC18xx/43xx 16/32-bit Timer/PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __TIMER_18XX_43XX_H_
+#define __TIMER_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup TIMER_18XX_43XX CHIP: LPC18xx/43xx 16/32-bit Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief 32-bit Standard timer register block structure
+ */
+typedef struct {                   /*!< TIMERn Structure       */
+   __IO uint32_t IR;               /*!< Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending. */
+   __IO uint32_t TCR;              /*!< Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR. */
+   __IO uint32_t TC;               /*!< Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR. */
+   __IO uint32_t PR;               /*!< Prescale Register. The Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC. */
+   __IO uint32_t PC;               /*!< Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface. */
+   __IO uint32_t MCR;              /*!< Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs. */
+   __IO uint32_t MR[4];            /*!< Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC. */
+   __IO uint32_t CCR;              /*!< Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place. */
+   __IO uint32_t CR[4];            /*!< Capture Register. CR is loaded with the value of TC when there is an event on the CAPn.0 input. */
+   __IO uint32_t EMR;              /*!< External Match Register. The EMR controls the external match pins MATn.0-3 (MAT0.0-3 and MAT1.0-3 respectively). */
+   __I  uint32_t RESERVED0[12];
+   __IO uint32_t CTCR;             /*!< Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting. */
+} LPC_TIMER_T;
+
+/** Macro to clear interrupt pending */
+#define TIMER_IR_CLR(n)         _BIT(n)
+
+/** Macro for getting a timer match interrupt bit */
+#define TIMER_MATCH_INT(n)      (_BIT((n) & 0x0F))
+/** Macro for getting a capture event interrupt bit */
+#define TIMER_CAP_INT(n)        (_BIT((((n) & 0x0F) + 4)))
+
+/** Timer/counter enable bit */
+#define TIMER_ENABLE            ((uint32_t) (1 << 0))
+/** Timer/counter reset bit */
+#define TIMER_RESET             ((uint32_t) (1 << 1))
+
+/** Bit location for interrupt on MRx match, n = 0 to 3 */
+#define TIMER_INT_ON_MATCH(n)   (_BIT(((n) * 3)))
+/** Bit location for reset on MRx match, n = 0 to 3 */
+#define TIMER_RESET_ON_MATCH(n) (_BIT((((n) * 3) + 1)))
+/** Bit location for stop on MRx match, n = 0 to 3 */
+#define TIMER_STOP_ON_MATCH(n)  (_BIT((((n) * 3) + 2)))
+
+/** Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
+#define TIMER_CAP_RISING(n)     (_BIT(((n) * 3)))
+/** Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
+#define TIMER_CAP_FALLING(n)    (_BIT((((n) * 3) + 1)))
+/** Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
+#define TIMER_INT_ON_CAP(n)     (_BIT((((n) * 3) + 2)))
+
+/**
+ * @brief  Initialize a timer
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Nothing
+ */
+void Chip_TIMER_Init(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief  Shutdown a timer
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Nothing
+ */
+void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief  Determine if a match interrupt is pending
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match interrupt number to check
+ * @return false if the interrupt is not pending, otherwise true
+ * @note   Determine if the match interrupt for the passed timer and match
+ * counter is pending.
+ */
+STATIC INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
+}
+
+/**
+ * @brief  Determine if a capture interrupt is pending
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture interrupt number to check
+ * @return false if the interrupt is not pending, otherwise true
+ * @note   Determine if the capture interrupt for the passed capture pin is
+ * pending.
+ */
+STATIC INLINE bool Chip_TIMER_CapturePending(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   return (bool) ((pTMR->IR & TIMER_CAP_INT(capnum)) != 0);
+}
+
+/**
+ * @brief  Clears a (pending) match interrupt
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match interrupt number to clear
+ * @return Nothing
+ * @note   Clears a pending timer match interrupt.
+ */
+STATIC INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->IR = TIMER_IR_CLR(matchnum);
+}
+
+/**
+ * @brief  Clears a (pending) capture interrupt
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture interrupt number to clear
+ * @return Nothing
+ * @note   Clears a pending timer capture interrupt.
+ */
+STATIC INLINE void Chip_TIMER_ClearCapture(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->IR = (0x10 << capnum);
+}
+
+/**
+ * @brief  Enables the timer (starts count)
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Nothing
+ * @note   Enables the timer to start counting.
+ */
+STATIC INLINE void Chip_TIMER_Enable(LPC_TIMER_T *pTMR)
+{
+   pTMR->TCR |= TIMER_ENABLE;
+}
+
+/**
+ * @brief  Disables the timer (stops count)
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Nothing
+ * @note   Disables the timer to stop counting.
+ */
+STATIC INLINE void Chip_TIMER_Disable(LPC_TIMER_T *pTMR)
+{
+   pTMR->TCR &= ~TIMER_ENABLE;
+}
+
+/**
+ * @brief  Returns the current timer count
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Current timer terminal count value
+ * @note   Returns the current timer terminal count.
+ */
+STATIC INLINE uint32_t Chip_TIMER_ReadCount(LPC_TIMER_T *pTMR)
+{
+   return pTMR->TC;
+}
+
+/**
+ * @brief  Returns the current prescale count
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Current timer prescale count value
+ * @note   Returns the current prescale count.
+ */
+STATIC INLINE uint32_t Chip_TIMER_ReadPrescale(LPC_TIMER_T *pTMR)
+{
+   return pTMR->PC;
+}
+
+/**
+ * @brief  Sets the prescaler value
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  prescale    : Prescale value to set the prescale register to
+ * @return Nothing
+ * @note   Sets the prescale count value.
+ */
+STATIC INLINE void Chip_TIMER_PrescaleSet(LPC_TIMER_T *pTMR, uint32_t prescale)
+{
+   pTMR->PR = prescale;
+}
+
+/**
+ * @brief  Sets a timer match value
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer to set match count for
+ * @param  matchval    : Match value for the selected match count
+ * @return Nothing
+ * @note   Sets one of the timer match values.
+ */
+STATIC INLINE void Chip_TIMER_SetMatch(LPC_TIMER_T *pTMR, int8_t matchnum, uint32_t matchval)
+{
+   pTMR->MR[matchnum] = matchval;
+}
+
+/**
+ * @brief  Reads a capture register
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture register to read
+ * @return The selected capture register value
+ * @note   Returns the selected capture register value.
+ */
+STATIC INLINE uint32_t Chip_TIMER_ReadCapture(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   return pTMR->CR[capnum];
+}
+
+/**
+ * @brief  Resets the timer terminal and prescale counts to 0
+ * @param  pTMR    : Pointer to timer IP register address
+ * @return Nothing
+ */
+void Chip_TIMER_Reset(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief  Enables a match interrupt that fires when the terminal count
+ *         matches the match counter value.
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer, 0 to 3
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_MatchEnableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->MCR |= TIMER_INT_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief  Disables a match interrupt for a match counter.
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer, 0 to 3
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_MatchDisableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->MCR &= ~TIMER_INT_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief  For the specific match counter, enables reset of the terminal count register when a match occurs
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer, 0 to 3
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_ResetOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->MCR |= TIMER_RESET_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief  For the specific match counter, disables reset of the terminal count register when a match occurs
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer, 0 to 3
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_ResetOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->MCR &= ~TIMER_RESET_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief  Enable a match timer to stop the terminal count when a
+ *         match count equals the terminal count.
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer, 0 to 3
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_StopOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->MCR |= TIMER_STOP_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief  Disable stop on match for a match timer. Disables a match timer
+ *         to stop the terminal count when a match count equals the terminal count.
+ * @param  pTMR        : Pointer to timer IP register address
+ * @param  matchnum    : Match timer, 0 to 3
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_StopOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+   pTMR->MCR &= ~TIMER_STOP_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief  Enables capture on on rising edge of selected CAP signal for the
+ *         selected capture register, enables the selected CAPn.capnum signal to load
+ *         the capture register with the terminal coount on a rising edge.
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture signal/register to use
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureRisingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->CCR |= TIMER_CAP_RISING(capnum);
+}
+
+/**
+ * @brief  Disables capture on on rising edge of selected CAP signal. For the
+ *         selected capture register, disables the selected CAPn.capnum signal to load
+ *         the capture register with the terminal coount on a rising edge.
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture signal/register to use
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureRisingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->CCR &= ~TIMER_CAP_RISING(capnum);
+}
+
+/**
+ * @brief  Enables capture on on falling edge of selected CAP signal. For the
+ *         selected capture register, enables the selected CAPn.capnum signal to load
+ *         the capture register with the terminal coount on a falling edge.
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture signal/register to use
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureFallingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->CCR |= TIMER_CAP_FALLING(capnum);
+}
+
+/**
+ * @brief  Disables capture on on falling edge of selected CAP signal. For the
+ *         selected capture register, disables the selected CAPn.capnum signal to load
+ *         the capture register with the terminal coount on a falling edge.
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture signal/register to use
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureFallingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->CCR &= ~TIMER_CAP_FALLING(capnum);
+}
+
+/**
+ * @brief  Enables interrupt on capture of selected CAP signal. For the
+ *         selected capture register, an interrupt will be generated when the enabled
+ *         rising or falling edge on CAPn.capnum is detected.
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture signal/register to use
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureEnableInt(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->CCR |= TIMER_INT_ON_CAP(capnum);
+}
+
+/**
+ * @brief  Disables interrupt on capture of selected CAP signal
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capnum  : Capture signal/register to use
+ * @return Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureDisableInt(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+   pTMR->CCR &= ~TIMER_INT_ON_CAP(capnum);
+}
+
+/**
+ * @brief Standard timer initial match pin state and change state
+ */
+typedef enum IP_TIMER_PIN_MATCH_STATE {
+   TIMER_EXTMATCH_DO_NOTHING = 0,  /*!< Timer match state does nothing on match pin */
+   TIMER_EXTMATCH_CLEAR      = 1,  /*!< Timer match state sets match pin low */
+   TIMER_EXTMATCH_SET        = 2,  /*!< Timer match state sets match pin high */
+   TIMER_EXTMATCH_TOGGLE     = 3   /*!< Timer match state toggles match pin */
+} TIMER_PIN_MATCH_STATE_T;
+
+/**
+ * @brief  Sets external match control (MATn.matchnum) pin control. For the pin
+ *          selected with matchnum, sets the function of the pin that occurs on
+ *          a terminal count match for the match count.
+ * @param  pTMR            : Pointer to timer IP register address
+ * @param  initial_state   : Initial state of the pin, high(1) or low(0)
+ * @param  matchState      : Selects the match state for the pin
+ * @param  matchnum        : MATn.matchnum signal to use
+ * @return Nothing
+ * @note   For the pin selected with matchnum, sets the function of the pin that occurs on
+ * a terminal count match for the match count.
+ */
+void Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
+                                                TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum);
+
+/**
+ * @brief Standard timer clock and edge for count source
+ */
+typedef enum IP_TIMER_CAP_SRC_STATE {
+   TIMER_CAPSRC_RISING_PCLK  = 0,  /*!< Timer ticks on PCLK rising edge */
+   TIMER_CAPSRC_RISING_CAPN  = 1,  /*!< Timer ticks on CAPn.x rising edge */
+   TIMER_CAPSRC_FALLING_CAPN = 2,  /*!< Timer ticks on CAPn.x falling edge */
+   TIMER_CAPSRC_BOTH_CAPN    = 3   /*!< Timer ticks on CAPn.x both edges */
+} TIMER_CAP_SRC_STATE_T;
+
+/**
+ * @brief  Sets timer count source and edge with the selected passed from CapSrc.
+ *          If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
+ * @param  pTMR    : Pointer to timer IP register address
+ * @param  capSrc  : timer clock source and edge
+ * @param  capnum  : CAPn.capnum pin to use (if used)
+ * @return Nothing
+ * @note   If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
+ */
+STATIC INLINE void Chip_TIMER_TIMER_SetCountClockSrc(LPC_TIMER_T *pTMR,
+                                                    TIMER_CAP_SRC_STATE_T capSrc,
+                                                    int8_t capnum)
+{
+   pTMR->CTCR = (uint32_t) capSrc | ((uint32_t) capnum) << 2;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TIMER_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/uart_18xx_43xx.h ./lpc_chip_43xx/inc/uart_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/uart_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/uart_18xx_43xx.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,826 @@
+/*
+ * @brief LPC18xx/43xx UART chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __UART_18XX_43XX_H_
+#define __UART_18XX_43XX_H_
+
+#include "ring_buffer.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup UART_18XX_43XX CHIP: LPC18xx/43xx UART driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief USART register block structure
+ */
+typedef struct {                   /*!< USARTn Structure       */
+
+   union {
+       __IO uint32_t  DLL;         /*!< Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1). */
+       __O  uint32_t  THR;         /*!< Transmit Holding Register. The next character to be transmitted is written here (DLAB = 0). */
+       __I  uint32_t  RBR;         /*!< Receiver Buffer Register. Contains the next received character to be read (DLAB = 0). */
+   };
+
+   union {
+       __IO uint32_t IER;          /*!< Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB = 0). */
+       __IO uint32_t DLM;          /*!< Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1). */
+   };
+
+   union {
+       __O  uint32_t FCR;          /*!< FIFO Control Register. Controls UART FIFO usage and modes. */
+       __I  uint32_t IIR;          /*!< Interrupt ID Register. Identifies which interrupt(s) are pending. */
+   };
+
+   __IO uint32_t LCR;              /*!< Line Control Register. Contains controls for frame formatting and break generation. */
+   __IO uint32_t MCR;              /*!< Modem Control Register. Only present on USART ports with full modem support. */
+   __I  uint32_t LSR;              /*!< Line Status Register. Contains flags for transmit and receive status, including line errors. */
+   __I  uint32_t MSR;              /*!< Modem Status Register. Only present on USART ports with full modem support. */
+   __IO uint32_t SCR;              /*!< Scratch Pad Register. Eight-bit temporary storage for software. */
+   __IO uint32_t ACR;              /*!< Auto-baud Control Register. Contains controls for the auto-baud feature. */
+   __IO uint32_t ICR;              /*!< IrDA control register (not all UARTS) */
+   __IO uint32_t FDR;              /*!< Fractional Divider Register. Generates a clock input for the baud rate divider. */
+   __IO uint32_t OSR;              /*!< Oversampling Register. Controls the degree of oversampling during each bit time. Only on some UARTS. */
+   __IO uint32_t TER1;             /*!< Transmit Enable Register. Turns off USART transmitter for use with software flow control. */
+   uint32_t  RESERVED0[3];
+    __IO uint32_t HDEN;                /*!< Half-duplex enable Register- only on some UARTs */
+   __I  uint32_t RESERVED1[1];
+   __IO uint32_t SCICTRL;          /*!< Smart card interface control register- only on some UARTs */
+
+   __IO uint32_t RS485CTRL;        /*!< RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes. */
+   __IO uint32_t RS485ADRMATCH;    /*!< RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode. */
+   __IO uint32_t RS485DLY;         /*!< RS-485/EIA-485 direction control delay. */
+
+   union {
+       __IO uint32_t SYNCCTRL;     /*!< Synchronous mode control register. Only on USARTs. */
+       __I  uint32_t FIFOLVL;      /*!< FIFO Level register. Provides the current fill levels of the transmit and receive FIFOs. */
+   };
+
+   __IO uint32_t TER2;             /*!< Transmit Enable Register. Only on LPC177X_8X UART4 and LPC18XX/43XX USART0/2/3. */
+} LPC_USART_T;
+
+
+/**
+ * @brief Macro defines for UART Receive Buffer register
+ */
+#define UART_RBR_MASKBIT    (0xFF)             /*!< UART Received Buffer mask bit (8 bits) */
+
+/**
+ * @brief Macro defines for UART Divisor Latch LSB register
+ */
+#define UART_LOAD_DLL(div)  ((div) & 0xFF)     /*!< Macro for loading LSB of divisor */
+#define UART_DLL_MASKBIT    (0xFF)             /*!< Divisor latch LSB bit mask */
+
+/**
+ * @brief Macro defines for UART Divisor Latch MSB register
+ */
+#define UART_LOAD_DLM(div)  (((div) >> 8) & 0xFF)  /*!< Macro for loading MSB of divisors */
+#define UART_DLM_MASKBIT    (0xFF)                 /*!< Divisor latch MSB bit mask */
+
+/**
+ * @brief Macro defines for UART Interrupt Enable Register
+ */
+#define UART_IER_RBRINT      (1 << 0)  /*!< RBR Interrupt enable */
+#define UART_IER_THREINT     (1 << 1)  /*!< THR Interrupt enable */
+#define UART_IER_RLSINT      (1 << 2)  /*!< RX line status interrupt enable */
+#define UART_IER_MSINT       (1 << 3)  /*!< Modem status interrupt enable - valid for 11xx, 17xx/40xx UART1, 18xx/43xx UART1  only */
+#define UART_IER_CTSINT      (1 << 7)  /*!< CTS signal transition interrupt enable - valid for 17xx/40xx UART1, 18xx/43xx UART1 only */
+#define UART_IER_ABEOINT     (1 << 8)  /*!< Enables the end of auto-baud interrupt */
+#define UART_IER_ABTOINT     (1 << 9)  /*!< Enables the auto-baud time-out interrupt */
+#define UART_IER_BITMASK     (0x307)   /*!< UART interrupt enable register bit mask  - valid for 13xx, 17xx/40xx UART0/2/3, 18xx/43xx UART0/2/3 only*/
+#define UART1_IER_BITMASK    (0x30F)   /*!< UART1 interrupt enable register bit mask - valid for 11xx only */
+#define UART2_IER_BITMASK    (0x38F)   /*!< UART2 interrupt enable register bit mask - valid for 17xx/40xx UART1, 18xx/43xx UART1 only */
+
+/**
+ * @brief Macro defines for UART Interrupt Identification Register
+ */
+#define UART_IIR_INTSTAT_PEND   (1 << 0)   /*!< Interrupt pending status - Active low */
+#define UART_IIR_FIFO_EN        (3 << 6)   /*!< These bits are equivalent to FCR[0] */
+#define UART_IIR_ABEO_INT       (1 << 8)   /*!< End of auto-baud interrupt */
+#define UART_IIR_ABTO_INT       (1 << 9)   /*!< Auto-baud time-out interrupt */
+#define UART_IIR_BITMASK        (0x3CF)        /*!< UART interrupt identification register bit mask */
+
+/* Interrupt ID bit definitions */
+#define UART_IIR_INTID_MASK     (7 << 1)   /*!< Interrupt identification: Interrupt ID mask */
+#define UART_IIR_INTID_RLS      (3 << 1)   /*!< Interrupt identification: Receive line interrupt */
+#define UART_IIR_INTID_RDA      (2 << 1)   /*!< Interrupt identification: Receive data available interrupt */
+#define UART_IIR_INTID_CTI      (6 << 1)   /*!< Interrupt identification: Character time-out indicator interrupt */
+#define UART_IIR_INTID_THRE     (1 << 1)   /*!< Interrupt identification: THRE interrupt */
+#define UART_IIR_INTID_MODEM    (0 << 1)   /*!< Interrupt identification: Modem interrupt */
+
+/**
+ * @brief Macro defines for UART FIFO Control Register
+ */
+#define UART_FCR_FIFO_EN        (1 << 0)   /*!< UART FIFO enable */
+#define UART_FCR_RX_RS          (1 << 1)   /*!< UART RX FIFO reset */
+#define UART_FCR_TX_RS          (1 << 2)   /*!< UART TX FIFO reset */
+#define UART_FCR_DMAMODE_SEL    (1 << 3)   /*!< UART DMA mode selection - valid for 17xx/40xx, 18xx/43xx only */
+#define UART_FCR_BITMASK        (0xCF)     /*!< UART FIFO control bit mask */
+
+#define UART_TX_FIFO_SIZE       (16)
+
+/* FIFO trigger level bit definitions */
+#define UART_FCR_TRG_LEV0       (0)            /*!< UART FIFO trigger level 0: 1 character */
+#define UART_FCR_TRG_LEV1       (1 << 6)   /*!< UART FIFO trigger level 1: 4 character */
+#define UART_FCR_TRG_LEV2       (2 << 6)   /*!< UART FIFO trigger level 2: 8 character */
+#define UART_FCR_TRG_LEV3       (3 << 6)   /*!< UART FIFO trigger level 3: 14 character */
+
+/**
+ * @brief Macro defines for UART Line Control Register
+ */
+/* UART word length select bit definitions */
+#define UART_LCR_WLEN_MASK      (3 << 0)       /*!< UART word length select bit mask */
+#define UART_LCR_WLEN5          (0 << 0)       /*!< UART word length select: 5 bit data mode */
+#define UART_LCR_WLEN6          (1 << 0)       /*!< UART word length select: 6 bit data mode */
+#define UART_LCR_WLEN7          (2 << 0)       /*!< UART word length select: 7 bit data mode */
+#define UART_LCR_WLEN8          (3 << 0)       /*!< UART word length select: 8 bit data mode */
+
+/* UART Stop bit select bit definitions */
+#define UART_LCR_SBS_MASK       (1 << 2)       /*!< UART stop bit select: bit mask */
+#define UART_LCR_SBS_1BIT       (0 << 2)       /*!< UART stop bit select: 1 stop bit */
+#define UART_LCR_SBS_2BIT       (1 << 2)       /*!< UART stop bit select: 2 stop bits (in 5 bit data mode, 1.5 stop bits) */
+
+/* UART Parity enable bit definitions */
+#define UART_LCR_PARITY_EN      (1 << 3)       /*!< UART Parity Enable */
+#define UART_LCR_PARITY_DIS     (0 << 3)       /*!< UART Parity Disable */
+#define UART_LCR_PARITY_ODD     (0 << 4)       /*!< UART Parity select: Odd parity */
+#define UART_LCR_PARITY_EVEN    (1 << 4)       /*!< UART Parity select: Even parity */
+#define UART_LCR_PARITY_F_1     (2 << 4)       /*!< UART Parity select: Forced 1 stick parity */
+#define UART_LCR_PARITY_F_0     (3 << 4)       /*!< UART Parity select: Forced 0 stick parity */
+#define UART_LCR_BREAK_EN       (1 << 6)       /*!< UART Break transmission enable */
+#define UART_LCR_DLAB_EN        (1 << 7)       /*!< UART Divisor Latches Access bit enable */
+#define UART_LCR_BITMASK        (0xFF)         /*!< UART line control bit mask */
+
+/**
+ * @brief Macro defines for UART Modem Control Register
+ */
+#define UART_MCR_DTR_CTRL       (1 << 0)       /*!< Source for modem output pin DTR */
+#define UART_MCR_RTS_CTRL       (1 << 1)       /*!< Source for modem output pin RTS */
+#define UART_MCR_LOOPB_EN       (1 << 4)       /*!< Loop back mode select */
+#define UART_MCR_AUTO_RTS_EN    (1 << 6)       /*!< Enable Auto RTS flow-control */
+#define UART_MCR_AUTO_CTS_EN    (1 << 7)       /*!< Enable Auto CTS flow-control */
+#define UART_MCR_BITMASK        (0xD3)         /*!< UART bit mask value */
+
+/**
+ * @brief Macro defines for UART Line Status Register
+ */
+#define UART_LSR_RDR        (1 << 0)   /*!< Line status: Receive data ready */
+#define UART_LSR_OE         (1 << 1)   /*!< Line status: Overrun error */
+#define UART_LSR_PE         (1 << 2)   /*!< Line status: Parity error */
+#define UART_LSR_FE         (1 << 3)   /*!< Line status: Framing error */
+#define UART_LSR_BI         (1 << 4)   /*!< Line status: Break interrupt */
+#define UART_LSR_THRE       (1 << 5)   /*!< Line status: Transmit holding register empty */
+#define UART_LSR_TEMT       (1 << 6)   /*!< Line status: Transmitter empty */
+#define UART_LSR_RXFE       (1 << 7)   /*!< Line status: Error in RX FIFO */
+#define UART_LSR_TXFE       (1 << 8)   /*!< Line status: Error in RX FIFO */
+#define UART_LSR_BITMASK    (0xFF)     /*!< UART Line status bit mask */
+#define UART1_LSR_BITMASK   (0x1FF)        /*!< UART1 Line status bit mask - valid for 11xx, 18xx/43xx UART0/2/3 only */
+
+/**
+ * @brief Macro defines for UART Modem Status Register
+ */
+#define UART_MSR_DELTA_CTS      (1 << 0)   /*!< Modem status: State change of input CTS */
+#define UART_MSR_DELTA_DSR      (1 << 1)   /*!< Modem status: State change of input DSR */
+#define UART_MSR_LO2HI_RI       (1 << 2)   /*!< Modem status: Low to high transition of input RI */
+#define UART_MSR_DELTA_DCD      (1 << 3)   /*!< Modem status: State change of input DCD */
+#define UART_MSR_CTS            (1 << 4)   /*!< Modem status: Clear To Send State */
+#define UART_MSR_DSR            (1 << 5)   /*!< Modem status: Data Set Ready State */
+#define UART_MSR_RI             (1 << 6)   /*!< Modem status: Ring Indicator State */
+#define UART_MSR_DCD            (1 << 7)   /*!< Modem status: Data Carrier Detect State */
+#define UART_MSR_BITMASK        (0xFF)     /*!< Modem status: MSR register bit-mask value */
+
+/**
+ * @brief Macro defines for UART Auto baudrate control register
+ */
+#define UART_ACR_START              (1 << 0)   /*!< UART Auto-baud start */
+#define UART_ACR_MODE               (1 << 1)   /*!< UART Auto baudrate Mode 1 */
+#define UART_ACR_AUTO_RESTART       (1 << 2)   /*!< UART Auto baudrate restart */
+#define UART_ACR_ABEOINT_CLR        (1 << 8)   /*!< UART End of auto-baud interrupt clear */
+#define UART_ACR_ABTOINT_CLR        (1 << 9)   /*!< UART Auto-baud time-out interrupt clear */
+#define UART_ACR_BITMASK            (0x307)        /*!< UART Auto Baudrate register bit mask */
+
+/**
+ * Autobaud modes
+ */
+#define UART_ACR_MODE0              (0)    /*!< Auto baudrate Mode 0 */
+#define UART_ACR_MODE1              (1)    /*!< Auto baudrate Mode 1 */
+
+/**
+ * @brief Macro defines for UART RS485 Control register
+ */
+#define UART_RS485CTRL_NMM_EN       (1 << 0)   /*!< RS-485/EIA-485 Normal Multi-drop Mode (NMM) is disabled */
+#define UART_RS485CTRL_RX_DIS       (1 << 1)   /*!< The receiver is disabled */
+#define UART_RS485CTRL_AADEN        (1 << 2)   /*!< Auto Address Detect (AAD) is enabled */
+#define UART_RS485CTRL_SEL_DTR      (1 << 3)   /*!< If direction control is enabled (bit DCTRL = 1), pin DTR is
+                                                       used for direction control */
+#define UART_RS485CTRL_DCTRL_EN     (1 << 4)   /*!< Enable Auto Direction Control */
+#define UART_RS485CTRL_OINV_1       (1 << 5)   /*!< This bit reverses the polarity of the direction
+                                                      control signal on the RTS (or DTR) pin. The direction control pin
+                                                      will be driven to logic "1" when the transmitter has data to be sent */
+#define UART_RS485CTRL_BITMASK      (0x3F)     /*!< RS485 control bit-mask value */
+
+/**
+ * @brief Macro defines for UART IrDA Control Register - valid for 11xx, 17xx/40xx UART0/2/3, 18xx/43xx UART3 only
+ */
+#define UART_ICR_IRDAEN         (1 << 0)           /*!< IrDA mode enable */
+#define UART_ICR_IRDAINV        (1 << 1)           /*!< IrDA serial input inverted */
+#define UART_ICR_FIXPULSE_EN    (1 << 2)           /*!< IrDA fixed pulse width mode */
+#define UART_ICR_PULSEDIV(n)    ((n & 0x07) << 3)  /*!< PulseDiv - Configures the pulse when FixPulseEn = 1 */
+#define UART_ICR_BITMASK        (0x3F)             /*!< UART IRDA bit mask */
+
+/**
+ * @brief Macro defines for UART half duplex register - ????
+ */
+#define UART_HDEN_HDEN          ((1 << 0))         /*!< enable half-duplex mode*/
+
+/**
+ * @brief Macro defines for UART Smart card interface Control Register - valid for 11xx, 18xx/43xx UART0/2/3 only
+ */
+#define UART_SCICTRL_SCIEN        (1 << 0)         /*!< enable asynchronous half-duplex smart card interface*/
+#define UART_SCICTRL_NACKDIS      (1 << 1)         /*!< NACK response is inhibited*/
+#define UART_SCICTRL_PROTSEL_T1   (1 << 2)         /*!< ISO7816-3 protocol T1 is selected*/
+#define UART_SCICTRL_TXRETRY(n)   ((n & 0x07) << 5)    /*!< number of retransmission*/
+#define UART_SCICTRL_GUARDTIME(n) ((n & 0xFF) << 8)    /*!< Extra guard time*/
+
+/**
+ * @brief Macro defines for UART Fractional Divider Register
+ */
+#define UART_FDR_DIVADDVAL(n)   (n & 0x0F)         /*!< Baud-rate generation pre-scaler divisor */
+#define UART_FDR_MULVAL(n)      ((n << 4) & 0xF0)  /*!< Baud-rate pre-scaler multiplier value */
+#define UART_FDR_BITMASK        (0xFF)             /*!< UART Fractional Divider register bit mask */
+
+/**
+ * @brief Macro defines for UART Tx Enable Register
+ */
+#define UART_TER1_TXEN      (1 << 7)       /*!< Transmit enable bit  - valid for 11xx, 13xx, 17xx/40xx only */
+#define UART_TER2_TXEN      (1 << 0)       /*!< Transmit enable bit  - valid for 18xx/43xx only */
+
+/**
+ * @brief Macro defines for UART Synchronous Control Register - 11xx, 18xx/43xx UART0/2/3 only
+ */
+#define UART_SYNCCTRL_SYNC             (1 << 0)            /*!< enable synchronous mode*/
+#define UART_SYNCCTRL_CSRC_MASTER      (1 << 1)        /*!< synchronous master mode*/
+#define UART_SYNCCTRL_FES              (1 << 2)            /*!< sample on falling edge*/
+#define UART_SYNCCTRL_TSBYPASS         (1 << 3)            /*!< to be defined*/
+#define UART_SYNCCTRL_CSCEN            (1 << 4)            /*!< Continuous running clock enable (master mode only)*/
+#define UART_SYNCCTRL_STARTSTOPDISABLE (1 << 5)            /*!< Do not send start/stop bit*/
+#define UART_SYNCCTRL_CCCLR            (1 << 6)            /*!< stop continuous clock*/
+
+/**
+ * @brief  Enable transmission on UART TxD pin
+ * @param  pUART   : Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
+{
+    pUART->TER2 = UART_TER2_TXEN;
+}
+
+/**
+ * @brief  Disable transmission on UART TxD pin
+ * @param  pUART   : Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_TXDisable(LPC_USART_T *pUART)
+{
+    pUART->TER2 = 0;
+}
+
+/**
+ * @brief  Transmit a single data byte through the UART peripheral
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  data    : Byte to transmit
+ * @return Nothing
+ * @note   This function attempts to place a byte into the UART transmit
+ *         FIFO or transmit hold register regard regardless of UART state
+ */
+STATIC INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
+{
+   pUART->THR = (uint32_t) data;
+}
+
+/**
+ * @brief  Read a single byte data from the UART peripheral
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return A single byte of data read
+ * @note   This function reads a byte from the UART receive FIFO or
+ *         receive hold register regard regardless of UART state. The
+ *         FIFO status should be read first prior to using this function
+ */
+STATIC INLINE uint8_t Chip_UART_ReadByte(LPC_USART_T *pUART)
+{
+   return (uint8_t) (pUART->RBR & UART_RBR_MASKBIT);
+}
+
+/**
+ * @brief  Enable UART interrupts
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  intMask : OR'ed Interrupts to enable in the Interrupt Enable Register (IER)
+ * @return Nothing
+ * @note   Use an OR'ed value of UART_IER_* definitions with this function
+ *         to enable specific UART interrupts. The Divisor Latch Access Bit
+ *         (DLAB) in LCR must be cleared in order to access the IER register.
+ *         This function doesn't alter the DLAB state
+ */
+STATIC INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
+{
+   pUART->IER |= intMask;
+}
+
+/**
+ * @brief  Disable UART interrupts
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  intMask : OR'ed Interrupts to disable in the Interrupt Enable Register (IER)
+ * @return Nothing
+ * @note   Use an OR'ed value of UART_IER_* definitions with this function
+ *         to disable specific UART interrupts. The Divisor Latch Access Bit
+ *         (DLAB) in LCR must be cleared in order to access the IER register.
+ *         This function doesn't alter the DLAB state
+ */
+STATIC INLINE void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
+{
+   pUART->IER &= ~intMask;
+}
+
+/**
+ * @brief  Returns UART interrupts that are enabled
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Returns the enabled UART interrupts
+ * @note   Use an OR'ed value of UART_IER_* definitions with this function
+ *         to determine which interrupts are enabled. You can check
+ *         for multiple enabled bits if needed.
+ */
+STATIC INLINE uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
+{
+   return pUART->IER;
+}
+
+/**
+ * @brief  Read the Interrupt Identification Register (IIR)
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Current pending interrupt status per the IIR register
+ */
+STATIC INLINE uint32_t Chip_UART_ReadIntIDReg(LPC_USART_T *pUART)
+{
+   return pUART->IIR;
+}
+
+/**
+ * @brief  Setup the UART FIFOs
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  fcr     : FIFO control register setup OR'ed flags
+ * @return Nothing
+ * @note   Use OR'ed value of UART_FCR_* definitions with this function
+ *         to select specific options. For example, to enable the FIFOs
+ *         with a RX trip level of 8 characters, use something like
+ *         (UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
+ */
+STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
+{
+   pUART->FCR = fcr;
+}
+
+/**
+ * @brief  Configure data width, parity and stop bits
+ * @param  pUART   : Pointer to selected pUART peripheral
+ * @param  config  : UART configuration, OR'ed values of UART_LCR_* defines
+ * @return Nothing
+ * @note   Select OR'ed config options for the UART from the UART_LCR_*
+ *         definitions. For example, a configuration of 8 data bits, 1
+ *         stop bit, and even (enabled) parity would be
+ *         (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
+ */
+STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
+{
+   pUART->LCR = config;
+}
+
+/**
+ * @brief  Enable access to Divisor Latches
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
+{
+   pUART->LCR |= UART_LCR_DLAB_EN;
+}
+
+/**
+ * @brief  Disable access to Divisor Latches
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_DisableDivisorAccess(LPC_USART_T *pUART)
+{
+   pUART->LCR &= ~UART_LCR_DLAB_EN;
+}
+
+/**
+ * @brief  Set LSB and MSB divisor latch registers
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  dll     : Divisor Latch LSB value
+ * @param  dlm     : Divisor Latch MSB value
+ * @return Nothing
+ * @note   The Divisor Latch Access Bit (DLAB) in LCR must be set in
+ *         order to access the USART Divisor Latches. This function
+ *         doesn't alter the DLAB state.
+ */
+STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
+{
+   pUART->DLL = (uint32_t) dll;
+   pUART->DLM = (uint32_t) dlm;
+}
+
+
+/**
+ * @brief  Return modem control register/status
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Modem control register (status)
+ * @note   Mask bits of the returned status value with UART_MCR_*
+ *         definitions for specific statuses.
+ */
+STATIC INLINE uint32_t Chip_UART_ReadModemControl(LPC_USART_T *pUART)
+{
+   return pUART->MCR;
+}
+
+/**
+ * @brief  Set modem control register/status
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  mcr     : Modem control register flags to set
+ * @return Nothing
+ * @note   Use an Or'ed value of UART_MCR_* definitions with this
+ *         call to set specific options.
+ */
+STATIC INLINE void Chip_UART_SetModemControl(LPC_USART_T *pUART, uint32_t mcr)
+{
+   pUART->MCR |= mcr;
+}
+
+/**
+ * @brief  Clear modem control register/status
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  mcr     : Modem control register flags to clear
+ * @return Nothing
+ * @note   Use an Or'ed value of UART_MCR_* definitions with this
+ *         call to clear specific options.
+ */
+STATIC INLINE void Chip_UART_ClearModemControl(LPC_USART_T *pUART, uint32_t mcr)
+{
+   pUART->MCR &= ~mcr;
+}
+
+/**
+ * @brief  Return Line Status register/status (LSR)
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Line Status register (status)
+ * @note   Mask bits of the returned status value with UART_LSR_*
+ *         definitions for specific statuses.
+ */
+STATIC INLINE uint32_t Chip_UART_ReadLineStatus(LPC_USART_T *pUART)
+{
+   return pUART->LSR;
+}
+
+/**
+ * @brief  Return Modem Status register/status (MSR)
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Modem Status register (status)
+ * @note   Mask bits of the returned status value with UART_MSR_*
+ *         definitions for specific statuses.
+ */
+STATIC INLINE uint32_t Chip_UART_ReadModemStatus(LPC_USART_T *pUART)
+{
+   return pUART->MSR;
+}
+
+/**
+ * @brief  Write a byte to the scratchpad register
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  data    : Byte value to write
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_SetScratch(LPC_USART_T *pUART, uint8_t data)
+{
+   pUART->SCR = (uint32_t) data;
+}
+
+/**
+ * @brief  Returns current byte value in the scratchpad register
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Byte value read from scratchpad register
+ */
+STATIC INLINE uint8_t Chip_UART_ReadScratch(LPC_USART_T *pUART)
+{
+   return (uint8_t) (pUART->SCR & 0xFF);
+}
+
+/**
+ * @brief  Set autobaud register options
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  acr     : Or'ed values to set for ACR register
+ * @return Nothing
+ * @note   Use an Or'ed value of UART_ACR_* definitions with this
+ *         call to set specific options.
+ */
+STATIC INLINE void Chip_UART_SetAutoBaudReg(LPC_USART_T *pUART, uint32_t acr)
+{
+   pUART->ACR |= acr;
+}
+
+/**
+ * @brief  Clear autobaud register options
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  acr     : Or'ed values to clear for ACR register
+ * @return Nothing
+ * @note   Use an Or'ed value of UART_ACR_* definitions with this
+ *         call to clear specific options.
+ */
+STATIC INLINE void Chip_UART_ClearAutoBaudReg(LPC_USART_T *pUART, uint32_t acr)
+{
+   pUART->ACR &= ~acr;
+}
+
+/**
+ * @brief  Set RS485 control register options
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  ctrl    : Or'ed values to set for RS485 control register
+ * @return Nothing
+ * @note   Use an Or'ed value of UART_RS485CTRL_* definitions with this
+ *         call to set specific options.
+ */
+STATIC INLINE void Chip_UART_SetRS485Flags(LPC_USART_T *pUART, uint32_t ctrl)
+{
+   pUART->RS485CTRL |= ctrl;
+}
+
+/**
+ * @brief  Clear RS485 control register options
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  ctrl    : Or'ed values to clear for RS485 control register
+ * @return Nothing
+ * @note   Use an Or'ed value of UART_RS485CTRL_* definitions with this
+ *         call to clear specific options.
+ */
+STATIC INLINE void Chip_UART_ClearRS485Flags(LPC_USART_T *pUART, uint32_t ctrl)
+{
+   pUART->RS485CTRL &= ~ctrl;
+}
+
+/**
+ * @brief  Set RS485 address match value
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  addr    : Address match value for RS-485/EIA-485 mode
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_SetRS485Addr(LPC_USART_T *pUART, uint8_t addr)
+{
+   pUART->RS485ADRMATCH = (uint32_t) addr;
+}
+
+/**
+ * @brief  Read RS485 address match value
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return Address match value for RS-485/EIA-485 mode
+ */
+STATIC INLINE uint8_t Chip_UART_GetRS485Addr(LPC_USART_T *pUART)
+{
+   return (uint8_t) (pUART->RS485ADRMATCH & 0xFF);
+}
+
+/**
+ * @brief  Set RS485 direction control (RTS or DTR) delay value
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  dly     : direction control (RTS or DTR) delay value
+ * @return Nothing
+ * @note   This delay time is in periods of the baud clock. Any delay
+ *         time from 0 to 255 bit times may be programmed.
+ */
+STATIC INLINE void Chip_UART_SetRS485Delay(LPC_USART_T *pUART, uint8_t dly)
+{
+   pUART->RS485DLY = (uint32_t) dly;
+}
+
+/**
+ * @brief  Read RS485 direction control (RTS or DTR) delay value
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return direction control (RTS or DTR) delay value
+ * @note   This delay time is in periods of the baud clock. Any delay
+ *         time from 0 to 255 bit times may be programmed.
+ */
+STATIC INLINE uint8_t Chip_UART_GetRS485Delay(LPC_USART_T *pUART)
+{
+   return (uint8_t) (pUART->RS485DLY & 0xFF);
+}
+
+/**
+ * @brief  Initializes the pUART peripheral
+ * @param  pUART       : Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+void Chip_UART_Init(LPC_USART_T *pUART);
+
+/**
+ * @brief  De-initializes the pUART peripheral.
+ * @param  pUART       : Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+void Chip_UART_DeInit(LPC_USART_T *pUART);
+
+
+/**
+ * @brief  Check whether if UART is busy or not
+ * @param  pUART   : Pointer to selected pUART peripheral
+ * @return RESET if UART is not busy, otherwise return SET
+ */
+FlagStatus Chip_UART_CheckBusy(LPC_USART_T *pUART);
+
+/**
+ * @brief  Transmit a byte array through the UART peripheral (non-blocking)
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  data        : Pointer to bytes to transmit
+ * @param  numBytes    : Number of bytes to transmit
+ * @return The actual number of bytes placed into the FIFO
+ * @note   This function places data into the transmit FIFO until either
+ *         all the data is in the FIFO or the FIFO is full. This function
+ *         will not block in the FIFO is full. The actual number of bytes
+ *         placed into the FIFO is returned. This function ignores errors.
+ */
+int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes);
+
+/**
+ * @brief  Read data through the UART peripheral (non-blocking)
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  data        : Pointer to bytes array to fill
+ * @param  numBytes    : Size of the passed data array
+ * @return The actual number of bytes read
+ * @note   This function reads data from the receive FIFO until either
+ *         all the data has been read or the passed buffer is completely full.
+ *         This function will not block. This function ignores errors.
+ */
+int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes);
+
+/**
+ * @brief  Sets best dividers to get a target bit rate (without fractional divider)
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  baudrate    : Target baud rate (baud rate = bit rate)
+ * @return The actual baud rate, or 0 if no rate can be found
+ */
+uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate);
+
+/**
+ * @brief  Sets best dividers to get a target bit rate (with fractional divider)
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  baud        : Target baud rate (baud rate = bit rate)
+ * @return The actual baud rate, or 0 if no rate can be found
+ * @note   The maximum bit rate possible is (clk / 16), the next possible bit
+ *             rate is (clk / 32), the next possible bit rate is (clk / 48), no
+ *             rates in-between any of the above three maximum rates could be set
+ *             using this API. Fractional dividers can only be used for rates
+ *             lower than (clk / 48) where @a clk is the base clock of the UART.
+ */
+uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud);
+
+/**
+ * @brief  Transmit a byte array through the UART peripheral (blocking)
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  data        : Pointer to data to transmit
+ * @param  numBytes    : Number of bytes to transmit
+ * @return The number of bytes transmitted
+ * @note   This function will send or place all bytes into the transmit
+ *         FIFO. This function will block until the last bytes are in the FIFO.
+ */
+int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes);
+
+/**
+ * @brief  Read data through the UART peripheral (blocking)
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  data        : Pointer to data array to fill
+ * @param  numBytes    : Size of the passed data array
+ * @return The size of the dat array
+ * @note   This function reads data from the receive FIFO until the passed
+ *         buffer is completely full. The function will block until full.
+ *         This function ignores errors.
+ */
+int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes);
+
+/**
+ * @brief  UART receive-only interrupt handler for ring buffers
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  pRB     : Pointer to ring buffer structure to use
+ * @return Nothing
+ * @note   If ring buffer support is desired for the receive side
+ *         of data transfer, the UART interrupt should call this
+ *         function for a receive based interrupt status.
+ */
+void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
+
+/**
+ * @brief  UART transmit-only interrupt handler for ring buffers
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  pRB     : Pointer to ring buffer structure to use
+ * @return Nothing
+ * @note   If ring buffer support is desired for the transmit side
+ *         of data transfer, the UART interrupt should call this
+ *         function for a transmit based interrupt status.
+ */
+void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
+
+/**
+ * @brief  Populate a transmit ring buffer and start UART transmit
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  pRB     : Pointer to ring buffer structure to use
+ * @param  data    : Pointer to buffer to move to ring buffer
+ * @param  bytes   : Number of bytes to move
+ * @return The number of bytes placed into the ring buffer
+ * @note   Will move the data into the TX ring buffer and start the
+ *         transfer. If the number of bytes returned is less than the
+ *         number of bytes to send, the ring buffer is considered full.
+ */
+uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int bytes);
+
+/**
+ * @brief  Copy data from a receive ring buffer
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  pRB     : Pointer to ring buffer structure to use
+ * @param  data    : Pointer to buffer to fill from ring buffer
+ * @param  bytes   : Size of the passed buffer in bytes
+ * @return The number of bytes placed into the ring buffer
+ * @note   Will move the data from the RX ring buffer up to the
+ *         the maximum passed buffer size. Returns 0 if there is
+ *         no data in the ring buffer.
+ */
+int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes);
+
+/**
+ * @brief  UART receive/transmit interrupt handler for ring buffers
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @param  pRXRB   : Pointer to transmit ring buffer
+ * @param  pTXRB   : Pointer to receive ring buffer
+ * @return Nothing
+ * @note   This provides a basic implementation of the UART IRQ
+ *         handler for support of a ring buffer implementation for
+ *         transmit and receive.
+ */
+void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB);
+
+/**
+ * @brief  Returns the Auto Baud status
+ * @param  pUART   : Pointer to selected UART peripheral
+ * @return RESET if autobaud not completed, SET if autobaud completed
+ */
+FlagStatus Chip_UART_GetABEOStatus(LPC_USART_T *pUART);
+
+/**
+ * @brief  Start/stop autobaud operation
+ * @param  pUART       : Pointer to selected UART peripheral
+ * @param  mode        : Autobaud mode (UART_ACR_MODE0 or UART_ACR_MODE1)
+ * @param  autorestart : Enable autorestart (true to enable or false to disable)
+ * @param  NewState    : ENABLE to start autobaud operation, DISABLE to
+ *                          stop autobaud operation
+ * @return Nothing
+ */
+void Chip_UART_ABCmd(LPC_USART_T *pUART, uint32_t mode, bool autorestart,
+        FunctionalState NewState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UART_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_adc.h ./lpc_chip_43xx/inc/usbd/usbd_adc.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_adc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_adc.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,377 @@
+/***********************************************************************
+* $Id:: mw_usbd_audio.h 165 2011-04-14 17:41:11Z usb10131                     $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Audio Device Class Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __AUDIO_H__
+#define __AUDIO_H__
+
+
+/* Audio Interface Subclass Codes */
+#define AUDIO_SUBCLASS_UNDEFINED                0x00
+#define AUDIO_SUBCLASS_AUDIOCONTROL             0x01
+#define AUDIO_SUBCLASS_AUDIOSTREAMING           0x02
+#define AUDIO_SUBCLASS_MIDISTREAMING            0x03
+
+/* Audio Interface Protocol Codes */
+#define AUDIO_PROTOCOL_UNDEFINED                0x00
+
+
+/* Audio Descriptor Types */
+#define AUDIO_UNDEFINED_DESCRIPTOR_TYPE         0x20
+#define AUDIO_DEVICE_DESCRIPTOR_TYPE            0x21
+#define AUDIO_CONFIGURATION_DESCRIPTOR_TYPE     0x22
+#define AUDIO_STRING_DESCRIPTOR_TYPE            0x23
+#define AUDIO_INTERFACE_DESCRIPTOR_TYPE         0x24
+#define AUDIO_ENDPOINT_DESCRIPTOR_TYPE          0x25
+
+
+/* Audio Control Interface Descriptor Subtypes */
+#define AUDIO_CONTROL_UNDEFINED                 0x00
+#define AUDIO_CONTROL_HEADER                    0x01
+#define AUDIO_CONTROL_INPUT_TERMINAL            0x02
+#define AUDIO_CONTROL_OUTPUT_TERMINAL           0x03
+#define AUDIO_CONTROL_MIXER_UNIT                0x04
+#define AUDIO_CONTROL_SELECTOR_UNIT             0x05
+#define AUDIO_CONTROL_FEATURE_UNIT              0x06
+#define AUDIO_CONTROL_PROCESSING_UNIT           0x07
+#define AUDIO_CONTROL_EXTENSION_UNIT            0x08
+
+/* Audio Streaming Interface Descriptor Subtypes */
+#define AUDIO_STREAMING_UNDEFINED               0x00
+#define AUDIO_STREAMING_GENERAL                 0x01
+#define AUDIO_STREAMING_FORMAT_TYPE             0x02
+#define AUDIO_STREAMING_FORMAT_SPECIFIC         0x03
+
+/* Audio Endpoint Descriptor Subtypes */
+#define AUDIO_ENDPOINT_UNDEFINED                0x00
+#define AUDIO_ENDPOINT_GENERAL                  0x01
+
+
+/* Audio Descriptor Sizes */
+#define AUDIO_CONTROL_INTERFACE_DESC_SZ(n)      0x08+n
+#define AUDIO_STREAMING_INTERFACE_DESC_SIZE     0x07
+#define AUDIO_INPUT_TERMINAL_DESC_SIZE          0x0C
+#define AUDIO_OUTPUT_TERMINAL_DESC_SIZE         0x09
+#define AUDIO_MIXER_UNIT_DESC_SZ(p,n)           0x0A+p+n
+#define AUDIO_SELECTOR_UNIT_DESC_SZ(p)          0x06+p
+#define AUDIO_FEATURE_UNIT_DESC_SZ(ch,n)        0x07+(ch+1)*n
+#define AUDIO_PROCESSING_UNIT_DESC_SZ(p,n,x)    0x0D+p+n+x
+#define AUDIO_EXTENSION_UNIT_DESC_SZ(p,n)       0x0D+p+n
+#define AUDIO_STANDARD_ENDPOINT_DESC_SIZE       0x09
+#define AUDIO_STREAMING_ENDPOINT_DESC_SIZE      0x07
+
+
+/* Audio Processing Unit Process Types */
+#define AUDIO_UNDEFINED_PROCESS                 0x00
+#define AUDIO_UP_DOWN_MIX_PROCESS               0x01
+#define AUDIO_DOLBY_PROLOGIC_PROCESS            0x02
+#define AUDIO_3D_STEREO_PROCESS                 0x03
+#define AUDIO_REVERBERATION_PROCESS             0x04
+#define AUDIO_CHORUS_PROCESS                    0x05
+#define AUDIO_DYN_RANGE_COMP_PROCESS            0x06
+
+
+/* Audio Request Codes */
+#define AUDIO_REQUEST_UNDEFINED                 0x00
+#define AUDIO_REQUEST_SET_CUR                   0x01
+#define AUDIO_REQUEST_GET_CUR                   0x81
+#define AUDIO_REQUEST_SET_MIN                   0x02
+#define AUDIO_REQUEST_GET_MIN                   0x82
+#define AUDIO_REQUEST_SET_MAX                   0x03
+#define AUDIO_REQUEST_GET_MAX                   0x83
+#define AUDIO_REQUEST_SET_RES                   0x04
+#define AUDIO_REQUEST_GET_RES                   0x84
+#define AUDIO_REQUEST_SET_MEM                   0x05
+#define AUDIO_REQUEST_GET_MEM                   0x85
+#define AUDIO_REQUEST_GET_STAT                  0xFF
+
+
+/* Audio Control Selector Codes */
+#define AUDIO_CONTROL_UNDEFINED                 0x00    /* Common Selector */
+
+/*  Terminal Control Selectors */
+#define AUDIO_COPY_PROTECT_CONTROL              0x01
+
+/*  Feature Unit Control Selectors */
+#define AUDIO_MUTE_CONTROL                      0x01
+#define AUDIO_VOLUME_CONTROL                    0x02
+#define AUDIO_BASS_CONTROL                      0x03
+#define AUDIO_MID_CONTROL                       0x04
+#define AUDIO_TREBLE_CONTROL                    0x05
+#define AUDIO_GRAPHIC_EQUALIZER_CONTROL         0x06
+#define AUDIO_AUTOMATIC_GAIN_CONTROL            0x07
+#define AUDIO_DELAY_CONTROL                     0x08
+#define AUDIO_BASS_BOOST_CONTROL                0x09
+#define AUDIO_LOUDNESS_CONTROL                  0x0A
+
+/*  Processing Unit Control Selectors: */
+#define AUDIO_ENABLE_CONTROL                    0x01    /* Common Selector */
+#define AUDIO_MODE_SELECT_CONTROL               0x02    /* Common Selector */
+
+/*  - Up/Down-mix Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+/*      AUDIO_MODE_SELECT_CONTROL               0x02       Common Selector */
+
+/*  - Dolby Prologic Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+/*      AUDIO_MODE_SELECT_CONTROL               0x02       Common Selector */
+
+/*  - 3D Stereo Extender Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_SPACIOUSNESS_CONTROL              0x02
+
+/*  - Reverberation Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_REVERB_LEVEL_CONTROL              0x02
+#define AUDIO_REVERB_TIME_CONTROL               0x03
+#define AUDIO_REVERB_FEEDBACK_CONTROL           0x04
+
+/*  - Chorus Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_CHORUS_LEVEL_CONTROL              0x02
+#define AUDIO_SHORUS_RATE_CONTROL               0x03
+#define AUDIO_CHORUS_DEPTH_CONTROL              0x04
+
+/*  - Dynamic Range Compressor Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_COMPRESSION_RATE_CONTROL          0x02
+#define AUDIO_MAX_AMPL_CONTROL                  0x03
+#define AUDIO_THRESHOLD_CONTROL                 0x04
+#define AUDIO_ATTACK_TIME_CONTROL               0x05
+#define AUDIO_RELEASE_TIME_CONTROL              0x06
+
+/*  Extension Unit Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+
+/*  Endpoint Control Selectors */
+#define AUDIO_SAMPLING_FREQ_CONTROL             0x01
+#define AUDIO_PITCH_CONTROL                     0x02
+
+
+/* Audio Format Specific Control Selectors */
+
+/*  MPEG Control Selectors */
+#define AUDIO_MPEG_CONTROL_UNDEFINED            0x00
+#define AUDIO_MPEG_DUAL_CHANNEL_CONTROL         0x01
+#define AUDIO_MPEG_SECOND_STEREO_CONTROL        0x02
+#define AUDIO_MPEG_MULTILINGUAL_CONTROL         0x03
+#define AUDIO_MPEG_DYN_RANGE_CONTROL            0x04
+#define AUDIO_MPEG_SCALING_CONTROL              0x05
+#define AUDIO_MPEG_HILO_SCALING_CONTROL         0x06
+
+/*  AC-3 Control Selectors */
+#define AUDIO_AC3_CONTROL_UNDEFINED             0x00
+#define AUDIO_AC3_MODE_CONTROL                  0x01
+#define AUDIO_AC3_DYN_RANGE_CONTROL             0x02
+#define AUDIO_AC3_SCALING_CONTROL               0x03
+#define AUDIO_AC3_HILO_SCALING_CONTROL          0x04
+
+
+/* Audio Format Types */
+#define AUDIO_FORMAT_TYPE_UNDEFINED             0x00
+#define AUDIO_FORMAT_TYPE_I                     0x01
+#define AUDIO_FORMAT_TYPE_II                    0x02
+#define AUDIO_FORMAT_TYPE_III                   0x03
+
+
+/* Audio Format Type Descriptor Sizes */
+#define AUDIO_FORMAT_TYPE_I_DESC_SZ(n)          0x08+(n*3)
+#define AUDIO_FORMAT_TYPE_II_DESC_SZ(n)         0x09+(n*3)
+#define AUDIO_FORMAT_TYPE_III_DESC_SZ(n)        0x08+(n*3)
+#define AUDIO_FORMAT_MPEG_DESC_SIZE             0x09
+#define AUDIO_FORMAT_AC3_DESC_SIZE              0x0A
+
+
+/* Audio Data Format Codes */
+
+/*  Audio Data Format Type I Codes */
+#define AUDIO_FORMAT_TYPE_I_UNDEFINED           0x0000
+#define AUDIO_FORMAT_PCM                        0x0001
+#define AUDIO_FORMAT_PCM8                       0x0002
+#define AUDIO_FORMAT_IEEE_FLOAT                 0x0003
+#define AUDIO_FORMAT_ALAW                       0x0004
+#define AUDIO_FORMAT_MULAW                      0x0005
+
+/*  Audio Data Format Type II Codes */
+#define AUDIO_FORMAT_TYPE_II_UNDEFINED          0x1000
+#define AUDIO_FORMAT_MPEG                       0x1001
+#define AUDIO_FORMAT_AC3                        0x1002
+
+/*  Audio Data Format Type III Codes */
+#define AUDIO_FORMAT_TYPE_III_UNDEFINED         0x2000
+#define AUDIO_FORMAT_IEC1937_AC3                0x2001
+#define AUDIO_FORMAT_IEC1937_MPEG1_L1           0x2002
+#define AUDIO_FORMAT_IEC1937_MPEG1_L2_3         0x2003
+#define AUDIO_FORMAT_IEC1937_MPEG2_NOEXT        0x2003
+#define AUDIO_FORMAT_IEC1937_MPEG2_EXT          0x2004
+#define AUDIO_FORMAT_IEC1937_MPEG2_L1_LS        0x2005
+#define AUDIO_FORMAT_IEC1937_MPEG2_L2_3         0x2006
+
+
+/* Predefined Audio Channel Configuration Bits */
+#define AUDIO_CHANNEL_M                         0x0000  /* Mono */
+#define AUDIO_CHANNEL_L                         0x0001  /* Left Front */
+#define AUDIO_CHANNEL_R                         0x0002  /* Right Front */
+#define AUDIO_CHANNEL_C                         0x0004  /* Center Front */
+#define AUDIO_CHANNEL_LFE                       0x0008  /* Low Freq. Enhance. */
+#define AUDIO_CHANNEL_LS                        0x0010  /* Left Surround */
+#define AUDIO_CHANNEL_RS                        0x0020  /* Right Surround */
+#define AUDIO_CHANNEL_LC                        0x0040  /* Left of Center */
+#define AUDIO_CHANNEL_RC                        0x0080  /* Right of Center */
+#define AUDIO_CHANNEL_S                         0x0100  /* Surround */
+#define AUDIO_CHANNEL_SL                        0x0200  /* Side Left */
+#define AUDIO_CHANNEL_SR                        0x0400  /* Side Right */
+#define AUDIO_CHANNEL_T                         0x0800  /* Top */
+
+
+/* Feature Unit Control Bits */
+#define AUDIO_CONTROL_MUTE                      0x0001
+#define AUDIO_CONTROL_VOLUME                    0x0002
+#define AUDIO_CONTROL_BASS                      0x0004
+#define AUDIO_CONTROL_MID                       0x0008
+#define AUDIO_CONTROL_TREBLE                    0x0010
+#define AUDIO_CONTROL_GRAPHIC_EQUALIZER         0x0020
+#define AUDIO_CONTROL_AUTOMATIC_GAIN            0x0040
+#define AUDIO_CONTROL_DEALY                     0x0080
+#define AUDIO_CONTROL_BASS_BOOST                0x0100
+#define AUDIO_CONTROL_LOUDNESS                  0x0200
+
+/* Processing Unit Control Bits: */
+#define AUDIO_CONTROL_ENABLE                    0x0001  /* Common Bit */
+#define AUDIO_CONTROL_MODE_SELECT               0x0002  /* Common Bit */
+
+/* - Up/Down-mix Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+/*      AUDIO_CONTROL_MODE_SELECT               0x0002     Common Bit */
+
+/* - Dolby Prologic Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+/*      AUDIO_CONTROL_MODE_SELECT               0x0002     Common Bit */
+
+/* - 3D Stereo Extender Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_SPACIOUSNESS              0x0002
+
+/* - Reverberation Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_REVERB_TYPE               0x0002
+#define AUDIO_CONTROL_REVERB_LEVEL              0x0004
+#define AUDIO_CONTROL_REVERB_TIME               0x0008
+#define AUDIO_CONTROL_REVERB_FEEDBACK           0x0010
+
+/* - Chorus Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_CHORUS_LEVEL              0x0002
+#define AUDIO_CONTROL_SHORUS_RATE               0x0004
+#define AUDIO_CONTROL_CHORUS_DEPTH              0x0008
+
+/* - Dynamic Range Compressor Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_COMPRESSION_RATE          0x0002
+#define AUDIO_CONTROL_MAX_AMPL                  0x0004
+#define AUDIO_CONTROL_THRESHOLD                 0x0008
+#define AUDIO_CONTROL_ATTACK_TIME               0x0010
+#define AUDIO_CONTROL_RELEASE_TIME              0x0020
+
+/* Extension Unit Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+
+/* Endpoint Control Bits */
+#define AUDIO_CONTROL_SAMPLING_FREQ             0x01
+#define AUDIO_CONTROL_PITCH                     0x02
+#define AUDIO_MAX_PACKETS_ONLY                  0x80
+
+
+/* Audio Terminal Types */
+
+/*  USB Terminal Types */
+#define AUDIO_TERMINAL_USB_UNDEFINED            0x0100
+#define AUDIO_TERMINAL_USB_STREAMING            0x0101
+#define AUDIO_TERMINAL_USB_VENDOR_SPECIFIC      0x01FF
+
+/*  Input Terminal Types */
+#define AUDIO_TERMINAL_INPUT_UNDEFINED          0x0200
+#define AUDIO_TERMINAL_MICROPHONE               0x0201
+#define AUDIO_TERMINAL_DESKTOP_MICROPHONE       0x0202
+#define AUDIO_TERMINAL_PERSONAL_MICROPHONE      0x0203
+#define AUDIO_TERMINAL_OMNI_DIR_MICROPHONE      0x0204
+#define AUDIO_TERMINAL_MICROPHONE_ARRAY         0x0205
+#define AUDIO_TERMINAL_PROCESSING_MIC_ARRAY     0x0206
+
+/*  Output Terminal Types */
+#define AUDIO_TERMINAL_OUTPUT_UNDEFINED         0x0300
+#define AUDIO_TERMINAL_SPEAKER                  0x0301
+#define AUDIO_TERMINAL_HEADPHONES               0x0302
+#define AUDIO_TERMINAL_HEAD_MOUNTED_AUDIO       0x0303
+#define AUDIO_TERMINAL_DESKTOP_SPEAKER          0x0304
+#define AUDIO_TERMINAL_ROOM_SPEAKER             0x0305
+#define AUDIO_TERMINAL_COMMUNICATION_SPEAKER    0x0306
+#define AUDIO_TERMINAL_LOW_FREQ_SPEAKER         0x0307
+
+/*  Bi-directional Terminal Types */
+#define AUDIO_TERMINAL_BIDIRECTIONAL_UNDEFINED  0x0400
+#define AUDIO_TERMINAL_HANDSET                  0x0401
+#define AUDIO_TERMINAL_HEAD_MOUNTED_HANDSET     0x0402
+#define AUDIO_TERMINAL_SPEAKERPHONE             0x0403
+#define AUDIO_TERMINAL_SPEAKERPHONE_ECHOSUPRESS 0x0404
+#define AUDIO_TERMINAL_SPEAKERPHONE_ECHOCANCEL  0x0405
+
+/*  Telephony Terminal Types */
+#define AUDIO_TERMINAL_TELEPHONY_UNDEFINED      0x0500
+#define AUDIO_TERMINAL_PHONE_LINE               0x0501
+#define AUDIO_TERMINAL_TELEPHONE                0x0502
+#define AUDIO_TERMINAL_DOWN_LINE_PHONE          0x0503
+
+/*  External Terminal Types */
+#define AUDIO_TERMINAL_EXTERNAL_UNDEFINED       0x0600
+#define AUDIO_TERMINAL_ANALOG_CONNECTOR         0x0601
+#define AUDIO_TERMINAL_DIGITAL_AUDIO_INTERFACE  0x0602
+#define AUDIO_TERMINAL_LINE_CONNECTOR           0x0603
+#define AUDIO_TERMINAL_LEGACY_AUDIO_CONNECTOR   0x0604
+#define AUDIO_TERMINAL_SPDIF_INTERFACE          0x0605
+#define AUDIO_TERMINAL_1394_DA_STREAM           0x0606
+#define AUDIO_TERMINAL_1394_DA_STREAM_TRACK     0x0607
+
+/*  Embedded Function Terminal Types */
+#define AUDIO_TERMINAL_EMBEDDED_UNDEFINED       0x0700
+#define AUDIO_TERMINAL_CALIBRATION_NOISE        0x0701
+#define AUDIO_TERMINAL_EQUALIZATION_NOISE       0x0702
+#define AUDIO_TERMINAL_CD_PLAYER                0x0703
+#define AUDIO_TERMINAL_DAT                      0x0704
+#define AUDIO_TERMINAL_DCC                      0x0705
+#define AUDIO_TERMINAL_MINI_DISK                0x0706
+#define AUDIO_TERMINAL_ANALOG_TAPE              0x0707
+#define AUDIO_TERMINAL_PHONOGRAPH               0x0708
+#define AUDIO_TERMINAL_VCR_AUDIO                0x0709
+#define AUDIO_TERMINAL_VIDEO_DISC_AUDIO         0x070A
+#define AUDIO_TERMINAL_DVD_AUDIO                0x070B
+#define AUDIO_TERMINAL_TV_TUNER_AUDIO           0x070C
+#define AUDIO_TERMINAL_SATELLITE_RECEIVER_AUDIO 0x070D
+#define AUDIO_TERMINAL_CABLE_TUNER_AUDIO        0x070E
+#define AUDIO_TERMINAL_DSS_AUDIO                0x070F
+#define AUDIO_TERMINAL_RADIO_RECEIVER           0x0710
+#define AUDIO_TERMINAL_RADIO_TRANSMITTER        0x0711
+#define AUDIO_TERMINAL_MULTI_TRACK_RECORDER     0x0712
+#define AUDIO_TERMINAL_SYNTHESIZER              0x0713
+
+
+#endif  /* __AUDIO_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_cdc.h ./lpc_chip_43xx/inc/usbd/usbd_cdc.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_cdc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_cdc.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,249 @@
+/***********************************************************************
+* $Id:: mw_usbd_cdc.h 165 2011-04-14 17:41:11Z usb10131                       $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Communication Device Class User module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __CDC_H
+#define __CDC_H
+
+#include "usbd.h"
+
+/*----------------------------------------------------------------------------
+ *      Definitions  based on usbcdc11.pdf (www.usb.org)
+ *---------------------------------------------------------------------------*/
+/* Communication device class specification version 1.10 */
+#define CDC_V1_10                               0x0110
+
+/* Communication interface class code */
+/* (usbcdc11.pdf, 4.2, Table 15) */
+#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
+
+/* Communication interface class subclass codes */
+/* (usbcdc11.pdf, 4.3, Table 16) */
+#define CDC_DIRECT_LINE_CONTROL_MODEL           0x01
+#define CDC_ABSTRACT_CONTROL_MODEL              0x02
+#define CDC_TELEPHONE_CONTROL_MODEL             0x03
+#define CDC_MULTI_CHANNEL_CONTROL_MODEL         0x04
+#define CDC_CAPI_CONTROL_MODEL                  0x05
+#define CDC_ETHERNET_NETWORKING_CONTROL_MODEL   0x06
+#define CDC_ATM_NETWORKING_CONTROL_MODEL        0x07
+
+/* Communication interface class control protocol codes */
+/* (usbcdc11.pdf, 4.4, Table 17) */
+#define CDC_PROTOCOL_COMMON_AT_COMMANDS         0x01
+
+/* Data interface class code */
+/* (usbcdc11.pdf, 4.5, Table 18) */
+#define CDC_DATA_INTERFACE_CLASS                0x0A
+
+/* Data interface class protocol codes */
+/* (usbcdc11.pdf, 4.7, Table 19) */
+#define CDC_PROTOCOL_ISDN_BRI                   0x30
+#define CDC_PROTOCOL_HDLC                       0x31
+#define CDC_PROTOCOL_TRANSPARENT                0x32
+#define CDC_PROTOCOL_Q921_MANAGEMENT            0x50
+#define CDC_PROTOCOL_Q921_DATA_LINK             0x51
+#define CDC_PROTOCOL_Q921_MULTIPLEXOR           0x52
+#define CDC_PROTOCOL_V42                        0x90
+#define CDC_PROTOCOL_EURO_ISDN                  0x91
+#define CDC_PROTOCOL_V24_RATE_ADAPTATION        0x92
+#define CDC_PROTOCOL_CAPI                       0x93
+#define CDC_PROTOCOL_HOST_BASED_DRIVER          0xFD
+#define CDC_PROTOCOL_DESCRIBED_IN_PUFD          0xFE
+
+/* Type values for bDescriptorType field of functional descriptors */
+/* (usbcdc11.pdf, 5.2.3, Table 24) */
+#define CDC_CS_INTERFACE                        0x24
+#define CDC_CS_ENDPOINT                         0x25
+
+/* Type values for bDescriptorSubtype field of functional descriptors */
+/* (usbcdc11.pdf, 5.2.3, Table 25) */
+#define CDC_HEADER                              0x00
+#define CDC_CALL_MANAGEMENT                     0x01
+#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
+#define CDC_DIRECT_LINE_MANAGEMENT              0x03
+#define CDC_TELEPHONE_RINGER                    0x04
+#define CDC_REPORTING_CAPABILITIES              0x05
+#define CDC_UNION                               0x06
+#define CDC_COUNTRY_SELECTION                   0x07
+#define CDC_TELEPHONE_OPERATIONAL_MODES         0x08
+#define CDC_USB_TERMINAL                        0x09
+#define CDC_NETWORK_CHANNEL                     0x0A
+#define CDC_PROTOCOL_UNIT                       0x0B
+#define CDC_EXTENSION_UNIT                      0x0C
+#define CDC_MULTI_CHANNEL_MANAGEMENT            0x0D
+#define CDC_CAPI_CONTROL_MANAGEMENT             0x0E
+#define CDC_ETHERNET_NETWORKING                 0x0F
+#define CDC_ATM_NETWORKING                      0x10
+
+/* CDC class-specific request codes */
+/* (usbcdc11.pdf, 6.2, Table 46) */
+/* see Table 45 for info about the specific requests. */
+#define CDC_SEND_ENCAPSULATED_COMMAND           0x00
+#define CDC_GET_ENCAPSULATED_RESPONSE           0x01
+#define CDC_SET_COMM_FEATURE                    0x02
+#define CDC_GET_COMM_FEATURE                    0x03
+#define CDC_CLEAR_COMM_FEATURE                  0x04
+#define CDC_SET_AUX_LINE_STATE                  0x10
+#define CDC_SET_HOOK_STATE                      0x11
+#define CDC_PULSE_SETUP                         0x12
+#define CDC_SEND_PULSE                          0x13
+#define CDC_SET_PULSE_TIME                      0x14
+#define CDC_RING_AUX_JACK                       0x15
+#define CDC_SET_LINE_CODING                     0x20
+#define CDC_GET_LINE_CODING                     0x21
+#define CDC_SET_CONTROL_LINE_STATE              0x22
+#define CDC_SEND_BREAK                          0x23
+#define CDC_SET_RINGER_PARMS                    0x30
+#define CDC_GET_RINGER_PARMS                    0x31
+#define CDC_SET_OPERATION_PARMS                 0x32
+#define CDC_GET_OPERATION_PARMS                 0x33
+#define CDC_SET_LINE_PARMS                      0x34
+#define CDC_GET_LINE_PARMS                      0x35
+#define CDC_DIAL_DIGITS                         0x36
+#define CDC_SET_UNIT_PARAMETER                  0x37
+#define CDC_GET_UNIT_PARAMETER                  0x38
+#define CDC_CLEAR_UNIT_PARAMETER                0x39
+#define CDC_GET_PROFILE                         0x3A
+#define CDC_SET_ETHERNET_MULTICAST_FILTERS      0x40
+#define CDC_SET_ETHERNET_PMP_FILTER             0x41
+#define CDC_GET_ETHERNET_PMP_FILTER             0x42
+#define CDC_SET_ETHERNET_PACKET_FILTER          0x43
+#define CDC_GET_ETHERNET_STATISTIC              0x44
+#define CDC_SET_ATM_DATA_FORMAT                 0x50
+#define CDC_GET_ATM_DEVICE_STATISTICS           0x51
+#define CDC_SET_ATM_DEFAULT_VC                  0x52
+#define CDC_GET_ATM_VC_STATISTICS               0x53
+
+/* Communication feature selector codes */
+/* (usbcdc11.pdf, 6.2.2..6.2.4, Table 47) */
+#define CDC_ABSTRACT_STATE                      0x01
+#define CDC_COUNTRY_SETTING                     0x02
+
+/* Feature Status returned for ABSTRACT_STATE Selector */
+/* (usbcdc11.pdf, 6.2.3, Table 48) */
+#define CDC_IDLE_SETTING                        (1 << 0)
+#define CDC_DATA_MULTPLEXED_STATE               (1 << 1)
+
+
+/* Control signal bitmap values for the SetControlLineState request */
+/* (usbcdc11.pdf, 6.2.14, Table 51) */
+#define CDC_DTE_PRESENT                         (1 << 0)
+#define CDC_ACTIVATE_CARRIER                    (1 << 1)
+
+/* CDC class-specific notification codes */
+/* (usbcdc11.pdf, 6.3, Table 68) */
+/* see Table 67 for Info about class-specific notifications */
+#define CDC_NOTIFICATION_NETWORK_CONNECTION     0x00
+#define CDC_RESPONSE_AVAILABLE                  0x01
+#define CDC_AUX_JACK_HOOK_STATE                 0x08
+#define CDC_RING_DETECT                         0x09
+#define CDC_NOTIFICATION_SERIAL_STATE           0x20
+#define CDC_CALL_STATE_CHANGE                   0x28
+#define CDC_LINE_STATE_CHANGE                   0x29
+#define CDC_CONNECTION_SPEED_CHANGE             0x2A
+
+/* UART state bitmap values (Serial state notification). */
+/* (usbcdc11.pdf, 6.3.5, Table 69) */
+#define CDC_SERIAL_STATE_OVERRUN                (1 << 6)  /* receive data overrun error has occurred */
+#define CDC_SERIAL_STATE_PARITY                 (1 << 5)  /* parity error has occurred */
+#define CDC_SERIAL_STATE_FRAMING                (1 << 4)  /* framing error has occurred */
+#define CDC_SERIAL_STATE_RING                   (1 << 3)  /* state of ring signal detection */
+#define CDC_SERIAL_STATE_BREAK                  (1 << 2)  /* state of break detection */
+#define CDC_SERIAL_STATE_TX_CARRIER             (1 << 1)  /* state of transmission carrier */
+#define CDC_SERIAL_STATE_RX_CARRIER             (1 << 0)  /* state of receiver carrier */
+
+
+/*----------------------------------------------------------------------------
+ *      Structures  based on usbcdc11.pdf (www.usb.org)
+ *---------------------------------------------------------------------------*/
+
+/* Header functional descriptor */
+/* (usbcdc11.pdf, 5.2.3.1) */
+/* This header must precede any list of class-specific descriptors. */
+PRE_PACK struct POST_PACK _CDC_HEADER_DESCRIPTOR{
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* Header functional descriptor subtype */
+  uint16_t bcdCDC;                               /* USB CDC specification release version */
+};
+typedef struct _CDC_HEADER_DESCRIPTOR CDC_HEADER_DESCRIPTOR;
+
+/* Call management functional descriptor */
+/* (usbcdc11.pdf, 5.2.3.2) */
+/* Describes the processing of calls for the communication class interface. */
+PRE_PACK struct POST_PACK _CDC_CALL_MANAGEMENT_DESCRIPTOR {
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* call management functional descriptor subtype */
+  uint8_t  bmCapabilities;                       /* capabilities that this configuration supports */
+  uint8_t  bDataInterface;                       /* interface number of the data class interface used for call management (optional) */
+};
+typedef struct _CDC_CALL_MANAGEMENT_DESCRIPTOR CDC_CALL_MANAGEMENT_DESCRIPTOR;
+
+/* Abstract control management functional descriptor */
+/* (usbcdc11.pdf, 5.2.3.3) */
+/* Describes the command supported by the communication interface class with the Abstract Control Model subclass code. */
+PRE_PACK struct POST_PACK _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR {
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* abstract control management functional descriptor subtype */
+  uint8_t  bmCapabilities;                       /* capabilities supported by this configuration */
+};
+typedef struct _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR;
+
+/* Union functional descriptors */
+/* (usbcdc11.pdf, 5.2.3.8) */
+/* Describes the relationship between a group of interfaces that can be considered to form a functional unit. */
+PRE_PACK struct POST_PACK _CDC_UNION_DESCRIPTOR {
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* union functional descriptor subtype */
+  uint8_t  bMasterInterface;                     /* interface number designated as master */
+};
+typedef struct _CDC_UNION_DESCRIPTOR CDC_UNION_DESCRIPTOR;
+
+/* Union functional descriptors with one slave interface */
+/* (usbcdc11.pdf, 5.2.3.8) */
+PRE_PACK struct POST_PACK _CDC_UNION_1SLAVE_DESCRIPTOR {
+  CDC_UNION_DESCRIPTOR sUnion;              /* Union functional descriptor */
+  uint8_t              bSlaveInterfaces[1]; /* Slave interface 0 */
+};
+typedef struct _CDC_UNION_1SLAVE_DESCRIPTOR CDC_UNION_1SLAVE_DESCRIPTOR;
+
+/* Line coding structure */
+/* Format of the data returned when a GetLineCoding request is received */
+/* (usbcdc11.pdf, 6.2.13) */
+PRE_PACK struct POST_PACK _CDC_LINE_CODING {
+  uint32_t dwDTERate;                            /* Data terminal rate in bits per second */
+  uint8_t  bCharFormat;                          /* Number of stop bits */
+  uint8_t  bParityType;                          /* Parity bit type */
+  uint8_t  bDataBits;                            /* Number of data bits */
+};
+typedef struct _CDC_LINE_CODING CDC_LINE_CODING;
+
+/* Notification header */
+/* Data sent on the notification endpoint must follow this header. */
+/* see  USB_SETUP_PACKET in file usb.h */
+typedef USB_SETUP_PACKET CDC_NOTIFICATION_HEADER;
+
+#endif /* __CDC_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_cdcuser.h ./lpc_chip_43xx/inc/usbd/usbd_cdcuser.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_cdcuser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_cdcuser.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,529 @@
+/***********************************************************************
+* $Id:: mw_usbd_cdcuser.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Communication Device Class User module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __CDCUSER_H__
+#define __CDCUSER_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_cdc.h"
+
+/** \file
+ *  \brief Communication Device Class (CDC) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based CDC function driver.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_CDC Communication Device Class (CDC) Function Driver
+ *  \section Sec_CDCModDescription Module Description
+ *  CDC Class Function Driver module. This module contains an internal implementation of the USB CDC Class.
+ *
+ *  User applications can use this class driver instead of implementing the CDC-ACM class manually
+ *  via the low-level USBD_HW and USBD_Core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB CDC-ACM Class.
+ */
+
+/*----------------------------------------------------------------------------
+  We need a buffer for incoming data on USB port because USB receives
+  much faster than  UART transmits
+ *---------------------------------------------------------------------------*/
+/* Buffer masks */
+#define CDC_BUF_SIZE               (128)               /* Output buffer in bytes (power 2) */
+                                                       /* large enough for file transfer */
+#define CDC_BUF_MASK               (CDC_BUF_SIZE-1ul)
+
+/** \brief Communication Device Class function driver initialization parameter data structure.
+ *  \ingroup USBD_CDC
+ *
+ *  \details  This data structure is used to pass initialization parameters to the
+ *  Communication Device Class function driver's init function.
+ *
+ */
+typedef struct USBD_CDC_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use.
+                      \note The \em mem_size should be greater than the size
+                      returned by USBD_CDC_API::GetMemSize() routine.*/
+  /** Pointer to the control interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T
+  * structure. The stack assumes both HS and FS use same BULK endpoints.
+  */
+  uint8_t* cif_intf_desc;
+  /** Pointer to the data interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T
+  * structure. The stack assumes both HS and FS use same BULK endpoints.
+  */
+  uint8_t* dif_intf_desc;
+
+  /* user defined functions */
+
+  /* required functions */
+  /**
+  *  Communication Interface Class specific get request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends CIC management element get requests.
+  *  \note Applications implementing Abstract Control Model subclass can set this
+  *  param to NULL. As the default driver parses ACM requests and calls the
+  *  individual ACM call-back routines defined in this structure. For all other subclasses
+  *  this routine should be provided by the application.
+  *  \n
+  *  The setup packet data (\em pSetup) is passed to the call-back so that application
+  *  can extract the CIC request type and other associated data. By default the stack
+  *  will assign \em pBuffer pointer to \em EP0Buff allocated at init. The application
+  *  code can directly write data into this buffer as long as data is less than 64 byte.
+  *  If more data has to be sent then application code should update \em pBuffer pointer
+  *  and length accordingly.
+  *
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing request data.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in, out] length  Amount of data to be sent back to host.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*CIC_GetRequest)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length);
+
+  /**
+  *  Communication Interface Class specific set request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a CIC management element requests.
+  *  \note Applications implementing Abstract Control Model subclass can set this
+  *  param to NULL. As the default driver parses ACM requests and calls the
+  *  individual ACM call-back routines defined in this structure. For all other subclasses
+  *  this routine should be provided by the application.
+  *  \n
+  *  The setup packet data (\em pSetup) is passed to the call-back so that application can
+  *  extract the CIC request type and other associated data. If a set request has data associated,
+  *  then this call-back is called twice.
+  *  -# First when setup request is received, at this time application code could update
+  *  \em pBuffer pointer to point to the intended destination. The length param is set to 0
+  *  so that application code knows this is first time. By default the stack will
+  *  assign \em pBuffer pointer to \em EP0Buff allocated at init. Note, if data length is
+  *  greater than 64 bytes and application code doesn't update \em pBuffer pointer the
+  *  stack will send STALL condition to host.
+  *  -# Second when the data is received from the host. This time the length param is set
+  *  with number of data bytes received.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing request data.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*CIC_SetRequest)( USBD_HANDLE_T hCdc, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+
+  /**
+  *  Communication Device Class specific BULK IN endpoint handler.
+  *
+  *  The application software should provide the BULK IN endpoint handler.
+  *  Applications should transfer data depending on the communication protocol type set in descriptors.
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*CDC_BulkIN_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /**
+  *  Communication Device Class specific BULK OUT endpoint handler.
+  *
+  *  The application software should provide the BULK OUT endpoint handler.
+  *  Applications should transfer data depending on the communication protocol type set in descriptors.
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*CDC_BulkOUT_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SEND_ENCAPSULATED_COMMAND request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SEND_ENCAPSULATED_COMMAND set request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] buffer Pointer to the command buffer.
+  *  \param[in] len  Length of the command buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SendEncpsCmd) (USBD_HANDLE_T hCDC, uint8_t* buffer, uint16_t len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific GET_ENCAPSULATED_RESPONSE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a GET_ENCAPSULATED_RESPONSE request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in, out] buffer Pointer to a pointer of data buffer containing response data.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in, out] len  Amount of data to be sent back to host.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*GetEncpsResp) (USBD_HANDLE_T hCDC, uint8_t** buffer, uint16_t* len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SET_COMM_FEATURE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SET_COMM_FEATURE set request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.
+  *  \param[in] buffer Pointer to the settings buffer for the specified communication feature.
+  *  \param[in] len  Length of the request buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t* buffer, uint16_t len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific GET_COMM_FEATURE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a GET_ENCAPSULATED_RESPONSE request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.
+  *  \param[in, out] buffer Pointer to a pointer of data buffer containing current settings
+  *                         for the communication feature.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *  \param[in, out] len  Amount of data to be sent back to host.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*GetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t** pBuffer, uint16_t* len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific CLEAR_COMM_FEATURE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a CLEAR_COMM_FEATURE request. In the call-back the application
+  *  should Clears the settings for a particular communication feature.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*ClrCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SET_CONTROL_LINE_STATE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SET_CONTROL_LINE_STATE request. RS-232 signal used to tell the DCE
+  *  device the DTE device is now present
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] state The state value uses bitmap values defined in usbcdc11.pdf,
+  *        section 6.2.14, Table 51.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SetCtrlLineState) (USBD_HANDLE_T hCDC, uint16_t state);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SEND_BREAK request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SEND_BREAK request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] mstime Duration of Break signal in milliseconds. If mstime is FFFFh, then
+  *        the application should send break until another SendBreak request is received
+  *        with the wValue of 0000h.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SendBreak) (USBD_HANDLE_T hCDC, uint16_t mstime);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SET_LINE_CODING request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SET_LINE_CODING request. The application should configure the device
+  *  per DTE rate, stop-bits, parity, and number-of-character bits settings provided in
+  *  command buffer. See usbcdc11.pdf, section 6.2.13, table 50 for detail of the command buffer.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] line_coding Pointer to the CDC_LINE_CODING command buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SetLineCode) (USBD_HANDLE_T hCDC, CDC_LINE_CODING* line_coding);
+
+  /**
+  *  Optional Communication Device Class specific INTERRUPT IN endpoint handler.
+  *
+  *  The application software should provide the INT IN endpoint handler.
+  *  Applications should transfer data depending on the communication protocol type set in descriptors.
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*CDC_InterruptEP_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /**
+  *  Optional user override-able function to replace the default CDC class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_CDC_API::Init().
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*CDC_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+} USBD_CDC_INIT_PARAM_T;
+
+/** \brief CDC class API functions structure.
+ *  \ingroup USBD_CDC
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_CDC_API
+{
+  /** \fn uint32_t GetMemSize(USBD_CDC_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the CDC function driver module.
+   *
+   *  This function is called by application layer before calling pUsbApi->CDC->Init(), to allocate memory used
+   *  by CDC function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller.
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing CDC function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_CDC_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param)
+   *  Function to initialize CDC function driver module.
+   *
+   *  This function is called by application layer to initialize CDC function driver module.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in, out] param Structure containing CDC function driver module initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte
+   *              aligned or smaller than required.
+   *          \retval ERR_API_INVALID_PARAM2 Either CDC_Write() or CDC_Read() or
+   *              CDC_Verify() callbacks are not defined.
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.
+   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed.
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param, USBD_HANDLE_T* phCDC);
+
+  /** \fn ErrorCode_t SendNotification(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data)
+   *  Function to send CDC class notifications to host.
+   *
+   *  This function is called by application layer to send CDC class notifications to host.
+   *  See usbcdc11.pdf, section 6.3, Table 67 for various notification types the CDC device can send.
+   *  \note The current version of the driver only supports following notifications allowed by ACM subclass:
+   *  CDC_NOTIFICATION_NETWORK_CONNECTION, CDC_RESPONSE_AVAILABLE, CDC_NOTIFICATION_SERIAL_STATE.
+   *  \n
+   *  For all other notifications application should construct the notification buffer appropriately
+   *  and call hw->USB_WriteEP() for interrupt endpoint associated with the interface.
+   *
+   *  \param[in] hCdc Handle to CDC function driver.
+   *  \param[in] bNotification Notification type allowed by ACM subclass. Should be CDC_NOTIFICATION_NETWORK_CONNECTION,
+   *        CDC_RESPONSE_AVAILABLE or CDC_NOTIFICATION_SERIAL_STATE. For all other types ERR_API_INVALID_PARAM2
+   *        is returned. See usbcdc11.pdf, section 3.6.2.1, table 5.
+   *  \param[in] data Data associated with notification.
+   *        \n For CDC_NOTIFICATION_NETWORK_CONNECTION a non-zero data value is interpreted as connected state.
+   *        \n For CDC_RESPONSE_AVAILABLE this parameter is ignored.
+   *        \n For CDC_NOTIFICATION_SERIAL_STATE the data should use bitmap values defined in usbcdc11.pdf,
+   *        section 6.3.5, Table 69.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_API_INVALID_PARAM2  If unsupported notification type is passed.
+   *
+   */
+  ErrorCode_t (*SendNotification)(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data);
+
+} USBD_CDC_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _CDC_CTRL_T
+{
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  /* notification buffer */
+  uint8_t notice_buf[12];
+  CDC_LINE_CODING line_coding;
+  uint8_t pad0;
+
+  uint8_t cif_num;                 /* control interface number */
+  uint8_t dif_num;                 /* data interface number */
+  uint8_t epin_num;                /* BULK IN endpoint number */
+  uint8_t epout_num;               /* BULK OUT endpoint number */
+  uint8_t epint_num;               /* Interrupt IN endpoint number */
+  uint8_t pad[3];
+  /* user defined functions */
+  ErrorCode_t (*SendEncpsCmd) (USBD_HANDLE_T hCDC, uint8_t* buffer, uint16_t len);
+  ErrorCode_t (*GetEncpsResp) (USBD_HANDLE_T hCDC, uint8_t** buffer, uint16_t* len);
+  ErrorCode_t (*SetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t* buffer, uint16_t len);
+  ErrorCode_t (*GetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t** pBuffer, uint16_t* len);
+  ErrorCode_t (*ClrCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature);
+  ErrorCode_t (*SetCtrlLineState) (USBD_HANDLE_T hCDC, uint16_t state);
+  ErrorCode_t (*SendBreak) (USBD_HANDLE_T hCDC, uint16_t state);
+  ErrorCode_t (*SetLineCode) (USBD_HANDLE_T hCDC, CDC_LINE_CODING* line_coding);
+
+  /* virtual functions */
+  ErrorCode_t (*CIC_GetRequest)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length);
+  ErrorCode_t (*CIC_SetRequest)( USBD_HANDLE_T hCdc, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+
+} USB_CDC_CTRL_T;
+
+/* structure used by old ROM drivers, needed for workaround */
+typedef struct _CDC0_CTRL_T {
+   USB_CORE_CTRL_T *pUsbCtrl;
+   /* notification buffer */
+   uint8_t notice_buf[12];
+   CDC_LINE_CODING line_coding;
+
+   uint8_t cif_num;                /* control interface number */
+   uint8_t dif_num;                /* data interface number */
+   uint8_t epin_num;               /* BULK IN endpoint number */
+   uint8_t epout_num;              /* BULK OUT endpoint number */
+   uint8_t epint_num;              /* Interrupt IN endpoint number */
+   /* user defined functions */
+   ErrorCode_t (*SendEncpsCmd)(USBD_HANDLE_T hCDC, uint8_t *buffer, uint16_t len);
+   ErrorCode_t (*GetEncpsResp)(USBD_HANDLE_T hCDC, uint8_t * *buffer, uint16_t *len);
+   ErrorCode_t (*SetCommFeature)(USBD_HANDLE_T hCDC, uint16_t feature, uint8_t *buffer, uint16_t len);
+   ErrorCode_t (*GetCommFeature)(USBD_HANDLE_T hCDC, uint16_t feature, uint8_t * *pBuffer, uint16_t *len);
+   ErrorCode_t (*ClrCommFeature)(USBD_HANDLE_T hCDC, uint16_t feature);
+   ErrorCode_t (*SetCtrlLineState)(USBD_HANDLE_T hCDC, uint16_t state);
+   ErrorCode_t (*SendBreak)(USBD_HANDLE_T hCDC, uint16_t state);
+   ErrorCode_t (*SetLineCode)(USBD_HANDLE_T hCDC, CDC_LINE_CODING *line_coding);
+
+   /* virtual functions */
+   ErrorCode_t (*CIC_GetRequest)(USBD_HANDLE_T hHid, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t *length);
+   ErrorCode_t (*CIC_SetRequest)(USBD_HANDLE_T hCdc, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length);
+
+} USB_CDC0_CTRL_T;
+
+typedef ErrorCode_t (*CIC_SetRequest_t)(USBD_HANDLE_T hCdc, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length);
+
+/** @cond  DIRECT_API */
+extern uint32_t mwCDC_GetMemSize(USBD_CDC_INIT_PARAM_T* param);
+extern ErrorCode_t mwCDC_init(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param, USBD_HANDLE_T* phCDC);
+extern ErrorCode_t mwCDC_SendNotification (USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data);
+/** @endcond */
+
+/** @endcond */
+
+
+
+
+
+#endif  /* __CDCUSER_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_core.h ./lpc_chip_43xx/inc/usbd/usbd_core.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_core.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_core.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,585 @@
+/***********************************************************************
+* $Id:: mw_usbd_core.h 331 2012-08-09 18:54:34Z usb10131                      $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB core controller structure definitions and function prototypes.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MW_USBD_CORE_H__
+#define __MW_USBD_CORE_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "app_usbd_cfg.h"
+
+/** \file
+ *  \brief ROM API for USB device stack.
+ *
+ *  Definition of functions exported by core layer of ROM based USB device stack.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_Core USB Core Layer
+ *  \section Sec_CoreModDescription Module Description
+ *  The USB Core Layer implements the device abstraction defined in the <em> Universal Serial Bus Specification, </em>
+ *  for applications to interact with the USB device interface on the device. The software in this layer responds to
+ *  standard requests and returns standard descriptors. In current stack the Init() routine part of
+ *  \ref USBD_HW_API_T structure initializes both hardware layer and core layer.
+ */
+
+
+/* function pointer types */
+
+/** \ingroup USBD_Core
+ *  \typedef USB_CB_T
+ *  \brief USB device stack's event callback function type.
+ *
+ *  The USB device stack exposes several event triggers through callback to application layer. The
+ *  application layer can register methods to be called when such USB event happens.
+ *
+ *  \param[in] hUsb Handle to the USB device stack.
+ *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+ *          \retval LPC_OK On success
+ *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+ *          \retval ERR_USBD_xxx  Other error conditions.
+ *
+ */
+typedef ErrorCode_t (*USB_CB_T) (USBD_HANDLE_T hUsb);
+
+/** \ingroup USBD_Core
+ *  \typedef USB_PARAM_CB_T
+ *  \brief USB device stack's event callback function type.
+ *
+ *  The USB device stack exposes several event triggers through callback to application layer. The
+ *  application layer can register methods to be called when such USB event happens.
+ *
+ *  \param[in] hUsb Handle to the USB device stack.
+ *  \param[in] param1 Extra information related to the event.
+ *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+ *          \retval LPC_OK On success
+ *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+ *          \retval ERR_USBD_xxx  For other error conditions.
+ *
+ */
+typedef ErrorCode_t (*USB_PARAM_CB_T) (USBD_HANDLE_T hUsb, uint32_t param1);
+
+/** \ingroup USBD_Core
+ *  \typedef USB_EP_HANDLER_T
+ *  \brief USBD setup request and endpoint event handler type.
+ *
+ *  The application layer should define the custom class's EP0 handler with function signature.
+ *  The stack calls all the registered class handlers on any EP0 event before going through default
+ *  handling of the event. This gives the class handlers to implement class specific request handlers
+ *  and also to override the default stack handling for a particular event targeted to the interface.
+ *  If an event is not handled by the callback the function should return ERR_USBD_UNHANDLED. For all
+ *  other return codes the stack assumes that callback has taken care of the event and hence will not
+ *  process the event any further and issues a STALL condition on EP0 indicating error to the host.
+ *  \n
+ *  For endpoint interrupt handler the return value is ignored by the stack.
+ *  \n
+ *  \param[in] hUsb Handle to the USB device stack.
+ *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+ *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+ *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+ *          \retval LPC_OK On success.
+ *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+ *          \retval ERR_USBD_xxx  For other error conditions.
+ *
+ */
+typedef ErrorCode_t (*USB_EP_HANDLER_T)(USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+
+/** \ingroup USBD_Core
+ *  \brief USB descriptors data structure.
+ *  \ingroup USBD_Core
+ *
+ *  \details  This structure is used as part of USB device stack initialization
+ *  parameter structure \ref USBD_API_INIT_PARAM_T. This structure contains
+ *  pointers to various descriptor arrays needed by the stack. These descriptors
+ *  are reported to USB host as part of enumerations process.
+ *
+ *  \note All descriptor pointers assigned in this structure should be on 4 byte
+ *  aligned address boundary.
+ */
+typedef struct _USB_CORE_DESCS_T
+{
+  uint8_t *device_desc; /**< Pointer to USB device descriptor */
+  uint8_t *string_desc; /**< Pointer to array of USB string descriptors */
+  uint8_t *full_speed_desc; /**< Pointer to USB device configuration descriptor
+                            * when device is operating in full speed mode.
+                            */
+  uint8_t *high_speed_desc; /**< Pointer to USB device configuration descriptor
+                            * when device is operating in high speed mode. For
+                            * full-speed only implementation this pointer should
+                            * be same as full_speed_desc.
+                            */
+  uint8_t *device_qualifier; /**< Pointer to USB device qualifier descriptor. For
+                             * full-speed only implementation this pointer should
+                             * be set to null (0).
+                             */
+} USB_CORE_DESCS_T;
+
+/** \brief USB device stack initialization parameter data structure.
+ *  \ingroup USBD_Core
+ *
+ *  \details  This data structure is used to pass initialization parameters to the
+ *  USB device stack's init function.
+ *
+ */
+typedef struct USBD_API_INIT_PARAM
+{
+  uint32_t usb_reg_base; /**< USB device controller's base register address. */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 2048 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use.
+                      \note The \em mem_size should be greater than the size
+                      returned by USBD_HW_API::GetMemSize() routine.*/
+  uint8_t max_num_ep; /**< max number of endpoints supported by the USB device
+                      controller instance (specified by \em usb_reg_base field)
+                      to which this instance of stack is attached.
+                      */
+  uint8_t pad0[3];
+  /* USB Device Events Callback Functions */
+   /** Event for USB interface reset. This event fires when the USB host requests that the device
+    *  reset its interface. This event fires after the control endpoint has been automatically
+    *  configured by the library.
+    *  \n
+    *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+    *  callback will prevent the device from enumerating correctly or operate properly.
+    *
+    */
+  USB_CB_T USB_Reset_Event;
+
+   /** Event for USB suspend. This event fires when the USB host suspends the device by halting its
+    *  transmission of Start Of Frame pulses to the device. This is generally hooked in order to move
+    *  the device over to a low power state until the host wakes up the device.
+    *  \n
+    *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+    *  callback will cause other system issues.
+    */
+  USB_CB_T USB_Suspend_Event;
+
+   /** Event for USB wake up or resume. This event fires when a the USB device interface is suspended
+    *  and the host wakes up the device by supplying Start Of Frame pulses. This is generally
+    *  hooked to pull the user application out of a low power state and back into normal operating
+    *  mode.
+    *  \n
+    *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+    *  callback will cause other system issues.
+    *
+    */
+  USB_CB_T USB_Resume_Event;
+
+  /** Reserved parameter should be set to zero. */
+  USB_CB_T reserved_sbz;
+
+  /** Event for USB Start Of Frame detection, when enabled. This event fires at the start of each USB
+    *  frame, once per millisecond in full-speed mode or once per 125 microseconds in high-speed mode,
+   *  and is synchronized to the USB bus.
+    *
+    *  This event is time-critical; it is run once per millisecond (full-speed mode) and thus long handlers
+    *  will significantly degrade device performance. This event should only be enabled when needed to
+   *  reduce device wake-ups.
+    *
+    *  \note This event is not normally active - it must be manually enabled and disabled via the USB interrupt
+    *        register.
+    *        \n\n
+    */
+  USB_CB_T USB_SOF_Event;
+
+  /** Event for remote wake-up configuration, when enabled. This event fires when the USB host
+    *  request the device to configure itself for remote wake-up capability. The USB host sends
+   *  this request to device which report remote wake-up capable in their device descriptors,
+   *  before going to low-power state. The application layer should implement this callback if
+   *  they have any special on board circuit to trigger remote wake up event. Also application
+   *  can use this callback to differentiate the following SUSPEND event is caused by cable plug-out
+   *  or host SUSPEND request. The device can wake-up host only after receiving this callback and
+   *  remote wake-up feature is enabled by host. To signal remote wake-up the device has to generate
+   *  resume signaling on bus by calling usapi.hw->WakeUp() routine.
+    *
+    *  \n\n
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] param1 When 0 - Clear the wake-up configuration, 1 - Enable the wake-up configuration.
+   *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+    */
+  USB_PARAM_CB_T USB_WakeUpCfg;
+
+  /** Reserved parameter should be set to zero. */
+  USB_PARAM_CB_T USB_Power_Event;
+
+  /** Event for error condition. This event fires when USB device controller detect
+    *  an error condition in the system.
+    *
+    *  \n\n
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] param1 USB device interrupt status register.
+   *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+   */
+  USB_PARAM_CB_T USB_Error_Event;
+
+  /* USB Core Events Callback Functions */
+  /** Event for USB configuration number changed. This event fires when a the USB host changes the
+   *  selected configuration number. On receiving configuration change request from host, the stack
+   *  enables/configures the endpoints needed by the new configuration before calling this callback
+   *  function.
+    *  \n
+    *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+    *  callback will prevent the device from enumerating correctly or operate properly.
+   *
+   */
+  USB_CB_T USB_Configure_Event;
+
+  /** Event for USB interface setting changed. This event fires when a the USB host changes the
+   *  interface setting to one of alternate interface settings. On receiving interface change
+   *  request from host, the stack enables/configures the endpoints needed by the new alternate
+   *  interface setting before calling this callback function.
+    *  \n
+    *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+    *  callback will prevent the device from enumerating correctly or operate properly.
+   *
+   */
+  USB_CB_T USB_Interface_Event;
+
+  /** Event for USB feature changed. This event fires when a the USB host send set/clear feature
+   *  request. The stack handles this request for USB_FEATURE_REMOTE_WAKEUP, USB_FEATURE_TEST_MODE
+   *  and USB_FEATURE_ENDPOINT_STALL features only. On receiving feature request from host, the
+   *  stack handle the request appropriately and then calls this callback function.
+    *  \n
+    *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+    *  callback will prevent the device from enumerating correctly or operate properly.
+   *
+   */
+ USB_CB_T USB_Feature_Event;
+
+  /* cache and MMU translation functions */
+  /** Reserved parameter for future use. should be set to zero. */
+  uint32_t (* virt_to_phys)(void* vaddr);
+  /** Reserved parameter for future use. should be set to zero. */
+  void (* cache_flush)(uint32_t* start_adr, uint32_t* end_adr);
+
+} USBD_API_INIT_PARAM_T;
+
+
+/** \brief USBD stack Core API functions structure.
+ *  \ingroup USBD_Core
+ *
+ *  \details  This module exposes functions which interact directly with USB device stack's core layer.
+ *  The application layer uses this component when it has to implement custom class function driver or
+ *  standard class function driver which is not part of the current USB device stack.
+ *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
+ *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
+ *  function to register custom endpoint interrupt handler.
+ *
+ */
+typedef struct USBD_CORE_API
+{
+ /** \fn ErrorCode_t RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data)
+  *  Function to register class specific EP0 event handler with USB device stack.
+  *
+  *  The application layer uses this function when it has to register the custom class's EP0 handler.
+  *  The stack calls all the registered class handlers on any EP0 event before going through default
+  *  handling of the event. This gives the class handlers to implement class specific request handlers
+  *  and also to override the default stack handling for a particular event targeted to the interface.
+  *  Check \ref USB_EP_HANDLER_T for more details on how the callback function should be implemented. Also
+  *  application layer could use this function to register EP0 handler which responds to vendor specific
+  *  requests.
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] pfn  Class specific EP0 handler function.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success
+  *          \retval ERR_USBD_TOO_MANY_CLASS_HDLR(0x0004000c)  The number of class handlers registered is
+                        greater than the number of handlers allowed by the stack.
+  *
+  */
+  ErrorCode_t (*RegisterClassHandler)(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
+
+ /** \fn ErrorCode_t RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data)
+  *  Function to register interrupt/event handler for the requested endpoint with USB device stack.
+  *
+  *  The application layer uses this function to register the endpoint event handler.
+  *  The stack calls all the registered endpoint handlers when
+  *  - USB_EVT_OUT or USB_EVT_OUT_NAK events happen for OUT endpoint.
+  *  - USB_EVT_IN or USB_EVT_IN_NAK events happen for IN endpoint.
+  *  Check USB_EP_HANDLER_T for more details on how the callback function should be implemented.
+  *  \note By default endpoint _NAK events are not enabled. Application should call \ref USBD_HW_API_T::EnableEvent
+  *  for the corresponding endpoint.
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] ep_index  Endpoint index. Computed as
+  *                       - For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.
+  *                       - For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5.
+  *  \param[in] pfn  Endpoint event handler function.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success
+  *          \retval ERR_API_INVALID_PARAM2  ep_index is outside the boundary ( < 2 * USBD_API_INIT_PARAM_T::max_num_ep).
+  *
+  */
+  ErrorCode_t (*RegisterEpHandler)(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);
+
+  /** \fn void SetupStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in setup state.
+   *
+   *  This function is called by USB stack and the application layer to
+   *  set the EP0 state machine in setup state. This function will read
+   *  the setup packet received from USB host into stack's buffer.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other
+   *  scenarios which are not handle by current stack. In most user applications
+   *  this function is not called directly.Also this function can be used by
+   *  users who are selectively modifying the USB device stack's standard handlers
+   *  through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*SetupStage )(USBD_HANDLE_T hUsb);
+
+  /** \fn void DataInStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in data_in state.
+   *
+   *  This function is called by USB stack and the application layer to
+   *  set the EP0 state machine in data_in state. This function will write
+   *  the data present in EP0Data buffer to EP0 FIFO for transmission to host.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other
+   *  scenarios which are not handle by current stack. In most user applications
+   *  this function is not called directly.Also this function can be used by
+   *  users who are selectively modifying the USB device stack's standard handlers
+   *  through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*DataInStage)(USBD_HANDLE_T hUsb);
+
+  /** \fn void DataOutStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in data_out state.
+   *
+   *  This function is called by USB stack and the application layer to
+   *  set the EP0 state machine in data_out state. This function will read
+   *  the control data (EP0 out packets) received from USB host into EP0Data buffer.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other
+   *  scenarios which are not handle by current stack. In most user applications
+   *  this function is not called directly.Also this function can be used by
+   *  users who are selectively modifying the USB device stack's standard handlers
+   *  through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*DataOutStage)(USBD_HANDLE_T hUsb);
+
+  /** \fn void StatusInStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in status_in state.
+   *
+   *  This function is called by USB stack and the application layer to
+   *  set the EP0 state machine in status_in state. This function will send
+   *  zero length IN packet on EP0 to host, indicating positive status.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other
+   *  scenarios which are not handle by current stack. In most user applications
+   *  this function is not called directly.Also this function can be used by
+   *  users who are selectively modifying the USB device stack's standard handlers
+   *  through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*StatusInStage)(USBD_HANDLE_T hUsb);
+  /** \fn void StatusOutStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in status_out state.
+   *
+   *  This function is called by USB stack and the application layer to
+   *  set the EP0 state machine in status_out state. This function will read
+   *  the zero length OUT packet received from USB host on EP0.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other
+   *  scenarios which are not handle by current stack. In most user applications
+   *  this function is not called directly.Also this function can be used by
+   *  users who are selectively modifying the USB device stack's standard handlers
+   *  through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*StatusOutStage)(USBD_HANDLE_T hUsb);
+
+  /** \fn void StallEp0(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in stall state.
+   *
+   *  This function is called by USB stack and the application layer to
+   *  generate STALL signaling on EP0 endpoint. This function will also
+   *  reset the EP0Data buffer.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other
+   *  scenarios which are not handle by current stack. In most user applications
+   *  this function is not called directly.Also this function can be used by
+   *  users who are selectively modifying the USB device stack's standard handlers
+   *  through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*StallEp0)(USBD_HANDLE_T hUsb);
+
+} USBD_CORE_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+
+ /** @cond  ADVANCED_API */
+
+/* forward declaration */
+struct _USB_CORE_CTRL_T;
+typedef struct _USB_CORE_CTRL_T  USB_CORE_CTRL_T;
+
+/* USB device Speed status defines */
+#define USB_FULL_SPEED    0
+#define USB_HIGH_SPEED    1
+
+/* USB Endpoint Data Structure */
+typedef struct _USB_EP_DATA
+{
+  uint8_t  *pData;
+  uint16_t   Count;
+  uint16_t pad0;
+} USB_EP_DATA;
+
+
+/* USB core controller data structure */
+struct _USB_CORE_CTRL_T
+{
+  /* override-able function pointers ~ c++ style virtual functions*/
+  USB_CB_T USB_EvtSetupHandler;
+  USB_CB_T USB_EvtOutHandler;
+  USB_PARAM_CB_T USB_ReqVendor;
+  USB_CB_T USB_ReqGetStatus;
+  USB_CB_T USB_ReqGetDescriptor;
+  USB_CB_T USB_ReqGetConfiguration;
+  USB_CB_T USB_ReqSetConfiguration;
+  USB_CB_T USB_ReqGetInterface;
+  USB_CB_T USB_ReqSetInterface;
+  USB_PARAM_CB_T USB_ReqSetClrFeature;
+
+  /* USB Device Events Callback Functions */
+  USB_CB_T USB_Reset_Event;
+  USB_CB_T USB_Suspend_Event;
+  USB_CB_T USB_Resume_Event;
+  USB_CB_T USB_SOF_Event;
+  USB_PARAM_CB_T USB_Power_Event;
+  USB_PARAM_CB_T USB_Error_Event;
+  USB_PARAM_CB_T USB_WakeUpCfg;
+
+  /* USB Core Events Callback Functions */
+  USB_CB_T USB_Configure_Event;
+  USB_CB_T USB_Interface_Event;
+  USB_CB_T USB_Feature_Event;
+
+  /* cache and MMU translation functions */
+  uint32_t (* virt_to_phys)(void* vaddr);
+  void (* cache_flush)(uint32_t* start_adr, uint32_t* end_adr);
+
+  /* event handlers for endpoints. */
+  USB_EP_HANDLER_T  ep_event_hdlr[2 * USB_MAX_EP_NUM];
+  void*  ep_hdlr_data[2 * USB_MAX_EP_NUM];
+
+  /* USB class handlers */
+  USB_EP_HANDLER_T  ep0_hdlr_cb[USB_MAX_IF_NUM];
+  void*  ep0_cb_data[USB_MAX_IF_NUM];
+  uint8_t num_ep0_hdlrs;
+  /* USB Core data Variables */
+  uint8_t max_num_ep; /* max number of endpoints supported by the HW */
+  uint8_t device_speed;
+  uint8_t  num_interfaces;
+  uint8_t  device_addr;
+  uint8_t  config_value;
+  uint16_t device_status;
+  uint8_t *device_desc;
+  uint8_t *string_desc;
+  uint8_t *full_speed_desc;
+  uint8_t *high_speed_desc;
+  uint8_t *device_qualifier;
+  uint32_t ep_mask;
+  uint32_t ep_halt;
+  uint32_t ep_stall;
+  uint8_t  alt_setting[USB_MAX_IF_NUM];
+  /* HW driver data pointer */
+  void* hw_data;
+
+  /* USB Endpoint 0 Data Info */
+  USB_EP_DATA EP0Data;
+
+  /* USB Endpoint 0 Buffer */
+  //ALIGNED(4)
+  uint8_t  EP0Buf[64];
+
+  /* USB Setup Packet */
+  //ALIGNED(4)
+  USB_SETUP_PACKET SetupPacket;
+
+};
+
+/* USB Core Functions */
+extern void mwUSB_InitCore(USB_CORE_CTRL_T* pCtrl, USB_CORE_DESCS_T* pdescr, USBD_API_INIT_PARAM_T* param);
+extern void mwUSB_ResetCore(USBD_HANDLE_T hUsb);
+
+/* inline functions */
+static INLINE void USB_SetSpeedMode(USB_CORE_CTRL_T* pCtrl, uint8_t mode)
+{
+    pCtrl->device_speed = mode;
+}
+
+static INLINE bool USB_IsConfigured(USBD_HANDLE_T hUsb)
+{
+    USB_CORE_CTRL_T* pCtrl = (USB_CORE_CTRL_T*) hUsb;
+    return (bool) (pCtrl->config_value != 0);
+}
+
+/** @cond  DIRECT_API */
+/* midleware API */
+extern ErrorCode_t mwUSB_RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
+extern ErrorCode_t mwUSB_RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);
+extern void mwUSB_SetupStage (USBD_HANDLE_T hUsb);
+extern void mwUSB_DataInStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_DataOutStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StatusInStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StatusOutStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StallEp0(USBD_HANDLE_T hUsb);
+extern ErrorCode_t mwUSB_RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
+extern ErrorCode_t mwUSB_RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);
+extern void mwUSB_SetupStage (USBD_HANDLE_T hUsb);
+extern void mwUSB_DataInStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_DataOutStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StatusInStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StatusOutStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StallEp0(USBD_HANDLE_T hUsb);
+/** @endcond */
+
+/** @endcond */
+
+#endif  /* __MW_USBD_CORE_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_desc.h ./lpc_chip_43xx/inc/usbd/usbd_desc.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_desc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_desc.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,48 @@
+/***********************************************************************
+* $Id:: mw_usbd_desc.h 165 2011-04-14 17:41:11Z usb10131                      $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Descriptors Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __USBDESC_H__
+#define __USBDESC_H__
+
+#include "usbd.h"
+
+#define WBVAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+#define B3VAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF),(((x) >> 16) & 0xFF)
+
+#define USB_DEVICE_DESC_SIZE        (sizeof(USB_DEVICE_DESCRIPTOR))
+#define USB_CONFIGUARTION_DESC_SIZE (sizeof(USB_CONFIGURATION_DESCRIPTOR))
+#define USB_INTERFACE_DESC_SIZE     (sizeof(USB_INTERFACE_DESCRIPTOR))
+#define USB_ENDPOINT_DESC_SIZE      (sizeof(USB_ENDPOINT_DESCRIPTOR))
+#define USB_DEVICE_QUALI_SIZE       (sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR))
+#define USB_OTHER_SPEED_CONF_SIZE   (sizeof(USB_OTHER_SPEED_CONFIGURATION))
+
+//#define HID_DESC_SIZE               (sizeof(HID_DESCRIPTOR))
+//#define HID_REPORT_DESC_SIZE        (sizeof(HID_ReportDescriptor))
+
+extern const uint8_t  HID_ReportDescriptor[];
+extern const uint16_t HID_ReportDescSize;
+extern const uint16_t HID_DescOffset;
+
+
+#endif  /* __USBDESC_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_dfu.h ./lpc_chip_43xx/inc/usbd/usbd_dfu.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_dfu.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_dfu.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,120 @@
+/***********************************************************************
+* $Id:: mw_usbd_dfu.h 331 2012-08-09 18:54:34Z usb10131                       $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Device Firmware Upgrade (DFU) module.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MW_USBD_DFU_H__
+#define __MW_USBD_DFU_H__
+
+#include "usbd.h"
+
+/** \file
+ *  \brief Device Firmware Upgrade (DFU) class descriptors.
+ *
+ *  Definition of DFU class descriptors and their bit defines.
+ *
+ */
+
+/**
+ * If USB device is only DFU capable, DFU Interface number is always 0.
+ * if USB device is (DFU + Other Class (Audio/Mass Storage/HID), DFU
+ * Interface number should also be 0 in this implementation.
+ */
+#define USB_DFU_IF_NUM 0x0
+
+#define USB_DFU_DESCRIPTOR_TYPE     0x21
+#define USB_DFU_DESCRIPTOR_SIZE     9
+#define USB_DFU_SUBCLASS            0x01
+
+/* DFU class-specific requests (Section 3, DFU Rev 1.1) */
+#define USB_REQ_DFU_DETACH          0x00
+#define USB_REQ_DFU_DNLOAD          0x01
+#define USB_REQ_DFU_UPLOAD          0x02
+#define USB_REQ_DFU_GETSTATUS       0x03
+#define USB_REQ_DFU_CLRSTATUS       0x04
+#define USB_REQ_DFU_GETSTATE        0x05
+#define USB_REQ_DFU_ABORT           0x06
+
+#define DFU_STATUS_OK               0x00
+#define DFU_STATUS_errTARGET        0x01
+#define DFU_STATUS_errFILE          0x02
+#define DFU_STATUS_errWRITE         0x03
+#define DFU_STATUS_errERASE         0x04
+#define DFU_STATUS_errCHECK_ERASED  0x05
+#define DFU_STATUS_errPROG          0x06
+#define DFU_STATUS_errVERIFY        0x07
+#define DFU_STATUS_errADDRESS       0x08
+#define DFU_STATUS_errNOTDONE       0x09
+#define DFU_STATUS_errFIRMWARE      0x0a
+#define DFU_STATUS_errVENDOR        0x0b
+#define DFU_STATUS_errUSBR          0x0c
+#define DFU_STATUS_errPOR           0x0d
+#define DFU_STATUS_errUNKNOWN       0x0e
+#define DFU_STATUS_errSTALLEDPKT    0x0f
+
+enum dfu_state {
+  DFU_STATE_appIDLE             = 0,
+  DFU_STATE_appDETACH           = 1,
+  DFU_STATE_dfuIDLE             = 2,
+  DFU_STATE_dfuDNLOAD_SYNC      = 3,
+  DFU_STATE_dfuDNBUSY           = 4,
+  DFU_STATE_dfuDNLOAD_IDLE      = 5,
+  DFU_STATE_dfuMANIFEST_SYNC    = 6,
+  DFU_STATE_dfuMANIFEST         = 7,
+  DFU_STATE_dfuMANIFEST_WAIT_RST= 8,
+  DFU_STATE_dfuUPLOAD_IDLE      = 9,
+  DFU_STATE_dfuERROR            = 10
+};
+
+#define DFU_EP0_NONE            0
+#define DFU_EP0_UNHANDLED       1
+#define DFU_EP0_STALL           2
+#define DFU_EP0_ZLP             3
+#define DFU_EP0_DATA            4
+
+#define USB_DFU_CAN_DOWNLOAD    (1 << 0)
+#define USB_DFU_CAN_UPLOAD      (1 << 1)
+#define USB_DFU_MANIFEST_TOL    (1 << 2)
+#define USB_DFU_WILL_DETACH     (1 << 3)
+
+PRE_PACK struct POST_PACK _USB_DFU_FUNC_DESCRIPTOR {
+  uint8_t   bLength;
+  uint8_t   bDescriptorType;
+  uint8_t   bmAttributes;
+  uint16_t  wDetachTimeOut;
+  uint16_t  wTransferSize;
+  uint16_t  bcdDFUVersion;
+};
+typedef struct _USB_DFU_FUNC_DESCRIPTOR USB_DFU_FUNC_DESCRIPTOR;
+
+PRE_PACK struct POST_PACK _DFU_STATUS {
+  uint8_t bStatus;
+  uint8_t bwPollTimeout[3];
+  uint8_t bState;
+  uint8_t iString;
+};
+typedef struct _DFU_STATUS DFU_STATUS_T;
+
+#define DFU_FUNC_DESC_SIZE    sizeof(USB_DFU_FUNC_DESCRIPTOR)
+#define DFU_GET_STATUS_SIZE   0x6
+
+
+#endif  /* __MW_USBD_DFU_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_dfuuser.h ./lpc_chip_43xx/inc/usbd/usbd_dfuuser.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_dfuuser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_dfuuser.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,270 @@
+/***********************************************************************
+* $Id:: mw_usbd_dfuuser.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Device Firmware Upgrade Class Custom User Module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __DFUUSER_H__
+#define __DFUUSER_H__
+
+#include "usbd.h"
+#include "usbd_dfu.h"
+#include "usbd_core.h"
+
+/** \file
+ *  \brief Device Firmware Upgrade (DFU) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based DFU function driver.
+ *
+ */
+
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_DFU Device Firmware Upgrade (DFU) Class Function Driver
+ *  \section Sec_MSCModDescription Module Description
+ *  DFU Class Function Driver module. This module contains an internal implementation of the USB DFU Class.
+ *  User applications can use this class driver instead of implementing the DFU class manually
+ *  via the low-level USBD_HW and USBD_Core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB DFU Class.
+ */
+
+/** \brief USB descriptors data structure.
+ *  \ingroup USBD_DFU
+ *
+ *  \details  This module exposes functions which interact directly with USB device stack's core layer.
+ *  The application layer uses this component when it has to implement custom class function driver or
+ *  standard class function driver which is not part of the current USB device stack.
+ *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
+ *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
+ *  function to register custom endpoint interrupt handler.
+ *
+ */
+typedef struct USBD_DFU_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use.
+                      \note The \em mem_size should be greater than the size
+                      returned by USBD_DFU_API::GetMemSize() routine.*/
+  /* DFU paramas */
+  uint16_t wTransferSize; /**< DFU transfer block size in number of bytes.
+                          This value should match the value set in DFU descriptor
+                          provided as part of the descriptor array
+                          (\em high_speed_desc) passed to Init() through
+                          \ref USB_CORE_DESCS_T structure.  */
+
+  uint16_t pad;
+  /** Pointer to the DFU interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T
+  * structure.
+  */
+  uint8_t* intf_desc;
+  /* user defined functions */
+  /**
+  *  DFU Write callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a write command. For application using zero-copy buffer scheme
+  *  this function is called for the first time with \em length parameter set to 0.
+  *  The application code should update the buffer pointer.
+  *
+  *  \param[in] block_num Destination start address.
+  *  \param[in, out] src  Pointer to a pointer to the source of data. Pointer-to-pointer
+  *                     is used to implement zero-copy buffers. See \ref USBD_ZeroCopy
+  *                     for more details on zero-copy concept.
+  *  \param[out] bwPollTimeout  Pointer to a 3 byte buffer which the callback implementer
+  *                     should fill with the amount of minimum time, in milliseconds,
+  *                     that the host should wait before sending a subsequent
+  *                     DFU_GETSTATUS request.
+  *  \param[in] length  Number of bytes to be written.
+  *  \return Returns DFU_STATUS_ values defined in mw_usbd_dfu.h.
+  *
+  */
+  uint8_t (*DFU_Write)( uint32_t block_num, uint8_t** src, uint32_t length, uint8_t* bwPollTimeout);
+
+  /**
+  *  DFU Read callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a read command.
+  *
+  *  \param[in] block_num Destination start address.
+  *  \param[in, out] dst  Pointer to a pointer to the source of data. Pointer-to-pointer
+  *                       is used to implement zero-copy buffers. See \ref USBD_ZeroCopy
+  *                       for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return Returns
+  *                 - DFU_STATUS_ values defined in mw_usbd_dfu.h to return error conditions.
+  *                 - 0 if there is no more data to be read. Stack will send EOF frame and set
+  *                     DFU state-machine to dfuIdle state.
+  *                 - length of the data copied, should be greater than or equal to 16. If the data copied
+  *                   is less than DFU \em wTransferSize the stack will send EOF frame and
+  *                   goes to dfuIdle state.
+  *
+  */
+  uint32_t (*DFU_Read)( uint32_t block_num, uint8_t** dst, uint32_t length);
+
+  /**
+  *  DFU done callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  after firmware download completes.
+  *
+  *  \return Nothing.
+  *
+  */
+  void (*DFU_Done)(void);
+
+  /**
+  *  DFU detach callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  after USB_REQ_DFU_DETACH is received. Applications which set USB_DFU_WILL_DETACH
+  *  bit in DFU descriptor should define this function. As part of this function
+  *  application can call Connect() routine to disconnect and then connect back with
+  *  host. For application which rely on WinUSB based host application should use this
+  *  feature since USB reset can be invoked only by kernel drivers on Windows host.
+  *  By implementing this feature host doen't have to issue reset instead the device
+  *  has to do it automatically by disconnect and connect procedure.
+  *
+  *  \param[in] hUsb Handle DFU control structure.
+  *  \return Nothing.
+  *
+  */
+  void (*DFU_Detach)(USBD_HANDLE_T hUsb);
+
+  /**
+  *  Optional user override-able function to replace the default DFU class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_DFU_API::Init().
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*DFU_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+} USBD_DFU_INIT_PARAM_T;
+
+
+/** \brief DFU class API functions structure.
+ *  \ingroup USBD_DFU
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_DFU_API
+{
+  /** \fn uint32_t GetMemSize(USBD_DFU_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the DFU function driver module.
+   *
+   *  This function is called by application layer before calling pUsbApi->dfu->Init(), to allocate memory used
+   *  by DFU function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller.
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing DFU function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_DFU_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param)
+   *  Function to initialize DFU function driver module.
+   *
+   *  This function is called by application layer to initialize DFU function driver module.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in, out] param Structure containing DFU function driver module initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte aligned or smaller than required.
+   *          \retval ERR_API_INVALID_PARAM2 Either DFU_Write() or DFU_Done() or DFU_Read() call-backs are not defined.
+   *          \retval ERR_USBD_BAD_DESC
+   *            - USB_DFU_DESCRIPTOR_TYPE is not defined immediately after
+   *              interface descriptor.
+   *            - wTransferSize in descriptor doesn't match the value passed
+   *              in param->wTransferSize.
+   *            - DFU_Detach() is not defined while USB_DFU_WILL_DETACH is set
+   *              in DFU descriptor.
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param, uint32_t init_state);
+
+} USBD_DFU_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _USBD_DFU_CTRL_T
+{
+  /*ALIGNED(4)*/ DFU_STATUS_T dfu_req_get_status;
+  uint16_t pad;
+  uint8_t dfu_state;
+  uint8_t dfu_status;
+  uint8_t download_done;
+  uint8_t if_num;                  /* interface number */
+
+  uint8_t* xfr_buf;
+  USB_DFU_FUNC_DESCRIPTOR* dfu_desc;
+
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  /* user defined functions */
+  /* return DFU_STATUS_ values defined in mw_usbd_dfu.h */
+  uint8_t (*DFU_Write)( uint32_t block_num, uint8_t** src, uint32_t length, uint8_t* bwPollTimeout);
+  /* return
+  * DFU_STATUS_ : values defined in mw_usbd_dfu.h in case of errors
+  * 0 : If end of memory reached
+  * length : Amount of data copied to destination buffer
+  */
+  uint32_t (*DFU_Read)( uint32_t block_num, uint8_t** dst, uint32_t length);
+  /* callback called after download is finished */
+  void (*DFU_Done)(void);
+  /* callback called after USB_REQ_DFU_DETACH is recived */
+  void (*DFU_Detach)(USBD_HANDLE_T hUsb);
+
+} USBD_DFU_CTRL_T;
+
+/** @cond  DIRECT_API */
+uint32_t mwDFU_GetMemSize(USBD_DFU_INIT_PARAM_T* param);
+extern ErrorCode_t mwDFU_init(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param, uint32_t init_state);
+/** @endcond */
+
+/** @endcond */
+
+#endif  /* __DFUUSER_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd.h ./lpc_chip_43xx/inc/usbd/usbd.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd.h	2018-01-19 23:55:10.980318663 -0300
@@ -0,0 +1,705 @@
+/***********************************************************************
+* $Id:: mw_usbd.h 575 2012-11-20 01:35:56Z usb10131                           $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __USBD_H__
+#define __USBD_H__
+
+/** \file
+ *  \brief Common definitions and declarations for the USB stack.
+ *
+ *  Common definitions and declarations for the USB stack.
+ *  \addtogroup USBD_Core
+ *  @{
+ */
+
+#include "lpc_types.h"
+
+#if defined(__GNUC__)
+/* As per http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax,
+6.29 Attributes Syntax
+"An attribute specifier list may appear as part of a struct, union or
+enum specifier. It may go either immediately after the struct, union
+or enum keyword, or after the closing brace. The former syntax is
+preferred. Where attribute specifiers follow the closing brace, they
+are considered to relate to the structure, union or enumerated type
+defined, not to any enclosing declaration the type specifier appears
+in, and the type defined is not complete until after the attribute
+specifiers."
+So use POST_PACK immediately after struct keyword
+*/
+#define PRE_PACK
+#define POST_PACK  __attribute__((__packed__))
+#define ALIGNED(n)      __attribute__((aligned (n)))
+
+#elif defined(__arm)
+#define PRE_PACK   __packed
+#define POST_PACK
+#define ALIGNED(n)      __align(n)
+
+#elif defined(__ICCARM__)
+#define PRE_PACK                __packed
+#define POST_PACK
+#define PRAGMA_ALIGN_4096       _Pragma("data_alignment=4096")
+#define PRAGMA_ALIGN_2048       _Pragma("data_alignment=2048")
+#define PRAGMA_ALIGN_512        _Pragma("data_alignment=512")
+#define PRAGMA_ALIGN_256        _Pragma("data_alignment=256")
+#define PRAGMA_ALIGN_128        _Pragma("data_alignment=128")
+#define PRAGMA_ALIGN_64         _Pragma("data_alignment=64")
+#define PRAGMA_ALIGN_48         _Pragma("data_alignment=48")
+#define PRAGMA_ALIGN_32         _Pragma("data_alignment=32")
+#define PRAGMA_ALIGN_4          _Pragma("data_alignment=4")
+#define ALIGNED(n)              PRAGMA_ALIGN_##n
+
+#pragma diag_suppress=Pe021
+#endif
+
+/** Structure to pack lower and upper byte to form 16 bit word. */
+PRE_PACK struct POST_PACK _WB_T
+{
+  uint8_t L; /**< lower byte */
+  uint8_t H; /**< upper byte */
+};
+/** Structure to pack lower and upper byte to form 16 bit word.*/
+typedef struct _WB_T WB_T;
+
+/** Union of \ref _WB_T struct and 16 bit word.*/
+PRE_PACK union POST_PACK __WORD_BYTE
+{
+  uint16_t W; /**< data member to do 16 bit access */
+  WB_T WB; /**< data member to do 8 bit access */
+} ;
+/** Union of \ref _WB_T struct and 16 bit word.*/
+typedef union __WORD_BYTE WORD_BYTE;
+
+/** bmRequestType.Dir defines
+ * @{
+ */
+/** Request from host to device */
+#define REQUEST_HOST_TO_DEVICE     0
+/** Request from device to host */
+#define REQUEST_DEVICE_TO_HOST     1
+/** @} */
+
+/** bmRequestType.Type defines
+ * @{
+ */
+/** Standard Request */
+#define REQUEST_STANDARD           0
+/** Class Request */
+#define REQUEST_CLASS              1
+/** Vendor Request */
+#define REQUEST_VENDOR             2
+/** Reserved Request */
+#define REQUEST_RESERVED           3
+/** @} */
+
+/** bmRequestType.Recipient defines
+ * @{
+ */
+/** Request to device */
+#define REQUEST_TO_DEVICE          0
+/** Request to interface */
+#define REQUEST_TO_INTERFACE       1
+/** Request to endpoint */
+#define REQUEST_TO_ENDPOINT        2
+/** Request to other */
+#define REQUEST_TO_OTHER           3
+/** @} */
+
+/** Structure to define 8 bit USB request.*/
+PRE_PACK struct POST_PACK _BM_T
+{
+  uint8_t Recipient :  5; /**< Recipient type. */
+  uint8_t Type      :  2; /**< Request type.  */
+  uint8_t Dir       :  1; /**< Direction type. */
+};
+/** Structure to define 8 bit USB request.*/
+typedef struct _BM_T BM_T;
+
+/** Union of \ref _BM_T struct and 8 bit byte.*/
+PRE_PACK union POST_PACK _REQUEST_TYPE
+{
+  uint8_t B; /**< byte wide access memeber */
+  BM_T BM;   /**< bitfield structure access memeber */
+} ;
+/** Union of \ref _BM_T struct and 8 bit byte.*/
+typedef union _REQUEST_TYPE REQUEST_TYPE;
+
+/** USB Standard Request Codes
+ * @{
+ */
+/** GET_STATUS request */
+#define USB_REQUEST_GET_STATUS                 0
+/** CLEAR_FEATURE request */
+#define USB_REQUEST_CLEAR_FEATURE              1
+/** SET_FEATURE request */
+#define USB_REQUEST_SET_FEATURE                3
+/** SET_ADDRESS request */
+#define USB_REQUEST_SET_ADDRESS                5
+/** GET_DESCRIPTOR request */
+#define USB_REQUEST_GET_DESCRIPTOR             6
+/** SET_DESCRIPTOR request */
+#define USB_REQUEST_SET_DESCRIPTOR             7
+/** GET_CONFIGURATION request */
+#define USB_REQUEST_GET_CONFIGURATION          8
+/** SET_CONFIGURATION request */
+#define USB_REQUEST_SET_CONFIGURATION          9
+/** GET_INTERFACE request */
+#define USB_REQUEST_GET_INTERFACE              10
+/** SET_INTERFACE request */
+#define USB_REQUEST_SET_INTERFACE              11
+/** SYNC_FRAME request */
+#define USB_REQUEST_SYNC_FRAME                 12
+/** @} */
+
+/** USB GET_STATUS Bit Values
+ * @{
+ */
+/** SELF_POWERED status*/
+#define USB_GETSTATUS_SELF_POWERED             0x01
+/** REMOTE_WAKEUP capable status*/
+#define USB_GETSTATUS_REMOTE_WAKEUP            0x02
+/** ENDPOINT_STALL status*/
+#define USB_GETSTATUS_ENDPOINT_STALL           0x01
+/** @} */
+
+/** USB Standard Feature selectors
+ * @{
+ */
+/** ENDPOINT_STALL feature*/
+#define USB_FEATURE_ENDPOINT_STALL             0
+/** REMOTE_WAKEUP feature*/
+#define USB_FEATURE_REMOTE_WAKEUP              1
+/** TEST_MODE feature*/
+#define USB_FEATURE_TEST_MODE                  2
+/** @} */
+
+/** USB Default Control Pipe Setup Packet*/
+PRE_PACK struct POST_PACK _USB_SETUP_PACKET
+{
+  REQUEST_TYPE bmRequestType; /**< This bitmapped field identifies the characteristics
+                              of the specific request. \sa _BM_T.
+                              */
+  uint8_t      bRequest; /**< This field specifies the particular request. The
+                         Type bits in the bmRequestType field modify the meaning
+                         of this field. \sa USBD_REQUEST.
+                         */
+  WORD_BYTE    wValue; /**< Used to pass a parameter to the device, specific
+                        to the request.
+                        */
+  WORD_BYTE    wIndex; /**< Used to pass a parameter to the device, specific
+                        to the request. The wIndex field is often used in
+                        requests to specify an endpoint or an interface.
+                        */
+  uint16_t     wLength; /**< This field specifies the length of the data
+                        transferred during the second phase of the control
+                        transfer.
+                        */
+} ;
+/** USB Default Control Pipe Setup Packet*/
+typedef struct _USB_SETUP_PACKET USB_SETUP_PACKET;
+
+
+/** USB Descriptor Types
+ * @{
+ */
+/** Device descriptor type  */
+#define USB_DEVICE_DESCRIPTOR_TYPE             1
+/** Configuration descriptor type  */
+#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
+/** String descriptor type  */
+#define USB_STRING_DESCRIPTOR_TYPE             3
+/** Interface descriptor type  */
+#define USB_INTERFACE_DESCRIPTOR_TYPE          4
+/** Endpoint descriptor type  */
+#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
+/** Device qualifier descriptor type  */
+#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE   6
+/** Other speed configuration descriptor type  */
+#define USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE 7
+/** Interface power descriptor type  */
+#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE    8
+/** OTG descriptor type  */
+#define USB_OTG_DESCRIPTOR_TYPE                     9
+/** Debug descriptor type  */
+#define USB_DEBUG_DESCRIPTOR_TYPE                  10
+/** Interface association descriptor type  */
+#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE  11
+/** @} */
+
+/** USB Device Classes
+ * @{
+ */
+/** Reserved device class  */
+#define USB_DEVICE_CLASS_RESERVED              0x00
+/** Audio device class  */
+#define USB_DEVICE_CLASS_AUDIO                 0x01
+/** Communications device class  */
+#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
+/** Human interface device class  */
+#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
+/** monitor device class  */
+#define USB_DEVICE_CLASS_MONITOR               0x04
+/** physical interface device class  */
+#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE    0x05
+/** power device class  */
+#define USB_DEVICE_CLASS_POWER                 0x06
+/** Printer device class  */
+#define USB_DEVICE_CLASS_PRINTER               0x07
+/** Storage device class  */
+#define USB_DEVICE_CLASS_STORAGE               0x08
+/** Hub device class  */
+#define USB_DEVICE_CLASS_HUB                   0x09
+/** miscellaneous device class  */
+#define USB_DEVICE_CLASS_MISCELLANEOUS         0xEF
+/** Application device class  */
+#define USB_DEVICE_CLASS_APP                   0xFE
+/** Vendor specific device class  */
+#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
+/** @} */
+
+/** bmAttributes in Configuration Descriptor
+ * @{
+ */
+/** Power field mask */
+#define USB_CONFIG_POWERED_MASK                0x40
+/** Bus powered */
+#define USB_CONFIG_BUS_POWERED                 0x80
+/** Self powered */
+#define USB_CONFIG_SELF_POWERED                0xC0
+/** remote wakeup */
+#define USB_CONFIG_REMOTE_WAKEUP               0x20
+/** @} */
+
+/** bMaxPower in Configuration Descriptor */
+#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
+
+/** bEndpointAddress in Endpoint Descriptor
+ * @{
+ */
+/** Endopint address mask */
+#define USB_ENDPOINT_DIRECTION_MASK            0x80
+/** Macro to convert OUT endopint number to endpoint address value. */
+#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
+/** Macro to convert IN endopint number to endpoint address value. */
+#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
+/** @} */
+
+/** bmAttributes in Endpoint Descriptor
+ * @{
+ */
+/** Endopint type mask */
+#define USB_ENDPOINT_TYPE_MASK                 0x03
+/** Control Endopint type */
+#define USB_ENDPOINT_TYPE_CONTROL              0x00
+/** isochronous Endopint type */
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
+/** bulk Endopint type */
+#define USB_ENDPOINT_TYPE_BULK                 0x02
+/** interrupt Endopint type */
+#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
+/** Endopint sync type mask */
+#define USB_ENDPOINT_SYNC_MASK                 0x0C
+/** no synchronization Endopint */
+#define USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION   0x00
+/** Asynchronous sync Endopint */
+#define USB_ENDPOINT_SYNC_ASYNCHRONOUS         0x04
+/** Adaptive sync Endopint */
+#define USB_ENDPOINT_SYNC_ADAPTIVE             0x08
+/** Synchronous sync Endopint */
+#define USB_ENDPOINT_SYNC_SYNCHRONOUS          0x0C
+/** Endopint usage type mask */
+#define USB_ENDPOINT_USAGE_MASK                0x30
+/** Endopint data usage type  */
+#define USB_ENDPOINT_USAGE_DATA                0x00
+/** Endopint feedback usage type  */
+#define USB_ENDPOINT_USAGE_FEEDBACK            0x10
+/** Endopint implicit feedback usage type  */
+#define USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK   0x20
+/** Endopint reserved usage type  */
+#define USB_ENDPOINT_USAGE_RESERVED            0x30
+/** @} */
+
+/** Control endopint EP0's maximum packet size in high-speed mode.*/
+#define USB_ENDPOINT_0_HS_MAXP                 64
+/** Control endopint EP0's maximum packet size in low-speed mode.*/
+#define USB_ENDPOINT_0_LS_MAXP                 8
+/** Bulk endopint's maximum packet size in high-speed mode.*/
+#define USB_ENDPOINT_BULK_HS_MAXP              512
+
+/** USB Standard Device Descriptor */
+PRE_PACK struct POST_PACK _USB_DEVICE_DESCRIPTOR
+{
+  uint8_t  bLength;     /**< Size of this descriptor in bytes. */
+  uint8_t  bDescriptorType; /**< DEVICE Descriptor Type. */
+  uint16_t bcdUSB; /**< BUSB Specification Release Number in
+                    Binary-Coded Decimal (i.e., 2.10 is 210H).
+                    This field identifies the release of the USB
+                    Specification with which the device and its
+                    descriptors are compliant.
+                   */
+  uint8_t  bDeviceClass; /**< Class code (assigned by the USB-IF).
+                          If this field is reset to zero, each interface
+                          within a configuration specifies its own
+                          class information and the various
+                          interfaces operate independently.\n
+                          If this field is set to a value between 1 and
+                          FEH, the device supports different class
+                          specifications on different interfaces and
+                          the interfaces may not operate
+                          independently. This value identifies the
+                          class definition used for the aggregate
+                          interfaces. \n
+                          If this field is set to FFH, the device class
+                          is vendor-specific.
+                          */
+  uint8_t  bDeviceSubClass; /**< Subclass code (assigned by the USB-IF).
+                            These codes are qualified by the value of
+                            the bDeviceClass field. \n
+                            If the bDeviceClass field is reset to zero,
+                            this field must also be reset to zero. \n
+                            If the bDeviceClass field is not set to FFH,
+                            all values are reserved for assignment by
+                            the USB-IF.
+                            */
+  uint8_t  bDeviceProtocol; /**< Protocol code (assigned by the USB-IF).
+                            These codes are qualified by the value of
+                            the bDeviceClass and the
+                            bDeviceSubClass fields. If a device
+                            supports class-specific protocols on a
+                            device basis as opposed to an interface
+                            basis, this code identifies the protocols
+                            that the device uses as defined by the
+                            specification of the device class. \n
+                            If this field is reset to zero, the device
+                            does not use class-specific protocols on a
+                            device basis. However, it may use classspecific
+                            protocols on an interface basis. \n
+                            If this field is set to FFH, the device uses a
+                            vendor-specific protocol on a device basis.
+                            */
+  uint8_t  bMaxPacketSize0; /**< Maximum packet size for endpoint zero
+                            (only 8, 16, 32, or 64 are valid). For HS devices
+                            is fixed to 64.
+                            */
+
+  uint16_t idVendor; /**< Vendor ID (assigned by the USB-IF). */
+  uint16_t idProduct; /**< Product ID (assigned by the manufacturer). */
+  uint16_t bcdDevice; /**< Device release number in binary-coded decimal. */
+  uint8_t  iManufacturer; /**< Index of string descriptor describing manufacturer. */
+  uint8_t  iProduct; /**< Index of string descriptor describing product. */
+  uint8_t  iSerialNumber; /**< Index of string descriptor describing the deviceï¿½s
+                          serial number.
+                          */
+  uint8_t  bNumConfigurations; /**< Number of possible configurations. */
+} ;
+/** USB Standard Device Descriptor */
+typedef struct _USB_DEVICE_DESCRIPTOR USB_DEVICE_DESCRIPTOR;
+
+/** USB 2.0 Device Qualifier Descriptor */
+PRE_PACK struct POST_PACK _USB_DEVICE_QUALIFIER_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of descriptor */
+  uint8_t  bDescriptorType; /**< Device Qualifier Type */
+  uint16_t bcdUSB; /**< USB specification version number (e.g., 0200H for V2.00) */
+  uint8_t  bDeviceClass; /**< Class Code */
+  uint8_t  bDeviceSubClass; /**< SubClass Code */
+  uint8_t  bDeviceProtocol; /**< Protocol Code */
+  uint8_t  bMaxPacketSize0; /**< Maximum packet size for other speed */
+  uint8_t  bNumConfigurations; /**< Number of Other-speed Configurations */
+  uint8_t  bReserved; /**< Reserved for future use, must be zero */
+} ;
+/** USB 2.0 Device Qualifier Descriptor */
+typedef struct _USB_DEVICE_QUALIFIER_DESCRIPTOR USB_DEVICE_QUALIFIER_DESCRIPTOR;
+
+/** USB Standard Configuration Descriptor */
+PRE_PACK struct POST_PACK _USB_CONFIGURATION_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes */
+  uint8_t  bDescriptorType; /**< CONFIGURATION Descriptor Type*/
+  uint16_t wTotalLength; /**< Total length of data returned for this
+                          configuration. Includes the combined length
+                          of all descriptors (configuration, interface,
+                          endpoint, and class- or vendor-specific)
+                          returned for this configuration.*/
+  uint8_t  bNumInterfaces; /**< Number of interfaces supported by this configuration*/
+  uint8_t  bConfigurationValue; /**< Value to use as an argument to the
+                                SetConfiguration() request to select this
+                                configuration. */
+  uint8_t  iConfiguration; /**< Index of string descriptor describing this
+                            configuration*/
+  uint8_t  bmAttributes; /**< Configuration characteristics \n
+                          D7: Reserved (set to one)\n
+                          D6: Self-powered \n
+                          D5: Remote Wakeup \n
+                          D4...0: Reserved (reset to zero) \n
+                          D7 is reserved and must be set to one for
+                          historical reasons. \n
+                          A device configuration that uses power from
+                          the bus and a local source reports a non-zero
+                          value in bMaxPower to indicate the amount of
+                          bus power required and sets D6. The actual
+                          power source at runtime may be determined
+                          using the GetStatus(DEVICE) request (see
+                          USB 2.0 spec Section 9.4.5). \n
+                          If a device configuration supports remote
+                          wakeup, D5 is set to one.*/
+  uint8_t  bMaxPower; /**< Maximum power consumption of the USB
+                      device from the bus in this specific
+                      configuration when the device is fully
+                      operational. Expressed in 2 mA units
+                      (i.e., 50 = 100 mA). \n
+                      Note: A device configuration reports whether
+                      the configuration is bus-powered or selfpowered.
+                      Device status reports whether the
+                      device is currently self-powered. If a device is
+                      disconnected from its external power source, it
+                      updates device status to indicate that it is no
+                      longer self-powered. \n
+                      A device may not increase its power draw
+                      from the bus, when it loses its external power
+                      source, beyond the amount reported by its
+                      configuration. \n
+                      If a device can continue to operate when
+                      disconnected from its external power source, it
+                      continues to do so. If the device cannot
+                      continue to operate, it fails operations it can
+                      no longer support. The USB System Software
+                      may determine the cause of the failure by
+                      checking the status and noting the loss of the
+                      deviceï¿½s power source.*/
+} ;
+/** USB Standard Configuration Descriptor */
+typedef struct _USB_CONFIGURATION_DESCRIPTOR USB_CONFIGURATION_DESCRIPTOR;
+
+/** USB Standard Interface Association Descriptor */
+PRE_PACK struct POST_PACK _USB_IAD_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< INTERFACE ASSOCIATION Descriptor Type*/
+  uint8_t  bFirstInterface; /**< Interface number of the first interface that is
+                            associated with this function.*/
+  uint8_t  bInterfaceCount; /**< Number of contiguous interfaces that are
+                            associated with this function. */
+  uint8_t  bFunctionClass; /**< Class code (assigned by USB-IF). \n
+                            A value of zero is not allowed in this descriptor.
+                            If this field is FFH, the function class is vendorspecific.
+                            All other values are reserved for assignment by
+                            the USB-IF.*/
+  uint8_t  bFunctionSubClass; /**< Subclass code (assigned by USB-IF). \n
+                            If the bFunctionClass field is not set to FFH all
+                            values are reserved for assignment by the USBIF.*/
+  uint8_t  bFunctionProtocol; /**< Protocol code (assigned by the USB). \n
+                                These codes are qualified by the values of the
+                                bFunctionClass and bFunctionSubClass fields.*/
+  uint8_t  iFunction; /**< Index of string descriptor describing this function.*/
+} ;
+/** USB Standard Interface Association Descriptor */
+typedef struct _USB_IAD_DESCRIPTOR USB_IAD_DESCRIPTOR;
+
+/** USB Standard Interface Descriptor */
+PRE_PACK struct POST_PACK _USB_INTERFACE_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< INTERFACE Descriptor Type*/
+  uint8_t  bInterfaceNumber; /**< Number of this interface. Zero-based
+                              value identifying the index in the array of
+                              concurrent interfaces supported by this
+                              configuration.*/
+  uint8_t  bAlternateSetting; /**< Value used to select this alternate setting
+                              for the interface identified in the prior field*/
+  uint8_t  bNumEndpoints; /**< Number of endpoints used by this
+                          interface (excluding endpoint zero). If this
+                          value is zero, this interface only uses the
+                          Default Control Pipe.*/
+  uint8_t  bInterfaceClass; /**< Class code (assigned by the USB-IF). \n
+                            A value of zero is reserved for future
+                            standardization. \n
+                            If this field is set to FFH, the interface
+                            class is vendor-specific. \n
+                            All other values are reserved for
+                            assignment by the USB-IF.*/
+  uint8_t  bInterfaceSubClass; /**< Subclass code (assigned by the USB-IF). \n
+                              These codes are qualified by the value of
+                              the bInterfaceClass field. \n
+                              If the bInterfaceClass field is reset to zero,
+                              this field must also be reset to zero. \n
+                              If the bInterfaceClass field is not set to
+                              FFH, all values are reserved for
+                              assignment by the USB-IF.*/
+  uint8_t  bInterfaceProtocol; /**< Protocol code (assigned by the USB). \n
+                                These codes are qualified by the value of
+                                the bInterfaceClass and the
+                                bInterfaceSubClass fields. If an interface
+                                supports class-specific requests, this code
+                                identifies the protocols that the device
+                                uses as defined by the specification of the
+                                device class. \n
+                                If this field is reset to zero, the device
+                                does not use a class-specific protocol on
+                                this interface. \n
+                                If this field is set to FFH, the device uses
+                                a vendor-specific protocol for this
+                                interface.*/
+  uint8_t  iInterface; /**< Index of string descriptor describing this interface*/
+} ;
+/** USB Standard Interface Descriptor */
+typedef struct _USB_INTERFACE_DESCRIPTOR USB_INTERFACE_DESCRIPTOR;
+
+/** USB Standard Endpoint Descriptor */
+PRE_PACK struct POST_PACK _USB_ENDPOINT_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< ENDPOINT Descriptor Type*/
+  uint8_t  bEndpointAddress; /**< The address of the endpoint on the USB device
+                            described by this descriptor. The address is
+                            encoded as follows: \n
+                            Bit 3...0: The endpoint number \n
+                            Bit 6...4: Reserved, reset to zero \n
+                            Bit 7: Direction, ignored for control endpoints
+                            0 = OUT endpoint
+                            1 = IN endpoint.  \n \sa USBD_ENDPOINT_ADR_Type*/
+  uint8_t  bmAttributes; /**< This field describes the endpointï¿½s attributes when it is
+                          configured using the bConfigurationValue. \n
+                          Bits 1..0: Transfer Type
+                          \li 00 = Control
+                          \li 01 = Isochronous
+                          \li 10 = Bulk
+                          \li 11 = Interrupt  \n
+                          If not an isochronous endpoint, bits 5..2 are reserved
+                          and must be set to zero. If isochronous, they are
+                          defined as follows: \n
+                          Bits 3..2: Synchronization Type
+                          \li 00 = No Synchronization
+                          \li 01 = Asynchronous
+                          \li 10 = Adaptive
+                          \li 11 = Synchronous \n
+                          Bits 5..4: Usage Type
+                          \li 00 = Data endpoint
+                          \li 01 = Feedback endpoint
+                          \li 10 = Implicit feedback Data endpoint
+                          \li 11 = Reserved \n
+                          Refer to Chapter 5 of USB 2.0 specification for more information. \n
+                          All other bits are reserved and must be reset to zero.
+                          Reserved bits must be ignored by the host.
+                         \n \sa USBD_EP_ATTR_Type*/
+  uint16_t wMaxPacketSize; /**< Maximum packet size this endpoint is capable of
+                          sending or receiving when this configuration is
+                          selected. \n
+                          For isochronous endpoints, this value is used to
+                          reserve the bus time in the schedule, required for the
+                          per-(micro)frame data payloads. The pipe may, on an
+                          ongoing basis, actually use less bandwidth than that
+                          reserved. The device reports, if necessary, the actual
+                          bandwidth used via its normal, non-USB defined
+                          mechanisms. \n
+                          For all endpoints, bits 10..0 specify the maximum
+                          packet size (in bytes). \n
+                          For high-speed isochronous and interrupt endpoints: \n
+                          Bits 12..11 specify the number of additional transaction
+                          opportunities per microframe: \n
+                          \li 00 = None (1 transaction per microframe)
+                          \li 01 = 1 additional (2 per microframe)
+                          \li 10 = 2 additional (3 per microframe)
+                          \li 11 = Reserved \n
+                          Bits 15..13 are reserved and must be set to zero.*/
+  uint8_t  bInterval; /**< Interval for polling endpoint for data transfers.
+                      Expressed in frames or microframes depending on the
+                      device operating speed (i.e., either 1 millisecond or
+                      125 ï¿½s units).
+                      \li For full-/high-speed isochronous endpoints, this value
+                      must be in the range from 1 to 16. The bInterval value
+                      is used as the exponent for a \f$ 2^(bInterval-1) \f$ value; e.g., a
+                      bInterval of 4 means a period of 8 (\f$ 2^(4-1) \f$).
+                      \li For full-/low-speed interrupt endpoints, the value of
+                      this field may be from 1 to 255.
+                      \li For high-speed interrupt endpoints, the bInterval value
+                      is used as the exponent for a \f$ 2^(bInterval-1) \f$ value; e.g., a
+                      bInterval of 4 means a period of 8 (\f$ 2^(4-1) \f$) . This value
+                      must be from 1 to 16.
+                      \li For high-speed bulk/control OUT endpoints, the
+                      bInterval must specify the maximum NAK rate of the
+                      endpoint. A value of 0 indicates the endpoint never
+                      NAKs. Other values indicate at most 1 NAK each
+                      bInterval number of microframes. This value must be
+                      in the range from 0 to 255. \n
+                      Refer to Chapter 5 of USB 2.0 specification for more information.
+                      */
+} ;
+/** USB Standard Endpoint Descriptor */
+typedef struct _USB_ENDPOINT_DESCRIPTOR USB_ENDPOINT_DESCRIPTOR;
+
+/** USB String Descriptor */
+PRE_PACK struct POST_PACK _USB_STRING_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< STRING Descriptor Type*/
+  uint16_t bString/*[]*/; /**< UNICODE encoded string */
+}  ;
+/** USB String Descriptor */
+typedef struct _USB_STRING_DESCRIPTOR USB_STRING_DESCRIPTOR;
+
+/** USB Common Descriptor */
+PRE_PACK struct POST_PACK _USB_COMMON_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< Descriptor Type*/
+} ;
+/** USB Common Descriptor */
+typedef struct _USB_COMMON_DESCRIPTOR USB_COMMON_DESCRIPTOR;
+
+/** USB Other Speed Configuration */
+PRE_PACK struct POST_PACK _USB_OTHER_SPEED_CONFIGURATION
+{
+  uint8_t  bLength; /**< Size of descriptor*/
+  uint8_t  bDescriptorType; /**< Other_speed_Configuration Type*/
+  uint16_t wTotalLength; /**< Total length of data returned*/
+  uint8_t  bNumInterfaces; /**< Number of interfaces supported by this speed configuration*/
+  uint8_t  bConfigurationValue; /**< Value to use to select configuration*/
+  uint8_t  IConfiguration; /**< Index of string descriptor*/
+  uint8_t  bmAttributes; /**< Same as Configuration descriptor*/
+  uint8_t  bMaxPower; /**< Same as Configuration descriptor*/
+} ;
+/** USB Other Speed Configuration */
+typedef struct _USB_OTHER_SPEED_CONFIGURATION USB_OTHER_SPEED_CONFIGURATION;
+
+/** \ingroup USBD_Core
+ * USB device stack/module handle.
+ */
+typedef void* USBD_HANDLE_T;
+
+#define WBVAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+#define B3VAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF),(((x) >> 16) & 0xFF)
+
+#define USB_DEVICE_DESC_SIZE        (sizeof(USB_DEVICE_DESCRIPTOR))
+#define USB_CONFIGURATION_DESC_SIZE (sizeof(USB_CONFIGURATION_DESCRIPTOR))
+#define USB_INTERFACE_DESC_SIZE     (sizeof(USB_INTERFACE_DESCRIPTOR))
+#define USB_INTERFACE_ASSOC_DESC_SIZE   (sizeof(USB_IAD_DESCRIPTOR))
+#define USB_ENDPOINT_DESC_SIZE      (sizeof(USB_ENDPOINT_DESCRIPTOR))
+#define USB_DEVICE_QUALI_SIZE       (sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR))
+#define USB_OTHER_SPEED_CONF_SIZE   (sizeof(USB_OTHER_SPEED_CONFIGURATION))
+
+/** @}*/
+
+#endif  /* __USBD_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_hid.h ./lpc_chip_43xx/inc/usbd/usbd_hid.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_hid.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_hid.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,431 @@
+/***********************************************************************
+* $Id: mw_usbd_hid.h.rca 1.2 Tue Nov  1 11:45:07 2011 nlv09221 Experimental $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     HID Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __HID_H__
+#define __HID_H__
+
+#include "usbd.h"
+
+/** \file
+ *  \brief Common definitions and declarations for the library USB HID Class driver.
+ *
+ *  Common definitions and declarations for the library USB HID Class driver.
+ *  \addtogroup USBD_HID
+ *  @{
+ */
+
+
+/** HID Subclass Codes
+ * @{
+ */
+/** Descriptor Subclass value indicating that the device or interface does not implement a HID boot protocol. */
+#define HID_SUBCLASS_NONE               0x00
+/** Descriptor Subclass value indicating that the device or interface implements a HID boot protocol. */
+#define HID_SUBCLASS_BOOT               0x01
+/** @} */
+
+/** HID Protocol Codes
+ * @{
+ */
+/** Descriptor Protocol value indicating that the device or interface does not belong to a HID boot protocol. */
+#define HID_PROTOCOL_NONE               0x00
+/** Descriptor Protocol value indicating that the device or interface belongs to the Keyboard HID boot protocol. */
+#define HID_PROTOCOL_KEYBOARD           0x01
+/** Descriptor Protocol value indicating that the device or interface belongs to the Mouse HID boot protocol. */
+#define HID_PROTOCOL_MOUSE              0x02
+/** @} */
+
+
+
+/** Descriptor Types
+ * @{
+ */
+/** Descriptor header type value, to indicate a HID class HID descriptor. */
+#define HID_HID_DESCRIPTOR_TYPE         0x21
+/** Descriptor header type value, to indicate a HID class HID report descriptor. */
+#define HID_REPORT_DESCRIPTOR_TYPE      0x22
+/** Descriptor header type value, to indicate a HID class HID Physical descriptor. */
+#define HID_PHYSICAL_DESCRIPTOR_TYPE    0x23
+/** @} */
+
+
+/** \brief HID class-specific HID Descriptor.
+ *
+ *  Type define for the HID class-specific HID descriptor, to describe the HID device's specifications. Refer to the HID
+ *  specification for details on the structure elements.
+ *
+ */
+PRE_PACK struct POST_PACK _HID_DESCRIPTOR {
+  uint8_t  bLength;    /**< Size of the descriptor, in bytes. */
+  uint8_t  bDescriptorType;    /**< Type of HID descriptor. */
+  uint16_t bcdHID; /**< BCD encoded version that the HID descriptor and device complies to. */
+  uint8_t  bCountryCode; /**< Country code of the localized device, or zero if universal. */
+  uint8_t  bNumDescriptors; /**< Total number of HID report descriptors for the interface. */
+
+  PRE_PACK struct POST_PACK _HID_DESCRIPTOR_LIST {
+    uint8_t  bDescriptorType; /**< Type of HID report. */
+    uint16_t wDescriptorLength; /**< Length of the associated HID report descriptor, in bytes. */
+  } DescriptorList[1]; /**< Array of one or more descriptors */
+} ;
+/** HID class-specific HID Descriptor. */
+typedef struct _HID_DESCRIPTOR HID_DESCRIPTOR;
+
+#define HID_DESC_SIZE   sizeof(HID_DESCRIPTOR)
+
+/** HID Request Codes
+ * @{
+ */
+#define HID_REQUEST_GET_REPORT          0x01
+#define HID_REQUEST_GET_IDLE            0x02
+#define HID_REQUEST_GET_PROTOCOL        0x03
+#define HID_REQUEST_SET_REPORT          0x09
+#define HID_REQUEST_SET_IDLE            0x0A
+#define HID_REQUEST_SET_PROTOCOL        0x0B
+/** @} */
+
+/** HID Report Types
+ * @{
+ */
+#define HID_REPORT_INPUT                0x01
+#define HID_REPORT_OUTPUT               0x02
+#define HID_REPORT_FEATURE              0x03
+/** @} */
+
+
+/** Usage Pages
+ * @{
+ */
+#define HID_USAGE_PAGE_UNDEFINED        0x00
+#define HID_USAGE_PAGE_GENERIC          0x01
+#define HID_USAGE_PAGE_SIMULATION       0x02
+#define HID_USAGE_PAGE_VR               0x03
+#define HID_USAGE_PAGE_SPORT            0x04
+#define HID_USAGE_PAGE_GAME             0x05
+#define HID_USAGE_PAGE_DEV_CONTROLS     0x06
+#define HID_USAGE_PAGE_KEYBOARD         0x07
+#define HID_USAGE_PAGE_LED              0x08
+#define HID_USAGE_PAGE_BUTTON           0x09
+#define HID_USAGE_PAGE_ORDINAL          0x0A
+#define HID_USAGE_PAGE_TELEPHONY        0x0B
+#define HID_USAGE_PAGE_CONSUMER         0x0C
+#define HID_USAGE_PAGE_DIGITIZER        0x0D
+#define HID_USAGE_PAGE_UNICODE          0x10
+#define HID_USAGE_PAGE_ALPHANUMERIC     0x14
+/** @} */
+
+
+/** Generic Desktop Page (0x01)
+ * @{
+ */
+#define HID_USAGE_GENERIC_POINTER               0x01
+#define HID_USAGE_GENERIC_MOUSE                 0x02
+#define HID_USAGE_GENERIC_JOYSTICK              0x04
+#define HID_USAGE_GENERIC_GAMEPAD               0x05
+#define HID_USAGE_GENERIC_KEYBOARD              0x06
+#define HID_USAGE_GENERIC_KEYPAD                0x07
+#define HID_USAGE_GENERIC_X                     0x30
+#define HID_USAGE_GENERIC_Y                     0x31
+#define HID_USAGE_GENERIC_Z                     0x32
+#define HID_USAGE_GENERIC_RX                    0x33
+#define HID_USAGE_GENERIC_RY                    0x34
+#define HID_USAGE_GENERIC_RZ                    0x35
+#define HID_USAGE_GENERIC_SLIDER                0x36
+#define HID_USAGE_GENERIC_DIAL                  0x37
+#define HID_USAGE_GENERIC_WHEEL                 0x38
+#define HID_USAGE_GENERIC_HATSWITCH             0x39
+#define HID_USAGE_GENERIC_COUNTED_BUFFER        0x3A
+#define HID_USAGE_GENERIC_BYTE_COUNT            0x3B
+#define HID_USAGE_GENERIC_MOTION_WAKEUP         0x3C
+#define HID_USAGE_GENERIC_VX                    0x40
+#define HID_USAGE_GENERIC_VY                    0x41
+#define HID_USAGE_GENERIC_VZ                    0x42
+#define HID_USAGE_GENERIC_VBRX                  0x43
+#define HID_USAGE_GENERIC_VBRY                  0x44
+#define HID_USAGE_GENERIC_VBRZ                  0x45
+#define HID_USAGE_GENERIC_VNO                   0x46
+#define HID_USAGE_GENERIC_SYSTEM_CTL            0x80
+#define HID_USAGE_GENERIC_SYSCTL_POWER          0x81
+#define HID_USAGE_GENERIC_SYSCTL_SLEEP          0x82
+#define HID_USAGE_GENERIC_SYSCTL_WAKE           0x83
+#define HID_USAGE_GENERIC_SYSCTL_CONTEXT_MENU   0x84
+#define HID_USAGE_GENERIC_SYSCTL_MAIN_MENU      0x85
+#define HID_USAGE_GENERIC_SYSCTL_APP_MENU       0x86
+#define HID_USAGE_GENERIC_SYSCTL_HELP_MENU      0x87
+#define HID_USAGE_GENERIC_SYSCTL_MENU_EXIT      0x88
+#define HID_USAGE_GENERIC_SYSCTL_MENU_SELECT    0x89
+#define HID_USAGE_GENERIC_SYSCTL_MENU_RIGHT     0x8A
+#define HID_USAGE_GENERIC_SYSCTL_MENU_LEFT      0x8B
+#define HID_USAGE_GENERIC_SYSCTL_MENU_UP        0x8C
+#define HID_USAGE_GENERIC_SYSCTL_MENU_DOWN      0x8D
+/** @} */
+
+/** Simulation Controls Page (0x02)
+ * @{
+ */
+#define HID_USAGE_SIMULATION_RUDDER             0xBA
+#define HID_USAGE_SIMULATION_THROTTLE           0xBB
+/** @} */
+
+/* Virtual Reality Controls Page (0x03) */
+/* ... */
+
+/* Sport Controls Page (0x04) */
+/* ... */
+
+/* Game Controls Page (0x05) */
+/* ... */
+
+/* Generic Device Controls Page (0x06) */
+/* ... */
+
+/** Keyboard/Keypad Page (0x07)
+ * @{
+ */
+/** Error "keys" */
+#define HID_USAGE_KEYBOARD_NOEVENT              0x00
+#define HID_USAGE_KEYBOARD_ROLLOVER             0x01
+#define HID_USAGE_KEYBOARD_POSTFAIL             0x02
+#define HID_USAGE_KEYBOARD_UNDEFINED            0x03
+
+/** Letters */
+#define HID_USAGE_KEYBOARD_aA                   0x04
+#define HID_USAGE_KEYBOARD_zZ                   0x1D
+
+/** Numbers */
+#define HID_USAGE_KEYBOARD_ONE                  0x1E
+#define HID_USAGE_KEYBOARD_ZERO                 0x27
+
+#define HID_USAGE_KEYBOARD_RETURN               0x28
+#define HID_USAGE_KEYBOARD_ESCAPE               0x29
+#define HID_USAGE_KEYBOARD_DELETE               0x2A
+
+/** Funtion keys */
+#define HID_USAGE_KEYBOARD_F1                   0x3A
+#define HID_USAGE_KEYBOARD_F12                  0x45
+
+#define HID_USAGE_KEYBOARD_PRINT_SCREEN         0x46
+
+/** Modifier Keys */
+#define HID_USAGE_KEYBOARD_LCTRL                0xE0
+#define HID_USAGE_KEYBOARD_LSHFT                0xE1
+#define HID_USAGE_KEYBOARD_LALT                 0xE2
+#define HID_USAGE_KEYBOARD_LGUI                 0xE3
+#define HID_USAGE_KEYBOARD_RCTRL                0xE4
+#define HID_USAGE_KEYBOARD_RSHFT                0xE5
+#define HID_USAGE_KEYBOARD_RALT                 0xE6
+#define HID_USAGE_KEYBOARD_RGUI                 0xE7
+#define HID_USAGE_KEYBOARD_SCROLL_LOCK          0x47
+#define HID_USAGE_KEYBOARD_NUM_LOCK             0x53
+#define HID_USAGE_KEYBOARD_CAPS_LOCK            0x39
+/** @} */
+
+/* ... */
+
+/** LED Page (0x08)
+ * @{
+ */
+#define HID_USAGE_LED_NUM_LOCK                  0x01
+#define HID_USAGE_LED_CAPS_LOCK                 0x02
+#define HID_USAGE_LED_SCROLL_LOCK               0x03
+#define HID_USAGE_LED_COMPOSE                   0x04
+#define HID_USAGE_LED_KANA                      0x05
+#define HID_USAGE_LED_POWER                     0x06
+#define HID_USAGE_LED_SHIFT                     0x07
+#define HID_USAGE_LED_DO_NOT_DISTURB            0x08
+#define HID_USAGE_LED_MUTE                      0x09
+#define HID_USAGE_LED_TONE_ENABLE               0x0A
+#define HID_USAGE_LED_HIGH_CUT_FILTER           0x0B
+#define HID_USAGE_LED_LOW_CUT_FILTER            0x0C
+#define HID_USAGE_LED_EQUALIZER_ENABLE          0x0D
+#define HID_USAGE_LED_SOUND_FIELD_ON            0x0E
+#define HID_USAGE_LED_SURROUND_FIELD_ON         0x0F
+#define HID_USAGE_LED_REPEAT                    0x10
+#define HID_USAGE_LED_STEREO                    0x11
+#define HID_USAGE_LED_SAMPLING_RATE_DETECT      0x12
+#define HID_USAGE_LED_SPINNING                  0x13
+#define HID_USAGE_LED_CAV                       0x14
+#define HID_USAGE_LED_CLV                       0x15
+#define HID_USAGE_LED_RECORDING_FORMAT_DET      0x16
+#define HID_USAGE_LED_OFF_HOOK                  0x17
+#define HID_USAGE_LED_RING                      0x18
+#define HID_USAGE_LED_MESSAGE_WAITING           0x19
+#define HID_USAGE_LED_DATA_MODE                 0x1A
+#define HID_USAGE_LED_BATTERY_OPERATION         0x1B
+#define HID_USAGE_LED_BATTERY_OK                0x1C
+#define HID_USAGE_LED_BATTERY_LOW               0x1D
+#define HID_USAGE_LED_SPEAKER                   0x1E
+#define HID_USAGE_LED_HEAD_SET                  0x1F
+#define HID_USAGE_LED_HOLD                      0x20
+#define HID_USAGE_LED_MICROPHONE                0x21
+#define HID_USAGE_LED_COVERAGE                  0x22
+#define HID_USAGE_LED_NIGHT_MODE                0x23
+#define HID_USAGE_LED_SEND_CALLS                0x24
+#define HID_USAGE_LED_CALL_PICKUP               0x25
+#define HID_USAGE_LED_CONFERENCE                0x26
+#define HID_USAGE_LED_STAND_BY                  0x27
+#define HID_USAGE_LED_CAMERA_ON                 0x28
+#define HID_USAGE_LED_CAMERA_OFF                0x29
+#define HID_USAGE_LED_ON_LINE                   0x2A
+#define HID_USAGE_LED_OFF_LINE                  0x2B
+#define HID_USAGE_LED_BUSY                      0x2C
+#define HID_USAGE_LED_READY                     0x2D
+#define HID_USAGE_LED_PAPER_OUT                 0x2E
+#define HID_USAGE_LED_PAPER_JAM                 0x2F
+#define HID_USAGE_LED_REMOTE                    0x30
+#define HID_USAGE_LED_FORWARD                   0x31
+#define HID_USAGE_LED_REVERSE                   0x32
+#define HID_USAGE_LED_STOP                      0x33
+#define HID_USAGE_LED_REWIND                    0x34
+#define HID_USAGE_LED_FAST_FORWARD              0x35
+#define HID_USAGE_LED_PLAY                      0x36
+#define HID_USAGE_LED_PAUSE                     0x37
+#define HID_USAGE_LED_RECORD                    0x38
+#define HID_USAGE_LED_ERROR                     0x39
+#define HID_USAGE_LED_SELECTED_INDICATOR        0x3A
+#define HID_USAGE_LED_IN_USE_INDICATOR          0x3B
+#define HID_USAGE_LED_MULTI_MODE_INDICATOR      0x3C
+#define HID_USAGE_LED_INDICATOR_ON              0x3D
+#define HID_USAGE_LED_INDICATOR_FLASH           0x3E
+#define HID_USAGE_LED_INDICATOR_SLOW_BLINK      0x3F
+#define HID_USAGE_LED_INDICATOR_FAST_BLINK      0x40
+#define HID_USAGE_LED_INDICATOR_OFF             0x41
+#define HID_USAGE_LED_FLASH_ON_TIME             0x42
+#define HID_USAGE_LED_SLOW_BLINK_ON_TIME        0x43
+#define HID_USAGE_LED_SLOW_BLINK_OFF_TIME       0x44
+#define HID_USAGE_LED_FAST_BLINK_ON_TIME        0x45
+#define HID_USAGE_LED_FAST_BLINK_OFF_TIME       0x46
+#define HID_USAGE_LED_INDICATOR_COLOR           0x47
+#define HID_USAGE_LED_RED                       0x48
+#define HID_USAGE_LED_GREEN                     0x49
+#define HID_USAGE_LED_AMBER                     0x4A
+#define HID_USAGE_LED_GENERIC_INDICATOR         0x4B
+/** @} */
+
+/*  Button Page (0x09)
+ */
+/*   There is no need to label these usages. */
+
+/*  Ordinal Page (0x0A)
+ */
+/*   There is no need to label these usages. */
+
+/** Telephony Device Page (0x0B)
+ * @{
+ */
+#define HID_USAGE_TELEPHONY_PHONE               0x01
+#define HID_USAGE_TELEPHONY_ANSWERING_MACHINE   0x02
+#define HID_USAGE_TELEPHONY_MESSAGE_CONTROLS    0x03
+#define HID_USAGE_TELEPHONY_HANDSET             0x04
+#define HID_USAGE_TELEPHONY_HEADSET             0x05
+#define HID_USAGE_TELEPHONY_KEYPAD              0x06
+#define HID_USAGE_TELEPHONY_PROGRAMMABLE_BUTTON 0x07
+/** @} */
+/* ... */
+
+/** Consumer Page (0x0C)
+ * @{
+ */
+#define HID_USAGE_CONSUMER_CONTROL              0x01
+#define HID_USAGE_CONSUMER_FAST_FORWARD       0xB3
+#define HID_USAGE_CONSUMER_REWIND             0xB4
+#define HID_USAGE_CONSUMER_PLAY_PAUSE              0xCD
+#define HID_USAGE_CONSUMER_VOLUME_INCREMENT        0xE9
+#define HID_USAGE_CONSUMER_VOLUME_DECREMENT        0xEA
+/** @} */
+/* ... */
+
+/* and others ... */
+
+
+/** HID Report Item Macros
+ * @{
+ */
+/** Main Items */
+#define HID_Input(x)           0x81,x
+#define HID_Output(x)          0x91,x
+#define HID_Feature(x)         0xB1,x
+#define HID_Collection(x)      0xA1,x
+#define HID_EndCollection      0xC0
+
+/** Data (Input, Output, Feature) */
+#define HID_Data               0<<0
+#define HID_Constant           1<<0
+#define HID_Array              0<<1
+#define HID_Variable           1<<1
+#define HID_Absolute           0<<2
+#define HID_Relative           1<<2
+#define HID_NoWrap             0<<3
+#define HID_Wrap               1<<3
+#define HID_Linear             0<<4
+#define HID_NonLinear          1<<4
+#define HID_PreferredState     0<<5
+#define HID_NoPreferred        1<<5
+#define HID_NoNullPosition     0<<6
+#define HID_NullState          1<<6
+#define HID_NonVolatile        0<<7
+#define HID_Volatile           1<<7
+
+/** Collection Data */
+#define HID_Physical           0x00
+#define HID_Application        0x01
+#define HID_Logical            0x02
+#define HID_Report             0x03
+#define HID_NamedArray         0x04
+#define HID_UsageSwitch        0x05
+#define HID_UsageModifier      0x06
+
+/** Global Items */
+#define HID_UsagePage(x)       0x05,x
+#define HID_UsagePageVendor(x) 0x06,x,0xFF
+#define HID_LogicalMin(x)      0x15,x
+#define HID_LogicalMinS(x)     0x16,(x&0xFF),((x>>8)&0xFF)
+#define HID_LogicalMinL(x)     0x17,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_LogicalMax(x)      0x25,x
+#define HID_LogicalMaxS(x)     0x26,(x&0xFF),((x>>8)&0xFF)
+#define HID_LogicalMaxL(x)     0x27,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_PhysicalMin(x)     0x35,x
+#define HID_PhysicalMinS(x)    0x36,(x&0xFF),((x>>8)&0xFF)
+#define HID_PhysicalMinL(x)    0x37,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_PhysicalMax(x)     0x45,x
+#define HID_PhysicalMaxS(x)    0x46,(x&0xFF),((x>>8)&0xFF)
+#define HID_PhysicalMaxL(x)    0x47,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_UnitExponent(x)    0x55,x
+#define HID_Unit(x)            0x65,x
+#define HID_UnitS(x)           0x66,(x&0xFF),((x>>8)&0xFF)
+#define HID_UnitL(x)           0x67,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_ReportSize(x)      0x75,x
+#define HID_ReportID(x)        0x85,x
+#define HID_ReportCount(x)     0x95,x
+#define HID_ReportCount16(x)   0x96,(x&0xFF),((x>>8)&0xFF)
+#define HID_Push               0xA0
+#define HID_Pop                0xB0
+
+/** Local Items */
+#define HID_Usage(x)           0x09,x
+#define HID_UsageMin(x)        0x19,x
+#define HID_UsageMax(x)        0x29,x
+/** @} */
+
+/** @} */
+
+#endif  /* __HID_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_hiduser.h ./lpc_chip_43xx/inc/usbd/usbd_hiduser.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_hiduser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_hiduser.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,421 @@
+/***********************************************************************
+* $Id:: mw_usbd_hiduser.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     HID Custom User Module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __HIDUSER_H__
+#define __HIDUSER_H__
+
+#include "usbd.h"
+#include "usbd_hid.h"
+#include "usbd_core.h"
+
+/** \file
+ *  \brief Human Interface Device (HID) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based HID function driver.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_HID HID Class Function Driver
+ *  \section Sec_HIDModDescription Module Description
+ *  HID Class Function Driver module. This module contains an internal implementation of the USB HID Class.
+ *  User applications can use this class driver instead of implementing the HID class manually
+ *  via the low-level HW and core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB HID Class.
+ */
+
+/** \brief HID report descriptor data structure.
+ *  \ingroup USBD_HID
+ *
+ *  \details  This structure is used as part of HID function driver initialization
+ *  parameter structure \ref USBD_HID_INIT_PARAM. This structure contains
+ *  details of a report type supported by the application. An application
+ *  can support multiple report types as a single HID device. The application
+ *  should define this report type data structure per report it supports and
+ *  the array of report types to USBD_HID_API::init() through \ref USBD_HID_INIT_PARAM
+ *  structure.
+ *
+ *  \note All descriptor pointers assigned in this structure should be on 4 byte
+ *  aligned address boundary.
+ *
+ */
+typedef struct _HID_REPORT_T {
+  uint16_t len; /**< Size of the report descriptor in bytes. */
+  uint8_t idle_time; /**< This value is used by stack to respond to Set_Idle &
+                     GET_Idle requests for the specified report ID. The value
+                     of this field specified the rate at which duplicate reports
+                     are generated for the specified Report ID. For example, a
+                     device with two input reports could specify an idle rate of
+                     20 milliseconds for report ID 1 and 500 milliseconds for
+                     report ID 2.
+                     */
+  uint8_t __pad; /**< Padding space. */
+  uint8_t* desc; /**< Report descriptor. */
+} USB_HID_REPORT_T;
+
+/** \brief USB descriptors data structure.
+ *  \ingroup USBD_HID
+ *
+ *  \details  This module exposes functions which interact directly with USB device stack's core layer.
+ *  The application layer uses this component when it has to implement custom class function driver or
+ *  standard class function driver which is not part of the current USB device stack.
+ *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
+ *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
+ *  function to register custom endpoint interrupt handler.
+ *
+ */
+typedef struct USBD_HID_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use.
+                      \note The \em mem_size should be greater than the size
+                      returned by USBD_HID_API::GetMemSize() routine.*/
+  /* HID paramas */
+  uint8_t max_reports; /**< Number of HID reports supported by this instance
+                       of HID class driver.
+                       */
+  uint8_t pad[3];
+  uint8_t* intf_desc; /**< Pointer to the HID interface descriptor within the
+                      descriptor array (\em high_speed_desc) passed to Init()
+                      through \ref USB_CORE_DESCS_T structure.
+                      */
+  USB_HID_REPORT_T* report_data; /**< Pointer to an array of HID report descriptor
+                                 data structure (\ref USB_HID_REPORT_T). The number
+                                 of elements in the array should be same a \em max_reports
+                                 value. The stack uses this array to respond to
+                                 requests received for various HID report descriptor
+                                 information. \note This array should be of global scope.
+                                 */
+
+  /* user defined functions */
+  /* required functions */
+  /**
+  *  HID get report callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a HID_REQUEST_GET_REPORT request. The setup packet data (\em pSetup)
+  *  is passed to the callback so that application can extract the report ID, report
+  *  type and other information need to generate the report. \note HID reports are sent
+  *  via interrupt IN endpoint also. This function is called only when report request
+  *  is received on control endpoint. Application should implement \em HID_EpIn_Hdlr to
+  *  send reports to host via interrupt IN endpoint.
+  *
+  *
+  *  \param[in] hHid Handle to HID function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_GetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length);
+
+  /**
+  *  HID set report callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a HID_REQUEST_SET_REPORT request. The setup packet data (\em pSetup)
+  *  is passed to the callback so that application can extract the report ID, report
+  *  type and other information need to modify the report. An application might choose
+  *  to ignore input Set_Report requests as meaningless. Alternatively these reports
+  *  could be used to reset the origin of a control (that is, current position should
+  *  report zero).
+  *
+  *  \param[in] hHid Handle to HID function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_SetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+
+  /* optional functions */
+
+  /**
+  *  Optional callback function to handle HID_GetPhysDesc request.
+  *
+  *  The application software could provide this callback HID_GetPhysDesc handler to
+  *  handle get physical descriptor requests sent by the host. When host requests
+  *  Physical Descriptor set 0, application should return a special descriptor
+  *  identifying the number of descriptor sets and their sizes. A Get_Descriptor
+  *  request with the Physical Index equal to 1 should return the first Physical
+  *  Descriptor set. A device could possibly have alternate uses for its items.
+  *  These can be enumerated by issuing subsequent Get_Descriptor requests while
+  *  incrementing the Descriptor Index. A device should return the last descriptor
+  *  set to requests with an index greater than the last number defined in the HID
+  *  descriptor.
+  *  \note Applications which don't have physical descriptor should set this data member
+  *  to zero before calling the USBD_HID_API::Init().
+  *  \n
+  *
+  *  \param[in] hHid Handle to HID function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in] pBuf Pointer to a pointer of data buffer containing physical descriptor
+  *                   data. If the physical descriptor is in USB accessible memory area
+  *                   application could just update the pointer or else it should copy
+  *                   the descriptor to the address pointed by this pointer.
+  *  \param[in] length  Amount of data copied to destination buffer or descriptor length.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_GetPhysDesc)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+
+  /**
+  *  Optional callback function to handle HID_REQUEST_SET_IDLE request.
+  *
+  *  The application software could provide this callback to handle HID_REQUEST_SET_IDLE
+  *  requests sent by the host. This callback is provided to applications to adjust
+  *  timers associated with various reports, which are sent to host over interrupt
+  *  endpoint. The setup packet data (\em pSetup) is passed to the callback so that
+  *  application can extract the report ID, report type and other information need
+  *  to modify the report's idle time.
+  *  \note Applications which don't send reports on Interrupt endpoint or don't
+  *  have idle time between reports should set this data member to zero before
+  *  calling the USBD_HID_API::Init().
+  *  \n
+  *
+  *  \param[in] hHid Handle to HID function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in] idleTime  Idle time to be set for the specified report.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_SetIdle)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t idleTime);
+
+  /**
+  *  Optional callback function to handle HID_REQUEST_SET_PROTOCOL request.
+  *
+  *  The application software could provide this callback to handle HID_REQUEST_SET_PROTOCOL
+  *  requests sent by the host. This callback is provided to applications to adjust
+  *  modes of their code between boot mode and report mode.
+  *  \note Applications which don't support protocol modes should set this data member
+  *  to zero before calling the USBD_HID_API::Init().
+  *  \n
+  *
+  *  \param[in] hHid Handle to HID function driver.
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in] protocol  Protocol mode.
+  *                       0 = Boot Protocol
+  *                       1 = Report Protocol
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_SetProtocol)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t protocol);
+
+  /**
+  *  Optional Interrupt IN endpoint event handler.
+  *
+  *  The application software could provide Interrupt IN endpoint event handler.
+  *  Application which send reports to host on interrupt endpoint should provide
+  *  an endpoint event handler through this data member. This data member is
+  *  ignored if the interface descriptor \em intf_desc doesn't have any IN interrupt
+  *  endpoint descriptor associated.
+  *  \n
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Handle to HID function driver.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_EpIn_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+  /**
+  *  Optional Interrupt OUT endpoint event handler.
+  *
+  *  The application software could provide Interrupt OUT endpoint event handler.
+  *  Application which receives reports from host on interrupt endpoint should provide
+  *  an endpoint event handler through this data member. This data member is
+  *  ignored if the interface descriptor \em intf_desc doesn't have any OUT interrupt
+  *  endpoint descriptor associated.
+  *  \n
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Handle to HID function driver.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_EpOut_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /* user override-able function */
+  /**
+  *  Optional user override-able function to replace the default HID_GetReportDesc handler.
+  *
+  *  The application software could override the default HID_GetReportDesc handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_HID_API::Init() and also provide report data array
+  *  \em report_data field.
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_GetReportDesc)(USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+  /**
+  *  Optional user override-able function to replace the default HID class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_HID_API::Init().
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*HID_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+} USBD_HID_INIT_PARAM_T;
+
+/** \brief HID class API functions structure.
+ *  \ingroup USBD_HID
+ *
+ *  This structure contains pointers to all the function exposed by HID function driver module.
+ *
+ */
+typedef struct USBD_HID_API
+{
+  /** \fn uint32_t GetMemSize(USBD_HID_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the HID function driver module.
+   *
+   *  This function is called by application layer before calling pUsbApi->hid->Init(), to allocate memory used
+   *  by HID function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller.
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing HID function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_HID_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param)
+   *  Function to initialize HID function driver module.
+   *
+   *  This function is called by application layer to initialize HID function driver
+   *  module. On successful initialization the function returns a handle to HID
+   *  function driver module in passed param structure.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in, out] param Structure containing HID function driver module
+   *      initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte
+   *              aligned or smaller than required.
+   *          \retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
+   *              callback are not defined.
+   *          \retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined
+   *              immediately after interface descriptor.
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.
+   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed.
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param);
+
+} USBD_HID_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _HID_CTRL_T {
+  /* pointer to controller */
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  /* descriptor pointers */
+  uint8_t* hid_desc;
+  USB_HID_REPORT_T* report_data;
+
+  uint8_t protocol;
+  uint8_t if_num;                  /* interface number */
+  uint8_t epin_adr;                /* IN interrupt endpoint */
+  uint8_t epout_adr;               /* OUT interrupt endpoint */
+
+  /* user defined functions */
+  ErrorCode_t (*HID_GetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length);
+  ErrorCode_t (*HID_SetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+  ErrorCode_t (*HID_GetPhysDesc)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+  ErrorCode_t (*HID_SetIdle)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t idleTime);
+  ErrorCode_t (*HID_SetProtocol)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t protocol);
+
+  /* virtual overridable functions */
+  ErrorCode_t (*HID_GetReportDesc)(USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+
+}USB_HID_CTRL_T;
+
+/** @cond  DIRECT_API */
+extern uint32_t mwHID_GetMemSize(USBD_HID_INIT_PARAM_T* param);
+extern ErrorCode_t mwHID_init(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param);
+/** @endcond */
+
+/** @endcond */
+
+#endif  /* __HIDUSER_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_hw.h ./lpc_chip_43xx/inc/usbd/usbd_hw.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_hw.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_hw.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,457 @@
+/***********************************************************************
+* $Id:: mw_usbd_hw.h 331 2012-08-09 18:54:34Z usb10131                        $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Hardware Function prototypes.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __USBHW_H__
+#define __USBHW_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_core.h"
+
+/** \file
+ *  \brief USB Hardware Function prototypes.
+ *
+ *  Definition of functions exported by ROM based Device Controller Driver (DCD).
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_HW USB Device Controller Driver
+ *  \section Sec_HWModDescription Module Description
+ *  The Device Controller Driver Layer implements the routines to deal directly with the hardware.
+ */
+
+/** \ingroup USBD_HW
+*  USB Endpoint/class handler Callback Events.
+*
+*/
+enum USBD_EVENT_T {
+  USB_EVT_SETUP =1,    /**< 1   Setup Packet received */
+  USB_EVT_OUT,         /**< 2   OUT Packet received */
+  USB_EVT_IN,          /**< 3    IN Packet sent */
+  USB_EVT_OUT_NAK,     /**< 4   OUT Packet - Not Acknowledged */
+  USB_EVT_IN_NAK,      /**< 5    IN Packet - Not Acknowledged */
+  USB_EVT_OUT_STALL,   /**< 6   OUT Packet - Stalled */
+  USB_EVT_IN_STALL,    /**< 7    IN Packet - Stalled */
+  USB_EVT_OUT_DMA_EOT, /**< 8   DMA OUT EP - End of Transfer */
+  USB_EVT_IN_DMA_EOT,  /**< 9   DMA  IN EP - End of Transfer */
+  USB_EVT_OUT_DMA_NDR, /**< 10  DMA OUT EP - New Descriptor Request */
+  USB_EVT_IN_DMA_NDR,  /**< 11  DMA  IN EP - New Descriptor Request */
+  USB_EVT_OUT_DMA_ERR, /**< 12  DMA OUT EP - Error */
+  USB_EVT_IN_DMA_ERR,  /**< 13  DMA  IN EP - Error */
+  USB_EVT_RESET,       /**< 14  Reset event recieved */
+  USB_EVT_SOF,         /**< 15  Start of Frame event */
+  USB_EVT_DEV_STATE,   /**< 16  Device status events */
+  USB_EVT_DEV_ERROR   /**< 17  Device error events */
+};
+
+/**
+ *  \brief Hardware API functions structure.
+ *  \ingroup USBD_HW
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_HW_API
+{
+  /** \fn uint32_t GetMemSize(USBD_API_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the USB device stack's DCD and core layers.
+   *
+   *  This function is called by application layer before calling pUsbApi->hw->Init(), to allocate memory used
+   *  by DCD and core layers. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller.
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing USB device stack initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_API_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t Init(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param)
+   *  Function to initialize USB device stack's DCD and core layers.
+   *
+   *  This function is called by application layer to initialize USB hardware and core layers.
+   *  On successful initialization the function returns a handle to USB device stack which should
+   *  be passed to the rest of the functions.
+   *
+   *  \param[in,out] phUsb Pointer to the USB device stack handle of type USBD_HANDLE_T.
+   *  \param[in]  pDesc Structure containing pointers to various descriptor arrays needed by the stack.
+   *                    These descriptors are reported to USB host as part of enumerations process.
+   *  \param[in]  param Structure containing USB device stack initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK(0) On success
+   *          \retval ERR_USBD_BAD_MEM_BUF(0x0004000b) When insufficient memory buffer is passed or memory
+   *                                             is not aligned on 2048 boundary.
+   */
+  ErrorCode_t (*Init)(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param);
+
+  /** \fn void Connect(USBD_HANDLE_T hUsb, uint32_t con)
+   *  Function to make USB device visible/invisible on the USB bus.
+   *
+   *  This function is called after the USB initialization. This function uses the soft connect
+   *  feature to make the device visible on the USB bus. This function is called only after the
+   *  application is ready to handle the USB data. The enumeration process is started by the
+   *  host after the device detection. The driver handles the enumeration process according to
+   *  the USB descriptors passed in the USB initialization function.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] con  States whether to connect (1) or to disconnect (0).
+   *  \return Nothing.
+   */
+  void (*Connect)(USBD_HANDLE_T hUsb, uint32_t con);
+
+  /** \fn void ISR(USBD_HANDLE_T hUsb)
+   *  Function to USB device controller interrupt events.
+   *
+   *  When the user application is active the interrupt handlers are mapped in the user flash
+   *  space. The user application must provide an interrupt handler for the USB interrupt and
+   *  call this function in the interrupt handler routine. The driver interrupt handler takes
+   *  appropriate action according to the data received on the USB bus.
+   *
+   *  \param[in]  hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void (*ISR)(USBD_HANDLE_T hUsb);
+
+  /** \fn void Reset(USBD_HANDLE_T hUsb)
+   *  Function to Reset USB device stack and hardware controller.
+   *
+   *  Reset USB device stack and hardware controller. Disables all endpoints except EP0.
+   *  Clears all pending interrupts and resets endpoint transfer queues.
+   *  This function is called internally by pUsbApi->hw->init() and from reset event.
+   *
+   *  \param[in]  hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void  (*Reset)(USBD_HANDLE_T hUsb);
+
+  /** \fn void ForceFullSpeed(USBD_HANDLE_T hUsb, uint32_t cfg)
+   *  Function to force high speed USB device to operate in full speed mode.
+   *
+   *  This function is useful for testing the behavior of current device when connected
+   *  to a full speed only hosts.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] cfg  When 1 - set force full-speed or
+   *                       0 - clear force full-speed.
+   *  \return Nothing.
+   */
+  void  (*ForceFullSpeed )(USBD_HANDLE_T hUsb, uint32_t cfg);
+
+  /** \fn void WakeUpCfg(USBD_HANDLE_T hUsb, uint32_t cfg)
+   *  Function to configure USB device controller to wake-up host on remote events.
+   *
+   *  This function is called by application layer to configure the USB device controller
+   *  to wakeup on remote events. It is recommended to call this function from users's
+   *  USB_WakeUpCfg() callback routine registered with stack.
+   *  \note User's USB_WakeUpCfg() is registered with stack by setting the USB_WakeUpCfg member
+   *  of USBD_API_INIT_PARAM_T structure before calling pUsbApi->hw->Init() routine.
+   *  Certain USB device controllers needed to keep some clocks always on to generate
+   *  resume signaling through pUsbApi->hw->WakeUp(). This hook is provided to support
+   *  such controllers. In most controllers cases this is an empty routine.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] cfg  When 1 - Configure controller to wake on remote events or
+   *                       0 - Configure controller not to wake on remote events.
+   *  \return Nothing.
+   */
+  void  (*WakeUpCfg)(USBD_HANDLE_T hUsb, uint32_t  cfg);
+
+  /** \fn void SetAddress(USBD_HANDLE_T hUsb, uint32_t adr)
+   *  Function to set USB address assigned by host in device controller hardware.
+   *
+   *  This function is called automatically when USB_REQUEST_SET_ADDRESS request is received
+   *  by the stack from USB host.
+   *  This interface is provided to users to invoke this function in other scenarios which are not
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's
+   *  standard handlers through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] adr  USB bus Address to which the device controller should respond. Usually
+   *                  assigned by the USB host.
+   *  \return Nothing.
+   */
+  void  (*SetAddress)(USBD_HANDLE_T hUsb, uint32_t adr);
+
+  /** \fn void Configure(USBD_HANDLE_T hUsb, uint32_t cfg)
+   *  Function to configure device controller hardware with selected configuration.
+   *
+   *  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received
+   *  by the stack from USB host.
+   *  This interface is provided to users to invoke this function in other scenarios which are not
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's
+   *  standard handlers through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] cfg  Configuration index.
+   *  \return Nothing.
+   */
+  void  (*Configure)(USBD_HANDLE_T hUsb, uint32_t  cfg);
+
+  /** \fn void ConfigEP(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD)
+   *  Function to configure USB Endpoint according to descriptor.
+   *
+   *  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received
+   *  by the stack from USB host. All the endpoints associated with the selected configuration
+   *  are configured.
+   *  This interface is provided to users to invoke this function in other scenarios which are not
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's
+   *  standard handlers through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] pEPD Endpoint descriptor structure defined in USB 2.0 specification.
+   *  \return Nothing.
+   */
+  void  (*ConfigEP)(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD);
+
+  /** \fn void DirCtrlEP(USBD_HANDLE_T hUsb, uint32_t dir)
+   *  Function to set direction for USB control endpoint EP0.
+   *
+   *  This function is called automatically by the stack on need basis.
+   *  This interface is provided to users to invoke this function in other scenarios which are not
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's
+   *  standard handlers through callback interface exposed by the stack.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] cfg  When 1 - Set EP0 in IN transfer mode
+   *                       0 - Set EP0 in OUT transfer mode
+   *  \return Nothing.
+   */
+  void  (*DirCtrlEP)(USBD_HANDLE_T hUsb, uint32_t dir);
+
+  /** \fn void EnableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to enable selected USB endpoint.
+   *
+   *  This function enables interrupts on selected endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*EnableEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void DisableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to disable selected USB endpoint.
+   *
+   *  This function disables interrupts on selected endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*DisableEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void ResetEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to reset selected USB endpoint.
+   *
+   *  This function flushes the endpoint buffers and resets data toggle logic.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+  */
+  void  (*ResetEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void SetStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to STALL selected USB endpoint.
+   *
+   *  Generates STALL signaling for requested endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*SetStallEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void ClrStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to clear STALL state for the requested endpoint.
+   *
+   *  This function clears STALL state for the requested endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*ClrStallEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn ErrorCode_t SetTestMode(USBD_HANDLE_T hUsb, uint8_t mode)
+   *  Function to set high speed USB device controller in requested test mode.
+   *
+   *  USB-IF requires the high speed device to be put in various test modes
+   *  for electrical testing. This USB device stack calls this function whenever
+   *  it receives USB_REQUEST_CLEAR_FEATURE request for USB_FEATURE_TEST_MODE.
+   *  Users can put the device in test mode by directly calling this function.
+   *  Returns ERR_USBD_INVALID_REQ when device controller is full-speed only.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] mode  Test mode defined in USB 2.0 electrical testing specification.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK(0) - On success
+   *          \retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid test mode or
+   *                                             Device controller is full-speed only.
+   */
+  ErrorCode_t (*SetTestMode)(USBD_HANDLE_T hUsb, uint8_t mode);
+
+  /** \fn uint32_t ReadEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData)
+   *  Function to read data received on the requested endpoint.
+   *
+   *  This function is called by USB stack and the application layer to read the data
+   *  received on the requested endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \param[in,out] pData Pointer to the data buffer where data is to be copied.
+   *  \return Returns the number of bytes copied to the buffer.
+   */
+  uint32_t (*ReadEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData);
+
+  /** \fn uint32_t ReadReqEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len)
+   *  Function to queue read request on the specified endpoint.
+   *
+   *  This function is called by USB stack and the application layer to queue a read request
+   *  on the specified endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. This buffer
+   *                       address should be accessible by USB DMA master.
+   *  \param[in] len  Length of the buffer passed.
+   *  \return Returns the length of the requested buffer.
+   */
+  uint32_t (*ReadReqEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len);
+
+  /** \fn uint32_t ReadSetupPkt(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData)
+   *  Function to read setup packet data received on the requested endpoint.
+   *
+   *  This function is called by USB stack and the application layer to read setup packet data
+   *  received on the requested endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP0_IN is represented by 0x80 number.
+   *  \param[in,out] pData Pointer to the data buffer where data is to be copied.
+   *  \return Returns the number of bytes copied to the buffer.
+   */
+  uint32_t (*ReadSetupPkt)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData);
+
+  /** \fn uint32_t WriteEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt)
+   *  Function to write data to be sent on the requested endpoint.
+   *
+   *  This function is called by USB stack and the application layer to send data
+   *  on the requested endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number as per USB specification.
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \param[in] pData Pointer to the data buffer from where data is to be copied.
+   *  \param[in] cnt  Number of bytes to write.
+   *  \return Returns the number of bytes written.
+   */
+  uint32_t (*WriteEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt);
+
+  /** \fn void WakeUp(USBD_HANDLE_T hUsb)
+   *  Function to generate resume signaling on bus for remote host wakeup.
+   *
+   *  This function is called by application layer to remotely wakeup host controller
+   *  when system is in suspend state. Application should indicate this remote wakeup
+   *  capability by setting USB_CONFIG_REMOTE_WAKEUP in bmAttributes of Configuration
+   *  Descriptor. Also this routine will generate resume signalling only if host
+   *  enables USB_FEATURE_REMOTE_WAKEUP by sending SET_FEATURE request before suspending
+   *  the bus.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \return Nothing.
+   */
+  void  (*WakeUp)(USBD_HANDLE_T hUsb);
+
+  /** \fn void EnableEvent(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable)
+   *  Function to enable/disable selected USB event.
+   *
+   *  This function enables interrupts on selected endpoint.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in] EPNum  Endpoint number corresponding to the event.
+   *                    ie. An EP1_IN is represented by 0x81 number. For device events
+   *                    set this param to 0x0.
+   *  \param[in] event_type  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+   *  \param[in] enable  1 - enable event, 0 - disable event.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK(0) - On success
+   *          \retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid event type.
+   */
+  ErrorCode_t  (*EnableEvent)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable);
+
+} USBD_HW_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes used by stack internally
+ *-----------------------------------------------------------------------------*/
+/** @cond  DIRECT_API */
+
+/* Driver functions */
+uint32_t hwUSB_GetMemSize(USBD_API_INIT_PARAM_T* param);
+ErrorCode_t hwUSB_Init(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param);
+void hwUSB_Connect(USBD_HANDLE_T hUsb, uint32_t con);
+void hwUSB_ISR(USBD_HANDLE_T hUsb);
+
+/* USB Hardware Functions */
+extern void  hwUSB_Reset(USBD_HANDLE_T hUsb);
+extern void  hwUSB_ForceFullSpeed (USBD_HANDLE_T hUsb, uint32_t con);
+extern void  hwUSB_WakeUpCfg(USBD_HANDLE_T hUsb, uint32_t  cfg);
+extern void  hwUSB_SetAddress(USBD_HANDLE_T hUsb, uint32_t adr);
+extern void  hwUSB_Configure(USBD_HANDLE_T hUsb, uint32_t  cfg);
+extern void  hwUSB_ConfigEP(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD);
+extern void  hwUSB_DirCtrlEP(USBD_HANDLE_T hUsb, uint32_t dir);
+extern void  hwUSB_EnableEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_DisableEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_ResetEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_SetStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_ClrStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern ErrorCode_t hwUSB_SetTestMode(USBD_HANDLE_T hUsb, uint8_t mode); /* for FS only devices return ERR_USBD_INVALID_REQ */
+extern uint32_t hwUSB_ReadEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData);
+extern uint32_t hwUSB_ReadReqEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len);
+extern uint32_t hwUSB_ReadSetupPkt(USBD_HANDLE_T hUsb, uint32_t, uint32_t *);
+extern uint32_t hwUSB_WriteEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt);
+
+/* generate resume signaling on the bus */
+extern void  hwUSB_WakeUp(USBD_HANDLE_T hUsb);
+extern ErrorCode_t  hwUSB_EnableEvent(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable);
+/* TODO implement following routines
+- function to program TD and queue them to ep Qh
+*/
+
+/** @endcond */
+
+
+#endif  /* __USBHW_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_msc.h ./lpc_chip_43xx/inc/usbd/usbd_msc.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_msc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_msc.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,119 @@
+/***********************************************************************
+* $Id:: mw_usbd_msc.h 331 2012-08-09 18:54:34Z usb10131                       $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Mass Storage Class definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __MSC_H__
+#define __MSC_H__
+
+#include "usbd.h"
+
+/** \file
+ *  \brief Mass Storage class (MSC) descriptors.
+ *
+ *  Definition of MSC class descriptors and their bit defines.
+ *
+ */
+
+/* MSC Subclass Codes */
+#define MSC_SUBCLASS_RBC                0x01
+#define MSC_SUBCLASS_SFF8020I_MMC2      0x02
+#define MSC_SUBCLASS_QIC157             0x03
+#define MSC_SUBCLASS_UFI                0x04
+#define MSC_SUBCLASS_SFF8070I           0x05
+#define MSC_SUBCLASS_SCSI               0x06
+
+/* MSC Protocol Codes */
+#define MSC_PROTOCOL_CBI_INT            0x00
+#define MSC_PROTOCOL_CBI_NOINT          0x01
+#define MSC_PROTOCOL_BULK_ONLY          0x50
+
+
+/* MSC Request Codes */
+#define MSC_REQUEST_RESET               0xFF
+#define MSC_REQUEST_GET_MAX_LUN         0xFE
+
+
+/* MSC Bulk-only Stage */
+#define MSC_BS_CBW                      0       /* Command Block Wrapper */
+#define MSC_BS_DATA_OUT                 1       /* Data Out Phase */
+#define MSC_BS_DATA_IN                  2       /* Data In Phase */
+#define MSC_BS_DATA_IN_LAST             3       /* Data In Last Phase */
+#define MSC_BS_DATA_IN_LAST_STALL       4       /* Data In Last Phase with Stall */
+#define MSC_BS_CSW                      5       /* Command Status Wrapper */
+#define MSC_BS_ERROR                    6       /* Error */
+
+
+/* Bulk-only Command Block Wrapper */
+PRE_PACK struct POST_PACK _MSC_CBW
+{
+  uint32_t dSignature;
+  uint32_t dTag;
+  uint32_t dDataLength;
+  uint8_t  bmFlags;
+  uint8_t  bLUN;
+  uint8_t  bCBLength;
+  uint8_t  CB[16];
+} ;
+typedef struct _MSC_CBW MSC_CBW;
+
+/* Bulk-only Command Status Wrapper */
+PRE_PACK struct POST_PACK _MSC_CSW
+{
+  uint32_t dSignature;
+  uint32_t dTag;
+  uint32_t dDataResidue;
+  uint8_t  bStatus;
+} ;
+typedef struct _MSC_CSW MSC_CSW;
+
+#define MSC_CBW_Signature               0x43425355
+#define MSC_CSW_Signature               0x53425355
+
+
+/* CSW Status Definitions */
+#define CSW_CMD_PASSED                  0x00
+#define CSW_CMD_FAILED                  0x01
+#define CSW_PHASE_ERROR                 0x02
+
+
+/* SCSI Commands */
+#define SCSI_TEST_UNIT_READY            0x00
+#define SCSI_REQUEST_SENSE              0x03
+#define SCSI_FORMAT_UNIT                0x04
+#define SCSI_INQUIRY                    0x12
+#define SCSI_MODE_SELECT6               0x15
+#define SCSI_MODE_SENSE6                0x1A
+#define SCSI_START_STOP_UNIT            0x1B
+#define SCSI_MEDIA_REMOVAL              0x1E
+#define SCSI_READ_FORMAT_CAPACITIES     0x23
+#define SCSI_READ_CAPACITY              0x25
+#define SCSI_READ10                     0x28
+#define SCSI_WRITE10                    0x2A
+#define SCSI_VERIFY10                   0x2F
+#define SCSI_READ12                     0xA8
+#define SCSI_WRITE12                    0xAA
+#define SCSI_MODE_SELECT10              0x55
+#define SCSI_MODE_SENSE10               0x5A
+
+
+#endif  /* __MSC_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_mscuser.h ./lpc_chip_43xx/inc/usbd/usbd_mscuser.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_mscuser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_mscuser.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,270 @@
+/***********************************************************************
+* $Id:: mw_usbd_mscuser.h 577 2012-11-20 01:42:04Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Mass Storage Class Custom User Module definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MSCUSER_H__
+#define __MSCUSER_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_msc.h"
+#include "usbd_core.h"
+#include "app_usbd_cfg.h"
+
+/** \file
+ *  \brief Mass Storage Class (MSC) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based MSC function driver.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_MSC Mass Storage Class (MSC) Function Driver
+ *  \section Sec_MSCModDescription Module Description
+ *  MSC Class Function Driver module. This module contains an internal implementation of the USB MSC Class.
+ *  User applications can use this class driver instead of implementing the MSC class manually
+ *  via the low-level USBD_HW and USBD_Core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB MSC Class.
+ */
+
+/** \brief Mass Storage class function driver initialization parameter data structure.
+ *  \ingroup USBD_MSC
+ *
+ *  \details  This data structure is used to pass initialization parameters to the
+ *  Mass Storage class function driver's init function.
+ *
+ */
+typedef struct USBD_MSC_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use.
+                      \note The \em mem_size should be greater than the size
+                      returned by USBD_MSC_API::GetMemSize() routine.*/
+  /* mass storage params */
+  uint8_t*  InquiryStr; /**< Pointer to the 28 character string. This string is
+                        sent in response to the SCSI Inquiry command. \note The data
+                        pointed by the pointer should be of global scope.
+                        */
+  uint32_t  BlockCount; /**< Number of blocks present in the mass storage device */
+  uint32_t  BlockSize; /**< Block size in number of bytes */
+  uint32_t  MemorySize; /**< Memory size in number of bytes */
+  /** Pointer to the interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T
+  * structure. The stack assumes both HS and FS use same BULK endpoints.
+  */
+
+  uint8_t* intf_desc;
+  /* user defined functions */
+
+ /**
+  *  MSC Write callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a write command.
+  *
+  *  \param[in] offset Destination start address.
+  *  \param[in, out] src  Pointer to a pointer to the source of data. Pointer-to-pointer
+  *                       is used to implement zero-copy buffers. See \ref USBD_ZeroCopy
+  *                       for more details on zero-copy concept.
+  *  \param[in] length  Number of bytes to be written.
+  *  \return Nothing.
+  *
+  */
+  void (*MSC_Write)( uint32_t offset, uint8_t** src, uint32_t length, uint32_t high_offset);
+ /**
+  *  MSC Read callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a read command.
+  *
+  *  \param[in] offset Source start address.
+  *  \param[in, out] dst  Pointer to a pointer to the source of data. The MSC function drivers
+  *         implemented in stack are written with zero-copy model. Meaning the stack doesn't make an
+  *          extra copy of buffer before writing/reading data from USB hardware FIFO. Hence the
+  *          parameter is pointer to a pointer containing address buffer (<em>uint8_t** dst</em>).
+  *          So that the user application can update the buffer pointer instead of copying data to
+  *          address pointed by the parameter. /note The updated buffer address should be accessible
+  *          by USB DMA master. If user doesn't want to use zero-copy model, then the user should copy
+  *          data to the address pointed by the passed buffer pointer parameter and shouldn't change
+  *          the address value. See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Number of bytes to be read.
+  *  \return Nothing.
+  *
+  */
+  void (*MSC_Read)( uint32_t offset, uint8_t** dst, uint32_t length, uint32_t high_offset);
+ /**
+  *  MSC Verify callback function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a verify command. The callback function should compare the buffer
+  *  with the destination memory at the requested offset and
+  *
+  *  \param[in] offset Destination start address.
+  *  \param[in] buf  Buffer containing the data sent by the host.
+  *  \param[in] length  Number of bytes to verify.
+  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK If data in the buffer matches the data at destination
+  *          \retval ERR_FAILED  At least one byte is different.
+  *
+  */
+  ErrorCode_t (*MSC_Verify)( uint32_t offset, uint8_t buf[], uint32_t length, uint32_t high_offset);
+  /**
+  *  Optional callback function to optimize MSC_Write buffer transfer.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends SCSI_WRITE10/SCSI_WRITE12 command. The callback function should
+  *  update the \em buff_adr pointer so that the stack transfers the data directly
+  *  to the target buffer. /note The updated buffer address should be accessible
+  *  by USB DMA master. If user doesn't want to use zero-copy model, then the user
+  *  should not update the buffer pointer. See \ref USBD_ZeroCopy for more details
+  *  on zero-copy concept.
+  *
+  *  \param[in] offset Destination start address.
+  *  \param[in,out] buf  Buffer containing the data sent by the host.
+  *  \param[in] length  Number of bytes to write.
+  *  \return Nothing.
+  *
+  */
+  void (*MSC_GetWriteBuf)( uint32_t offset, uint8_t** buff_adr, uint32_t length, uint32_t high_offset);
+
+  /**
+  *  Optional user override-able function to replace the default MSC class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_MSC_API::Init().
+  *  \n
+  *  \note
+  *
+  *  \param[in] hUsb Handle to the USB device stack.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack.
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*MSC_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  uint64_t  MemorySize64;
+
+} USBD_MSC_INIT_PARAM_T;
+
+/** \brief MSC class API functions structure.
+ *  \ingroup USBD_MSC
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_MSC_API
+{
+  /** \fn uint32_t GetMemSize(USBD_MSC_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the MSC function driver module.
+   *
+   *  This function is called by application layer before calling pUsbApi->msc->Init(), to allocate memory used
+   *  by MSC function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller.
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing MSC function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_MSC_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param)
+   *  Function to initialize MSC function driver module.
+   *
+   *  This function is called by application layer to initialize MSC function driver module.
+   *
+   *  \param[in] hUsb Handle to the USB device stack.
+   *  \param[in, out] param Structure containing MSC function driver module initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte
+   *              aligned or smaller than required.
+   *          \retval ERR_API_INVALID_PARAM2 Either MSC_Write() or MSC_Read() or
+   *              MSC_Verify() callbacks are not defined.
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.
+   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed.
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param);
+
+} USBD_MSC_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _MSC_CTRL_T
+{
+  /* If it's a USB HS, the max packet is 512, if it's USB FS,
+  the max packet is 64. Use 512 for both HS and FS. */
+  /*ALIGNED(4)*/ uint8_t  BulkBuf[USB_HS_MAX_BULK_PACKET]; /* Bulk In/Out Buffer */
+  /*ALIGNED(4)*/MSC_CBW CBW;                   /* Command Block Wrapper */
+  /*ALIGNED(4)*/MSC_CSW CSW;                   /* Command Status Wrapper */
+
+  USB_CORE_CTRL_T*  pUsbCtrl;
+
+  uint64_t Offset;                  /* R/W Offset */
+  uint32_t Length;                  /* R/W Length */
+  uint32_t BulkLen;                 /* Bulk In/Out Length */
+  uint8_t* rx_buf;
+
+  uint8_t BulkStage;               /* Bulk Stage */
+  uint8_t if_num;                  /* interface number */
+  uint8_t epin_num;                /* BULK IN endpoint number */
+  uint8_t epout_num;               /* BULK OUT endpoint number */
+  uint32_t MemOK;                  /* Memory OK */
+
+  uint8_t*  InquiryStr;
+  uint32_t  BlockCount;
+  uint32_t  BlockSize;
+  uint64_t  MemorySize;
+  /* user defined functions */
+  void (*MSC_Write)( uint32_t offset, uint8_t** src, uint32_t length, uint32_t high_offset);
+  void (*MSC_Read)( uint32_t offset, uint8_t** dst, uint32_t length, uint32_t high_offset);
+  ErrorCode_t (*MSC_Verify)( uint32_t offset, uint8_t src[], uint32_t length, uint32_t high_offset);
+  /* optional call back for MSC_Write optimization */
+  void (*MSC_GetWriteBuf)( uint32_t offset, uint8_t** buff_adr, uint32_t length, uint32_t high_offset);
+
+
+}USB_MSC_CTRL_T;
+
+/** @cond  DIRECT_API */
+extern uint32_t mwMSC_GetMemSize(USBD_MSC_INIT_PARAM_T* param);
+extern ErrorCode_t mwMSC_init(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param);
+/** @endcond */
+
+/** @endcond */
+
+
+#endif  /* __MSCUSER_H__ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_rom_api.h ./lpc_chip_43xx/inc/usbd/usbd_rom_api.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbd/usbd_rom_api.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbd/usbd_rom_api.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,92 @@
+/***********************************************************************
+* $Id:: mw_usbd_rom_api.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     ROM API Module definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MW_USBD_ROM_API_H
+#define __MW_USBD_ROM_API_H
+/** \file
+ *  \brief ROM API for USB device stack.
+ *
+ *  Definition of functions exported by ROM based USB device stack.
+ *
+ */
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_hw.h"
+#include "usbd_core.h"
+#include "usbd_mscuser.h"
+#include "usbd_dfuuser.h"
+#include "usbd_hiduser.h"
+#include "usbd_cdcuser.h"
+
+/** \brief Main USBD API functions structure.
+ *  \ingroup Group_USBD
+ *
+ *  This structure contains pointer to various USB Device stack's sub-module
+ *  function tables. This structure is used as main entry point to access
+ *  various methods (grouped in sub-modules) exposed by ROM based USB device
+ *  stack.
+ *
+ */
+typedef struct USBD_API
+{
+  const USBD_HW_API_T* hw; /**< Pointer to function table which exposes functions
+                           which interact directly with USB device stack's core
+                           layer.*/
+  const USBD_CORE_API_T* core; /**< Pointer to function table which exposes functions
+                           which interact directly with USB device controller
+                           hardware.*/
+  const USBD_MSC_API_T* msc; /**< Pointer to function table which exposes functions
+                           provided by MSC function driver module.
+                           */
+  const USBD_DFU_API_T* dfu; /**< Pointer to function table which exposes functions
+                           provided by DFU function driver module.
+                           */
+  const USBD_HID_API_T* hid; /**< Pointer to function table which exposes functions
+                           provided by HID function driver module.
+                           */
+  const USBD_CDC_API_T* cdc; /**< Pointer to function table which exposes functions
+                           provided by CDC-ACM function driver module.
+                           */
+  const uint32_t* reserved6; /**< Reserved for future function driver module.
+                           */
+  const uint32_t version; /**< Version identifier of USB ROM stack. The version is
+                          defined as 0x0CHDMhCC where each nibble represents version
+                          number of the corresponding component.
+                          CC -  7:0  - 8bit core version number
+                           h - 11:8  - 4bit hardware interface version number
+                           M - 15:12 - 4bit MSC class module version number
+                           D - 19:16 - 4bit DFU class module version number
+                           H - 23:20 - 4bit HID class module version number
+                           C - 27:24 - 4bit CDC class module version number
+                           H - 31:28 - 4bit reserved
+                           */
+
+} USBD_API_T;
+
+/* Applications using USBD ROM API should define this instance. The pointer should be assigned a value computed based on chip definitions. */
+extern const USBD_API_T* g_pUsbApi;
+#define USBD_API g_pUsbApi
+
+#endif /*__MW_USBD_ROM_API_H*/
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/usbhs_18xx_43xx.h ./lpc_chip_43xx/inc/usbhs_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/usbhs_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/usbhs_18xx_43xx.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,123 @@
+/*
+ * @brief LPC18xx/43xx High-Speed USB driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __USBHS_18XX_43XX_H_
+#define __USBHS_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup USBHS_18XX_43XX CHIP: LPC18xx/43xx USBHS Device, Host, & OTG driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief USB High-Speed register block structure
+ */
+typedef struct {                           /*!< USB Structure         */
+   __I  uint32_t  RESERVED0[64];
+   __I  uint32_t  CAPLENGTH;               /*!< Capability register length */
+   __I  uint32_t  HCSPARAMS;               /*!< Host controller structural parameters */
+   __I  uint32_t  HCCPARAMS;               /*!< Host controller capability parameters */
+   __I  uint32_t  RESERVED1[5];
+   __I  uint32_t  DCIVERSION;              /*!< Device interface version number */
+   __I  uint32_t  RESERVED2[7];
+   union {
+       __IO uint32_t  USBCMD_H;            /*!< USB command (host mode) */
+       __IO uint32_t  USBCMD_D;            /*!< USB command (device mode) */
+   };
+
+   union {
+       __IO uint32_t  USBSTS_H;            /*!< USB status (host mode) */
+       __IO uint32_t  USBSTS_D;            /*!< USB status (device mode) */
+   };
+
+   union {
+       __IO uint32_t  USBINTR_H;           /*!< USB interrupt enable (host mode) */
+       __IO uint32_t  USBINTR_D;           /*!< USB interrupt enable (device mode) */
+   };
+
+   union {
+       __IO uint32_t  FRINDEX_H;           /*!< USB frame index (host mode) */
+       __I  uint32_t  FRINDEX_D;           /*!< USB frame index (device mode) */
+   };
+
+   __I  uint32_t  RESERVED3;
+   union {
+       __IO uint32_t  PERIODICLISTBASE;    /*!< Frame list base address */
+       __IO uint32_t  DEVICEADDR;          /*!< USB device address     */
+   };
+
+   union {
+       __IO uint32_t  ASYNCLISTADDR;       /*!< Address of endpoint list in memory (host mode) */
+       __IO uint32_t  ENDPOINTLISTADDR;    /*!< Address of endpoint list in memory (device mode) */
+   };
+
+   __IO uint32_t  TTCTRL;                  /*!< Asynchronous buffer status for embedded TT (host mode) */
+   __IO uint32_t  BURSTSIZE;               /*!< Programmable burst size */
+   __IO uint32_t  TXFILLTUNING;            /*!< Host transmit pre-buffer packet tuning (host mode) */
+   __I  uint32_t  RESERVED4[2];
+   __IO uint32_t  ULPIVIEWPORT;            /*!< ULPI viewport          */
+   __IO uint32_t  BINTERVAL;               /*!< Length of virtual frame */
+   __IO uint32_t  ENDPTNAK;                /*!< Endpoint NAK (device mode) */
+   __IO uint32_t  ENDPTNAKEN;              /*!< Endpoint NAK Enable (device mode) */
+   __I  uint32_t  RESERVED5;
+   union {
+       __IO uint32_t  PORTSC1_H;           /*!< Port 1 status/control (host mode) */
+       __IO uint32_t  PORTSC1_D;           /*!< Port 1 status/control (device mode) */
+   };
+
+   __I  uint32_t  RESERVED6[7];
+   __IO uint32_t  OTGSC;                   /*!< OTG status and control */
+   union {
+       __IO uint32_t  USBMODE_H;           /*!< USB mode (host mode)   */
+       __IO uint32_t  USBMODE_D;           /*!< USB mode (device mode) */
+   };
+
+   __IO uint32_t  ENDPTSETUPSTAT;          /*!< Endpoint setup status  */
+   __IO uint32_t  ENDPTPRIME;              /*!< Endpoint initialization */
+   __IO uint32_t  ENDPTFLUSH;              /*!< Endpoint de-initialization */
+   __I  uint32_t  ENDPTSTAT;               /*!< Endpoint status        */
+   __IO uint32_t  ENDPTCOMPLETE;           /*!< Endpoint complete      */
+   __IO uint32_t  ENDPTCTRL[6];            /*!< Endpoint control 0     */
+} LPC_USBHS_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __USBHS_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/inc/wwdt_18xx_43xx.h ./lpc_chip_43xx/inc/wwdt_18xx_43xx.h
--- a_qSC69Z/lpc_chip_43xx/inc/wwdt_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/inc/wwdt_18xx_43xx.h	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,227 @@
+/*
+ * @brief LPC18xx/43xx WWDT driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __WWDT_18XX_43XX_H_
+#define __WWDT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup WWDT_18XX_43XX CHIP: LPC18xx/43xx Windowed Watchdog driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define WATCHDOG_WINDOW_SUPPORT
+
+/** WDT oscillator frequency value */
+#define WDT_OSC     (CGU_IRC_FREQ)
+
+/**
+ * @brief Windowed Watchdog register block structure
+ */
+typedef struct {               /*!< WWDT Structure         */
+   __IO uint32_t  MOD;         /*!< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
+   __IO uint32_t  TC;          /*!< Watchdog timer constant register. This register determines the time-out value. */
+   __O  uint32_t  FEED;        /*!< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC. */
+   __I  uint32_t  TV;          /*!< Watchdog timer value register. This register reads out the current value of the Watchdog timer. */
+   __I  uint32_t  RESERVED0;
+#ifdef WATCHDOG_WINDOW_SUPPORT
+   __IO uint32_t  WARNINT;     /*!< Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value. */
+   __IO uint32_t  WINDOW;      /*!< Watchdog timer window register. This register contains the Watchdog window value. */
+#endif
+} LPC_WWDT_T;
+
+/**
+ * @brief Watchdog Mode register definitions
+ */
+/** Watchdog Mode Bitmask */
+#define WWDT_WDMOD_BITMASK          ((uint32_t) 0x1F)
+/** WWDT interrupt enable bit */
+#define WWDT_WDMOD_WDEN             ((uint32_t) (1 << 0))
+/** WWDT interrupt enable bit */
+#define WWDT_WDMOD_WDRESET          ((uint32_t) (1 << 1))
+/** WWDT time out flag bit */
+#define WWDT_WDMOD_WDTOF            ((uint32_t) (1 << 2))
+/** WDT Time Out flag bit */
+#define WWDT_WDMOD_WDINT            ((uint32_t) (1 << 3))
+/** WWDT Protect flag bit */
+#define WWDT_WDMOD_WDPROTECT        ((uint32_t) (1 << 4))
+
+/**
+ * @brief  Initialize the Watchdog timer
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @return None
+ */
+void Chip_WWDT_Init(LPC_WWDT_T *pWWDT);
+
+/**
+ * @brief  Shutdown the Watchdog timer
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @return None
+ */
+void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT);
+
+/**
+ * @brief  Set WDT timeout constant value used for feed
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @param  timeout : WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
+ * @return none
+ */
+STATIC INLINE void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+   pWWDT->TC = timeout;
+}
+
+/**
+ * @brief  Feed watchdog timer
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @return None
+ * @note   If this function isn't called, a watchdog timer warning will occur.
+ * After the warning, a timeout will occur if a feed has happened.
+ */
+STATIC INLINE void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
+{
+   pWWDT->FEED = 0xAA;
+   pWWDT->FEED = 0x55;
+}
+
+#if defined(WATCHDOG_WINDOW_SUPPORT)
+/**
+ * @brief  Set WWDT warning interrupt
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @param  timeout : WDT warning in ticks, between 0 and 1023
+ * @return None
+ * @note   This is the number of ticks after the watchdog interrupt that the
+ * warning interrupt will be generated.
+ */
+STATIC INLINE void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+   pWWDT->WARNINT = timeout;
+}
+
+/**
+ * @brief  Set WWDT window time
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @param  timeout : WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
+ * @return None
+ * @note   The watchdog timer must be fed between the timeout from the Chip_WWDT_SetTimeOut()
+ * function and this function, with this function defining the last tick before the
+ * watchdog window interrupt occurs.
+ */
+STATIC INLINE void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+   pWWDT->WINDOW = timeout;
+}
+
+#endif
+
+/**
+ * @brief  Enable watchdog timer options
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @param  options : An or'ed set of options of values
+ *                     WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
+ * @return None
+ * @note   You can enable more than one option at once (ie, WWDT_WDMOD_WDRESET |
+ * WWDT_WDMOD_WDPROTECT), but use the WWDT_WDMOD_WDEN after all other options
+ * are set (or unset) with no other options. If WWDT_WDMOD_LOCK is used, it cannot
+ * be unset.
+ */
+STATIC INLINE void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
+{
+   pWWDT->MOD |= options;
+}
+
+/**
+ * @brief  Disable/clear watchdog timer options
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @param  options : An or'ed set of options of values
+ *                     WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
+ * @return None
+ * @note   You can disable more than one option at once (ie, WWDT_WDMOD_WDRESET |
+ * WWDT_WDMOD_WDTOF).
+ */
+STATIC INLINE void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
+{
+   pWWDT->MOD &= (~options) & WWDT_WDMOD_BITMASK;
+}
+
+/**
+ * @brief  Enable WWDT activity
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @return None
+ */
+STATIC INLINE void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
+{
+   Chip_WWDT_SetOption(pWWDT, WWDT_WDMOD_WDEN);
+   Chip_WWDT_Feed(pWWDT);
+}
+
+/**
+ * @brief  Read WWDT status flag
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @return Watchdog status, an Or'ed value of WWDT_WDMOD_*
+ */
+STATIC INLINE uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
+{
+   return pWWDT->MOD;
+}
+
+/**
+ * @brief  Clear WWDT interrupt status flags
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @param  status  : Or'ed value of status flag(s) that you want to clear, should be:
+ *              - WWDT_WDMOD_WDTOF: Clear watchdog timeout flag
+ *              - WWDT_WDMOD_WDINT: Clear watchdog warning flag
+ * @return None
+ */
+void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status);
+
+/**
+ * @brief  Get the current value of WDT
+ * @param  pWWDT   : The base of WatchDog Timer peripheral on the chip
+ * @return current value of WDT
+ */
+STATIC INLINE uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
+{
+   return pWWDT->TV;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __WWDT_18XX_43XX_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/adc_18xx_43xx.c ./lpc_chip_43xx/src/adc_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/adc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/adc_18xx_43xx.c	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,257 @@
+/*
+ * @brief LPC18xx/43xx A/D conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Get the number of clock for a full conversion */
+STATIC INLINE uint8_t getFullConvClk(void)
+{
+   return 11;
+}
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_ADC_GetClockIndex(LPC_ADC_T *pADC)
+{
+   CHIP_CCU_CLK_T clkADC;
+
+   if (pADC == LPC_ADC1) {
+       clkADC = CLK_APB3_ADC1;
+   }
+   else {
+       clkADC = CLK_APB3_ADC0;
+   }
+
+   return clkADC;
+}
+
+/* Get divider value */
+STATIC uint8_t getClkDiv(LPC_ADC_T *pADC, bool burstMode, uint32_t adcRate, uint8_t clks)
+{
+   uint32_t adcBlockFreq;
+   uint32_t fullAdcRate;
+   uint8_t div;
+
+   /* The APB clock (PCLK_ADC0) is divided by (CLKDIV+1) to produce the clock for
+      A/D converter, which should be less than or equal to 4.5MHz.
+      A fully conversion requires (bits_accuracy+1) of these clocks.
+      ADC Clock = PCLK_ADC0 / (CLKDIV + 1);
+      ADC rate = ADC clock / (the number of clocks required for each conversion);
+    */
+   adcBlockFreq = Chip_Clock_GetRate(Chip_ADC_GetClockIndex(pADC));
+   if (burstMode) {
+       fullAdcRate = adcRate * clks;
+   }
+   else {
+       fullAdcRate = adcRate * getFullConvClk();
+   }
+
+   /* Get the round value by fomular: (2*A + B)/(2*B) */
+   div = ((adcBlockFreq * 2 + fullAdcRate) / (fullAdcRate * 2)) - 1;
+   return div;
+}
+
+/* Set start mode for ADC */
+void setStartMode(LPC_ADC_T *pADC, uint8_t start_mode)
+{
+   uint32_t temp;
+   temp = pADC->CR & (~ADC_CR_START_MASK);
+   pADC->CR = temp | (ADC_CR_START_MODE_SEL((uint32_t) start_mode));
+}
+
+/* Get the ADC value */
+Status readAdcVal(LPC_ADC_T *pADC, uint8_t channel, uint16_t *data)
+{
+   uint32_t temp;
+   temp = pADC->DR[channel];
+   if (!ADC_DR_DONE(temp)) {
+       return ERROR;
+   }
+   /*  if(ADC_DR_OVERRUN(temp) && (pADC->CR & ADC_CR_BURST)) */
+   /*  return ERROR; */
+   *data = (uint16_t) ADC_DR_RESULT(temp);
+   return SUCCESS;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the ADC peripheral and the ADC setup structure to default value */
+void Chip_ADC_Init(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup)
+{
+   uint8_t div;
+   uint32_t cr = 0;
+   uint32_t clk;
+
+   Chip_Clock_EnableOpts(Chip_ADC_GetClockIndex(pADC), true, true, 1);
+
+   pADC->INTEN = 0;        /* Disable all interrupts */
+
+   cr |= ADC_CR_PDN;
+   ADCSetup->adcRate = ADC_MAX_SAMPLE_RATE;
+   ADCSetup->bitsAccuracy = ADC_10BITS;
+   clk = 11;
+   ADCSetup->burstMode = false;
+   div = getClkDiv(pADC, false, ADCSetup->adcRate, clk);
+   cr |= ADC_CR_CLKDIV(div);
+   cr |= ADC_CR_BITACC(ADCSetup->bitsAccuracy);
+   pADC->CR = cr;
+}
+
+/* Shutdown ADC */
+void Chip_ADC_DeInit(LPC_ADC_T *pADC)
+{
+   pADC->INTEN = 0x00000100;
+   pADC->CR = 0;
+   Chip_Clock_Disable(Chip_ADC_GetClockIndex(pADC));
+}
+
+/* Get the ADC value */
+Status Chip_ADC_ReadValue(LPC_ADC_T *pADC, uint8_t channel, uint16_t *data)
+{
+   return readAdcVal(pADC, channel, data);
+}
+
+/* Get ADC Channel status from ADC data register */
+FlagStatus Chip_ADC_ReadStatus(LPC_ADC_T *pADC, uint8_t channel, uint32_t StatusType)
+{
+   switch (StatusType) {
+   case ADC_DR_DONE_STAT:
+       return (pADC->STAT & (1UL << channel)) ? SET : RESET;
+
+   case ADC_DR_OVERRUN_STAT:
+       channel += 8;
+       return (pADC->STAT & (1UL << channel)) ? SET : RESET;
+
+   case ADC_DR_ADINT_STAT:
+       return pADC->STAT >> 16 ? SET : RESET;
+
+   default:
+       break;
+   }
+   return RESET;
+}
+
+/* Enable/Disable interrupt for ADC channel */
+void Chip_ADC_Int_SetChannelCmd(LPC_ADC_T *pADC, uint8_t channel, FunctionalState NewState)
+{
+   if (NewState == ENABLE) {
+       pADC->INTEN |= (1UL << channel);
+   }
+   else {
+       pADC->INTEN &= (~(1UL << channel));
+   }
+}
+
+/* Select the mode starting the AD conversion */
+void Chip_ADC_SetStartMode(LPC_ADC_T *pADC, ADC_START_MODE_T mode, ADC_EDGE_CFG_T EdgeOption)
+{
+   if ((mode != ADC_START_NOW) && (mode != ADC_NO_START)) {
+       if (EdgeOption) {
+           pADC->CR |= ADC_CR_EDGE;
+       }
+       else {
+           pADC->CR &= ~ADC_CR_EDGE;
+       }
+   }
+   setStartMode(pADC, (uint8_t) mode);
+}
+
+/* Set the ADC Sample rate */
+void Chip_ADC_SetSampleRate(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, uint32_t rate)
+{
+   uint8_t div;
+   uint32_t cr;
+
+   cr = pADC->CR & (~ADC_SAMPLE_RATE_CONFIG_MASK);
+   ADCSetup->adcRate = rate;
+   div = getClkDiv(pADC, ADCSetup->burstMode, rate, (11 - ADCSetup->bitsAccuracy));
+   cr |= ADC_CR_CLKDIV(div);
+   cr |= ADC_CR_BITACC(ADCSetup->bitsAccuracy);
+   pADC->CR = cr;
+}
+
+/* Set the ADC accuracy bits */
+void Chip_ADC_SetResolution(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, ADC_RESOLUTION_T resolution)
+{
+   ADCSetup->bitsAccuracy = resolution;
+   Chip_ADC_SetSampleRate(pADC, ADCSetup, ADCSetup->adcRate);
+}
+
+/* Enable or disable the ADC channel on ADC peripheral */
+void Chip_ADC_EnableChannel(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, FunctionalState NewState)
+{
+   if (NewState == ENABLE) {
+       pADC->CR |= ADC_CR_CH_SEL(channel);
+   }
+   else {
+       pADC->CR &= ~ADC_CR_START_MASK;
+       pADC->CR &= ~ADC_CR_CH_SEL(channel);
+   }
+}
+
+/* Enable burst mode */
+void Chip_ADC_SetBurstCmd(LPC_ADC_T *pADC, FunctionalState NewState)
+{
+   setStartMode(pADC, ADC_NO_START);
+
+    if (NewState == DISABLE) {
+       pADC->CR &= ~ADC_CR_BURST;
+   }
+   else {
+       pADC->CR |= ADC_CR_BURST;
+   }
+}
+
+/* Read the ADC value and convert it to 8bits value */
+Status Chip_ADC_ReadByte(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, uint8_t *data)
+{
+   uint16_t temp;
+   Status rt;
+
+   rt = readAdcVal(pADC, channel, &temp);
+   *data = (uint8_t) temp;
+
+   return rt;
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/aes_18xx_43xx.c ./lpc_chip_43xx/src/aes_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/aes_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/aes_18xx_43xx.c	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,174 @@
+/*
+ * @brief LPC18xx/43xx AES Engine driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define BOOTROM_BASE           0x10400100
+#define AES_API_TABLE_OFFSET   0x2
+
+typedef    void        (*V_FP_V)(void);
+typedef    uint32_t    (*U32_FP_V)(void);
+
+static unsigned long *BOOTROM_API_TABLE;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+static uint32_t (*aes_SetMode)(CHIP_AES_OP_MODE_T AesMode);
+static void (*aes_LoadKey1)(void);
+static void (*aes_LoadKey2)(void);
+static void (*aes_LoadKeyRNG)(void);
+static void (*aes_LoadKeySW)(uint8_t *pKey);
+static void (*aes_LoadIV_SW)(uint8_t *pVector);
+static void (*aes_LoadIV_IC)(void);
+static uint32_t (*aes_Operate)(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t size);
+static uint32_t (*aes_ProgramKey1)(uint8_t *pKey);
+static uint32_t (*aes_ProgramKey2)(uint8_t *pKey);
+static uint32_t (*aes_Config_DMA) (uint32_t channel_id);
+static uint32_t (*aes_Operate_DMA)(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size);
+static uint32_t (*aes_Get_Status_DMA) (uint32_t channel_id);
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* CHIP AES Initialisation function */
+void Chip_AES_Init(void)
+{
+   uint32_t (*ROM_aes_Init)(void);
+
+   BOOTROM_API_TABLE = *((unsigned long * *) BOOTROM_BASE + AES_API_TABLE_OFFSET);
+
+   ROM_aes_Init        = (uint32_t (*)(void))BOOTROM_API_TABLE[0];
+   aes_SetMode         = (uint32_t (*)(CHIP_AES_OP_MODE_T AesMode))BOOTROM_API_TABLE[1];
+   aes_LoadKey1        = (void (*)(void))BOOTROM_API_TABLE[2];
+   aes_LoadKey2        = (void (*)(void))BOOTROM_API_TABLE[3];
+   aes_LoadKeyRNG      = (void (*)(void))BOOTROM_API_TABLE[4];
+   aes_LoadKeySW       = (void (*)(uint8_t *pKey))BOOTROM_API_TABLE[5];
+   aes_LoadIV_SW       = (void (*)(uint8_t *pVector))BOOTROM_API_TABLE[6];
+   aes_LoadIV_IC       = (void (*)(void))BOOTROM_API_TABLE[7];
+   aes_Operate         = (uint32_t (*)(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t Size))BOOTROM_API_TABLE[8];
+   aes_ProgramKey1     = (uint32_t (*)(uint8_t *pKey))BOOTROM_API_TABLE[9];
+   aes_ProgramKey2     = (uint32_t (*)(uint8_t *pKey))BOOTROM_API_TABLE[10];
+   aes_Config_DMA      = (uint32_t (*)(uint32_t channel_id))BOOTROM_API_TABLE[11];
+   aes_Operate_DMA     = (uint32_t (*)(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size))BOOTROM_API_TABLE[12];
+   aes_Get_Status_DMA  = (uint32_t (*) (uint32_t channel_id))BOOTROM_API_TABLE[13];
+
+   ROM_aes_Init();
+}
+
+/* Set Operation mode in AES Engine */
+uint32_t Chip_AES_SetMode(CHIP_AES_OP_MODE_T AesMode)
+{
+   return aes_SetMode(AesMode);
+}
+
+/* Load 128-bit user key in AES Engine */
+void Chip_AES_LoadKey(uint32_t keyNum)
+{
+   if (keyNum) {
+       aes_LoadKey2();
+   }
+   else {
+       aes_LoadKey1();
+   }
+}
+
+/* Load randomly generated key in AES engine */
+void Chip_AES_LoadKeyRNG(void)
+{
+   aes_LoadKeyRNG();
+}
+
+/* Load 128-bit AES software defined user key */
+void Chip_AES_LoadKeySW(uint8_t *pKey)
+{
+   aes_LoadKeySW(pKey);
+}
+
+/* Load 128-bit AES initialization vector */
+void Chip_AES_LoadIV_SW(uint8_t *pVector)
+{
+   aes_LoadIV_SW(pVector);
+}
+
+/* Load IC specific 128-bit AES initialization vector */
+void Chip_AES_LoadIV_IC(void)
+{
+   aes_LoadIV_IC();
+}
+
+/* Operate AES Engine */
+uint32_t Chip_AES_Operate(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t Size)
+{
+   return aes_Operate(pDatOut, pDatIn, Size);
+}
+
+/* Program 128-bit AES Key in OTP */
+uint32_t Chip_AES_ProgramKey(uint32_t KeyNum, uint8_t *pKey)
+{
+   uint32_t status;
+
+   if (KeyNum) {
+       status = aes_ProgramKey2(pKey);
+   }
+   else {
+       status = aes_ProgramKey1(pKey);
+   }
+   return status;
+}
+
+/* Configure DMA channel to process AES block */
+uint32_t Chip_AES_Config_DMA(uint32_t channel_id)
+{
+   return aes_Config_DMA(channel_id);
+}
+
+/* Enables DMA channel and Operates AES Engine */
+uint32_t Chip_AES_OperateDMA(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size)
+{
+   return aes_Operate_DMA(channel_id,dataOutAddr,dataInAddr,size);
+}
+
+/* Read status of DMA channels that process an AES data block. */
+uint32_t Chip_AES_GetStatusDMA(uint32_t channel_id)
+{
+   return aes_Get_Status_DMA(channel_id);
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/atimer_18xx_43xx.c ./lpc_chip_43xx/src/atimer_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/atimer_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/atimer_18xx_43xx.c	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,63 @@
+/*
+ * @brief LPC18xx/43xx Alarm Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize Alarm Timer */
+void Chip_ATIMER_Init(LPC_ATIMER_T *pATIMER, uint32_t PresetValue)
+{
+   Chip_ATIMER_UpdatePresetValue(pATIMER, PresetValue);
+   Chip_ATIMER_ClearIntStatus(pATIMER);
+}
+
+/* Close ATIMER device */
+void Chip_ATIMER_DeInit(LPC_ATIMER_T *pATIMER)
+{
+   Chip_ATIMER_ClearIntStatus(pATIMER);
+   Chip_ATIMER_IntDisable(pATIMER);
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/ccan_18xx_43xx.c ./lpc_chip_43xx/src/ccan_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/ccan_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/ccan_18xx_43xx.c	2018-01-19 23:55:10.984318734 -0300
@@ -0,0 +1,311 @@
+/*
+ * @brief LPC18xx/43xx CCAN driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Configure the bit timing for CCAN bus */
+STATIC void configTimming(LPC_CCAN_T *pCCAN,
+                         uint32_t ClkDiv,
+                         uint32_t BaudRatePrescaler,
+                         uint8_t SynJumpWidth,
+                         uint8_t Tseg1,
+                         uint8_t Tseg2)
+{
+   /* Reset software */
+   if (!(pCCAN->CNTL & CCAN_CTRL_INIT)) {
+       pCCAN->CNTL |= CCAN_CTRL_INIT;
+   }
+
+   /*Set bus timing */
+   pCCAN->CLKDIV = ClkDiv;         /* Divider for CAN VPB3 clock */
+   pCCAN->CNTL |= CCAN_CTRL_CCE;       /* Start configuring bit timing */
+   pCCAN->BT = (BaudRatePrescaler & 0x3F) | (SynJumpWidth & 0x03) << 6 | (Tseg1 & 0x0F) << 8 | (Tseg2 & 0x07) << 12;
+   pCCAN->BRPE = BaudRatePrescaler >> 6;   /* Set Baud Rate Prescaler MSBs */
+   pCCAN->CNTL &= ~CCAN_CTRL_CCE;      /* Stop configuring bit timing */
+
+   /* Finish software initialization */
+   pCCAN->CNTL &= ~CCAN_CTRL_INIT;
+   while ( pCCAN->CNTL & CCAN_CTRL_INIT ) {}
+}
+
+/* Return 1->32; 0 if not find free msg */
+STATIC uint8_t getFreeMsgObject(LPC_CCAN_T *pCCAN)
+{
+   uint32_t msg_valid;
+   uint8_t i;
+   msg_valid = Chip_CCAN_GetValidMsg(pCCAN);
+   for (i = 0; i < CCAN_MSG_MAX_NUM; i++) {
+       if (!((msg_valid >> i) & 1UL)) {
+           return i + 1;
+       }
+   }
+   return 0;   // No free object
+}
+
+STATIC void freeMsgObject(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum)
+{
+   Chip_CCAN_SetValidMsg(pCCAN, IFSel, msgNum, false);
+}
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_CCAN_GetClockIndex(LPC_CCAN_T *pCCAN)
+{
+   CHIP_CCU_CLK_T clkCCAN;
+
+   if (pCCAN == LPC_C_CAN1) {
+       clkCCAN = CLK_APB1_CAN1;
+   }
+   else {
+       clkCCAN = CLK_APB3_CAN0;
+   }
+
+   return clkCCAN;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the CCAN peripheral, free all message object in RAM */
+void Chip_CCAN_Init(LPC_CCAN_T *pCCAN)
+{
+   uint8_t i;
+
+   Chip_Clock_EnableOpts(Chip_CCAN_GetClockIndex(pCCAN), true, false, 1);
+
+   for (i = 1; i <= CCAN_MSG_MAX_NUM; i++) {
+       freeMsgObject(pCCAN, CCAN_MSG_IF1, i);
+   }
+   Chip_CCAN_ClearStatus(pCCAN, (CCAN_STAT_RXOK | CCAN_STAT_TXOK));
+}
+
+/* De-initialize the CCAN peripheral */
+void Chip_CCAN_DeInit(LPC_CCAN_T *pCCAN)
+{
+   Chip_Clock_Disable(Chip_CCAN_GetClockIndex(pCCAN));
+}
+
+/* Select bit rate for CCAN bus */
+Status Chip_CCAN_SetBitRate(LPC_CCAN_T *pCCAN, uint32_t bitRate)
+{
+   uint32_t pClk, div, quanta, segs, seg1, seg2, clk_per_bit, can_sjw;
+   pClk = Chip_Clock_GetRate(Chip_CCAN_GetClockIndex(pCCAN));
+   clk_per_bit = pClk / bitRate;
+
+   for (div = 0; div <= 15; div++) {
+       for (quanta = 1; quanta <= 32; quanta++) {
+           for (segs = 3; segs <= 17; segs++) {
+               if (clk_per_bit == (segs * quanta * (div + 1))) {
+                   segs -= 3;
+                   seg1 = segs / 2;
+                   seg2 = segs - seg1;
+                   can_sjw = seg1 > 3 ? 3 : seg1;
+                   configTimming(pCCAN, div, quanta - 1, can_sjw, seg1, seg2);
+                   return SUCCESS;
+               }
+           }
+       }
+   }
+   return ERROR;
+}
+
+/* Clear the status of CCAN bus */
+void Chip_CCAN_ClearStatus(LPC_CCAN_T *pCCAN, uint32_t val)
+{
+   uint32_t tmp = Chip_CCAN_GetStatus(pCCAN);
+   Chip_CCAN_SetStatus(pCCAN, tmp & (~val));
+}
+
+/* Set a message into the message object in message RAM */
+void Chip_CCAN_SetMsgObject(LPC_CCAN_T *pCCAN,
+                           CCAN_MSG_IF_T IFSel,
+                           CCAN_TRANSFER_DIR_T dir,
+                           bool remoteFrame,
+                           uint8_t msgNum,
+                           const CCAN_MSG_OBJ_T *pMsgObj)
+{
+   uint16_t *pData;
+   uint32_t msgCtrl = 0;
+
+   if (pMsgObj == NULL) {
+       return;
+   }
+   pData = (uint16_t *) (pMsgObj->data);
+
+   msgCtrl |= CCAN_IF_MCTRL_UMSK | CCAN_IF_MCTRL_RMTEN(remoteFrame) | CCAN_IF_MCTRL_EOB |
+              (pMsgObj->dlc & CCAN_IF_MCTRL_DLC_MSK);
+   if (dir == CCAN_TX_DIR) {
+       msgCtrl |= CCAN_IF_MCTRL_TXIE;
+       if (!remoteFrame) {
+           msgCtrl |= CCAN_IF_MCTRL_TXRQ;
+       }
+   }
+   else {
+       msgCtrl |= CCAN_IF_MCTRL_RXIE;
+   }
+
+   pCCAN->IF[IFSel].MCTRL = msgCtrl;
+   pCCAN->IF[IFSel].DA1 = *pData++;    /* Lower two bytes of message pointer */
+   pCCAN->IF[IFSel].DA2 = *pData++;    /* Upper two bytes of message pointer */
+   pCCAN->IF[IFSel].DB1 = *pData++;    /* Lower two bytes of message pointer */
+   pCCAN->IF[IFSel].DB2 = *pData;  /* Upper two bytes of message pointer */
+
+   /* Configure arbitration */
+   if (!(pMsgObj->id & (0x1 << 30))) {                 /* bit 30 is 0, standard frame */
+       /* Mxtd: 0, Mdir: 1, Mask is 0x7FF */
+       pCCAN->IF[IFSel].MSK2 = CCAN_IF_MASK2_MDIR(dir) | (CCAN_MSG_ID_STD_MASK << 2);
+       pCCAN->IF[IFSel].MSK1 = 0x0000;
+
+       /* MsgVal: 1, Mtd: 0, Dir: 1, ID = 0x200 */
+       pCCAN->IF[IFSel].ARB2 = CCAN_IF_ARB2_MSGVAL | CCAN_IF_ARB2_DIR(dir) | (pMsgObj->id << 2);
+       pCCAN->IF[IFSel].ARB1 = 0x0000;
+   }
+   else {                                      /* Extended frame */
+       /* Mxtd: 1, Mdir: 1, Mask is 0x1FFFFFFF */
+       pCCAN->IF[IFSel].MSK2 = CCAN_IF_MASK2_MXTD | CCAN_IF_MASK2_MDIR(dir) | (CCAN_MSG_ID_EXT_MASK >> 16);
+       pCCAN->IF[IFSel].MSK1 = CCAN_MSG_ID_EXT_MASK & 0x0000FFFF;
+
+       /* MsgVal: 1, Mtd: 1, Dir: 1, ID = 0x200000 */
+       pCCAN->IF[IFSel].ARB2 = CCAN_IF_ARB2_MSGVAL | CCAN_IF_ARB2_XTD | CCAN_IF_ARB2_DIR(dir) | (pMsgObj->id >> 16);
+       pCCAN->IF[IFSel].ARB1 = pMsgObj->id & 0x0000FFFF;
+   }
+
+   Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_WR | CCAN_IF_CMDMSK_TRANSFER_ALL, msgNum);
+}
+
+/* Get a message object in message RAM into the message buffer */
+void Chip_CCAN_GetMsgObject(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, CCAN_MSG_OBJ_T *pMsgObj)
+{
+   uint32_t *pData;
+   if (!pMsgObj) {
+       return;
+   }
+   pData = (uint32_t *) pMsgObj->data;
+   Chip_CCAN_TransferMsgObject(pCCAN,
+                               IFSel,
+                               CCAN_IF_CMDMSK_RD | CCAN_IF_CMDMSK_TRANSFER_ALL | CCAN_IF_CMDMSK_R_CLRINTPND,
+                               msgNum);
+
+   if (pCCAN->IF[IFSel].MCTRL & CCAN_IF_MCTRL_NEWD) {
+       pMsgObj->id = (pCCAN->IF[IFSel].ARB1) | (pCCAN->IF[IFSel].ARB2 << 16);
+       pMsgObj->dlc = pCCAN->IF[IFSel].MCTRL & CCAN_IF_MCTRL_DLC_MSK;
+       *pData++ = (pCCAN->IF[IFSel].DA2 << 16) | pCCAN->IF[IFSel].DA1;
+       *pData = (pCCAN->IF[IFSel].DB2 << 16) | pCCAN->IF[IFSel].DB1;
+
+       if (pMsgObj->id & (0x1 << 30)) {
+           pMsgObj->id &= CCAN_MSG_ID_EXT_MASK;
+       }
+       else {
+           pMsgObj->id >>= 18;
+           pMsgObj->id &= CCAN_MSG_ID_STD_MASK;
+       }
+   }
+}
+
+/* Data transfer between IF registers and Message RAM */
+void Chip_CCAN_TransferMsgObject(LPC_CCAN_T *pCCAN,
+                                CCAN_MSG_IF_T IFSel,
+                                uint32_t mask,
+                                uint32_t msgNum) {
+   msgNum &= 0x3F;
+   pCCAN->IF[IFSel].CMDMSK = mask;
+   pCCAN->IF[IFSel].CMDREQ = msgNum;
+   while (pCCAN->IF[IFSel].CMDREQ & CCAN_IF_CMDREQ_BUSY ) {}
+}
+
+/* Enable/Disable the message object to valid */
+void Chip_CCAN_SetValidMsg(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, bool valid)
+{
+
+   uint32_t temp;
+   temp = pCCAN->IF[IFSel].ARB2;
+   if (!valid) {
+       pCCAN->IF[IFSel].ARB2 = (temp & (~CCAN_IF_ARB2_MSGVAL));
+   }
+   else {
+       pCCAN->IF[IFSel].ARB2 = (temp | (CCAN_IF_ARB2_MSGVAL));
+   }
+
+   Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_WR | CCAN_IF_CMDMSK_ARB, msgNum);
+}
+
+/* Send a message */
+void Chip_CCAN_Send(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, bool remoteFrame, CCAN_MSG_OBJ_T *pMsgObj)
+{
+   uint8_t msgNum = getFreeMsgObject(pCCAN);
+   if (!msgNum) {
+       return;
+   }
+   Chip_CCAN_SetMsgObject(pCCAN, IFSel, CCAN_TX_DIR, remoteFrame, msgNum, pMsgObj);
+   while (Chip_CCAN_GetTxRQST(pCCAN) >> (msgNum - 1)) {    // blocking , wait for sending completed
+   }
+   if (!remoteFrame) {
+       freeMsgObject(pCCAN, IFSel, msgNum);
+   }
+}
+
+/* Register a message ID for receiving */
+void Chip_CCAN_AddReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id)
+{
+   CCAN_MSG_OBJ_T temp;
+   uint8_t msgNum = getFreeMsgObject(pCCAN);
+   if (!msgNum) {
+       return;
+   }
+   temp.id = id;
+   Chip_CCAN_SetMsgObject(pCCAN, IFSel, CCAN_RX_DIR, false, msgNum, &temp);
+}
+
+/* Remove a registered message ID from receiving */
+void Chip_CCAN_DeleteReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id)
+{
+   uint8_t i;
+   CCAN_MSG_OBJ_T temp;
+   for (i = 1; i <= CCAN_MSG_MAX_NUM; i++) {
+       Chip_CCAN_GetMsgObject(pCCAN, IFSel, i, &temp);
+       if (temp.id == id) {
+           freeMsgObject(pCCAN, IFSel, i);
+       }
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/chip_18xx_43xx.c ./lpc_chip_43xx/src/chip_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/chip_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/chip_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,117 @@
+/*
+ * @brief LPC18xx/LPC43xx chip driver source
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+/* USB PLL pre-initialized setup values for 480MHz output rate */
+static const CGU_USBAUDIO_PLL_SETUP_T usbPLLSetup = {
+   0x0000601D, /* Default control with main osc input, PLL disabled */
+   0x06167FFA, /* M-divider value for 480MHz output from 12MHz input */
+   0x00000000, /* N-divider value */
+   0x00000000, /* Not applicable for USB PLL */
+   480000000   /* PLL output frequency */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+/* System Clock Frequency (Core Clock) */
+uint32_t SystemCoreClock;
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+static void Chip_USB_PllSetup(void)
+{
+   /* No need to setup anything if PLL is already setup for the frequency */
+   if (Chip_Clock_GetClockInputHz(CLKIN_USBPLL) == usbPLLSetup.freq)
+       return ;
+
+   /* Setup default USB PLL state for a 480MHz output and attach */
+   Chip_Clock_SetupPLL(CLKIN_CRYSTAL, CGU_USB_PLL, &usbPLLSetup);
+
+   /* enable USB PLL */
+   Chip_Clock_EnablePLL(CGU_USB_PLL);
+
+   /* Wait for PLL lock */
+   while (!(Chip_Clock_GetPLLStatus(CGU_USB_PLL) & CGU_PLL_LOCKED)) {}
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+void Chip_USB0_Init(void)
+{
+   /* Set up USB PLL */
+   Chip_USB_PllSetup();
+
+   /* Setup USB0 base clock as clock out from USB PLL */
+   Chip_Clock_SetBaseClock( CLK_BASE_USB0, CLKIN_USBPLL, true, true);
+
+   /* enable USB main clock */
+   Chip_Clock_EnableBaseClock(CLK_BASE_USB0);
+   Chip_Clock_EnableOpts(CLK_MX_USB0, true, true, 1);
+   /* enable USB0 phy */
+   Chip_CREG_EnableUSB0Phy();
+}
+
+void Chip_USB1_Init(void)
+{
+   /* Setup and enable the PLL */
+   Chip_USB_PllSetup();
+
+   /* USB1 needs a 60MHz clock. To get it, a divider of 4 and then 2 are
+      chained to make a divide by 8 function. Connect the output of
+      divider D to the USB1 base clock. */
+   Chip_Clock_SetDivider(CLK_IDIV_A, CLKIN_USBPLL, 4);
+   Chip_Clock_SetDivider(CLK_IDIV_D, CLKIN_IDIVA, 2);
+   Chip_Clock_SetBaseClock(CLK_BASE_USB1, CLKIN_IDIVD, true, true);
+
+   /* enable USB main clock */
+   Chip_Clock_EnableBaseClock(CLK_BASE_USB1);
+   Chip_Clock_EnableOpts(CLK_MX_USB1, true, true, 1);
+   /* enable USB1_DP and USB1_DN on chip FS phy.*/
+   LPC_SCU->SFSUSB = 0x12;
+}
+
+
+/* Update system core clock rate, should be called if the system has
+   a clock rate change */
+void SystemCoreClockUpdate(void)
+{
+   /* CPU core speed */
+   SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/clock_18xx_43xx.c ./lpc_chip_43xx/src/clock_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/clock_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/clock_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,823 @@
+/*
+ * @brief LPC18xx/43xx clock driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Maps a peripheral clock to it's base clock */
+typedef struct {
+   CHIP_CCU_CLK_T clkstart;
+   CHIP_CCU_CLK_T clkend;
+   CHIP_CGU_BASE_CLK_T clkbase;
+} CLK_PERIPH_TO_BASE_T;
+static const CLK_PERIPH_TO_BASE_T periph_to_base[] = {
+   {CLK_APB3_BUS, CLK_APB3_CAN0, CLK_BASE_APB3},
+   {CLK_APB1_BUS, CLK_APB1_CAN1, CLK_BASE_APB1},
+   {CLK_SPIFI, CLK_SPIFI, CLK_BASE_SPIFI},
+   {CLK_MX_BUS, CLK_MX_QEI, CLK_BASE_MX},
+#if defined(CHIP_LPC43XX)
+   {CLK_PERIPH_BUS, CLK_PERIPH_SGPIO, CLK_BASE_PERIPH},
+#endif
+   {CLK_USB0, CLK_USB0, CLK_BASE_USB0},
+   {CLK_USB1, CLK_USB1, CLK_BASE_USB1},
+#if defined(CHIP_LPC43XX)
+   {CLK_SPI, CLK_SPI, CLK_BASE_SPI},
+   {CLK_ADCHS, CLK_ADCHS, CLK_BASE_ADCHS},
+#endif
+   {CLK_APLL, CLK_APLL, CLK_BASE_APLL},
+   {CLK_APB2_UART3, CLK_APB2_UART3, CLK_BASE_UART3},
+   {CLK_APB2_UART2, CLK_APB2_UART2, CLK_BASE_UART2},
+   {CLK_APB0_UART1, CLK_APB0_UART1, CLK_BASE_UART1},
+   {CLK_APB0_UART0, CLK_APB0_UART0, CLK_BASE_UART0},
+   {CLK_APB2_SSP1, CLK_APB2_SSP1, CLK_BASE_SSP1},
+   {CLK_APB0_SSP0, CLK_APB0_SSP0, CLK_BASE_SSP0},
+   {CLK_APB2_SDIO, CLK_APB2_SDIO, CLK_BASE_SDIO},
+   {CLK_CCU2_LAST, CLK_CCU2_LAST, CLK_BASE_NONE}
+};
+
+#define CRYSTAL_32K_FREQ_IN    (32 * 1024)
+
+/* Variables to use audio and usb pll frequency */
+static uint32_t audio_usb_pll_freq[CGU_AUDIO_PLL+1];
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+__STATIC_INLINE uint32_t ABS(int val)
+{
+   if (val < 0)
+       return -val;
+   return val;
+}
+
+static void pll_calc_divs(uint32_t freq, PLL_PARAM_T *ppll)
+{
+
+   uint32_t prev = freq;
+   int n, m, p;
+
+   /* When direct mode is set FBSEL should be a don't care */
+   if (ppll->ctrl & (1 << 7)) {
+       ppll->ctrl &= ~(1 << 6);
+   }
+   for (n = 1; n <= 4; n++) {
+       for (p = 0; p < 4; p ++) {
+           for (m = 1; m <= 256; m++) {
+               uint32_t fcco, fout;
+               if (ppll->ctrl & (1 << 6)) {
+                   fcco = ((m << (p + 1)) * ppll->fin) / n;
+               } else {
+                   fcco = (m * ppll->fin) / n;
+               }
+               if (fcco < PLL_MIN_CCO_FREQ) continue;
+               if (fcco > PLL_MAX_CCO_FREQ) break;
+               if (ppll->ctrl & (1 << 7)) {
+                   fout = fcco;
+               } else {
+                   fout = fcco >> (p + 1);
+               }
+
+               if (ABS(freq - fout) < prev) {
+                   ppll->nsel = n;
+                   ppll->psel = p + 1;
+                   ppll->msel = m;
+                   ppll->fout = fout;
+                   ppll->fcco = fcco;
+                   prev = ABS(freq - fout);
+               }
+           }
+       }
+   }
+}
+
+static void pll_get_frac(uint32_t freq, PLL_PARAM_T *ppll)
+{
+   int diff[3];
+   PLL_PARAM_T pll[3] = {{0},{0},{0}};
+
+   /* Try direct mode */
+   pll[0].ctrl |= (1 << 7);
+   pll[0].fin = ppll->fin;
+   pll[0].srcin = ppll->srcin;
+   pll_calc_divs(freq, &pll[0]);
+   if (pll[0].fout == freq) {
+       *ppll = pll[0];
+       return ;
+   }
+   diff[0] = ABS(freq - pll[0].fout);
+
+   /* Try non-Integer mode */
+   pll[2].ctrl = (1 << 6);
+   pll[2].fin = ppll->fin;
+   pll[2].srcin = ppll->srcin;
+   pll_calc_divs(freq, &pll[2]);
+   if (pll[2].fout == freq) {
+       *ppll = pll[2];
+       return ;
+   }
+
+   diff[2] = ABS(freq - pll[2].fout);
+   /* Try integer mode */
+   pll[1].ctrl = (1 << 6);
+   pll[1].fin = ppll->fin;
+   pll[1].srcin = ppll->srcin;
+   pll_calc_divs(freq, &pll[1]);
+   if (pll[1].fout == freq) {
+       *ppll = pll[1];
+       return ;
+   }
+   diff[1] = ABS(freq - pll[1].fout);
+
+   /* Find the min of 3 and return */
+   if (diff[0] <= diff[1]) {
+       if (diff[0] <= diff[2]) {
+           *ppll = pll[0];
+       } else {
+           *ppll = pll[2];
+       }
+   } else {
+       if (diff[1] <= diff[2]) {
+           *ppll = pll[1];
+       } else {
+           *ppll = pll[2];
+       }
+   }
+}
+
+/* Test PLL input values for a specific frequency range */
+static uint32_t Chip_Clock_TestMainPLLMultiplier(uint32_t InputHz, uint32_t TestMult, uint32_t MinHz, uint32_t MaxHz)
+{
+   uint32_t TestHz = TestMult * InputHz;
+
+   if ((TestHz < MinHz) || (TestHz > MAX_CLOCK_FREQ) || (TestHz > MaxHz)) {
+       TestHz = 0;
+   }
+
+   return TestHz;
+}
+
+/* Returns clock rate out of a divider */
+static uint32_t Chip_Clock_GetDivRate(CHIP_CGU_CLKIN_T clock, CHIP_CGU_IDIV_T divider)
+{
+   CHIP_CGU_CLKIN_T input;
+   uint32_t div;
+
+   input = Chip_Clock_GetDividerSource(divider);
+   div = Chip_Clock_GetDividerDivisor(divider);
+   return Chip_Clock_GetClockInputHz(input) / (div + 1);
+}
+
+/* Finds the base clock for the peripheral clock */
+static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
+{
+   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
+   int i = 0;
+
+   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
+       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
+           baseclk = periph_to_base[i].clkbase;
+       }
+       else {
+           i++;
+       }
+   }
+
+   return baseclk;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Enables the crystal oscillator */
+void Chip_Clock_EnableCrystal(void)
+{
+   volatile uint32_t delay = 1000;
+
+   uint32_t OldCrystalConfig = LPC_CGU->XTAL_OSC_CTRL;
+
+   /* Clear bypass mode */
+   OldCrystalConfig &= (~2);
+   if (OldCrystalConfig != LPC_CGU->XTAL_OSC_CTRL) {
+       LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
+   }
+
+   /* Enable crystal oscillator */
+   OldCrystalConfig &= (~1);
+   if (OscRateIn >= 20000000) {
+       OldCrystalConfig |= 4;  /* Set high frequency mode */
+
+   }
+   LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
+
+   /* Delay for 250uSec */
+   while(delay--) {}
+}
+
+/* Calculate the Main PLL div values */
+int Chip_Clock_CalcMainPLLValue(uint32_t freq, PLL_PARAM_T *ppll)
+{
+   ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);
+
+   /* Do sanity check on frequency */
+   if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
+       return -1;
+   }
+
+   ppll->ctrl = 1 << 7; /* Enable direct mode [If possible] */
+   ppll->nsel = 0;
+   ppll->psel = 0;
+   ppll->msel = freq / ppll->fin;
+
+   if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
+       pll_get_frac(freq, ppll);
+       if (!ppll->nsel) {
+           return -1;
+       }
+       ppll->nsel --;
+   }
+
+   if (ppll->msel == 0) {
+       return - 1;
+   }
+
+   if (ppll->psel) {
+       ppll->psel --;
+   }
+
+   ppll->msel --;
+
+   return 0;
+}
+
+/* Disables the crystal oscillator */
+void Chip_Clock_DisableCrystal(void)
+{
+   /* Disable crystal oscillator */
+   LPC_CGU->XTAL_OSC_CTRL |= 1;
+}
+
+/* Configures the main PLL */
+uint32_t Chip_Clock_SetupMainPLLHz(CHIP_CGU_CLKIN_T Input, uint32_t MinHz, uint32_t DesiredHz, uint32_t MaxHz)
+{
+   uint32_t freqin = Chip_Clock_GetClockInputHz(Input);
+   uint32_t Mult, LastMult, MultEnd;
+   uint32_t freqout, freqout2;
+
+   if (DesiredHz != 0xFFFFFFFF) {
+       /* Test DesiredHz rounded down */
+       Mult = DesiredHz / freqin;
+       freqout = Chip_Clock_TestMainPLLMultiplier(freqin, Mult, MinHz, MaxHz);
+
+       /* Test DesiredHz rounded up */
+       Mult++;
+       freqout2 = Chip_Clock_TestMainPLLMultiplier(freqin, Mult, MinHz, MaxHz);
+
+       if (freqout && !freqout2) { /* rounding up is no good? set first multiplier */
+           Mult--;
+           return Chip_Clock_SetupMainPLLMult(Input, Mult);
+       }
+       if (!freqout && freqout2) { /* didn't work until rounded up? set 2nd multiplier */
+           return Chip_Clock_SetupMainPLLMult(Input, Mult);
+       }
+
+       if (freqout && freqout2) {  /* either multiplier okay? choose closer one */
+           if ((DesiredHz - freqout) > (freqout2 - DesiredHz)) {
+               Mult--;
+               return Chip_Clock_SetupMainPLLMult(Input, Mult);
+           }
+           else {
+               return Chip_Clock_SetupMainPLLMult(Input, Mult);
+           }
+       }
+   }
+
+   /* Neither multiplier okay? Try to start at MinHz and increment.
+      This should find the highest multiplier that is still good */
+   Mult = MinHz / freqin;
+   MultEnd = MaxHz / freqin;
+   LastMult = 0;
+   while (1) {
+       freqout = Chip_Clock_TestMainPLLMultiplier(freqin, Mult, MinHz, MaxHz);
+
+       if (freqout) {
+           LastMult = Mult;
+       }
+
+       if (Mult >= MultEnd) {
+           break;
+       }
+       Mult++;
+   }
+
+   if (LastMult) {
+       return Chip_Clock_SetupMainPLLMult(Input, LastMult);
+   }
+
+   return 0;
+}
+
+/* Directly set the PLL multipler */
+uint32_t Chip_Clock_SetupMainPLLMult(CHIP_CGU_CLKIN_T Input, uint32_t mult)
+{
+   volatile uint32_t delay = 250;
+   uint32_t freq = Chip_Clock_GetClockInputHz(Input);
+   uint32_t msel = 0, nsel = 0, psel = 0, pval = 1;
+   uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
+
+   freq *= mult;
+   msel = mult - 1;
+
+   PLLReg &= ~(0x1F << 24);/* clear input source bits */
+   PLLReg |= Input << 24;  /* set input source bits to parameter */
+
+   /* Clear other PLL input bits */
+   PLLReg &= ~((1 << 6) |  /* FBSEL */
+               (1 << 1) |  /* BYPASS */
+               (1 << 7) |  /* DIRECT */
+               (0x03 << 8) | (0xFF << 16) | (0x03 << 12)); /* PSEL, MSEL, NSEL- divider ratios */
+
+   if (freq < 156000000) {
+       /* psel is encoded such that 0=1, 1=2, 2=4, 3=8 */
+       while ((2 * (pval) * freq) < 156000000) {
+           psel++;
+           pval *= 2;
+       }
+
+       PLLReg |= (msel << 16) | (nsel << 12) | (psel << 8) | (1 << 6); /* dividers + FBSEL */
+   }
+   else if (freq < 320000000) {
+       PLLReg |= (msel << 16) | (nsel << 12) | (psel << 8) | (1 << 7) | (1 << 6);  /* dividers + DIRECT + FBSEL */
+   }
+   else {
+       Chip_Clock_DisableMainPLL();
+       return 0;
+   }
+   LPC_CGU->PLL1_CTRL = PLLReg & ~(1 << 0);
+
+   /* Wait for 50uSec */
+   while(delay--) {}
+
+   return freq;
+}
+
+/* Returns the frequency of the main PLL */
+uint32_t Chip_Clock_GetMainPLLHz(void)
+{
+   uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
+   uint32_t freq = Chip_Clock_GetClockInputHz((CHIP_CGU_CLKIN_T) ((PLLReg >> 24) & 0xF));
+   uint32_t msel, nsel, psel, direct, fbsel;
+   uint32_t m, n, p;
+   const uint8_t ptab[] = {1, 2, 4, 8};
+
+   /* No lock? */
+   if (!(LPC_CGU->PLL1_STAT & 1)) {
+       return 0;
+   }
+
+   msel = (PLLReg >> 16) & 0xFF;
+   nsel = (PLLReg >> 12) & 0x3;
+   psel = (PLLReg >> 8) & 0x3;
+   direct = (PLLReg >> 7) & 0x1;
+   fbsel = (PLLReg >> 6) & 0x1;
+
+   m = msel + 1;
+   n = nsel + 1;
+   p = ptab[psel];
+
+   if (direct || fbsel) {
+       return m * (freq / n);
+   }
+
+   return (m / (2 * p)) * (freq / n);
+}
+
+/* Sets up a CGU clock divider and it's input clock */
+void Chip_Clock_SetDivider(CHIP_CGU_IDIV_T Divider, CHIP_CGU_CLKIN_T Input, uint32_t Divisor)
+{
+   uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
+
+   Divisor--;
+
+   if (Input != CLKINPUT_PD) {
+       /* Mask off bits that need to changes */
+       reg &= ~((0x1F << 24) | 1 | (CHIP_CGU_IDIV_MASK(Divider) << 2));
+
+       /* Enable autoblocking, clear PD, and set clock source & divisor */
+       LPC_CGU->IDIV_CTRL[Divider] = reg | (1 << 11) | (Input << 24) | (Divisor << 2);
+   }
+   else {
+       LPC_CGU->IDIV_CTRL[Divider] = reg | 1;  /* Power down this divider */
+   }
+}
+
+/* Gets a CGU clock divider source */
+CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
+{
+   uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
+
+   if (reg & 1) {  /* divider is powered down */
+       return CLKINPUT_PD;
+   }
+
+   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
+}
+
+/* Gets a CGU clock divider divisor */
+uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider)
+{
+   return (CHIP_CGU_CLKIN_T) ((LPC_CGU->IDIV_CTRL[Divider] >> 2) & CHIP_CGU_IDIV_MASK(Divider));
+}
+
+/* Returns the frequency of the specified input clock source */
+uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
+{
+   uint32_t rate = 0;
+
+   switch (input) {
+   case CLKIN_32K:
+       rate = CRYSTAL_32K_FREQ_IN;
+       break;
+
+   case CLKIN_IRC:
+       rate = CGU_IRC_FREQ;
+       break;
+
+   case CLKIN_ENET_RX:
+       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
+           /* MII mode requires 25MHz clock */
+           rate = 25000000;
+       }
+       break;
+
+   case CLKIN_ENET_TX:
+       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
+           rate = 25000000; /* MII uses 25 MHz */
+       } else {
+           rate = 50000000; /* RMII uses 50 MHz */
+       }
+       break;
+
+   case CLKIN_CLKIN:
+       rate = ExtRateIn;
+       break;
+
+   case CLKIN_CRYSTAL:
+       rate = OscRateIn;
+       break;
+
+   case CLKIN_USBPLL:
+       rate = audio_usb_pll_freq[CGU_USB_PLL];
+       break;
+
+   case CLKIN_AUDIOPLL:
+       rate = audio_usb_pll_freq[CGU_AUDIO_PLL];
+       break;
+
+   case CLKIN_MAINPLL:
+       rate = Chip_Clock_GetMainPLLHz();
+       break;
+
+   case CLKIN_IDIVA:
+       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_A);
+       break;
+
+   case CLKIN_IDIVB:
+       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_B);
+       break;
+
+   case CLKIN_IDIVC:
+       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_C);
+       break;
+
+   case CLKIN_IDIVD:
+       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_D);
+       break;
+
+   case CLKIN_IDIVE:
+       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_E);
+       break;
+
+   case CLKINPUT_PD:
+       rate = 0;
+       break;
+
+   default:
+       break;
+   }
+
+   return rate;
+}
+
+/* Returns the frequency of the specified base clock source */
+uint32_t Chip_Clock_GetBaseClocktHz(CHIP_CGU_BASE_CLK_T clock)
+{
+   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
+}
+
+/* Sets a CGU Base Clock clock source */
+void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn)
+{
+   uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
+
+   if (BaseClock < CLK_BASE_NONE) {
+       if (Input != CLKINPUT_PD) {
+           /* Mask off fields we plan to update */
+           reg &= ~((0x1F << 24) | 1 | (1 << 11));
+
+           if (autoblocken) {
+               reg |= (1 << 11);
+           }
+           if (powerdn) {
+               reg |= (1 << 0);
+           }
+
+           /* Set clock source */
+           reg |= (Input << 24);
+
+           LPC_CGU->BASE_CLK[BaseClock] = reg;
+       }
+   }
+   else {
+       LPC_CGU->BASE_CLK[BaseClock] = reg | 1; /* Power down this base clock */
+   }
+}
+
+/* Reads CGU Base Clock clock source information */
+void Chip_Clock_GetBaseClockOpts(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T *Input, bool *autoblocken,
+                                bool *powerdn)
+{
+   uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
+   CHIP_CGU_CLKIN_T ClkIn = (CHIP_CGU_CLKIN_T) ((reg  >> 24) & 0x1F );
+
+   if (BaseClock < CLK_BASE_NONE) {
+       /* Get settings */
+       *Input = ClkIn;
+       *autoblocken = (reg & (1 << 11)) ? true : false;
+       *powerdn = (reg & (1 << 0)) ? true : false;
+   }
+   else {
+       *Input = CLKINPUT_PD;
+       *powerdn = true;
+       *autoblocken = true;
+   }
+}
+
+/*Enables a base clock source */
+void Chip_Clock_EnableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+   if (BaseClock < CLK_BASE_NONE) {
+       LPC_CGU->BASE_CLK[BaseClock] &= ~1;
+   }
+}
+
+/* Disables a base clock source */
+void Chip_Clock_DisableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+   if (BaseClock < CLK_BASE_NONE) {
+       LPC_CGU->BASE_CLK[BaseClock] |= 1;
+   }
+}
+
+/* Returns base clock enable state */
+bool Chip_Clock_IsBaseClockEnabled(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+   bool enabled;
+
+   if (BaseClock < CLK_BASE_NONE) {
+       enabled = (bool) ((LPC_CGU->BASE_CLK[BaseClock] & 1) == 0);
+   }
+   else {
+       enabled = false;
+   }
+
+   return enabled;
+}
+
+/* Gets a CGU Base Clock clock source */
+CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+   uint32_t reg;
+
+   if (BaseClock >= CLK_BASE_NONE) {
+       return CLKINPUT_PD;
+   }
+
+   reg = LPC_CGU->BASE_CLK[BaseClock];
+
+   /* base clock is powered down? */
+   if (reg & 1) {
+       return CLKINPUT_PD;
+   }
+
+   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
+}
+
+/* Enables a peripheral clock and sets clock states */
+void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
+{
+   uint32_t reg = 1;
+
+   if (autoen) {
+       reg |= (1 << 1);
+   }
+   if (wakeupen) {
+       reg |= (1 << 2);
+   }
+
+   /* Not all clocks support a divider, but we won't check that here. Only
+      dividers of 1 and 2 are allowed. Assume 1 if not 2 */
+   if (div == 2) {
+       reg |= (1 << 5);
+   }
+
+   /* Setup peripheral clock and start running */
+   if (clk >= CLK_CCU2_START) {
+       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
+   }
+   else {
+       LPC_CCU1->CLKCCU[clk].CFG = reg;
+   }
+}
+
+/* Enables a peripheral clock */
+void Chip_Clock_Enable(CHIP_CCU_CLK_T clk)
+{
+   /* Start peripheral clock running */
+   if (clk >= CLK_CCU2_START) {
+       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG |= 1;
+   }
+   else {
+       LPC_CCU1->CLKCCU[clk].CFG |= 1;
+   }
+}
+
+/* Enable RTC Clock */
+void Chip_Clock_RTCEnable(void)
+{
+   LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));  /* Reset 32Khz oscillator */
+   LPC_CREG->CREG0 |= (1 << 1) | (1 << 0); /* Enable 32 kHz & 1 kHz on osc32k and release reset */
+}
+
+/* Disables a peripheral clock */
+void Chip_Clock_Disable(CHIP_CCU_CLK_T clk)
+{
+   /* Stop peripheral clock */
+   if (clk >= CLK_CCU2_START) {
+       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG &= ~1;
+   }
+   else {
+       LPC_CCU1->CLKCCU[clk].CFG &= ~1;
+   }
+}
+
+/**
+ * Disable all branch output clocks with wake up mechanism enabled.
+ * Only the clocks with wake up mechanism enabled will be disabled &
+ * power down sequence started
+ */
+void Chip_Clock_StartPowerDown(void)
+{
+   /* Set Power Down bit */
+   LPC_CCU1->PM = 1;
+   LPC_CCU2->PM = 1;
+}
+
+/**
+ * Enable all branch output clocks after the wake up event.
+ * Only the clocks with wake up mechanism enabled will be enabled
+ */
+void Chip_Clock_ClearPowerDown(void)
+{
+   /* Clear Power Down bit */
+   LPC_CCU1->PM = 0;
+   LPC_CCU2->PM = 0;
+}
+
+/* Returns a peripheral clock rate */
+uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk)
+{
+   CHIP_CGU_BASE_CLK_T baseclk;
+   uint32_t reg, div, rate;
+
+   /* Get CCU config register for clock */
+   if (clk >= CLK_CCU2_START) {
+       reg = LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG;
+   }
+   else {
+       reg = LPC_CCU1->CLKCCU[clk].CFG;
+   }
+
+   /* Is the clock enabled? */
+   if (reg & 1) {
+       /* Get base clock for this peripheral clock */
+       baseclk = Chip_Clock_FindBaseClock(clk);
+
+       /* Get base clock rate */
+       rate = Chip_Clock_GetBaseClocktHz(baseclk);
+
+       /* Get divider for this clock */
+       if (((reg >> 5) & 0x7) == 0) {
+           div = 1;
+       }
+       else {
+           div = 2;/* No other dividers supported */
+
+       }
+       rate = rate / div;
+   }
+   else {
+       rate = 0;
+   }
+
+   return rate;
+}
+
+/* Get EMC Clock Rate */
+uint32_t Chip_Clock_GetEMCRate(void)
+
+{
+   uint32_t ClkFreq;
+   uint32_t EMCDiv;
+   ClkFreq = Chip_Clock_GetRate(CLK_MX_EMC);
+
+   /* EMC Divider readback at pos 27
+       TODO: just checked but dont mention in UM */
+   EMCDiv = (LPC_CCU1->CLKCCU[CLK_MX_EMC_DIV].CFG >> 27) & 0x07;
+
+   /* Check EMC Divider to get real EMC clock out */
+   if ((EMCDiv == 1) && (LPC_CREG->CREG6 & (1 << 16))) {
+       ClkFreq >>= 1;
+   }
+   return ClkFreq;
+}
+
+/* Sets up the audio or USB PLL */
+void Chip_Clock_SetupPLL(CHIP_CGU_CLKIN_T Input, CHIP_CGU_USB_AUDIO_PLL_T pllnum,
+                        const CGU_USBAUDIO_PLL_SETUP_T *pPLLSetup)
+{
+   uint32_t reg = pPLLSetup->ctrl | (Input << 24);
+
+   /* Setup from passed values */
+   LPC_CGU->PLL[pllnum].PLL_CTRL = reg;
+   LPC_CGU->PLL[pllnum].PLL_MDIV = pPLLSetup->mdiv;
+   LPC_CGU->PLL[pllnum].PLL_NP_DIV = pPLLSetup->ndiv;
+
+   /* Fractional divider is for audio PLL only */
+   if (pllnum == CGU_AUDIO_PLL) {
+       LPC_CGU->PLL0AUDIO_FRAC = pPLLSetup->fract;
+   }
+   audio_usb_pll_freq[pllnum] = pPLLSetup->freq;
+}
+
+/* Enables the audio or USB PLL */
+void Chip_Clock_EnablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
+{
+   LPC_CGU->PLL[pllnum].PLL_CTRL &= ~1;
+}
+
+/* Disables the audio or USB PLL */
+void Chip_Clock_DisablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
+{
+   LPC_CGU->PLL[pllnum].PLL_CTRL |= 1;
+}
+
+/* Returns the PLL status */
+uint32_t Chip_Clock_GetPLLStatus(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
+{
+   return LPC_CGU->PLL[pllnum].PLL_STAT;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/dac_18xx_43xx.c ./lpc_chip_43xx/src/dac_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/dac_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/dac_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,85 @@
+/*
+ * @brief LPC18xx/43xx D/A conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the DAC peripheral */
+void Chip_DAC_Init(LPC_DAC_T *pDAC)
+{
+   Chip_Clock_EnableOpts(CLK_APB3_DAC, true, true, 1);
+
+   /* Set maximum update rate 1MHz */
+   Chip_DAC_SetBias(pDAC, DAC_MAX_UPDATE_RATE_1MHz);
+}
+
+/* Shutdown DAC peripheral */
+void Chip_DAC_DeInit(LPC_DAC_T *pDAC)
+{
+   Chip_Clock_Disable(CLK_APB3_DAC);
+}
+
+/* Update value to DAC buffer*/
+void Chip_DAC_UpdateValue(LPC_DAC_T *pDAC, uint32_t dac_value)
+{
+   uint32_t tmp;
+
+   tmp = pDAC->CR & DAC_BIAS_EN;
+   tmp |= DAC_VALUE(dac_value);
+   /* Update value */
+   pDAC->CR = tmp;
+}
+
+/* Set Maximum update rate for DAC */
+void Chip_DAC_SetBias(LPC_DAC_T *pDAC, uint32_t bias)
+{
+   pDAC->CR &= ~DAC_BIAS_EN;
+
+   if (bias  == DAC_MAX_UPDATE_RATE_400kHz) {
+       pDAC->CR |= DAC_BIAS_EN;
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/eeprom_18xx_43xx.c ./lpc_chip_43xx/src/eeprom_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/eeprom_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/eeprom_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,100 @@
+/*
+ * @brief LPC18xx/43xx EEPROM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Setup EEPROM clock */
+STATIC void setClkDiv(LPC_EEPROM_T *pEEPROM)
+{
+   uint32_t clk;
+
+   /* Setup EEPROM timing to 375KHz based on PCLK rate */
+   clk = Chip_Clock_GetRate(CLK_MX_EEPROM);
+
+   /* Set EEPROM clock divide value*/
+   pEEPROM->CLKDIV = clk / EEPROM_CLOCK_DIV - 1;
+}
+
+/* Setup EEPROM clock */
+STATIC INLINE void setWaitState(LPC_EEPROM_T *pEEPROM)
+{
+   /* Setup EEPROM wait states*/
+   Chip_EEPROM_SetReadWaitState(pEEPROM, EEPROM_READ_WAIT_STATE_VAL);
+   Chip_EEPROM_SetWaitState(pEEPROM, EEPROM_WAIT_STATE_VAL);
+
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the EEPROM peripheral with specified parameter */
+void Chip_EEPROM_Init(LPC_EEPROM_T *pEEPROM)
+{
+   /* Disable EEPROM power down mode */
+   Chip_EEPROM_DisablePowerDown(pEEPROM);
+   setClkDiv(pEEPROM);
+   setWaitState(pEEPROM);
+}
+
+/* Write data from page register to non-volatile memory */
+void Chip_EEPROM_EraseProgramPage(LPC_EEPROM_T *pEEPROM)
+{
+   Chip_EEPROM_ClearIntStatus(pEEPROM, EEPROM_CMD_ERASE_PRG_PAGE);
+   Chip_EEPROM_SetCmd(pEEPROM, EEPROM_CMD_ERASE_PRG_PAGE);
+   Chip_EEPROM_WaitForIntStatus(pEEPROM, EEPROM_INT_ENDOFPROG);
+}
+
+/* Wait for interrupt */
+void Chip_EEPROM_WaitForIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+   uint32_t status;
+   while (1) {
+       status = Chip_EEPROM_GetIntStatus(pEEPROM);
+       if ((status & mask) == mask) {
+           break;
+       }
+   }
+   Chip_EEPROM_ClearIntStatus(pEEPROM, mask);
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/emc_18xx_43xx.c ./lpc_chip_43xx/src/emc_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/emc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/emc_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,289 @@
+/*
+ * @brief LPC18xx/43xx EMC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* DIV function with result rounded up */
+#define EMC_DIV_ROUND_UP(x, y)  ((x + y - 1) / y)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+#ifndef EMC_SUPPORT_ONLY_PL172
+/* Get ARM External Memory Controller Version */
+STATIC uint32_t getARMPeripheralID(void)
+{
+   uint32_t *RegAdd;
+   RegAdd = (uint32_t *) ((uint32_t) LPC_EMC + 0xFE0);
+   return (RegAdd[0] & 0xFF) | ((RegAdd[1] & 0xFF) << 8) |
+          ((RegAdd[2] & 0xFF) << 16) | (RegAdd[3] << 24);
+}
+
+#endif
+
+/* Calculate Clock Count from Timing Unit(nanoseconds) */
+STATIC uint32_t convertTimmingParam(uint32_t EMC_Clock, int32_t input_ns, uint32_t adjust)
+{
+   uint32_t temp;
+   if (input_ns < 0) {
+       return (-input_ns) >> 8;
+   }
+   temp = EMC_Clock / 1000000;     /* MHz calculation */
+   temp = temp * input_ns / 1000;
+
+   /* round up */
+   temp += 0xFF;
+
+   /* convert to simple integer number format */
+   temp >>= 8;
+   if (temp > adjust) {
+       return temp - adjust;
+   }
+
+   return 0;
+}
+
+/* Get Dynamic Memory Device Colum len */
+STATIC uint32_t getColsLen(uint32_t DynConfig)
+{
+   uint32_t DevBusWidth;
+   DevBusWidth = (DynConfig >> EMC_DYN_CONFIG_DEV_BUS_BIT) & 0x03;
+   if (DevBusWidth == 2) {
+       return 8;
+   }
+   else if (DevBusWidth == 1) {
+       return ((DynConfig >> (EMC_DYN_CONFIG_DEV_SIZE_BIT + 1)) & 0x03) + 8;
+   }
+   else if (DevBusWidth == 0) {
+       return ((DynConfig >> (EMC_DYN_CONFIG_DEV_SIZE_BIT + 1)) & 0x03) + 9;
+   }
+
+   return 0;
+}
+
+/* Initializes the Dynamic Controller according to the specified parameters
+   in the IP_EMC_DYN_CONFIG_T */
+void initDynMem(LPC_EMC_T *pEMC, IP_EMC_DYN_CONFIG_T *Dynamic_Config, uint32_t EMC_Clock)
+{
+   uint32_t ChipSelect, tmpclk;
+   volatile int i;
+
+   for (ChipSelect = 0; ChipSelect < 4; ChipSelect++) {
+       LPC_EMC_T *EMC_Reg_add = (LPC_EMC_T *) ((uint32_t) pEMC + (ChipSelect << 5));
+
+       EMC_Reg_add->DYNAMICRASCAS0    = Dynamic_Config->DevConfig[ChipSelect].RAS |
+                                        ((Dynamic_Config->DevConfig[ChipSelect].ModeRegister <<
+                                          (8 - EMC_DYN_MODE_CAS_BIT)) & 0xF00);
+       EMC_Reg_add->DYNAMICCONFIG0    = Dynamic_Config->DevConfig[ChipSelect].DynConfig;
+   }
+   pEMC->DYNAMICREADCONFIG = Dynamic_Config->ReadConfig;   /* Read strategy */
+
+   pEMC->DYNAMICRP         = convertTimmingParam(EMC_Clock, Dynamic_Config->tRP, 1);
+   pEMC->DYNAMICRAS        = convertTimmingParam(EMC_Clock, Dynamic_Config->tRAS, 1);
+   pEMC->DYNAMICSREX       = convertTimmingParam(EMC_Clock, Dynamic_Config->tSREX, 1);
+   pEMC->DYNAMICAPR        = convertTimmingParam(EMC_Clock, Dynamic_Config->tAPR, 1);
+   pEMC->DYNAMICDAL        = convertTimmingParam(EMC_Clock, Dynamic_Config->tDAL, 0);
+   pEMC->DYNAMICWR         = convertTimmingParam(EMC_Clock, Dynamic_Config->tWR, 1);
+   pEMC->DYNAMICRC         = convertTimmingParam(EMC_Clock, Dynamic_Config->tRC, 1);
+   pEMC->DYNAMICRFC        = convertTimmingParam(EMC_Clock, Dynamic_Config->tRFC, 1);
+   pEMC->DYNAMICXSR        = convertTimmingParam(EMC_Clock, Dynamic_Config->tXSR, 1);
+   pEMC->DYNAMICRRD        = convertTimmingParam(EMC_Clock, Dynamic_Config->tRRD, 1);
+   pEMC->DYNAMICMRD        = convertTimmingParam(EMC_Clock, Dynamic_Config->tMRD, 1);
+
+   for (i = 0; i < 1000; i++) {    /* wait 100us */
+   }
+   pEMC->DYNAMICCONTROL    = 0x00000183;   /* Issue NOP command */
+
+   for (i = 0; i < 1000; i++) {}
+   pEMC->DYNAMICCONTROL    = 0x00000103;   /* Issue PALL command */
+
+   pEMC->DYNAMICREFRESH = 2;   /* ( 2 * 16 ) -> 32 clock cycles */
+
+   for (i = 0; i < 80; i++) {}
+
+   tmpclk = EMC_DIV_ROUND_UP(convertTimmingParam(EMC_Clock, Dynamic_Config->RefreshPeriod, 0), 16);
+   pEMC->DYNAMICREFRESH    = tmpclk;
+
+   pEMC->DYNAMICCONTROL    = 0x00000083;   /* Issue MODE command */
+
+   for (ChipSelect = 0; ChipSelect < 4; ChipSelect++) {
+       /*uint32_t burst_length;*/
+       uint32_t DynAddr;
+       uint8_t Col_len;
+
+       Col_len = getColsLen(Dynamic_Config->DevConfig[ChipSelect].DynConfig);
+       /* get bus wide: if 32bit, len is 4 else if 16bit len is 2 */
+       /* burst_length = 1 << ((((Dynamic_Config->DynConfig[ChipSelect] >> 14) & 1)^1) +1); */
+       if (Dynamic_Config->DevConfig[ChipSelect].DynConfig & (1 << EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT)) {
+           /*32bit bus */
+           /*burst_length = 2;*/
+           Col_len += 2;
+       }
+       else {
+           /*burst_length = 4;*/
+           Col_len += 1;
+       }
+
+       /* Check for RBC mode */
+       if (!(Dynamic_Config->DevConfig[ChipSelect].DynConfig & EMC_DYN_CONFIG_LPSDRAM)) {
+           if (!(Dynamic_Config->DevConfig[ChipSelect].DynConfig & (0x7 << EMC_DYN_CONFIG_DEV_SIZE_BIT))) {
+               /* 2 banks => 1 bank select bit */
+               Col_len += 1;
+           }
+           else {
+               /* 4 banks => 2 bank select bits */
+               Col_len += 2;
+           }
+       }
+
+       DynAddr = Dynamic_Config->DevConfig[ChipSelect].BaseAddr;
+
+
+       if (DynAddr != 0) {
+           uint32_t temp;
+           uint32_t ModeRegister;
+           ModeRegister = Dynamic_Config->DevConfig[ChipSelect].ModeRegister;
+           temp = *((volatile uint32_t *) (DynAddr | (ModeRegister << Col_len)));
+           temp = temp;
+       }
+   }
+   pEMC->DYNAMICCONTROL    = 0x00000000;   /* Issue NORMAL command */
+
+   /* enable buffers */
+   pEMC->DYNAMICCONFIG0    |= 1 << 19;
+   pEMC->DYNAMICCONFIG1    |= 1 << 19;
+   pEMC->DYNAMICCONFIG2    |= 1 << 19;
+   pEMC->DYNAMICCONFIG3    |= 1 << 19;
+}
+
+/* Initializes the Static Controller according to the specified parameters
+ * in the IP_EMC_STATIC_CONFIG_T
+ */
+void initStaticMem(LPC_EMC_T *pEMC, IP_EMC_STATIC_CONFIG_T *Static_Config, uint32_t EMC_Clock)
+{
+   LPC_EMC_T *EMC_Reg_add = (LPC_EMC_T *) ((uint32_t) pEMC + ((Static_Config->ChipSelect) << 5));
+   EMC_Reg_add->STATICCONFIG0      = Static_Config->Config;
+   EMC_Reg_add->STATICWAITWEN0     = convertTimmingParam(EMC_Clock, Static_Config->WaitWen, 1);
+   EMC_Reg_add->STATICWAITOEN0     = convertTimmingParam(EMC_Clock, Static_Config->WaitOen, 0);
+   EMC_Reg_add->STATICWAITRD0      = convertTimmingParam(EMC_Clock, Static_Config->WaitRd, 1);
+   EMC_Reg_add->STATICWAITPAG0     = convertTimmingParam(EMC_Clock, Static_Config->WaitPage, 1);
+   EMC_Reg_add->STATICWAITWR0      = convertTimmingParam(EMC_Clock, Static_Config->WaitWr, 2);
+   EMC_Reg_add->STATICWAITTURN0    = convertTimmingParam(EMC_Clock, Static_Config->WaitTurn, 1);
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Dyanmic memory setup */
+void Chip_EMC_Dynamic_Init(IP_EMC_DYN_CONFIG_T *Dynamic_Config)
+{
+   uint32_t ClkFreq;
+
+   /* Note clocks must be enabled prior to this call */
+   ClkFreq = Chip_Clock_GetEMCRate();
+
+   initDynMem(LPC_EMC, Dynamic_Config, ClkFreq);
+}
+
+/* Enable Dynamic Memory Controller */
+void Chip_EMC_Dynamic_Enable(uint8_t Enable)
+{
+   if (Enable) {
+       LPC_EMC->DYNAMICCONTROL |= EMC_DYN_CONTROL_ENABLE;
+   }
+   else {
+       LPC_EMC->DYNAMICCONTROL &= ~EMC_DYN_CONTROL_ENABLE;
+   }
+}
+
+/* Static memory setup */
+void Chip_EMC_Static_Init(IP_EMC_STATIC_CONFIG_T *Static_Config)
+{
+   uint32_t ClkFreq;
+
+   /* Note clocks must be enabled prior to this call */
+   ClkFreq = Chip_Clock_GetEMCRate();
+
+   initStaticMem(LPC_EMC, Static_Config, ClkFreq);
+}
+
+/* Mirror CS1 to CS0 and DYCS0 */
+void Chip_EMC_Mirror(uint8_t Enable)
+{
+   if (Enable) {
+       LPC_EMC->CONTROL |= 1 << 1;
+   }
+   else {
+       LPC_EMC->CONTROL &= ~(1 << 1);
+   }
+}
+
+/* Enable EMC */
+void Chip_EMC_Enable(uint8_t Enable)
+{
+   if (Enable) {
+       LPC_EMC->CONTROL |= 1;
+   }
+   else {
+       LPC_EMC->CONTROL &= ~(1);
+   }
+}
+
+/* Set EMC LowPower Mode */
+void Chip_EMC_LowPowerMode(uint8_t Enable)
+{
+   if (Enable) {
+       LPC_EMC->CONTROL |= 1 << 2;
+   }
+   else {
+       LPC_EMC->CONTROL &= ~(1 << 2);
+   }
+}
+
+/* Initialize EMC */
+void Chip_EMC_Init(uint32_t Enable, uint32_t ClockRatio, uint32_t EndianMode)
+{
+   LPC_EMC->CONFIG    = (EndianMode ? 1 : 0) | ((ClockRatio ? 1 : 0) << 8);
+
+   /* Enable EMC 001 Normal Memory Map, No low power mode */
+   LPC_EMC->CONTROL     = (Enable ? 1 : 0);
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/enet_18xx_43xx.c ./lpc_chip_43xx/src/enet_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/enet_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/enet_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,182 @@
+/*
+ * @brief LPC18xx/43xx Ethernet driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Saved address for PHY and clock divider */
+STATIC uint32_t phyCfg;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+STATIC INLINE void reset(LPC_ENET_T *pENET)
+{
+    Chip_RGU_TriggerReset(RGU_ETHERNET_RST);
+   while (Chip_RGU_InReset(RGU_ETHERNET_RST))
+    {}
+
+   /* Reset ethernet peripheral */
+   Chip_ENET_Reset(pENET);
+}
+
+STATIC uint32_t Chip_ENET_CalcMDCClock(void)
+{
+   uint32_t val = SystemCoreClock / 1000000UL;
+
+   if (val >= 20 && val < 35)
+       return 2;
+   if (val >= 35 && val < 60)
+       return 3;
+   if (val >= 60 && val < 100)
+       return 0;
+   if (val >= 100 && val < 150)
+       return 1;
+   if (val >= 150 && val < 250)
+       return 4;
+   if (val >= 250 && val < 300)
+       return 5;
+
+   /* Code should never reach here
+      unless there is BUG in frequency settings
+   */
+   return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Basic Ethernet interface initialization */
+void Chip_ENET_Init(LPC_ENET_T *pENET, uint32_t phyAddr)
+{
+   Chip_Clock_EnableOpts(CLK_MX_ETHERNET, true, true, 1);
+
+   reset(pENET);
+
+   /* Setup MII link divider to /102 and PHY address 1 */
+   Chip_ENET_SetupMII(pENET, Chip_ENET_CalcMDCClock(), phyAddr);
+
+   /* Enhanced descriptors, burst length = 1 */
+   pENET->DMA_BUS_MODE = DMA_BM_ATDS | DMA_BM_PBL(1) | DMA_BM_RPBL(1);
+
+   /* Initial MAC configuration for checksum offload, full duplex,
+      100Mbps, disable receive own in half duplex, inter-frame gap
+      of 64-bits */
+   pENET->MAC_CONFIG = MAC_CFG_BL(0) | MAC_CFG_IPC | MAC_CFG_DM |
+                       MAC_CFG_DO | MAC_CFG_FES | MAC_CFG_PS | MAC_CFG_IFG(3);
+
+   /* Setup default filter */
+   pENET->MAC_FRAME_FILTER = MAC_FF_PR | MAC_FF_RA;
+
+   /* Flush transmit FIFO */
+   pENET->DMA_OP_MODE = DMA_OM_FTF;
+
+   /* Setup DMA to flush receive FIFOs at 32 bytes, service TX FIFOs at
+      64 bytes */
+   pENET->DMA_OP_MODE |= DMA_OM_RTC(1) | DMA_OM_TTC(0);
+
+   /* Clear all MAC interrupts */
+   pENET->DMA_STAT = DMA_ST_ALL;
+
+   /* Enable MAC interrupts */
+   pENET->DMA_INT_EN = 0;
+}
+
+/* Ethernet interface shutdown */
+void Chip_ENET_DeInit(LPC_ENET_T *pENET)
+{
+   /* Disable packet reception */
+   pENET->MAC_CONFIG = 0;
+
+   /* Flush transmit FIFO */
+   pENET->DMA_OP_MODE = DMA_OM_FTF;
+
+   /* Disable receive and transmit DMA processes */
+   pENET->DMA_OP_MODE = 0;
+
+   Chip_Clock_Disable(CLK_MX_ETHERNET);
+}
+
+/* Sets up the PHY link clock divider and PHY address */
+void Chip_ENET_SetupMII(LPC_ENET_T *pENET, uint32_t div, uint8_t addr)
+{
+   /* Save clock divider and PHY address in MII address register */
+   phyCfg = MAC_MIIA_PA(addr) | MAC_MIIA_CR(div);
+}
+
+/* Starts a PHY write via the MII */
+void Chip_ENET_StartMIIWrite(LPC_ENET_T *pENET, uint8_t reg, uint16_t data)
+{
+   /* Write value at PHY address and register */
+   pENET->MAC_MII_ADDR = phyCfg | MAC_MIIA_GR(reg) | MAC_MIIA_W;
+   pENET->MAC_MII_DATA = (uint32_t) data;
+   pENET->MAC_MII_ADDR |= MAC_MIIA_GB;
+}
+
+/*Starts a PHY read via the MII */
+void Chip_ENET_StartMIIRead(LPC_ENET_T *pENET, uint8_t reg)
+{
+   /* Read value at PHY address and register */
+   pENET->MAC_MII_ADDR = phyCfg | MAC_MIIA_GR(reg);
+   pENET->MAC_MII_ADDR |= MAC_MIIA_GB;
+}
+
+/* Sets full or half duplex for the interface */
+void Chip_ENET_SetDuplex(LPC_ENET_T *pENET, bool full)
+{
+   if (full) {
+       pENET->MAC_CONFIG |= MAC_CFG_DM;
+   }
+   else {
+       pENET->MAC_CONFIG &= ~MAC_CFG_DM;
+   }
+}
+
+/* Sets speed for the interface */
+void Chip_ENET_SetSpeed(LPC_ENET_T *pENET, bool speed100)
+{
+   if (speed100) {
+       pENET->MAC_CONFIG |= MAC_CFG_FES;
+   }
+   else {
+       pENET->MAC_CONFIG &= ~MAC_CFG_FES;
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/evrt_18xx_43xx.c ./lpc_chip_43xx/src/evrt_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/evrt_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/evrt_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,111 @@
+/*
+ * @brief LPC18xx/43xx event router driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the EVRT */
+void Chip_EVRT_Init(void)
+{
+   uint8_t i = 0;
+   // Clear all register to be default
+   LPC_EVRT->HILO      = 0x0000;
+   LPC_EVRT->EDGE      = 0x0000;
+   LPC_EVRT->CLR_EN    = 0xFFFF;
+   do {
+       i++;
+       LPC_EVRT->CLR_STAT  = 0xFFFFF;
+   } while ((LPC_EVRT->STATUS != 0) && (i < 10));
+}
+
+/* Set up the type of interrupt type for a source to EVRT */
+void Chip_EVRT_ConfigIntSrcActiveType(CHIP_EVRT_SRC_T EVRT_Src, CHIP_EVRT_SRC_ACTIVE_T type)
+{
+   switch (type) {
+   case EVRT_SRC_ACTIVE_LOW_LEVEL:
+       LPC_EVRT->HILO &= ~(1 << (uint8_t) EVRT_Src);
+       LPC_EVRT->EDGE &= ~(1 << (uint8_t) EVRT_Src);
+       break;
+
+   case EVRT_SRC_ACTIVE_HIGH_LEVEL:
+       LPC_EVRT->HILO |= (1 << (uint8_t) EVRT_Src);
+       LPC_EVRT->EDGE &= ~(1 << (uint8_t) EVRT_Src);
+       break;
+
+   case EVRT_SRC_ACTIVE_FALLING_EDGE:
+       LPC_EVRT->HILO &= ~(1 << (uint8_t) EVRT_Src);
+       LPC_EVRT->EDGE |= (1 << (uint8_t) EVRT_Src);
+       break;
+
+   case EVRT_SRC_ACTIVE_RISING_EDGE:
+       LPC_EVRT->HILO |= (1 << (uint8_t) EVRT_Src);
+       LPC_EVRT->EDGE |= (1 << (uint8_t) EVRT_Src);
+       break;
+
+   default:
+       break;
+   }
+}
+
+/* Enable or disable interrupt sources to EVRT */
+void Chip_EVRT_SetUpIntSrc(CHIP_EVRT_SRC_T EVRT_Src, FunctionalState state)
+{
+   if (state == ENABLE) {
+       LPC_EVRT->SET_EN = (1 << (uint8_t) EVRT_Src);
+   }
+   else {
+       LPC_EVRT->CLR_EN = (1 << (uint8_t) EVRT_Src);
+   }
+}
+
+/* Check if a source is sending interrupt to EVRT */
+IntStatus Chip_EVRT_IsSourceInterrupting(CHIP_EVRT_SRC_T EVRT_Src)
+{
+   if (LPC_EVRT->STATUS & (1 << (uint8_t) EVRT_Src)) {
+       return SET;
+   }
+   else {return RESET; }
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/fpu_init.c ./lpc_chip_43xx/src/fpu_init.c
--- a_qSC69Z/lpc_chip_43xx/src/fpu_init.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/fpu_init.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,97 @@
+/*
+ * @brief FPU init code
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#if defined(CORE_M4)
+
+#include "sys_config.h"
+#include "cmsis.h"
+#include "stdint.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define LPC_CPACR           0xE000ED88
+
+#define SCB_MVFR0           0xE000EF40
+#define SCB_MVFR0_RESET     0x10110021
+
+#define SCB_MVFR1           0xE000EF44
+#define SCB_MVFR1_RESET     0x11000011
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Early initialization of the FPU */
+void fpuInit(void)
+{
+#if __FPU_PRESENT != 0
+   // from arm trm manual:
+   //                ; CPACR is located at address 0xE000ED88
+   //                LDR.W R0, =0xE000ED88
+   //                ; Read CPACR
+   //                LDR R1, [R0]
+   //                ; Set bits 20-23 to enable CP10 and CP11 coprocessors
+   //                ORR R1, R1, #(0xF << 20)
+   //                ; Write back the modified value to the CPACR
+   //                STR R1, [R0]
+
+   volatile uint32_t *regCpacr = (uint32_t *) LPC_CPACR;
+   volatile uint32_t *regMvfr0 = (uint32_t *) SCB_MVFR0;
+   volatile uint32_t *regMvfr1 = (uint32_t *) SCB_MVFR1;
+   volatile uint32_t Cpacr;
+   volatile uint32_t Mvfr0;
+   volatile uint32_t Mvfr1;
+   char vfpPresent = 0;
+
+   Mvfr0 = *regMvfr0;
+   Mvfr1 = *regMvfr1;
+
+   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
+
+   if (vfpPresent) {
+       Cpacr = *regCpacr;
+       Cpacr |= (0xF << 20);
+       *regCpacr = Cpacr;  // enable CP10 and CP11 for full access
+   }
+#endif /* __FPU_PRESENT != 0 */
+}
+
+#endif /* defined(CORE_M4 */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/gpdma_18xx_43xx.c ./lpc_chip_43xx/src/gpdma_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/gpdma_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/gpdma_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,746 @@
+/*
+ * @brief LPC18xx/43xx GPDMA driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Channel array to monitor free channel */
+static DMA_ChannelHandle_t ChannelHandlerArray[GPDMA_NUMBER_CHANNELS];
+
+/* Optimized Peripheral Source and Destination burst size (18xx,43xx) */
+static const uint8_t GPDMA_LUTPerBurst[] = {
+   GPDMA_BSIZE_4,  /* MEMORY             */
+   GPDMA_BSIZE_1,  /* MAT0.0             */
+   GPDMA_BSIZE_1,  /* UART0 Tx           */
+   GPDMA_BSIZE_1,  /* MAT0.1             */
+   GPDMA_BSIZE_1,  /* UART0 Rx           */
+   GPDMA_BSIZE_1,  /* MAT1.0             */
+   GPDMA_BSIZE_1,  /* UART1 Tx           */
+   GPDMA_BSIZE_1,  /* MAT1.1             */
+   GPDMA_BSIZE_1,  /* UART1 Rx           */
+   GPDMA_BSIZE_1,  /* MAT2.0             */
+   GPDMA_BSIZE_1,  /* UART2 Tx           */
+   GPDMA_BSIZE_1,  /* MAT2.1             */
+   GPDMA_BSIZE_1,  /* UART2 Rx           */
+   GPDMA_BSIZE_1,  /* MAT3.0             */
+   GPDMA_BSIZE_1,  /* UART3 Tx           */
+   0,              /* SCT timer channel 0*/
+   GPDMA_BSIZE_1,  /* MAT3.1             */
+   GPDMA_BSIZE_1,  /* UART3 Rx           */
+   0,              /* SCT timer channel 1*/
+   GPDMA_BSIZE_4,  /* SSP0 Rx            */
+   GPDMA_BSIZE_32, /* I2S channel 0      */
+   GPDMA_BSIZE_4,  /* SSP0 Tx            */
+   GPDMA_BSIZE_32, /* I2S channel 1      */
+   GPDMA_BSIZE_4,  /* SSP1 Rx            */
+   GPDMA_BSIZE_4,  /* SSP1 Tx            */
+   GPDMA_BSIZE_4,  /* ADC 0              */
+   GPDMA_BSIZE_4,  /* ADC 1              */
+   GPDMA_BSIZE_1,  /* DAC                */
+   GPDMA_BSIZE_32, /* I2S channel 0      */
+   GPDMA_BSIZE_32  /* I2S channel 0      */
+};
+
+/* Optimized Peripheral Source and Destination transfer width (18xx,43xx) */
+static const uint8_t GPDMA_LUTPerWid[] = {
+   GPDMA_WIDTH_WORD,   /* MEMORY             */
+   GPDMA_WIDTH_WORD,   /* MAT0.0             */
+   GPDMA_WIDTH_BYTE,   /* UART0 Tx           */
+   GPDMA_WIDTH_WORD,   /* MAT0.1             */
+   GPDMA_WIDTH_BYTE,   /* UART0 Rx           */
+   GPDMA_WIDTH_WORD,   /* MAT1.0             */
+   GPDMA_WIDTH_BYTE,   /* UART1 Tx           */
+   GPDMA_WIDTH_WORD,   /* MAT1.1             */
+   GPDMA_WIDTH_BYTE,   /* UART1 Rx           */
+   GPDMA_WIDTH_WORD,   /* MAT2.0             */
+   GPDMA_WIDTH_BYTE,   /* UART2 Tx           */
+   GPDMA_WIDTH_WORD,   /* MAT2.1             */
+   GPDMA_WIDTH_BYTE,   /* UART2 Rx           */
+   GPDMA_WIDTH_WORD,   /* MAT3.0             */
+   GPDMA_WIDTH_BYTE,   /* UART3 Tx           */
+   0,                  /* SCT timer channel 0*/
+   GPDMA_WIDTH_WORD,   /* MAT3.1             */
+   GPDMA_WIDTH_BYTE,   /* UART3 Rx           */
+   0,                  /* SCT timer channel 1*/
+   GPDMA_WIDTH_BYTE,   /* SSP0 Rx            */
+   GPDMA_WIDTH_WORD,   /* I2S channel 0      */
+   GPDMA_WIDTH_BYTE,   /* SSP0 Tx            */
+   GPDMA_WIDTH_WORD,   /* I2S channel 1      */
+   GPDMA_WIDTH_BYTE,   /* SSP1 Rx            */
+   GPDMA_WIDTH_BYTE,   /* SSP1 Tx            */
+   GPDMA_WIDTH_WORD,   /* ADC 0              */
+   GPDMA_WIDTH_WORD,   /* ADC 1              */
+   GPDMA_WIDTH_WORD,   /* DAC                */
+   GPDMA_WIDTH_WORD,   /* I2S channel 0      */
+   GPDMA_WIDTH_WORD/* I2S channel 0      */
+};
+
+/* Lookup Table of Connection Type matched with (18xx,43xx) Peripheral Data (FIFO) register base address */
+volatile static const void *GPDMA_LUTPerAddr[] = {
+   NULL,                           /* MEMORY             */
+   (&LPC_TIMER0->MR),              /* MAT0.0             */
+   (&LPC_USART0-> /*RBTHDLR.*/ THR),   /* UART0 Tx           */
+   ((uint32_t *) &LPC_TIMER0->MR + 1), /* MAT0.1             */
+   (&LPC_USART0-> /*RBTHDLR.*/ RBR),   /* UART0 Rx           */
+   (&LPC_TIMER1->MR),              /* MAT1.0             */
+   (&LPC_UART1-> /*RBTHDLR.*/ THR),/* UART1 Tx           */
+   ((uint32_t *) &LPC_TIMER1->MR + 1), /* MAT1.1             */
+   (&LPC_UART1-> /*RBTHDLR.*/ RBR),/* UART1 Rx           */
+   (&LPC_TIMER2->MR),              /* MAT2.0             */
+   (&LPC_USART2-> /*RBTHDLR.*/ THR),   /* UART2 Tx           */
+   ((uint32_t *) &LPC_TIMER2->MR + 1), /* MAT2.1             */
+   (&LPC_USART2-> /*RBTHDLR.*/ RBR),   /* UART2 Rx           */
+   (&LPC_TIMER3->MR),              /* MAT3.0             */
+   (&LPC_USART3-> /*RBTHDLR.*/ THR),   /* UART3 Tx           */
+   0,                              /* SCT timer channel 0*/
+   ((uint32_t *) &LPC_TIMER3->MR + 1), /* MAT3.1             */
+   (&LPC_USART3-> /*RBTHDLR.*/ RBR),   /* UART3 Rx           */
+   0,                              /* SCT timer channel 1*/
+   (&LPC_SSP0->DR),                /* SSP0 Rx            */
+   (&LPC_I2S0->TXFIFO),            /* I2S0 Tx on channel 0 */
+   (&LPC_SSP0->DR),                /* SSP0 Tx            */
+   (&LPC_I2S0->RXFIFO),            /* I2S0 Rx on channel 1  */
+   (&LPC_SSP1->DR),                /* SSP1 Rx            */
+   (&LPC_SSP1->DR),                /* SSP1 Tx            */
+   (&LPC_ADC0->GDR),               /* ADC 0              */
+   (&LPC_ADC1->GDR),               /* ADC 1              */
+   (&LPC_DAC->CR),                 /* DAC                */
+   (&LPC_I2S1->TXFIFO),            /* I2S1 Tx on channel 0 */
+   (&LPC_I2S1->RXFIFO)             /* I2S1 Rx on channel 1 */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+/* Control which set of peripherals is connected to the DMA controller */
+STATIC uint8_t configDMAMux(uint32_t gpdma_peripheral_connection_number)
+{
+   uint8_t function, channel;
+
+   switch (gpdma_peripheral_connection_number) {
+   case GPDMA_CONN_MAT0_0:
+       function = 0;
+       channel = 1;
+       break;
+
+   case GPDMA_CONN_UART0_Tx:
+       function = 1;
+       channel = 1;
+       break;
+
+   case GPDMA_CONN_MAT0_1:
+       function = 0;
+       channel = 2;
+       break;
+
+   case GPDMA_CONN_UART0_Rx:
+       function = 1;
+       channel = 2;
+       break;
+
+   case GPDMA_CONN_MAT1_0:
+       function = 0;
+       channel = 3;
+       break;
+
+   case GPDMA_CONN_UART1_Tx:
+       function = 1;
+       channel = 3;
+       break;
+
+   case GPDMA_CONN_I2S1_Tx_Channel_0:
+       function = 2;
+       channel = 3;
+       break;
+
+   case GPDMA_CONN_MAT1_1:
+       function = 0;
+       channel = 4;
+       break;
+
+   case GPDMA_CONN_UART1_Rx:
+       function = 1;
+       channel = 4;
+       break;
+
+   case GPDMA_CONN_I2S1_Rx_Channel_1:
+       function = 2;
+       channel =  4;
+       break;
+
+   case GPDMA_CONN_MAT2_0:
+       function = 0;
+       channel = 5;
+       break;
+
+   case GPDMA_CONN_UART2_Tx:
+       function = 1;
+       channel = 5;
+       break;
+
+   case GPDMA_CONN_MAT2_1:
+       function = 0;
+       channel = 6;
+       break;
+
+   case GPDMA_CONN_UART2_Rx:
+       function = 1;
+       channel = 6;
+       break;
+
+   case GPDMA_CONN_MAT3_0:
+       function = 0;
+       channel = 7;
+       break;
+
+   case GPDMA_CONN_UART3_Tx:
+       function = 1;
+       channel = 7;
+       break;
+
+   case GPDMA_CONN_SCT_0:
+       function = 2;
+       channel = 7;
+       break;
+
+   case GPDMA_CONN_MAT3_1:
+       function = 0;
+       channel = 8;
+       break;
+
+   case GPDMA_CONN_UART3_Rx:
+       function = 1;
+       channel = 8;
+       break;
+
+   case GPDMA_CONN_SCT_1:
+       function = 2;
+       channel = 8;
+       break;
+
+   case GPDMA_CONN_SSP0_Rx:
+       function = 0;
+       channel = 9;
+       break;
+
+   case GPDMA_CONN_I2S_Tx_Channel_0:
+       function = 1;
+       channel = 9;
+       break;
+
+   case GPDMA_CONN_SSP0_Tx:
+       function = 0;
+       channel = 10;
+       break;
+
+   case GPDMA_CONN_I2S_Rx_Channel_1:
+       function = 1;
+       channel = 10;
+       break;
+
+   case GPDMA_CONN_SSP1_Rx:
+       function = 0;
+       channel = 11;
+       break;
+
+   case GPDMA_CONN_SSP1_Tx:
+       function = 0;
+       channel = 12;
+       break;
+
+   case GPDMA_CONN_ADC_0:
+       function = 0;
+       channel = 13;
+       break;
+
+   case GPDMA_CONN_ADC_1:
+       function = 0;
+       channel = 14;
+       break;
+
+   case GPDMA_CONN_DAC:
+       function = 0;
+       channel = 15;
+       break;
+
+   default:
+       function = 3;
+       channel = 15;
+       break;
+   }
+   /* Set select function to dmamux register */
+   if (0 != gpdma_peripheral_connection_number) {
+       uint32_t temp;
+       temp = LPC_CREG->DMAMUX & (~(0x03 << (2 * channel)));
+       LPC_CREG->DMAMUX = temp | (function << (2 * channel));
+   }
+   return channel;
+}
+
+uint32_t makeCtrlWord(const GPDMA_CH_CFG_T *GPDMAChannelConfig,
+                     uint32_t GPDMA_LUTPerBurstSrcConn,
+                     uint32_t GPDMA_LUTPerBurstDstConn,
+                     uint32_t GPDMA_LUTPerWidSrcConn,
+                     uint32_t GPDMA_LUTPerWidDstConn)
+{
+   uint32_t ctrl_word = 0;
+
+   switch (GPDMAChannelConfig->TransferType) {
+   /* Memory to memory */
+   case GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA:
+       ctrl_word = GPDMA_DMACCxControl_TransferSize(GPDMAChannelConfig->TransferSize)
+                   | GPDMA_DMACCxControl_SBSize((4UL))             /**< Burst size = 32 */
+                   | GPDMA_DMACCxControl_DBSize((4UL))             /**< Burst size = 32 */
+                   | GPDMA_DMACCxControl_SWidth(GPDMAChannelConfig->TransferWidth)
+                   | GPDMA_DMACCxControl_DWidth(GPDMAChannelConfig->TransferWidth)
+                   | GPDMA_DMACCxControl_SI
+                   | GPDMA_DMACCxControl_DI
+                   | GPDMA_DMACCxControl_I;
+       break;
+
+   case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA:
+   case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL:
+       ctrl_word = GPDMA_DMACCxControl_TransferSize((uint32_t) GPDMAChannelConfig->TransferSize)
+                   | GPDMA_DMACCxControl_SBSize(GPDMA_LUTPerBurstDstConn)
+                   | GPDMA_DMACCxControl_DBSize(GPDMA_LUTPerBurstDstConn)
+                   | GPDMA_DMACCxControl_SWidth(GPDMA_LUTPerWidDstConn)
+                   | GPDMA_DMACCxControl_DWidth(GPDMA_LUTPerWidDstConn)
+                   | GPDMA_DMACCxControl_DestTransUseAHBMaster1
+                   | GPDMA_DMACCxControl_SI
+                   | GPDMA_DMACCxControl_I;
+       break;
+
+   case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA:
+   case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL:
+       ctrl_word = GPDMA_DMACCxControl_TransferSize((uint32_t) GPDMAChannelConfig->TransferSize)
+                   | GPDMA_DMACCxControl_SBSize(GPDMA_LUTPerBurstSrcConn)
+                   | GPDMA_DMACCxControl_DBSize(GPDMA_LUTPerBurstSrcConn)
+                   | GPDMA_DMACCxControl_SWidth(GPDMA_LUTPerWidSrcConn)
+                   | GPDMA_DMACCxControl_DWidth(GPDMA_LUTPerWidSrcConn)
+                   | GPDMA_DMACCxControl_SrcTransUseAHBMaster1
+                   | GPDMA_DMACCxControl_DI
+                   | GPDMA_DMACCxControl_I;
+       break;
+
+   case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA:
+   case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL:
+   case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL:
+       ctrl_word = GPDMA_DMACCxControl_TransferSize((uint32_t) GPDMAChannelConfig->TransferSize)
+                   | GPDMA_DMACCxControl_SBSize(GPDMA_LUTPerBurstSrcConn)
+                   | GPDMA_DMACCxControl_DBSize(GPDMA_LUTPerBurstDstConn)
+                   | GPDMA_DMACCxControl_SWidth(GPDMA_LUTPerWidSrcConn)
+                   | GPDMA_DMACCxControl_DWidth(GPDMA_LUTPerWidDstConn)
+                   | GPDMA_DMACCxControl_SrcTransUseAHBMaster1
+                   | GPDMA_DMACCxControl_DestTransUseAHBMaster1
+                   | GPDMA_DMACCxControl_I;
+
+       break;
+
+   /* Do not support any more transfer type, return ERROR */
+   default:
+       return ERROR;
+   }
+   return ctrl_word;
+}
+
+/* Set up the DPDMA according to the specification configuration details */
+Status setupChannel(LPC_GPDMA_T *pGPDMA,
+                   GPDMA_CH_CFG_T *GPDMAChannelConfig,
+                   uint32_t CtrlWord,
+                   uint32_t LinkListItem,
+                   uint8_t SrcPeripheral,
+                   uint8_t DstPeripheral)
+{
+   GPDMA_CH_T *pDMAch;
+
+   if (pGPDMA->ENBLDCHNS & ((((1UL << (GPDMAChannelConfig->ChannelNum)) & 0xFF)))) {
+       /* This channel is enabled, return ERROR, need to release this channel first */
+       return ERROR;
+   }
+
+   /* Get Channel pointer */
+   pDMAch = (GPDMA_CH_T *) &(pGPDMA->CH[GPDMAChannelConfig->ChannelNum]);
+
+   /* Reset the Interrupt status */
+   pGPDMA->INTTCCLEAR = (((1UL << (GPDMAChannelConfig->ChannelNum)) & 0xFF));
+   pGPDMA->INTERRCLR = (((1UL << (GPDMAChannelConfig->ChannelNum)) & 0xFF));
+
+   /* Assign Linker List Item value */
+   pDMAch->LLI = LinkListItem;
+
+   /* Enable DMA channels, little endian */
+   pGPDMA->CONFIG = GPDMA_DMACConfig_E;
+   while (!(pGPDMA->CONFIG & GPDMA_DMACConfig_E)) {}
+
+   pDMAch->SRCADDR = GPDMAChannelConfig->SrcAddr;
+   pDMAch->DESTADDR = GPDMAChannelConfig->DstAddr;
+
+   /* Configure DMA Channel, enable Error Counter and Terminate counter */
+   pDMAch->CONFIG = GPDMA_DMACCxConfig_IE
+                    | GPDMA_DMACCxConfig_ITC       /*| GPDMA_DMACCxConfig_E*/
+                    | GPDMA_DMACCxConfig_TransferType((uint32_t) GPDMAChannelConfig->TransferType)
+                    | GPDMA_DMACCxConfig_SrcPeripheral(SrcPeripheral)
+                    | GPDMA_DMACCxConfig_DestPeripheral(DstPeripheral);
+
+   pDMAch->CONTROL = CtrlWord;
+
+   return SUCCESS;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the GPDMA */
+void Chip_GPDMA_Init(LPC_GPDMA_T *pGPDMA)
+{
+   uint8_t i;
+
+   Chip_Clock_EnableOpts(CLK_MX_DMA, true, true, 1);
+
+   /* Reset all channel configuration register */
+   for (i = 8; i > 0; i--) {
+       pGPDMA->CH[i - 1].CONFIG = 0;
+   }
+
+   /* Clear all DMA interrupt and error flag */
+   pGPDMA->INTTCCLEAR = 0xFF;
+   pGPDMA->INTERRCLR = 0xFF;
+
+   /* Reset all channels are free */
+   for (i = 0; i < GPDMA_NUMBER_CHANNELS; i++) {
+       ChannelHandlerArray[i].ChannelStatus = DISABLE;
+   }
+}
+
+/* Shutdown the GPDMA */
+void Chip_GPDMA_DeInit(LPC_GPDMA_T *pGPDMA)
+{
+   Chip_Clock_Disable(CLK_MX_DMA);
+}
+
+/* Stop a stream DMA transfer */
+void Chip_GPDMA_Stop(LPC_GPDMA_T *pGPDMA,
+                    uint8_t ChannelNum)
+{
+   Chip_GPDMA_ChannelCmd(pGPDMA, (ChannelNum), DISABLE);
+   if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTTC, ChannelNum)) {
+       /* Clear terminate counter Interrupt pending */
+       Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTTC, ChannelNum);
+   }
+   if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTERR, ChannelNum)) {
+       /* Clear terminate counter Interrupt pending */
+       Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTERR, ChannelNum);
+   }
+   ChannelHandlerArray[ChannelNum].ChannelStatus = DISABLE;
+}
+
+/* The GPDMA stream interrupt status checking */
+Status Chip_GPDMA_Interrupt(LPC_GPDMA_T *pGPDMA,
+                           uint8_t ChannelNum)
+{
+
+   if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INT, ChannelNum)) {
+       /* Check counter terminal status */
+       if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTTC, ChannelNum)) {
+           /* Clear terminate counter Interrupt pending */
+           Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTTC, ChannelNum);
+           return SUCCESS;
+       }
+       /* Check error terminal status */
+       if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTERR, ChannelNum)) {
+           /* Clear error counter Interrupt pending */
+
+           Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTERR, ChannelNum);
+           return ERROR;
+       }
+   }
+   return ERROR;
+}
+
+int Chip_GPDMA_InitChannelCfg(LPC_GPDMA_T *pGPDMA,
+                             GPDMA_CH_CFG_T *GPDMACfg,
+                             uint8_t  ChannelNum,
+                             uint32_t src,
+                             uint32_t dst,
+                             uint32_t Size,
+                             GPDMA_FLOW_CONTROL_T TransferType)
+{
+   int rval = -1;
+   GPDMACfg->ChannelNum = ChannelNum;
+   GPDMACfg->TransferType = TransferType;
+   GPDMACfg->TransferSize = Size;
+
+   switch (TransferType) {
+   case GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA:
+       GPDMACfg->SrcAddr = (uint32_t) src;
+       GPDMACfg->DstAddr = (uint32_t) dst;
+       rval = 3;
+       GPDMACfg->TransferWidth = GPDMA_WIDTH_WORD;
+       GPDMACfg->TransferSize = Size / 4;
+       break;
+
+   case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA:
+   case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL:
+       GPDMACfg->SrcAddr = (uint32_t) src;
+       rval = 1;
+       GPDMACfg->DstAddr = (uint32_t) GPDMA_LUTPerAddr[dst];
+       break;
+
+   case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA:
+   case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL:
+       GPDMACfg->SrcAddr = (uint32_t) GPDMA_LUTPerAddr[src];
+       GPDMACfg->DstAddr = (uint32_t) dst;
+       rval = 2;
+       break;
+
+   case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA:
+   case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL:
+   case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL:
+       GPDMACfg->SrcAddr = (uint32_t) GPDMA_LUTPerAddr[src];
+       GPDMACfg->DstAddr = (uint32_t) GPDMA_LUTPerAddr[dst];
+       rval = 0;
+       break;
+
+   default:
+       break;
+   }
+   return rval;
+}
+
+/* Read the status from different registers according to the type */
+IntStatus Chip_GPDMA_IntGetStatus(LPC_GPDMA_T *pGPDMA, GPDMA_STATUS_T type, uint8_t channel)
+{
+   /**
+    * TODO check the channel <=8 type is exited
+    */
+   switch (type) {
+   case GPDMA_STAT_INT:/* check status of DMA channel interrupts */
+       return (IntStatus) (pGPDMA->INTSTAT & (((1UL << channel) & 0xFF)));
+
+   case GPDMA_STAT_INTTC:  /* check terminal count interrupt request status for DMA */
+       return (IntStatus) (pGPDMA->INTTCSTAT & (((1UL << channel) & 0xFF)));
+
+   case GPDMA_STAT_INTERR: /* check interrupt status for DMA channels */
+       return (IntStatus) (pGPDMA->INTERRSTAT & (((1UL << channel) & 0xFF)));
+
+   case GPDMA_STAT_RAWINTTC:   /* check status of the terminal count interrupt for DMA channels */
+       return (IntStatus) (pGPDMA->RAWINTTCSTAT & (((1UL << channel) & 0xFF)));
+
+   case GPDMA_STAT_RAWINTERR:  /* check status of the error interrupt for DMA channels */
+       return (IntStatus) (pGPDMA->RAWINTERRSTAT & (((1UL << channel) & 0xFF)));
+
+   default:/* check enable status for DMA channels */
+       return (IntStatus) (pGPDMA->ENBLDCHNS & (((1UL << channel) & 0xFF)));
+   }
+}
+
+/* Clear the Interrupt Flag from different registers according to the type */
+void Chip_GPDMA_ClearIntPending(LPC_GPDMA_T *pGPDMA, GPDMA_STATECLEAR_T type, uint8_t channel)
+{
+   if (type == GPDMA_STATCLR_INTTC) {
+       /* clears the terminal count interrupt request on DMA channel */
+       pGPDMA->INTTCCLEAR = (((1UL << (channel)) & 0xFF));
+   }
+   else {
+       /* clear the error interrupt request */
+       pGPDMA->INTERRCLR = (((1UL << (channel)) & 0xFF));
+   }
+}
+
+/* Enable or Disable the GPDMA Channel */
+void Chip_GPDMA_ChannelCmd(LPC_GPDMA_T *pGPDMA, uint8_t channelNum, FunctionalState NewState)
+{
+   GPDMA_CH_T *pDMAch;
+
+   /* Get Channel pointer */
+   pDMAch = (GPDMA_CH_T *) &(pGPDMA->CH[channelNum]);
+
+   if (NewState == ENABLE) {
+       pDMAch->CONFIG |= GPDMA_DMACCxConfig_E;
+   }
+   else {
+       pDMAch->CONFIG &= ~GPDMA_DMACCxConfig_E;
+   }
+}
+
+/* Do a DMA transfer M2M, M2P,P2M or P2P */
+Status Chip_GPDMA_Transfer(LPC_GPDMA_T *pGPDMA,
+                          uint8_t ChannelNum,
+                          uint32_t src,
+                          uint32_t dst,
+                          GPDMA_FLOW_CONTROL_T TransferType,
+                          uint32_t Size)
+{
+   GPDMA_CH_CFG_T GPDMACfg;
+   uint8_t SrcPeripheral = 0, DstPeripheral = 0;
+   uint32_t cwrd;
+   int ret;
+
+   ret = Chip_GPDMA_InitChannelCfg(pGPDMA, &GPDMACfg, ChannelNum, src, dst, Size, TransferType);
+   if (ret < 0) {
+       return ERROR;
+   }
+
+   /* Adjust src/dst index if they are memory */
+   if (ret & 1) {
+       src = 0;
+   }
+   else {
+       SrcPeripheral = configDMAMux(src);
+   }
+
+   if (ret & 2) {
+       dst = 0;
+   }
+   else {
+       DstPeripheral = configDMAMux(dst);
+   }
+
+   cwrd = makeCtrlWord(&GPDMACfg,
+                       (uint32_t) GPDMA_LUTPerBurst[src],
+                       (uint32_t) GPDMA_LUTPerBurst[dst],
+                       (uint32_t) GPDMA_LUTPerWid[src],
+                       (uint32_t) GPDMA_LUTPerWid[dst]);
+   if (setupChannel(pGPDMA, &GPDMACfg, cwrd, 0, SrcPeripheral, DstPeripheral) == ERROR) {
+       return ERROR;
+   }
+
+   /* Start the Channel */
+   Chip_GPDMA_ChannelCmd(pGPDMA, ChannelNum, ENABLE);
+   return SUCCESS;
+}
+
+Status Chip_GPDMA_PrepareDescriptor(LPC_GPDMA_T *pGPDMA,
+                                   DMA_TransferDescriptor_t *DMADescriptor,
+                                   uint32_t src,
+                                   uint32_t dst,
+                                   uint32_t Size,
+                                   GPDMA_FLOW_CONTROL_T TransferType,
+                                   const DMA_TransferDescriptor_t *NextDescriptor)
+{
+   int ret;
+   GPDMA_CH_CFG_T GPDMACfg;
+
+   ret = Chip_GPDMA_InitChannelCfg(pGPDMA, &GPDMACfg, 0, src, dst, Size, TransferType);
+   if (ret < 0) {
+       return ERROR;
+   }
+
+   /* Adjust src/dst index if they are memory */
+   if (ret & 1) {
+       src = 0;
+   }
+
+   if (ret & 2) {
+       dst = 0;
+   }
+
+   DMADescriptor->src  = GPDMACfg.SrcAddr;
+   DMADescriptor->dst  = GPDMACfg.DstAddr;
+   DMADescriptor->lli  = (uint32_t) NextDescriptor;
+   DMADescriptor->ctrl = makeCtrlWord(&GPDMACfg,
+                                      (uint32_t) GPDMA_LUTPerBurst[src],
+                                      (uint32_t) GPDMA_LUTPerBurst[dst],
+                                      (uint32_t) GPDMA_LUTPerWid[src],
+                                      (uint32_t) GPDMA_LUTPerWid[dst]);
+
+   /* By default set interrupt only for last transfer */
+   if (NextDescriptor) {
+       DMADescriptor->ctrl &= ~GPDMA_DMACCxControl_I;
+   }
+
+   return SUCCESS;
+}
+
+/* Do a DMA scatter-gather transfer M2M, M2P,P2M or P2P using DMA descriptors */
+Status Chip_GPDMA_SGTransfer(LPC_GPDMA_T *pGPDMA,
+                            uint8_t ChannelNum,
+                            const DMA_TransferDescriptor_t *DMADescriptor,
+                            GPDMA_FLOW_CONTROL_T TransferType)
+{
+   const DMA_TransferDescriptor_t *dsc = DMADescriptor;
+   GPDMA_CH_CFG_T GPDMACfg;
+   uint8_t SrcPeripheral = 0, DstPeripheral = 0;
+   uint32_t src = DMADescriptor->src, dst = DMADescriptor->dst;
+   int ret;
+
+   ret = Chip_GPDMA_InitChannelCfg(pGPDMA, &GPDMACfg, ChannelNum, src, dst, 0, TransferType);
+   if (ret < 0) {
+       return ERROR;
+   }
+
+   /* Adjust src/dst index if they are memory */
+   if (ret & 1) {
+       src = 0;
+   }
+   else {
+       SrcPeripheral = configDMAMux(src);
+   }
+
+   if (ret & 2) {
+       dst = 0;
+   }
+   else {
+       DstPeripheral = configDMAMux(dst);
+   }
+
+   if (setupChannel(pGPDMA, &GPDMACfg, dsc->ctrl, dsc->lli, SrcPeripheral, DstPeripheral) == ERROR) {
+       return ERROR;
+   }
+
+   /* Start the Channel */
+   Chip_GPDMA_ChannelCmd(pGPDMA, ChannelNum, ENABLE);
+   return SUCCESS;
+}
+
+/* Get a free GPDMA channel for one DMA connection */
+uint8_t Chip_GPDMA_GetFreeChannel(LPC_GPDMA_T *pGPDMA,
+                                 uint32_t PeripheralConnection_ID)
+{
+   uint8_t temp = 0;
+   for (temp = 0; temp < GPDMA_NUMBER_CHANNELS; temp++) {
+       if (!Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_ENABLED_CH,
+                                    temp) && (ChannelHandlerArray[temp].ChannelStatus == DISABLE)) {
+           ChannelHandlerArray[temp].ChannelStatus = ENABLE;
+           return temp;
+       }
+   }
+   return 0;
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/gpio_18xx_43xx.c ./lpc_chip_43xx/src/gpio_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/gpio_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/gpio_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,102 @@
+/*
+ * @brief LPC18xx/43xx GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize GPIO block */
+void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
+{
+}
+
+/* De-Initialize GPIO block */
+void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO)
+{
+}
+
+/* Set a GPIO direction */
+void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit, bool setting)
+{
+   if (setting) {
+       pGPIO->DIR[port] |= 1UL << bit;
+   }
+   else {
+       pGPIO->DIR[port] &= ~(1UL << bit);
+   }
+}
+
+/* Set Direction for a GPIO port */
+void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
+{
+   if (out) {
+       pGPIO->DIR[portNum] |= bitValue;
+   }
+   else {
+       pGPIO->DIR[portNum] &= ~bitValue;
+   }
+}
+
+/* Set GPIO direction for a single GPIO pin */
+void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output)
+{
+   if (output) {
+       Chip_GPIO_SetPinDIROutput(pGPIO, port, pin);
+   }
+   else {
+       Chip_GPIO_SetPinDIRInput(pGPIO, port, pin);
+   }
+}
+
+/* Set GPIO direction for a all selected GPIO pins to an input or output */
+void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask, bool outSet)
+{
+   if (outSet) {
+       Chip_GPIO_SetPortDIROutput(pGPIO, port, pinMask);
+   }
+   else {
+       Chip_GPIO_SetPortDIRInput(pGPIO, port, pinMask);
+   }
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/gpiogroup_18xx_43xx.c ./lpc_chip_43xx/src/gpiogroup_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/gpiogroup_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/gpiogroup_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,48 @@
+/*
+ * @brief LPC18xx/43xx GPIO group driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/hsadc_18xx_43xx.c ./lpc_chip_43xx/src/hsadc_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/hsadc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/hsadc_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,178 @@
+/*
+ * @brief LPC18xx/43xx High speed ADC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* CRS and DGEC values mapped to maximum HSADC sample rates */
+typedef struct {
+   uint32_t minRate;
+   uint8_t crs;
+   uint8_t dgec;
+} CRSDCEG_T;
+static const CRSDCEG_T powerSets[] = {
+   {20000000,   0, 0x0},   /* Use 0/0 for less than 20MHz */
+   {30000000,   1, 0x0},   /* Use 1/0 for less than 30MHz */
+   {50000000,   2, 0x0},   /* Use 2/0 for less than 50MHz */
+   {65000000,   3, 0xF},   /* Use 3/F for less than 65MHz */
+   {0xFFFFFFFF, 4, 0xE},   /* Use 4/E for everything else */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the High speed ADC */
+void Chip_HSADC_Init(LPC_HSADC_T *pHSADC)
+{
+   /* Enable HSADC register clock */
+   Chip_Clock_EnableOpts(CLK_MX_ADCHS, true, true, 1);
+
+   /* Enable HSADC sample clock */
+   Chip_Clock_Enable(CLK_ADCHS);
+
+   /* Reset HSADC, will auto-clear */
+   Chip_RGU_TriggerReset(RGU_ADCHS_RST);
+}
+
+/* Shutdown ADC */
+void Chip_HSADC_DeInit(LPC_HSADC_T *pHSADC)
+{
+   /* Power down */
+   Chip_HSADC_DisablePower(pHSADC);
+
+   /* Reset HSADC and wait for clear, will auto-clear */
+   Chip_RGU_TriggerReset(RGU_ADCHS_RST);
+   while (Chip_RGU_InReset(RGU_ADCHS_RST)) {}
+
+   /* SHutdown HSADC clock after reset is complete */
+   Chip_Clock_Disable(CLK_MX_ADCHS);
+}
+
+/* Sets up HSADC FIFO trip level and packing */
+void Chip_HSADC_SetupFIFO(LPC_HSADC_T *pHSADC, uint8_t trip, bool packed)
+{
+   uint32_t val = (uint32_t) trip << 1;
+   if (packed) {
+       val |= 1;
+   }
+
+   pHSADC->FIFO_CFG = val;
+}
+
+/* Set HSADC Threshold low value */
+void Chip_HSADC_SetThrLowValue(LPC_HSADC_T *pHSADC, uint8_t thrnum, uint16_t value)
+{
+   uint32_t reg;
+
+   reg = pHSADC->THR[thrnum] & ~0xFFF;
+   pHSADC->THR[thrnum] = reg | (uint32_t) value;
+}
+
+/* Set HSADC Threshold high value */
+void Chip_HSADC_SetThrHighValue(LPC_HSADC_T *pHSADC, uint8_t thrnum, uint16_t value)
+{
+   uint32_t reg;
+
+   reg = pHSADC->THR[thrnum] & ~0xFFF0000;
+   pHSADC->THR[thrnum] = reg | (((uint32_t) value) << 16);
+}
+
+/* Setup speed for a input channel */
+void Chip_HSADC_SetSpeed(LPC_HSADC_T *pHSADC, uint8_t channel, uint8_t speed)
+{
+   uint32_t reg, shift = channel * 4;
+
+   reg = pHSADC->ADC_SPEED & ~(0xF << shift);
+   pHSADC->ADC_SPEED = reg | (speed << shift);
+}
+
+/* Setup (common) HSADC power and speed settings */
+void Chip_HSADC_SetPowerSpeed(LPC_HSADC_T *pHSADC, bool comp2)
+{
+   uint32_t rate, val, orBits;
+   int i, idx;
+
+   /* Get current clock rate for HSADC */
+   rate = Chip_HSADC_GetBaseClockRate(pHSADC);
+
+   /* Determine optimal CRS and DCEG settings based on clock rate */
+   idx = 0;
+   while (rate > powerSets[idx].minRate) {
+       idx++;
+   }
+
+   /* Add CRS selection based on clock speed */
+   orBits = powerSets[idx].crs;
+
+   /* Enable 2's complement data format? */
+   if (comp2) {
+       orBits |= (1 << 16);
+   }
+
+   /* Update DCEG settings for all channels based on current CRS */
+   for (i = 0; i < 6; i++) {
+       Chip_HSADC_SetSpeed(pHSADC, i, powerSets[idx].dgec);
+   }
+
+   /* Get current power control register value and mask off bits that
+      may change */
+   val = pHSADC->POWER_CONTROL & ~((1 << 16) | 0xF);
+
+   /* Update with new power and data format settings */
+   pHSADC->POWER_CONTROL = val | orBits;
+}
+
+/* Setup AC-DC coupling selection for a channel */
+void Chip_HSADC_SetACDCBias(LPC_HSADC_T *pHSADC, uint8_t channel,
+                           HSADC_DCBIAS_T dcInNeg, HSADC_DCBIAS_T dcInPos)
+{
+   uint32_t reg, mask, orBits;
+
+   /* Build mask and enable words for selected DCINNEG abd DCINPOS
+      fields for the selected channel */
+   mask = ((1 << 4) | (1 << 10)) << channel;
+   orBits = (((uint32_t) dcInNeg << 4) | ((uint32_t) dcInPos << 10)) << channel;
+
+   reg = pHSADC->POWER_CONTROL & ~mask;
+   pHSADC->POWER_CONTROL = reg | orBits;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/i2c_18xx_43xx.c ./lpc_chip_43xx/src/i2c_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/i2c_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/i2c_18xx_43xx.c	2018-01-19 23:55:10.988318805 -0300
@@ -0,0 +1,554 @@
+/*
+ * @brief LPC18xx/43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Control flags */
+#define I2C_CON_FLAGS (I2C_CON_AA | I2C_CON_SI | I2C_CON_STO | I2C_CON_STA)
+#define LPC_I2Cx(id)      ((i2c[id].ip))
+#define SLAVE_ACTIVE(iic) (((iic)->flags & 0xFF00) != 0)
+
+/* I2C common interface structure */
+struct i2c_interface {
+   LPC_I2C_T *ip;      /* IP base address of the I2C device */
+   CHIP_CCU_CLK_T clk; /* Clock used by I2C */
+   I2C_EVENTHANDLER_T mEvent;  /* Current active Master event handler */
+   I2C_EVENTHANDLER_T sEvent;  /* Slave transfer events */
+   I2C_XFER_T *mXfer;  /* Current active xfer pointer */
+   I2C_XFER_T *sXfer;  /* Pointer to store xfer when bus is busy */
+   uint32_t flags;     /* Flags used by I2C master and slave */
+};
+
+/* Slave interface structure */
+struct i2c_slave_interface {
+   I2C_XFER_T *xfer;
+   I2C_EVENTHANDLER_T event;
+};
+
+/* I2C interfaces */
+static struct i2c_interface i2c[I2C_NUM_INTERFACE] = {
+   {LPC_I2C0, CLK_APB1_I2C0, Chip_I2C_EventHandler, NULL, NULL, NULL, 0},
+   {LPC_I2C1, CLK_APB3_I2C1, Chip_I2C_EventHandler, NULL, NULL, NULL, 0}
+};
+
+static struct i2c_slave_interface i2c_slave[I2C_NUM_INTERFACE][I2C_SLAVE_NUM_INTERFACE];
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+STATIC INLINE void enableClk(I2C_ID_T id)
+{
+   Chip_Clock_Enable(i2c[id].clk);
+}
+
+STATIC INLINE void disableClk(I2C_ID_T id)
+{
+   Chip_Clock_Disable(i2c[id].clk);
+}
+
+/* Get the ADC Clock Rate */
+STATIC INLINE uint32_t getClkRate(I2C_ID_T id)
+{
+   return Chip_Clock_GetRate(i2c[id].clk);
+}
+
+/* Enable I2C and start master transfer */
+STATIC INLINE void startMasterXfer(LPC_I2C_T *pI2C)
+{
+   /* Reset STA, STO, SI */
+   pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA | I2C_CON_AA;
+
+   /* Enter to Master Transmitter mode */
+   pI2C->CONSET = I2C_CON_I2EN | I2C_CON_STA;
+}
+
+/* Enable I2C and enable slave transfers */
+STATIC INLINE void startSlaverXfer(LPC_I2C_T *pI2C)
+{
+   /* Reset STA, STO, SI */
+   pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA;
+
+   /* Enter to Master Transmitter mode */
+   pI2C->CONSET = I2C_CON_I2EN | I2C_CON_AA;
+}
+
+/* Check if I2C bus is free */
+STATIC INLINE int isI2CBusFree(LPC_I2C_T *pI2C)
+{
+   return !(pI2C->CONSET & I2C_CON_STO);
+}
+
+/* Get current state of the I2C peripheral */
+STATIC INLINE int getCurState(LPC_I2C_T *pI2C)
+{
+   return (int) (pI2C->STAT & I2C_STAT_CODE_BITMASK);
+}
+
+/* Check if the active state belongs to master mode*/
+STATIC INLINE int isMasterState(LPC_I2C_T *pI2C)
+{
+   return getCurState(pI2C) < 0x60;
+}
+
+/* Set OWN slave address for specific slave ID */
+STATIC void setSlaveAddr(LPC_I2C_T *pI2C, I2C_SLAVE_ID sid, uint8_t addr, uint8_t mask)
+{
+   uint32_t index = (uint32_t) sid - 1;
+   pI2C->MASK[index] = mask;
+   if (sid == I2C_SLAVE_0) {
+       pI2C->ADR0 = addr;
+   }
+   else {
+       volatile uint32_t *abase = &pI2C->ADR1;
+       abase[index - 1] = addr;
+   }
+}
+
+/* Match the slave address */
+STATIC int isSlaveAddrMatching(uint8_t addr1, uint8_t addr2, uint8_t mask)
+{
+   mask |= 1;
+   return (addr1 & ~mask) == (addr2 & ~mask);
+}
+
+/* Get the index of the active slave */
+STATIC I2C_SLAVE_ID lookupSlaveIndex(LPC_I2C_T *pI2C, uint8_t slaveAddr)
+{
+   if (!(slaveAddr >> 1)) {
+       return I2C_SLAVE_GENERAL;                   /* General call address */
+   }
+   if (isSlaveAddrMatching(pI2C->ADR0, slaveAddr, pI2C->MASK[0])) {
+       return I2C_SLAVE_0;
+   }
+   if (isSlaveAddrMatching(pI2C->ADR1, slaveAddr, pI2C->MASK[1])) {
+       return I2C_SLAVE_1;
+   }
+   if (isSlaveAddrMatching(pI2C->ADR2, slaveAddr, pI2C->MASK[2])) {
+       return I2C_SLAVE_2;
+   }
+   if (isSlaveAddrMatching(pI2C->ADR3, slaveAddr, pI2C->MASK[3])) {
+       return I2C_SLAVE_3;
+   }
+
+   /* If everything is fine the code should never come here */
+   return I2C_SLAVE_GENERAL;
+}
+
+/* Master transfer state change handler handler */
+int handleMasterXferState(LPC_I2C_T *pI2C, I2C_XFER_T  *xfer)
+{
+   uint32_t cclr = I2C_CON_FLAGS;
+
+   switch (getCurState(pI2C)) {
+   case 0x08:      /* Start condition on bus */
+   case 0x10:      /* Repeated start condition */
+       pI2C->DAT = (xfer->slaveAddr << 1) | (xfer->txSz == 0);
+       break;
+
+   /* Tx handling */
+   case 0x18:      /* SLA+W sent and ACK received */
+   case 0x28:      /* DATA sent and ACK received */
+       if (!xfer->txSz) {
+           cclr &= ~(xfer->rxSz ? I2C_CON_STA : I2C_CON_STO);
+       }
+       else {
+           pI2C->DAT = *xfer->txBuff++;
+           xfer->txSz--;
+       }
+       break;
+
+   /* Rx handling */
+   case 0x58:      /* Data Received and NACK sent */
+       cclr &= ~I2C_CON_STO;
+
+   case 0x50:      /* Data Received and ACK sent */
+       *xfer->rxBuff++ = pI2C->DAT;
+       xfer->rxSz--;
+
+   case 0x40:      /* SLA+R sent and ACK received */
+       if (xfer->rxSz > 1) {
+           cclr &= ~I2C_CON_AA;
+       }
+       break;
+
+   /* NAK Handling */
+   case 0x20:      /* SLA+W sent NAK received */
+   case 0x48:      /* SLA+R sent NAK received */
+       xfer->status = I2C_STATUS_SLAVENAK;
+       cclr &= ~I2C_CON_STO;
+       break;
+
+   case 0x30:      /* DATA sent NAK received */
+       xfer->status = I2C_STATUS_NAK;
+       cclr &= ~I2C_CON_STO;
+       break;
+
+   case 0x38:      /* Arbitration lost */
+       xfer->status = I2C_STATUS_ARBLOST;
+       break;
+
+   /* Bus Error */
+   case 0x00:
+       xfer->status = I2C_STATUS_BUSERR;
+       cclr &= ~I2C_CON_STO;
+   }
+
+   /* Set clear control flags */
+   pI2C->CONSET = cclr ^ I2C_CON_FLAGS;
+   pI2C->CONCLR = cclr & ~I2C_CON_STO;
+
+   /* If stopped return 0 */
+   if (!(cclr & I2C_CON_STO) || (xfer->status == I2C_STATUS_ARBLOST)) {
+       if (xfer->status == I2C_STATUS_BUSY) {
+           xfer->status = I2C_STATUS_DONE;
+       }
+       return 0;
+   }
+   return 1;
+}
+
+/* Find the slave address of SLA+W or SLA+R */
+I2C_SLAVE_ID getSlaveIndex(LPC_I2C_T *pI2C)
+{
+   switch (getCurState(pI2C)) {
+   case 0x60:
+   case 0x68:
+   case 0x70:
+   case 0x78:
+   case 0xA8:
+   case 0xB0:
+       return lookupSlaveIndex(pI2C, pI2C->DAT);
+   }
+
+   /* If everything is fine code should never come here */
+   return I2C_SLAVE_GENERAL;
+}
+
+/* Slave state machine handler */
+int handleSlaveXferState(LPC_I2C_T *pI2C, I2C_XFER_T *xfer)
+{
+   uint32_t cclr = I2C_CON_FLAGS;
+   int ret = RET_SLAVE_BUSY;
+
+   xfer->status = I2C_STATUS_BUSY;
+   switch (getCurState(pI2C)) {
+   case 0x80:      /* SLA: Data received + ACK sent */
+   case 0x90:      /* GC: Data received + ACK sent */
+       *xfer->rxBuff++ = pI2C->DAT;
+       xfer->rxSz--;
+       ret = RET_SLAVE_RX;
+       if (xfer->rxSz > 1) {
+           cclr &= ~I2C_CON_AA;
+       }
+       break;
+
+   case 0x60:      /* Own SLA+W received */
+   case 0x68:      /* Own SLA+W received after losing arbitration */
+   case 0x70:      /* GC+W received */
+   case 0x78:      /* GC+W received after losing arbitration */
+       xfer->slaveAddr = pI2C->DAT & ~1;
+       if (xfer->rxSz > 1) {
+           cclr &= ~I2C_CON_AA;
+       }
+       break;
+
+   case 0xA8:      /* SLA+R received */
+   case 0xB0:      /* SLA+R received after losing arbitration */
+       xfer->slaveAddr = pI2C->DAT & ~1;
+
+   case 0xB8:      /* DATA sent and ACK received */
+       pI2C->DAT = *xfer->txBuff++;
+       xfer->txSz--;
+       if (xfer->txSz > 0) {
+           cclr &= ~I2C_CON_AA;
+       }
+       ret = RET_SLAVE_TX;
+       break;
+
+   case 0xC0:      /* Data transmitted and NAK received */
+   case 0xC8:      /* Last data transmitted and ACK received */
+   case 0x88:      /* SLA: Data received + NAK sent */
+   case 0x98:      /* GC: Data received + NAK sent */
+   case 0xA0:      /* STOP/Repeated START condition received */
+       ret = RET_SLAVE_IDLE;
+       cclr &= ~I2C_CON_AA;
+       xfer->status = I2C_STATUS_DONE;
+       if (xfer->slaveAddr & 1) {
+           cclr &= ~I2C_CON_STA;
+       }
+       break;
+   }
+
+   /* Set clear control flags */
+   pI2C->CONSET = cclr ^ I2C_CON_FLAGS;
+   pI2C->CONCLR = cclr & ~I2C_CON_STO;
+
+   return ret;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Chip event handler interrupt based */
+void Chip_I2C_EventHandler(I2C_ID_T id, I2C_EVENT_T event)
+{
+   struct i2c_interface *iic = &i2c[id];
+   volatile I2C_STATUS_T *stat;
+
+   /* Only WAIT event needs to be handled */
+   if (event != I2C_EVENT_WAIT) {
+       return;
+   }
+
+   stat = &iic->mXfer->status;
+   /* Wait for the status to change */
+   while (*stat == I2C_STATUS_BUSY) {}
+}
+
+/* Chip polling event handler */
+void Chip_I2C_EventHandlerPolling(I2C_ID_T id, I2C_EVENT_T event)
+{
+   struct i2c_interface *iic = &i2c[id];
+   volatile I2C_STATUS_T *stat;
+
+   /* Only WAIT event needs to be handled */
+   if (event != I2C_EVENT_WAIT) {
+       return;
+   }
+
+   stat = &iic->mXfer->status;
+   /* Call the state change handler till xfer is done */
+   while (*stat == I2C_STATUS_BUSY) {
+       if (Chip_I2C_IsStateChanged(id)) {
+           Chip_I2C_MasterStateHandler(id);
+       }
+   }
+}
+
+/* Initializes the LPC_I2C peripheral with specified parameter */
+void Chip_I2C_Init(I2C_ID_T id)
+{
+   enableClk(id);
+
+   /* Set I2C operation to default */
+   LPC_I2Cx(id)->CONCLR = (I2C_CON_AA | I2C_CON_SI | I2C_CON_STA | I2C_CON_I2EN);
+}
+
+/* De-initializes the I2C peripheral registers to their default reset values */
+void Chip_I2C_DeInit(I2C_ID_T id)
+{
+   /* Disable I2C control */
+   LPC_I2Cx(id)->CONCLR = I2C_CON_I2EN | I2C_CON_SI | I2C_CON_STA | I2C_CON_AA;
+
+   disableClk(id);
+}
+
+/* Set up clock rate for LPC_I2C peripheral */
+void Chip_I2C_SetClockRate(I2C_ID_T id, uint32_t clockrate)
+{
+   uint32_t SCLValue;
+
+   SCLValue = (getClkRate(id) / clockrate);
+   LPC_I2Cx(id)->SCLH = (uint32_t) (SCLValue >> 1);
+   LPC_I2Cx(id)->SCLL = (uint32_t) (SCLValue - LPC_I2Cx(id)->SCLH);
+}
+
+/* Get current clock rate for LPC_I2C peripheral */
+uint32_t Chip_I2C_GetClockRate(I2C_ID_T id)
+{
+   return getClkRate(id) / (LPC_I2Cx(id)->SCLH + LPC_I2Cx(id)->SCLL);
+}
+
+/* Set the master event handler */
+int Chip_I2C_SetMasterEventHandler(I2C_ID_T id, I2C_EVENTHANDLER_T event)
+{
+   struct i2c_interface *iic = &i2c[id];
+   if (!iic->mXfer) {
+       iic->mEvent = event;
+   }
+   return iic->mEvent == event;
+}
+
+/* Get the master event handler */
+I2C_EVENTHANDLER_T Chip_I2C_GetMasterEventHandler(I2C_ID_T id)
+{
+   return i2c[id].mEvent;
+}
+
+/* Transmit and Receive data in master mode */
+int Chip_I2C_MasterTransfer(I2C_ID_T id, I2C_XFER_T *xfer)
+{
+   struct i2c_interface *iic = &i2c[id];
+
+   iic->mEvent(id, I2C_EVENT_LOCK);
+   xfer->status = I2C_STATUS_BUSY;
+   iic->mXfer = xfer;
+
+   /* If slave xfer not in progress */
+   if (!iic->sXfer) {
+       startMasterXfer(iic->ip);
+   }
+   iic->mEvent(id, I2C_EVENT_WAIT);
+   iic->mXfer = 0;
+
+   /* Wait for stop condition to appear on bus */
+   while (!isI2CBusFree(iic->ip)) {}
+
+   /* Start slave if one is active */
+   if (SLAVE_ACTIVE(iic)) {
+       startSlaverXfer(iic->ip);
+   }
+
+   iic->mEvent(id, I2C_EVENT_UNLOCK);
+   return (int) xfer->status;
+}
+
+/* Master tx only */
+int Chip_I2C_MasterSend(I2C_ID_T id, uint8_t slaveAddr, const uint8_t *buff, uint8_t len)
+{
+   I2C_XFER_T xfer = {0};
+   xfer.slaveAddr = slaveAddr;
+   xfer.txBuff = buff;
+   xfer.txSz = len;
+   while (Chip_I2C_MasterTransfer(id, &xfer) == I2C_STATUS_ARBLOST) {}
+   return len - xfer.txSz;
+}
+
+/* Transmit one byte and receive an array of bytes after a repeated start condition is generated in Master mode.
+ * This function is useful for communicating with the I2C slave registers
+ */
+int Chip_I2C_MasterCmdRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t cmd, uint8_t *buff, int len)
+{
+   I2C_XFER_T xfer = {0};
+   xfer.slaveAddr = slaveAddr;
+   xfer.txBuff = &cmd;
+   xfer.txSz = 1;
+   xfer.rxBuff = buff;
+   xfer.rxSz = len;
+   while (Chip_I2C_MasterTransfer(id, &xfer) == I2C_STATUS_ARBLOST) {}
+   return len - xfer.rxSz;
+}
+
+/* Sequential master read */
+int Chip_I2C_MasterRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t *buff, int len)
+{
+   I2C_XFER_T xfer = {0};
+   xfer.slaveAddr = slaveAddr;
+   xfer.rxBuff = buff;
+   xfer.rxSz = len;
+   while (Chip_I2C_MasterTransfer(id, &xfer) == I2C_STATUS_ARBLOST) {}
+   return len - xfer.rxSz;
+}
+
+/* Check if master state is active */
+int Chip_I2C_IsMasterActive(I2C_ID_T id)
+{
+   return isMasterState(i2c[id].ip);
+}
+
+/* State change handler for master transfer */
+void Chip_I2C_MasterStateHandler(I2C_ID_T id)
+{
+   if (!handleMasterXferState(i2c[id].ip, i2c[id].mXfer)) {
+       i2c[id].mEvent(id, I2C_EVENT_DONE);
+   }
+}
+
+/* Setup slave function */
+void Chip_I2C_SlaveSetup(I2C_ID_T id,
+                        I2C_SLAVE_ID sid,
+                        I2C_XFER_T *xfer,
+                        I2C_EVENTHANDLER_T event,
+                        uint8_t addrMask)
+{
+   struct i2c_interface *iic = &i2c[id];
+   struct i2c_slave_interface *si2c = &i2c_slave[id][sid];
+   si2c->xfer = xfer;
+   si2c->event = event;
+
+   /* Set up the slave address */
+   if (sid != I2C_SLAVE_GENERAL) {
+       setSlaveAddr(iic->ip, sid, xfer->slaveAddr, addrMask);
+   }
+
+   if (!SLAVE_ACTIVE(iic) && !iic->mXfer) {
+       startSlaverXfer(iic->ip);
+   }
+   iic->flags |= 1 << (sid + 8);
+}
+
+/* I2C Slave event handler */
+void Chip_I2C_SlaveStateHandler(I2C_ID_T id)
+{
+   int ret;
+   struct i2c_interface *iic = &i2c[id];
+
+   /* Get the currently addressed slave */
+   if (!iic->sXfer) {
+       struct i2c_slave_interface *si2c;
+
+       I2C_SLAVE_ID sid = getSlaveIndex(iic->ip);
+       si2c = &i2c_slave[id][sid];
+       iic->sXfer = si2c->xfer;
+       iic->sEvent = si2c->event;
+   }
+
+   iic->sXfer->slaveAddr |= iic->mXfer != 0;
+   ret = handleSlaveXferState(iic->ip, iic->sXfer);
+   if (ret) {
+       if (iic->sXfer->status == I2C_STATUS_DONE) {
+           iic->sXfer = 0;
+       }
+       iic->sEvent(id, (I2C_EVENT_T) ret);
+   }
+}
+
+/* Disable I2C device */
+void Chip_I2C_Disable(I2C_ID_T id)
+{
+   LPC_I2Cx(id)->CONCLR = I2C_I2CONCLR_I2ENC;
+}
+
+/* State change checking */
+int Chip_I2C_IsStateChanged(I2C_ID_T id)
+{
+   return (LPC_I2Cx(id)->CONSET & I2C_CON_SI) != 0;
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/i2cm_18xx_43xx.c ./lpc_chip_43xx/src/i2cm_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/i2cm_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/i2cm_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,265 @@
+/*
+ * @brief LPC18xx/43xx I2C master driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Control flags */
+#define I2C_CON_FLAGS (I2C_CON_AA | I2C_CON_SI | I2C_CON_STO | I2C_CON_STA)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+/* Get the ADC Clock Rate */
+static CHIP_CCU_CLK_T i2cm_getClkId(LPC_I2C_T *pI2C)
+{
+   return (pI2C == LPC_I2C0)? CLK_APB1_I2C0 : CLK_APB3_I2C1;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the LPC_I2C peripheral with specified parameter */
+void Chip_I2CM_Init(LPC_I2C_T *pI2C)
+{
+   /* Enable I2C clock */
+   Chip_Clock_Enable(i2cm_getClkId(pI2C));
+   /* Reset I2C state machine */
+   Chip_I2CM_ResetControl(pI2C);
+}
+
+/* De-initializes the I2C peripheral registers to their default reset values */
+void Chip_I2CM_DeInit(LPC_I2C_T *pI2C)
+{
+   /* Reset I2C state machine */
+   Chip_I2CM_ResetControl(pI2C);
+   /* Disable I2C clock */
+   Chip_Clock_Disable(i2cm_getClkId(pI2C));
+}
+
+/* Set up bus speed for LPC_I2C interface */
+void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed)
+{
+   uint32_t clockDiv = (Chip_Clock_GetRate(i2cm_getClkId(pI2C)) / busSpeed);
+
+   Chip_I2CM_SetDutyCycle(pI2C, (clockDiv >> 1), (clockDiv - (clockDiv >> 1)));
+}
+
+/* Master transfer state change handler handler */
+uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+   uint32_t cclr = I2C_CON_FLAGS;
+
+   switch (Chip_I2CM_GetCurState(pI2C)) {
+   case 0x08:      /* Start condition on bus */
+   case 0x10:      /* Repeated start condition */
+       pI2C->DAT = (xfer->slaveAddr << 1) | (xfer->txSz == 0);
+       break;
+
+   /* Tx handling */
+   case 0x20:      /* SLA+W sent NAK received */
+   case 0x30:      /* DATA sent NAK received */
+       if ((xfer->options & I2CM_XFER_OPTION_IGNORE_NACK) == 0) {
+           xfer->status = I2CM_STATUS_NAK;
+           cclr &= ~I2C_CON_STO;
+           break;
+       }
+
+   case 0x18:      /* SLA+W sent and ACK received */
+   case 0x28:      /* DATA sent and ACK received */
+       if (!xfer->txSz) {
+           if (xfer->rxSz) {
+               cclr &= ~I2C_CON_STA;
+           }
+           else {
+               xfer->status = I2CM_STATUS_OK;
+               cclr &= ~I2C_CON_STO;
+           }
+
+       }
+       else {
+           pI2C->DAT = *xfer->txBuff++;
+           xfer->txSz--;
+       }
+       break;
+
+   /* Rx handling */
+   case 0x58:      /* Data Received and NACK sent */
+   case 0x50:      /* Data Received and ACK sent */
+       *xfer->rxBuff++ = pI2C->DAT;
+       xfer->rxSz--;
+
+   case 0x40:      /* SLA+R sent and ACK received */
+       if ((xfer->rxSz > 1) || (xfer->options & I2CM_XFER_OPTION_LAST_RX_ACK)) {
+           cclr &= ~I2C_CON_AA;
+       }
+       if (xfer->rxSz == 0) {
+           xfer->status = I2CM_STATUS_OK;
+           cclr &= ~I2C_CON_STO;
+       }
+       break;
+
+   /* NAK Handling */
+   case 0x48:      /* SLA+R sent NAK received */
+       xfer->status = I2CM_STATUS_SLAVE_NAK;
+       cclr &= ~I2C_CON_STO;
+       break;
+
+   case 0x38:      /* Arbitration lost */
+       xfer->status = I2CM_STATUS_ARBLOST;
+       break;
+
+   case 0x00:      /* Bus Error */
+       xfer->status = I2CM_STATUS_BUS_ERROR;
+       cclr &= ~I2C_CON_STO;
+        break;
+    default:
+       xfer->status = I2CM_STATUS_ERROR;
+       cclr &= ~I2C_CON_STO;
+        break;
+   }
+
+   /* Set clear control flags */
+   pI2C->CONSET = cclr ^ I2C_CON_FLAGS;
+   /* Stop flag should not be cleared as it is a reserved bit */
+   pI2C->CONCLR = cclr & (I2C_CON_AA | I2C_CON_SI | I2C_CON_STA);
+
+   return xfer->status != I2CM_STATUS_BUSY;
+}
+
+/* Transmit and Receive data in master mode */
+void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+   /* set the transfer status as busy */
+   xfer->status = I2CM_STATUS_BUSY;
+   /* Clear controller state. */
+   Chip_I2CM_ResetControl(pI2C);
+   /* Enter to Master Transmitter mode */
+   Chip_I2CM_SendStart(pI2C);
+}
+
+/* Transmit and Receive data in master mode */
+uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+   uint32_t ret = 0;
+   /* start transfer */
+   Chip_I2CM_Xfer(pI2C, xfer);
+
+   while (ret == 0) {
+       /* wait for status change interrupt */
+       while ( Chip_I2CM_StateChanged(pI2C) == 0) {}
+       /* call state change handler */
+       ret = Chip_I2CM_XferHandler(pI2C, xfer);
+   }
+   return ret;
+}
+
+/* Master tx only */
+uint32_t Chip_I2CM_Write(LPC_I2C_T *pI2C, const uint8_t *buff, uint32_t len)
+{
+   uint32_t txLen = 0, err = 0;
+
+   /* clear state change interrupt status */
+   Chip_I2CM_ClearSI(pI2C);
+   /* generate START condition */
+   Chip_I2CM_SendStart(pI2C);
+
+   while ((txLen < len) && (err == 0)) {
+       /* wait for status change interrupt */
+       while ( Chip_I2CM_StateChanged(pI2C) == 0) {}
+
+       /* check status and send data */
+       switch (Chip_I2CM_GetCurState(pI2C)) {
+       case 0x08:      /* Start condition on bus */
+       case 0x10:      /* Repeated start condition */
+       case 0x18:      /* SLA+W sent and ACK received */
+       case 0x28:      /* DATA sent and ACK received */
+           Chip_I2CM_WriteByte(pI2C, buff[txLen++]);
+           break;
+
+       case 0x38:      /* Arbitration lost */
+           break;
+
+       default:        /* we shouldn't be in any other state */
+           err = 1;
+           break;
+       }
+       /* clear state change interrupt status */
+       Chip_I2CM_ClearSI(pI2C);
+   }
+
+   return txLen;
+}
+
+/* Sequential master read */
+uint32_t Chip_I2CM_Read(LPC_I2C_T *pI2C, uint8_t *buff, uint32_t len)
+{
+   uint32_t rxLen = 0, err = 0;
+
+   /* clear state change interrupt status */
+   Chip_I2CM_ClearSI(pI2C);
+   /* generate START condition and auto-ack data received */
+   pI2C->CONSET = I2C_CON_AA | I2C_CON_STA;
+
+   while ((rxLen < len) && (err == 0)) {
+       /* wait for status change interrupt */
+       while ( Chip_I2CM_StateChanged(pI2C) == 0) {}
+
+       /* check status and send data */
+       switch (Chip_I2CM_GetCurState(pI2C)) {
+       case 0x08:      /* Start condition on bus */
+       case 0x10:      /* Repeated start condition */
+       case 0x40:      /* SLA+R sent and ACK received */
+       case 0x50:      /* Data Received and ACK sent */
+           buff[rxLen++] = Chip_I2CM_ReadByte(pI2C);
+           break;
+
+       case 0x38:      /* Arbitration lost */
+           break;
+
+       default:        /* we shouldn't be in any other state */
+           err = 1;
+           break;
+       }
+       /* clear state change interrupt status */
+       Chip_I2CM_ClearSI(pI2C);
+   }
+
+   return rxLen;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/i2s_18xx_43xx.c ./lpc_chip_43xx/src/i2s_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/i2s_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/i2s_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,258 @@
+/*
+ * @brief LPC18xx/43xx I2S driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Get divider value */
+STATIC Status getClkDiv(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format, uint16_t *pxDiv, uint16_t *pyDiv, uint32_t *pN)
+{
+   uint32_t pClk;
+   uint32_t x, y;
+   uint64_t divider;
+   uint16_t dif;
+   uint16_t xDiv = 0, yDiv = 0;
+   uint32_t N;
+   uint16_t err, ErrorOptimal = 0xFFFF;
+
+   pClk = Chip_Clock_GetRate(CLK_APB1_I2S);
+
+   /* divider is a fixed point number with 16 fractional bits */
+   divider = (((uint64_t) (format->SampleRate) * 2 * (format->WordWidth) * 2) << 16) / pClk;
+   /* find N that make x/y <= 1 -> divider <= 2^16 */
+   for (N = 64; N > 0; N--) {
+       if ((divider * N) < (1 << 16)) {
+           break;
+       }
+   }
+   if (N == 0) {
+       return ERROR;
+   }
+   divider *= N;
+   for (y = 255; y > 0; y--) {
+       x = y * divider;
+       if (x & (0xFF000000)) {
+           continue;
+       }
+       dif = x & 0xFFFF;
+       if (dif > 0x8000) {
+           err = 0x10000 - dif;
+       }
+       else {
+           err = dif;
+       }
+       if (err == 0) {
+           yDiv = y;
+           break;
+       }
+       else if (err < ErrorOptimal) {
+           ErrorOptimal = err;
+           yDiv = y;
+       }
+   }
+   xDiv = ((uint64_t) yDiv * (format->SampleRate) * 2 * (format->WordWidth) * N * 2) / pClk;
+   if (xDiv >= 256) {
+       xDiv = 0xFF;
+   }
+   if (xDiv == 0) {
+       xDiv = 1;
+   }
+
+   *pxDiv = xDiv;
+   *pyDiv = yDiv;
+   *pN = N;
+   return SUCCESS;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the I2S interface */
+void Chip_I2S_Init(LPC_I2S_T *pI2S)
+{
+   Chip_Clock_Enable(CLK_APB1_I2S);
+}
+
+/* Shutdown I2S */
+void Chip_I2S_DeInit(LPC_I2S_T *pI2S)
+{
+   pI2S->DAI = 0x07E1;
+   pI2S->DAO = 0x87E1;
+   pI2S->IRQ = 0;
+   pI2S->TXMODE = 0;
+   pI2S->RXMODE = 0;
+   pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] = 0;
+   pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] = 0;
+   Chip_Clock_Disable(CLK_APB1_I2S);
+}
+
+/* Configure I2S for Audio Format input */
+Status Chip_I2S_TxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format)
+{
+   uint32_t temp;
+   uint16_t xDiv, yDiv;
+   uint32_t N;
+
+   if (getClkDiv(pI2S, format, &xDiv, &yDiv, &N) == ERROR) {
+       return ERROR;
+   }
+
+   temp = pI2S->DAO & (~(I2S_DAO_WORDWIDTH_MASK | I2S_DAO_MONO | I2S_DAO_SLAVE | I2S_DAO_WS_HALFPERIOD_MASK));
+   if (format->WordWidth <= 8) {
+       temp |= I2S_WORDWIDTH_8;
+   }
+   else if (format->WordWidth <= 16) {
+       temp |= I2S_WORDWIDTH_16;
+   }
+   else {
+       temp |= I2S_WORDWIDTH_32;
+   }
+
+   temp |= (format->ChannelNumber) == 1 ? I2S_MONO : I2S_STEREO;
+   temp |= I2S_MASTER_MODE;
+   temp |= I2S_DAO_WS_HALFPERIOD(format->WordWidth - 1);
+   pI2S->DAO = temp;
+   pI2S->TXMODE = I2S_TXMODE_CLKSEL(0);
+   pI2S->TXBITRATE = N - 1;
+   pI2S->TXRATE = yDiv | (xDiv << 8);
+   return SUCCESS;
+}
+
+/* Configure I2S for Audio Format input */
+Status Chip_I2S_RxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format)
+{
+   uint32_t temp;
+   uint16_t xDiv, yDiv;
+   uint32_t N;
+
+   if (getClkDiv(pI2S, format, &xDiv, &yDiv, &N) == ERROR) {
+       return ERROR;
+   }
+   temp = pI2S->DAI & (~(I2S_DAI_WORDWIDTH_MASK | I2S_DAI_MONO | I2S_DAI_SLAVE | I2S_DAI_WS_HALFPERIOD_MASK));
+   if (format->WordWidth <= 8) {
+       temp |= I2S_WORDWIDTH_8;
+   }
+   else if (format->WordWidth <= 16) {
+       temp |= I2S_WORDWIDTH_16;
+   }
+   else {
+       temp |= I2S_WORDWIDTH_32;
+   }
+
+   temp |= (format->ChannelNumber) == 1 ? I2S_MONO : I2S_STEREO;
+   temp |= I2S_MASTER_MODE;
+   temp |= I2S_DAI_WS_HALFPERIOD(format->WordWidth - 1);
+   pI2S->DAI = temp;
+   pI2S->RXMODE = I2S_RXMODE_CLKSEL(0);
+   pI2S->RXBITRATE = N - 1;
+   pI2S->RXRATE = yDiv | (xDiv << 8);
+   return SUCCESS;
+}
+
+/* Enable/Disable Interrupt with a specific FIFO depth */
+void Chip_I2S_Int_TxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth)
+{
+   uint32_t temp;
+   depth &= 0x0F;
+   if (newState == ENABLE) {
+       temp = pI2S->IRQ & (~I2S_IRQ_TX_DEPTH_MASK);
+       pI2S->IRQ = temp | (I2S_IRQ_TX_DEPTH(depth));
+       pI2S->IRQ |= 0x02;
+   }
+   else {
+       pI2S->IRQ &= (~0x02);
+   }
+}
+
+/* Enable/Disable Interrupt with a specific FIFO depth */
+void Chip_I2S_Int_RxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth)
+{
+   uint32_t temp;
+   depth &= 0x0F;
+   if (newState == ENABLE) {
+       temp = pI2S->IRQ & (~I2S_IRQ_RX_DEPTH_MASK);
+       pI2S->IRQ = temp | (I2S_IRQ_RX_DEPTH(depth));
+       pI2S->IRQ |= 0x01;
+   }
+   else {
+       pI2S->IRQ &= (~0x01);
+   }
+}
+
+/* Enable/Disable DMA with a specific FIFO depth */
+void Chip_I2S_DMA_TxCmd(LPC_I2S_T *pI2S,
+                       I2S_DMA_CHANNEL_T dmaNum,
+                       FunctionalState newState,
+                       uint8_t depth)
+{
+   /* Enable/Disable I2S transmit*/
+   if (newState == ENABLE) {
+       /* Set FIFO Level */
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] &= ~(0x0F << 16);
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] |= depth << 16;
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] |= 0x02;
+   }
+   else {
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] &= ~0x02;
+   }
+}
+
+/* Enable/Disable DMA with a specific FIFO depth */
+void Chip_I2S_DMA_RxCmd(LPC_I2S_T *pI2S,
+                       I2S_DMA_CHANNEL_T dmaNum,
+                       FunctionalState newState,
+                       uint8_t depth)
+{
+
+   /* Enable/Disable I2S Receive */
+   if (newState == ENABLE) {
+       /* Set FIFO Level */
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] &= ~(0x0F << 8);
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] |= depth << 8;
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] |= 0x01;
+   }
+   else {
+       pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] &= ~0x01;
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/iap_18xx_43xx.c ./lpc_chip_43xx/src/iap_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/iap_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/iap_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,191 @@
+/*
+ * @brief Common FLASH IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Prepare sector for write operation */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector, uint8_t flashBank)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_PREWRRITE_CMD;
+   command[1] = strSector;
+   command[2] = endSector;
+   command[3] = flashBank;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Copy RAM to flash */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_WRISECTOR_CMD;
+   command[1] = dstAdd;
+   command[2] = (uint32_t) srcAdd;
+   command[3] = byteswrt;
+   command[4] = SystemCoreClock / 1000;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Erase sector */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector, uint8_t flashBank)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_ERSSECTOR_CMD;
+   command[1] = strSector;
+   command[2] = endSector;
+   command[3] = SystemCoreClock / 1000;
+   command[4] = flashBank;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Blank check sector */
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector, uint8_t flashBank)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_BLANK_CHECK_SECTOR_CMD;
+   command[1] = strSector;
+   command[2] = endSector;
+   command[3] = flashBank;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Read part identification number */
+uint32_t Chip_IAP_ReadPID()
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_REPID_CMD;
+   iap_entry(command, result);
+
+   return result[1];
+}
+
+/* Read boot code version number */
+uint8_t Chip_IAP_ReadBootCode()
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_READ_BOOT_CODE_CMD;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* IAP compare */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_COMPARE_CMD;
+   command[1] = dstAdd;
+   command[2] = srcAdd;
+   command[3] = bytescmp;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Reinvoke ISP */
+uint8_t Chip_IAP_ReinvokeISP()
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_REINVOKE_ISP_CMD;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Read the unique ID */
+uint32_t Chip_IAP_ReadUID()
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_READ_UID_CMD;
+   iap_entry(command, result);
+
+   return result[1];
+}
+
+/* Erase page */
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_ERASE_PAGE_CMD;
+   command[1] = strPage;
+   command[2] = endPage;
+   command[3] = SystemCoreClock / 1000;
+   iap_entry(command, result);
+
+   return result[0];
+}
+
+/* Set active boot flash bank */
+uint8_t Chip_IAP_SetBootFlashBank(uint8_t bankNum)
+{
+    unsigned int command[5], result[4];
+
+   command[0] = IAP_SET_BOOT_FLASH;
+   command[1] = bankNum;
+   command[2] = SystemCoreClock / 1000;
+   iap_entry(command, result);
+
+   return result[0];
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/lcd_18xx_43xx.c ./lpc_chip_43xx/src/lcd_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/lcd_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/lcd_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,206 @@
+/*
+ * @brief LPC18xx/43xx LCD chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+static LCD_CURSOR_SIZE_OPT_T LCD_Cursor_Size = LCD_CURSOR_64x64;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the LCD controller */
+void Chip_LCD_Init(LPC_LCD_T *pLCD, LCD_CONFIG_T *LCD_ConfigStruct)
+{
+   uint32_t i, regValue, *pPal;
+   uint32_t pcd;
+
+   /* Enable LCD Clock */
+   Chip_Clock_EnableOpts(CLK_MX_LCD, true, true, 1);
+
+   /* disable the display */
+   pLCD->CTRL &= ~CLCDC_LCDCTRL_ENABLE;
+
+   /* Setting LCD_TIMH register */
+   regValue = ( ((((LCD_ConfigStruct->PPL / 16) - 1) & 0x3F) << 2)
+                |         (( (LCD_ConfigStruct->HSW - 1)    & 0xFF) << 8)
+                |         (( (LCD_ConfigStruct->HFP - 1)    & 0xFF) << 16)
+                |         (( (LCD_ConfigStruct->HBP - 1)    & 0xFF) << 24) );
+   pLCD->TIMH = regValue;
+
+   /* Setting LCD_TIMV register */
+   regValue = ((((LCD_ConfigStruct->LPP - 1) & 0x3FF) << 0)
+               |        (((LCD_ConfigStruct->VSW - 1) & 0x03F) << 10)
+               |        (((LCD_ConfigStruct->VFP - 1) & 0x0FF) << 16)
+               |        (((LCD_ConfigStruct->VBP - 1) & 0x0FF) << 24) );
+   pLCD->TIMV = regValue;
+
+   /* Generate the clock and signal polarity control word */
+   regValue = 0;
+   regValue = (((LCD_ConfigStruct->ACB - 1) & 0x1F) << 6);
+   regValue |= (LCD_ConfigStruct->IOE & 1) << 14;
+   regValue |= (LCD_ConfigStruct->IPC & 1) << 13;
+   regValue |= (LCD_ConfigStruct->IHS & 1) << 12;
+   regValue |= (LCD_ConfigStruct->IVS & 1) << 11;
+
+   /* Compute clocks per line based on panel type */
+   switch (LCD_ConfigStruct->LCD) {
+   case LCD_MONO_4:
+       regValue |= ((((LCD_ConfigStruct->PPL / 4) - 1) & 0x3FF) << 16);
+       break;
+
+   case LCD_MONO_8:
+       regValue |= ((((LCD_ConfigStruct->PPL / 8) - 1) & 0x3FF) << 16);
+       break;
+
+   case LCD_CSTN:
+       regValue |= (((((LCD_ConfigStruct->PPL * 3) / 8) - 1) & 0x3FF) << 16);
+       break;
+
+   case LCD_TFT:
+   default:
+       regValue |=  /*1<<26 |*/ (((LCD_ConfigStruct->PPL - 1) & 0x3FF) << 16);
+   }
+
+   /* panel clock divisor */
+   pcd = 5;// LCD_ConfigStruct->pcd;   // TODO: should be calculated from LCDDCLK
+   pcd &= 0x3FF;
+   regValue |=  ((pcd >> 5) << 27) | ((pcd) & 0x1F);
+   pLCD->POL = regValue;
+
+   /* disable interrupts */
+   pLCD->INTMSK = 0;
+
+   /* set bits per pixel */
+   regValue = LCD_ConfigStruct->BPP << 1;
+
+   /* set color format RGB */
+   regValue |= LCD_ConfigStruct->color_format << 8;
+   regValue |= LCD_ConfigStruct->LCD << 4;
+   if (LCD_ConfigStruct->Dual == 1) {
+       regValue |= 1 << 7;
+   }
+   pLCD->CTRL = regValue;
+
+   /* clear palette */
+   pPal = (uint32_t *) (&(pLCD->PAL));
+   for (i = 0; i < 128; i++) {
+       *pPal = 0;
+       pPal++;
+   }
+}
+
+/* Shutdown the LCD controller */
+void Chip_LCD_DeInit(LPC_LCD_T *pLCD)
+{
+   Chip_Clock_Disable(CLK_MX_LCD);
+}
+
+/* Configure Cursor */
+void Chip_LCD_Cursor_Config(LPC_LCD_T *pLCD, LCD_CURSOR_SIZE_OPT_T cursor_size, bool sync)
+{
+   LCD_Cursor_Size = cursor_size;
+   pLCD->CRSR_CFG = ((sync ? 1 : 0) << 1) | cursor_size;
+}
+
+/* Write Cursor Image into Internal Cursor Image Buffer */
+void Chip_LCD_Cursor_WriteImage(LPC_LCD_T *pLCD, uint8_t cursor_num, void *Image)
+{
+   int i, j;
+   uint32_t *fifoptr, *crsr_ptr = (uint32_t *) Image;
+
+   /* Check if Cursor Size was configured as 32x32 or 64x64*/
+   if (LCD_Cursor_Size == LCD_CURSOR_32x32) {
+       i = cursor_num * 64;
+       j = i + 64;
+   }
+   else {
+       i = 0;
+       j = 256;
+   }
+   fifoptr = (void *) &(pLCD->CRSR_IMG[0]);
+
+   /* Copy Cursor Image content to FIFO */
+   for (; i < j; i++) {
+
+       *fifoptr = *crsr_ptr;
+       crsr_ptr++;
+       fifoptr++;
+   }
+}
+
+/* Load LCD Palette */
+void Chip_LCD_LoadPalette(LPC_LCD_T *pLCD, void *palette)
+{
+   LCD_PALETTE_ENTRY_T pal_entry = {0};
+   uint8_t i, *pal_ptr;
+   /* This function supports loading of the color palette from
+      the C file generated by the bmp2c utility. It expects the
+      palette to be passed as an array of 32-bit BGR entries having
+      the following format:
+      2:0 - Not used
+      7:3 - Blue
+      10:8 - Not used
+      15:11 - Green
+      18:16 - Not used
+      23:19 - Red
+      31:24 - Not used
+      arg = pointer to input palette table address */
+   pal_ptr = (uint8_t *) palette;
+
+   /* 256 entry in the palette table */
+   for (i = 0; i < 256 / 2; i++) {
+       pal_entry.Bl = (*pal_ptr++) >> 3;   /* blue first */
+       pal_entry.Gl = (*pal_ptr++) >> 3;   /* get green */
+       pal_entry.Rl = (*pal_ptr++) >> 3;   /* get red */
+       pal_ptr++;  /* skip over the unused byte */
+       /* do the most significant halfword of the palette */
+       pal_entry.Bu = (*pal_ptr++) >> 3;   /* blue first */
+       pal_entry.Gu = (*pal_ptr++) >> 3;   /* get green */
+       pal_entry.Ru = (*pal_ptr++) >> 3;   /* get red */
+       pal_ptr++;  /* skip over the unused byte */
+
+       pLCD->PAL[i] = *((uint32_t *)&pal_entry);
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/otp_18xx_43xx.c ./lpc_chip_43xx/src/otp_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/otp_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/otp_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,145 @@
+/*
+ * @brief LPC18xx/43xx OTP Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define BOOTROM_BASE            0x10400100
+#define OTP_API_TABLE_OFFSET    0x1
+
+static unsigned long *BOOTROM_API_TABLE;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+static uint32_t (*Otp_ProgBootSrc)(CHIP_OTP_BOOT_SRC_T BootSrc);
+static uint32_t (*Otp_ProgJTAGDis)(void);
+static uint32_t (*Otp_ProgUSBID)(uint32_t ProductID, uint32_t VendorID);
+static uint32_t (*Otp_ProgGP0)(uint32_t Data, uint32_t Mask);
+static uint32_t (*Otp_ProgGP1)(uint32_t Data, uint32_t Mask);
+static uint32_t (*Otp_ProgGP2)(uint32_t Data, uint32_t Mask);
+static uint32_t (*Otp_ProgKey1)(uint8_t *key);
+static uint32_t (*Otp_ProgKey2)(uint8_t *key);
+static uint32_t (*Otp_GenRand)(void);
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* CHIP OTP Initialisation function */
+uint32_t Chip_OTP_Init(void)
+{
+   uint32_t (*ROM_otp_Init)(void);
+
+   BOOTROM_API_TABLE = *((unsigned long * *) BOOTROM_BASE + OTP_API_TABLE_OFFSET);
+
+   ROM_otp_Init      = (uint32_t (*)(void))BOOTROM_API_TABLE[0];
+   Otp_ProgBootSrc   = (uint32_t (*)(CHIP_OTP_BOOT_SRC_T BootSrc))BOOTROM_API_TABLE[1];
+   Otp_ProgJTAGDis   = (uint32_t (*)(void))BOOTROM_API_TABLE[2];
+   Otp_ProgUSBID     = (uint32_t (*)(uint32_t ProductID, uint32_t VendorID))BOOTROM_API_TABLE[3];
+   Otp_ProgGP0       = (uint32_t (*)(uint32_t Data, uint32_t Mask))BOOTROM_API_TABLE[8];
+   Otp_ProgGP1       = (uint32_t (*)(uint32_t Data, uint32_t Mask))BOOTROM_API_TABLE[9];
+   Otp_ProgGP2       = (uint32_t (*)(uint32_t Data, uint32_t Mask))BOOTROM_API_TABLE[10];
+   Otp_ProgKey1      = (uint32_t (*)(uint8_t *key))BOOTROM_API_TABLE[11];
+   Otp_ProgKey2      = (uint32_t (*)(uint8_t *key))BOOTROM_API_TABLE[12];
+   Otp_GenRand       = (uint32_t (*)(void))BOOTROM_API_TABLE[13];
+
+   return ROM_otp_Init();
+}
+
+/* Program boot source in OTP Controller */
+uint32_t Chip_OTP_ProgBootSrc(CHIP_OTP_BOOT_SRC_T BootSrc)
+{
+   return Otp_ProgBootSrc(BootSrc);
+}
+
+/* Program the JTAG bit in OTP Controller */
+uint32_t Chip_OTP_ProgJTAGDis(void)
+{
+   return Otp_ProgJTAGDis();
+}
+
+/* Program USB ID in OTP Controller */
+uint32_t Chip_OTP_ProgUSBID(uint32_t ProductID, uint32_t VendorID)
+{
+   return Otp_ProgUSBID(ProductID, VendorID);
+}
+
+/* Program OTP GP Word memory */
+uint32_t Chip_OTP_ProgGPWord(uint32_t WordNum, uint32_t Data, uint32_t Mask)
+{
+   uint32_t status;
+
+   switch (WordNum) {
+   case 1:
+       status = Otp_ProgGP1(Data, Mask);
+       break;
+
+   case 2:
+       status = Otp_ProgGP2(Data, Mask);
+       break;
+
+   case 0:
+   default:
+       status = Otp_ProgGP0(Data, Mask);
+       break;
+   }
+
+   return status;
+}
+
+/* Program AES Key */
+uint32_t Chip_OTP_ProgKey(uint32_t KeyNum, uint8_t *key)
+{
+   uint32_t status;
+
+   if (KeyNum) {
+       status = Otp_ProgKey2(key);
+   }
+   else {
+       status = Otp_ProgKey1(key);
+   }
+   return status;
+}
+
+/* Generate Random Number using HW Random Number Generator */
+uint32_t Chip_OTP_GenRand(void)
+{
+   return Otp_GenRand();
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/pinint_18xx_43xx.c ./lpc_chip_43xx/src/pinint_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/pinint_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/pinint_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,48 @@
+/*
+ * @brief LPC18xx/43xx Pin Interrupt and Pattern Match driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/pmc_18xx_43xx.c ./lpc_chip_43xx/src/pmc_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/pmc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/pmc_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,69 @@
+/*
+ * @brief LPC18xx/43xx Power Management Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set to sleep mode */
+void Chip_PMC_Sleep(void)
+{
+   /* Sleep Mode*/
+   __WFI();
+}
+
+/* Set power state */
+void Chip_PMC_Set_PwrState(CHIP_PMC_PWR_STATE_T PwrState)
+{
+
+   /* Set Deep sleep mode bit in System Control register of M4 core */
+   SCB->SCR = 0x4;
+
+   /* Set power state in PMC */
+   LPC_PMC->PD0_SLEEP0_MODE = (uint32_t) PwrState;
+
+   __WFI();
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/ring_buffer.c ./lpc_chip_43xx/src/ring_buffer.c
--- a_qSC69Z/lpc_chip_43xx/src/ring_buffer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/ring_buffer.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,167 @@
+/*
+ * @brief Common ring buffer support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include <string.h>
+#include "ring_buffer.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define RB_INDH(rb)                ((rb)->head & ((rb)->count - 1))
+#define RB_INDT(rb)                ((rb)->tail & ((rb)->count - 1))
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize ring buffer */
+int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
+{
+   RingBuff->data = buffer;
+   RingBuff->count = count;
+   RingBuff->itemSz = itemSize;
+   RingBuff->head = RingBuff->tail = 0;
+
+   return 1;
+}
+
+/* Insert a single item into Ring Buffer */
+int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
+{
+   uint8_t *ptr = RingBuff->data;
+
+   /* We cannot insert when queue is full */
+   if (RingBuffer_IsFull(RingBuff))
+       return 0;
+
+   ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
+   memcpy(ptr, data, RingBuff->itemSz);
+   RingBuff->head++;
+
+   return 1;
+}
+
+/* Insert multiple items into Ring Buffer */
+int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num)
+{
+   uint8_t *ptr = RingBuff->data;
+   int cnt1, cnt2;
+
+   /* We cannot insert when queue is full */
+   if (RingBuffer_IsFull(RingBuff))
+       return 0;
+
+   /* Calculate the segment lengths */
+   cnt1 = cnt2 = RingBuffer_GetFree(RingBuff);
+   if (RB_INDH(RingBuff) + cnt1 >= RingBuff->count)
+       cnt1 = RingBuff->count - RB_INDH(RingBuff);
+   cnt2 -= cnt1;
+
+   cnt1 = MIN(cnt1, num);
+   num -= cnt1;
+
+   cnt2 = MIN(cnt2, num);
+   num -= cnt2;
+
+   /* Write segment 1 */
+   ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
+   memcpy(ptr, data, cnt1 * RingBuff->itemSz);
+   RingBuff->head += cnt1;
+
+   /* Write segment 2 */
+   ptr = (uint8_t *) RingBuff->data + RB_INDH(RingBuff) * RingBuff->itemSz;
+   data = (const uint8_t *) data + cnt1 * RingBuff->itemSz;
+   memcpy(ptr, data, cnt2 * RingBuff->itemSz);
+   RingBuff->head += cnt2;
+
+   return cnt1 + cnt2;
+}
+
+/* Pop single item from Ring Buffer */
+int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data)
+{
+   uint8_t *ptr = RingBuff->data;
+
+   /* We cannot pop when queue is empty */
+   if (RingBuffer_IsEmpty(RingBuff))
+       return 0;
+
+   ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
+   memcpy(data, ptr, RingBuff->itemSz);
+   RingBuff->tail++;
+
+   return 1;
+}
+
+/* Pop multiple items from Ring buffer */
+int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num)
+{
+   uint8_t *ptr = RingBuff->data;
+   int cnt1, cnt2;
+
+   /* We cannot insert when queue is empty */
+   if (RingBuffer_IsEmpty(RingBuff))
+       return 0;
+
+   /* Calculate the segment lengths */
+   cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
+   if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
+       cnt1 = RingBuff->count - RB_INDT(RingBuff);
+   cnt2 -= cnt1;
+
+   cnt1 = MIN(cnt1, num);
+   num -= cnt1;
+
+   cnt2 = MIN(cnt2, num);
+   num -= cnt2;
+
+   /* Write segment 1 */
+   ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
+   memcpy(data, ptr, cnt1 * RingBuff->itemSz);
+   RingBuff->tail += cnt1;
+
+   /* Write segment 2 */
+   ptr = (uint8_t *) RingBuff->data + RB_INDT(RingBuff) * RingBuff->itemSz;
+   data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
+   memcpy(data, ptr, cnt2 * RingBuff->itemSz);
+   RingBuff->tail += cnt2;
+
+   return cnt1 + cnt2;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/ritimer_18xx_43xx.c ./lpc_chip_43xx/src/ritimer_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/ritimer_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/ritimer_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,97 @@
+/*
+ * @brief LPC18xx/43xx RITimer chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the RIT */
+void Chip_RIT_Init(LPC_RITIMER_T *pRITimer)
+{
+   Chip_Clock_EnableOpts(CLK_MX_RITIMER, true, true, 1);
+   pRITimer->COMPVAL = 0xFFFFFFFF;
+   pRITimer->MASK  = 0x00000000;
+   pRITimer->CTRL  = 0x0C;
+   pRITimer->COUNTER   = 0x00000000;
+}
+
+/* DeInitialize the RIT */
+void Chip_RIT_DeInit(LPC_RITIMER_T *pRITimer)
+{
+   Chip_RIT_Init(pRITimer);
+   Chip_Clock_Disable(CLK_MX_RITIMER);
+}
+
+/* Set timer interval value */
+void Chip_RIT_SetTimerInterval(LPC_RITIMER_T *pRITimer, uint32_t time_interval)
+{
+   uint32_t cmp_value;
+
+   /* Determine aapproximate compare value based on clock rate and passed interval */
+   cmp_value = (Chip_Clock_GetRate(CLK_MX_RITIMER) / 1000) * time_interval;
+
+   /* Set timer compare value */
+   Chip_RIT_SetCOMPVAL(pRITimer, cmp_value);
+
+   /* Set timer enable clear bit to clear timer to 0 whenever
+      counter value equals the contents of RICOMPVAL */
+   Chip_RIT_EnableCTRL(pRITimer, RIT_CTRL_ENCLR);
+}
+
+/* Check whether interrupt is pending */
+IntStatus Chip_RIT_GetIntStatus(LPC_RITIMER_T *pRITimer)
+{
+   uint8_t result;
+
+   if ((pRITimer->CTRL & RIT_CTRL_INT) == 1) {
+       result = SET;
+   }
+   else {
+       return RESET;
+   }
+
+   return (IntStatus) result;
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/rtc_18xx_43xx.c ./lpc_chip_43xx/src/rtc_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/rtc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/rtc_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,220 @@
+/*
+ * @brief LPC18xx/43xx RTC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the RTC peripheral */
+void Chip_RTC_Init(LPC_RTC_T *pRTC)
+{
+   Chip_Clock_RTCEnable();
+
+   /* 2-Second delay after enabling RTC clock */
+   LPC_ATIMER->DOWNCOUNTER = 2048;
+   while (LPC_ATIMER->DOWNCOUNTER);
+
+   /* Disable RTC */
+   Chip_RTC_Enable(pRTC, DISABLE);
+
+   /* Disable Calibration */
+   Chip_RTC_CalibCounterCmd(pRTC, DISABLE);
+
+   /* Reset RTC Clock */
+   Chip_RTC_ResetClockTickCounter(pRTC);
+
+   /* Clear counter increment and alarm interrupt */
+   pRTC->ILR = RTC_IRL_RTCCIF | RTC_IRL_RTCALF;
+   while (pRTC->ILR != 0) {}
+
+   /* Clear all register to be default */
+   pRTC->CIIR = 0x00;
+   pRTC->AMR = 0xFF;
+   pRTC->CALIBRATION = 0x00;
+}
+
+/*De-initialize the RTC peripheral */
+void Chip_RTC_DeInit(LPC_RTC_T *pRTC)
+{
+   pRTC->CCR = 0x00;
+}
+
+/* Reset clock tick counter in the RTC peripheral */
+void Chip_RTC_ResetClockTickCounter(LPC_RTC_T *pRTC)
+{
+   /* Reset RTC clock*/
+   pRTC->CCR |= RTC_CCR_CTCRST;
+   while (!(pRTC->CCR & RTC_CCR_CTCRST)) {}
+
+   /* Finish resetting RTC clock */
+   pRTC->CCR = (pRTC->CCR & ~RTC_CCR_CTCRST) & RTC_CCR_BITMASK;
+   while (pRTC->CCR & RTC_CCR_CTCRST) {}
+}
+
+/* Start/Stop RTC peripheral */
+void Chip_RTC_Enable(LPC_RTC_T *pRTC, FunctionalState NewState)
+{
+   if (NewState == ENABLE) {
+       pRTC->CCR |= RTC_CCR_CLKEN;
+   } else {
+       pRTC->CCR = (pRTC->CCR & ~RTC_CCR_CLKEN) & RTC_CCR_BITMASK;
+   }
+}
+
+/* Enable/Disable Counter increment interrupt for a time type in the RTC peripheral */
+void Chip_RTC_CntIncrIntConfig(LPC_RTC_T *pRTC, uint32_t cntrMask, FunctionalState NewState)
+{
+   if (NewState == ENABLE) {
+       pRTC->CIIR |= cntrMask;
+   }
+
+   else {
+       pRTC->CIIR &= (~cntrMask) & RTC_AMR_CIIR_BITMASK;
+       while (pRTC->CIIR & cntrMask) {}
+   }
+}
+
+/* Enable/Disable Alarm interrupt for a time type in the RTC peripheral */
+void Chip_RTC_AlarmIntConfig(LPC_RTC_T *pRTC, uint32_t alarmMask, FunctionalState NewState)
+{
+   if (NewState == ENABLE) {
+       pRTC->AMR &= (~alarmMask) & RTC_AMR_CIIR_BITMASK;
+   }
+   else {
+       pRTC->AMR |= (alarmMask);
+       while ((pRTC->AMR & alarmMask) == 0) {}
+   }
+}
+
+/* Set full time in the RTC peripheral */
+void Chip_RTC_SetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+   RTC_TIMEINDEX_T i;
+   uint32_t ccr_val = pRTC->CCR;
+
+   /* Temporarily disable */
+   if (ccr_val & RTC_CCR_CLKEN) {
+       pRTC->CCR = ccr_val & (~RTC_CCR_CLKEN) & RTC_CCR_BITMASK;
+   }
+
+   /* Date time setting */
+   for (i = RTC_TIMETYPE_SECOND; i < RTC_TIMETYPE_LAST; i++) {
+       pRTC->TIME[i] = pFullTime->time[i];
+   }
+
+   /* Restore to old setting */
+   pRTC->CCR = ccr_val;
+}
+
+/* Get full time from the RTC peripheral */
+void Chip_RTC_GetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+   RTC_TIMEINDEX_T i;
+   uint32_t secs = 0xFF;
+
+   /* Read full time, but verify second tick didn't change during the read. If
+      it did, re-read the time again so it will be consistent across all fields. */
+   while (secs != pRTC->TIME[RTC_TIMETYPE_SECOND]) {
+       secs = pFullTime->time[RTC_TIMETYPE_SECOND] = pRTC->TIME[RTC_TIMETYPE_SECOND];
+       for (i = RTC_TIMETYPE_MINUTE; i < RTC_TIMETYPE_LAST; i++) {
+           pFullTime->time[i] = pRTC->TIME[i];
+       }
+   }
+}
+
+/* Set full alarm time in the RTC peripheral */
+void Chip_RTC_SetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+   RTC_TIMEINDEX_T i;
+
+   for (i = RTC_TIMETYPE_SECOND; i < RTC_TIMETYPE_LAST; i++) {
+       pRTC->ALRM[i] = pFullTime->time[i];
+   }
+}
+
+/* Get full alarm time in the RTC peripheral */
+void Chip_RTC_GetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+   RTC_TIMEINDEX_T i;
+
+   for (i = RTC_TIMETYPE_SECOND; i < RTC_TIMETYPE_LAST; i++) {
+       pFullTime->time[i] = pRTC->ALRM[i];
+   }
+}
+
+/* Enable/Disable calibration counter in the RTC peripheral */
+void Chip_RTC_CalibCounterCmd(LPC_RTC_T *pRTC, FunctionalState NewState)
+{
+   if (NewState == ENABLE) {
+       do {
+           pRTC->CCR &= (~RTC_CCR_CCALEN) & RTC_CCR_BITMASK;
+       } while (pRTC->CCR & RTC_CCR_CCALEN);
+   }
+   else {
+       pRTC->CCR |= RTC_CCR_CCALEN;
+   }
+}
+
+#if RTC_EV_SUPPORT
+/* Get first timestamp value */
+void Chip_RTC_EV_GetFirstTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp)
+{
+   pTimeStamp->sec = RTC_ER_TIMESTAMP_SEC(pRTC->ERFIRSTSTAMP[ch]);
+   pTimeStamp->min = RTC_ER_TIMESTAMP_MIN(pRTC->ERFIRSTSTAMP[ch]);
+   pTimeStamp->hour = RTC_ER_TIMESTAMP_HOUR(pRTC->ERFIRSTSTAMP[ch]);
+   pTimeStamp->dayofyear = RTC_ER_TIMESTAMP_DOY(pRTC->ERFIRSTSTAMP[ch]);
+}
+
+/* Get last timestamp value */
+void Chip_RTC_EV_GetLastTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp)
+{
+   pTimeStamp->sec = RTC_ER_TIMESTAMP_SEC(pRTC->ERLASTSTAMP[ch]);
+   pTimeStamp->min = RTC_ER_TIMESTAMP_MIN(pRTC->ERLASTSTAMP[ch]);
+   pTimeStamp->hour = RTC_ER_TIMESTAMP_HOUR(pRTC->ERLASTSTAMP[ch]);
+   pTimeStamp->dayofyear = RTC_ER_TIMESTAMP_DOY(pRTC->ERLASTSTAMP[ch]);
+}
+
+#endif /*RTC_EV_SUPPORT*/
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/sct_18xx_43xx.c ./lpc_chip_43xx/src/sct_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/sct_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/sct_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,87 @@
+/*
+ * @brief LPC18xx/43xx State Configurable Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize SCT */
+void Chip_SCT_Init(LPC_SCT_T *pSCT)
+{
+   Chip_Clock_EnableOpts(CLK_MX_SCT, true, true, 1);
+}
+
+/* Shutdown SCT */
+void Chip_SCT_DeInit(LPC_SCT_T *pSCT)
+{
+   Chip_Clock_Disable(CLK_MX_SCT);
+}
+
+/* Set/Clear SCT control register */
+void Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena)
+{
+   uint32_t tem;
+
+   tem = pSCT->CTRL_U;
+   if (ena == ENABLE) {
+       tem |= value;
+   }
+   else {
+       tem &= (~value);
+   }
+   pSCT->CTRL_U = tem;
+}
+
+/* Set Conflict resolution */
+void Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value)
+{
+   uint32_t tem;
+
+   tem = pSCT->RES;
+   tem &= ~(0x03 << (2 * outnum));
+   tem |= (value << (2 * outnum));
+   pSCT->RES = tem;
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/sct_pwm_18xx_43xx.c ./lpc_chip_43xx/src/sct_pwm_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/sct_pwm_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/sct_pwm_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,87 @@
+/*
+ * @brief LPC18xx_43xx State Configurable Timer PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Setup the OUTPUT pin corresponding to the PWM index */
+void Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin)
+{
+   int ix = (int) index;
+   pSCT->EVENT[ix].CTRL = index | (1 << 12);
+   pSCT->EVENT[ix].STATE = 1;
+   pSCT->OUT[pin].SET = 1;
+   pSCT->OUT[pin].CLR = 1 << ix;
+
+   /* Clear the output in-case of conflict */
+   pSCT->RES = (pSCT->RES & ~(3 << (pin << 1))) | (0x01 << (pin << 1));
+
+   /* Set and Clear do not depend on direction */
+   pSCT->OUTPUTDIRCTRL = (pSCT->OUTPUTDIRCTRL & ~(3 << (pin << 1)));
+}
+
+/* Set the PWM frequency */
+void Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq)
+{
+   uint32_t rate;
+
+   rate = Chip_Clock_GetRate(CLK_MX_SCT) / freq;;
+
+   /* Stop the SCT before configuration */
+   Chip_SCTPWM_Stop(pSCT);
+
+   /* Set MATCH0 for max limit */
+   pSCT->REGMODE_L = 0;
+   pSCT->REGMODE_H = 0;
+   Chip_SCT_SetMatchCount(pSCT, SCT_MATCH_0, 0);
+   Chip_SCT_SetMatchReload(pSCT, SCT_MATCH_0, rate);
+   pSCT->EVENT[0].CTRL = 1 << 12;
+   pSCT->EVENT[0].STATE = 1;
+   pSCT->LIMIT_L = 1;
+
+   /* Set SCT Counter to count 32-bits and reset to 0 after reaching MATCH0 */
+   Chip_SCT_Config(pSCT, SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_AUTOLIMIT_L);
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/sdif_18xx_43xx.c ./lpc_chip_43xx/src/sdif_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/sdif_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/sdif_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,223 @@
+/*
+ * @brief LPC18xx/43xx SD/SDIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "string.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the SD/MMC controller */
+void Chip_SDIF_Init(LPC_SDMMC_T *pSDMMC)
+{
+    /* Enable SDIO module clock */
+   Chip_Clock_EnableOpts(CLK_MX_SDIO, true, true, 1);
+
+    /* Software reset */
+   pSDMMC->BMOD = MCI_BMOD_SWR;
+
+   /* reset all blocks */
+   pSDMMC->CTRL = MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET | MCI_CTRL_DMA_RESET;
+   while (pSDMMC->CTRL & (MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET | MCI_CTRL_DMA_RESET)) {}
+
+   /* Internal DMA setup for control register */
+   pSDMMC->CTRL = MCI_CTRL_USE_INT_DMAC | MCI_CTRL_INT_ENABLE;
+   pSDMMC->INTMASK = 0;
+
+   /* Clear the interrupts for the host controller */
+   pSDMMC->RINTSTS = 0xFFFFFFFF;
+
+   /* Put in max timeout */
+   pSDMMC->TMOUT = 0xFFFFFFFF;
+
+   /* FIFO threshold settings for DMA, DMA burst of 4,   FIFO watermark at 16 */
+   pSDMMC->FIFOTH = MCI_FIFOTH_DMA_MTS_4 | MCI_FIFOTH_RX_WM((SD_FIFO_SZ / 2) - 1) | MCI_FIFOTH_TX_WM(SD_FIFO_SZ / 2);
+
+   /* Enable internal DMA, burst size of 4, fixed burst */
+   pSDMMC->BMOD = MCI_BMOD_DE | MCI_BMOD_PBL4 | MCI_BMOD_DSL(4);
+
+   /* disable clock to CIU (needs latch) */
+   pSDMMC->CLKENA = 0;
+   pSDMMC->CLKSRC = 0;
+}
+
+/* Shutdown the SD/MMC controller */
+void Chip_SDIF_DeInit(LPC_SDMMC_T *pSDMMC)
+{
+    /* Disable the clock */
+   Chip_Clock_Disable(CLK_MX_SDIO);
+}
+
+/* Function to send command to Card interface unit (CIU) */
+int32_t Chip_SDIF_SendCmd(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg)
+{
+   volatile int32_t tmo = 50;
+   volatile int delay;
+
+   /* set command arg reg*/
+   pSDMMC->CMDARG = arg;
+   pSDMMC->CMD = MCI_CMD_START | cmd;
+
+   /* poll untill command is accepted by the CIU */
+   while (--tmo && (pSDMMC->CMD & MCI_CMD_START)) {
+       if (tmo & 1) {
+           delay = 50;
+       }
+       else {
+           delay = 18000;
+       }
+
+       while (--delay > 1) {}
+   }
+
+   return (tmo < 1) ? 1 : 0;
+}
+
+/* Read the response from the last command */
+void Chip_SDIF_GetResponse(LPC_SDMMC_T *pSDMMC, uint32_t *resp)
+{
+   /* on this chip response is not a fifo so read all 4 regs */
+   resp[0] = pSDMMC->RESP0;
+   resp[1] = pSDMMC->RESP1;
+   resp[2] = pSDMMC->RESP2;
+   resp[3] = pSDMMC->RESP3;
+}
+
+/* Sets the SD bus clock speed */
+void Chip_SDIF_SetClock(LPC_SDMMC_T *pSDMMC, uint32_t clk_rate, uint32_t speed)
+{
+   /* compute SD/MMC clock dividers */
+   uint32_t div;
+
+   div = ((clk_rate / speed) + 2) >> 1;
+
+   if ((div == pSDMMC->CLKDIV) && pSDMMC->CLKENA) {
+       return; /* Closest speed is already set */
+
+   }
+   /* disable clock */
+   pSDMMC->CLKENA = 0;
+
+   /* User divider 0 */
+   pSDMMC->CLKSRC = MCI_CLKSRC_CLKDIV0;
+
+   /* inform CIU */
+   Chip_SDIF_SendCmd(pSDMMC, MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+
+   /* set divider 0 to desired value */
+   pSDMMC->CLKDIV = MCI_CLOCK_DIVIDER(0, div);
+
+   /* inform CIU */
+   Chip_SDIF_SendCmd(pSDMMC, MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+
+   /* enable clock */
+   pSDMMC->CLKENA = MCI_CLKEN_ENABLE;
+
+   /* inform CIU */
+   Chip_SDIF_SendCmd(pSDMMC, MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+}
+
+/* Function to clear interrupt & FIFOs */
+void Chip_SDIF_SetClearIntFifo(LPC_SDMMC_T *pSDMMC)
+{
+   /* reset all blocks */
+   pSDMMC->CTRL |= MCI_CTRL_FIFO_RESET;
+
+   /* wait till resets clear */
+   while (pSDMMC->CTRL & MCI_CTRL_FIFO_RESET) {}
+
+   /* Clear interrupt status */
+   pSDMMC->RINTSTS = 0xFFFFFFFF;
+}
+
+/* Setup DMA descriptors */
+void Chip_SDIF_DmaSetup(LPC_SDMMC_T *pSDMMC, sdif_device *psdif_dev, uint32_t addr, uint32_t size)
+{
+   int i = 0;
+   uint32_t ctrl, maxs;
+
+   /* Reset DMA */
+   pSDMMC->CTRL |= MCI_CTRL_DMA_RESET | MCI_CTRL_FIFO_RESET;
+   while (pSDMMC->CTRL & MCI_CTRL_DMA_RESET) {}
+
+   /* Build a descriptor list using the chained DMA method */
+   while (size > 0) {
+       /* Limit size of the transfer to maximum buffer size */
+       maxs = size;
+       if (maxs > MCI_DMADES1_MAXTR) {
+           maxs = MCI_DMADES1_MAXTR;
+       }
+       size -= maxs;
+
+       /* Set buffer size */
+       psdif_dev->mci_dma_dd[i].des1 = MCI_DMADES1_BS1(maxs);
+
+       /* Setup buffer address (chained) */
+       psdif_dev->mci_dma_dd[i].des2 = addr + (i * MCI_DMADES1_MAXTR);
+
+       /* Setup basic control */
+       ctrl = MCI_DMADES0_OWN | MCI_DMADES0_CH;
+       if (i == 0) {
+           ctrl |= MCI_DMADES0_FS; /* First DMA buffer */
+
+       }
+       /* No more data? Then this is the last descriptor */
+       if (!size) {
+           ctrl |= MCI_DMADES0_LD;
+       }
+       else {
+           ctrl |= MCI_DMADES0_DIC;
+       }
+
+       /* Another descriptor is needed */
+       psdif_dev->mci_dma_dd[i].des3 = (uint32_t) &psdif_dev->mci_dma_dd[i + 1];
+       psdif_dev->mci_dma_dd[i].des0 = ctrl;
+
+       i++;
+   }
+
+   /* Set DMA derscriptor base address */
+   pSDMMC->DBADDR = (uint32_t) &psdif_dev->mci_dma_dd[0];
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/sdio_18xx_43xx.c ./lpc_chip_43xx/src/sdio_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/sdio_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/sdio_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,518 @@
+/*
+ * @brief LPC18xx/43xx SDIO Card driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define SDIO_CMD_INT_MSK    0xA146       /* Interrupts to be enabled for CMD */
+#define SDIO_DATA_INT_MSK   0xBE88       /* Interrupts to enable for data transfer */
+#define SDIO_CARD_INT_MSK   (1UL << 16)  /* SDIO Card interrupt */
+
+static struct
+{
+   void (*wake_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg);
+   uint32_t (*wait_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg);
+   uint32_t flag;
+   uint32_t response[4];
+   int fnum;
+   uint16_t blkSz[8];     /* Block size setting for the 8- function blocks */
+   sdif_device sdev;      /* SDIO interface device structure */
+}sdio_context, *sdioif = &sdio_context;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Set the SDIO Card voltage level to 3v3 */
+static int SDIO_Card_SetVoltage(LPC_SDMMC_T *pSDMMC)
+{
+   int ret, i;
+   uint32_t val;
+
+   ret = SDIO_Send_Command(pSDMMC, CMD5, 0);
+   if (ret) return ret;
+   val = sdioif->response[0];
+
+   /* Number of functions supported by the card */
+   sdioif->fnum = (val >> 28) & 7;
+
+   /* Check number of I/O functions*/
+   if(sdioif->fnum == 0) {
+       /* Number of I/O functions */
+       return SDIO_ERR_FNUM;
+   }
+
+   /* ---- check OCR ---- */
+   if((val & SDIO_VOLT_3_3) == 0){
+       /* invalid voltage */
+       return SDIO_ERR_VOLT;
+   }
+
+   /* ==== send CMD5 write new voltage  === */
+   for(i = 0; i < 100; i++){
+       ret = SDIO_Send_Command(pSDMMC, CMD5, SDIO_VOLT_3_3);
+       if (ret) return ret;
+       val = sdioif->response[0];
+
+       /* Is card ready ? */
+       if(val & (1UL << 31)){
+           break;
+       }
+
+       sdioif->wait_evt(pSDMMC, SDIO_WAIT_DELAY, (void *)10);
+   }
+
+   /* ==== Check C bit  ==== */
+   if(val & (1UL << 31)){
+       return 0;
+   }
+
+   return SDIO_ERR_VOLT; /* error end */
+}
+
+/* Set SDIO Card RCA */
+static int SDIO_CARD_SetRCA(LPC_SDMMC_T *pSDMMC)
+{
+   int ret;
+
+   /* ==== send CMD3 get RCA  ==== */
+   ret = SDIO_Send_Command(pSDMMC, CMD3, 0);
+   if (ret) return ret;
+
+   /* R6 response to CMD3 */
+   if((sdioif->response[0] & 0x0000e000) != 0){
+                       /* COM_CRC_ERROR */
+                       /* ILLEGAL_CRC_ERROR */
+                       /* ERROR */
+       return SDIO_ERR_RCA;
+   }
+
+   /* change card state */
+   sdioif->flag |= SDIO_POWER_INIT;
+
+   /* New published RCA */
+   sdioif->response[0] &= 0xffff0000;
+
+   /* ==== change state to Stanby State ==== */
+   return SDIO_Send_Command(pSDMMC, CMD7, sdioif->response[0]);
+}
+
+/* Set the Clock speed and mode [1/4 bit] of the card */
+static int SDIO_Card_SetMode(LPC_SDMMC_T *pSDMMC, uint32_t clk, int mode_4bit)
+{
+   int ret;
+   uint32_t val;
+
+   Chip_SDIF_SetClock(pSDMMC, Chip_Clock_GetBaseClocktHz(CLK_BASE_SDIO), clk);
+
+   if (!mode_4bit)
+       return 0;
+
+   val = 0x02;
+   ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, 0x07, &val);
+   if (ret) return ret;
+
+   if (val & 0x02) {
+       Chip_SDIF_SetCardType(pSDMMC, MCI_CTYPE_4BIT);
+   }
+   return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Set the block size of a function */
+int SDIO_Card_SetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t blkSize)
+{
+   int ret;
+   uint32_t tmp, asz;
+   if (func > sdioif->fnum)
+       return SDIO_ERR_INVFUNC;
+
+   if (blkSize > 2048)
+       return SDIO_ERR_INVARG;
+
+   tmp = blkSize & 0xFF;
+   ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, (func << 8) + 0x10, &tmp);
+   if (ret) return ret;
+   asz = tmp;
+
+   tmp = blkSize >> 8;
+   ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, (func << 8) + 0x11, &tmp);
+   if (ret) return ret;
+   asz |= tmp << 8;
+   sdioif->blkSz[func] = asz;
+   return 0;
+}
+
+/* Get the block size of a particular function */
+uint32_t SDIO_Card_GetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func)
+{
+   if (func > sdioif->fnum)
+       return 0;
+
+   return sdioif->blkSz[func];
+}
+
+/* Write data to SDIO Card */
+int SDIO_Card_WriteData(LPC_SDMMC_T *pSDMMC, uint32_t func,
+   uint32_t dest_addr, const uint8_t *src_addr,
+   uint32_t size, uint32_t flags)
+{
+   int ret;
+   uint32_t bs = size, bsize = size;
+   uint32_t cmd = CMD53 | (1UL << 10);
+
+   if (func > sdioif->fnum)
+       return SDIO_ERR_INVFUNC;
+
+   if (bsize > 512 || bsize == 0)
+       return SDIO_ERR_INVARG;
+
+   if (flags & SDIO_MODE_BLOCK) {
+       uint32_t bs = SDIO_Card_GetBlockSize(pSDMMC, func);
+       if (!bs) return SDIO_ERR_INVARG;
+       size *= bs;
+   }
+
+   /* Set Block Size */
+   Chip_SDIF_SetBlkSize(pSDMMC, bs);
+
+   /* set number of bytes to read */
+   Chip_SDIF_SetByteCnt(pSDMMC, size);
+
+   sdioif->wait_evt(pSDMMC, SDIO_START_DATA, 0);
+   Chip_SDIF_DmaSetup(pSDMMC, &sdioif->sdev, (uint32_t) src_addr, size);
+
+   ret = SDIO_Send_Command(pSDMMC, cmd, (func << 28) | (dest_addr << 9) | (bsize & 0x1FF) | (1UL << 31) | (flags & (0x3 << 26)));
+   if (ret) return ret;
+
+   /* Check response for errors */
+   if(sdioif->response[0] & 0xcb00){
+                       /* COM_CRC_ERROR */
+                       /* ILLEGAL_CRC_ERROR */
+                       /* ERROR */
+                       /* RFU FUNCTION_NUMBER */
+                       /* OUT_OF_RANGE */
+       /* Response flag error */
+       return SDIO_ERR_READWRITE;
+   }
+   return sdioif->wait_evt(pSDMMC, SDIO_WAIT_DATA, 0);
+}
+
+/* Write data to SDIO Card */
+int SDIO_Card_ReadData(LPC_SDMMC_T *pSDMMC, uint32_t func, uint8_t *dest_addr, uint32_t src_addr, uint32_t size, uint32_t flags)
+{
+   int ret;
+   uint32_t bs = size, bsize = size;
+   uint32_t cmd = CMD53;
+
+   if (func > sdioif->fnum)
+       return SDIO_ERR_INVFUNC;
+
+   if (bsize > 512 || bsize == 0)
+       return SDIO_ERR_INVARG;
+
+   if (flags & SDIO_MODE_BLOCK) {
+       bs = SDIO_Card_GetBlockSize(pSDMMC, func);
+       if (!bs) return SDIO_ERR_INVARG;
+       size *= bs;
+   }
+   /* Set the block size */
+   Chip_SDIF_SetBlkSize(pSDMMC, bs);
+
+   /* set number of bytes to read */
+   Chip_SDIF_SetByteCnt(pSDMMC, size);
+
+   sdioif->wait_evt(pSDMMC, SDIO_START_DATA, 0);
+   Chip_SDIF_DmaSetup(pSDMMC, &sdioif->sdev, (uint32_t) dest_addr, size);
+
+   ret = SDIO_Send_Command(pSDMMC, cmd | (1 << 13), (func << 28) | (src_addr << 9) | (bsize & 0x1FF) | (flags & (0x3 << 26)));
+   if (ret) return ret;
+
+   /* Check response for errors */
+   if(sdioif->response[0] & 0xcb00){
+                       /* COM_CRC_ERROR */
+                       /* ILLEGAL_CRC_ERROR */
+                       /* ERROR */
+                       /* RFU FUNCTION_NUMBER */
+                       /* OUT_OF_RANGE */
+       /* Response flag error */
+       return SDIO_ERR_READWRITE;
+   }
+
+   return sdioif->wait_evt(pSDMMC, SDIO_WAIT_DATA, 0);
+}
+
+/* Enable SDIO function interrupt */
+int SDIO_Card_EnableInt(LPC_SDMMC_T *pSDMMC, uint32_t func)
+{
+   int ret;
+   uint32_t val;
+
+   if (func > sdioif->fnum)
+       return SDIO_ERR_INVFUNC;
+
+   ret = SDIO_Read_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, &val);
+   if (ret) return ret;
+   val |= (1 << func) | 1;
+   ret = SDIO_Write_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, val);
+   if (ret) return ret;
+   pSDMMC->INTMASK |= SDIO_CARD_INT_MSK;
+
+   return 0;
+}
+
+/* Disable SDIO function interrupt */
+int SDIO_Card_DisableInt(LPC_SDMMC_T *pSDMMC, uint32_t func)
+{
+   int ret;
+   uint32_t val;
+
+   if (func > sdioif->fnum)
+       return SDIO_ERR_INVFUNC;
+
+   ret = SDIO_Read_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, &val);
+   if (ret) return ret;
+   val &= ~(1 << func);
+
+   /* Disable master interrupt if it is the only thing enabled */
+   if (val == 1)
+       val = 0;
+   ret = SDIO_Write_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, val);
+   if (ret) return ret;
+   if (!val)
+       pSDMMC->INTMASK &= ~SDIO_CARD_INT_MSK;
+
+   return 0;
+}
+
+/* Initialize the SDIO card */
+int SDIO_Card_Init(LPC_SDMMC_T *pSDMMC, uint32_t freq)
+{
+   int ret;
+   uint32_t val;
+
+   /* Set Clock to 400KHz */
+   Chip_SDIF_SetClock(pSDMMC, Chip_Clock_GetBaseClocktHz(CLK_BASE_SDIO), freq);
+   Chip_SDIF_SetCardType(pSDMMC, 0);
+
+   sdioif->wait_evt(pSDMMC, SDIO_WAIT_DELAY, (void *) 100); /* Wait for card to wake up */
+
+   if (sdioif->flag & SDIO_POWER_INIT) {
+       /* Write to the Reset Bit */
+       ret = SDIO_Write_Direct(pSDMMC, SDIO_AREA_CIA, 0x06, 0x08);
+       if (ret) return ret;
+   }
+
+   /* Set Voltage level to 3v3 */
+   ret = SDIO_Card_SetVoltage(pSDMMC);
+   if (ret) return ret;
+
+   /* Set the RCA */
+   ret = SDIO_CARD_SetRCA(pSDMMC);
+   if (ret) return ret;
+
+   /* ==== check card capability ==== */
+   val = 0x02;
+   ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, 0x13, &val);
+   if (ret) return ret;
+
+   /* FIXME: Verify */
+   /* FIFO threshold settings for DMA, DMA burst of 4,   FIFO watermark at 16 */
+   pSDMMC->FIFOTH = MCI_FIFOTH_DMA_MTS_1 | MCI_FIFOTH_RX_WM(0) | MCI_FIFOTH_TX_WM(1);
+
+   /* Enable internal DMA, burst size of 4, fixed burst */
+   pSDMMC->BMOD = MCI_BMOD_DE | MCI_BMOD_PBL1 | MCI_BMOD_DSL(0);
+
+   /* High Speed Support? */
+   if ((val & 0x03) == 3) {
+       return SDIO_Card_SetMode(pSDMMC, SDIO_CLK_HISPEED, 1);
+   }
+
+   ret = SDIO_Read_Direct(pSDMMC, SDIO_AREA_CIA, 0x08, &val);
+   if (ret) return ret;
+
+   /* Full Speed Support? */
+   if (val & SDIO_CCCR_LSC) {
+       return SDIO_Card_SetMode(pSDMMC, SDIO_CLK_FULLSPEED, 1);
+   }
+
+   /* Low Speed Card */
+   return SDIO_Card_SetMode(pSDMMC, SDIO_CLK_LOWSPEED, val & SDIO_CCCR_4BLS);
+}
+
+/* Write given data to register space of the CARD */
+int SDIO_Write_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t data)
+{
+   int ret;
+
+   ret = SDIO_Send_Command(pSDMMC, CMD52, (func << 28) | (addr << 9) | (data & 0xFF) | (1UL << 31));
+   if (ret) return ret;
+
+   /* Check response for errors */
+   if(sdioif->response[0] & 0xcb00){
+                       /* COM_CRC_ERROR */
+                       /* ILLEGAL_CRC_ERROR */
+                       /* ERROR */
+                       /* RFU FUNCTION_NUMBER */
+                       /* OUT_OF_RANGE */
+       /* Response flag error */
+       return SDIO_ERR_READWRITE;
+   }
+   return data != (sdioif->response[0] & 0xFF);
+}
+
+/* Write given data to register, and read back the register into data */
+int SDIO_WriteRead_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data)
+{
+   int ret;
+
+   ret = SDIO_Send_Command(pSDMMC, CMD52, (func << 28) | (1 << 27) | (addr << 9) | ((*data) & 0xFF) | (1UL << 31));
+   if (ret) return ret;
+
+   /* Check response for errors */
+   if(sdioif->response[0] & 0xcb00){
+                       /* COM_CRC_ERROR */
+                       /* ILLEGAL_CRC_ERROR */
+                       /* ERROR */
+                       /* RFU FUNCTION_NUMBER */
+                       /* OUT_OF_RANGE */
+       /* Response flag error */
+       return SDIO_ERR_READWRITE;
+   }
+   *data = sdioif->response[0] & 0xFF;
+   return 0;
+}
+
+/* Read a register from the register address space of the CARD */
+int SDIO_Read_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data)
+{
+   int ret;
+   ret = SDIO_Send_Command(pSDMMC, CMD52, ((func & 7) << 28) | ((addr & 0x1FFFF) << 9));
+   if (ret) return ret;
+
+   /* Check response for errors */
+   if(sdioif->response[0] & 0xcb00){
+                       /* COM_CRC_ERROR */
+                       /* ILLEGAL_CRC_ERROR */
+                       /* ERROR */
+                       /* RFU FUNCTION_NUMBER */
+                       /* OUT_OF_RANGE */
+       /* Response flag error */
+       return SDIO_ERR_READWRITE;
+   }
+   *data = sdioif->response[0] & 0xFF;
+   return 0;
+}
+
+/* Set up the wait and wake call-back functions */
+void SDIO_Setup_Callback(LPC_SDMMC_T *pSDMMC,
+   void (*wake_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg),
+   uint32_t (*wait_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg))
+{
+   sdioif->wake_evt = wake_evt;
+   sdioif->wait_evt = wait_evt;
+}
+
+/* Send and SD Command to the SDIO Card */
+uint32_t SDIO_Send_Command(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg)
+{
+   uint32_t ret, ival;
+   uint32_t imsk = pSDMMC->INTMASK;
+   ret = sdioif->wait_evt(pSDMMC, SDIO_START_COMMAND, (void *)(cmd & 0x3F));
+   ival = SDIO_CMD_INT_MSK & ~ret;
+
+   /* Set data interrupts for data commands */
+   if (cmd & SDIO_CMD_DATA) {
+       ival |= SDIO_DATA_INT_MSK;
+       imsk |= SDIO_DATA_INT_MSK;
+   }
+
+   Chip_SDIF_SetIntMask(pSDMMC, ival);
+   Chip_SDIF_SendCmd(pSDMMC, cmd, arg);
+   ret = sdioif->wait_evt(pSDMMC, SDIO_WAIT_COMMAND, 0);
+   if (!ret && (cmd & SDIO_CMD_RESP_R1)) {
+       Chip_SDIF_GetResponse(pSDMMC, &sdioif->response[0]);
+   }
+
+   Chip_SDIF_SetIntMask(pSDMMC, imsk);
+   return ret;
+}
+
+/* SDIO Card interrupt handler */
+void SDIO_Handler(LPC_SDMMC_T *pSDMMC)
+{
+   uint32_t status = pSDMMC->MINTSTS;
+   uint32_t iclr = 0;
+
+   /* Card Detected */
+   if (status & 1) {
+       sdioif->wake_evt(pSDMMC, SDIO_CARD_DETECT, 0);
+       iclr = 1;
+   }
+
+   /* Command event error */
+   if (status & (SDIO_CMD_INT_MSK & ~4)) {
+       sdioif->wake_evt(pSDMMC, SDIO_CMD_ERR, (void *) (status & (SDIO_CMD_INT_MSK & ~4)));
+       iclr |= status & SDIO_CMD_INT_MSK;
+   } else if (status & 4) {
+       /* Command event done */
+       sdioif->wake_evt(pSDMMC, SDIO_CMD_DONE, (void *) status);
+       iclr |= status & SDIO_CMD_INT_MSK;
+   }
+
+   /* Command event error */
+   if (status & (SDIO_DATA_INT_MSK & ~8)) {
+       sdioif->wake_evt(pSDMMC, SDIO_DATA_ERR, (void *) (status & (SDIO_DATA_INT_MSK & ~8)));
+       iclr |= (status & SDIO_DATA_INT_MSK) | (3 << 4);
+   } else if (status & 8) {
+       /* Command event done */
+       sdioif->wake_evt(pSDMMC, SDIO_DATA_DONE, (void *) status);
+       iclr |= (status & SDIO_DATA_INT_MSK) | (3 << 4);
+   }
+
+   /* Handle Card interrupt */
+   if (status & SDIO_CARD_INT_MSK) {
+       sdioif->wake_evt(pSDMMC, SDIO_CARD_INT, 0);
+       iclr |= status & SDIO_CARD_INT_MSK;
+   }
+
+   /* Clear the interrupts */
+   pSDMMC->RINTSTS = iclr;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/sdmmc_18xx_43xx.c ./lpc_chip_43xx/src/sdmmc_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/sdmmc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/sdmmc_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,592 @@
+/*
+ * @brief LPC18xx/43xx SD/SDIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "string.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Global instance of the current card */
+static mci_card_struct *g_card_info;
+
+/* Helper definition: all SD error conditions in the status word */
+#define SD_INT_ERROR (MCI_INT_RESP_ERR | MCI_INT_RCRC | MCI_INT_DCRC | \
+                     MCI_INT_RTO | MCI_INT_DTO | MCI_INT_HTO | MCI_INT_FRUN | MCI_INT_HLE | \
+                     MCI_INT_SBE | MCI_INT_EBE)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Function to execute a command */
+static int32_t sdmmc_execute_command(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg, uint32_t wait_status)
+{
+   int32_t step = (cmd & CMD_BIT_APP) ? 2 : 1;
+   int32_t status = 0;
+   uint32_t cmd_reg = 0;
+
+   if (!wait_status) {
+       wait_status = (cmd & CMD_MASK_RESP) ? MCI_INT_CMD_DONE : MCI_INT_DATA_OVER;
+   }
+
+   /* Clear the interrupts & FIFOs*/
+   if (cmd & CMD_BIT_DATA) {
+       Chip_SDIF_SetClearIntFifo(pSDMMC);
+   }
+
+   /* also check error conditions */
+   wait_status |= MCI_INT_EBE | MCI_INT_SBE | MCI_INT_HLE | MCI_INT_RTO | MCI_INT_RCRC | MCI_INT_RESP_ERR;
+   if (wait_status & MCI_INT_DATA_OVER) {
+       wait_status |= MCI_INT_FRUN | MCI_INT_HTO | MCI_INT_DTO | MCI_INT_DCRC;
+   }
+
+   while (step) {
+       Chip_SDIF_SetClock(pSDMMC, Chip_Clock_GetBaseClocktHz(CLK_BASE_SDIO), g_card_info->card_info.speed);
+
+       /* Clear the interrupts */
+       Chip_SDIF_ClrIntStatus(pSDMMC, 0xFFFFFFFF);
+
+       g_card_info->card_info.evsetup_cb((void *) &wait_status);
+
+       switch (step) {
+       case 1: /* Execute command */
+           cmd_reg = ((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) |
+                     ((cmd & CMD_BIT_INIT)  ? MCI_CMD_INIT : 0) |
+                     ((cmd & CMD_BIT_DATA)  ? (MCI_CMD_DAT_EXP | MCI_CMD_PRV_DAT_WAIT) : 0) |
+                     (((cmd & CMD_MASK_RESP) == CMD_RESP_R2) ? MCI_CMD_RESP_LONG : 0) |
+                     ((cmd & CMD_MASK_RESP) ? MCI_CMD_RESP_EXP : 0) |
+                     ((cmd & CMD_BIT_WRITE)  ? MCI_CMD_DAT_WR : 0) |
+                     ((cmd & CMD_BIT_STREAM) ? MCI_CMD_STRM_MODE : 0) |
+                     ((cmd & CMD_BIT_BUSY) ? MCI_CMD_STOP : 0) |
+                     ((cmd & CMD_BIT_AUTO_STOP)  ? MCI_CMD_SEND_STOP : 0) |
+                     MCI_CMD_START;
+
+           /* wait for previos data finsh for select/deselect commands */
+           if (((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) == MMC_SELECT_CARD) {
+               cmd_reg |= MCI_CMD_PRV_DAT_WAIT;
+           }
+
+           /* wait for command to be accepted by CIU */
+           if (Chip_SDIF_SendCmd(pSDMMC, cmd_reg, arg) == 0) {
+               --step;
+           }
+           break;
+
+       case 0:
+           return 0;
+
+       case 2: /* APP prefix */
+           cmd_reg = MMC_APP_CMD | MCI_CMD_RESP_EXP |
+                     ((cmd & CMD_BIT_INIT)  ? MCI_CMD_INIT : 0) |
+                     MCI_CMD_START;
+
+           if (Chip_SDIF_SendCmd(pSDMMC, cmd_reg, g_card_info->card_info.rca << 16) == 0) {
+               --step;
+           }
+           break;
+       }
+
+       /* wait for command response */
+       status = g_card_info->card_info.waitfunc_cb();
+
+       /* We return an error if there is a timeout, even if we've fetched  a response */
+       if (status & SD_INT_ERROR) {
+           return status;
+       }
+
+       if (status & MCI_INT_CMD_DONE) {
+           switch (cmd & CMD_MASK_RESP) {
+           case 0:
+               break;
+
+           case CMD_RESP_R1:
+           case CMD_RESP_R3:
+           case CMD_RESP_R2:
+               Chip_SDIF_GetResponse(pSDMMC, &g_card_info->card_info.response[0]);
+               break;
+           }
+       }
+   }
+
+   return 0;
+}
+
+/* Checks whether card is acquired properly or not */
+static int32_t prv_card_acquired(void)
+{
+   return g_card_info->card_info.cid[0] != 0;
+}
+
+/* Helper function to get a bit field withing multi-word  buffer. Used to get
+   fields with-in CSD & EXT-CSD */
+static uint32_t prv_get_bits(int32_t start, int32_t end, uint32_t *data)
+{
+   uint32_t v;
+   uint32_t i = end >> 5;
+   uint32_t j = start & 0x1f;
+
+   if (i == (start >> 5)) {
+       v = (data[i] >> j);
+   }
+   else {
+       v = ((data[i] << (32 - j)) | (data[start >> 5] >> j));
+   }
+
+   return v & ((1 << (end - start + 1)) - 1);
+}
+
+/* Function to process the CSD & EXT-CSD of the card */
+static void prv_process_csd(LPC_SDMMC_T *pSDMMC)
+{
+   int32_t status = 0;
+   int32_t c_size = 0;
+   int32_t c_size_mult = 0;
+   int32_t mult = 0;
+
+   /* compute block length based on CSD response */
+   g_card_info->card_info.block_len = 1 << prv_get_bits(80, 83, g_card_info->card_info.csd);
+
+   if ((g_card_info->card_info.card_type & CARD_TYPE_HC) && (g_card_info->card_info.card_type & CARD_TYPE_SD)) {
+       /* See section 5.3.3 CSD Register (CSD Version 2.0) of SD2.0 spec  an explanation for the calculation of these values */
+       c_size = prv_get_bits(48, 63, (uint32_t *) g_card_info->card_info.csd) + 1;
+       g_card_info->card_info.blocknr = c_size << 10;  /* 512 byte blocks */
+   }
+   else {
+       /* See section 5.3 of the 4.1 revision of the MMC specs for  an explanation for the calculation of these values */
+       c_size = prv_get_bits(62, 73, (uint32_t *) g_card_info->card_info.csd);
+       c_size_mult = prv_get_bits(47, 49, (uint32_t *) g_card_info->card_info.csd);
+       mult = 1 << (c_size_mult + 2);
+       g_card_info->card_info.blocknr = (c_size + 1) * mult;
+
+       /* adjust blocknr to 512/block */
+       if (g_card_info->card_info.block_len > MMC_SECTOR_SIZE) {
+           g_card_info->card_info.blocknr = g_card_info->card_info.blocknr * (g_card_info->card_info.block_len >> 9);
+       }
+
+       /* get extended CSD for newer MMC cards CSD spec >= 4.0*/
+       if (((g_card_info->card_info.card_type & CARD_TYPE_SD) == 0) &&
+           (prv_get_bits(122, 125, (uint32_t *) g_card_info->card_info.csd) >= 4)) {
+           /* put card in trans state */
+           status = sdmmc_execute_command(pSDMMC, CMD_SELECT_CARD, g_card_info->card_info.rca << 16, 0);
+
+           /* set block size and byte count */
+           Chip_SDIF_SetBlkSizeByteCnt(pSDMMC, MMC_SECTOR_SIZE);
+
+           /* send EXT_CSD command */
+           Chip_SDIF_DmaSetup(pSDMMC,
+                             &g_card_info->sdif_dev,
+                             (uint32_t) g_card_info->card_info.ext_csd,
+                             MMC_SECTOR_SIZE);
+
+           status = sdmmc_execute_command(pSDMMC, CMD_SEND_EXT_CSD, 0, 0 | MCI_INT_DATA_OVER);
+           if ((status & SD_INT_ERROR) == 0) {
+               /* check EXT_CSD_VER is greater than 1.1 */
+               if ((g_card_info->card_info.ext_csd[48] & 0xFF) > 1) {
+                   g_card_info->card_info.blocknr = g_card_info->card_info.ext_csd[53];/* bytes 212:215 represent sec count */
+
+               }
+               /* switch to 52MHz clock if card type is set to 1 or else set to 26MHz */
+               if ((g_card_info->card_info.ext_csd[49] & 0xFF) == 1) {
+                   /* for type 1 MMC cards high speed is 52MHz */
+                   g_card_info->card_info.speed = MMC_HIGH_BUS_MAX_CLOCK;
+               }
+               else {
+                   /* for type 0 MMC cards high speed is 26MHz */
+                   g_card_info->card_info.speed = MMC_LOW_BUS_MAX_CLOCK;
+               }
+           }
+       }
+   }
+
+   g_card_info->card_info.device_size = (uint64_t) g_card_info->card_info.blocknr << 9;    /* blocknr * 512 */
+}
+
+/* Puts current selected card in trans state */
+static int32_t prv_set_trans_state(LPC_SDMMC_T *pSDMMC)
+{
+   uint32_t status;
+
+   /* get current state of the card */
+   status = sdmmc_execute_command(pSDMMC, CMD_SEND_STATUS, g_card_info->card_info.rca << 16, 0);
+   if (status & MCI_INT_RTO) {
+       /* unable to get the card state. So return immediatly. */
+       return -1;
+   }
+
+   /* check card state in response */
+   status = R1_CURRENT_STATE(g_card_info->card_info.response[0]);
+   switch (status) {
+   case SDMMC_STBY_ST:
+       /* put card in 'Trans' state */
+       status = sdmmc_execute_command(pSDMMC, CMD_SELECT_CARD, g_card_info->card_info.rca << 16, 0);
+       if (status != 0) {
+           /* unable to put the card in Trans state. So return immediatly. */
+           return -1;
+       }
+       break;
+
+   case SDMMC_TRAN_ST:
+       /*do nothing */
+       break;
+
+   default:
+       /* card shouldn't be in other states so return */
+       return -1;
+   }
+
+   return 0;
+}
+
+/* Sets card data width and block size */
+static int32_t prv_set_card_params(LPC_SDMMC_T *pSDMMC)
+{
+   int32_t status;
+
+#if SDIO_BUS_WIDTH > 1
+   if (g_card_info->card_info.card_type & CARD_TYPE_SD) {
+       status = sdmmc_execute_command(pSDMMC, CMD_SD_SET_WIDTH, 2, 0);
+       if (status != 0) {
+           return -1;
+       }
+
+       /* if positive response */
+       Chip_SDIF_SetCardType(pSDMMC, MCI_CTYPE_4BIT);
+   }
+#elif SDIO_BUS_WIDTH > 4
+#error 8-bit mode not supported yet!
+#endif
+
+   /* set block length */
+   Chip_SDIF_SetBlkSize(pSDMMC, MMC_SECTOR_SIZE);
+   status = sdmmc_execute_command(pSDMMC, CMD_SET_BLOCKLEN, MMC_SECTOR_SIZE, 0);
+   if (status != 0) {
+       return -1;
+   }
+
+   return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Get card's current state (idle, transfer, program, etc.) */
+int32_t Chip_SDMMC_GetState(LPC_SDMMC_T *pSDMMC)
+{
+   uint32_t status;
+
+   /* get current state of the card */
+   status = sdmmc_execute_command(pSDMMC, CMD_SEND_STATUS, g_card_info->card_info.rca << 16, 0);
+   if (status & MCI_INT_RTO) {
+       return -1;
+   }
+
+   /* check card state in response */
+   return (int32_t) R1_CURRENT_STATE(g_card_info->card_info.response[0]);
+}
+
+/* Function to enumerate the SD/MMC/SDHC/MMC+ cards */
+uint32_t Chip_SDMMC_Acquire(LPC_SDMMC_T *pSDMMC, mci_card_struct *pcardinfo)
+{
+   int32_t status;
+   int32_t tries = 0;
+   uint32_t ocr = OCR_VOLTAGE_RANGE_MSK;
+   uint32_t r;
+   int32_t state = 0;
+   uint32_t command = 0;
+
+   g_card_info = pcardinfo;
+
+   /* clear card type */
+   Chip_SDIF_SetCardType(pSDMMC, 0);
+
+   /* set high speed for the card as 20MHz */
+   g_card_info->card_info.speed = MMC_MAX_CLOCK;
+
+   status = sdmmc_execute_command(pSDMMC, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+
+   while (state < 100) {
+       switch (state) {
+       case 0: /* Setup for SD */
+           /* check if it is SDHC card */
+           status = sdmmc_execute_command(pSDMMC, CMD_SD_SEND_IF_COND, SD_SEND_IF_ARG, 0);
+           if (!(status & MCI_INT_RTO)) {
+               /* check response has same echo pattern */
+               if ((g_card_info->card_info.response[0] & SD_SEND_IF_ECHO_MSK) == SD_SEND_IF_RESP) {
+                   ocr |= OCR_HC_CCS;
+               }
+           }
+
+           ++state;
+           command = CMD_SD_OP_COND;
+           tries = INIT_OP_RETRIES;
+
+           /* assume SD card */
+           g_card_info->card_info.card_type |= CARD_TYPE_SD;
+           g_card_info->card_info.speed = SD_MAX_CLOCK;
+           break;
+
+       case 10:    /* Setup for MMC */
+           /* start fresh for MMC crds */
+           g_card_info->card_info.card_type &= ~CARD_TYPE_SD;
+           status = sdmmc_execute_command(pSDMMC, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+           command = CMD_MMC_OP_COND;
+           tries = INIT_OP_RETRIES;
+           ocr |= OCR_HC_CCS;
+           ++state;
+
+           /* for MMC cards high speed is 20MHz */
+           g_card_info->card_info.speed = MMC_MAX_CLOCK;
+           break;
+
+       case 1:
+       case 11:
+           status = sdmmc_execute_command(pSDMMC, command, 0, 0);
+           if (status & MCI_INT_RTO) {
+               state += 9; /* Mode unavailable */
+           }
+           else {
+               ++state;
+           }
+           break;
+
+       case 2:     /* Initial OCR check  */
+       case 12:
+           ocr = g_card_info->card_info.response[0] | (ocr & OCR_HC_CCS);
+           if (ocr & OCR_ALL_READY) {
+               ++state;
+           }
+           else {
+               state += 2;
+           }
+           break;
+
+       case 3:     /* Initial wait for OCR clear */
+       case 13:
+           while ((ocr & OCR_ALL_READY) && --tries > 0) {
+               g_card_info->card_info.msdelay_func(MS_ACQUIRE_DELAY);
+               status = sdmmc_execute_command(pSDMMC, command, 0, 0);
+               ocr = g_card_info->card_info.response[0] | (ocr & OCR_HC_CCS);
+           }
+           if (ocr & OCR_ALL_READY) {
+               state += 7;
+           }
+           else {
+               ++state;
+           }
+           break;
+
+       case 14:
+           /* for MMC cards set high capacity bit */
+           ocr |= OCR_HC_CCS;
+
+       case 4: /* Assign OCR */
+           tries = SET_OP_RETRIES;
+           ocr &= OCR_VOLTAGE_RANGE_MSK | OCR_HC_CCS;  /* Mask for the bits we care about */
+           do {
+               g_card_info->card_info.msdelay_func(MS_ACQUIRE_DELAY);
+               status = sdmmc_execute_command(pSDMMC, command, ocr, 0);
+               r = g_card_info->card_info.response[0];
+           } while (!(r & OCR_ALL_READY) && --tries > 0);
+
+           if (r & OCR_ALL_READY) {
+               /* is it high capacity card */
+               g_card_info->card_info.card_type |= (r & OCR_HC_CCS);
+               ++state;
+           }
+           else {
+               state += 6;
+           }
+           break;
+
+       case 5: /* CID polling */
+       case 15:
+           status = sdmmc_execute_command(pSDMMC, CMD_ALL_SEND_CID, 0, 0);
+           memcpy(&g_card_info->card_info.cid, &g_card_info->card_info.response[0], 16);
+           ++state;
+           break;
+
+       case 6: /* RCA send, for SD get RCA */
+           status = sdmmc_execute_command(pSDMMC, CMD_SD_SEND_RCA, 0, 0);
+           g_card_info->card_info.rca = (g_card_info->card_info.response[0]) >> 16;
+           ++state;
+           break;
+
+       case 16:    /* RCA assignment for MMC set to 1 */
+           g_card_info->card_info.rca = 1;
+           status = sdmmc_execute_command(pSDMMC, CMD_MMC_SET_RCA, g_card_info->card_info.rca << 16, 0);
+           ++state;
+           break;
+
+       case 7:
+       case 17:
+           status = sdmmc_execute_command(pSDMMC, CMD_SEND_CSD, g_card_info->card_info.rca << 16, 0);
+           memcpy(&g_card_info->card_info.csd, &g_card_info->card_info.response[0], 16);
+           state = 100;
+           break;
+
+       default:
+           state += 100;   /* break from while loop */
+           break;
+       }
+   }
+
+   /* Compute card size, block size and no. of blocks  based on CSD response recived. */
+   if (prv_card_acquired()) {
+       prv_process_csd(pSDMMC);
+
+       /* Setup card data width and block size (once) */
+       if (prv_set_trans_state(pSDMMC) != 0) {
+           return 0;
+       }
+       if (prv_set_card_params(pSDMMC) != 0) {
+           return 0;
+       }
+   }
+
+   return prv_card_acquired();
+}
+
+/* Get the device size of SD/MMC card (after enumeration) */
+uint64_t Chip_SDMMC_GetDeviceSize(LPC_SDMMC_T *pSDMMC)
+{
+   return g_card_info->card_info.device_size;
+}
+
+/* Get the number of blocks in SD/MMC card (after enumeration) */
+int32_t Chip_SDMMC_GetDeviceBlocks(LPC_SDMMC_T *pSDMMC)
+{
+   return g_card_info->card_info.blocknr;
+}
+
+/* Performs the read of data from the SD/MMC card */
+int32_t Chip_SDMMC_ReadBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks)
+{
+   int32_t cbRead = (num_blocks) * MMC_SECTOR_SIZE;
+   int32_t status = 0;
+   int32_t index;
+
+   /* if card is not acquired return immediately */
+   if (( start_block < 0) || ( (start_block + num_blocks) > g_card_info->card_info.blocknr) ) {
+       return 0;
+   }
+
+   /* put card in trans state */
+   if (prv_set_trans_state(pSDMMC) != 0) {
+       return 0;
+   }
+
+   /* set number of bytes to read */
+   Chip_SDIF_SetByteCnt(pSDMMC, cbRead);
+
+   /* if high capacity card use block indexing */
+   if (g_card_info->card_info.card_type & CARD_TYPE_HC) {
+       index = start_block;
+   }
+   else {  /*fix at 512 bytes*/
+       index = start_block << 9;   // \* g_card_info->card_info.block_len;
+
+   }
+   Chip_SDIF_DmaSetup(pSDMMC, &g_card_info->sdif_dev, (uint32_t) buffer, cbRead);
+
+   /* Select single or multiple read based on number of blocks */
+   if (num_blocks == 1) {
+       status = sdmmc_execute_command(pSDMMC, CMD_READ_SINGLE, index, 0 | MCI_INT_DATA_OVER);
+   }
+   else {
+       status = sdmmc_execute_command(pSDMMC, CMD_READ_MULTIPLE, index, 0 | MCI_INT_DATA_OVER);
+   }
+
+   if (status != 0) {
+       cbRead = 0;
+   }
+   /*Wait for card program to finish*/
+   while (Chip_SDMMC_GetState(pSDMMC) != SDMMC_TRAN_ST) {}
+
+   return cbRead;
+}
+
+/* Performs write of data to the SD/MMC card */
+int32_t Chip_SDMMC_WriteBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks)
+{
+   int32_t cbWrote = num_blocks *  MMC_SECTOR_SIZE;
+   int32_t status;
+   int32_t index;
+
+   /* if card is not acquired return immediately */
+   if (( start_block < 0) || ( (start_block + num_blocks) > g_card_info->card_info.blocknr) ) {
+       return 0;
+   }
+
+   /*Wait for card program to finish*/
+   while (Chip_SDMMC_GetState(pSDMMC) != SDMMC_TRAN_ST) {}
+
+   /* put card in trans state */
+   if (prv_set_trans_state(pSDMMC) != 0) {
+       return 0;
+   }
+
+   /* set number of bytes to write */
+   Chip_SDIF_SetByteCnt(pSDMMC, cbWrote);
+
+   /* if high capacity card use block indexing */
+   if (g_card_info->card_info.card_type & CARD_TYPE_HC) {
+       index = start_block;
+   }
+   else {  /*fix at 512 bytes*/
+       index = start_block << 9;   // * g_card_info->card_info.block_len;
+
+   }
+
+   Chip_SDIF_DmaSetup(pSDMMC, &g_card_info->sdif_dev, (uint32_t) buffer, cbWrote);
+
+   /* Select single or multiple write based on number of blocks */
+   if (num_blocks == 1) {
+       status = sdmmc_execute_command(pSDMMC, CMD_WRITE_SINGLE, index, 0 | MCI_INT_DATA_OVER);
+   }
+   else {
+       status = sdmmc_execute_command(pSDMMC, CMD_WRITE_MULTIPLE, index, 0 | MCI_INT_DATA_OVER);
+   }
+
+   /*Wait for card program to finish*/
+   while (Chip_SDMMC_GetState(pSDMMC) != SDMMC_TRAN_ST) {}
+
+   if (status != 0) {
+       cbWrote = 0;
+   }
+
+   return cbWrote;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/spi_18xx_43xx.c ./lpc_chip_43xx/src/spi_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/spi_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/spi_18xx_43xx.c	2018-01-19 23:55:10.992318876 -0300
@@ -0,0 +1,227 @@
+/*
+ * @brief LPC43xx SPI driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+#if defined(CHIP_LPC43XX)
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Execute callback function */
+STATIC void executeCallback(LPC_SPI_T *pSPI, SPI_CALLBACK_T pfunc)
+{
+   if (pfunc) {
+       (pfunc) ();
+   }
+}
+
+/* Write byte(s) to FIFO buffer */
+STATIC void writeData(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup, uint32_t num_bytes)
+{
+   uint16_t data2write = 0xFFFF;
+
+   if ( pXfSetup->pTxData) {
+       data2write =  pXfSetup->pTxData[pXfSetup->cnt];
+       if (num_bytes == 2) {
+           data2write |= pXfSetup->pTxData[pXfSetup->cnt + 1] << 8;
+       }
+   }
+
+   Chip_SPI_SendFrame(pSPI, data2write);
+
+}
+
+/* Read byte(s) from FIFO buffer */
+STATIC void readData(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup, uint16_t rDat, uint32_t num_bytes)
+{
+   rDat = Chip_SPI_ReceiveFrame(pSPI);
+   if (pXfSetup->pRxData) {
+       pXfSetup->pRxData[pXfSetup->cnt] = rDat;
+       if (num_bytes == 2) {
+           pXfSetup->pRxData[pXfSetup->cnt + 1] = rDat >> 8;
+       }
+   }
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* SPI Polling Read/Write in blocking mode */
+uint32_t Chip_SPI_RWFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
+{
+   uint32_t status;
+   uint16_t rDat = 0x0000;
+   uint8_t bytes = 1;
+
+   /* Clear status */
+   Chip_SPI_Int_FlushData(pSPI);
+
+   if (Chip_SPI_GetDataSize(pSPI) != SPI_BITS_8) {
+       bytes = 2;
+   }
+
+   executeCallback(pSPI, pXfSetup->fnBefTransfer);
+
+   while (pXfSetup->cnt < pXfSetup->length) {
+
+       executeCallback(pSPI, pXfSetup->fnBefFrame);
+
+       /* write data to buffer */
+       writeData(pSPI, pXfSetup, bytes);
+
+       /* Wait for transfer completes */
+       while (1) {
+           status = Chip_SPI_GetStatus(pSPI);
+           /* Check error */
+           if (status & SPI_SR_ERROR) {
+               goto rw_end;
+           }
+           if (status & SPI_SR_SPIF) {
+               break;
+           }
+       }
+
+       executeCallback(pSPI, pXfSetup->fnAftFrame);
+
+       /* Read data*/
+       readData(pSPI, pXfSetup, rDat, bytes);
+       pXfSetup->cnt += bytes;
+   }
+
+rw_end:
+   executeCallback(pSPI, pXfSetup->fnAftTransfer);
+   return pXfSetup->cnt;
+}
+
+/* Clean all data in RX FIFO of SPI */
+void Chip_SPI_Int_FlushData(LPC_SPI_T *pSPI)
+{
+   volatile uint32_t tmp;
+   Chip_SPI_GetStatus(pSPI);
+   tmp = Chip_SPI_ReceiveFrame(pSPI);
+   Chip_SPI_Int_ClearStatus(pSPI, SPI_INT_SPIF);
+}
+
+/* SPI Interrupt Read/Write with 8-bit frame width */
+Status Chip_SPI_Int_RWFrames(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup, uint8_t bytes)
+{
+   uint32_t status;
+   uint16_t rDat = 0x0000;
+
+   status = Chip_SPI_GetStatus(pSPI);
+   /* Check error status */
+   if (status & SPI_SR_ERROR) {
+       return ERROR;
+   }
+
+   Chip_SPI_Int_ClearStatus(pSPI, SPI_INT_SPIF);
+   if (status & SPI_SR_SPIF) {
+       executeCallback(pSPI, pXfSetup->fnAftFrame);
+       if (pXfSetup->cnt < pXfSetup->length) {
+           /* read data */
+           readData(pSPI, pXfSetup, rDat, bytes);
+           pXfSetup->cnt += bytes;
+       }
+   }
+
+   if (pXfSetup->cnt < pXfSetup->length) {
+
+       executeCallback(pSPI, pXfSetup->fnBefFrame);
+
+       /* Write data  */
+       writeData(pSPI, pXfSetup, bytes);
+   }
+   else {
+       executeCallback(pSPI, pXfSetup->fnAftTransfer);
+   }
+   return SUCCESS;
+}
+
+/* SPI Interrupt Read/Write with 8-bit frame width */
+Status Chip_SPI_Int_RWFrames8Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
+{
+   return Chip_SPI_Int_RWFrames(pSPI, pXfSetup, 1);
+}
+
+/* SPI Interrupt Read/Write with 16-bit frame width */
+Status Chip_SPI_Int_RWFrames16Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
+{
+   return Chip_SPI_Int_RWFrames(pSPI, pXfSetup, 2);
+}
+
+/* Set the clock frequency for SPI interface */
+void Chip_SPI_SetBitRate(LPC_SPI_T *pSPI, uint32_t bitRate)
+{
+   uint32_t spiClk, counter;
+   /* Get SPI clock rate */
+   spiClk = Chip_Clock_GetRate(CLK_SPI);
+
+   counter = spiClk / bitRate;
+   if (counter < 8) {
+       counter = 8;
+   }
+   counter = ((counter + 1) / 2) * 2;
+
+   if (counter > 254) {
+       counter = 254;
+   }
+
+   Chip_SPI_SetClockCounter(pSPI, counter);
+}
+
+/* Initialize the SPI */
+void Chip_SPI_Init(LPC_SPI_T *pSPI)
+{
+   Chip_Clock_Enable(CLK_SPI);
+
+   Chip_SPI_SetMode(pSPI, SPI_MODE_MASTER);
+   pSPI->CR = (pSPI->CR & (~0xF1C)) | SPI_CR_BIT_EN | SPI_BITS_8 | SPI_CLOCK_CPHA0_CPOL0 | SPI_DATA_MSB_FIRST;
+   Chip_SPI_SetBitRate(pSPI, 400000);
+}
+
+/* De-initializes the SPI peripheral */
+void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
+{
+   Chip_Clock_Disable(CLK_SPI);
+}
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/ssp_18xx_43xx.c ./lpc_chip_43xx/src/ssp_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/ssp_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/ssp_18xx_43xx.c	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,469 @@
+/*
+ * @brief LPC18xx/43xx SSP driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+STATIC void SSP_Write2BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   if (xf_setup->tx_data) {
+       Chip_SSP_SendFrame(pSSP, (*(uint16_t *) ((uint32_t) xf_setup->tx_data +
+                                                xf_setup->tx_cnt)));
+   }
+   else {
+       Chip_SSP_SendFrame(pSSP, 0xFFFF);
+   }
+
+   xf_setup->tx_cnt += 2;
+}
+
+/** SSP macro: write 1 bytes to FIFO buffer */
+STATIC void SSP_Write1BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   if (xf_setup->tx_data) {
+       Chip_SSP_SendFrame(pSSP, (*(uint8_t *) ((uint32_t) xf_setup->tx_data + xf_setup->tx_cnt)));
+   }
+   else {
+       Chip_SSP_SendFrame(pSSP, 0xFF);
+   }
+
+   xf_setup->tx_cnt++;
+}
+
+/** SSP macro: read 1 bytes from FIFO buffer */
+STATIC void SSP_Read2BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   uint16_t rDat;
+
+   while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET) &&
+          (xf_setup->rx_cnt < xf_setup->length)) {
+       rDat = Chip_SSP_ReceiveFrame(pSSP);
+       if (xf_setup->rx_data) {
+           *(uint16_t *) ((uint32_t) xf_setup->rx_data + xf_setup->rx_cnt) = rDat;
+       }
+
+       xf_setup->rx_cnt += 2;
+   }
+}
+
+/** SSP macro: read 2 bytes from FIFO buffer */
+STATIC void SSP_Read1BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   uint16_t rDat;
+
+   while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET) &&
+          (xf_setup->rx_cnt < xf_setup->length)) {
+       rDat = Chip_SSP_ReceiveFrame(pSSP);
+       if (xf_setup->rx_data) {
+           *(uint8_t *) ((uint32_t) xf_setup->rx_data + xf_setup->rx_cnt) = rDat;
+       }
+
+       xf_setup->rx_cnt++;
+   }
+}
+
+/* Returns clock index for the register interface */
+STATIC CHIP_CCU_CLK_T Chip_SSP_GetClockIndex(LPC_SSP_T *pSSP)
+{
+   CHIP_CCU_CLK_T clkSSP;
+
+   if (pSSP == LPC_SSP1) {
+       clkSSP = CLK_MX_SSP1;
+   }
+   else {
+       clkSSP = CLK_MX_SSP0;
+   }
+
+   return clkSSP;
+}
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_SSP_GetPeriphClockIndex(LPC_SSP_T *pSSP)
+{
+   CHIP_CCU_CLK_T clkSSP;
+
+   if (pSSP == LPC_SSP1) {
+       clkSSP = CLK_APB2_SSP1;
+   }
+   else {
+       clkSSP = CLK_APB0_SSP0;
+   }
+
+   return clkSSP;
+}
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/*Set up output clocks per bit for SSP bus*/
+void Chip_SSP_SetClockRate(LPC_SSP_T *pSSP, uint32_t clk_rate, uint32_t prescale)
+{
+   uint32_t temp;
+   temp = pSSP->CR0 & (~(SSP_CR0_SCR(0xFF)));
+   pSSP->CR0 = temp | (SSP_CR0_SCR(clk_rate));
+   pSSP->CPSR = prescale;
+}
+
+/* SSP Polling Read/Write in blocking mode */
+uint32_t Chip_SSP_RWFrames_Blocking(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   /* Clear all remaining frames in RX FIFO */
+   while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+       Chip_SSP_ReceiveFrame(pSSP);
+   }
+
+   /* Clear status */
+   Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+
+   if (Chip_SSP_GetDataSize(pSSP) > SSP_BITS_8) {
+       while (xf_setup->rx_cnt < xf_setup->length || xf_setup->tx_cnt < xf_setup->length) {
+           /* write data to buffer */
+           if (( Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && ( xf_setup->tx_cnt < xf_setup->length) ) {
+               SSP_Write2BFifo(pSSP, xf_setup);
+           }
+
+           /* Check overrun error */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /* Check for any data available in RX FIFO */
+           SSP_Read2BFifo(pSSP, xf_setup);
+       }
+   }
+   else {
+       while (xf_setup->rx_cnt < xf_setup->length || xf_setup->tx_cnt < xf_setup->length) {
+           /* write data to buffer */
+           if (( Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && ( xf_setup->tx_cnt < xf_setup->length) ) {
+               SSP_Write1BFifo(pSSP, xf_setup);
+           }
+
+           /* Check overrun error */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /* Check for any data available in RX FIFO */
+           SSP_Read1BFifo(pSSP, xf_setup);
+       }
+   }
+   if (xf_setup->tx_data) {
+       return xf_setup->tx_cnt;
+   }
+   else if (xf_setup->rx_data) {
+       return xf_setup->rx_cnt;
+   }
+
+   return 0;
+}
+
+/* SSP Polling Write in blocking mode */
+uint32_t Chip_SSP_WriteFrames_Blocking(LPC_SSP_T *pSSP, const uint8_t *buffer, uint32_t buffer_len)
+{
+   uint32_t tx_cnt = 0, rx_cnt = 0;
+
+   /* Clear all remaining frames in RX FIFO */
+   while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+       Chip_SSP_ReceiveFrame(pSSP);
+   }
+
+   /* Clear status */
+   Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+
+   if (Chip_SSP_GetDataSize(pSSP) > SSP_BITS_8) {
+       uint16_t *wdata16;
+
+       wdata16 = (uint16_t *) buffer;
+
+       while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+           /* write data to buffer */
+           if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+               Chip_SSP_SendFrame(pSSP, *wdata16);
+               wdata16++;
+               tx_cnt += 2;
+           }
+
+           /* Check overrun error */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /* Check for any data available in RX FIFO */
+           while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET) {
+               Chip_SSP_ReceiveFrame(pSSP);    /* read dummy data */
+               rx_cnt += 2;
+           }
+       }
+   }
+   else {
+       const uint8_t *wdata8;
+
+       wdata8 = buffer;
+
+       while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+           /* write data to buffer */
+           if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+               Chip_SSP_SendFrame(pSSP, *wdata8);
+               wdata8++;
+               tx_cnt++;
+           }
+
+           /* Check overrun error */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /* Check for any data available in RX FIFO */
+           while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET && rx_cnt < buffer_len) {
+               Chip_SSP_ReceiveFrame(pSSP);    /* read dummy data */
+               rx_cnt++;
+           }
+       }
+   }
+
+   return tx_cnt;
+
+}
+
+/* SSP Polling Read in blocking mode */
+uint32_t Chip_SSP_ReadFrames_Blocking(LPC_SSP_T *pSSP, uint8_t *buffer, uint32_t buffer_len)
+{
+   uint32_t rx_cnt = 0, tx_cnt = 0;
+
+   /* Clear all remaining frames in RX FIFO */
+   while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+       Chip_SSP_ReceiveFrame(pSSP);
+   }
+
+   /* Clear status */
+   Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+
+   if (Chip_SSP_GetDataSize(pSSP) > SSP_BITS_8) {
+       uint16_t *rdata16;
+
+       rdata16 = (uint16_t *) buffer;
+
+       while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+           /* write data to buffer */
+           if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+               Chip_SSP_SendFrame(pSSP, 0xFFFF);   /* just send dummy data */
+               tx_cnt += 2;
+           }
+
+           /* Check overrun error */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /* Check for any data available in RX FIFO */
+           while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET && rx_cnt < buffer_len) {
+               *rdata16 = Chip_SSP_ReceiveFrame(pSSP);
+               rdata16++;
+               rx_cnt += 2;
+           }
+       }
+   }
+   else {
+       uint8_t *rdata8;
+
+       rdata8 = buffer;
+
+       while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+           /* write data to buffer */
+           if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+               Chip_SSP_SendFrame(pSSP, 0xFF); /* just send dummy data      */
+               tx_cnt++;
+           }
+
+           /* Check overrun error */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /* Check for any data available in RX FIFO */
+           while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET && rx_cnt < buffer_len) {
+               *rdata8 = Chip_SSP_ReceiveFrame(pSSP);
+               rdata8++;
+               rx_cnt++;
+           }
+       }
+   }
+
+   return rx_cnt;
+
+}
+
+/* Clean all data in RX FIFO of SSP */
+void Chip_SSP_Int_FlushData(LPC_SSP_T *pSSP)
+{
+   if (Chip_SSP_GetStatus(pSSP, SSP_STAT_BSY)) {
+       while (Chip_SSP_GetStatus(pSSP, SSP_STAT_BSY)) {}
+   }
+
+   /* Clear all remaining frames in RX FIFO */
+   while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+       Chip_SSP_ReceiveFrame(pSSP);
+   }
+
+   /* Clear status */
+   Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+}
+
+/* SSP Interrupt Read/Write with 8-bit frame width */
+Status Chip_SSP_Int_RWFrames8Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   /* Check overrun error in RIS register */
+   if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+       return ERROR;
+   }
+
+   if ((xf_setup->tx_cnt != xf_setup->length) || (xf_setup->rx_cnt != xf_setup->length)) {
+       /* check if RX FIFO contains data */
+       SSP_Read1BFifo(pSSP, xf_setup);
+
+       while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF)) && (xf_setup->tx_cnt != xf_setup->length)) {
+           /* Write data to buffer */
+           SSP_Write1BFifo(pSSP, xf_setup);
+
+           /* Check overrun error in RIS register */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /*  Check for any data available in RX FIFO */
+           SSP_Read1BFifo(pSSP, xf_setup);
+       }
+
+       return SUCCESS;
+   }
+
+   return ERROR;
+}
+
+/* SSP Interrupt Read/Write with 16-bit frame width */
+Status Chip_SSP_Int_RWFrames16Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+   /* Check overrun error in RIS register */
+   if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+       return ERROR;
+   }
+
+   if ((xf_setup->tx_cnt != xf_setup->length) || (xf_setup->rx_cnt != xf_setup->length)) {
+       /* check if RX FIFO contains data */
+       SSP_Read2BFifo(pSSP, xf_setup);
+
+       while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF)) && (xf_setup->tx_cnt != xf_setup->length)) {
+           /* Write data to buffer */
+           SSP_Write2BFifo(pSSP, xf_setup);
+
+           /* Check overrun error in RIS register */
+           if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+               return ERROR;
+           }
+
+           /*  Check for any data available in RX FIFO          */
+           SSP_Read2BFifo(pSSP, xf_setup);
+       }
+
+       return SUCCESS;
+   }
+
+   return ERROR;
+}
+
+/* Set the SSP operating modes, master or slave */
+void Chip_SSP_SetMaster(LPC_SSP_T *pSSP, bool master)
+{
+   if (master) {
+       Chip_SSP_Set_Mode(pSSP, SSP_MODE_MASTER);
+   }
+   else {
+       Chip_SSP_Set_Mode(pSSP, SSP_MODE_SLAVE);
+   }
+}
+
+/* Set the clock frequency for SSP interface */
+void Chip_SSP_SetBitRate(LPC_SSP_T *pSSP, uint32_t bitRate)
+{
+   uint32_t ssp_clk, cr0_div, cmp_clk, prescale;
+
+   ssp_clk = Chip_Clock_GetRate(Chip_SSP_GetPeriphClockIndex(pSSP));
+
+   cr0_div = 0;
+   cmp_clk = 0xFFFFFFFF;
+   prescale = 2;
+
+   while (cmp_clk > bitRate) {
+       cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
+       if (cmp_clk > bitRate) {
+           cr0_div++;
+           if (cr0_div > 0xFF) {
+               cr0_div = 0;
+               prescale += 2;
+           }
+       }
+   }
+
+   Chip_SSP_SetClockRate(pSSP, cr0_div, prescale);
+}
+
+/* Initialize the SSP */
+void Chip_SSP_Init(LPC_SSP_T *pSSP)
+{
+   Chip_Clock_Enable(Chip_SSP_GetClockIndex(pSSP));
+   Chip_Clock_Enable(Chip_SSP_GetPeriphClockIndex(pSSP));
+
+   Chip_SSP_Set_Mode(pSSP, SSP_MODE_MASTER);
+   Chip_SSP_SetFormat(pSSP, SSP_BITS_8, SSP_FRAMEFORMAT_SPI, SSP_CLOCK_CPHA0_CPOL0);
+   Chip_SSP_SetBitRate(pSSP, 100000);
+}
+
+/* De-initializes the SSP peripheral */
+void Chip_SSP_DeInit(LPC_SSP_T *pSSP)
+{
+   Chip_SSP_Disable(pSSP);
+
+   Chip_Clock_Disable(Chip_SSP_GetPeriphClockIndex(pSSP));
+   Chip_Clock_Disable(Chip_SSP_GetClockIndex(pSSP));
+
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/stopwatch_18xx_43xx.c ./lpc_chip_43xx/src/stopwatch_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/stopwatch_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/stopwatch_18xx_43xx.c	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,106 @@
+/*
+ * @brief LPC18xx/43xx specific stopwatch implementation
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "stopwatch.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Precompute these to optimize runtime */
+static uint32_t ticksPerSecond;
+static uint32_t ticksPerMs;
+static uint32_t ticksPerUs;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize stopwatch */
+void StopWatch_Init(void)
+{
+   /* Use timer 1. Set prescaler to divide by 8 */
+   const uint32_t prescaleDivisor = 8;
+   Chip_TIMER_Init(LPC_TIMER0);
+   Chip_TIMER_PrescaleSet(LPC_TIMER0, prescaleDivisor - 1);
+   Chip_TIMER_Enable(LPC_TIMER0);
+
+   /* Pre-compute tick rate. */
+   ticksPerSecond = Chip_Clock_GetRate(CLK_MX_TIMER0) / prescaleDivisor;
+   ticksPerMs = ticksPerSecond / 1000;
+   ticksPerUs = ticksPerSecond / 1000000;
+}
+
+/* Start a stopwatch */
+uint32_t StopWatch_Start(void)
+{
+   /* Return the current timer count. */
+   return Chip_TIMER_ReadCount(LPC_TIMER0);
+}
+
+/* Returns number of ticks per second of the stopwatch timer */
+uint32_t StopWatch_TicksPerSecond(void)
+{
+   return ticksPerSecond;
+}
+
+/* Converts from stopwatch ticks to mS. */
+uint32_t StopWatch_TicksToMs(uint32_t ticks)
+{
+   return ticks / ticksPerMs;
+}
+
+/* Converts from stopwatch ticks to uS. */
+uint32_t StopWatch_TicksToUs(uint32_t ticks)
+{
+   return ticks / ticksPerUs;
+}
+
+/* Converts from mS to stopwatch ticks. */
+uint32_t StopWatch_MsToTicks(uint32_t mS)
+{
+   return mS * ticksPerMs;
+}
+
+/* Converts from uS to stopwatch ticks. */
+uint32_t StopWatch_UsToTicks(uint32_t uS)
+{
+   return uS * ticksPerUs;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/sysinit_18xx_43xx.c ./lpc_chip_43xx/src/sysinit_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/sysinit_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/sysinit_18xx_43xx.c	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,162 @@
+/*
+ * @brief LPC18xx/LPC43xx Chip specific SystemInit
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Structure for initial base clock states */
+struct CLK_BASE_STATES {
+   CHIP_CGU_BASE_CLK_T clk;    /* Base clock */
+   CHIP_CGU_CLKIN_T clkin; /* Base clock source, see UM for allowable souorces per base clock */
+   bool autoblock_enab;    /* Set to true to enable autoblocking on frequency change */
+   bool powerdn;           /* Set to true if the base clock is initially powered down */
+};
+
+static const struct CLK_BASE_STATES InitClkStates[] = {
+   {CLK_BASE_SAFE, CLKIN_IRC, true, false},
+   {CLK_BASE_APB1, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_APB3, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_USB0, CLKIN_USBPLL, true, true},
+#if defined(CHIP_LPC43XX)
+   {CLK_BASE_PERIPH, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_SPI, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_ADCHS, CLKIN_MAINPLL, true, true},
+#endif
+   {CLK_BASE_SDIO, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_SSP0, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_SSP1, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_UART0, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_UART1, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_UART2, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_UART3, CLKIN_MAINPLL, true, false},
+   {CLK_BASE_OUT, CLKINPUT_PD, true, false},
+   {CLK_BASE_APLL, CLKINPUT_PD, true, false},
+   {CLK_BASE_CGU_OUT0, CLKINPUT_PD, true, false},
+   {CLK_BASE_CGU_OUT1, CLKINPUT_PD, true, false},
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Setup Chip Core clock */
+void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
+{
+   int i;
+   volatile uint32_t delay = 5500;
+   uint32_t direct = 0;
+   PLL_PARAM_T ppll;
+
+   if (clkin == CLKIN_CRYSTAL) {
+       /* Switch main system clocking to crystal */
+       Chip_Clock_EnableCrystal();
+   }
+   Chip_Clock_SetBaseClock(CLK_BASE_MX, clkin, true, false);
+   Chip_Clock_DisableMainPLL(); /* Disable PLL */
+
+   /* Calculate the PLL Parameters */
+   ppll.srcin = clkin;
+   Chip_Clock_CalcMainPLLValue(core_freq, &ppll);
+
+   if (core_freq > 110000000UL) {
+       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
+           PLL_PARAM_T lpll;
+           /* Calculate the PLL Parameters */
+           lpll.srcin = clkin;
+           Chip_Clock_CalcMainPLLValue(110000000UL, &lpll);
+           Chip_Clock_SetupMainPLL(&lpll);
+           /* Wait for the PLL to lock */
+           while(!Chip_Clock_MainPLLLocked()) {}
+           Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
+           while(delay --){}
+           delay = 5500;
+       } else {
+           direct = 1;
+           ppll.ctrl &= ~(1 << 7);
+       }
+   }
+
+   /* Setup and start the PLL */
+   Chip_Clock_SetupMainPLL(&ppll);
+
+   /* Wait for the PLL to lock */
+   while(!Chip_Clock_MainPLLLocked()) {}
+
+   /* Set core clock base as PLL1 */
+   Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
+
+   while(delay --){} /* Wait for approx 50 uSec */
+   if (direct) {
+       delay = 5500;
+       ppll.ctrl |= 1 << 7;
+       Chip_Clock_SetupMainPLL(&ppll); /* Set DIRECT to operate at full frequency */
+       while(delay --){} /* Wait for approx 50 uSec */
+   }
+
+   if (setbase) {
+       /* Setup system base clocks and initial states. This won't enable and
+          disable individual clocks, but sets up the base clock sources for
+          each individual peripheral clock. */
+       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
+           Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
+                                   InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
+       }
+   }
+}
+
+/* Setup system clocking */
+void Chip_SetupXtalClocking(void)
+{
+   Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Chip_SetupIrcClocking(void)
+{
+   Chip_SetupCoreClock(CLKIN_IRC, MAX_CLOCK_FREQ, true);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Chip_SystemInit(void)
+{
+   /* Initial internal clocking */
+   Chip_SetupIrcClocking();
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/timer_18xx_43xx.c ./lpc_chip_43xx/src/timer_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/timer_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/timer_18xx_43xx.c	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,117 @@
+/*
+ * @brief LPC18xx/43xx 16/32-bit Timer/PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_TIMER_GetClockIndex(LPC_TIMER_T *pTMR)
+{
+   CHIP_CCU_CLK_T clkTMR;
+
+   if (pTMR == LPC_TIMER3) {
+       clkTMR = CLK_MX_TIMER3;
+   }
+    else if (pTMR == LPC_TIMER2) {
+       clkTMR = CLK_MX_TIMER2;
+   }
+    else if (pTMR == LPC_TIMER1) {
+       clkTMR = CLK_MX_TIMER1;
+   }
+   else {
+       clkTMR = CLK_MX_TIMER0;
+   }
+
+   return clkTMR;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize a timer */
+void Chip_TIMER_Init(LPC_TIMER_T *pTMR)
+{
+   Chip_Clock_Enable(Chip_TIMER_GetClockIndex(pTMR));
+}
+
+/* Shutdown a timer */
+void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR)
+{
+   Chip_Clock_Disable(Chip_TIMER_GetClockIndex(pTMR));
+}
+
+/* Resets the timer terminal and prescale counts to 0 */
+void Chip_TIMER_Reset(LPC_TIMER_T *pTMR)
+{
+   uint32_t reg;
+
+   /* Disable timer, set terminal count to non-0 */
+   reg = pTMR->TCR;
+   pTMR->TCR = 0;
+   pTMR->TC = 1;
+
+   /* Reset timer counter */
+   pTMR->TCR = TIMER_RESET;
+
+   /* Wait for terminal count to clear */
+   while (pTMR->TC != 0) {}
+
+   /* Restore timer state */
+   pTMR->TCR = reg;
+}
+
+/* Sets external match control (MATn.matchnum) pin control */
+void Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
+                                  TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum)
+{
+   uint32_t mask, reg;
+
+   /* Clear bits corresponding to selected match register */
+   mask = (1 << matchnum) | (0x03 << (4 + (matchnum * 2)));
+   reg = pTMR->EMR &= ~mask;
+
+   /* Set new configuration for selected match register */
+   pTMR->EMR = reg | (((uint32_t) initial_state) << matchnum) |
+               (((uint32_t) matchState) << (4 + (matchnum * 2)));
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/uart_18xx_43xx.c ./lpc_chip_43xx/src/uart_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/uart_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/uart_18xx_43xx.c	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,424 @@
+/*
+ * @brief LPC18xx/43xx UART chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Autobaud status flag */
+STATIC volatile FlagStatus ABsyncSts = RESET;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+ /* UART Peripheral clocks */
+static const CHIP_CCU_CLK_T UART_PClock[] = {CLK_MX_UART0, CLK_MX_UART1, CLK_MX_UART2, CLK_MX_UART3};
+
+/* UART Bus clocks */
+static const CHIP_CCU_CLK_T UART_BClock[] = {CLK_APB0_UART0, CLK_APB0_UART1, CLK_APB2_UART2, CLK_APB2_UART3};
+
+/* Returns clock index for the peripheral block */
+static int Chip_UART_GetIndex(LPC_USART_T *pUART)
+{
+   uint32_t base = (uint32_t) pUART;
+   switch(base) {
+       case LPC_USART0_BASE:
+           return 0;
+       case LPC_UART1_BASE:
+           return 1;
+       case LPC_USART2_BASE:
+           return 2;
+       case LPC_USART3_BASE:
+           return 3;
+       default:
+           return 0; /* Should never come here */
+   }
+}
+
+/* UART Autobaud command interrupt handler */
+STATIC void Chip_UART_ABIntHandler(LPC_USART_T *pUART)
+{
+   /* Handle End Of Autobaud interrupt */
+   if((Chip_UART_ReadIntIDReg(pUART) & UART_IIR_ABEO_INT) != 0) {
+        Chip_UART_SetAutoBaudReg(pUART, UART_ACR_ABEOINT_CLR);
+       Chip_UART_IntDisable(pUART, UART_IER_ABEOINT);
+       if (ABsyncSts == RESET) {
+           ABsyncSts = SET;
+        }
+   }
+
+    /* Handle Autobaud Timeout interrupt */
+   if((Chip_UART_ReadIntIDReg(pUART) & UART_IIR_ABTO_INT) != 0) {
+        Chip_UART_SetAutoBaudReg(pUART, UART_ACR_ABTOINT_CLR);
+       Chip_UART_IntDisable(pUART, UART_IER_ABTOINT);
+   }
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the pUART peripheral */
+void Chip_UART_Init(LPC_USART_T *pUART)
+{
+    volatile uint32_t tmp;
+
+   /* Enable UART clocking. UART base clock(s) must already be enabled */
+   Chip_Clock_EnableOpts(UART_PClock[Chip_UART_GetIndex(pUART)], true, true, 1);
+
+   /* Enable FIFOs by default, reset them */
+   Chip_UART_SetupFIFOS(pUART, (UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS));
+
+    /* Disable Tx */
+    Chip_UART_TXDisable(pUART);
+
+    /* Disable interrupts */
+   pUART->IER = 0;
+   /* Set LCR to default state */
+   pUART->LCR = 0;
+   /* Set ACR to default state */
+   pUART->ACR = 0;
+    /* Set RS485 control to default state */
+   pUART->RS485CTRL = 0;
+   /* Set RS485 delay timer to default state */
+   pUART->RS485DLY = 0;
+   /* Set RS485 addr match to default state */
+   pUART->RS485ADRMATCH = 0;
+
+    /* Clear MCR */
+    if (pUART == LPC_UART1) {
+       /* Set Modem Control to default state */
+       pUART->MCR = 0;
+       /*Dummy Reading to Clear Status */
+       tmp = pUART->MSR;
+   }
+
+   /* Default 8N1, with DLAB disabled */
+   Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));
+
+   /* Disable fractional divider */
+   pUART->FDR = 0x10;
+}
+
+/* De-initializes the pUART peripheral */
+void Chip_UART_DeInit(LPC_USART_T *pUART)
+{
+    /* Disable Tx */
+    Chip_UART_TXDisable(pUART);
+
+    /* Disable clock */
+   Chip_Clock_Disable(UART_PClock[Chip_UART_GetIndex(pUART)]);
+}
+
+/* Transmit a byte array through the UART peripheral (non-blocking) */
+int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes)
+{
+   int sent = 0;
+   uint8_t *p8 = (uint8_t *) data;
+
+   /* Send until the transmit FIFO is full or out of bytes */
+   while ((sent < numBytes) &&
+          ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_THRE) != 0)) {
+       Chip_UART_SendByte(pUART, *p8);
+       p8++;
+       sent++;
+   }
+
+   return sent;
+}
+
+/* Check whether if UART is busy or not */
+FlagStatus Chip_UART_CheckBusy(LPC_USART_T *pUART)
+{
+   if (pUART->LSR & UART_LSR_TEMT) {
+       return RESET;
+   }
+   else {
+       return SET;
+   }
+}
+
+/* Transmit a byte array through the UART peripheral (blocking) */
+int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
+{
+   int pass, sent = 0;
+   uint8_t *p8 = (uint8_t *) data;
+
+   while (numBytes > 0) {
+       pass = Chip_UART_Send(pUART, p8, numBytes);
+       numBytes -= pass;
+       sent += pass;
+       p8 += pass;
+   }
+
+   return sent;
+}
+
+/* Read data through the UART peripheral (non-blocking) */
+int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes)
+{
+   int readBytes = 0;
+   uint8_t *p8 = (uint8_t *) data;
+
+   /* Send until the transmit FIFO is full or out of bytes */
+   while ((readBytes < numBytes) &&
+          ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_RDR) != 0)) {
+       *p8 = Chip_UART_ReadByte(pUART);
+       p8++;
+       readBytes++;
+   }
+
+   return readBytes;
+}
+
+/* Read data through the UART peripheral (blocking) */
+int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes)
+{
+   int pass, readBytes = 0;
+   uint8_t *p8 = (uint8_t *) data;
+
+   while (readBytes < numBytes) {
+       pass = Chip_UART_Read(pUART, p8, numBytes);
+       numBytes -= pass;
+       readBytes += pass;
+       p8 += pass;
+   }
+
+   return readBytes;
+}
+
+/* Determines and sets best dividers to get a target bit rate */
+uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
+{
+   uint32_t div, divh, divl, clkin;
+
+   /* Determine UART clock in rate without FDR */
+   clkin = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
+   div = clkin / (baudrate * 16);
+
+   /* High and low halves of the divider */
+   divh = div / 256;
+   divl = div - (divh * 256);
+
+   Chip_UART_EnableDivisorAccess(pUART);
+   Chip_UART_SetDivisorLatches(pUART, divl, divh);
+   Chip_UART_DisableDivisorAccess(pUART);
+
+   /* Fractional FDR alreadt setup for 1 in UART init */
+
+   return clkin / div;
+}
+
+/* UART receive-only interrupt handler for ring buffers */
+void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
+{
+   /* New data will be ignored if data not popped in time */
+   while (Chip_UART_ReadLineStatus(pUART) & UART_LSR_RDR) {
+       uint8_t ch = Chip_UART_ReadByte(pUART);
+       RingBuffer_Insert(pRB, &ch);
+   }
+}
+
+/* UART transmit-only interrupt handler for ring buffers */
+void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
+{
+   uint8_t ch;
+
+   /* Fill FIFO until full or until TX ring buffer is empty */
+   while ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_THRE) != 0 &&
+          RingBuffer_Pop(pRB, &ch)) {
+       Chip_UART_SendByte(pUART, ch);
+   }
+
+   /* Turn off interrupt if the ring buffer is empty */
+   if (RingBuffer_IsEmpty(pRB)) {
+       /* Shut down transmit */
+       Chip_UART_IntDisable(pUART, UART_IER_THREINT);
+   }
+}
+
+/* Populate a transmit ring buffer and start UART transmit */
+uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int bytes)
+{
+   uint32_t ret;
+   uint8_t *p8 = (uint8_t *) data;
+
+   /* Don't let UART transmit ring buffer change in the UART IRQ handler */
+   Chip_UART_IntDisable(pUART, UART_IER_THREINT);
+
+   /* Move as much data as possible into transmit ring buffer */
+   ret = RingBuffer_InsertMult(pRB, p8, bytes);
+   Chip_UART_TXIntHandlerRB(pUART, pRB);
+
+   /* Add additional data to transmit ring buffer if possible */
+   ret += RingBuffer_InsertMult(pRB, (p8 + ret), (bytes - ret));
+
+   /* Enable UART transmit interrupt */
+   Chip_UART_IntEnable(pUART, UART_IER_THREINT);
+
+   return ret;
+}
+
+/* Copy data from a receive ring buffer */
+int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
+{
+   (void) pUART;
+
+   return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
+}
+
+/* UART receive/transmit interrupt handler for ring buffers */
+void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB)
+{
+   /* Handle transmit interrupt if enabled */
+   if (pUART->IER & UART_IER_THREINT) {
+       Chip_UART_TXIntHandlerRB(pUART, pTXRB);
+
+       /* Disable transmit interrupt if the ring buffer is empty */
+       if (RingBuffer_IsEmpty(pTXRB)) {
+           Chip_UART_IntDisable(pUART, UART_IER_THREINT);
+       }
+   }
+
+   /* Handle receive interrupt */
+   Chip_UART_RXIntHandlerRB(pUART, pRXRB);
+
+    /* Handle Autobaud interrupts */
+    Chip_UART_ABIntHandler(pUART);
+}
+
+/* Determines and sets best dividers to get a target baud rate */
+uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
+{
+   uint32_t sdiv = 0, sm = 1, sd = 0;
+   uint32_t pclk, m, d;
+   uint32_t odiff = -1UL; /* old best diff */
+
+   /* Get base clock for the corresponding UART */
+   pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
+
+   /* Loop through all possible fractional divider values */
+   for (m = 1; odiff && m < 16; m++) {
+       for (d = 0; d < m; d++) {
+           uint32_t diff, div;
+           uint64_t dval = (((uint64_t) pclk << 28) * m) / (baud * (m + d));
+
+           /* Lower 32-bit of dval has diff */
+           diff = (uint32_t) dval;
+           /* Upper 32-bit of dval has div */
+           div = (uint32_t) (dval >> 32);
+
+           /* Closer to next div */
+           if ((int)diff < 0) {
+               diff = -diff;
+               div ++;
+           }
+
+           /* Check if new value is worse than old or out of range */
+           if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
+               continue;
+           }
+
+           /* Store the new better values */
+           sdiv = div;
+           sd = d;
+           sm = m;
+           odiff = diff;
+
+           /* On perfect match, break loop */
+           if(!diff) {
+               break;
+           }
+       }
+   }
+
+   /* Return 0 if a vaild divisor is not possible */
+   if (!sdiv) {
+       return 0;
+   }
+
+   /* Update UART registers */
+   Chip_UART_EnableDivisorAccess(pUART);
+   Chip_UART_SetDivisorLatches(pUART, UART_LOAD_DLL(sdiv), UART_LOAD_DLM(sdiv));
+   Chip_UART_DisableDivisorAccess(pUART);
+
+   /* Set best fractional divider */
+   pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));
+
+   /* Return actual baud rate */
+   return (pclk >> 4) * sm / (sdiv * (sm + sd));
+}
+
+/* UART interrupt service routine */
+FlagStatus Chip_UART_GetABEOStatus(LPC_USART_T *pUART)
+{
+   (void) pUART;
+   return ABsyncSts;
+}
+
+/* Start/Stop Auto Baudrate activity */
+void Chip_UART_ABCmd(LPC_USART_T *pUART, uint32_t mode, bool autorestart, FunctionalState NewState)
+{
+    uint32_t tmp = 0;
+
+   if (NewState == ENABLE) {
+       /* Clear DLL and DLM value */
+       pUART->LCR |= UART_LCR_DLAB_EN;
+       pUART->DLL = 0;
+       pUART->DLM = 0;
+       pUART->LCR &= ~UART_LCR_DLAB_EN;
+
+       /* FDR value must be reset to default value */
+       pUART->FDR = 0x10;
+
+       if (mode == UART_ACR_MODE1) {
+           tmp = UART_ACR_START | UART_ACR_MODE;
+       }
+       else {
+           tmp = UART_ACR_START;
+       }
+
+       if (autorestart == true) {
+           tmp |= UART_ACR_AUTO_RESTART;
+       }
+       pUART->ACR = tmp;
+   }
+   else {
+       pUART->ACR = 0;
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/src/wwdt_18xx_43xx.c ./lpc_chip_43xx/src/wwdt_18xx_43xx.c
--- a_qSC69Z/lpc_chip_43xx/src/wwdt_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/src/wwdt_18xx_43xx.c	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,78 @@
+/*
+ * @brief LPC18xx/43xx WWDT driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the Watchdog timer */
+void Chip_WWDT_Init(LPC_WWDT_T *pWWDT)
+{
+   /* Disable watchdog */
+   pWWDT->MOD       = 0;
+   pWWDT->TC        = 0xFF;
+#if defined(WATCHDOG_WINDOW_SUPPORT)
+   pWWDT->WARNINT   = 0xFFFF;
+   pWWDT->WINDOW    = 0xFFFFFF;
+#endif
+}
+
+/* Shutdown the Watchdog timer */
+void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT)
+{
+}
+
+/* Clear WWDT interrupt status flags */
+void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status)
+{
+   if (status & WWDT_WDMOD_WDTOF) {
+       pWWDT->MOD &= (~WWDT_WDMOD_WDTOF) & WWDT_WDMOD_BITMASK;
+   }
+
+   if (status & WWDT_WDMOD_WDINT) {
+       pWWDT->MOD |= WWDT_WDMOD_WDINT;
+   }
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/lpc_chip_43xx/version.txt ./lpc_chip_43xx/version.txt
--- a_qSC69Z/lpc_chip_43xx/version.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./lpc_chip_43xx/version.txt	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,3 @@
+LPCOPEN VERSION: 2_16
+RELEASE DATE:
+Fri 02/20/2015
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/Makefile ./Makefile
--- a_qSC69Z/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ ./Makefile	2018-01-20 00:01:05.454294804 -0300
@@ -0,0 +1,91 @@
+include config.mk
+
+SRC=$(foreach m, $(MODULES), $(wildcard $(m)/src/*.c))
+INCLUDES=$(foreach m, $(MODULES), -I$(m)/inc)
+_DEFINES=$(foreach m, $(DEFINES), -D$(m))
+OBJECTS=$(SRC:.c=.o)
+DEPS=$(SRC:.c=.d)
+LDSCRIPT=ciaa_lpc4337.ld
+
+ARCH_FLAGS=-mcpu=cortex-m4 -mthumb
+
+TARGET=$(APP).elf
+TARGET_BIN=$(basename $(TARGET)).bin
+TARGET_LST=$(basename $(TARGET)).lst
+TARGET_MAP=$(basename $(TARGET)).map
+
+ifeq ($(USE_FPU),y)
+ARCH_FLAGS+=-mfloat-abi=hard -mfpu=fpv4-sp-d16
+endif
+
+CFLAGS=$(ARCH_FLAGS) $(INCLUDES) $(_DEFINES) -ggdb3 -O$(OPT) -ffunction-sections -fdata-sections
+LDFLAGS=$(ARCH_FLAGS) -T$(LDSCRIPT) -nostartfiles -Wl,-gc-sections -Wl,-Map=$(TARGET_MAP) -Wl,--cref
+
+ifeq ($(USE_NANO),y)
+LDFLAGS+=--specs=nano.specs
+endif
+
+ifeq ($(SEMIHOST),y)
+LDFLAGS+=--specs=rdimon.specs
+endif
+
+CROSS=arm-none-eabi-
+CC=$(CROSS)gcc
+LD=$(CROSS)gcc
+SIZE=$(CROSS)size
+LIST=$(CROSS)objdump -xdS
+OBJCOPY=$(CROSS)objcopy
+GDB=$(CROSS)gdb
+OOCD=openocd
+
+OOCD_SCRIPT?=ciaa-nxp.cfg
+
+ifeq ($(VERBOSE),y)
+Q=
+else
+Q=@
+endif
+
+all: $(TARGET) $(TARGET_BIN) $(TARGET_LST) size
+
+-include $(DEPS)
+
+%.o: %.c
+	@echo CC $<
+	$(Q)$(CC) -MMD $(CFLAGS) -c -o $@ $<
+
+$(TARGET): $(OBJECTS)
+	@echo LD $@
+	$(Q)$(LD) $(LDFLAGS) -o $@ $(OBJECTS)
+
+$(TARGET_BIN): $(TARGET)
+	@echo BIN
+	$(Q)$(OBJCOPY) -v -O binary $< $@
+
+$(TARGET_LST): $(TARGET)
+	@echo LIST
+	$(Q)$(LIST) $< > $@
+
+size: $(TARGET)
+	$(Q)$(SIZE) $<
+
+program: $(TARGET_BIN)
+	@echo PROG
+	$(Q)$(OOCD) -f $(OOCD_SCRIPT) \
+		-c "init" \
+		-c "halt 0" \
+		-c "flash write_image erase unlock $< 0x1A000000 bin" \
+		-c "reset run" \
+		-c "shutdown" 2>&1
+
+debug:
+	@echo Iniciando depurador...
+	$(Q)$(OOCD) -f $(OOCD_SCRIPT) 2>&1
+	@echo
+	@echo Finalizado.
+
+clean:
+	@echo CLEAN
+	$(Q)rm -fR $(OBJECTS) $(TARGET) $(TARGET_BIN) $(TARGET_LST) $(DEPS)
+
+.PHONY: all size clean program
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhassert.h ./rkh/inc/rkhassert.h
--- a_qSC69Z/rkh/inc/rkhassert.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhassert.h	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,271 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhassert.h
+ *  \brief
+ *	The assertions (\c RKH_ASSERT() macro) are used to check expressions
+ *	that ought to be true as long as the program is running correctly. It
+ *	is a convenient way to insert sanity checks.
+ *
+ *	A number of philosophies can be employed when deciding where to use an
+ *	\c RKH_ASSERT() macro. Broadly speaking, the assertions only serve the
+ *	purposes of catching bugs and helping documentation. Helping to
+ *	document the code means that the statements inside the assertion tell
+ *	the reader something he might not already know.
+ *
+ *  \ingroup    apiAssert
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiAssert Assertions
+ *  @{
+ *  \brief \copybrief rkhassert.h
+ *  \copydetails rkhassert.h
+ *  @}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHASSERT_H__
+#define __RKHASSERT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhcfg.h"
+#include "rkhfwk_module.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if RKH_CFG_FWK_ASSERT_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *  The RKH_ASSERT() macro is used to check expressions that ought to
+     *  be true as long as the program is running correctly.
+     *
+     *	The assertions (\c RKH_ASSERT() macro) are used to check expressions
+     *	that ought to be true as long as the program is running correctly. It
+     *	is a convenient way to insert sanity checks.
+     *	A number of philosophies can be employed when deciding where to use an
+     *	\c RKH_ASSERT() macro. Broadly speaking, the assertions only serve the
+     *	purposes of catching bugs and helping documentation. Helping to
+     *	document the code means that the statements inside the assertion tell
+     *	the reader something he might not already know.
+     *
+     *  \param[in] exp		expression to be checked.
+     *
+     *	\note
+     *	The preprocessor switch RKH_CFG_FWK_ASSERT_EN disables checking
+     *	assertions.
+     *  In particular macros RKH_ASSERT(), RKH_REQUIRE(), RKH_ENSURE(),
+     *  RKH_INVARIANT(), and RKH_ERROR() do NOT evaluate the test condition
+     *  passed as the argument to these macros. One notable exception is the
+     *  macro RKH_ALLEGE(), that still evaluates the test condition, but does
+     *  not report assertion failures when the switch
+     *  RKH_CFG_FWK_ASSERT_EN is defined.
+     *
+     *  \sa RKH_ALLEGE(), RKH_REQUIRE(), RKH_ENSURE(), RKH_ERROR() and
+     *  RKH_INVARIANT() macros.
+     *
+     *	\usage
+     *	\code
+     *	...
+     *	some_function( const char *p, int size )
+     *	{
+     *		RKH_ASSERT(     p != ( const char* )0 &&
+     *					size > 0  &&
+     *					size < MAX_SIZE );
+     *		...
+     *	}
+     *	\endcode
+     *
+     *  \ingroup apiAssert
+     */
+    #define RKH_ASSERT(exp) \
+        if ((exp)) \
+        { \
+        } \
+        else \
+        { \
+            rkh_assert(m_name, __LINE__); \
+        }
+
+    /**
+     *  \brief
+     *  General purpose assertion that ALWAYS evaluates the \a exp
+     *  argument and calls the RKH_ASSERT() macro if the \a exp	evaluates
+     *  to FALSE.
+     *
+     *  \note The \a exp argument IS always evaluated even when assertions
+     *  are disabled with the RKH_CFG_FWK_ASSERT_EN.
+     *  When the RKH_CFG_ASSERT_EN is set to one (1), the RKH_ASSERT()
+     *  macro is NOT called, even if the \a exp evaluates to FALSE.
+     *
+     *  \ingroup apiAssert
+     */
+    #define RKH_ALLEGE(exp)     RKH_ASSERT(exp)
+
+    /**
+     *  \brief
+     *  Assertion that always calls the rkh_assert() callback if
+     *  ever executed.
+     *
+     *  \note
+     *  Can be disabled with the RKH_CFG_FWK_ASSERT_EN switch.
+     *
+     *  \ingroup apiAssert
+     */
+    #define RKH_ERROR()         rkh_assert(m_name, __LINE__)
+
+#else
+    #define RKH_ASSERT(exp)     ((void)0)
+    #define RKH_ALLEGE(exp)     ((void)(exp))
+    #define RKH_ERROR()         ((void)0)
+#endif
+
+/**
+ *  \brief
+ *	This macro checks the precondition.
+ *
+ *	This macro is equivalent to RKH_ASSERT() macro, except the name provides
+ *	a better documentation of the intention of this assertion.
+ *
+ *  \ingroup apiAssert
+ */
+#define RKH_REQUIRE(exp)        RKH_ASSERT(exp)
+
+/**
+ *  \brief
+ *	This macro checks the postcondition.
+ *
+ *	This macro is equivalent to RKH_ASSERT() macro, except the name provides
+ *	a better documentation of the intention of this assertion.
+ *
+ *  \ingroup apiAssert
+ */
+#define RKH_ENSURE(exp)         RKH_ASSERT(exp)
+
+/**
+ *  \brief
+ *	This macro is used to check a loop invariant.
+ *
+ *	This macro is equivalent to RKH_ASSERT() macro, except the name provides
+ *	a better documentation of the intention of this assertion.
+ *
+ *  \ingroup apiAssert
+ */
+#define RKH_INVARIANT(exp)      RKH_ASSERT(exp)
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+#if RKH_CFG_FWK_ASSERT_EN == RKH_ENABLED
+/**
+ *	\brief
+ *	Callback invoked in case the condition passed to RKH_ASSERT(),
+ *  RKH_REQUIRE(), RKH_ENSURE(), RKH_ERROR(), or RKH_ALLEGE() evaluates
+ *  to FALSE.
+ *
+ *  If the expression evaluates to FALSE (0), the function rkh_assert()
+ *  will be invoked, typically halting the program in some way and
+ *  storing or reporting the error code.
+ *  Once the rkh_assert() callback has stored or reported the error, it
+ *  must decide on the system's next action. One option is:
+ *
+ *	-# disable general interrupt
+ *	-# stores or send detected error (could be use a trace facility)
+ *	-# trigger a software reset
+ *
+ *	The policy chooses will be largely determined by the nature of
+ *	product.
+ *	If the system is running with a source level debugger, place a
+ *	breakpoint within. Another option is to trigger a software reset and
+ *	attempt to run the system again.
+ *
+ *  Also a unique identifier that can be reported from the field, easing
+ *  the investigation of the problem. Therefore, the error code could be
+ *  composed of the software version number, file number (.c file),
+ *  line number of assertion, and other information. A number is easier
+ *  to fill in on a report form and easier to store in NVRAM.
+ *
+ *  \param[in] file			file name where the assertion failed
+ *  \param[in] line         line number at which the assertion failed
+ *
+ *	\note
+ *	The rkh_assert() callback will only get called if
+ *	RKH_CFG_FWK_ASSERT_EN is set to 1 within rkhcfg.h file. When this
+ *	is set the application must provide the callback function.
+ *
+ *  \usage
+ *	The following listing shows a illustrative example for Visual Studio
+ *	C++ 2008 IDE:
+ *	\code
+ *	void
+ *	rkh_assert( RKHROM char * const file, int line )
+ *	{
+ *		printf( "RKH_ASSERT: [%d] line from %s file\n", line, file );
+ *
+ *		RKH_DIS_INTERRUPT();
+ *		RKH_TR_FWK_ASSERT( (RKHROM char *)file, line );
+ *		__debugbreak();
+ *	}
+ *	\endcode
+ *
+ *	\ingroup apiBSPMisc
+ *  \ingroup apiAssert
+ */
+void rkh_assert(const char *const file, int line);
+#endif
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhdef.h ./rkh/inc/rkhdef.h
--- a_qSC69Z/rkh/inc/rkhdef.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhdef.h	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,291 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhdef.h
+ *  \brief      Platform - independent file that contains standard constants 
+ *              and macros.
+ *
+ *  All constants and macros are prefixed with RKH_ to provide a consistent 
+ *  naming convention and to avoid namespace conflicts with other constants 
+ *  and macros in your application.
+ *
+ *  \ingroup apiDef
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiDef Definition library
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHDEF_H__
+#define __RKHDEF_H__
+
+/* ----------------------------- Include files ----------------------------- */
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* 
+ * Bit's macros.
+ */
+
+/**
+ *  \brief
+ *  Create bit mask with single, specified bit set.
+ *
+ *  \param[in] bit      Bit number of bit to set.
+ *
+ *  \return
+ *  Bit mask with single, specified bit set.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT(bit)            (1u << (bit))
+
+/**@{
+ *  \brief
+ *  Create bit mask of specified bit size with single, specified bit set.
+ *
+ *  \param[in] bit      Bit number of bit to set.
+ *
+ *  \return
+ *  Bit mask with single, specified bit set.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT08(bit)          ((rui8_t)((rui8_t) 1u << (bit)))
+#define RKH_BIT16(bit)          ((rui16_t)((rui16_t) 1u << (bit)))
+#define RKH_BIT32(bit)          ((rui32_t)((rui32_t) 1u << (bit)))
+/*@}*/
+
+/**
+ *  \brief
+ *  Shift a bit mask.
+ *
+ *  \param[in] bit_mask     Bit mask to shift.
+ *  \param[in] bit_shift    Number of bit positions to left-shift bit mask.
+ *
+ *  \return
+ *  Shifted bit mask.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_MASK(bit_mask, bit_shift) \
+    ((bit_mask) << (bit_shift))
+
+/**@{
+ *  \brief
+ *  Shift a bit mask of specified bit size.
+ *
+ *  \param[in] bit_mask		Bit mask to shift.
+ *  \param[in] bit_shift	Number of bit positions to left-shift bit mask.
+ *
+ *  \return
+ *  Shifted bit mask.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_MASK_08(bit_mask, bit_shift) \
+    ((rui8_t)((rui8_t)(bit_mask) << (bit_shift)))
+#define RKH_BIT_MASK_16(bit_mask, bit_shift) \
+    ((rui16_t)((rui16_t)(bit_mask) << (bit_shift)))
+#define RKH_BIT_MASK_32(bit_mask, bit_shift) \
+    ((rui32_t)((rui32_t)(bit_mask) << (bit_shift)))
+/*@}*/
+
+/**@{
+ *  \brief
+ *  Set specified bit(s) in a value of specified bit size.
+ *
+ *  \param[in] val		Value to modify by setting specified bit(s).
+ *  \param[in] mask		Mask of bits to set.
+ *
+ *  \return
+ *  Modified value with specified bit(s) set.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_SET_08(val, mask) \
+    ((val) = (rui8_t)(((rui8_t)(val)) | ((rui8_t)(mask))))
+#define RKH_BIT_SET_16(val, mask) \
+    ((val) = (rui16_t)(((rui16_t)(val)) | ((rui16_t)(mask))))
+#define RKH_BIT_SET_32(val, mask) \
+    ((val) = (rui32_t)(((rui32_t)(val)) | ((rui32_t)(mask))))
+/*@}*/
+
+/**@{
+ *  \brief
+ *  Clear specified bit(s) in a value of specified bit size.
+ *
+ *  \param[in] val		Value to modify by clearing specified bit(s).
+ *  \param[in] mask		Mask of bits to clear.
+ *
+ *  \return
+ *  Modified value with specified bit(s) clear.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_CLR_08(val, mask) \
+    ((val) = (rui8_t)(((rui8_t)(val)) & ((rui8_t) ~(mask))))
+#define RKH_BIT_CLR_16(val, mask) \
+    ((val) = (rui16_t)(((rui16_t)(val)) & ((rui16_t) ~(mask))))
+#define RKH_BIT_CLR_32(val, mask) \
+    ((val) = (rui32_t)(((rui32_t)(val)) & ((rui32_t) ~(mask))))
+/*@}*/
+
+/**
+ *  \brief
+ *  Determine if specified bit(s) in a value are set.
+ *
+ *  \param[in] val		Value to check for specified bit(s) set.
+ *  \param[in] mask		Mask of bits to check if set.
+ *
+ *  \return
+ *  RKH_YES, if ALL specified bit(s) are set in value.
+ *  RKH_NO,  if ALL specified bit(s) are NOT set in value.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_IS_SET(val, mask) \
+    ((((mask)  !=  0u)  && \
+      (((val) & (mask)) == (mask))) ? (RKH_YES) : (RKH_NO))
+
+/**
+ *  \brief
+ *  Determine if specified bit(s) in a value are clear.
+ *
+ *  \param[in] val		Value to check for specified bit(s) clear.
+ *  \param[in] mask		Mask of bits to check if clear.
+ *
+ *  \return
+ *  RKH_YES, if ALL specified bit(s) are clear in value.
+ *  RKH_NO,  if ALL specified bit(s) are NOT clear in value.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_IS_CLR(val, mask) \
+    ((((mask)  !=  0u)  && \
+      (((val) & (mask)) ==  0u)) ? (RKH_YES) : (RKH_NO))
+
+/**
+ *  \brief
+ *  Determine if any specified bit(s) in a value are set.
+ *
+ *  \param[in] val		Value to check for specified bit(s) set.
+ *  \param[in] mask		Mask of bits to check if set.
+ *
+ *  \return
+ *  RKH_YES, if ALL specified bit(s) are set in value.
+ *  RKH_NO,  if ALL specified bit(s) are NOT set in value.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_IS_SET_ANY(val, mask) \
+    ((((val) & (mask)) ==  0u) ? (RKH_NO) : (RKH_YES))
+
+/**
+ *  \brief
+ *  Determine if any specified bit(s) in a value are clear.
+ *
+ *  \param[in] val		Value to check for specified bit(s) clear.
+ *  \param[in] mask		Mask of bits to check if clear.
+ *
+ *  \return
+ *  RKH_YES, if ALL specified bit(s) are clear in value.
+ *  RKH_NO,  if ALL specified bit(s) are NOT clear in value.
+ *
+ *  \ingroup apiDef 
+ */
+#define RKH_BIT_IS_CLR_ANY(val, mask) \
+    ((((val) & (mask)) == (mask)) ? (RKH_NO) : (RKH_YES))
+
+/* -------------------------------- Constants ------------------------------ */
+#define  RKH_NULL               ((void *) 0)
+
+/**@{
+ * \brief
+ * Standard define.
+ *
+ *  \ingroup apiDef 
+ */
+#define  RKH_FALSE              0u
+#define  RKH_TRUE               1u
+
+#define  RKH_NO                 0u
+#define  RKH_YES                1u
+
+#define  RKH_DISABLED           0u
+#define  RKH_ENABLED            1u
+
+#define  RKH_INACTIVE           0u
+#define  RKH_ACTIVE             1u
+
+#define  RKH_INVALID            0u
+#define  RKH_VALID              1u
+
+#define  RKH_OFF                0u
+#define  RKH_ON                 1u
+
+#define  RKH_CLR                0u
+#define  RKH_SET                1u
+
+#define  RKH_FAIL               0u
+#define  RKH_OK                 1u
+/*@}*/
+
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhevt.h ./rkh/inc/rkhevt.h
--- a_qSC69Z/rkh/inc/rkhevt.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhevt.h	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,200 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhevt.h
+ *  \brief      Event data type and other related macros.This header file must 
+ *              be included in all modules(*.c files) that use RKH.
+ *
+ *  \ingroup    apiEvt
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiEvt Events
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHEVT_H__
+#define __RKHEVT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+#include "rkhcfg.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *  Perform cast to pointer to RKH event structure (RKH_EVT_T*).
+ *
+ *  \ingroup apiEvt
+ */
+#define RKH_EVT_CAST(_e)      ((RKH_EVT_T *)(_e))
+
+#define RKH_CAST_EVT(e)       ((RKH_EVT_T *)(e))
+
+#if RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED
+    #define RKH_INC_REF(evt) \
+        if (RKH_CAST_EVT(evt)->pool != 0) \
+        { \
+            ++RKH_CAST_EVT(evt)->nref; \
+        }
+#else
+    #define RKH_INC_REF(evt) \
+        (void)0
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  Defines the size of event. The valid values [in bits] are 8, 16 or 32. 
+ *  Default is 8. This type is configurable via the preprocessor switch 
+ *  RKH_CFG_FWK_SIZEOF_EVT.
+ */
+#if RKH_CFG_FWK_SIZEOF_EVT == 8
+typedef rui8_t RKH_SIG_T;
+#elif RKH_CFG_FWK_SIZEOF_EVT == 16
+typedef rui16_t RKH_SIG_T;
+#elif RKH_CFG_FWK_SIZEOF_EVT == 32
+typedef rui32_t RKH_SIG_T;
+#else
+typedef rui8_t RKH_SIG_T;
+#endif
+
+/**
+ *  Defines the data type of event size. The valid values [in bits] are
+ *  8, 16 or 32. Default is 8. This type is configurable via the
+ *  preprocessor switch RKH_CFG_FWK_SIZEOF_EVT_SIZE.
+ */
+
+#if RKH_CFG_FWK_SIZEOF_EVT_SIZE == 8
+typedef rui8_t RKH_ES_T;
+#elif RKH_CFG_FWK_SIZEOF_EVT_SIZE == 16
+typedef rui16_t RKH_ES_T;
+#elif RKH_CFG_FWK_SIZEOF_EVT_SIZE == 32
+typedef rui32_t RKH_ES_T;
+#else
+typedef rui8_t RKH_ES_T;
+#endif
+
+/**
+ *  \brief
+ *  Represents events without parameters.
+ *
+ *  An event can have associated parameters, allowing the event
+ *  instance to convey not only the occurrence of some interesting
+ *  incident but also quantitative information regarding that occurrence.
+ *	Implementing the single inheritance in C is very simply by literally
+ *	embedding the base structure, RKH_EVT_T in this case, as the first
+ *	member of the derived structure.
+ *  For example, the structure MYEVT_T derived from the base structure
+ *  RKH_EVT_T by embedding the RKH_EVT_T instance as the first member of
+ *	MYEVT_T.
+ *
+ *  \code
+ *  typedef struct
+ *  {
+ *      RKH_EVT_T evt;	// base structure
+ *		int x;			// parameter 'x'
+ *		int y;			// parameter 'y'
+ *  } MYEVT_T;
+ *  \endcode
+ *
+ *	Such nesting of structures always aligns the data member 'evt' at the
+ *	beginning of every instance of the derived structure. In particular, this
+ *	alignment lets you treat a pointer to the derived MYEVT_T structure as a
+ *	pointer to the RKH_EVT_T base structure. Consequently, you can always
+ *	safely pass a pointer to MYEVT_T to any C function that expects a pointer
+ *	to RKH_EVT_T. (To be strictly correct in C, you should explicitly cast this
+ *	pointer. In OOP such casting is called upcasting and is always safe.)
+ *	Therefore, all functions designed for the RKH_EVT_T structure are
+ *	automatically available to the MYEVT_T structure as well as other
+ *	structures derived from RKH_EVT_T.
+ *
+ *  \note
+ *  The RKH takes the \a 'e' member of RKH_EVT_T structure for triggering a
+ *  state transition.
+ *
+ *  \sa rkh_put_fifo(), rkh_put_lifo(), rkh_alloc_event(),
+ *  rkh_set_static_event() and rkh_fwk_gc().
+ *
+ *  \ingroup apiEvt 
+ */
+
+typedef struct RKH_EVT_T
+{
+    /**
+     *  \brief
+     *	Signal of the event instance.
+     */
+    RKH_SIG_T e;
+
+    /**
+     *  \brief
+     *  Attribute of dynamic events.
+     */
+    rui8_t nref;
+
+    /**
+     *  \brief
+     *  Attribute of dynamic events (0 for static event).
+     */
+    rui8_t pool;
+} RKH_EVT_T;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_bittbl.h ./rkh/inc/rkhfwk_bittbl.h
--- a_qSC69Z/rkh/inc/rkhfwk_bittbl.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_bittbl.h	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,101 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_bittbl.h
+ *  \brief      Native priority management.
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.21.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_BITTBL_H__
+#define __RKHFWK_BITTBL_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+#define RKH_INVALID_BITPOS      (rui8_t)0xff
+
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Get the bit mask from a bit position (from an 8-bit value).
+ *
+ *  \param[in] bitPos   bit position.
+ *
+ *	\return
+ *  The bit mask from a bit position (from an 8-bit value) if bitPos is less 
+ *  than 8, otherwise RKH_INVALID_BITPOS.
+ */
+rui8_t rkh_bittbl_getBitMask(rui8_t bitPos);
+
+/**
+ *  \brief
+ *  Used to return the bit position of the least significant bit set - a 
+ *  number between 0 and 7 (from an 8-bit value).
+ *
+ *  \param[in] value    data value to retrieve the least significant bit set.
+ *
+ *	\return
+ *  The bit position of the least significant bit set - a number between 0 
+ *  and 7 (from an 8-bit value).
+ */
+rui8_t rkh_bittbl_getLeastBitSetPos(rui8_t value);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_cast.h ./rkh/inc/rkhfwk_cast.h
--- a_qSC69Z/rkh/inc/rkhfwk_cast.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_cast.h	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,119 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_cast.h
+ *  \brief      ...
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_CAST_H__
+#define __RKHFWK_CAST_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+#include "rkhcfg.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *  Convert a pointer to a base-class. 
+ *
+ *  In other words, upcasting allows us to treat a derived type as though 
+ *  it were its base type.
+ *
+ *  \ingroup apiAO
+ */
+#define RKH_UPCAST(BaseType_, me_)          ((BaseType_ *)me_)
+
+/**
+ *  \brief
+ *  Converts a base-class pointer to a derived-class pointer.
+ *
+ *  \ingroup apiAO
+ */
+#define RKH_DOWNCAST(DerivedType_, me_)     ((DerivedType_ *)me_)
+
+/**
+ *  \brief
+ *  Perform downcast of a reference of a base class to one of its derived
+ *  classes.
+ *
+ *	\sa
+ *	\link RKH_EVT_T single inheritance in C \endlink, and
+ *	\link RKH_CREATE_BASIC_STATE another example \endlink.
+ *
+ *  \usage
+ *  \code
+ *  void
+ *  svr_start( const struct RKH_SMA_T *me, RKH_EVT_T *pe )
+ *  {
+ *      START_EVT_T *e_start;
+ *
+ *      e_start = RKH_ALLOC_EVT( START_EVT_T, START, me );
+ *      e_start->clino = RKH_CAST(REQ_EVT_T, pe)->clino;
+ *      RKH_SMA_POST_FIFO( RKH_GET_SMA( RKH_CAST(REQ_EVT_T, pe)->clino ),
+ *												RKH_EVT_CAST(e_start), me );
+ *  }
+ *  \endcode
+ */
+#define RKH_CAST(_type, _obj)     ((_type *)(_obj))
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_dynevt.h ./rkh/inc/rkhfwk_dynevt.h
--- a_qSC69Z/rkh/inc/rkhfwk_dynevt.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_dynevt.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,461 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_dynevt.h
+ *  \brief      
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_DYNEVT_H__
+#define __RKHFWK_DYNEVT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+#include "rkhfwk_evtpool.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *	This macro dynamically creates a new event of type \a et with its
+ *	signal.
+ *
+ *	The basic policy is to allocate the event from the first pool that
+ *	has a block size big enough to fit the requested event size. RKH
+ *	can manage up to three event pools (e.g., small, medium, and large
+ *	events, like shirt sizes). It returns a pointer to the event
+ *	already cast to the event type (et*). 
+ *
+ *  \param[in] et		type of event
+ *  \param[in] e		event signal
+ *  \param[in] sender_	pointer to the actor that request a memory block. It 
+ *                      is not necessarily a pointer to an active object. In 
+ *                      fact, if RKH_ALLOC_EVT() is called from an interrupt or 
+ *                      other context, it can create a unique object just to 
+ *                      unambiguously identify the publisher of the event.
+ *
+ *  \note
+ *	The assertions inside rkh_fwk_ae() function guarantee that the
+ *	pointer is valid, so you don't need to check the pointer returned
+ *	from rkh_fwk_ae(), unlike the value returned from malloc(), which
+ *	you should check.
+ *
+ *  \usage
+ *	Here is an example of dynamic event allocation with the macro 
+ *	RKH_ALLOC_EVT():
+ *
+ *	\code
+ *	MYEVT_T *mye = RKH_ALLOC_EVT(MYEVT_T, DATA, me);
+ *	mye->y = mye->x = 0;
+ *	...
+ *	\endcode
+ *
+ *  \ingroup apiEvt
+ */
+#if RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED
+    #define RKH_ALLOC_EVT(et, e, sender_) \
+        (et *)rkh_fwk_ae((RKH_ES_T)sizeof(et),(RKH_SIG_T)(e), sender_)
+#else
+    #define RKH_ALLOC_EVT(et, e, sender_) \
+        (void)0
+#endif
+
+/**
+ *  \brief
+ *  Recycle a dynamic event.
+ *
+ *  This macro implements a simple garbage collector for the dynamic
+ *  events.	Only dynamic events are candidates for recycling.
+ *  (A dynamic event is one that is allocated from an event pool, which
+ *  is determined as non-zero	e->nref attribute.) Next, the function
+ *  decrements the reference counter of the event, and recycles the
+ *  event only if the counter drops to zero (meaning that no more
+ *  references are outstanding for this event). The dynamic event is
+ *  recycled by returning it to the pool from which	it was originally
+ *  allocated. The pool-of-origin information is stored in the
+ *  e->pool member.
+ *
+ *  \param[in] e		pointer to event to be potentially recycled.
+ *  \param[in] sender_  Pointer to the actor that request a memory block. 
+ *                      It is not necessarily a pointer to an active 
+ *                      object. In fact, if RKH_FWK_GC() is called from 
+ *                      an interrupt or other context, it can create a 
+ *                      unique object just to unambiguously identify the 
+ *                      publisher of the event.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it. Instead, use #RKH_FWK_GC() macro.
+ *  \note
+ *  The garbage collector must be explicitly invoked at all appropriate
+ *  contexts, when an event can become garbage (automatic garbage
+ *  collection).
+ *  \note
+ *  When setting RKH_CFG_FWK_DYN_EVT_EN = 0 the garbage collector has
+ *  not effect, thus it's eliminated in compile-time.
+ *
+ *  \ingroup apiEvt
+ */
+#if RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED
+    #define RKH_FWK_GC(e, sender_)      rkh_fwk_gc(e, sender_)
+#else
+    #define RKH_FWK_GC(e, sender_)      (void)0
+#endif
+
+/**
+ *  \brief
+ *  Reserve the dynamic event to be recycled.
+ *
+ *  This is the complement to RKH_FWK_GC(). It increments the reference
+ *  count of a dynamic event so the event can be saved by an SMA (AO).
+ *  Sometime later the SMA should manually release the event with
+ *  RKH_FWK_GC().
+ *
+ *  \param[in] e		pointer to event to be reserved.
+ *
+ *  \ingroup apiEvt
+ */
+#if RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED
+    #define RKH_FWK_RSV(e)            rkh_fwk_reserve(e)
+#else
+    #define RKH_FWK_RSV(e)            (void)0
+#endif
+
+/**
+ *  \brief
+ *	This macro initialize an event \a e with \a es signal and establishes
+ *	it as one static event.
+ *
+ *  \param[in] ev_obj	name of event structure (object).
+ *  \param[in] ev_sig	event signal. The RKH takes this value for triggering
+ *                      a state transition.
+ *
+ *	\sa RKH_ROM_STATIC_EVENT() and RKH_STATIC_EVENT() macros.
+ *
+ *	\usage
+ *	\code
+ *	typedef struct
+ *	{
+ *		RKH_EVT_T e;
+ *		rui8_t cmd;
+ *	} RPC_REQ_T;
+ *
+ *	typedef struct
+ *	{
+ *		RPC_REQ_T e;
+ *		rkhui8_t txtsz;
+ *		EADR_T dst;
+ *		EADR_T sc;
+ *		char txt[ PDU_SIZEOF_UD_ASCII ];
+ *	} REQ_SEND_SMS_T;
+ *
+ *	...
+ *	static REQ_SEND_SMS_T ev_txsm;
+ *
+ *	...
+ *  some_function( ... )
+ *  {
+ *      RKH_SET_STATIC_EVENT( &ev_txsm, REQ_SEND_SMS );
+ *      ev_txsm.e.cmd = RPC_SEND_SMS;
+ *		...
+ *	}
+ *	\endcode
+ *
+ *  \ingroup apiEvt
+ */
+#define RKH_SET_STATIC_EVENT(ev_obj, ev_sig) \
+    MK_SET_EVT(ev_obj, ev_sig)
+
+/**
+ *  \brief
+ *	This macro declares and initializes the event structure \a ev_ob with
+ *	\a ev_sig signal number and establishes it as one static event.
+ *
+ *  \param[in] ev_obj	name of event structure (object).
+ *  \param[in] ev_sig	event signal. The RKH takes this value for triggering
+ *                      a state transition.
+ *
+ *	\sa RKH_SET_STATIC_EVENT() and RKH_ROM_STATIC_EVENT() macros.
+ *
+ *	\usage
+ *	\code
+ *	...
+ *	static RKH_STATIC_EVENT( ev_udrej, UPG_DIC_REJ );
+ *
+ *	void
+ *	dm_upgdic_rej( ... )
+ *	{
+ *		...
+ *		rkh_put_fifo( drpc, &ev_udrej );
+ *	}
+ *	\endcode
+ *
+ *  \ingroup apiEvt
+ */
+#define RKH_STATIC_EVENT(ev_obj, ev_sig) \
+    MK_EVT(ev_obj, ev_sig)
+
+/**
+ *  \brief
+ *	This macro declares and initializes the event structure \a ev_ob with
+ *	\a ev_sig signal number and establishes it as one static event.
+ *
+ *  \param[in] ev_obj	name of event structure (object).
+ *  \param[in] ev_sig	event signal. The RKH takes this value for triggering
+ *                      a state transition.
+ *
+ *	\sa RKH_SET_STATIC_EVENT() and RKH_STATIC_EVENT() macros.
+ *
+ *	\warning
+ *	The created event object is explicitly placed at ROM.
+ *
+ *	\usage
+ *	\code
+ *	...
+ *	static RKH_ROM_STATIC_EVENT( ev_timer, RPC_TIMER_RET );
+ *
+ *	void
+ *	offhook( void )
+ *	{
+ *		...
+ *		rkh_put_fifo( qphone, &ev_timer );
+ *	}
+ *	\endcode
+ *
+ *  \ingroup apiEvt
+ */
+#define RKH_ROM_STATIC_EVENT(ev_obj, ev_sig) \
+    MK_ROM_EVT(ev_obj, ev_sig)
+
+/**
+ *  \brief
+ *	Initializes the attibutes of a RKH's event object structure.
+ *
+ *	\usage
+ *	\code
+ *	typedef struct
+ *	{
+ *		RKH_EVT_T e;
+ *		rui8_t cmd;
+ *	} RPC_REQ_T;
+ *
+ *  ...
+ *	static RKHROM RPC_REQ_T ev_ssreq =
+ *	{
+ *		RKH_INIT_STATIC_EVT( REQ_SEND_SMS_REQ ),
+ *		RPC_SEND_SMS_REQ
+ *	};
+ *
+ *  ...
+ *  void
+ *  some_function(void)
+ *  {
+ *      RKH_SMA_POST_FIFO(drpc, RKH_EVT_CAST(&ev_ssreq), 0);
+ *      ...
+ *  }
+ *	\endcode
+ *
+ *  \ingroup apiEvt
+ */
+#define RKH_INIT_STATIC_EVT(ev_sig) \
+    MK_EVT_STRUCT(ev_sig)
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+typedef struct RKHEvtPoolMgr RKHEvtPoolMgr;
+struct RKHEvtPoolMgr
+{
+    RKH_ES_T blockSize;
+    RKHEvtPool *evtPool;
+};
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Initializes the dynamic event manager.
+ */
+void rkh_dynEvt_init(void);
+
+/**
+ *  \brief
+ *  Registers a new event pool into the event pool list.
+ *
+ *  Before using dynamic events (or event with arguments) the application
+ *  code must register the event pools, which stores the events as a
+ *  fixed-sized memory block. Each event pool must be registered with the
+ *  RKH framework, by means of the rkh_fwk_registerEvtPool() function.
+ *
+ *	This function initializes one event pool at a time and must be called
+ *  exactly once for each event pool before the pool can be used.
+ *
+ *  The application code might initialize the event pools by making calls
+ *  to the rkh_fwk_registerEvtPool() function. However, for the simplicity of
+ *  the internal implementation, the application code initialize event pools
+ *  in the ascending order of the event size.
+ *
+ *  Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can
+ *  be adapted for RKH event pools. In case such support is missing, RKH
+ *  provides a native RKH event pool manager implementation. See 
+ *  rkhfwk_evtpool.c.
+ *
+ *  For adapting RKH event pools to any fixed-size memory block service RTOS
+ *  provided the application code must provides the implementation of the 
+ *  rkhfwk_etpoo.h interface.
+ *
+ *  The dynamic allocation of events is optional then if the
+ *  #RKH_CFGPORT_NATIVE_DYN_EVT_EN is set to 1 and the native fixed-size
+ *  memory block facility is enabled (see #RKH_CFG_MP_EN) then RKH will
+ *  include its own implementation of dynamic memory management.
+ *  When #RKH_CFGPORT_NATIVE_DYN_EVT_EN is enabled RKH also will provide the 
+ *  event pool manager implementation based on its native memory pool module.
+ *
+ *  \param[in] sstart   storage start. Pointer to memory from which memory 
+ *                      blocks are allocated.
+ *  \param[in] ssize:	storage size. Size of the memory pool storage in bytes.
+ *  \param[in] esize	event size. This number determines the size of each 
+ *                      memory block in the pool.
+ *
+ *  \usage
+ *	\code
+ *	#define SIZEOF_EP0STO				64
+ *	#define SIZEOF_EP0_BLOCK			sizeof( TOUT_T )
+ *
+ *	#define SIZEOF_EP1STO				32
+ *	#define SIZEOF_EP1_BLOCK			sizeof( DIAL_T )
+ *
+ *	#define SIZEOF_EP2STO				32
+ *	#define SIZEOF_EP2_BLOCK			sizeof( SETUP_T )
+ *
+ *	typedef struct
+ *	{
+ *		RKH_EVT_T evt;                  // base structure
+ *		int timerno;					// parameter 'timerno'
+ *	} TOUT_T;
+ *
+ *	typedef struct
+ *	{
+ *		RKH_EVT_T evt;                  // base structure
+ *		char dial[ MAX_SIZE_DIAL ];     // parameter 'dial'
+ *		int qty;                        // parameter 'qty'
+ *	} DIAL_T;
+ *
+ *	typedef struct
+ *	{
+ *		RKH_EVT_T evt;                  // base structure
+ *		int volume;                     // parameter 'volume'
+ *		int baud_rate;                  // parameter 'baud_rate'
+ *		char name[ MAX_SIZE_NAME ];     // parameter 'name'
+ *		int iloop;                      // parameter 'iloop'
+ *	} SETUP_T;
+ *
+ *	// declares the storage memory of event pool
+ *	static rui8_t	ep0sto[ SIZEOF_EP0STO ],
+ *					ep1sto[ SIZEOF_EP1STO ],
+ *					ep2sto[ SIZEOF_EP2STO ];
+ *  ...
+ *  rkh_fwk_registerEvtPool( ep0sto, SIZEOF_EP0STO, SIZEOF_EP0_BLOCK  );
+ *  rkh_fwk_registerEvtPool( ep1sto, SIZEOF_EP1STO, SIZEOF_EP1_BLOCK  );
+ *  rkh_fwk_registerEvtPool( ep2sto, SIZEOF_EP2STO, SIZEOF_EP2_BLOCK  );
+ *  ...
+ *	\endcode
+ */
+void rkh_fwk_registerEvtPool(void *sstart, rui32_t ssize, RKH_ES_T esize);
+
+/**
+ *  \brief
+ *  Allocates an event from the previously created event pool.
+ *
+ *  \param[in] esize    size of event [in bytes].
+ *  \param[in] e        event signal.
+ *  \param[in] sender	pointer to the actor that request a memory block. It 
+ *                      is not necessarily a pointer to an active object. In 
+ *                      fact, if RKH_ALLOC_EVT() is called from an interrupt or 
+ *                      other context, it can create a unique object just to 
+ *                      unambiguously identify the publisher of the event.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should not call 
+ *  it. Instead, use #RKH_ALLOC_EVT() macro.
+ *
+ *  \sa rkh_put_fifo(), rkh_put_lifo(), rkh_alloc_event(),
+ *  rkh_set_static_event() and rkh_fwk_gc().
+ */
+RKH_EVT_T *rkh_fwk_ae(RKH_ES_T esize, RKH_SIG_T e, const void *const sender);
+
+/**
+ *  \brief
+ *  Recycle a dynamic event.
+ *
+ *  \param[in] e        Event signal.
+ *  \param[in] sender   Pointer to the actor that request a memory block. 
+ *                      It is not necessarily a pointer to an active 
+ *                      object. In fact, if RKH_FWK_GC() is called from 
+ *                      an interrupt or other context, it can create a 
+ *                      unique object just to unambiguously identify the 
+ *                      publisher of the event.
+ */
+void rkh_fwk_gc(RKH_EVT_T *e, const void *const sender);
+
+/**
+ *  \brief
+ *  Reserve the dynamic event to be recycled.
+ *
+ *  \param[in] e    event signal.
+ */
+void rkh_fwk_reserve(RKH_EVT_T *e);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_evtpool.h ./rkh/inc/rkhfwk_evtpool.h
--- a_qSC69Z/rkh/inc/rkhfwk_evtpool.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_evtpool.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,214 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_evtpool.h
+ *  \ingroup    fwk
+ *  \brief      Specificates the event pool interface.
+ *              Typically, these platform-dependent functions, must be define 
+ *              it in the specific implementation file to a particular 
+ *              platform. However, only the ports to the external OS/RTOS 
+ *              usually need some code to bolt the framework to the external 
+ *              OS/RTOS.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_EVTPOOL_H__
+#define __RKHFWK_EVTPOOL_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+typedef struct RKHEvtPool RKHEvtPool;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Encapsulates the initialization of event pool manager.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+void rkh_evtPool_init();
+
+/**
+ *  \brief
+ *  Encapsulates the creation of an event pool.
+ *
+ *  \param[in] stoStart	storage start. Pointer to memory from which 
+ *                      memory blocks (events) are allocated.
+ *  \param[in] stoSize 	storage size. Size of the memory pool storage in 
+ *                      bytes.
+ *  \param[in] evtSize	event size. This number determines the size of each
+ *                      memory block in the pool.
+ *  
+ *  \return
+ *  A pointer to assigned event pool.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+RKHEvtPool *rkh_evtPool_getPool(void *stoStart, rui16_t stoSize, 
+                                RKH_ES_T evtSize);
+
+/**
+ *  \brief
+ *  Encapsulates how RKH should obtain the block size of an event pool.
+ *
+ * \param[in] me		pointer to previously allocated memory pool 
+ *                      structure.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+rui8_t rkh_evtPool_getBlockSize(RKHEvtPool *const me);
+
+/**
+ *  \brief
+ *	Encapsulates how RKH should obtain an event \c evt from the
+ *	event pool \c me.
+ *
+ *  \param[in] me		pointer to previously allocated memory pool 
+ *                      structure.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+RKH_EVT_T *rkh_evtPool_get(RKHEvtPool *const me);
+
+/**
+ *  \brief
+ *	Encapsulates how RKH should return an event \c evt to the event
+ *	pool \c me.
+ *
+ *  \param[in] me		pointer to previously allocated memory pool 
+ *                      structure.
+ *  \param[in] evt      pointer to the returned event.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+void rkh_evtPool_put(RKHEvtPool *const me, RKH_EVT_T *evt);
+
+/**
+ *  \brief
+ *	Encapsulates how RKH should return the current number of memory 
+ *	blocks used in the pool \c me.
+ *
+ *  \param[in] me		pointer to previously allocated memory pool 
+ *                      structure.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+rui8_t rkh_evtPool_getNumUsed(RKHEvtPool *const me);
+
+/**
+ *  \brief
+ *	Encapsulates how RKH should return the lowest number of free 
+ *	blocks ever present in the pool \c me.
+ *  This number provides valuable empirical data for proper sizing of the
+ *  memory pool.
+ *
+ *  \param[in] me		pointer to previously allocated memory pool 
+ *                      structure.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+rui8_t rkh_evtPool_getNumMin(RKHEvtPool *const me);
+
+/**
+ *  \brief
+ *	Encapsulates how RKH should return the total number of blocks in the 
+ *	pool \c me.
+ *
+ *  \param[in] me		pointer to previously allocated memory pool 
+ *                      structure.
+ *
+ *  \note
+ *  Platform-dependent function. Typically, must be define it in the specific 
+ *  implementation file to a particular platform. However, only the ports to 
+ *  the external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ */
+rui8_t rkh_evtPool_getNumBlock(RKHEvtPool *const me);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_hook.h ./rkh/inc/rkhfwk_hook.h
--- a_qSC69Z/rkh/inc/rkhfwk_hook.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_hook.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,261 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_hook.h
+ *  \brief      ...
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.25.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_HOOK_H__
+#define __RKHFWK_HOOK_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+#include "rkhsma.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if (RKH_CFG_HOOK_DISPATCH_EN == RKH_ENABLED)
+    #define RKH_HOOK_DISPATCH(sma, e) \
+        rkh_hook_dispatch((sma), (RKH_EVT_T *)(e))
+#else
+    #define RKH_HOOK_DISPATCH(sma, e)   (void)0
+#endif
+
+#if (RKH_CFG_HOOK_TIMEOUT_EN == RKH_ENABLED)
+    #define RKH_HOOK_TIMEOUT(t)     rkh_hook_timeout((t))
+#else
+    #define RKH_HOOK_TIMEOUT(t)     (void)0
+#endif
+
+#if (RKH_CFG_HOOK_SIGNAL_EN == RKH_ENABLED)
+    #define RKH_HOOK_SIGNAL(e)      rkh_hook_signal((RKH_EVT_T *)(e))
+#else
+    #define RKH_HOOK_SIGNAL(e)      (void)0
+#endif
+
+#if (RKH_CFG_HOOK_START_EN == RKH_ENABLED)
+    #define RKH_HOOK_START()        rkh_hook_start()
+#else
+    #define RKH_HOOK_START()        (void)0
+#endif
+
+#if (RKH_CFG_HOOK_EXIT_EN == RKH_ENABLED)
+    #define RKH_HOOK_EXIT()         rkh_hook_exit()
+#else
+    #define RKH_HOOK_EXIT()         (void)0
+#endif
+
+#if (RKH_CFG_HOOK_TIMETICK_EN == RKH_ENABLED)
+    #define RKH_HOOK_TIMETICK()     rkh_hook_timetick()
+#else
+    #define RKH_HOOK_TIMETICK()     (void)0
+#endif
+
+#if (RKH_CFG_HOOK_PUT_TRCEVT_EN == RKH_ENABLED)
+    #define RKH_HOOK_PUT_TRCEVT()   rkh_hook_putTrcEvt()
+#else
+    #define RKH_HOOK_PUT_TRCEVT()   (void)0
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  When dispatching an event to a SMA the dispatch hook function will be
+ *  executed.
+ *
+ *  \param[in] me  pointer to previously created state machine application.
+ *	\param[in] e    pointer to arrived event.
+ *
+ *	\note
+ *	The dispatch hook will only get called if RKH_CFG_HOOK_DISPATCH_EN is
+ *	set to 1 within rkhcfg.h file. When this is set the application must
+ *	provide the hook function.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_dispatch(RKH_SMA_T *me, RKH_EVT_T *e);
+
+/**
+ *  \brief
+ *  When the producer of an event directly posts the event to the event queue
+ *  of the consumer SMA the rkh_hook_signal() will optionally called.
+ *
+ *	\param[in] e    pointer to arrived event.
+ *
+ *	\note
+ *	The signal hook will only get called if RKH_CFG_HOOK_SIGNAL_EN is set
+ *	to 1 within rkhcfg.h file. When this is set the application must provide
+ *	the hook function.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_signal(RKH_EVT_T *e);
+
+/**
+ *  \brief
+ *  If a timer expires the rkh_hook_timeout() function is called just before
+ *  the assigned event is directly posted into the state machine application
+ *  queue.
+ *
+ *	\param[in] t    pointer to previously allocated timer structure.
+ *					A cast to RKH_TMR_T data type must be internally
+ *					implemented to get the appropiated timer control block.
+ *
+ *	\note
+ *	The timeout hook will only get called if RKH_CFG_HOOK_TIMEOUT_EN is set
+ *	to 1 within rkhcfg.h file. When this is set the application must provide
+ *	the hook function.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_timeout(const void *t);
+
+/**
+ *  \brief
+ *  This hook function is called just before the RKH takes over control of
+ *  the application.
+ *
+ *	\note
+ *	The start hook will only get called if RKH_CFG_HOOK_START_EN is set to 1
+ *	within rkhcfg.h file. When this is set the application must provide the
+ *	hook function.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_start(void);
+
+/**
+ *  \brief
+ *  This hook function is called just before the RKH returns to the
+ *  underlying OS/RTOS. Usually, the rkh_hook_exit() is useful when executing
+ *  clean-up code upon SMA terminate or framework exit.
+ *
+ *	\note
+ *	The exit hook will only get called if RKH_CFG_HOOK_EXIT_EN is set to 1
+ *	within rkhcfg.h file. When this is set the application must provide the
+ *	hook function.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_exit(void);
+
+/**
+ *  \brief
+ *  An idle hook function will only get executed (with interrupts LOCKED)
+ *  when there are no SMAs of higher priority that are ready to run.
+ *
+ *  This makes the idle hook function an ideal place to put the processor
+ *  into a low power state - providing an automatic power saving whenever
+ *  there is no processing to be performed.
+ *
+ *  \note
+ *	The rkh_hook_idle() callback is called with interrupts locked, because the
+ *	determination of the idle condition might change by any interrupt posting
+ *	an event. This function must internally unlock interrupts, ideally
+ *	atomically with putting the CPU to the power-saving mode.
+ *
+ *  \usage
+ *	\code
+ *	void
+ *	rkh_hook_idle( void )       // NOTE: entered with interrupts DISABLED
+ *	{
+ *		RKH_ENA_INTERRUPT();	// must at least enable interrupts
+ *		...
+ *	}
+ *	\endcode
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_idle(void);
+
+/**
+ *  \brief
+ *  This function is called by rkh_tmr_tick(), which is assumed to be called
+ *  from an ISR. rkh_hook_timetick() is called at the very beginning of
+ *  rkh_tmr_tick(), to give priority to user or port-specific code when the
+ *  tick interrupt occurs.
+ *
+ *	Usually, this hook allows to the application to extend the functionality
+ *	of RKH, giving the port developer the opportunity to add code that will
+ *	be called by rkh_tmr_tick(). Frequently, the rkh_hook_timetick() is
+ *	called from the tick ISR and must not make any blocking calls and must
+ *	execute as quickly as possible.
+ *
+ *	\note
+ *	The time tick hook will only get called if RKH_CFG_HOOK_TIMETICK_EN is
+ *	set to 1 within rkhcfg.h file. When this is set the application must
+ *	provide the hook function.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_timetick(void);
+
+/**
+ *  \brief
+ *  This function is called from rkh_trc_end() function, at the end of that, 
+ *  to allow to the application to extend the functionality of RKH, giving 
+ *  the port developer the opportunity to add code that will be called when 
+ *  is put a trace event into the stream buffer.
+ *
+ *	\ingroup apiBSPHook
+ */
+void rkh_hook_putTrcEvt(void);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_module.h ./rkh/inc/rkhfwk_module.h
--- a_qSC69Z/rkh/inc/rkhfwk_module.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_module.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,139 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_module.h
+ *  \brief      ...
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_MODULE_H__
+#define __RKHFWK_MODULE_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+#include "rkhcfg.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *	\brief
+ *	This macro appears at the top of each C/C++ source file defining
+ *	the version string for that file (module).
+ *
+ *  \param[in] __fname		file (module) name.
+ *  \param[in] __version    file (module) version.
+ */
+#define RKH_MODULE_VERSION(__fname, __version) \
+    static RKHROM char *const m_version = # __version;
+
+/**
+ *	\brief
+ *	Get the module version.
+ */
+#define RKH_MODULE_GET_VERSION() \
+    ((const char *)m_version);
+
+/**
+ *	\brief
+ *	This macro appears at the top of each C/C++ source file defining
+ *	the description string for that file (module).
+ *
+ *  \param[in] __fname		file (module) name.
+ *  \param[in] __desc	    file (module) description.
+ */
+#define RKH_MODULE_DESC(__fname, __desc) \
+    static RKHROM char *const m_desc = __desc;
+
+/**
+ *	\brief
+ *	Get the module description.
+ */
+#define RKH_MODULE_GET_DESC() \
+    ((const char *)m_desc)
+
+#if RKH_CFG_FWK_ASSERT_EN == RKH_ENABLED
+    /**
+     *	\brief
+     *	This macro appears at the top of each C/C++ source file defining
+     *	a name for that file.
+     *
+     *  \param[in] __fname		file name where the assertion failed
+     *
+     *  \ingroup apiAssert
+     */
+    #define RKH_MODULE_NAME(__fname) \
+        static RKHROM char *const m_name = # __fname;
+
+    /**
+     *	\brief
+     *	This macro appears at the top of each C/C++ source file defining
+     *	a name for that file, by means of __FILE__ compiler directive.
+     *
+     *  \ingroup apiAssert
+     */
+    #define RKH_THIS_MODULE \
+        static RKHROM char *const m_name = __FILE__;
+
+#else
+    #define RKH_MODULE_NAME(__fname)
+    #define RKH_THIS_MODULE
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_sched.h ./rkh/inc/rkhfwk_sched.h
--- a_qSC69Z/rkh/inc/rkhfwk_sched.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_sched.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,160 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_sched.h
+ *  \brief      ...
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05 LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_SCHED_H__
+#define __RKHFWK_SCHED_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if ((RKH_CFGPORT_NATIVE_SCHEDULER_EN == 1) && (RKH_EN_DOXYGEN == 0))
+    #define RKH_EQ_TYPE     RKH_QUEUE_T
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Initializes the RKH framework.
+ *
+ *  A requirement of RKH is that must be called rkh_fwk_init() before call any
+ *  of its other services. This function initializes all of RKH's variables
+ *  and data structures.
+ *
+ *  \note
+ *	Platform-dependent function. All RKH ports must be define it in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \usage
+ *	Implementation example for x86, linux emulator of simple cooperative 
+ *	scheduler non-preemptive.
+ *  \snippet linux_st_rkhport.c Initializes the RKH framework
+ *
+ *  \ingroup apiPortMisc
+ */
+void rkh_fwk_init(void);
+
+/**
+ *  \brief
+ *  RKH framework is started.
+ *
+ *  This entry function turns over control to RKH (and does not return!).
+ *  This function runs the highest priority state machine application (SMA)
+ *  that is ready to run in run-to-completation model.
+ *
+ *  \note
+ *  The call to this function does not return. Hence, any code after it will
+ *  never be executed.
+ *
+ *  \note
+ *	Platform-dependent function. All RKH ports must be define it in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \usage
+ *	Implementation example for x86, linux emulator of simple cooperative 
+ *	scheduler non-preemptive.
+ *  \snippet linux_st_rkhport.c Run RKH framework
+ *
+ *	Here is the basic algorithm for interpreting the listing shown above.
+ *	A pseudocode description of the procedure is:
+ *  \include pseudo_cooperative_emulator.c
+ *
+ *  \ingroup apiPortMisc
+ */
+void rkh_fwk_enter(void);
+
+/**
+ *  \brief
+ *  Exit the RKH framework.
+ *
+ *  Function invoked by the application layer to exit the RKH application and
+ *  return control to the underlying OS/Kernel.
+ *
+ *  \note
+ *	This function is strongly platform-dependent. All RKH ports and must be
+ *	defined in the RKH port to a particular platform.
+ *	Some RKH ports might not require implementing this function at all,
+ *	because many embedded applications don't have anything to exit to.
+ *
+ *  \note
+ *	Platform-dependent function. All RKH ports must be defined in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \usage
+ *	Implementation example for x86, linux emulator of simple cooperative 
+ *	scheduler non-preemptive.
+ *  \snippet linux_st_rkhport.c Exit the RKH framework
+ *
+ *  \ingroup apiPortMisc
+ */
+void rkh_fwk_exit(void);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhfwk_version.h ./rkh/inc/rkhfwk_version.h
--- a_qSC69Z/rkh/inc/rkhfwk_version.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhfwk_version.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,93 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_version.h
+ *  \brief      RKH version
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.21.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHFWK_VERSION_H__
+#define __RKHFWK_VERSION_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/**
+ *  \brief
+ *	This macro expands to the binary representation of the RKH version.
+ *
+ *	The version number is composed as 0xABCC, where:
+ *	the number A (1-digit) denoted the major revision, the number B (1-digit)
+ *	denoted the minor revision, and the number C (2-digit) indicated the
+ *	release number. For example, the code for 2.2.04 is 0x2204.
+ *
+ *  \releasedate 12/14/2016
+ */
+#define RKH_VERSION_CODE            0x2406u
+
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/**
+ *  \brief
+ *  String describing the RKH version.
+ */
+extern RKHROM char rkh_version[];
+
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkh.h ./rkh/inc/rkh.h
--- a_qSC69Z/rkh/inc/rkh.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkh.h	2018-01-19 23:55:10.996318947 -0300
@@ -0,0 +1,134 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkh.h
+ *  \brief      RKH framwwork platform - independent interface.
+ *
+ *  \ingroup    apiSM
+ *  \ingroup    apiAO
+ *
+ *  \addtogroup api
+ *  @{
+ *      \addtogroup apiSM State machines
+ *      @{@}
+ *      \addtogroup apiAO Active objects
+ *      @{@}
+ *      \addtogroup apiPort Port
+ *      @{
+ *          \addtogroup apiPortMisc Miscellaneous
+ *          @{@}
+ *          \addtogroup apiPortAO Active objects
+ *          @{
+ *          \brief Related to underlying OS/RTOS
+ *          @}
+ *      @}
+ *      \addtogroup apiBSP BSP
+ *      @{
+ *          \addtogroup apiBSPHook Hooks
+ *          @{
+ *          \brief The hook functions allows to bsp/port developer to extend
+ *                 the functionality of the framework.
+ *
+ *                 A RKH port cannot and should not define all the functions 
+ *                 that it calls, because this would render the port too 
+ *                 inflexible. The functions that RKH calls but doesn't 
+ *                 actually implement are referred to as callback or hook 
+ *                 functions. All these functions in RKH are easily 
+ *                 indentifiable by the \b "_hook_" key word used in the 
+ *                 function name, rkh_hook_dispatch(), rkh_hook_signal(), 
+ *                 rkh_hook_timeout(), rkh_hook_start(), rkh_hook_exit(), and 
+ *                 rkh_hook_idle(). 
+ *                 Please, see RKH_CFG_HOOK_DISPATCH_EN, 
+ *                 RKH_CFG_HOOK_SIGNAL_EN, RKH_CFG_HOOK_TIMEOUT_EN, 
+ *                 RKH_CFG_HOOK_START_EN, and RKH_CFG_HOOK_EXIT_EN options 
+ *                 from the \c rkhcfg.h.\n
+ *          @}
+ *          \addtogroup apiBSPTrc Trace
+ *          @{
+ *          \brief Related to manage a trace session with Trazer application.
+*           See the \ref dbg section for more information. 
+ *          @}
+ *      @}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/*
+ *  (1) This header file must be included in all modules (*.c) that use RKH.
+ */
+
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKH_H__
+#define __RKH_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc.h"
+#include "rkhsma.h"
+#include "rkhqueue.h"
+#include "rkhmempool.h"
+#include "rkhtmr.h"
+#include "rkhassert.h"
+#include "rkhfwk_hook.h"
+#include "rkhfwk_bittbl.h"
+#include "rkhfwk_module.h"
+#include "rkhfwk_cast.h"
+#include "rkhfwk_version.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhitl.h ./rkh/inc/rkhitl.h
--- a_qSC69Z/rkh/inc/rkhitl.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhitl.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,2496 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhitl.h
+ *  \brief      RKH engine interface.This header file is directly included in 
+ *              RKH interface file, rkh.h.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHITL_H__
+#define __RKHITL_H__
+
+/* ----------------------------- Include files ----------------------------- */
+/**
+ *  Specific definitions to the platform being used.
+ */
+#include "rkhplat.h"
+
+/**
+ *  Defines standard constants and macros.
+ *  Application specific configuration options.
+ *  Event data type and related macros.
+ */
+#include "rkhevt.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if (((RKH_CFG_TRC_EN == 1) && (RKH_CFG_SMA_TRC_SNDR_EN == 1)) || \
+      (defined(RKH_EN_DOXYGEN) && RKH_EN_DOXYGEN == 1))
+    /**
+     *  \brief
+     *  This macro is used to verify the sender object usage on post an 
+     *  event.
+     *
+     *  The macros RKH_TIM_TICK(), RKH_SMA_POST_FIFO(), and
+     *  RKH_SMA_POST_LIFO() takes an additional argument \a sender, which 
+     *  is a pointer to the sender object. This argument is actually only 
+     *  used when software tracing is enabled (macro #RKH_USE_TRC_SENDER is
+     *  defined).
+     *  When software tracing is disabled, the macros RKH_TIM_TICK(),
+     *  RKH_SMA_POST_FIFO(), and RKH_SMA_POST_LIFO() calls rkh_tmr_tick(),
+     *  rkh_sma_post_fifo(), and rkh_sma_post_lifo() respectively without 
+     *  any arguments, so the overhead of passing this extra argument is 
+     *  entirely avoided.
+     */
+    #define RKH_USE_TRC_SENDER
+#endif
+
+/**
+ *  \brief
+ *  This macro retrieves a pointer to string describing the RKH version.
+ *  For example, "2.2.04".
+ */
+#define RKH_RELEASE                 rkh_version
+
+/**
+ *  \brief
+ *  This is the macro used to build an integer version code from the
+ *  individual numbers that build up a version number.
+ *
+ *  For example, RKH_VERSION(2,2,04) expands to 0x2204. This macro is very
+ *  useful when needs to compare the current version (#RKH_VERSION_CODE) and
+ *  a known checkpoint version at compile-time.
+ *
+ *  \param[in] a    major revision
+ *  \param[in] b    minor revision
+ *  \param[in] c    release number
+ *
+ *  \usage
+ *  \code
+ *  #if RKH_VERSION_CODE <= RKH_VERSION(1, 2, 03)
+ *  ...
+ *  #else
+ *  ...
+ *  #endif
+ *  \endcode
+ */
+#define RKH_VERSION(a, b, c) \
+    (((((a) <<   12) & 0xF000) | \
+      (((b) <<    8) & 0x0F00) | \
+      (((c) &  0xFF) & 0x00FF)) & 0xFFFF)
+
+/**
+ *  \brief
+ *	This macro is used to indicate the end of a transition table.
+ */
+#define RKH_ANY                     ((RKH_SIG_T)(-1))
+
+/**
+ *  \brief
+ *	This macro is used to indicate the completion event.
+ *
+ *  A special kind of transition is a completion transition, which has an 
+ *  implicit trigger. The event that enables this trigger is called a 
+ *  completion event and it signifies that all behaviors associated with the 
+ *  source state of the completion transition have completed execution.
+ */
+#define RKH_COMPLETION_EVENT        (RKH_ANY - 1)
+
+/**
+ *  \brief
+ *  RKH allows up to RKH_CFG_FWK_MAX_SMA different priority levels
+ *  (see rkhcfg.h).
+ *
+ *  In RKH, a low-priority number corresponds to a high-priority level.
+ *  Priority level zero (0) is thus the highest priority level. Priority
+ *	RKH_LOWEST_PRIO (RKH_CFG_FWK_MAX_SMA - 1) is the lowest priority level.
+ */
+#define RKH_LOWEST_PRIO             (RKH_CFG_FWK_MAX_SMA - 1)
+
+/*
+ *  Verifies port file from rkhport.h included in rkhplat.h.
+ */
+
+#ifndef RKHROM
+#error "rkhport.h, Missing RKHROM: Qualifier for ROM data storage. \
+    See Porting chapter in readme file for more information"
+#endif
+
+#define FOREVER                     for (;; )
+
+/*
+ *  Macros for casting
+ */
+#define CB(p)           ((RKH_BASE_T *)(p))
+#define CST(p)          ((RKH_ST_T *)(p))
+#define CCMP(p)         ((RKH_SCMP_T *)(p))
+#define CBSC(p)         ((RKH_SBSC_T *)(p))
+#define CCD(p)          ((RKH_SCOND_T *)(p))
+#define CCH(p)          ((RKH_SCHOICE_T *)(p))
+#define CH(p)           ((RKH_SHIST_T *)(p))
+#define CSBM(p)         ((RKH_SSBM_T *)(p))
+#define CRSM(p)         ((RKH_RSM_T *)(p))
+#define CM(p)           ((RKHROM RKH_SM_T *)(p))
+#define CT(p)           ((RKHROM RKH_TR_T *)(p))
+#define CPT(p)          ((RKHROM RKH_SCMP_T *)(p))
+#define CPP(p)          ((RKH_PPRO_T)(p))
+#define CG(p)           ((RKH_GUARD_T)(p))
+#define CA(p)           ((RKH_TRN_ACT_T)(p))
+#define CENP(p)         ((RKH_SENP_T *)(p))
+#define CEXP(p)         ((RKH_SEXP_T *)(p))
+#define CENPCN(p)       ((RKH_ENPCN_T *)(p))
+#define CEXPCN(p)       ((RKH_EXPCN_T *)(p))
+#define CE(p)           ((RKH_EVT_T *)(p))
+#define CCE(p)          ((const RKH_EVT_T *)(p))
+#define CV(p)           ((void *)(p))
+#define CSMA(p)         ((const RKH_SMA_T *)(p))
+#define CQ(p)           ((RKH_QUEUE_T *)(p))
+#define CIA(s)          ((RKH_INIT_ACT_T)(RKH_SMA_ACCESS_CONST(sma, iaction)))
+#define CTA(ta)         ((RKH_TRN_ACT_T)(ta))
+
+/**
+ *  \brief
+ *  This macro declares a typed and external pointer to previously defined 
+ *  object.
+ *
+ *  \param[in] type_    Data type of the defined object. 
+ *  \param[in] me_	    Pointer to previously defined object.
+ *
+ *  \sa
+ *  RKH_SMA_DCLR_TYPE(), RKH_SM_DCLR_TYPE().
+ */
+#define RKH_DCLR_PTR_TYPE(type_, me_) \
+        extern type_ * const me_
+
+/* ------------------------- Configuration errors -------------------------- */
+
+/*
+ *  LOOK FOR MISSING #define CONSTANTS
+ *
+ *  This section is used to generate ERROR messages at compile time if
+ *  certain #define constants are MISSING in rkhcfg.h.  This allows you to
+ *  quickly determine the source of the error.
+ *
+ *  You SHOULD NOT change this section UNLESS you would like to add more
+ *  comments as to the source of the compile time error.
+ */
+
+/*  MEMORY POOL   --------------------------------------------------------- */
+#ifndef RKH_CFG_MP_EN
+    #error "RKH_CFG_MP_EN                         not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_MP_EN != RKH_ENABLED) && \
+    (RKH_CFG_MP_EN != RKH_DISABLED))
+    #error "RKH_CFG_MP_EN                   illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#elif   (RKH_CFG_MP_EN == RKH_ENABLED)
+
+    #ifndef RKH_CFG_MP_REDUCED_EN
+    #error "RKH_CFG_MP_REDUCED_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_MP_REDUCED_EN != RKH_ENABLED) && \
+    (RKH_CFG_MP_REDUCED_EN != RKH_DISABLED))
+    #error "RKH_CFG_MP_REDUCED_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_MP_SIZEOF_BSIZE
+    #error "RKH_CFG_MP_SIZEOF_BSIZE               not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+
+    #elif  ((RKH_CFG_MP_SIZEOF_BSIZE != 8) && \
+    (RKH_CFG_MP_SIZEOF_BSIZE != 16) && \
+    (RKH_CFG_MP_SIZEOF_BSIZE != 32))
+    #error  "RKH_CFG_MP_SIZEOF_BSIZE        illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+    #endif
+
+    #ifndef RKH_CFG_MP_SIZEOF_NBLOCK
+    #error "RKH_CFG_MP_SIZEOF_NBLOCK              not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+
+    #elif  ((RKH_CFG_MP_SIZEOF_NBLOCK != 8) && \
+    (RKH_CFG_MP_SIZEOF_NBLOCK != 16) && \
+    (RKH_CFG_MP_SIZEOF_NBLOCK != 32))
+    #error  "RKH_CFG_MP_SIZEOF_NBLOCK       illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+    #endif
+
+    #ifndef RKH_CFG_MP_GET_BSIZE_EN
+    #error "RKH_CFG_MP_GET_BSIZE_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_MP_GET_BSIZE_EN != RKH_ENABLED) && \
+    (RKH_CFG_MP_GET_BSIZE_EN != RKH_DISABLED))
+    #error "RKH_CFG_MP_GET_BSIZE_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_MP_GET_NFREE_EN
+    #error "RKH_CFG_MP_GET_NFREE_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_MP_GET_NFREE_EN != RKH_ENABLED) && \
+    (RKH_CFG_MP_GET_NFREE_EN != RKH_DISABLED))
+    #error "RKH_CFG_MP_GET_NFREE_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_MP_GET_LWM_EN
+    #error "RKH_CFG_MP_GET_LWM_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_MP_GET_LWM_EN != RKH_ENABLED) && \
+    (RKH_CFG_MP_GET_LWM_EN != RKH_DISABLED))
+    #error "RKH_CFG_MP_GET_LWM_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_MP_GET_INFO_EN
+    #error "RKH_CFG_MP_GET_INFO_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_MP_GET_INFO_EN != RKH_ENABLED) && \
+    (RKH_CFG_MP_GET_INFO_EN != RKH_DISABLED))
+    #error "RKH_CFG_MP_GET_INFO_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+#endif
+
+/*  QUEUE         --------------------------------------------------------- */
+#ifndef RKH_CFG_QUE_EN
+    #error "RKH_CFG_QUE_EN                         not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_EN                   illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_SIZEOF_NELEM
+    #error "RKH_CFG_QUE_SIZEOF_NELEM               not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+
+#elif  ((RKH_CFG_QUE_SIZEOF_NELEM != 8) && \
+    (RKH_CFG_QUE_SIZEOF_NELEM != 16) && \
+    (RKH_CFG_QUE_SIZEOF_NELEM != 32))
+    #error  "RKH_CFG_QUE_SIZEOF_NELEM        illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_GET_LWMARK_EN
+    #error "RKH_CFG_QUE_GET_LWMARK_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_GET_LWMARK_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_GET_LWMARK_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_GET_LWMARK_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_READ_EN
+    #error "RKH_CFG_QUE_READ_EN                    not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_READ_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_READ_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_READ_EN              illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_DEPLETE_EN
+    #error "RKH_CFG_QUE_DEPLETE_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_DEPLETE_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_DEPLETE_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_DEPLETE_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_IS_FULL_EN
+    #error "RKH_CFG_QUE_IS_FULL_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_IS_FULL_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_IS_FULL_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_IS_FULL_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_GET_NELEMS_EN
+    #error "RKH_CFG_QUE_GET_NELEMS_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_GET_NELEMS_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_GET_NELEMS_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_GET_NELEMS_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_PUT_LIFO_EN
+    #error "RKH_CFG_QUE_PUT_LIFO_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_PUT_LIFO_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_PUT_LIFO_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_PUT_LIFO_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_QUE_GET_INFO_EN
+    #error "RKH_CFG_QUE_GET_INFO_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_QUE_GET_INFO_EN != RKH_ENABLED) && \
+    (RKH_CFG_QUE_GET_INFO_EN != RKH_DISABLED))
+    #error "RKH_CFG_QUE_GET_INFO_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+/*  TIMER         --------------------------------------------------------- */
+#ifndef RKH_CFG_TMR_EN
+    #error "RKH_CFG_TMR_EN                        not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_TMR_EN != RKH_ENABLED) && \
+    (RKH_CFG_TMR_EN != RKH_DISABLED))
+    #error "RKH_CFG_TMR_EN                  illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#elif   (RKH_CFG_TMR_EN == RKH_ENABLED)
+    #ifndef RKH_CFG_FWK_TICK_RATE_HZ
+    #error "RKH_CFG_FWK_TICK_RATE_HZ              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+    #elif (RKH_CFG_FWK_TICK_RATE_HZ <= 0u)
+    #error "RKH_CFG_FWK_TICK_RATE_HZ        illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be > 0]                    "
+    #endif
+
+    #ifndef RKH_CFG_TMR_SIZEOF_NTIMER
+    #error "RKH_CFG_TMR_SIZEOF_NTIMER             not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+
+    #elif  ((RKH_CFG_TMR_SIZEOF_NTIMER != 8) && \
+    (RKH_CFG_TMR_SIZEOF_NTIMER != 16) && \
+    (RKH_CFG_TMR_SIZEOF_NTIMER != 32))
+    #error  "RKH_CFG_TMR_SIZEOF_NTIMER      illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]      "
+    #error  "                               [     || 16  (16-bit size)]      "
+    #error  "                               [     || 32  (32-bit size)]      "
+    #endif
+
+    #ifndef RKH_CFG_TMR_HOOK_EN
+    #error "RKH_CFG_TMR_HOOK_EN                   not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_TMR_HOOK_EN != RKH_ENABLED) && \
+    (RKH_CFG_TMR_HOOK_EN != RKH_DISABLED))
+    #error "RKH_CFG_TMR_HOOK_EN             illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_TMR_GET_INFO_EN
+    #error "RKH_CFG_TMR_GET_INFO_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_TMR_GET_INFO_EN != RKH_ENABLED) && \
+    (RKH_CFG_TMR_GET_INFO_EN != RKH_DISABLED))
+    #error "RKH_CFG_TMR_GET_INFO_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+#endif
+
+/*  STATE MACHINE APPLICATIONS  -------------------------------------------- */
+#ifndef RKH_CFG_SMA_GET_INFO_EN
+    #error "RKH_CFG_SMA_GET_INFO_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_GET_INFO_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_GET_INFO_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_GET_INFO_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_PPRO_EN
+    #error "RKH_CFG_SMA_PPRO_EN                   not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_PPRO_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_PPRO_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_PPRO_EN             illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_HCAL_EN
+    #error "RKH_CFG_SMA_HCAL_EN                   not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_HCAL_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_HCAL_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_HCAL_EN             illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_MAX_HCAL_DEPTH
+    #error "RKH_CFG_SMA_MAX_HCAL_DEPTH            not #define'd in 'rkhcfg.h'"
+    #error "                                [MUST be >  0]                   "
+    #error "                                [     && <= 8]                   "
+
+#elif   ((RKH_CFG_SMA_MAX_HCAL_DEPTH == 0) || \
+    (RKH_CFG_SMA_MAX_HCAL_DEPTH > 8))
+    #error "RKH_CFG_SMA_MAX_HCAL_DEPTH      illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >= 0]                   "
+    #error  "                               [     && <= 8]                   "
+
+#endif
+
+#ifndef RKH_CFG_SMA_MAX_TRC_SEGS
+    #error "RKH_CFG_SMA_MAX_TRC_SEGS              not #define'd in 'rkhcfg.h'"
+    #error "                                [MUST be >  0]                   "
+    #error "                                [     && <= 8]                   "
+
+#elif   ((RKH_CFG_SMA_MAX_TRC_SEGS == 0) || \
+    (RKH_CFG_SMA_MAX_TRC_SEGS > 8))
+    #error "RKH_CFG_SMA_MAX_TRC_SEGS        illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >= 0]                   "
+    #error  "                               [     && <= 8]                   "
+
+#endif
+
+#ifndef RKH_CFG_SMA_PSEUDOSTATE_EN
+    #error "RKH_CFG_SMA_PSEUDOSTATE_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_PSEUDOSTATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_PSEUDOSTATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_PSEUDOSTATE_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_DEEP_HIST_EN
+    #error "RKH_CFG_SMA_DEEP_HIST_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_DEEP_HIST_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_DEEP_HIST_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_DEEP_HIST_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_SHALLOW_HIST_EN
+    #error "RKH_CFG_SMA_SHALLOW_HIST_EN           not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_SHALLOW_HIST_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_SHALLOW_HIST_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_SHALLOW_HIST_EN     illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_CHOICE_EN
+    #error "RKH_CFG_SMA_CHOICE_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_CHOICE_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_CHOICE_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_CHOICE_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]     "
+
+#endif
+
+#ifndef RKH_CFG_SMA_CONDITIONAL_EN
+    #error "RKH_CFG_SMA_CONDITIONAL_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_CONDITIONAL_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_CONDITIONAL_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_CONDITIONAL_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_SUBMACHINE_EN
+    #error "RKH_CFG_SMA_SUBMACHINE_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_SUBMACHINE_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_SUBMACHINE_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_SUBMACHINE_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_TRC_SNDR_EN
+    #error "RKH_CFG_SMA_TRC_SNDR_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_TRC_SNDR_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_TRC_SNDR_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_TRC_SNDR_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_INIT_ARG_SMA_EN
+    #error "RKH_CFG_SMA_INIT_ARG_SMA_EN           not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_INIT_ARG_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_INIT_ARG_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_INIT_ARG_SMA_EN     illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_ENT_ARG_SMA_EN
+    #error "RKH_CFG_SMA_ENT_ARG_SMA_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_ENT_ARG_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_ENT_ARG_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_ENT_ARG_SMA_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_ENT_ARG_STATE_EN
+    #error "RKH_CFG_SMA_ENT_ARG_STATE_EN          not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_ENT_ARG_STATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_ENT_ARG_STATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_ENT_ARG_STATE_EN    illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_EXT_ARG_SMA_EN
+    #error "RKH_CFG_SMA_EXT_ARG_SMA_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_EXT_ARG_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_EXT_ARG_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_EXT_ARG_SMA_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_EXT_ARG_STATE_EN
+    #error "RKH_CFG_SMA_EXT_ARG_STATE_EN          not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_EXT_ARG_STATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_EXT_ARG_STATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_EXT_ARG_STATE_EN    illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_ACT_ARG_SMA_EN
+    #error "RKH_CFG_SMA_ACT_ARG_SMA_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_ACT_ARG_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_ACT_ARG_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_ACT_ARG_SMA_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_ACT_ARG_EVT_EN
+    #error "RKH_CFG_SMA_ACT_ARG_EVT_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_ACT_ARG_EVT_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_ACT_ARG_EVT_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_ACT_ARG_EVT_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_GRD_ARG_EVT_EN
+    #error "RKH_CFG_SMA_GRD_ARG_EVT_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_GRD_ARG_EVT_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_GRD_ARG_EVT_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_GRD_ARG_EVT_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_GRD_ARG_SMA_EN
+    #error "RKH_CFG_SMA_GRD_ARG_SMA_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_GRD_ARG_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_GRD_ARG_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_GRD_ARG_SMA_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_PPRO_ARG_SMA_EN
+    #error "RKH_CFG_SMA_PPRO_ARG_SMA_EN           not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_PPRO_ARG_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_PPRO_ARG_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_PPRO_ARG_SMA_EN     illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_SM_CONST_EN
+    #error "RKH_CFG_SMA_SM_CONST_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif ((RKH_CFG_SMA_SM_CONST_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_SM_CONST_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_SM_CONST_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_RT_CTOR_EN
+    #error "RKH_CFG_SMA_RT_CTOR_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif ((RKH_CFG_SMA_RT_CTOR_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_RT_CTOR_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_RT_CTOR_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+#ifndef RKH_CFG_SMA_VFUNCT_EN
+    #error "RKH_CFG_SMA_VFUNCT_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_SMA_VFUNCT_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_VFUNCT_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_VFUNCT_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#endif
+
+/*  TRACE         --------------------------------------------------------- */
+#ifndef RKH_CFG_TRC_EN
+    #error "RKH_CFG_TRC_EN                        not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+#elif   ((RKH_CFG_TRC_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_EN                  illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+
+#elif   (RKH_CFG_TRC_EN == RKH_ENABLED)
+
+    #ifndef RKH_CFG_TRC_RTFIL_EN
+    #error "RKH_CFG_TRC_RTFIL_EN                  not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_TRC_RTFIL_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_RTFIL_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_RTFIL_EN            illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_TRC_RTFIL_SMA_EN
+    #error "RKH_CFG_TRC_RTFIL_SMA_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_TRC_RTFIL_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_RTFIL_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_RTFIL_SMA_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_TRC_RTFIL_SIGNAL_EN
+    #error "RKH_CFG_TRC_RTFIL_SIGNAL_EN           not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]       "
+    #error "                                    [     || RKH_DISABLED]       "
+
+    #elif   ((RKH_CFG_TRC_RTFIL_SIGNAL_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_RTFIL_SIGNAL_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_RTFIL_SIGNAL_EN     illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]      "
+    #error "                                    [     ||  RKH_DISABLED]      "
+    #endif
+
+    #ifndef RKH_CFG_TRC_USER_TRACE_EN
+    #error "RKH_CFG_TRC_USER_TRACE_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_USER_TRACE_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_USER_TRACE_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_USER_TRACE_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_ALL_EN
+    #error "RKH_CFG_TRC_ALL_EN                    not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_ALL_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_ALL_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_ALL_EN              illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_MP_EN
+    #error "RKH_CFG_TRC_MP_EN                     not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_MP_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_MP_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_MP_EN               illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_QUE_EN
+    #error "RKH_CFG_TRC_QUE_EN                     not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_QUE_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_QUE_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_QUE_EN               illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SMA_EN
+    #error "RKH_CFG_TRC_SMA_EN                    not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SMA_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SMA_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SMA_EN              illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_TMR_EN
+    #error "RKH_CFG_TRC_TMR_EN                    not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_TMR_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_TMR_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_TMR_EN              illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_EN
+    #error "RKH_CFG_TRC_SM_EN                     not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_EN               illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_FWK_EN
+    #error "RKH_CFG_TRC_FWK_EN                    not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_FWK_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_FWK_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_FWK_EN              illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_ASSERT_EN
+    #error "RKH_CFG_TRC_ASSERT_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_ASSERT_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_ASSERT_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_ASSERT_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_INIT_EN
+    #error "RKH_CFG_TRC_SM_INIT_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_INIT_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_INIT_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_INIT_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_DCH_EN
+    #error "RKH_CFG_TRC_SM_DCH_EN                  not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_DCH_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_DCH_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_DCH_EN            illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_CLRH_EN
+    #error "RKH_CFG_TRC_SM_CLRH_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_CLRH_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_CLRH_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_CLRH_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_TRN_EN
+    #error "RKH_CFG_TRC_SM_TRN_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_TRN_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_TRN_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_TRN_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_STATE_EN
+    #error "RKH_CFG_TRC_SM_STATE_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_STATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_STATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_STATE_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_ENSTATE_EN
+    #error "RKH_CFG_TRC_SM_ENSTATE_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_ENSTATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_ENSTATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_ENSTATE_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_EXSTATE_EN
+    #error "RKH_CFG_TRC_SM_EXSTATE_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_EXSTATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_EXSTATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_EXSTATE_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_NENEX_EN
+    #error "RKH_CFG_TRC_SM_NENEX_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_NENEX_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_NENEX_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_NENEX_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_NTRNACT_EN
+    #error "RKH_CFG_TRC_SM_NTRNACT_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_NTRNACT_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_NTRNACT_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_NTRNACT_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_TS_STATE_EN
+    #error "RKH_CFG_TRC_SM_TS_STATE_EN            not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_TS_STATE_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_TS_STATE_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_TS_STATE_EN      illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_PROCESS_EN
+    #error "RKH_CFG_TRC_SM_PROCESS_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_PROCESS_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_PROCESS_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_PROCESS_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SM_EXE_ACT_EN
+    #error "RKH_CFG_TRC_SM_EXE_ACT_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_SM_EXE_ACT_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_SM_EXE_ACT_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_SM_EXE_ACT_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_NSEQ_EN
+    #error "RKH_CFG_TRC_NSEQ_EN                   not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_NSEQ_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_NSEQ_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_NSEQ_EN             illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_CHK_EN
+    #error "RKH_CFG_TRC_CHK_EN                    not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_CHK_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_CHK_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_CHK_EN              illegally #define'd in 'rkhcfg.h'"
+    #error "                                     MUST be  RKH_ENABLED ]       "
+    #error "                                          ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_TSTAMP_EN
+    #error "RKH_CFG_TRC_TSTAMP_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                     MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFG_TRC_TSTAMP_EN != RKH_ENABLED) && \
+    (RKH_CFG_TRC_TSTAMP_EN != RKH_DISABLED))
+    #error "RKH_CFG_TRC_TSTAMP_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFGPORT_TRC_SIZEOF_TSTAMP
+    #error "RKH_CFGPORT_TRC_SIZEOF_TSTAMP         not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]       "
+    #error  "                               [     || 16  (16-bit size)]       "
+    #error  "                               [     || 32  (32-bit size)]       "
+
+    #elif  ((RKH_CFGPORT_TRC_SIZEOF_TSTAMP != 8) && \
+    (RKH_CFGPORT_TRC_SIZEOF_TSTAMP != 16) && \
+    (RKH_CFGPORT_TRC_SIZEOF_TSTAMP != 32))
+    #error  "RKH_CFGPORT_TRC_SIZEOF_TSTAMP  illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]       "
+    #error  "                               [     || 16  (16-bit size)]       "
+    #error  "                               [     || 32  (32-bit size)]       "
+    #endif
+
+    #ifndef RKH_CFGPORT_SMA_QSTO_EN
+    #error "RKH_CFGPORT_SMA_QSTO_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFGPORT_SMA_QSTO_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_SMA_QSTO_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_SMA_QSTO_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFGPORT_SMA_STK_EN
+    #error "RKH_CFGPORT_SMA_STK_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+    #elif   ((RKH_CFGPORT_SMA_STK_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_SMA_STK_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_SMA_STK_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+    #endif
+
+    #ifndef RKH_CFG_TRC_SIZEOF_STREAM
+    #error "RKH_CFG_TRC_SIZEOF_STREAM             not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >     0]                 "
+    #error  "                               [     && <= 2048]                 "
+
+    #elif   ((RKH_CFG_TRC_SIZEOF_STREAM == 0) || \
+    (RKH_CFG_TRC_SIZEOF_STREAM > 2048))
+    #error "RKH_CFG_TRC_SIZEOF_STREAM       illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >    0]                  "
+    #error  "                               [     && <= 2048]                 "
+    #endif
+
+#endif
+
+/*  FRAMEWORK     --------------------------------------------------------- */
+#ifndef RKH_CFG_FWK_MAX_SMA
+    #error "RKH_CFG_FWK_MAX_SMA                   not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >=  1]                   "
+    #error  "                               [     && <= 64]                   "
+
+#elif ((RKH_CFG_FWK_MAX_SMA == 0) || (RKH_CFG_FWK_MAX_SMA > 64))
+    #error "RKH_CFG_FWK_MAX_SMA             illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >=  1]                   "
+    #error  "                               [     && <= 64]                   "
+
+#endif
+
+#ifndef RKH_CFG_FWK_DYN_EVT_EN
+    #error "RKH_CFG_FWK_DYN_EVT_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   (RKH_CFG_FWK_DYN_EVT_EN == RKH_DISABLED)
+
+    /*
+     *	If the dynamic event support is disabled, RKH not allows to use
+     *	events with parameters, defer/recall mechanism, allocating and
+     *	recycling dynamic events, among other features.
+     */
+    #undef RKH_CFGPORT_NATIVE_DYN_EVT_EN
+    #define RKH_CFGPORT_NATIVE_DYN_EVT_EN           RKH_DISABLED
+
+#endif
+
+#ifndef RKH_CFG_FWK_MAX_EVT_POOL
+    #error "RKH_CFG_FWK_MAX_EVT_POOL              not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >    0]                  "
+    #error  "                               [     && <  256]                  "
+
+#elif   (RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED)
+    #if ((RKH_CFG_FWK_MAX_EVT_POOL == 0) || (RKH_CFG_FWK_MAX_EVT_POOL > 255))
+    #error "RKH_CFG_FWK_MAX_EVT_POOL        illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >    0]                  "
+    #error  "                               [     && <  256]                  "
+    #endif
+
+#endif
+
+#ifndef RKH_CFG_FWK_SIZEOF_EVT
+    #error "RKH_CFG_FWK_SIZEOF_EVT                not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]       "
+    #error  "                               [     || 16  (16-bit size)]       "
+    #error  "                               [     || 32  (32-bit size)]       "
+
+#elif  ((RKH_CFG_FWK_SIZEOF_EVT != 8) && \
+    (RKH_CFG_FWK_SIZEOF_EVT != 16) && \
+    (RKH_CFG_FWK_SIZEOF_EVT != 32))
+    #error  "RKH_CFG_FWK_SIZEOF_EVT         illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]       "
+    #error  "                               [     || 16  (16-bit size)]       "
+    #error  "                               [     || 32  (32-bit size)]       "
+
+#endif
+
+#ifndef RKH_CFG_FWK_MAX_SIGNALS
+    #error "RKH_CFG_FWK_MAX_SIGNALS               not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >  0]                    "
+    #error  "                        [MUST be <  2^RKH_CFG_FWK_SIZEOF_EVT    "
+
+#elif ((RKH_CFG_FWK_MAX_SIGNALS == 0u) || \
+    (RKH_CFG_FWK_MAX_SIGNALS >= RKH_BIT(RKH_CFG_FWK_SIZEOF_EVT)))
+    #error "RKH_CFG_FWK_MAX_SIGNALS         illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be >  0]                    "
+    #error  "                        [MUST be <  2^RKH_CFG_FWK_SIZEOF_EVT    "
+
+#endif
+
+#ifndef RKH_CFG_FWK_SIZEOF_EVT_SIZE
+    #error "RKH_CFG_FWK_SIZEOF_EVT_SIZE           not #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]       "
+    #error  "                               [     || 16  (16-bit size)]       "
+    #error  "                               [     || 32  (32-bit size)]       "
+
+#elif  ((RKH_CFG_FWK_SIZEOF_EVT_SIZE != 8) && \
+    (RKH_CFG_FWK_SIZEOF_EVT_SIZE != 16) && \
+    (RKH_CFG_FWK_SIZEOF_EVT_SIZE != 32))
+    #error  "RKH_CFG_FWK_SIZEOF_EVT_SIZE    illegally #define'd in 'rkhcfg.h'"
+    #error  "                               [MUST be  8  ( 8-bit size)]       "
+    #error  "                               [     || 16  (16-bit size)]       "
+    #error  "                               [     || 32  (32-bit size)]       "
+
+#endif
+
+#ifndef RKH_CFG_FWK_DEFER_EVT_EN
+    #error "RKH_CFG_FWK_DEFER_EVT_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_FWK_DEFER_EVT_EN == RKH_ENABLED) && \
+    (RKH_CFG_QUE_EN == RKH_DISABLED))
+    #error "RKH_CFG_QUE_EN                    illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+
+#endif
+
+#ifndef RKH_CFG_FWK_ASSERT_EN
+    #error "RKH_CFG_FWK_ASSERT_EN                not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_FWK_ASSERT_EN != RKH_ENABLED) && \
+    (RKH_CFG_FWK_ASSERT_EN != RKH_DISABLED))
+    #error "RKH_CFG_FWK_ASSERT_EN          illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_DISPATCH_EN
+    #error "RKH_CFG_HOOK_DISPATCH_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_DISPATCH_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_DISPATCH_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_DISPATCH_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_SIGNAL_EN
+    #error "RKH_CFG_HOOK_SIGNAL_EN                not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_SIGNAL_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_SIGNAL_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_SIGNAL_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_TIMEOUT_EN
+    #error "RKH_CFG_HOOK_TIMEOUT_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_TIMEOUT_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_TIMEOUT_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_TIMEOUT_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_START_EN
+    #error "RKH_CFG_HOOK_START_EN                 not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_START_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_START_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_START_EN           illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_EXIT_EN
+    #error "RKH_CFG_HOOK_EXIT_EN                  not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_EXIT_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_EXIT_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_EXIT_EN            illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_TIMETICK_EN
+    #error "RKH_CFG_HOOK_TIMETICK_EN              not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_TIMETICK_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_TIMETICK_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_TIMETICK_EN        illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_HOOK_PUT_TRCEVT_EN
+    #error "RKH_CFG_HOOK_PUT_TRCEVT_EN             not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_HOOK_PUT_TRCEVT_EN != RKH_ENABLED) && \
+    (RKH_CFG_HOOK_PUT_TRCEVT_EN != RKH_DISABLED))
+    #error "RKH_CFG_HOOK_PUT_TRCEVT_EN       illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFG_SMA_INIT_EVT_EN
+    #error "RKH_CFG_SMA_INIT_EVT_EN               not #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFG_SMA_INIT_EVT_EN != RKH_ENABLED) && \
+    (RKH_CFG_SMA_INIT_EVT_EN != RKH_DISABLED))
+    #error "RKH_CFG_SMA_INIT_EVT_EN         illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+/*  PORT          --------------------------------------------------------- */
+#ifndef RKH_CFGPORT_SMA_THREAD_EN
+    #error "RKH_CFGPORT_SMA_THREAD_EN            not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFGPORT_SMA_THREAD_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_SMA_THREAD_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_SMA_THREAD_EN      illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFGPORT_SMA_THREAD_DATA_EN
+    #error "RKH_CFGPORT_SMA_THREAD_DATA_EN       not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFGPORT_SMA_THREAD_DATA_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_SMA_THREAD_DATA_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_SMA_THREAD_DATA_EN illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFGPORT_NATIVE_SCHEDULER_EN
+    #error "RKH_CFGPORT_NATIVE_SCHEDULER_EN      not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFGPORT_NATIVE_SCHEDULER_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_NATIVE_SCHEDULER_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_NATIVE_SCHEDULER_EN illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFGPORT_NATIVE_EQUEUE_EN
+    #error "RKH_CFGPORT_NATIVE_EQUEUE_EN         not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFGPORT_NATIVE_EQUEUE_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_NATIVE_EQUEUE_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_NATIVE_EQUEUE_EN   illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#elif   ((RKH_CFGPORT_NATIVE_EQUEUE_EN == RKH_ENABLED) && \
+    (RKH_CFG_QUE_EN != RKH_ENABLED))
+    #error "RKH_CFG_QUE_EN                   illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#endif
+
+#ifndef RKH_CFGPORT_NATIVE_DYN_EVT_EN
+    #error "RKH_CFGPORT_NATIVE_DYN_EVT_EN        not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFGPORT_NATIVE_DYN_EVT_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_NATIVE_DYN_EVT_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_NATIVE_DYN_EVT_EN  illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#elif   (RKH_CFGPORT_NATIVE_DYN_EVT_EN == RKH_ENABLED)
+    #if ((RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED) && \
+    (RKH_CFG_MP_EN == RKH_DISABLED))
+    #error "RKH_CFG_FWK_DYN_EVT_EN          illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "RKH_CFG_MP_EN                   illegally #define'd in 'rkhcfg.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #endif
+
+#endif
+
+#ifndef RKH_CFGPORT_REENTRANT_EN
+    #error "RKH_CFGPORT_REENTRANT_EN             not #define'd in 'rkhport.h'"
+    #error "                                    [MUST be RKH_ENABLED ]        "
+    #error "                                    [     || RKH_DISABLED]        "
+
+#elif   ((RKH_CFGPORT_REENTRANT_EN != RKH_ENABLED) && \
+    (RKH_CFGPORT_REENTRANT_EN != RKH_DISABLED))
+    #error "RKH_CFGPORT_REENTRANT_EN       illegally #define'd in 'rkhport.h'"
+    #error "                                    [MUST be  RKH_ENABLED ]       "
+    #error "                                    [     ||  RKH_DISABLED]       "
+
+#endif
+
+#ifndef RKH_CFGPORT_TRC_SIZEOF_PTR
+    #error "RKH_CFGPORT_TRC_SIZEOF_PTR       not #define'd in 'rkhport.h'"
+    #error  "                               [MUST be  8  ( 8-bit pointer)]    "
+    #error  "                               [     || 16  (16-bit pointer)]    "
+    #error  "                               [     || 32  (32-bit pointer)]    "
+
+#elif  ((RKH_CFGPORT_TRC_SIZEOF_PTR != 8) && \
+    (RKH_CFGPORT_TRC_SIZEOF_PTR != 16) && \
+    (RKH_CFGPORT_TRC_SIZEOF_PTR != 32))
+    #error  "RKH_CFGPORT_TRC_SIZEOF_PTR illegally #define'd in 'rkhport.h'"
+    #error  "                               [MUST be  8  ( 8-bit pointer)]    "
+    #error  "                               [     || 16  (16-bit pointer)]    "
+    #error  "                               [     || 32  (32-bit pointer)]    "
+
+#endif
+
+#ifndef RKH_CFGPORT_TRC_SIZEOF_FUN_PTR
+    #error "RKH_CFGPORT_TRC_SIZEOF_FUN_PTR       not #define'd in 'rkhport.h'"
+    #error  "                               [MUST be  8  ( 8-bit pointer)]    "
+    #error  "                               [     || 16  (16-bit pointer)]    "
+    #error  "                               [     || 32  (32-bit pointer)]    "
+
+#elif  ((RKH_CFGPORT_TRC_SIZEOF_FUN_PTR != 8) && \
+    (RKH_CFGPORT_TRC_SIZEOF_FUN_PTR != 16) && \
+    (RKH_CFGPORT_TRC_SIZEOF_FUN_PTR != 32))
+    #error  "RKH_CFGPORT_TRC_SIZEOF_FUN_PTR illegally #define'd in 'rkhport.h'"
+    #error  "                               [MUST be  8  ( 8-bit pointer)]    "
+    #error  "                               [     || 16  (16-bit pointer)]    "
+    #error  "                               [     || 32  (32-bit pointer)]    "
+
+#endif
+
+/**
+ *  It can be used to convert ticks to milliseconds.
+ *  This format is more convenient and natural than ticks.
+ *  This configuration constant is not used by RKH, it is just
+ *  a value to allow an application to deal with time when
+ *  using timer services.
+ *  You can use the global constant RKH_CFG_FWK_TICK_RATE_HZ (see
+ *  rkhcfg.h) to convert time to ticks using the macros like
+ *  RKH_TIME_MS(), RKH_TIME_SEC(), and RKH_TIME_MIN().
+ */
+#define RKH_TICK_RATE_MS    \
+    ((RKH_TNT_T)(1000 / RKH_CFG_FWK_TICK_RATE_HZ))
+
+/** @{
+ *  \brief
+ *  It can be used to convert ticks to time.
+ *
+ *  This format is more convenient and natural than ticks. You can use
+ *  the global constant RKH_CFG_FWK_TICK_RATE_HZ (see rkhcfg.h) to convert
+ *  time to ticks using the macros like RKH_TIME_MS(), RKH_TIME_SEC(),
+ *  and RKH_TIME_MIN().
+ */
+#define RKH_TIME_MS(ms_)      ((ms_) / RKH_TICK_RATE_MS)
+#define RKH_TIME_SEC(s_)      ((s_) * 1000u / RKH_TICK_RATE_MS)
+#define RKH_TIME_MIN(m_)      ((m_) * 60 * 1000u / RKH_TICK_RATE_MS)
+/*@}*/
+
+/*
+ *  The following macros and constants are INTERNAL to RKH and
+ *  the user application should NOT call it.
+ */
+
+#define RKH_REGULAR                     0x80
+#define RKH_PSEUDO                      0
+#define RKH_TYPE(t,i)                   (t | i)
+
+#define RKH_UNKNOWN_VERTEX              RKH_TYPE(0,            0)
+#define RKH_BASIC                       RKH_TYPE(RKH_REGULAR,  0)
+#define RKH_COMPOSITE                   RKH_TYPE(RKH_REGULAR,  0x01)
+#define RKH_SUBMACHINE                  RKH_TYPE(RKH_REGULAR,  0x02)
+#define RKH_REF_SUBMACHINE              RKH_TYPE(RKH_REGULAR,  0x04)
+#define RKH_FINAL                       RKH_TYPE(RKH_REGULAR,  0x08)
+
+#define RKH_CONDITIONAL                 RKH_TYPE(RKH_PSEUDO,   0x02)
+#define RKH_CHOICE                      RKH_TYPE(RKH_PSEUDO,   0x04)
+#define RKH_SHISTORY                    RKH_TYPE(RKH_PSEUDO,   0x08)
+#define RKH_DHISTORY                    RKH_TYPE(RKH_PSEUDO,   0x10)
+#define RKH_ENPOINT                     RKH_TYPE(RKH_PSEUDO,   0x20)
+#define RKH_EXPOINT                     RKH_TYPE(RKH_PSEUDO,   0x40)
+
+#define RKH_NO_HISTORY                  RKH_UNKNOWN_VERTEX
+
+#if (RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_DISABLED || \
+     (RKH_CFG_SMA_DEEP_HIST_EN    == RKH_DISABLED && \
+      RKH_CFG_SMA_SHALLOW_HIST_EN == RKH_DISABLED && \
+      RKH_CFG_SMA_SUBMACHINE_EN   == RKH_DISABLED && \
+      RKH_CFG_SMA_CONDITIONAL_EN  == RKH_DISABLED && \
+      RKH_CFG_SMA_CHOICE_EN       == RKH_DISABLED))
+    #define RKH_PSEUDOSTATE     RKH_DISABLED
+#else
+    #define RKH_PSEUDOSTATE     RKH_ENABLED
+#endif
+
+#if (RKH_CFG_SMA_HCAL_EN         == RKH_ENABLED &&   \
+     RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_ENABLED &&   \
+     (RKH_CFG_SMA_SHALLOW_HIST_EN == RKH_ENABLED ||   \
+      RKH_CFG_SMA_DEEP_HIST_EN    == RKH_ENABLED))
+    #define RKH_HISTORY_ENABLED
+#endif
+
+#if (RKH_CFG_SMA_HCAL_EN         == RKH_ENABLED && \
+     RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_ENABLED && \
+     RKH_CFG_SMA_DEEP_HIST_EN    == RKH_ENABLED)
+    #define RKH_DEEP_ENABLED
+#endif
+
+#if (RKH_CFG_SMA_HCAL_EN         == RKH_ENABLED && \
+     RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_ENABLED && \
+     RKH_CFG_SMA_SHALLOW_HIST_EN == RKH_ENABLED)
+    #define RKH_SHALLOW_ENABLED
+#endif
+
+#if (RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_ENABLED && \
+     RKH_CFG_SMA_SUBMACHINE_EN   == RKH_ENABLED)
+    #define RKH_SUBMACHINE_ENABLED
+#endif
+
+#if (RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_ENABLED && \
+     RKH_CFG_SMA_CHOICE_EN       == RKH_ENABLED)
+    #define RKH_CHOICE_ENABLED
+#endif
+
+#if (RKH_CFG_SMA_PSEUDOSTATE_EN  == RKH_ENABLED && \
+     (RKH_CFG_SMA_CONDITIONAL_EN  == RKH_ENABLED || \
+      RKH_CFG_SMA_CHOICE_EN       == RKH_ENABLED))
+    #define RKH_CHOICE_OR_CONDITIONAL_ENABLED
+#endif
+
+#if (RKH_CFG_TRC_EN == RKH_ENABLED  && \
+     (RKH_CFG_TRC_ALL_EN == RKH_ENABLED || \
+      RKH_CFG_TRC_SMA_EN == RKH_ENABLED || \
+      RKH_CFG_TRC_SM_EN == RKH_ENABLED || \
+      RKH_CFG_TRC_FWK_EN == RKH_ENABLED))
+    #define R_TRC_AO_NAME_EN    RKH_ENABLED
+#else
+    #define R_TRC_AO_NAME_EN    RKH_DISABLED
+#endif
+
+#define MKTRN(evt_, guard_, effect_, target_) \
+    { \
+        evt_, (RKH_GUARD_T)guard_, \
+        (RKH_TRN_ACT_T)effect_, (RKHROM RKH_ST_T *)target_ \
+    }
+
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define MKSM(constSM, initialState) \
+        (RKHROM RKH_ROM_T *)(constSM), /** RKH_SM_T::romrkh member */ \
+        (RKHROM RKH_ST_T *)(initialState) /** RKH_SM_T::state member */
+
+    #if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+        #define MKSMA(constSM, initialState) \
+            { \
+                MKSM(constSM, initialState), /** RKH_SM_T members */ \
+                &rkhSmaVtbl /** RKH_SMA_T::vptr member */ \
+            }
+    #else
+        #define MKSMA(constSM, initialState) \
+            { \
+                MKSM(constSM, initialState)  /** RKH_SM_T members */ \
+            }
+    #endif
+#else
+    #if (RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED)
+        #if R_TRC_AO_NAME_EN == RKH_ENABLED
+            #define MKSM(name, prio, ppty, initialState, initialAction, \
+                         initialEvt) \
+                (prio), (ppty), #name, (RKHROM RKH_ST_T*)initialState, \
+                ((RKH_INIT_ACT_T)initialAction), (initialEvt), \
+                (RKHROM RKH_ST_T*)initialState
+        #else
+            #define MKSM(name, prio, ppty, initialState, initialAction, \
+                         initialEvt) \
+                (prio), (ppty), (RKHROM RKH_ST_T*)initialState, \
+                ((RKH_INIT_ACT_T)initialAction), (initialEvt), \
+                (RKHROM RKH_ST_T*)initialState
+        #endif
+    #else
+        #if R_TRC_AO_NAME_EN == RKH_ENABLED
+            #define MKSM(name, prio, ppty, initialState, initialAction, \
+                         initialEvt) \
+                (prio), (ppty), #name, (RKHROM RKH_ST_T*)initialState, \
+                ((RKH_INIT_ACT_T)initialAction), \
+                (RKHROM RKH_ST_T*)initialState
+        #else
+            #define MKSM(name, prio, ppty, initialState, initialAction, \
+                         initialEvt) \
+                (prio), (ppty), (RKHROM RKH_ST_T*)initialState, \
+                ((RKH_INIT_ACT_T)initialAction), \
+                (RKHROM RKH_ST_T*)initialState
+        #endif
+    #endif
+    #if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+        #define MKSMA(name, prio, ppty, \
+                      initialState, initialAction, initialEvt) \
+            { \
+                MKSM(name, prio, ppty, initialState, \
+                     initialAction, initialEvt), /* RKH_SM_T members */ \
+                &rkhSmaVtbl /** RKH_SMA_T::vptr member */ \
+            }
+    #else
+        #define MKSMA(name, prio, ppty, \
+                      initialState, initialAction, initialEvt) \
+            { \
+                MKSM(name, prio, ppty, initialState, \
+                     initialAction, initialEvt)  /* RKH_SM_T members */ \
+            }
+    #endif
+
+    #define MKRT_SM(sm_, name_, prio_, ppty_, initialState_, initialAction_, \
+                    initialEvt_) \
+        ((RKH_SM_T *)(sm_))->prio = prio_; \
+        ((RKH_SM_T *)(sm_))->ppty = ppty_; \
+        MKSM_NAME(sm_, name_); \
+        ((RKH_SM_T *)(sm_))->istate = (RKHROM RKH_ST_T*)initialState_; \
+        ((RKH_SM_T *)(sm_))->iaction = (RKH_INIT_ACT_T)initialAction_; \
+        MKSM_IEVENT(sm_, initialEvt_); \
+        ((RKH_SM_T *)(sm_))->state = (RKHROM RKH_ST_T*)initialState_
+
+    #if R_TRC_AO_NAME_EN == RKH_ENABLED
+        #if RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED
+            #define MKSM_NAME(sm_, name_) \
+                ((RKH_SM_T *)sm_)->name = #name_
+            #define MKSM_IEVENT(sm_, ievent_) \
+                ((RKH_SM_T *)sm_)->ievent = ievent_
+        #else
+            #define MKSM_NAME(sm_, name_) \
+                ((RKH_SM_T *)sm_)->name = #name_
+            #define MKSM_IEVENT(sm_, ievent_)
+        #endif
+    #else
+        #if RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED
+            #define MKSM_NAME(sm_, name_) \
+            #define MKSM_IEVENT(sm_, ievent_) \
+                ((RKH_SM_T *)sm_)->ievent = ievent_
+        #else
+            #define MKSM_NAME(sm_, name_) \
+            #define MKSM_IEVENT(sm_, ievent_)
+        #endif
+    #endif
+#endif
+
+#if (RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED)
+    #if R_TRC_AO_NAME_EN == RKH_ENABLED
+        #define MKRRKH(name, prio, ppty, is, ia, ie) \
+            { \
+                (prio), (ppty), # name, (RKHROM RKH_ST_T *)is, \
+                (RKH_INIT_ACT_T)(ia), (ie) \
+            }
+    #else
+        #define MKRRKH(name, prio, ppty, is, ia, ie) \
+            { \
+                (prio), (ppty), (RKHROM RKH_ST_T *)is, \
+                (RKH_INIT_ACT_T)(ia), (ie) \
+            }
+    #endif
+#else
+    #if R_TRC_AO_NAME_EN == RKH_ENABLED
+        #define MKRRKH(name, prio, ppty, is, ia, ie) \
+            { \
+                (prio), (ppty), # name, (RKHROM RKH_ST_T *)is, \
+                (RKH_INIT_ACT_T)(ia) \
+            }
+    #else
+        #define MKRRKH(name, prio, ppty, is, ia, ie) \
+            { \
+                (prio), (ppty), (RKHROM RKH_ST_T *)is, \
+                (RKH_INIT_ACT_T)(ia) \
+            }
+    #endif
+#endif
+
+#if R_TRC_AO_NAME_EN == RKH_ENABLED
+    #define MKBASE(t, n)        {t, # n}
+#else
+    #define MKBASE(t, n)        {t}
+#endif
+
+#if (RKH_CFG_SMA_HCAL_EN == RKH_ENABLED)
+    #if (RKH_CFG_SMA_PPRO_EN == RKH_ENABLED)
+        #if defined(RKH_HISTORY_ENABLED)
+            #define MKBASIC(n,pp)               n##_trtbl, (RKH_PPRO_T)pp
+            #define MKCOMP(n, d, dftTrn_, h)    n##_trtbl, NULL, d, \
+                                                (RKH_INIT_ACT_T)dftTrn_, h
+            #define MKHIST_INCOMP(name, kOfH, dTG, dTA, dTT, ramMem) \
+                RKHROM RKH_SHIST_T name##Hist = \
+                { \
+                    MKBASE(kOfH, name##Hist), \
+                    (RKHROM RKH_ST_T *)&name, ramMem, \
+                    RKH_TRREG(0, dTG, dTA, dTT) \
+                }
+            #define MKHISTORY(name, parent, kOfH, dTG, dTA, dTT, ramMem) \
+                RKHROM RKH_SHIST_T name = \
+                { \
+                    MKBASE(kOfH, name), \
+                    (RKHROM RKH_ST_T *)parent, ramMem, \
+                    RKH_TRREG(0, dTG, dTA, dTT) \
+                }
+            #define MKFINAL(name_) \
+                name_##_trtbl, NULL
+            #define MKFINAL_INCOMP(name_) \
+                RKH_CREATE_FINAL_STATE(name_##Final, &name_)
+        #else
+            #define MKBASIC(n,pp)               n##_trtbl, (RKH_PPRO_T)pp
+            #define MKCOMP(n, d, dftTrn_, h)    n##_trtbl, NULL, d, \
+                                                (RKH_INIT_ACT_T)dftTrn_
+            #define MKHIST_INCOMP(name, kOfH, dTG, dTA, dTT, ramMem)
+            #define MKHISTORY(name, parent, kOfH, dTG, dTA, dTT, ramMem)
+            #define MKFINAL(name_) \
+                name_##_trtbl, NULL
+            #define MKFINAL_INCOMP(name_) \
+                RKH_CREATE_FINAL_STATE(name_##Final, &name_)
+        #endif
+    #else
+        #if defined(RKH_HISTORY_ENABLED)
+            #define MKBASIC(n,pp)               n##_trtbl
+            #define MKCOMP(n, d, dftTrn_, h)    n##_trtbl, d, \
+                                                (RKH_INIT_ACT_T)dftTrn_, h
+            #define MKHIST_INCOMP(name, kOfH, dTG, dTA, dTT, ramMem) \
+                RKHROM RKH_SHIST_T name##Hist = \
+                { \
+                    MKBASE(kOfH, name##Hist), \
+                    (RKHROM RKH_ST_T *)&name, ramMem, \
+                    RKH_TRREG(0, dTG, dTA, dTT) \
+                }
+            #define MKHISTORY(name, parent, kOfH, dTG, dTA, dTT, ramMem) \
+                RKHROM RKH_SHIST_T name = \
+                { \
+                    MKBASE(kOfH, name), \
+                    (RKHROM RKH_ST_T *)parent, ramMem, \
+                    RKH_TRREG(0, dTG, dTA, dTT) \
+                }
+            #define MKFINAL(name_) \
+                name_##_trtbl
+            #define MKFINAL_INCOMP(name_) \
+                RKH_CREATE_FINAL_STATE(name_##Final, &name_)
+        #else
+            #define MKBASIC(n,pp)               n##_trtbl
+            #define MKCOMP(n, d, dftTrn_, h)    n##_trtbl, d, \
+                                                (RKH_INIT_ACT_T)dftTrn_
+            #define MKHIST_INCOMP(name, kOfH, dTG, dTA, dTT, ramMem)
+            #define MKHISTORY(name, parent, kOfH, dTG, dTA, dTT, ramMem)
+            #define MKFINAL(name_) \
+                name_##_trtbl
+            #define MKFINAL_INCOMP(name_) \
+                RKH_CREATE_FINAL_STATE(name_##Final, &name_)
+        #endif
+    #endif
+    #define MKST(en,ex,p)           (RKH_ENT_ACT_T)en, \
+                                    (RKH_EXT_ACT_T)ex, \
+                                    (RKHROM RKH_ST_T *)p
+    #define MKSBM(n,sbm)            n##_trtbl,n##_exptbl,sbm
+    #define MKMCH(d,i,n)            d, (RKH_TRN_ACT_T)i, \
+                                    (RKHROM RKH_ST_T * *)&rdyp_##n
+    #define MKENP(e,s)              e,(RKHROM RKH_ST_T *)s
+#else
+    #if (RKH_CFG_SMA_PPRO_EN == RKH_ENABLED)
+        #define MKBASIC(n,pp)       n##_trtbl, (RKH_PPRO_T)pp
+        #define MKCOMP(n, d, dftTrn_, h)        n##_trtbl, NULL
+        #define MKFINAL(name_)
+        #define MKFINAL_INCOMP(name_)
+    #else
+        #define MKBASIC(n,pp)       n##_trtbl
+        #define MKCOMP(n, d, dftTrn_, h)        n##_trtbl
+        #define MKFINAL(name_)
+        #define MKFINAL_INCOMP(name_)
+    #endif
+    #define MKST(en,ex,p)
+    #define MKSBM(n,sbm)            n##_trtbl,n##_exptbl,sbm
+    #define MKMCH(d,i,n)            d, (RKH_TRN_ACT_T)i, \
+                                    (RKHROM RKH_ST_T *)&rdyp_##n
+    #define MKENP(e,s)              e,(RKHROM RKH_ST_T *)s
+#endif
+
+#define MK_SET_EVT(ev_obj, ev_sig) \
+    ((RKH_EVT_T *)(ev_obj))->e = (RKH_SIG_T)ev_sig;  \
+    ((RKH_EVT_T *)(ev_obj))->nref = 0; \
+    ((RKH_EVT_T *)(ev_obj))->pool = 0
+
+#define MK_EVT(ev_obj, ev_sig) \
+    RKH_EVT_T ev_obj = {ev_sig, 0, 0}
+
+#define MK_ROM_EVT(ev_obj, ev_sig) \
+    RKHROM RKH_EVT_T ev_obj = {ev_sig,  0, 0}
+
+#define MK_EVT_STRUCT(ev_sig) \
+    {ev_sig, 0, 0}
+
+#ifndef RKH_DIS_INTERRUPT
+    #error \
+    "rkhport.h, Must be defined the platform-dependent macro RKH_DIS_INTERRUPT"
+#endif
+
+#ifndef RKH_ENA_INTERRUPT
+    #error \
+    "rkhport.h, Must be defined the platform-dependent macro RKH_ENA_INTERRUPT"
+#endif
+
+#ifndef RKH_EN_DOXYGEN
+    #define RKH_EN_DOXYGEN  0
+#endif
+
+#if RKH_EN_DOXYGEN == RKH_ENABLED
+    /**
+     *  \addtogroup config
+     *  @{
+     *  \addtogroup configPort Related to RKH port
+     *  @{
+     *  \brief Configuration options related to RKH port
+     */
+
+    /**
+     *  \brief
+     *	If the #RKH_CFGPORT_SMA_THREAD_EN is set to 1, each SMA (active
+     *	object) has its own thread of execution.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_DISABLED
+     */
+    #define RKH_CFGPORT_SMA_THREAD_EN           RKH_ENABLED
+
+    /**
+     *  \brief
+     *	If the #RKH_CFGPORT_SMA_THREAD_EN and
+     *	#RKH_CFGPORT_SMA_THREAD_DATA_EN are set to 1, each SMA (active
+     *	object) has its own thread of execution and its own object data.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_DISABLED
+     */
+    #define RKH_CFGPORT_SMA_THREAD_DATA_EN      RKH_ENABLED
+
+    /**
+     *  \brief
+     *  If the #RKH_CFGPORT_NATIVE_SCHEDULER_EN is set to 1 then RKH will
+     *  include the simple, cooperative, and nonpreemptive scheduler RKHS.
+     *  When #RKH_CFGPORT_NATIVE_SCHEDULER_EN is enabled RKH also will
+     *  automatically define #RKH_EQ_TYPE, RKH_SMA_BLOCK(), RKH_SMA_READY(),
+     *  RKH_SMA_UNREADY(), and assume the native priority scheme.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_ENABLED
+     */
+    #define RKH_CFGPORT_NATIVE_SCHEDULER_EN     RKH_ENABLED
+
+    /**
+     *  \brief
+     *  If the #RKH_CFGPORT_NATIVE_EQUEUE_EN is set to 1 and the native
+     *  event queue is enabled (see #RKH_CFG_QUE_EN) then RKH will include
+     *  its own implementation of rkh_sma_post_fifo(), rkh_sma_post_lifo(),
+     *  and rkh_sma_get() functions.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_ENABLED
+     */
+    #define RKH_CFGPORT_NATIVE_EQUEUE_EN        RKH_ENABLED
+
+    /**
+     *  \brief
+     *  If the #RKH_CFGPORT_NATIVE_DYN_EVT_EN is set to 1 and the native 
+     *  fixed-size memory block facility is enabled (see #RKH_CFG_MP_EN) then 
+     *  RKH will include its own implementation of dynamic memory management.
+     *  When #RKH_CFGPORT_NATIVE_DYN_EVT_EN is enabled RKH also will provide 
+     *  the event pool manager implementation based on its native memory pool 
+     *  module.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_ENABLED
+     */
+    #define RKH_CFGPORT_NATIVE_DYN_EVT_EN       RKH_ENABLED
+
+    /**
+     *  \brief
+     *	If the #RKH_CFGPORT_REENTRANT_EN is set to 1, the RKH event dispatch
+     *	allows to be invoked from several threads of executions. Enable this
+     *	only if the application is based on a multi-thread architecture.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_DISABLED
+     */
+    #define RKH_CFGPORT_REENTRANT_EN            RKH_ENABLED
+
+    /**
+     *  \brief
+     *  Specify the size of void pointer. The valid values [in bits] are
+     *  16 or 32. Default is 32. See RKH_TRC_SYM() macro.
+     *
+     *	\type       Integer
+     *	\range      [8, 16, 32]
+     *	\default    32
+     */
+    #define RKH_CFGPORT_TRC_SIZEOF_PTR          32u
+
+    /**
+     *  \brief
+     *  Specify the size of function pointer. The valid values [in bits] are
+     *  16 or 32. Default is 32. See RKH_TUSR_FUN() and RKH_TRC_FUN() macros.
+     *
+     *	\type       Integer
+     *	\range      [8, 16, 32]
+     *	\default    32
+     */
+    #define RKH_CFGPORT_TRC_SIZEOF_FUN_PTR      32u
+
+    /**
+     *  \brief
+     *  Specify the number of bytes (size) used by the trace record timestamp.
+     *  The valid values [in bits] are 8, 16 or 32. Default is 16.
+     *
+     *	\type       Integer
+     *	\range      [8, 16, 32]
+     *	\default    16
+     */
+    #define RKH_CFGPORT_TRC_SIZEOF_TSTAMP       32u
+
+    /**
+     *  \brief
+     *  If the #RKH_CFGPORT_SMA_QSTO_EN is set to 1 then RKH_SMA_ACTIVATE()
+     *  macro invokes the rkh_sma_activate() function ignoring the external
+     *  event queue storage argument, \c qs.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_ENABLED
+     */
+    #define RKH_CFGPORT_SMA_QSTO_EN             RKH_ENABLED
+
+    /**
+     *  \brief
+     *  If the #RKH_CFGPORT_SMA_STK_EN is set to 0 then RKH_SMA_ACTIVATE()
+     *  macro invokes the rkh_sma_activate() function ignoring the thread's
+     *  stack related arguments, \c stks and \c stksize.
+     *
+     * \type       Boolean 
+     * \range      
+     * \default    RKH_DISABLED
+     */
+    #define RKH_CFGPORT_SMA_STK_EN              RKH_ENABLED
+
+    /** @} doxygen end group definition */
+    /** @} doxygen end group definition */
+
+    /**
+     *  \brief
+     *  Defines the data type of the event queue for active objects.
+     *  The event queue can be implemented with a message queue of
+     *  the RTOS/OS. But it is also possible to use the native RKH
+     *  queue RKH_QUEUE_T type if the underlying RTOS/OS does not provide
+     *  an adequate queue.
+     *
+     *  <EM>Example for using the native queue</EM>
+     *  \code
+     *	// RKH's native queue
+     *  #define RKH_EQ_TYPE			RKH_QUEUE_T
+     *	// Message queue of ucos/II
+     *  #define RKH_EQ_TYPE			OS_EVENT
+     *	// Message queue of FreeRTOS
+     *  #define RKH_EQ_TYPE			xQueueHandle
+     *  \endcode
+     */
+    #define RKH_EQ_TYPE
+
+    /**
+     *  \brief
+     *  Frequently, the active object has its own task processing loop that
+     *  waits for the signal to be posted, and when it is, loops to remove
+     *  and process all events that are currently queued.
+     *  The RKH_SMA_POST_FIFO() macro enqueues an event and signals	the OS
+     *  that an event has arrived. In this case, \c os_signal holds the OS
+     *  object used to signal that an event has been queued.
+     *  The data type RKH_THREAD_TYPE holds the thread handle associated
+     *  with the active object.
+     *
+     *  <EM>Example for using the uCOS/II, FreeRTOS, Linux (Posix) and
+     *  Win32</EM>
+     *  \code
+     *	// For uCOS/II
+     *  #define RKH_THREAD_TYPE		INT8U
+     *	// For FreeRTOS
+     *  #define RKH_THREAD_TYPE		xTaskHandle
+     *	// For Linux (Posix)
+     *  #define RKH_THREAD_TYPE		pthread_t
+     *	// For Win32
+     *  #define RKH_THREAD_TYPE		void*
+     *  \endcode
+     */
+    #define RKH_THREAD_TYPE
+
+    /**
+     *  \brief
+     *  The \c os_signal member of RKH_SMA_T is necessary when the underlying
+     *  OS does not provide an adequate queue facility, so the native RKH
+     *  queue RKH_QUEUE_T must be used. In this case the RKH_OSSIGNAL_TYPE
+     *  indicates an operating system specific primitive to efficiently
+     *  block the native RKH event queue when the queue is empty.
+     *  Frequently, the active object has its own task processing loop that
+     *  waits for the signal to be posted, and when it is, loops to remove
+     *  and process all events that are currently queued.
+     *  The RKH_SMA_POST_FIFO() macro enqueues an event and signals	the OS
+     *  that an event has arrived. In this case, \c os_signal holds the OS
+     *  object used to signal that an event has been queued.
+     *
+     *  <EM>Example for using the Linux (Posix) and Win32</EM>
+     *  \code
+     *	// For Linux (Posix)
+     *  #define RKH_OSSIGNAL_TYPE	pthread_cond_t
+     *	// For Win32
+     *  #define RKH_OSSIGNAL_TYPE	void*
+     *  \endcode
+     */
+    #define RKH_OSSIGNAL_TYPE
+
+    /**@{
+     *  \brief
+     *  RKH need to disable interrupts in order to access critical sections
+     *  of code, and re-enable interrupts when done. This allows RKH to
+     *  protect critical code from being entered simultaneously. To hide the
+     *  implementation method chosen by the processor, compiler, etc, RKH
+     *  defines two macros to unconditionally disable and enable interrupts:
+     *  RKH_DIS_INTERRUPT() and RKH_ENA_INTERRUPT() respectively. Obviously,
+     *  they resides in \b rkhport.h file, which the user always need to
+     *  provide.
+     *
+     *  <EM>Example for HCS08 CW6.3 from C:</EM>
+     *  \code
+     *  #define RKH_DIS_INTERRUPT()			DisableInterrupts
+     *  #define RKH_ENA_INTERRUPT()			EnableInterrupts
+     *  \endcode
+     */
+    #define RKH_DIS_INTERRUPT()
+    #define RKH_ENA_INTERRUPT()
+    /*@}*/
+
+    /**@{
+     *  \brief
+     *  RKH need to disable interrupts in order to access critical sections of
+     *  code, and re-enable interrupts when done.
+     *
+     *  This allows RKH to protect
+     *  critical code from being entered simultaneously from either multiple
+     *  SMAs or ISRs. Every processor generally provide instructions to
+     *  disable/enable interrupts and the C compiler must have a mechanism to
+     *  perform these operations directly from C. Some compilers will allows
+     *  to insert in-line assembly language statements in the C source code.
+     *  This makes it quite easy to insert processor instructions to enable and
+     *  disable interrupts. Other compilers will actually contain language
+     *  extensions to enable and disable interrupts directly from C. To hide
+     *  the implementation method chosen by the compiler manufacturer, RKH
+     *  defines two macros to disable and enable interrupts:
+     *  RKH_ENTER_CRITICAL() and RKH_EXIT_CRITICAL().
+     *
+     *  The RKH_ENTER_CRITICAL() macro saves the interrupt disable status onto
+     *  the stack and then, disable interrupts.
+     *  RKH_EXIT_CRITICAL() would simply be implemented by restoring the
+     *  interrupt status from the stack. Using this scheme, if it's called a
+     *  RKH service with either interrupts enabled or disabled then, the
+     *  status would be preserved across the call. If calls a RKH service with
+     *  interrupts disabled, is potentially extending the interrupt latency of
+     *  application. The application can use RKH_ENTER_CRITICAL() and
+     *  RKH_EXIT_CRITICAL() to also protect critical sections of code. As a
+     *  general rule, should always call RKH services with interrupts enabled!.
+     *
+     *  \note
+     *  These macros are internal to RKH and the user application should
+     *  not call it.
+     *
+     *  <EM>Example for x86, VC2008, and win32 single thread:</EM>
+     *  \code
+     *  //#define RKH_CPUSR_TYPE
+     *  #define RKH_ENTER_CRITICAL( dummy )		EnterCriticalSection(&csection)
+     *  #define RKH_EXIT_CRITICAL( dummy )		LeaveCriticalSection(&csection)
+     *  \endcode
+     */
+    #define RKH_CPUSR_TYPE
+    #define RKH_SR_ALLOC() \
+        RKH_CPUSR_TYPE sr = (RKH_CPUSR_TYPE)0
+    #define RKH_ENTER_CRITICAL(dummy)
+    #define RKH_EXIT_CRITICAL(dummy)
+    /*@}*/
+#endif
+
+#ifdef RKH_CPUSR_TYPE
+    #if RKH_EN_DOXYGEN == RKH_DISABLED
+        #define RKH_SR_ALLOC()          RKH_CPUSR_TYPE sr = (RKH_CPUSR_TYPE)0
+        #define RKH_ENTER_CRITICAL_()   RKH_ENTER_CRITICAL(sr)
+        #define RKH_EXIT_CRITICAL_()    RKH_EXIT_CRITICAL(sr)
+    #endif
+#else
+    #define RKH_SR_ALLOC()
+    #define RKH_ENTER_CRITICAL_()       RKH_ENTER_CRITICAL(dummy)
+    #define RKH_EXIT_CRITICAL_()        RKH_EXIT_CRITICAL(dummy)
+#endif
+
+#if (RKH_CFG_SMA_INIT_ARG_SMA_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED)
+    #define RKH_EXEC_INIT(me_, action_) \
+        if ((RKH_INIT_ACT_T)action_) \
+        { \
+            (*(RKH_INIT_ACT_T)action_)((me_), \
+                                      RKH_SMA_ACCESS_CONST(CM(me_), ievent)); \
+            RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_INI, \
+                              (me_), \
+                              0, \
+                              CM(me_)); \
+        }
+    #define RKH_EXEC_STATE_INIT(me_, action_) \
+        RKH_EXEC_INIT(me_, action_)
+#elif (RKH_CFG_SMA_INIT_ARG_SMA_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_INIT_EVT_EN == RKH_DISABLED)
+    #define RKH_EXEC_INIT(me_, action_) \
+        if ((RKH_INIT_ACT_T)action_) \
+        { \
+            (*(RKH_INIT_ACT_T)action_)((me_)); \
+            RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_INI, \
+                              (me_), \
+                              0, \
+                              CM(me_)); \
+        }
+    #define RKH_EXEC_STATE_INIT(me_, action_) \
+        RKH_EXEC_INIT(me_, action_)
+#elif (RKH_CFG_SMA_INIT_ARG_SMA_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED)
+    #define RKH_EXEC_INIT(me_, action_) \
+        if ((RKH_INIT_ACT_T)action_) \
+        { \
+            (*(RKH_INIT_ACT_T)action_)(RKH_SMA_ACCESS_CONST(CM(me_), ievent)); \
+            RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_INI, \
+                              (me_), \
+                              0, \
+                              CM(me_)); \
+        }
+    #define RKH_EXEC_STATE_INIT(me_, action_) \
+        RKH_EXEC_INIT(me_, action_)
+#else
+    #define RKH_EXEC_INIT(me_, action_) \
+        if ((RKH_INIT_ACT_T)action_) \
+        { \
+            (*(RKH_INIT_ACT_T)action_)(); \
+            RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_INI, \
+                              (me_), \
+                              0, \
+                              CM(me_)); \
+        }
+    #define RKH_EXEC_STATE_INIT(me_, action_) \
+        RKH_EXEC_INIT(me_, action_)
+#endif
+
+#if RKH_CFG_SMA_ENT_ARG_SMA_EN == RKH_ENABLED
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+        #define RKH_EXEC_ENTRY(state_, me_) \
+            if ((state_)->enter) \
+            { \
+                (*(state_)->enter)(me_, state_); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EN, \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->enter); \
+            }
+    #else
+        #define RKH_EXEC_ENTRY(state_, me_) \
+            if ((state_)->enter) \
+            { \
+                (*(state_)->enter)(me_); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EN, \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->enter); \
+            }
+    #endif
+#else
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+        #define RKH_EXEC_ENTRY(state_, me_) \
+            if ((state_)->enter) \
+            { \
+                (*(state_)->enter)(state_); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EN, \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->enter); \
+            }
+    #else
+    #define RKH_EXEC_ENTRY(state_, me_) \
+        if ((state_)->enter) \
+        { \
+            (*(state_)->enter)(); \
+            RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EN, \
+                              (me_), \
+                              (state_), \
+                              (state_)->enter); \
+        }
+    #endif
+#endif
+
+#if RKH_CFG_SMA_EXT_ARG_SMA_EN == RKH_ENABLED
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+        #define RKH_EXEC_EXIT(state_, me_) \
+            if ((state_)->exit) \
+            { \
+                (*(state_)->exit)(me_, state_); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EX, \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->exit); \
+            }
+    #else
+        #define RKH_EXEC_EXIT(state_, me_) \
+            if ((state_)->exit) \
+            { \
+                (*(state_)->exit)(me_); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EX,  \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->exit); \
+            }
+    #endif
+#else
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+        #define RKH_EXEC_EXIT(state_, me_) \
+            if ((state_)->exit) \
+            { \
+                (*(state_)->exit)(state_); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EX, \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->exit); \
+            }
+    #else
+        #define RKH_EXEC_EXIT(state_, me_) \
+            if ((state_)->exit) \
+            {  \
+                (*(state_)->exit)(); \
+                RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EX, \
+                                  (me_), \
+                                  (state_), \
+                                  (state_)->exit); \
+            }
+    #endif
+#endif
+
+#if RKH_CFG_SMA_PPRO_ARG_SMA_EN == RKH_ENABLED
+    #define RKH_EXEC_PREPRO(state_, me_, evt_) \
+        (*(state_)->prepro)(me_, evt_); \
+        RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_PP, \
+                          (me_), \
+                          (((RKH_SM_T *)me_))->state, \
+                          (state_)->prepro)
+#else
+    #define RKH_EXEC_PREPRO(state_, me_, evt_) \
+        (*(state_)->prepro)(evt_); \
+        RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_PP, \
+                          (me_), \
+                          (((RKH_SM_T *)me_))->state, \
+                          (state_)->prepro)
+#endif
+
+#if (RKH_CFG_SMA_ACT_ARG_EVT_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_ACT_ARG_SMA_EN == RKH_ENABLED)
+    #define RKH_EXEC_EFF(action_, me_, evt_) \
+        (*CTA(action_))((me_), (evt_)); \
+        RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EFF, \
+                          (me_), \
+                          (((RKH_SM_T *)me_))->state, \
+                          (action_))
+#elif (RKH_CFG_SMA_ACT_ARG_EVT_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_ACT_ARG_SMA_EN == RKH_DISABLED)
+    #define RKH_EXEC_EFF(action_, me_, evt_) \
+        (*CTA(action_))((evt_)); \
+        RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EFF, \
+                          (me_), \
+                          (((RKH_SM_T *)me_))->state, \
+                          (action_))
+#elif (RKH_CFG_SMA_ACT_ARG_EVT_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_ACT_ARG_SMA_EN == RKH_ENABLED)
+    #define RKH_EXEC_EFF(action_, me_, evt_) \
+        (*CTA(action_))((me_)); \
+        RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EFF, \
+                          (me_), \
+                          (((RKH_SM_T *)me_))->state, \
+                          (action_))
+#else
+    #define RKH_EXEC_EFF(action_, me_, evt_) \
+        (*CTA(action_))(); \
+        RKH_TR_SM_EXE_ACT(RKH_SUBTE_SM_EXE_ACT_EFF, \
+                          (me_), \
+                          (((RKH_SM_T *)me_))->state, \
+                          (action_))
+#endif
+
+#if (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+    #define RKH_EXEC_GUARD(trn_, me_, evt_) \
+        (*(trn_)->guard)(me_, evt_)
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_DISABLED)
+    #define RKH_EXEC_GUARD(trn_, me_, evt_) \
+        (*(trn_)->guard)(evt_)
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+    #define RKH_EXEC_GUARD(trn_, me_, evt_) \
+        (*(trn_)->guard)(me_)
+#else
+    #define RKH_EXEC_GUARD(trn_, me_, evt_) \
+        (*(trn_)->guard)()
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+#ifndef NULL
+#define NULL    (void *)0
+#endif
+
+/* ------------------------------- Data types ------------------------------ */
+typedef struct RKH_ROM_T RKH_ROM_T;
+typedef struct RKHSmaVtbl RKHSmaVtbl;
+typedef struct RKH_SM_T RKH_SM_T;
+typedef struct RKH_SMA_T RKH_SMA_T;
+typedef struct RKH_TR_T RKH_TR_T;
+typedef struct RKH_BASE_T RKH_BASE_T;
+typedef struct RKH_ST_T RKH_ST_T;
+typedef struct RKH_SHIST_T RKH_SHIST_T;
+typedef struct RKH_SBSC_T RKH_SBSC_T;
+typedef struct RKH_SCMP_T RKH_SCMP_T;
+typedef struct RKH_FINAL_T RKH_FINAL_T;
+typedef struct RKH_EXPCN_T RKH_EXPCN_T;
+typedef struct RKH_ENPCN_T RKH_ENPCN_T;
+typedef struct RKH_SSBM_T RKH_SSBM_T;
+typedef struct RKH_RSM_T RKH_RSM_T;
+typedef struct RKH_SENP_T RKH_SENP_T;
+typedef struct RKH_SEXP_T RKH_SEXP_T;
+typedef struct RKH_SCOND_T RKH_SCOND_T;
+typedef struct RKH_SCHOICE_T RKH_SCHOICE_T;
+
+/* -------------------------- External variables --------------------------- */
+/**
+ *  \brief
+ *  String representing the name of undefined object name.
+ */
+extern RKHROM char noname[];
+
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhmempool.h ./rkh/inc/rkhmempool.h
--- a_qSC69Z/rkh/inc/rkhmempool.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhmempool.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,432 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhmempool.h
+ *  \brief      Platform - independent interface for supporting fixed - size
+ *              memory blocks facility.
+ *
+ *  \ingroup    apiMemPool
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiMemPool Manager of fixed-sized memory block
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHMEMPOOL_H__
+#define __RKHMEMPOOL_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+#include "rkhcfg.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  Defines the size of number of memory block size. The valid values
+ *  [in bits] are 8, 16 or 32. Default is 8. This type is configurable via
+ *  the preprocessor switch RKH_CFG_MP_SIZEOF_NBLOCK.
+ */
+#if RKH_CFG_MP_SIZEOF_NBLOCK == 8
+typedef rui8_t RKH_MPNB_T;
+#elif RKH_CFG_MP_SIZEOF_NBLOCK == 16
+typedef rui16_t RKH_MPNB_T;
+#elif RKH_CFG_MP_SIZEOF_NBLOCK == 32
+typedef rui32_t RKH_MPNB_T;
+#else
+typedef rui8_t RKH_MPNB_T;
+#endif
+
+/**
+ *  Defines the size of memory block size. The valid values [in bits] are
+ *  8, 16 or 32. Default is 8. This type is configurable via the
+ *  preprocessor switch RKH_CFG_MP_SIZEOF_BSIZE.
+ */
+#if RKH_CFG_MP_SIZEOF_BSIZE == 8
+typedef rui8_t RKH_MPBS_T;
+#elif RKH_CFG_MP_SIZEOF_BSIZE == 16
+typedef rui16_t RKH_MPBS_T;
+#elif RKH_CFG_MP_SIZEOF_BSIZE == 32
+typedef rui32_t RKH_MPBS_T;
+#else
+typedef rui8_t RKH_MPBS_T;
+#endif
+
+/**
+ *  \brief
+ *  Defines the data structure into which the performance information for
+ *  memory pools is stored.
+ */
+typedef struct
+{
+    /**
+     *  \brief
+     *  Number of pool create requests.
+     */
+    rui8_t inits;
+
+    /**
+     *  \brief
+     *	Number of get memory block requests.
+     */
+    rui8_t gets;
+
+    /**
+     *  \brief
+     *	Number of put memory block requests.
+     */
+    rui8_t puts;
+
+    /**
+     *  \brief
+     *	Number of no free retrieves.
+     */
+    rui8_t free;
+
+    /**
+     *  \brief
+     *	Number of full retrieves.
+     */
+    rui8_t full;
+} RKH_MPI_T;
+
+/**
+ *  \brief
+ *  Defines the data structure used to memory block pool facility.
+ *
+ *  Since memory block pools consist of fixed-size blocks, there are
+ *  never any fragmentation problems. Of course, fragmentation causes
+ *  behavior that is inherently un-deterministic. In addition, the time
+ *  required to allocate and free a fixed-size memory is comparable to
+ *  that of simple linked-list manipulation.
+ *  Lack of flexibility is the main drawback of fixed-size memory pools.
+ *  The block size of a pool must be large enough to handle the worst
+ *  case memory requirements of its users. Of course, memory may be wasted
+ *  if many different size memory requests are made to the same pool.
+ *  A possible solution is to make several different memory block pools
+ *  that contain different sized memory blocks. Each memory block pool
+ *  is a public resource.
+ *
+ *  The memory block pools contain a number of fixed-size blocks. The block
+ *  size, in bytes, is specified during creation of the pool. Each memory
+ *  block in the pool imposes a small amount of overhead the size of a C
+ *  pointer. In addition, RKH may pad the block size in order to keep the
+ *  beginning of each memory block on proper alignment.
+ *
+ *  The number of memory blocks in a pool depends on the block size and the
+ *  total number of bytes in the memory area supplied during creation. To
+ *  calculate the capacity of a pool (number of blocks that will be
+ *  available), divide the block size (including padding and the pointer
+ *  overhead bytes) into the total number of bytes in the supplied memory
+ *  area.
+ *
+ *  The memory area for the block pool is specified during creation, and can
+ *  be located anywhere in the target's address space. This is an important
+ *  feature because of the considerable flexibility it gives the application.
+ *
+ *	\note
+ *  RKH prohibits an application from explicitly modifying the RKH_MEMPOOL_T
+ *  structure. The RKH's memory block pool structures can be located anywhere
+ *  in memory, but it is most common to make it a global structure by
+ *  defining it outside the scope of any function.
+ *  An RKH memory pool is created when an memory pool is declared with the
+ *  RKH_MEMPOOL_T data type. The following listing declares "my_pool" memory 
+ *  pool:
+ *
+ *  \code
+ *  RKH_MEMPOOL_T my_pool;
+ *  \endcode
+ *
+ *  \ingroup apiMemPool
+ */
+typedef struct RKH_MEMPOOL_T
+{
+    /**
+     *  \brief
+     *	The head of the linked list of free blocks.
+     *
+     *	The only data member strictly required for allocating and freeing
+     *	blocks in the pool is the head of the free list 'free'.
+     */
+    void *free;
+
+    /**
+     *  \brief
+     *  Number of free blocks remaining.
+     */
+    RKH_MPNB_T nfree;
+
+    /**
+     *  \brief
+     *  Total number of blocks in bytes.
+     *
+     *  The type RKH_MPNB_T is configurable by the macro
+     *  RKH_CFG_MP_SIZEOF_NBLOCK.
+     *  The valid values [in bits] are 8, 16 or 32. Default is 8. The dynamic
+     *  range of the RKH_MPNB_T data type determines the maximum number of
+     *  blocks that can be stored in the pool.
+     */
+    RKH_MPNB_T nblocks;
+
+    /**
+     *  \brief
+     *  Maximum block size in bytes.
+     *
+     *  The type RKH_MPBS_T is configurable by the macro
+     *  RKH_CFG_MP_SIZEOF_BSIZE. The valid values [in bits] are 8, 16 or 32.
+     *  Default is 8. The dynamic range of the RKH_MPBS_T data type
+     *  determines the maximum size of blocks that can be managed by the
+     *  pool manager.
+     */
+    RKH_MPBS_T bsize;
+
+#if RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+    /**
+     *  \brief
+     *  The start of the original pool buffer.
+     *
+     *  The start and end pointers are used as delimiters of the valid range
+     *  of memory blocks managed by this pool.
+     */
+    void *start;
+
+    /**
+     *  \brief
+     *  The last block in this pool.
+     */
+    void *end;
+
+    /**
+     *  \brief
+     *  Minimum number of free blocks ever in this pool, i.e. holds
+     *  the lowest number of free blocks ever present in the pool.
+     *
+     *	The nmin low-watermark provides valuable empirical data for
+     *	proper sizing of the memory pool.
+     */
+#if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED
+    RKH_MPNB_T nmin;
+#endif
+
+#endif
+
+    /**
+     *  Performance information. This member is optional, thus it could be
+     *  eliminated in compile-time with RKH_CFG_MP_GET_INFO_EN.
+     */
+#if RKH_CFG_MP_GET_INFO_EN == RKH_ENABLED
+    RKH_MPI_T mpi;
+#endif
+} RKH_MEMPOOL_T;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *	Initializes the previously allocated memory pool data strcuture 
+ *	RKH_MEMPOOL_T.
+ *
+ *  A memory block pool is declared with the RKH_MEMPOOL_T data type and is
+ *  defined with the rkh_memPool_init() service.
+ *
+ *  A general challenge in writing this function is portability,
+ *  because storage allocation is intrinsically machine-dependent. Perhaps
+ *  the trickiest aspect here is the proper and optimal alignment of the
+ *  blocks within the contiguous memory buffer. In particular, the alignment
+ *  of blocks must be such that every new block can be treated as a pointer
+ *  to the next block [MS].
+ *	Internally, this function rounds up the block size so that it can fit
+ *	an integer number of pointers. This is done to achieve proper alignment
+ *	of the blocks within the pool. Due to the rounding of block size the
+ *	actual capacity of the pool might be less than (pool_size/blk_size).
+ *	[MS]
+ *
+ *	Check the capacity of the pool by calling the rkh_memPool_get_nfree()
+ *	function.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *  \param[in] sstart	storage start. Pointer to memory from which memory 
+ *                      blocks are allocated.
+ *  \param[in] ssize 	storage size. Size of the memory pool storage in bytes.
+ *  \param[in] bsize	block size. This number determines the size of each
+ *                      memory block in the pool.
+ *
+ *	\note
+ *	See RKH_MEMPOOL_T structure for more information.
+ *
+ *  \ingroup apiMemPool
+ */
+void rkh_memPool_init(RKH_MEMPOOL_T *mp, void *sstart, rui16_t ssize,
+                 RKH_MPBS_T bsize);
+
+/**
+ *  \brief
+ *  Get a memory block from one of the previously allocated memory pool.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *
+ *  \return
+ *  A pointer to a new memory block or NULL if the pool runs out of blocks.
+ *
+ *  \ingroup apiMemPool
+ */
+void *rkh_memPool_get(RKH_MEMPOOL_T *mp);
+
+/**
+ *  \brief
+ *  When the application is done with the memory block, it must be returned
+ *  to the appropiate memory pool. The block must be allocated from the same
+ *  memory pool to which it is returned.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *  \param[in] blk		pointer to the returned memory block.
+ *
+ *  \ingroup apiMemPool
+ */
+void rkh_memPool_put(RKH_MEMPOOL_T *mp, void *blk);
+
+/**
+ *  \brief
+ *  Retrieves the size of memory block in bytes.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *
+ *  \return
+ *  The size of memory block in bytes.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_MP_GET_BSIZE_EN.
+ *
+ *  \ingroup apiMemPool
+ */
+RKH_MPBS_T rkh_memPool_get_bsize(RKH_MEMPOOL_T *mp);
+
+/**
+ *  \brief
+ *  Retrieves the current number of free memory blocks in the pool.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *
+ *  \return
+ *  The number of free memory blocks in the pool.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_MP_GET_NFREE_EN.
+ *
+ *  \ingroup apiMemPool
+ */
+RKH_MPNB_T rkh_memPool_get_nfree(RKH_MEMPOOL_T *mp);
+
+/**
+ *  \brief
+ *  Retrieves the lowest number of free blocks ever present in the pool.
+ *  This number provides valuable empirical data for proper sizing of the
+ *  memory pool.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *
+ *  \return
+ *  Lowest number of free blocks ever present in the pool.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_MP_GET_LWM_EN.
+ *
+ *  \ingroup apiMemPool
+ */
+RKH_MPNB_T rkh_memPool_get_low_wmark(RKH_MEMPOOL_T *mp);
+
+/**
+ *  \brief
+ *  Retrieves performance information for a particular memory pool.
+ *
+ *  Information is available during run-time for each of the RKSYS
+ *  resources. This information can be useful in determining whether
+ *  the application is performing properly, as well as helping to
+ *  optimize the application.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *  \param[in] mpi		pointer to the buffer into which the performance
+ *                      information will be copied by reference.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_MP_GET_INFO_EN.
+ *
+ *  \ingroup apiMemPool
+ */
+void rkh_memPool_get_info(RKH_MEMPOOL_T *mp, RKH_MPI_T *mpi);
+
+/**
+ *  \brief
+ *  Clear performance information for a particular memory pool.
+ *
+ *  \param[in] mp		pointer to previously allocated memory pool structure.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_MP_GET_INFO_EN.
+ *
+ *  \ingroup apiMemPool
+ */
+void rkh_memPool_clear_info(RKH_MEMPOOL_T *mp);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhplat.h ./rkh/inc/rkhplat.h
--- a_qSC69Z/rkh/inc/rkhplat.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhplat.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,135 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhplat.h
+ *  \brief      RKH platform - dependent interface.
+ *  \ingroup    apiPortMisc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHPLAT_H__
+#define __RKHPLAT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#ifdef __W32STVC__
+    #include "..\..\portable\80x86\win32_st\vc\rkhport.h"
+#endif
+
+#ifdef __W32MTVC__
+    #include "..\..\portable\80x86\win32_mt\vc\rkhport.h"
+#endif
+
+#ifdef __LNXGNU__
+    #include "../../portable/80x86/linux_st/gnu/rkhport.h"
+#endif
+
+#ifdef __S08CW63__
+    #include "..\..\portable\s08\rkhs\cw6_3\rkhport.h"
+#endif
+
+#ifdef __CFV1CW63__
+    #include "..\..\portable\cfv1\rkhs\cw6_3\rkhport.h"
+#endif
+
+#ifdef __ARM_CM0CW10__
+    #include "../../portable/arm-cortex/rkhs/arm_cm0/cw_v10/rkhport.h"
+#endif
+
+#ifdef __ARM_CM4FCW10__
+    #include "../../portable/arm-cortex/rkhs/arm_cm4f/cw_v10/rkhport.h"
+#endif
+
+#ifdef __KSDK_KDS__
+    #include "..\..\portable\arm-cortex\rkhs\ksdk\kds\rkhport.h"
+#endif
+
+#ifdef __KSDK_OS_KDS__
+    #include "..\..\portable\arm-cortex\ksdk_os\ucosiii\kds\rkhport.h"
+#endif
+
+#ifdef __UCOS_V3_03_01__
+    #include "..\..\portable\ucos\v3.03.01\rkhport.h"
+#endif
+
+#ifdef __ARM_CM3XPRESSO___
+    #include "../../portable/arm-cortex/rkhs/arm_cm3/codered/rkhport.h"
+#endif
+
+#ifdef __EDUCIAA_EID__
+    #include "rkhport.h"
+#endif
+
+#ifdef __TEST__
+    #include "..\..\portable\test\rkhport.h"
+#endif
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *	If RKHROM has not been defined then	\b rkhport.h has not yet been
+ *	included - as every \b rkhport.h provides a RKHROM definition.
+ */
+
+#ifndef RKHROM
+    #error "rkhplat.h: Missing definition of platform to be used. \
+    See Porting chapter in readme file for more information"
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhport.h ./rkh/inc/rkhport.h
--- a_qSC69Z/rkh/inc/rkhport.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhport.h	2018-01-19 23:55:11.000319018 -0300
@@ -0,0 +1,181 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhport.h
+ * 	\brief 		ARM Cortex-M MCU's, LPCXpresso port
+ *  \ingroup    port
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  Daba  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ *  DaBa  Dario Baliï¿½a       dariosb@gmail.com
+ */
+
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHPORT_H__
+#define __RKHPORT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtype.h"
+#include "rkhqueue.h"
+#include "rkhmempool.h"
+#include "rkhsma_prio.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#define RKH_DIS_INTERRUPT()				__asm volatile ("cpsid i")
+#define RKH_ENA_INTERRUPT()				__asm volatile ("cpsie i")
+#define RKH_ENTER_CRITICAL( dummy )		rkhport_enter_critical()
+#define RKH_EXIT_CRITICAL( dummy )		rkhport_exit_critical()
+
+/* ------------------------------- Constants ------------------------------- */
+
+#define KERNEL_IRQ_PRIO		6
+#define HIGHEST_IRQ_PRI		5
+        
+/**
+ *	If the #RKH_CFGPORT_SMA_THREAD_EN is set to 1, each SMA (active object) has its own 
+ *	thread of execution.
+ */
+#define RKH_CFGPORT_SMA_THREAD_EN 			RKH_DISABLED
+
+/**
+ *	If the #RKH_CFGPORT_SMA_THREAD_EN and #RKH_CFGPORT_SMA_THREAD_DATA_EN 
+ *	are set to 1, each SMA (active object) has its own thread of execution 
+ *	and its own object data.
+ */
+#define RKH_CFGPORT_SMA_THREAD_DATA_EN		RKH_DISABLED
+
+/**
+ * 	If the #RKH_CFGPORT_NATIVE_SCHEDULER_EN is set to 1 then RKH will 
+ * 	include the simple, cooperative, and nonpreemptive scheduler RKHS.
+ * 	When #RKH_CFGPORT_NATIVE_SCHEDULER_EN is enabled RKH also will 
+ * 	automatically define #RKH_EQ_TYPE, RKH_SMA_BLOCK(), RKH_SMA_READY(), 
+ * 	RKH_SMA_UNREADY(), and assume the native priority scheme.
+ */
+#define RKH_CFGPORT_NATIVE_SCHEDULER_EN		RKH_ENABLED
+
+/**
+ * 	If the #RKH_CFGPORT_NATIVE_EQUEUE_EN is set to 1 and the native event 
+ * 	queue is enabled (see #RKH_CFG_RQ_EN) then RKH will include its own 
+ * 	implementation of rkh_sma_post_fifo(), rkh_sma_post_lifo(), and 
+ * 	rkh_sma_get() functions.
+ */
+#define RKH_CFGPORT_NATIVE_EQUEUE_EN		RKH_ENABLED
+
+/**
+ * 	If the #RKH_CFGPORT_NATIVE_DYN_EVT_EN is set to 1 and the native 
+ * 	fixed-size memory block facility is enabled (see #RKH_CFG_MP_EN) then 
+ * 	RKH will include its own implementation of dynamic memory management.
+ * 	When #RKH_CFGPORT_NATIVE_DYN_EVT_EN is enabled RKH also will 
+ * 	automatically define RKH_DYNE_TYPE, RKH_DYNE_INIT(), 
+ * 	RKH_DYNE_GET_ESIZE(), RKH_DYNE_GET(), RKH_DYNE_PUT(), 
+ * 	RKH_DYNE_GET_NUSED(), RKH_DYNE_GET_NMIN(), and RKH_DYNE_GET_PSIZE() macros.
+ */
+#define RKH_CFGPORT_NATIVE_DYN_EVT_EN		RKH_ENABLED
+
+/**
+ *	If the #RKH_CFGPORT_REENTRANT_EN is set to 1, the RKH event dispatch 
+ *	allows to be invoked from several threads of executions. Enable this 
+ *	only if the application is based on a multi-thread architecture.
+ */
+#define RKH_CFGPORT_REENTRANT_EN			RKH_DISABLED
+
+/**
+ * 	Specify the size of void pointer. The valid values [in bits] are 
+ * 	16 or 32. Default is 32. See RKH_TRC_SYM() macro.
+ */
+#define RKH_CFGPORT_TRC_SIZEOF_PTR			32u
+
+/**
+ * 	Specify the size of function pointer. The valid values [in bits] are 
+ * 	16 or 32. Default is 32. See RKH_TUSR_FUN() and RKH_TRC_FUN() macros.
+ */
+#define RKH_CFGPORT_TRC_SIZEOF_FUN_PTR		32u
+
+/** 
+ * 	Specify the number of bytes (size) used by the trace record timestamp. 
+ * 	The valid values [in bits] are 8, 16 or 32. Default is 16.
+ */
+#define RKH_CFGPORT_TRC_SIZEOF_TSTAMP		32u
+
+/** 
+ * 	If the #RKH_CFGPORT_SMA_QSTO_EN is set to 1 then RKH_SMA_ACTIVATE() 
+ * 	macro invokes the rkh_sma_activate() function ignoring the external 
+ * 	event queue storage argument, \c qs.
+ */
+#define RKH_CFGPORT_SMA_QSTO_EN				RKH_ENABLED
+
+/** 
+ * 	If the #RKH_CFGPORT_SMA_STK_EN is set to 0 then RKH_SMA_ACTIVATE() 
+ * 	macro invokes the rkh_sma_activate() function ignoring the thread's 
+ * 	stack related arguments, \c stks and \c stksize.
+ */
+#define RKH_CFGPORT_SMA_STK_EN				RKH_DISABLED
+
+/*
+ * 	Declaring an object RKHROM announces that its value will
+ * 	not be changed and it will be stored in ROM.
+ */
+#define RKHROM								const
+
+/**
+ * Native event queue data type
+ */
+#define RKH_EQ_TYPE              		    RKH_QUEUE_T
+
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+const char *rkhport_get_version(void);
+const char *rkhport_get_desc(void);
+void rkhport_enter_critical(void);
+void rkhport_exit_critical(void);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhqueue.h ./rkh/inc/rkhqueue.h
--- a_qSC69Z/rkh/inc/rkhqueue.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhqueue.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,460 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhqueue.h
+ *  \brief      Platform - independent interface for supporting queue services.
+ *
+ *  \ingroup    apiQueue
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiQueue Event queues
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHQUEUE_H__
+#define __RKHQUEUE_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhcfg.h"
+#include "rkhtype.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *  This macro query the queue.
+ *
+ *  \param[in] q		pointer to previously created queue.
+ *
+ *  \return
+ *  '1' (RKH_TRUE) if queue is empty, otherwise '0' (RKH_FALSE).
+ *
+ *  \ingroup apiQueue 
+ */
+#define RKH_QUEUE_IS_EMPTY(q) \
+    (rbool_t)(rkh_queue_get_num((RKH_QUEUE_T *)(q)) == 0)
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  \brief
+ *  This data type defines the maximum number of elements that any queue
+ *	can contain.
+ *
+ *	The valid values [in bits] are 8, 16 or 32. Default is 8. This type is
+ *	configurable via the preprocessor switch RKH_CFG_QUE_SIZEOF_NELEM.
+ */
+#if RKH_CFG_QUE_SIZEOF_NELEM == 8
+typedef rui8_t RKH_QUENE_T;
+#elif RKH_CFG_QUE_SIZEOF_NELEM == 16
+typedef rui16_t RKH_QUENE_T;
+#elif RKH_CFG_QUE_SIZEOF_NELEM == 32
+typedef rui32_t RKH_QUENE_T;
+#else
+typedef rui8_t RKH_QUENE_T;
+#endif
+
+/**
+ *  \brief
+ *  Return codes from queue operations.
+ */
+typedef enum
+{
+    RKH_QUE_OK, RKH_QUE_EMPTY, RKH_QUE_FULL
+} RKH_QUECODE_T;
+
+/**
+ *  \brief
+ *  Defines the data structure into which the performance information for
+ *  queues is stored.
+ *
+ *	The application must allocate an RKH_QUEI_T data structure used to
+ *	receive information. The performance information is available during
+ *	run-time for each of the RKH services. This can be useful in determining
+ *	whether the application is performing properly, as well as helping to
+ *	optimize the application.
+ */
+typedef struct RKH_QINFO_T
+{
+    rui16_t nputs;      /*	# of put requests */
+    rui16_t ngets;      /*	# of get requests */
+    rui16_t nreads;     /*	# of queue read requests */
+    rui16_t nempty;     /*	# of queue empty retrieves */
+    rui16_t nfull;      /*	# of queue full retrieves */
+} RKH_QUEI_T;
+
+/**
+ *  \brief
+ *  Defines the data structure used to maintain information about the queue.
+ *
+ *  The queue is a buffer-like object through which state machine
+ *  applications (SMA) and ISRs send and receive messages to communicate and
+ *  synchornize with data. It temporarily holds pointer to messages from a
+ *  sender until the intended receiver is ready to read them.
+ *
+ *  The number of messages a queue can hold depends on its message size
+ *  (pointer size) and the size of the memory area supplied during creation.
+ *  To calculate the total message capacity of the queue, divide the number
+ *  of bytes in each message into the total number of bytes in the supplied
+ *
+ *  The memory area for buffering messages is specified during queue
+ *  creation. It can be located anywhere in the target's address space.
+ *  This is an important feature because it gives the application
+ *  considerable flexibility.
+ *
+ *  \note
+ *  RKH prohibits an application from explicitly modifying the RKH_QUEUE_T
+ *  structure. The RKH's queue structures can be located anywhere in memory,
+ *  but it is most common to make it a global structure by defining it
+ *  outside the scope of any function.
+ *  An RKH queue is created when an queue (copy by reference) is declared
+ *  with the RKH_QUEUE_T data type. The following listing declares "gsmque"
+ *  timer:
+ *
+ *  \code
+ *  RKH_QUEUE_T gsmque;
+ *  \endcode
+ *
+ *  \ingroup apiQueue 
+ */
+typedef struct RKH_QUEUE_T
+{
+    /**
+     *  \brief
+     *  Number of elements.
+     */
+    RKH_QUENE_T nelems;
+
+    /**
+     *  \brief
+     *  Number of elements currently in the queue.
+     */
+    RKH_QUENE_T qty;
+
+    /**
+     *  \brief
+     *	Points to the free next place in the storage area.
+     */
+    void **pout;
+
+    /**
+     *  \brief
+     *  Points to the next place of queued item.
+     */
+    void **pin;
+
+    /**
+     *  \brief
+     *  Points to beginning of the queue storage area.
+     */
+    const void **pstart;
+
+    /**
+     *  \brief
+     *  Points to the end of the queue storage area.
+     */
+    void **pend;
+
+    /**
+     *  \brief
+     *  Points to the associated SMA (a.k.a Active Object) that receives the
+     *  enqueued events.
+     *
+     *  \note
+     *  If \a sma is set to NULL they never block.
+     */
+    const struct RKH_SMA_T *sma;
+
+    /**
+     *  \brief
+     *  Minimum number of free elements ever in this queue.
+     *	The nmin low-watermark provides valuable empirical data for
+     *	proper sizing of the queue.
+     */
+#if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+    RKH_QUENE_T nmin;
+#endif
+
+    /**
+     *  \brief
+     *  Performance information. This member is optional, thus it could be
+     *  eliminated in compile-time with RKH_CFG_QUE_GET_INFO_EN.
+     */
+#if RKH_CFG_QUE_GET_INFO_EN == RKH_ENABLED
+    RKH_QUEI_T rqi;
+#endif
+} RKH_QUEUE_T;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ * \brief
+ *	Initializes the previously allocated queue data structure RKH_QUEUE_T.
+ *
+ *  A queue is declared with the RKH_QUEUE_T data type and is defined with the
+ *  rkh_queue_init() service. The total number of messages is calculated from
+ *  the specified message size (pointer size) and the total number of bytes
+ *  in the queue. Note that if the total number of bytes specified in the
+ *  queue's memory area is not evenly divisible by the specified message
+ *  size, the remaining bytes in the memory area are not used.
+ *
+ *  \param[in] q		pointer to previously allocated queue structure.
+ *  \param[in] sstart	storage start. Pointer to an array of pointers that 
+ *                      holds the elements. This array must be declared as an 
+ *                      array of void pointers.
+ *  \param[in] ssize	storage size [in the units of void pointers].
+ *  \param[in] sma		pointer to associated SMA that receives the enqueued
+ *                      events. If \a sma is set to NULL they never block. When
+ *                      using a queue to store deferred events the \a sma
+ *                      parameter must be set to NULL.
+ *
+ *	\sa
+ *	RKH_QUEUE_T structure for more information.
+ *
+ *  \ingroup apiQueue 
+ */
+void rkh_queue_init(RKH_QUEUE_T *q, const void * *sstart, RKH_QUENE_T ssize,
+                 void *sma);
+
+/**
+ *  \brief
+ *  This function query the queue.
+ *
+ *  \param[in] q	pointer to previously created queue.
+ *
+ *  \return
+ *  '1' (RKH_TRUE) if queue is full, otherwise '0' (RKH_FALSE).
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_IS_FULL_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+rbool_t rkh_queue_is_full(RKH_QUEUE_T *q);
+
+/**
+ *  \brief
+ *  Returns the number of elements currently in the queue.
+ *
+ *  \param[in] q	pointer to previously created queue.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_GET_NELEMS_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+RKH_QUENE_T rkh_queue_get_num(RKH_QUEUE_T *q);
+
+/**
+ *	\brief
+ *  This function returns the lowest number of free elements ever present
+ *  in the pool.
+ *  This number provides valuable empirical data for proper sizing of the
+ *  queue.
+ *
+ *  \param[in] q	pointer to previously created queue.
+ *
+ *  \return
+ *  Lowest number of free elements ever present in the queue.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_GET_LWMARK_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+RKH_QUENE_T rkh_queue_get_lwm(RKH_QUEUE_T *q);
+
+/**
+ *  \brief
+ *	Get and remove an element from a queue.
+ *
+ *  \param[in] q	pointer to previously created queue from which the
+ *                  elements are received.
+ *
+ *  \ingroup apiQueue 
+ */
+void *rkh_queue_get(RKH_QUEUE_T *q);
+
+/**
+ *  \brief
+ *	Puts an element on a queue in a FIFO manner. The element is queued by
+ *	reference, not by copy.
+ *
+ *  \param[in] q	pointer to previously created queue into which the element
+ *                  is deposited.
+ *  \param[in] pe	pointer-sized variable and is application specific.
+ *
+ *  \note
+ *  This function must be invoked within a critical section.
+ *  \note
+ *  The function raises an assertion if the queue becomes full and cannot
+ *  accept the element.
+ *
+ *  \ingroup apiQueue 
+ */
+void rkh_queue_put_fifo(RKH_QUEUE_T *q, const void *pe);
+
+/**
+ *  \brief
+ *	Puts an element on a queue in a LIFO manner. The element is queued by
+ *	reference, not by copy.
+ *
+ *  \param[in] q	pointer to previously created queue into which the element
+ *                  is deposited.
+ *  \param[in] pe	pointer-sized variable and is application specific.
+ *
+ *  \note
+ *  This function must be invoked within a critical section.
+ *  \note
+ *  The function raises an assertion if the queue becomes full and cannot
+ *  accept the element.
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_PUT_LIFO_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+void rkh_queue_put_lifo(RKH_QUEUE_T *q, const void *pe);
+
+/**
+ *  \brief
+ *	Depletes a queue. Empties the contents of the queue and eliminates all
+ *	stored elements.
+ *
+ *  \param[in] q	pointer to previously created queue.
+ *
+ *	\note
+ *	This function should be used with great care because, when to flush the
+ *	queue, the references are LOOSE to what the queue entries are pointing
+ *	to and thus, could cause 'memory leaks'. In other words, the data
+ *	pointing to that's being referenced by the queue entries should, most
+ *	likely, need to be deallocated. To flush a queue that contains entries,
+ *	is much safer instead repeateadly use rkh_queue_get().
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_DEPLETE_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+void rkh_queue_deplete(RKH_QUEUE_T *q);
+
+/**
+ *  \brief
+ *	Read an element from a queue without remove it.
+ *
+ *  \param[in] q	pointer to previously created queue from which the
+ *                  elements are received.
+ *  \param[in] pe	pointer to the buffer into which the received item will be
+ *                  copied.
+ *
+ *  \return
+ *  RKH_QUE_OK if an element was successfully readed from the queue, otherwise
+ *  error code.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_READ_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+ruint rkh_queue_read(RKH_QUEUE_T *q, void *pe);
+
+/**
+ *  \brief
+ *  Retrieves performance information for a particular queue.
+ *
+ *	The user application must allocate an RKH_QUEI_T data structure used to
+ *	receive data. The performance information is available during run-time
+ *	for each of the RKH services. This can be useful in determining whether
+ *	the application is performing properly, as well as helping to optimize the
+ *	application.
+ *	This information provides a "snapshot" a particular instant in time, i.e.,
+ *	when the service is invoked.
+ *
+ *  \param[in] q	pointer to previously created queue.
+ *  \param[in] pqi	pointer to the buffer into which the performance
+ *                  information will be copied.
+ *
+ *  \note
+ *  See RKH_QUEI_T structure for more information. This function is
+ *  optional, thus it could be eliminated in compile-time with
+ *  RKH_CFG_QUE_GET_INFO_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+void rkh_queue_get_info(RKH_QUEUE_T *q, RKH_QUEI_T *pqi);
+
+/**
+ *  \brief
+ *  Clear performance information for a particular queue.
+ *
+ *  \param[in] q	pointer to previously created queue.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_QUE_GET_INFO_EN.
+ *
+ *  \ingroup apiQueue 
+ */
+void rkh_queue_clear_info(RKH_QUEUE_T *q);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhsma.h ./rkh/inc/rkhsma.h
--- a_qSC69Z/rkh/inc/rkhsma.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhsma.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,1213 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsma.h
+ *  \brief      Platform - independent interface for supporting acive objects 
+ *              (SMA state machine applications)
+ *
+ *  \ingroup    apiAO
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiAO Active objects
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHSMA_H__
+#define __RKHSMA_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhsm.h"
+#include "rkhqueue.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#define RKH_SMA_NAME(smaName_)       s_##smaName_
+
+/**
+ *  \brief
+ *  Macro for accessing to state member of state machine structure.
+ *
+ *  \param[in] me_      Pointer to object of state machine.
+ */
+#define RKH_SMA_ACCESS_STATE(me_) \
+    ((RKH_SM_T *)me_)->state
+
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+/**
+ *  \brief
+ *  Macro for accessing to members of state machine structure.
+ *
+ *  \param[in] me_      Pointer to object of state machine.
+ *  \param[in] member_  Member of state machine structure.
+ */
+    #define RKH_SMA_ACCESS_CONST(me_, member_) \
+        ((RKH_SM_T *)me_)->romrkh->member_
+#else
+/**
+ *  \brief
+ *  Macro for accessing to members of state machine structure.
+ *
+ *  \param[in] me_      Pointer to object of state machine.
+ *  \param[in] member_  Member of state machine structure.
+ */
+    #define RKH_SMA_ACCESS_CONST(me_, member_) \
+        ((RKH_SM_T *)me_)->member_
+#endif
+
+/**
+ *  \brief
+ *  This macro declares a opaque pointer to previously created state machine
+ *  application (SMA aka active object) to be used as a global object.
+ *
+ *  This global pointer represent the active object in the application.
+ *  These pointers are "opaque" because they cannot access the whole active 
+ *  object structure, but only the part inherited from the RKH_SMA_T structure.
+ *  The power of an "opaque" pointer is that it allows to completely hide the 
+ *  definition of the active object structure and make it inaccessible to the 
+ *  rest of the application, thus strengthening the encapsulation concept.
+ *
+ *  \param[in] me_  pointer to previously created state machine application.
+ *
+ *	\note
+ *  Generally, this macro is used in the SMA's header file.
+ *
+ *  \sa
+ *  RKH_SMA_CREATE().
+ *
+ *  \usage
+ *  \code
+ *  //	my.h: state-machine application's header file
+ *
+ *  RKH_SMA_DCLR(my);
+ *  \endcode
+ */
+#define RKH_SMA_DCLR(me_) \
+            RKH_DCLR_PTR_TYPE(RKH_SMA_T, me_)
+
+/**
+ *  \brief
+ *  This macro declares a typed pointer to previously created state machine
+ *  application (SMA aka active object) to be used as a global and public 
+ *  object.
+ *
+ *  \param[in] type_
+ *                  Data type of the state machine application. Could be 
+ *                  derived from RKH_SMA_T.
+ *                  The pointer could be used to publish the internals of the 
+ *                  class of the state machine. 
+ *  \param[in] me_	pointer to previously created state machine application.
+ *
+ *	\note
+ *  Generally, this macro is used in the SMA's header file.
+ *
+ *  \sa
+ *  RKH_SMA_CREATE(), RKH_SMA_DCLR().
+ *
+ *  \usage
+ *  \code
+ *  //	my.h: state-machine application's header file
+ *
+ *  RKH_SMA_DCLR_TYPE(Blinky, blinky);
+ *  \endcode
+ */
+#define RKH_SMA_DCLR_TYPE(type_, me_) \
+            RKH_DCLR_PTR_TYPE(type_, me_)
+
+/**
+ *  \brief
+ *  Invoke the active object activation function rkh_sma_activate(). 
+ *  If RKH_CFG_SMA_VFUNCT_EN is set RKH_ENABLED, this operation is 
+ *  polymorphic, where its implementation is defined by the virtual table of 
+ *  the active object to activate. 
+ *
+ *  This macro is the recommended way of invoke the rkh_sma_activate()
+ *  function to active an active object, because it allows to
+ *  completely hides the platform-specific code.
+ *
+ *  \param[in] me_	    pointer to previously created state machine
+ *                      application.
+ *  \param[in] qSto_	base address of the event storage area. A message
+ *                      storage area is declared as an array of pointers
+ *                      to RKH events.
+ *  \param[in] qStoSize size of the storage event area [in number of
+ *                      entries].
+ *  \param[in] stkSto_	starting address of the stack's memory area.
+ *  \param[in] stkSize_ size of stack memory area [in bytes].
+ *
+ *  \note
+ *  In the next releases this macro will be improved, calling a function 
+ *  instead of using its own vptr.  
+ *
+ *	\sa
+ *	rkh_sma_activate().
+ *
+ *  \usage
+ *	\code
+ *	int
+ *	main( int argc, char *argv[] )
+ *	{
+ *		...
+ *		RKH_SMA_ACTIVATE( blinky, qsto, QSTO_SIZE, 0, 0 );
+ *		...
+ *		return 0;
+ *	}
+ *	\endcode
+ *
+ *  \ingroup apiAO
+ */
+#if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+#if RKH_CFGPORT_SMA_QSTO_EN == RKH_ENABLED
+    #if RKH_CFGPORT_SMA_STK_EN == RKH_ENABLED
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+         ((RKH_SMA_T *)(me_))->vptr->activate(me_, \
+                                              (const RKH_EVT_T **)qSto_, \
+                                              qStoSize, \
+                                              (void *)stkSto_, \
+                                              (rui32_t)stkSize_)
+    #else
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        ((RKH_SMA_T *)(me_))->vptr->activate(me_, \
+                                             (const RKH_EVT_T **)qSto_, \
+                                             qStoSize, \
+                                             (void *)0, \
+                                             (rui32_t)0)
+    #endif
+#else
+    #if RKH_CFGPORT_SMA_STK_EN == RKH_ENABLED
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        ((RKH_SMA_T *)(me_))->vptr->activate(me_, \
+                                             (const RKH_EVT_T **)0, \
+                                             qStoSize, \
+                                             (void *)stkSto_, \
+                                             (rui32_t)stkSize_)
+    #else
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        ((RKH_SMA_T *)(me_))->vptr->activate(me_, \
+                                             (const RKH_EVT_T **)0, \
+                                             qStoSize, \
+                                             (void *)0, \
+                                             (rui32_t)0)
+    #endif
+#endif
+#else
+#if RKH_CFGPORT_SMA_QSTO_EN == RKH_ENABLED
+    #if RKH_CFGPORT_SMA_STK_EN == RKH_ENABLED
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        rkh_sma_activate(me_, \
+                         (const RKH_EVT_T **)qSto_, \
+                         qStoSize, \
+                         (void *)stkSto_, \
+                         (rui32_t)stkSize_)
+    #else
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        rkh_sma_activate(me_, \
+                         (const RKH_EVT_T **)qSto_, \
+                         qStoSize, \
+                         (void *)0, \
+                         (rui32_t)0)
+    #endif
+#else
+    #if RKH_CFGPORT_SMA_STK_EN == RKH_ENABLED
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        rkh_sma_activate(me_, \
+                         (const RKH_EVT_T **)0, \
+                         qStoSize, \
+                         (void *)stkSto_, \
+                         (rui32_t)stkSize_)
+    #else
+    #define RKH_SMA_ACTIVATE(me_, qSto_, qStoSize, stkSto_, stkSize_) \
+        rkh_sma_activate(me_, \
+                         (const RKH_EVT_T **)0, \
+                         qStoSize, \
+                         (void *)0, \
+                         (rui32_t)0)
+    #endif
+#endif
+#endif
+
+/**
+ *  \brief
+ *  Declare and allocate a SMA (active object) derived from RKH_SMA_T. Also,
+ *  initializes and assigns a state machine to previously declared SMA.
+ *
+ *  In the UML specification, every state machine has a top state
+ *  (the abstract root of every state machine hierarchy), which contains
+ *  all the other elements of the entire state machine. RKH provides the
+ *  top state using the macro RKH_SMA_CREATE().
+ *	Frequently, RKH_SMA_CREATE() is used within state-machine's module
+ *	(.c file), thus the structure definition is in fact entirely encapsulated
+ *	in its module and is inaccessible to the rest of the application.
+ *	However, use RKH_SMA_DEF_PTR() or RKH_SMA_DEF_PTR_TYPE() macros to 
+ *	define a opaque pointer or typed pointer to that state machine application 
+ *	structure, respectively. Also, use the RKH_SMA_DCLR() macro to declare it 
+ *	to be for the rest of application code. 
+ *  RKH_SMA_T is not intended to be instantiated directly, but rather
+ *  serves as the base structure for derivation of state machines in the
+ *  application code.
+ *  The following example illustrates how to derive an state machine from
+ *  RKH_SMA_T. Please note that the RKH_SMA_T member sm is defined as the
+ *  FIRST member of the derived structure.
+ *
+ *  \param[in] type 	Data type of the SMA. Could be derived from RKH_SMA_T.
+ *  \param[in] name		Name of state machine application. Also, it represents 
+ *                      the top state of state diagram.
+ *  \param[in] prio		State machine application priority. A unique priority
+ *                      number must be assigned to each SMA from 0 to
+ *                      RKH_LOWEST_PRIO. The lower the number, the higher the
+ *                      priority.
+ *  \param[in] ppty		State machine properties. The available properties are
+ *                      enumerated in RKH_HPPTY_T enumeration in the rkh.h
+ *                      file.
+ *  \param[in] initialState
+ *                      Pointer to initial state. This state could be defined
+ *                      either composite or basic (not pseudo-state).
+ *  \param[in] initialAction
+ *                      Pointer to initialization action (optional). The
+ *                      function prototype is defined as RKH_INIT_ACT_T. This
+ *                      argument is optional, thus it could be declared as
+ *                      NULL.
+ *  \param[in] initialEvt
+ *                      Pointer to an event that will be passed to state
+ *                      machine application when it starts. Could be used to
+ *                      pass arguments to the state machine like an argc/argv.
+ *                      This argument is optional, thus it could be declared
+ *                      as NULL or eliminated in compile-time with
+ *                      RKH_CFG_SMA_INIT_EVT_EN = 0.
+ *
+ *  \sa RKH_SM_CONST_CREATE(), RKH_SM_GET_CONST(), RKH_SM_GET_CONST(),
+ *      RKH_SMA_DEF_PTR(), RKH_SMA_DEF_PTR_TYPE()
+ *
+ *	\usage
+ *	\code
+ *	...within state-machine application's module
+ *
+ *	typedef struct
+ *	{
+ *		RKH_SMA_T ao;	// base structure
+ *		rui8_t x;		// private member
+ *		rui8_t y;		// private member
+ *	} MYSM_T;
+ *
+ *  //	static instance of SMA object
+ *	RKH_SMA_CREATE(MYSM_T, my, 0, HCAL, &S1, my_iaction, &my_ievent);
+ *	\endcode
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SMA_CREATE(type, name, prio, ppty, initialState, \
+                           initialAction, initialEvt) \
+        RKH_SM_CONST_CREATE(name, prio, ppty, initialState, initialAction, \
+                            initialEvt); \
+        static type RKH_SMA_NAME(name) = MKSMA(&RKH_SM_CONST_NAME(name), \
+                                               initialState)
+#else
+    #define RKH_SMA_CREATE(type, name, prio, ppty, initialState, \
+                           initialAction, initialEvt) \
+        static type RKH_SMA_NAME(name) = MKSMA(name, \
+                                               prio, \
+                                               ppty, \
+                                               initialState, \
+                                               initialAction, \
+                                               initialEvt)
+#endif
+
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SMA_INIT(me, prio, ppty, initialState, initialAction, \
+                         initialEvt)
+#else
+    #define RKH_SMA_INIT(me, prio, ppty, initialState, initialAction, \
+                         initialEvt) \
+        MKRT_SM(me, me, prio, ppty, initialState, initialAction, initialEvt)
+#endif
+
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SMA_GET_OBJ(type, me)
+#else
+    #define RKH_SMA_GET_OBJ(type, me) \
+        (type *)&RKH_SMA_NAME(me)
+#endif
+
+/**
+ *  \brief
+ *  Declare a opaque pointer pointing to an previously created active 
+ *  object.
+ *
+ *  \param[in] me_  Name of state machine application.
+ *
+ *  \sa RKH_SMA_DCLR()
+ */
+#define RKH_SMA_DEF_PTR(me_) \
+    RKH_SMA_T *const me_ = (RKH_SMA_T *)&RKH_SMA_NAME(me_)
+
+/**
+ *  \brief
+ *  Declare a pointer of specified type pointing to an previously created 
+ *  active object.
+ *  
+ *  The pointer could be used to hide (opaque) or to publish the internals of 
+ *  the class of the active object. 
+ *
+ *  \param[in] type Data type of the state machine application. Could be 
+ *                  derived from RKH_SMA_T.
+ *  \param[in] me_  Name of state machine application.
+ *
+ *  \sa RKH_SMA_DCLR()
+ */
+#define RKH_SMA_DEF_PTR_TYPE(type, me_) \
+    type *const me_ = (type *)&RKH_SMA_NAME(me_)
+
+/**
+ *  \brief
+ *  Invoke the direct event posting facility rkh_sma_post_fifo().
+ *  If RKH_CFG_SMA_VFUNCT_EN is set RKH_ENABLED, this operation is 
+ *  polymorphic, where its implementation is defined by the virtual table of 
+ *  the target active object. 
+ *
+ *  This macro is the recommended way of posting events, because it
+ *  provides the vital information for software tracing and avoids any
+ *  overhead when the tracing is disabled.
+ *
+ *  \param[in] me_		pointer to previously created state machine
+ *                      application.
+ *  \param[in] e_		actual event sent to the state machine application.
+ *  \param[in] sender_	pointer to the sender object. It is not
+ *                      necessarily a pointer to an active object. In
+ *                      fact, if RKH_SMA_POST_FIFO() is called from an
+ *                      interrupt or other context, it can create a
+ *                      unique object just to unambiguously identify the
+ *                      publisher of the event.
+ *
+ *  \note
+ *  In the next releases this macro will be improved, calling a function 
+ *  instead of using its own vptr.  
+ *
+ *	\sa
+ *	rkh_sma_post_fifo().
+ *
+ *  \ingroup apiAO
+ */
+#if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+    #if defined(RKH_USE_TRC_SENDER)
+        #define RKH_SMA_POST_FIFO(me_, e_, sender_) \
+            ((RKH_SMA_T *)(me_))->vptr->post_fifo((me_), (e_), (sender_))
+    #else
+        #define RKH_SMA_POST_FIFO(me_, e_, sender_) \
+            ((RKH_SMA_T *)(me_))->vptr->post_fifo((me_), (e_))
+    #endif
+#else
+    #if defined(RKH_USE_TRC_SENDER)
+        #define RKH_SMA_POST_FIFO(me_, e_, sender_) \
+            rkh_sma_post_fifo((me_), (e_), (sender_))
+    #else
+        #define RKH_SMA_POST_FIFO(me_, e_, sender_) \
+            rkh_sma_post_fifo((me_), (e_))
+    #endif
+#endif
+
+/**
+ *  \brief
+ *  Invoke the direct event posting facility rkh_sma_post_lifo().
+ *  If RKH_CFG_SMA_VFUNCT_EN is set RKH_ENABLED, this operation is 
+ *  polymorphic, where its implementation is defined by the virtual table of 
+ *  the target active object. 
+ *
+ *  This macro is the recommended way of posting events, because it
+ *  provides the vital information for software tracing and avoids any
+ *  overhead when the tracing is disabled.
+ *
+ *  \param[in] me_	    pointer to previously created state machine
+ *                      application.
+ *  \param[in] e_		actual event sent to the state machine application.
+ *  \param[in] sender_	pointer to the sender object. It is not
+ *                      necessarily a pointer to an active object. In
+ *                      fact, if RKH_SMA_POST_LIFO() is called from an
+ *                      interrupt or other context, it can create a
+ *                      unique object just to unambiguously identify the
+ *                      publisher of the event.
+ *
+ *  \note
+ *  In the next releases this macro will be improved, calling a function 
+ *  instead of using its own vptr.  
+ *
+ *	\sa
+ *	rkh_sma_post_lifo().
+ *
+ *  \ingroup apiAO
+ */
+#if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+    #if defined(RKH_USE_TRC_SENDER)
+        #define RKH_SMA_POST_LIFO(me_, e_, sender_) \
+            ((RKH_SMA_T *)(me_))->vptr->post_lifo((me_), (e_), (sender_))
+    #else
+        #define RKH_SMA_POST_LIFO(me_, e_, sender_) \
+            ((RKH_SMA_T *)(me_))->vptr->post_lifo((me_), (e_))
+    #endif
+#else
+    #if defined(RKH_USE_TRC_SENDER)
+        #define RKH_SMA_POST_LIFO(me_, e_, sender_) \
+            rkh_sma_post_lifo((me_), (e_), (sender_))
+    #else
+        #define RKH_SMA_POST_LIFO(me_, e_, sender_) \
+            rkh_sma_post_lifo((me_), (e_))
+    #endif
+#endif
+
+/**
+ *  \brief
+ *  Declares a opaque pointer to previously created array of state machine
+ *  applications SMA (a.k.a Active Object) to be used as a global object.
+ *
+ *  \param[in] _arr		pointer to previously created array of state machine
+ *                      applications. To do that is recommended to use the 
+ *                      macro RKH_ARRAY_SMA_CREATE().
+ *  \param[in] _num		size of array [in active objects].
+ *
+ *	\note
+ *  Generally, this macro is used in the SMA's header file.
+ *
+ *  \sa
+ *  RKH_SMA_CREATE().
+ *
+ *  \usage
+ *  \code
+ *  //	cli.h: state-machine application's header file
+ *  #define NUM_CLIENTS			4
+ *
+ *  typedef struct
+ *  {
+ *      RKH_SMA_T me;		// base structure
+ *      RKH_TMR_T cli_utmr; // usage time
+ *      RKH_TMR_T cli_rtmr;	// waiting request time
+ *  } CLI_T;				// Active Object derived from RKH_SMA_T structure
+ *
+ *  RKH_ARRAY_SMA_DCLR( clis, NUM_CLIENTS );
+ *  \endcode
+ */
+#define RKH_ARRAY_SMA_DCLR(_arr, _num) \
+    extern RKH_SMA_T * const *_arr[_num]
+
+/**
+ *  \brief
+ *  Declares a typed pointer to previously created array of state machine
+ *  applications SMA (a.k.a Active Object) to be used as a global object.
+ *
+ *  \param[in] type_	data type of active object.
+ *  \param[in] array_	pointer to previously created array of state machine
+ *                      applications. To do that is recommended to use the 
+ *                      macro RKH_ARRAY_SMA_CREATE_TYPE().
+ *  \param[in] num_		size of array [in active objects].
+ *
+ *	\note
+ *  Generally, this macro is used in the SMA's header file.
+ *
+ *  \sa
+ *  RKH_SMA_CREATE().
+ *
+ *  \usage
+ *  \code
+ *  //	cli.h: state-machine application's header file
+ *  #define NUM_CLIENTS			4
+ *
+ *  typedef struct
+ *  {
+ *      RKH_SMA_T me;		// base structure
+ *      RKH_TMR_T cli_utmr; // usage time
+ *      RKH_TMR_T cli_rtmr;	// waiting request time
+ *  } CLI_T;				// Active Object derived from RKH_SMA_T structure
+ *
+ *  RKH_ARRAY_SMA_DCLR_TYPE(CLI_T, clis, NUM_CLIENTS);
+ *  \endcode
+ */
+#define RKH_ARRAY_SMA_DCLR_TYPE(type_, array_, num_) \
+    extern type_ * const * array_[num_]
+
+/**
+ *  \brief
+ *  Declare and allocate an array of SMAs (a.k.a active objects) derived from
+ *  RKH_SMA_T.
+ *
+ *  \param[in] _arr		name of SMA's array.
+ *  \param[in] _num		size of array [in active objects].
+ *
+ *  \usage
+ *  \code
+ *	// Defines SMAs (a.k.a Active Objects)
+ *
+ *	RKH_SMA_CREATE( CLI_T, cli0, 1, HCAL, &cli_idle, cli_init, NULL );
+ *	RKH_SMA_CREATE( CLI_T, cli1, 2, HCAL, &cli_idle, cli_init, NULL );
+ *	RKH_SMA_CREATE( CLI_T, cli2, 3, HCAL, &cli_idle, cli_init, NULL );
+ *	RKH_SMA_CREATE( CLI_T, cli3, 4, HCAL, &cli_idle, cli_init, NULL );
+ *
+ *	RKH_ARRAY_SMA_CREATE( clis, NUM_CLIENTS )
+ *	{
+ *		&cli0, &cli1, &cli2, &cli3
+ *	};
+ *  \endcode
+ */
+#define RKH_ARRAY_SMA_CREATE(_arr, _num) \
+    RKH_SMA_T * const *_arr[_num] =
+
+/**
+ *  \brief
+ *  Declare and allocate an array of SMAs (a.k.a active objects) derived from
+ *  RKH_SMA_T.
+ *
+ *  \param[in] type_	data type of active object.
+ *  \param[in] array_	name of SMA's array.
+ *  \param[in] num_		size of array [in active objects].
+ *
+ *  \usage
+ *  \code
+ *	// Defines SMAs (a.k.a Active Objects)
+ *
+ *	RKH_SMA_CREATE(CLI_T, cli0, 1, HCAL, &cli_idle, cli_init, NULL);
+ *	RKH_SMA_CREATE(CLI_T, cli1, 2, HCAL, &cli_idle, cli_init, NULL);
+ *	RKH_SMA_CREATE(CLI_T, cli2, 3, HCAL, &cli_idle, cli_init, NULL);
+ *	RKH_SMA_CREATE(CLI_T, cli3, 4, HCAL, &cli_idle, cli_init, NULL);
+ *
+ *	RKH_ARRAY_SMA_CREATE(CLI_T, clis, NUM_CLIENTS)
+ *	{
+ *		&cli0, &cli1, &cli2, &cli3
+ *	};
+ *  \endcode
+ */
+#define RKH_ARRAY_SMA_CREATE_TYPE(type_, array_, num_) \
+    type_ * const * array_[num_] =
+
+/**
+ *  \brief
+ *  Retrieves the pointer to active object from a SMA's array.
+ *
+ *  \param[in] _arr		name of SMA's array.
+ *  \param[in] _ix		index (position in the array).
+ *
+ *  \usage
+ *  \code
+ *  #define NUM_CLIENTS				4
+ *  #define CLI( _clino )			RKH_ARRAY_SMA( clis, _clino )
+ *
+ *  #define CLI0					CLI(0)
+ *  #define CLI1					CLI(1)
+ *  #define CLI2					CLI(2)
+ *  #define CLI3					CLI(3)
+ *
+ *  typedef struct
+ *  {
+ *      RKH_SMA_T me;		// base structure
+ *      RKH_TMR_T cli_utmr; // usage time
+ *      RKH_TMR_T cli_rtmr;	// waiting request time
+ *  } CLI_T;				// Active Object derived from RKH_SMA_T structure
+ *
+ *  RKH_ARRAY_SMA_DCLR( clis, NUM_CLIENTS );
+ *  \endcode
+ */
+#define RKH_ARRAY_SMA(_arr, _ix)      *_arr[_ix]
+
+#if R_TRC_AO_NAME_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *  This macro retrieves the name of an registered active object.
+     *
+     *  \param[in] ao		pointer to previously created active object.
+     *
+     *  \return
+     *  Name of active object.
+     */
+    #define RKH_GET_AO_NAME(ao)       RKH_SMA_ACCESS_CONST(ao, name)
+#else
+    #define RKH_GET_AO_NAME(ao)       noname
+#endif
+
+/**
+ *  \brief
+ *  Retrieves the address of an registered active object (SMA) according to
+ *  its priority.
+ *
+ *  \param[in] _prio	registered active object (SMA) priority.
+ *  \return			    pointer to previously registered active object (SMA).
+ */
+#define RKH_GET_SMA(_prio) \
+    rkh_sptbl[(rui8_t)(_prio)]
+
+/**
+ *  \brief
+ *  Retrieves the priority number of an registered active object (SMA).
+ *
+ *  \param[in] _ao		pointer to previously registered active object (SMA).
+ */
+#define RKH_GET_PRIO(_ao) \
+    (rui8_t)(RKH_SMA_ACCESS_CONST(_ao, prio))
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  \brief
+ *  Defines the data structure into which the collected performance
+ *  information for state machine is stored.
+ *
+ *  This member is optional, thus it could be declared as NULL or eliminated
+ *  in compile-time with RKH_EN_SMA_GET_INFO = 0.
+ */
+typedef struct RKH_SMAI_T
+{
+    rui16_t ndevt;          /**< # of dispatched events */
+    rui16_t exectr;         /**< # of executed transitions */
+} RKH_SMAI_T;
+
+/**
+ *  \brief
+ *  Describes the SMA (active object in UML).
+ *
+ *	This structure resides in RAM because its members are dinamically updated
+ *	by RKH (context of state machine).
+ *	The \b RKH_SM_T::romrkh member points to RKH_ROM_T structure, allocated in 
+ *	ROM, to reduce the size of RAM consume. The key parameters of a state 
+ *	machine are allocated within. Therefore cannot be modified in runtime.
+ *
+ *  RKH_SMA_T is not intended to be instantiated directly, but rather
+ *  serves as the base structure for derivation of active objects in the
+ *  application code.
+ *  The following example illustrates how to derive an active object from
+ *  RKH_SMA_T. Please note that the RKH_SMA_T member ao is defined as the
+ *  FIRST member of the derived struct.
+ *
+ *	Example:
+ *	\code
+ *	//	...within state-machine's module
+ *
+ *	typedef struct
+ *	{
+ *		RKH_SMA_T ao;	// base structure
+ *		rui8_t x;		// private member
+ *		rui8_t y;		// private member
+ *	} MYSM_T;
+ *
+ *  //	static instance of SMA object
+ *	RKH_SMA_CREATE(MYSM_T, my, HCAL, &S1, my_iaction, &my_ievent);
+ *	\endcode
+ *
+ *	\sa
+ *	RKH_SMA_T structure definition for more information. Also,
+ *	\link RKH_EVT_T single inheritance in C \endlink, and
+ *	\link RKH_CREATE_BASIC_STATE another example \endlink.
+ *
+ *  \ingroup apiAO
+ */
+struct RKH_SMA_T
+{
+    /**
+     *  \brief
+     *  State machine.
+     */
+    RKH_SM_T sm;
+
+    /**
+     *  \brief
+     *  Virtual pointer.
+     */
+#if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+    const RKHSmaVtbl *vptr;
+#endif
+
+    /**
+     *  \brief
+     *  OS-dependent thread of control of the active object.
+     *
+     *  Frequently, the active object has its own task processing loop that
+     *  waits for the signal to be posted, and when it is, loops to remove
+     *  and process all events that are currently queued.
+     *  The RKH_SMA_POST_FIFO() macro enqueues an event and signals	the OS
+     *  that an event has arrived. In this case, \c os_signal holds the OS
+     *  object used to signal that an event has been queued.
+     *	This data might be used in various ways, depending on the RKH port.
+     *  In some ports it's used to store the thread handler.
+     *
+     *  \note
+     *  This member is optional, thus it could be declared as NULL or
+     *  eliminated in compile-time with RKH_CFGPORT_SMA_THREAD_EN = 0.
+     */
+#if RKH_CFGPORT_SMA_THREAD_EN == RKH_ENABLED
+    RKH_THREAD_TYPE thread;
+
+    /**
+     *  \brief
+     *	OS-dependent object used to signal that an event has been queued.
+     *
+     *  Frequently, the active object has its own task processing loop that
+     *  waits for the signal to be posted, and when it is, loops to remove
+     *  and process all events that are currently queued.
+     *  The RKH_SMA_POST_FIFO() macro enqueues an event and signals	the OS
+     *  that an event has arrived. In this case, \c os_signal holds the OS
+     *  object used to signal that an event has been queued.
+     *  This data might be used in various ways, depending on the RKH port.
+     *  In some ports it's used to block the calling thread when the native
+     *  RKH queue is empty. In other RKH ports the OS-dependent	data object
+     *  might be used differently.
+     *
+     *  \note
+     *  This member is optional, thus it could be eliminated in compile-time
+     *  with RKH_CFGPORT_SMA_THREAD_DATA_EN = 0.
+     */
+#if RKH_CFGPORT_SMA_THREAD_DATA_EN == RKH_ENABLED
+    RKH_OSSIGNAL_TYPE os_signal;
+#endif
+#endif
+
+    /**
+     *  \brief
+     *  Event queue of the SMA (a.k.a Active Object).
+     */
+    RKH_EQ_TYPE equeue;
+
+    /**
+     *  \brief
+     *  The Boolean loop variable determining if the thread routine
+     *  of the SMA is running.
+     */
+    rbool_t running;
+
+    /**
+     *  \brief
+     *  Performance information. This member is optional, thus it could be
+     *  declared as NULL or eliminated in compile-time with
+     *  RKH_CFG_SMA_GET_INFO_EN = 0.
+     */
+#if RKH_CFG_SMA_GET_INFO_EN == RKH_ENABLED
+    RKH_SMAI_T sinfo;
+#endif
+};
+
+/** \copydetails RKHSmaVtbl::activate */
+typedef void (*RKHActivate)(RKH_SMA_T *me, 
+                         const RKH_EVT_T **qSto, RKH_QUENE_T qSize, 
+                         void *stkSto, rui32_t stkSize);
+
+/** \copydetails RKHSmaVtbl::task */
+typedef void (*RKHTask)(RKH_SMA_T *me, void *arg);
+
+/** \copydetails RKHSmaVtbl::post_fifo */
+#if defined(RKH_USE_TRC_SENDER)
+typedef void (*RKHPostFifo)(RKH_SMA_T *me, const RKH_EVT_T *e, 
+                         const void *const sender);
+#else
+typedef void (*RKHPostFifo)(RKH_SMA_T *me, const RKH_EVT_T *e);
+#endif
+
+/** \copydetails RKHSmaVtbl::post_lifo */
+#if defined(RKH_USE_TRC_SENDER)
+typedef void (*RKHPostLifo)(RKH_SMA_T *me, const RKH_EVT_T *e, 
+                         const void *const sender);
+#else
+typedef void (*RKHPostLifo)(RKH_SMA_T *me, const RKH_EVT_T *e);
+#endif
+
+/**
+ *  \brief
+ *  Virtual table for the RKH_SMA_T structure.
+ */
+struct RKHSmaVtbl
+{
+    /** Virtual function to activate the active object (thread) */
+    /** \sa RKH_SMA_ACTIVATE() */
+    RKHActivate activate;
+
+    /** 
+     *  \brief
+     *  Virtual function to control the execution of the AO (thread task).
+     *
+     *  Frequently, the active object has its own task processing loop, also 
+     *  as known as thread of control, that waits for the signal to be posted,
+     *  and when it is, loops to remove and process all events that are 
+     *  currently queued.
+     */
+    RKHTask task;
+
+    /** Virtual function to asynchronously post (FIFO) an event to an AO */
+    /** \sa RKH_SMA_POST_FIFO() */
+    RKHPostFifo post_fifo;
+
+    /** Virtual function to asynchronously post (LIFO) an event to an AO */
+    /** \sa RKH_SMA_POST_LIFO() */
+    RKHPostLifo post_lifo;
+};
+
+/* -------------------------- External variables --------------------------- */
+/** Default virtual table for the RKH_SMA_T structure */
+extern const RKHSmaVtbl rkhSmaVtbl;
+
+/**
+ *  \brief
+ *  Priority arranged table of registered SMA.
+ *
+ *  Register a state machine application into the framework implies to store
+ *  a pointer to the SMA in the priority table. A unique priority number must
+ *  be assigned to each SMA from 0 to RKH_LOWEST_PRIO. The lower the number,
+ *  the higher the priority.
+ */
+extern RKH_SMA_T *rkh_sptbl[RKH_CFG_FWK_MAX_SMA];
+
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+/**
+ *  \brief
+ *  Registers a state machine application (SMA) as known as active object into
+ *  the framework, which implies to store a pointer to the SMA in the priority
+ *  table.
+ *
+ *  \param[in] me  pointer to previously created state machine application.
+ */
+void rkh_sma_register(RKH_SMA_T *me);
+
+/**
+ *  \brief
+ *	Removes the SMA as known as active object from the priority table, and
+ *	thus from the framework, by simply replacing the link to the SMA being
+ *	deleted with a NULL pointer.
+ *
+ *  \param[in] me  pointer to previously created state machine application.
+ */
+void rkh_sma_unregister(RKH_SMA_T *me);
+
+/**
+ *  \brief
+ *  Initializes the virtual table of the active object instance and calls the 
+ *  constructor operation of its base class.
+ *
+ *  \param[in] me   pointer to previously created state machine application.
+ *  \param[in] vtbl pointer to virtual table. Define it as null to use the 
+ *                  default virtual table, rkhSmaVtbl.
+ *
+ *  \note
+ *  The initializer assumes that memory has previously been allocated for the 
+ *  object (either statically or dynamically).
+ */
+void rkh_sma_ctor(RKH_SMA_T *me, const RKHSmaVtbl *vtbl);
+
+/**
+ *  \brief
+ *  Initializes and activates a previously created state machine application
+ *  (SMA) as known as active object.
+ *
+ *  A state machine application (SMA) is declared with the RKH_SMA_T data
+ *  type and is defined with the rkh_sma_activate() service.
+ *
+ *  \param[in] me       pointer to previously created state machine
+ *                      application.
+ *  \param[in] qSto     base address of the event storage area. A message
+ *                      storage area is declared as an array of pointers to
+ *                      RKH events.
+ *  \param[in] qSize    size of the storage event area [in number of entries].
+ *  \param[in] stkSto   starting address of the stack's memory area.
+ *  \param[in] stkSize  size of stack memory area [in bytes].
+ *
+ *	\note
+ *	Platform-dependent function. All RKH ports must be defined in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \usage
+ *	Implementation example for x86, linux emulator of simple cooperative 
+ *	scheduler non-preemptive.
+ *  \snippet linux_st_rkhport.c Activates an active object
+ *
+ *  \ingroup apiPortAO
+ */
+void rkh_sma_activate(RKH_SMA_T *me, const RKH_EVT_T * *qSto,
+                      RKH_QUENE_T qSize, void *stkSto, rui32_t stkSize);
+
+/**
+ *  \brief
+ *  Terminate a state machine application (SMA) as known as active object.
+ *
+ *  A state machine application may call this service to terminate itself.
+ *  Once terminated, the state machine application must be re-created in
+ *  order for it to execute again.
+ *
+ *  \param[in] me      pointer to previously created state machine
+ *                      application.
+ *
+ *	\note
+ *	Platform-dependent function. All RKH ports must be defined in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \usage
+ *	Implementation example for x86, linux emulator of simple cooperative 
+ *	scheduler non-preemptive.
+ *  \snippet linux_st_rkhport.c Terminates an active object
+ *
+ *  \ingroup apiPortAO
+ */
+void rkh_sma_terminate(RKH_SMA_T *me);
+
+#if defined(RKH_USE_TRC_SENDER)
+/**
+ *  \brief
+ *  Send an event to a state machine application (SMA) as known as active
+ *  object through a queue using the FIFO policy. A message is a pointer
+ *  size variable and its use is application specific.
+ *
+ *  \param[in] me      pointer to previously created state machine
+ *                      application.
+ *  \param[in] e		actual event sent to the state machine application.
+ *  \param[in] sender	pointer to the sender object. It is not necessarily a 
+ *                      pointer to an active object. In fact, if 
+ *                      RKH_SMA_POST_FIFO() is called from an interrupt or 
+ *                      other context, it can create a unique object just to 
+ *                      unambiguously identify the publisher of the event.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it. Instead, use RKH_SMA_POST_FIFO() macro.
+ *  \note
+ *	For memory efficiency and best performance the SMA's event queue,
+ *	STORE ONLY POINTERS to events, not the whole event objects.
+ *	The assertion inside it guarantee that the pointer is valid, so is not
+ *	necessary to check the pointer returned from rkh_sma_post_fifo().
+ *	\note
+ *	Platform-dependent function. All RKH ports must be defined in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \ingroup apiPortAO
+ */
+void rkh_sma_post_fifo(RKH_SMA_T *me, const RKH_EVT_T *e,
+                       const void *const sender);
+#else
+void rkh_sma_post_fifo(RKH_SMA_T *me, const RKH_EVT_T *e);
+#endif
+
+#if defined(RKH_USE_TRC_SENDER)
+/**
+ *  \brief
+ *  Send an event to a state machine application (SMA) as known as active
+ *  object through a queue using the LIFO policy. A message is a pointer
+ *  size variable and its use is application specific.
+ *
+ *  \param[in] me		pointer to previously created state machine 
+ *                      application.
+ *  \param[in] e		actual event sent to the state machine application.
+ *  \param[in] sender	pointer to the sender object. It is not
+ *                      necessarily a pointer to an active object. In
+ *                      fact, if RKH_SMA_POST_FIFO() is called from an
+ *                      interrupt or other context, it can create a
+ *                      unique object just to unambiguously identify the
+ *                      publisher of the event.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it. Instead, use RKH_SMA_POST_LIFO() macro.
+ *  \note
+ *	For memory efficiency and best performance the SMA's event queue,
+ *	STORE ONLY POINTERS to events, not the whole event objects.
+ *	The assertion inside it guarantee that the pointer is valid, so is not
+ *	necessary to check the pointer returned from rkh_sma_post_lifo().
+ *	\note
+ *	Platform-dependent function. All RKH ports must be defined in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *
+ *  \ingroup apiPortAO
+ */
+void rkh_sma_post_lifo(RKH_SMA_T *me, const RKH_EVT_T *e,
+                       const void *const sender);
+
+#else
+void rkh_sma_post_lifo(RKH_SMA_T *me, const RKH_EVT_T *e);
+#endif
+
+/**
+ *  \brief
+ *  Get an event from the event queue of an state machine application (SMA)
+ *  as known as active object.
+ *  The events received are pointer size variables and their use is
+ *  application specific.
+ *
+ *  \param[in] me		pointer to previously created state machine 
+ *                      application.
+ *
+ *	\return     A non-NULL pointer indicates that a event pointer was 
+ *	            available, otherwise a NULL pointer.
+ *
+ *	\note
+ *	Platform-dependent function. All RKH ports must be defined in the RKH
+ *	port file to a particular platform. However, only the ports to the
+ *	external OS/RTOS usually need some code to bolt the framework to the
+ *	external OS/RTOS.
+ *	Depending on the underlying OS or kernel, if no event is present at the
+ *	queue, the function will block the current thread until an event is
+ *	received.
+ *
+ *  \ingroup apiPortAO
+ */
+RKH_EVT_T *rkh_sma_get(RKH_SMA_T *me);
+
+/**
+ *  \brief
+ *	Defer an event to a given separate event queue.
+ *
+ *  Event deferral comes in very handy when an event arrives in a
+ *  particularly inconvenient moment but can be deferred for some later time,
+ *  when the system is in a much better position to handle the event. RKH
+ *  supports very efficient event deferring and recalling mechanisms.
+ *  This function is part of the event deferral mechanism. An SMA
+ *  uses this function to defer an event \a e to the event queue \a q.
+ *  RKH correctly accounts for another outstanding reference to the event
+ *  and will not recycle the event at the end of the RTC step.
+ *  Later, the SMA might recall one event at a time from the
+ *  event queue by means of rkh_sma_recall() function.
+ *
+ *  \param[in] q    pointer to previously created queue.
+ *  \param[in] e    pointer to event.
+ *
+ *	\note
+ *	For memory efficiency and best performance the deferred event queue,
+ *	STORE ONLY POINTERS to events, not the whole event objects.
+ *  An SMA can use multiple event queues to defer events of
+ *  different kinds.
+ *	The assertion inside it guarantee that operation is valid, so is not
+ *	necessary to check the value returned from it.
+ *
+ *  \usage
+ *	\code
+ *	static RKH_QUEUE_T qurc;
+ *	static RKH_EVT_T *qurc_sto[ MAX_SIZEOF_QURC ];
+ *
+ *	rkh_queue_init( &qurc, qurc_sto, MAX_SIZEOF_QURC, NULL );
+ *	...
+ *
+ *	void
+ *	ring( const struct rkh_t *me, RKH_EVT_T *pe )
+ *	{
+ *		(void)me;                  // argument not used
+ *		rkh_sma_defer( &qurc, pe );	// defer event
+ *	}
+ *	\endcode
+ */
+void rkh_sma_defer(RKH_QUEUE_T *q, const RKH_EVT_T *e);
+
+/**
+ *  \brief
+ *  Recall a deferred event from a given event queue.
+ *
+ *  This function is part of the event deferral support. An SMA
+ *  uses this function to recall a deferred event from a given event queue.
+ *  Recalling an event means that it is removed from the deferred event
+ *  queue \a q and posted (LIFO) to the event queue of the \a me state
+ *  machine application.
+ *
+ *  \note
+ *	For memory efficiency and best performance the destination event queue,
+ *	STORE ONLY POINTERS to events, not the whole event objects.
+ *
+ *  \return     The pointer to the recalled event to the caller, or NULL if no
+ *              event has been recalled.
+ *
+ *  \usage
+ *	\code
+ *	void
+ *	exit_rx_manager( const struct rkh_t *me )
+ *	{
+ *		rkh_sma_recall( me, &qurc );
+ *	}
+ *	\endcode
+ *
+ */
+RKH_EVT_T *rkh_sma_recall(RKH_SMA_T *me, RKH_QUEUE_T *q);
+
+/**
+ *  \brief
+ *  Clear performance information for a particular state machine application
+ *  (SMA) as known as active object.
+ *
+ *  \param[in] me  pointer to previously created state machine application.
+ *
+ *  \note
+ *  This function is optional, thus it could be eliminated in compile-time
+ *  with RKH_CFG_SMA_GET_INFO_EN = 0.
+ */
+void rkh_sma_clear_info(RKH_SMA_T *me);
+
+/**
+ *  \brief
+ *  Retrieves performance information for a particular state machine
+ *  application (SMA) as known as active object.
+ *
+ *	The user application must allocate an RKH_SMAI_T data structure used to
+ *	receive data. The performance information is available during run-time
+ *	for each of the RKH services. This can be useful in determining whether
+ *	the application is performing properly, as well as helping to optimize the
+ *	application.
+ *	This information provides a "snapshot" a particular instant in time, i.e.,
+ *	when the service is invoked.
+ *
+ *  \param[in] me  pointer to previously created state machine application.
+ *  \param[in] psi  pointer to the buffer into which the performance
+ *                  information will be copied by reference.
+ *
+ *  \note
+ *  See RKH_SMAI_T structure for more information. This function is optional, 
+ *  thus it could be eliminated in compile-time with 
+ *  RKH_CFG_SMA_GET_INFO_EN = 0.
+ *
+ */
+void rkh_sma_get_info(RKH_SMA_T *me, RKH_SMAI_T *psi);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhsma_prio.h ./rkh/inc/rkhsma_prio.h
--- a_qSC69Z/rkh/inc/rkhsma_prio.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhsma_prio.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,128 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsma_prio.h
+ *  \brief      Native priority mechanism for active object scheduling
+ *  \ingroup    sma
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.15  LeFr  v2.4.05  ---
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHSMA_PRIO_H__
+#define __RKHSMA_PRIO_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhcfg.h"
+#include "rkhtype.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *  Initializes the native priority mechanism for active object scheduling.
+ */
+void rkh_smaPrio_init(void);
+
+/**
+ *  \brief
+ *	Evaluates to true if all active objects are not ready to run.
+ */
+rbool_t rkh_smaPrio_isNotReady(void);
+
+/**
+ *  \brief
+ *	Evaluates to true if any active object is ready to run.
+ */
+rbool_t rkh_smaPrio_isReady(void);
+
+/**
+ *  \brief
+ *  Making an active object ready-to-run inserting it into the ready list.
+ *
+ *  The lower 3 bits of the SMA's priority are used to determine the bit
+ *  position in rkhrg.tbl[], while the next three most significant bits are
+ *  used to determine the index into rkhrg.tbl[].
+ *
+ *  \param[in] prio     number of active object's priority.
+ */
+void rkh_smaPrio_setReady(rui8_t prio);
+
+/**
+ *  \brief
+ *  Removing an active object from the ready list.
+ *
+ *  Clears the ready bit of the active object in rkhrg.tbl[] and clears the 
+ *  bit in rkhrg.grp only if all active objects in a group are not ready to 
+ *  run, i.e. all bits in rkhrg.tbl[prio >> 3] are 0.
+ *
+ *  \param[in] prio		number of active object's priority.
+ */
+void rkh_smaPrio_setUnready(rui8_t prio);
+
+/**
+ *  \brief
+ *	Finding the highest priority active object ready to run.
+ *
+ *	Another table lookup is performed, rather than scanning through the table
+ *	starting with rkhrg.tbl[0] to find the highest priority task ready to
+ *	run. Eight bits are used to represent when tasks are ready in a group. The 
+ *  least significant bit has the highest priority. Using this byte to index 
+ *  the table returns the bit position of the highest priority bit set, a 
+ *  number between 0 and 7.
+ */
+rui8_t rkh_smaPrio_findHighest(void);
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhsma_sync.h ./rkh/inc/rkhsma_sync.h
--- a_qSC69Z/rkh/inc/rkhsma_sync.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhsma_sync.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,101 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsma_sync.h
+ *  \brief      ...
+ *  \ingroup    sma
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHSMA_SYNC_H__
+#define __RKHSMA_SYNC_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhsma.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Encapsulates the mechanism of blocking the native event queue.
+ *
+ *  \param[in] me 		pointer to active object
+ */
+void rkh_sma_block(RKH_SMA_T *const me);
+
+/**
+ *  \brief
+ *  Encapsulates the mechanism of signaling the thread waiting on the
+ *  used native event queue. Thus, the active object is inserted in the 
+ *  ready list as ready-to-dispatch.
+ *
+ *  \param[in] me 		pointer to active object
+ */
+void rkh_sma_setReady(RKH_SMA_T *const me);
+
+/**
+ *  \brief
+ *  Informs the underlying kernel that the active object's event queue is 
+ *  becoming empty. Thus, the active object is removed from the ready list.
+ *
+ *  \param[in] me 		pointer to active object
+ */
+void rkh_sma_setUnready(RKH_SMA_T *const me);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhsm.h ./rkh/inc/rkhsm.h
--- a_qSC69Z/rkh/inc/rkhsm.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhsm.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,2663 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsm.h
+ *  \brief      Platform - independent interface for supporting state-machines. 
+ *
+ *  \ingroup    apiSM
+ *  \ingroup    apiAO
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHSM_H__
+#define __RKHSM_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#define RKH_SM_NAME(smName_)         s_##smName_
+#define RKH_SM_CONST_NAME(smName_)   rs_##smName_
+
+/**
+ *  \brief
+ *  Each condition connector can have one special branch with a guard
+ *	labeled ELSE, which is taken if all the guards on the other
+ *	branches are false.
+ *
+ *  A guard function takes the state machine pointer and the event
+ *  pointer as arguments.
+ *  These arguments are optional, thus they could be eliminated in
+ *  compile-time by means of RKH_EN_GRD_EVT_ARG and RKH_EN_GRD_HSM_ARG
+ *  preprocessor directives.
+ */
+#define ELSE        rkh_sm_else
+
+/**
+ *  \brief
+ *	This macro creates a composite state with a single region, including its 
+ *	own initial pseudostate, history (shallow and deep type) pseudostate, as 
+ *	well as its own final state.
+ *
+ *	The names of history pseudostate and final state are internally conformed 
+ *	as "<nameOfCompositeState>Hist" and "<nameOfCompositeState>Final" 
+ *	respectively. Thus, use these names as target vertex in a transition. 
+ *
+ *	Shallow history means that history applies to the current nesting context
+ *	only  states nested more deeply are not affected by the presence of a
+ *	history pseudostates in a higher context.
+ *	Deep history applies downwards to all levels of nesting.
+ *
+ *  \param[in] name     state name. Represents a composite state structure.
+ *  \param[in] en       pointer to state entry action. This argument is
+ *                      optional, thus it could be declared as NULL.
+ *                      The RKH implementation preserves the transition sequence
+ *                      imposed by Harel's Statechart and UML.
+ *  \param[in] ex	    pointer to state exit action. This argument is
+ *                      optional, thus it could be declared as NULL.
+ *                      The RKH implementation preserves the transition sequence
+ *                      imposed by Harel's Statechart and UML.
+ *  \param[in] parent	pointer to parent state.
+ *  \param[in] defchild	pointer to default child state or pseudostate.
+ *  \param[in] initialTrn
+ *                      pointer to initial transition action of the composite 
+ *                      state's region. This argument is optional, thus it 
+ *                      could be declared as NULL. The RKH implementation 
+ *                      preserves the transition sequence imposed by UML.
+ *  \param[in] kindOfHistory 
+ *                      Kind of history pseudostate. It could be defined
+ *                      either shallow history (RKH_SHISTORY), deep history 
+ *                      (RKH_DHISTORY) or without history (RKH_NO_HISTORY).
+ *                      When it is defined as RKH_NO_HISTORY each of 
+ *                      parameters related to history default transition are 
+ *                      ignored.
+ *  \param[in] hDftTrnGuard	
+ *                      pointer to guard function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] hDftTrnAction
+ *                      pointer to action function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] hDftTarget
+ *                      pointer to target state. If a default history 
+ *                      Transition is defined (the target parameter is not 
+ *                      NULL) originating from the History Pseudostate, it 
+ *                      will be taken. Otherwise, default State entry is 
+ *                      applied. 
+ *  \param[in] hRamMem
+ *                      pointer to a RAM location which maintains the last 
+ *                      visited state of this region. If composite state don't 
+ *                      include the history pseudostate then this parameter 
+ *                      should be passed as NULL.
+ *                      Please, use RKH_CREATE_HISTORY_STORAGE() macro to 
+ *                      create the history RAM location.
+ *
+ *	\sa
+ *	RKH_SCMP_T structure definition for more information.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_COMP_REGION_STATE(name, en, ex, parent, defchild, \
+                                     initialTrn, \
+                                     kindOfHistory, hDftTrnGuard, \
+                                     hDftTrnAction, hDftTarget, hRamMem) \
+                                                                         \
+    MKFINAL_INCOMP(name); \
+    MKHIST_INCOMP(name, kindOfHistory, hDftTrnGuard, hDftTrnAction, \
+                  hDftTarget, hRamMem); \
+                                        \
+    extern RKHROM RKH_TR_T name##_trtbl[]; \
+    RKHROM RKH_SCMP_T name = \
+    { \
+        {MKBASE(RKH_COMPOSITE, name), MKST(en, ex, parent)}, \
+        MKCOMP(name, defchild, initialTrn, &name##Hist) \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a composite state.
+ *
+ *  \param[in] name     state name. Represents a composite state structure.
+ *  \param[in] en       pointer to state entry action. This argument is
+ *                      optional, thus it could be declared as NULL.
+ *                      The RKH implementation preserves the transition sequence
+ *                      imposed by Harel's Statechart and UML.
+ *  \param[in] ex	    pointer to state exit action. This argument is
+ *                      optional, thus it could be declared as NULL.
+ *                      The RKH implementation preserves the transition sequence
+ *                      imposed by Harel's Statechart and UML.
+ *  \param[in] parent	pointer to parent state.
+ *  \param[in] defchild	pointer to default child state or pseudostate.
+ * 	\param[in] history	pointer history pseudostate. This argument is 
+ *                      optional, thus it could be declared as NULL.
+ *
+ *	\sa
+ *	RKH_SCMP_T structure definition for more information.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_COMP_STATE(name, en, ex, parent, defchild, history) \
+                                                                       \
+    extern RKHROM RKH_TR_T name##_trtbl[]; \
+    RKHROM RKH_SCMP_T name = \
+    { \
+        {MKBASE(RKH_COMPOSITE, name), MKST(en, ex, parent)}, \
+        MKCOMP(name, defchild, NULL, history) \
+    }
+
+/**
+ *  \brief
+ *  This macro creates a final state.
+ *
+ *  \param[in] name     state name. Represents a composite state structure.
+ *  \param[in] parent	pointer to parent state.
+ *
+ *	\sa
+ *	RKH_FINAL_T structure definition for more information.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_FINAL_STATE(name, parent) \
+                                             \
+    static RKHROM RKH_TR_T name##_trtbl[] = \
+        RKH_TRREG(RKH_ANY, NULL, NULL, NULL); \
+    RKHROM RKH_FINAL_T name = \
+    { \
+        {MKBASE(RKH_FINAL, name), MKST(NULL, NULL, parent)}, \
+        MKFINAL(name) \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a basic state.
+ *
+ *  \param[in] name	state name. Represents a basic state structure.
+ *  \param[in] en	pointer to state entry action. This argument is
+ *					optional, thus it could be declared as NULL.
+ *					The RKH implementation preserves the transition sequence
+ *					imposed by Harel's Statechart and UML.
+ *  \param[in] ex	pointer to state exit action. This argument is
+ *					optional, thus it could be declared as NULL.
+ *					The RKH implementation preserves the transition sequence
+ *					imposed by Harel's Statechart and UML.
+ *  \param[in] parent	pointer to parent state.
+ *  \param[in] prepro	pointer to input preprocessor function. This function
+ *                  could be called "Moore" action.
+ *                  This argument is optional, thus it could be declared
+ *                  as NULL.
+ *					Aditionally, by means of single inheritance in C it
+ *					could be used as state's abstract data.
+ *					Moreover, implementing the single inheritance in C
+ *					is very simply by literally embedding the base type,
+ *					RKH_PPRO_T in this case, as the first member of the
+ *					derived structure. See \a prepro member of RKH_SBSC_T
+ *					structure for more information. 
+ *					\usage
+ *                  \code
+ *					static RKH_SIG_T
+ *					preprocessor( RKH_EVT_T *pe )
+ *					{
+ *						...
+ *					}
+ *
+ *					typedef struct
+ *					{
+ *						RKH_PPRO_T prepro;  // extend the RKH_PPRO_T class
+ *						unsigned min:4;
+ *						unsigned max:4;
+ *						char *buff;
+ *					} SDATA_T;
+ *
+ *					static const SDATA_T option = { preprocessor,4,8,token1 };
+ *
+ *					RKH_CREATE_BASIC_STATE( S111, set_x_1,
+ *											NULL, &S11, preprocessor );
+ *					RKH_CREATE_BASIC_STATE( S22, set_x_4,
+ *											NULL, &S2,
+ *											(RKH_PPRO_T*)&option );
+ *					\endcode
+ *
+ *	\sa
+ *	RKH_SBSC_T structure definition for more information.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_BASIC_STATE(name, en, ex, parent, prepro) \
+                                                             \
+    extern RKHROM RKH_TR_T name##_trtbl[]; \
+                                             \
+    RKHROM RKH_SBSC_T name = \
+    { \
+        {MKBASE(RKH_BASIC, name), MKST(en,ex,parent)}, \
+        MKBASIC(name,prepro)  \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a conditional pseudostate (a.k.a. junction).
+ *
+ *  The conditional pseudostates are semantic-free vertices that are used to
+ *  chain together multiple transitions. They are used to construct compound
+ *  transition paths between states. For example, a junction can be used to
+ *  converge multiple incoming transitions into a single outgoing transition
+ *  representing a shared transition path (this is known as a merge).
+ *  Conversely, they can be used to split an incoming transition into multiple
+ *  outgoing transition segments with different guard conditions. This
+ *  realizes a static conditional branch. (In the latter case, outgoing
+ *  transitions whose guard conditions evaluate to false are disabled. A
+ *  predefined guard denoted "ELSE" may be defined for at most one outgoing
+ *  transition. This transition is enabled if all the guards labeling the
+ *  other transitions are false.) Static conditional branches are distinct
+ *  from dynamic conditional branches that are realized by choice vertices.
+ *
+ *  \param[in] name     pseudostate name. Represents a conditional pseudostate
+ *                      structure.
+ *
+ *	\sa
+ *	RKH_SCOND_T structure definition for more information.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_COND_STATE(name) \
+                                    \
+    extern RKHROM RKH_TR_T name##_trtbl[]; \
+                                             \
+    RKHROM RKH_SCOND_T name = \
+    { \
+        MKBASE(RKH_CONDITIONAL, name), \
+        name##_trtbl \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a choice pseudostate.
+ *
+ *  Choice pseudostate which, when reached, result in the dynamic evaluation
+ *  of the guards of its outgoing transitions. This realizes a dynamic
+ *  conditional branch. It allows splitting of transitions into multiple
+ *  outgoing paths such that the decision on which path to take may be a
+ *  function of the results of prior actions performed in the same
+ *  run-to-completion step. If more than one of the guards evaluates to true,
+ *  an arbitrary one is selected. If none of the guards evaluates to true,
+ *  then the model is considered ill-formed. To avoid this, it is recommended
+ *  to define one outgoing transition with the predefined "ELSE" guard for
+ *  every choice pseudostate.
+ *	Also, branches cannot contain triggers, but in addition to a guard they
+ *	may contain actions. A branch can enter another choice connector, thus
+ *	providing for the nesting of branches.
+ *
+ *  \param[in] name		pseudostate name. Represents a choice pseudostate
+ *                      structure.
+ *
+ *	\sa
+ *	RKH_SCHOICE_T structure definition for more information.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_CHOICE_STATE(name) \
+                                      \
+    extern RKHROM RKH_TR_T name##_trtbl[]; \
+                                           \
+    RKHROM RKH_SCHOICE_T name = \
+    { \
+        MKBASE(RKH_CHOICE, name), \
+        name##_trtbl \
+    }
+
+/**
+ * 	\deprecated 
+ * 	This macro creates a deep history pseudostate. Instead use: 
+ *	RKH_CREATE_COMP_REGION_STATE() macro.
+ *
+ *	Deep history applies downwards to all levels of nesting.
+ *
+ *	\note
+ *	At this framework version, it is not recommended to instantiate the 
+ *	same history object more than once using this macro, since it uses a 
+ *	static memory to store the last visited state (memory of history 
+ *	pseudostate).
+ *
+ *	\sa
+ *	RKH_SHIST_T structure definition for more information.
+ *
+ * 	\param[in] name		pseudostate name. Represents a deep history 
+ *                      pseudostate structure.
+ * 	\param[in] parent	pointer to parent state.
+ *  \param[in] dftTrnGuard	
+ *                      pointer to guard function. This argument is
+ *			   	        optional, thus it could be declared as NULL.
+ *  \param[in] dftTrnAction
+ *                      pointer to action function. This argument is
+ *			   	        optional, thus it could be declared as NULL.
+ *  \param[in] dftTarget
+ *                      pointer to target state. If a default history 
+ *                      Transition is defined (the target parameter is not 
+ *                      NULL) originating from the History Pseudostate, it 
+ *                      will be taken. Otherwise, default State entry is 
+ *                      applied. 
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_DEEP_HISTORY_STATE(name, parent, dftTrnGuard, \
+                                      dftTrnAction, dftTarget) \
+                                                               \
+    static RKHROM RKH_ST_T *ram##name; \
+    MKHISTORY(name, parent, RKH_DHISTORY, dftTrnGuard, dftTrnAction, \
+              dftTarget, &ram##name)
+
+/**
+ * 	\deprecated 
+ *	This macro creates a shallow history pseudostate. Instead use: 
+ *	RKH_CREATE_COMP_REGION_STATE() macro.
+ *
+ *	Shallow history means that history applies to the current nesting context 
+ *	only  states nested more deeply are not affected by the presence of a 
+ *	history pseudostates in a higher context.
+ *	
+ *	\note
+ *	At this framework version, it is not recommended to instantiate the 
+ *	same history object more than once using this macro, since it uses a 
+ *	static memory to store the last visited state (memory of history 
+ *	pseudostate).
+ *
+ *	\sa
+ *	RKH_SHIST_T structure definition for more information.
+ *
+ * 	\param[in] name     pseudostate name. Represents a shallow history 
+ *                      pseudostate structure.
+ * 	\param[in] parent   pointer to parent state.
+ *  \param[in] dftTrnGuard	
+ *                      pointer to guard function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] dftTrnAction
+ *                      pointer to action function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] dftTarget
+ *                      pointer to target state. If a default history 
+ *                      Transition is defined (the target parameter is not 
+ *                      NULL) originating from the History Pseudostate, it 
+ *                      will be taken. Otherwise, default State entry is 
+ *                      applied. 
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_SHALLOW_HISTORY_STATE(name, parent, dftTrnGuard, \
+                                         dftTrnAction, dftTarget) \
+                                                                  \
+    static RKHROM RKH_ST_T *ram##name; \
+    MKHISTORY(name, parent, RKH_SHISTORY, dftTrnGuard, dftTrnAction, \
+              dftTarget, &ram##name)
+
+/**
+ *  \brief
+ *	This macro creates a submachine state.
+ *
+ *  A submachine state is a kind of a state that actually refers to
+ *  another defined state machine.
+ *  A submachine state is logically equivalent to the insertion of the
+ *  referenced state machine as a composite state in the place of
+ *  the submachine state. Consequently, every entrance to a submachine
+ *  state is equivalent to the corresponding entrance to the inserted
+ *  (referenced) composite state. In particular, it can be entered
+ *  thruough its initial pseudostate (as any other composite state), or
+ *  through one of its entry points.
+ *
+ *  Similary, every exit from a submachine state is equivalent to the
+ *  corresponding exit from the inserted composite state. It can be exited
+ *  through one of its exit points. When it is exited through its exit point
+ *  the effect of the transition targeting the exit point is executed first,
+ *  followed by the exit behavior of the composite state.
+ *
+ *  The purpose od defining submachine states is to decompose and localize
+ *  repetitive parts because the same state machine can be referenced from
+ *  more than one submachine state.
+ *
+ *  \param[in] name     submachine state name. Represents a submachine state
+ *                      structure.
+ *  \param[in] en		pointer to state entry action. This argument is
+ *                      optional, thus it could be declared as NULL.
+ *                      The RKH implementation preserves the transition sequence
+ *                      imposed by Harel's Statechart and UML.
+ *  \param[in] ex       pointer to state exit action. This argument is
+ *                      optional, thus it could be declared as NULL.
+ *                      The RKH implementation preserves the transition sequence
+ *                      imposed by Harel's Statechart and UML.
+ *  \param[in] parent	pointer to parent state.
+ *  \param[in] sbm		pointer to referenced submachine state machine.
+ *
+ *	\sa
+ *	RKH_SSBM_T structure definition for more information.
+ *
+ *	\code
+ *	RKH_CREATE_SUBMACHINE_STATE(    adquire,		// state name
+ *									start_adquire,  // entry action
+ *									stop_adquire,   // exit action
+ *									&processing,    // parent state
+ *									&herror );		// referenced submachine
+ *	\endcode
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_SUBMACHINE_STATE(name, en, ex, parent, sbm) \
+                                                               \
+    extern RKHROM RKH_EXPCN_T name##_exptbl[]; \
+    extern RKHROM RKH_TR_T name##_trtbl[]; \
+                                             \
+    RKHROM RKH_SSBM_T name = \
+    { \
+        {MKBASE(RKH_SUBMACHINE, name), MKST(en,ex,parent)}, \
+        MKSBM(name,sbm) \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a exit point connection point reference table.
+ *
+ *  \param[in] name		submachine state name
+ *
+ *	\note
+ *	This macro is not terminated with the semicolon.
+ *
+ *	\usage
+ *	This table have the general structure shown below:
+ *	\code
+ *	RKH_CREATE_EX_CNNPNT_TABLE( S2 )
+ *		RKH_EX_CNNPNT( EX1S2, &EXPNT1, NULL, &S1 ),
+ *		RKH_EX_CNNPNT( EX2S2, &EXPNT2, NULL, &S3 ),
+ *	RKH_END_EX_CNNPNT_TABLE
+ *	\endcode
+ *  Each exit point connection reference table always begins with the macro
+ *  RKH_CREATE_EX_CNNPNT_TABLE() and ends with the macro
+ *  RKH_END_EX_CNNPNT_TABLE().
+ *	As noted above, sandwiched between these macros are the exit point
+ *	macros, RKH_EX_CNNPNT().
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_EX_CNNPNT_TABLE(name) \
+    RKHROM RKH_EXPCN_T name##_exptbl[]= \
+    {
+
+/**
+ *  \brief
+ *	This macro creates an exit point connection point reference.
+ *
+ *	Connection point references are sources/targets of transitions implying
+ *	exits out of/entries into the submachine state machine referenced by a
+ *	submachine state.
+ *
+ *	An exit point connection point reference as the source of a transition
+ *	implies that the source of the transition is the exit point pseudostate
+ *	as defined in the submachine of the submachine state that has the exit
+ *	point connection point defined.
+ *
+ *	A connection point reference to an exit point has the same notation as
+ *	an exit point pseudostate.
+ *
+ *  \param[in] name     exit point connection point reference name.
+ *  \param[in] expnt	referenced exit point.
+ *  \param[in] act		pointer to transition action function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] ts		pointer to target state.
+ *
+ *	\sa
+ *	RKH_EXPCN_T structure definition for more information.
+ *
+ *  \usage
+ *  \code
+ *	// --- exit point pseudostates of SB submachine ---
+ *	RKH_CREATE_REF_EXPNT(   EXPNT1,
+ *							0,		// index of exit point connection table
+ *							&SB );
+ *	RKH_CREATE_REF_EXPNT(   EXPNT2,
+ *							1,      // index of exit point connection table
+ *							&SB );
+ *							...
+ *	// --- exit point connection references of S12 submachine state ---
+ *	RKH_CREATE_EX_CNNPNT_TABLE( S12 )
+ *		RKH_EX_CNNPNT( EX1S12, &EXPNT1, ... ), // table index = 0 (EXPNT1)
+ *		RKH_EX_CNNPNT( EX2S12, &EXPNT2, ... ), // table index = 1 (EXPNT2)
+ *	RKH_END_EX_CNNPNT_TABLE
+ *	\endcode
+ */
+#define RKH_EX_CNNPNT(name, expnt, act, ts) \
+    {(RKH_TRN_ACT_T)act, (RKHROM struct RKH_ST_T *)ts}
+
+/**
+ *  \brief
+ *	This macro is used to terminate a exit point connection reference table.
+ *
+ *	\note
+ *	This macro is not terminated with the semicolon.
+ *
+ *	\usage
+ *	This table have the general structure shown below:
+ *	\code
+ *	RKH_CREATE_EX_CNNPNT_TABLE( S2 )
+ *		RKH_EX_CNNPNT( EX1S2, &EXPNT1, NULL, &S1 ),
+ *		RKH_EX_CNNPNT( EX2S2, &EXPNT2, NULL, &S3 ),
+ *	RKH_END_EX_CNNPNT_TABLE
+ *	\endcode
+ *  Each exit point table always begins with the macro
+ *  RKH_CREATE_EX_CNNPNT_TABLE() and ends with the macro
+ *  RKH_END_EX_CNNPNT_TABLE().
+ *	As noted above, sandwiched between these macros are the exit point
+ *	macros, RKH_EX_CNNPNT().
+ */
+#define RKH_END_EX_CNNPNT_TABLE     };
+
+/**
+ *  \brief
+ *	This macro creates an entry point connection point reference.
+ *
+ *	Connection point references are sources/targets of transitions implying
+ *	exits out of/entries into the submachine state machine referenced by a
+ *	submachine state.
+ *
+ *	An entry point connection point reference as the target of a transition
+ *	implies that the target of the transition is the entry point pseudostate
+ *	as defined in the submachine of the submachine state.
+ *
+ *	A connection point reference to an entry point has the same notation as
+ *	an entry point pseudostate.
+ *
+ *  \param[in] name		entry point connection point reference name.
+ *  \param[in] enpnt	referenced entry point.
+ *  \param[in] subm		pointer to submachine state.
+ *
+ *	\sa
+ *	RKH_SENP_T structure definition for more information.
+ */
+#define RKH_EN_CNNPNT(name, enpnt, subm) \
+                                         \
+    RKHROM RKH_SENP_T name = \
+    { \
+        MKBASE(RKH_ENPOINT, name), \
+        MKENP(enpnt,subm) \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a submachine state machine, which is to be
+ *	inserted in place of the (submachine) state.
+ *
+ *  \param[in] name		submachine name. Represents a submachine structure.
+ *  \param[in] defchild	pointer to default child state.
+ *  \param[in] iact		pointer to initialization action (optional). The
+ *                      function prototype is defined as RKH_INIT_ACT_T. This
+ *                      argument is optional, thus it could be declared as
+ *                      NULL.
+ *
+ *	\sa
+ *	RKH_RSM_T structure definition for more information.
+ *
+ *  \code
+ *  RKH_CREATE_REF_SUBMACHINE(  adquire,
+ *                              &wait,
+ *                              init_adquire );
+ *  \endcode
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_REF_SUBMACHINE(name, defchild, iact) \
+                                                        \
+    static RKHROM RKH_ST_T * rdyp_##name; \
+                                            \
+    RKHROM RKH_RSM_T name = \
+    { \
+        MKBASE(RKH_REF_SUBMACHINE, name), \
+        MKMCH(defchild,iact,name) \
+    }
+
+/**
+ *  \brief
+ *	This macro creates an exit point.
+ *
+ *  An exit pseudostate is used to join an internal transition terminating on
+ *  that exit point to an external transition emanating from that exit point.
+ *  The main purpose of such entry and exit points is to execute the state
+ *  entry and exit actions respectively in between the actions that are
+ *  associated with the joined transitions.
+ *
+ *  \param[in] name		entry point name.
+ *  \param[in] ix		index of exit point connection table. Note that each 
+ *                      row number matches with the index number of the exit 
+ *                      point pseudostate that it represent.
+ *  \param[in] subm		pointer to submachine state machine.
+ *
+ *  \code
+ *  RKH_CREATE_REF_EXPNT(handled,
+ *                       0,
+ *                       &handle_error);
+ *  \endcode
+ *
+ *	\sa
+ *	RKH_SEXP_T structure definition for more information.
+ *
+ *  \usage
+ *	\code
+ *	// --- exit point pseudostates of SB submachine ---
+ *	RKH_CREATE_REF_EXPNT(   EXPNT1,
+ *							0,		// index of exit point connection table
+ *							&SB );
+ *	RKH_CREATE_REF_EXPNT(   EXPNT2,
+ *							1,      // index of exit point connection table
+ *							&SB );
+ *							...
+ *	// --- exit point connection references of S12 submachine state ---
+ *	RKH_CREATE_EX_CNNPNT_TABLE( S12 )
+ *		RKH_EX_CNNPNT( EX1S12, &EXPNT1, ... ), // table index = 0 (EXPNT1)
+ *		RKH_EX_CNNPNT( EX2S12, &EXPNT2, ... ), // table index = 1 (EXPNT2)
+ *	RKH_END_EX_CNNPNT_TABLE
+ *	\endcode
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_REF_EXPNT(name, ix, subm) \
+                                             \
+    RKHROM RKH_SEXP_T name = \
+    { \
+        MKBASE(RKH_EXPOINT, name), \
+        ix, subm \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a entry point.
+ *
+ *  An entry pseudostate is used to join an external transition terminating
+ *  on that entry point to an internal transition emanating from that entry
+ *  point.
+ *  The main purpose of such entry and exit points is to execute the state
+ *  entry and exit actions respectively in between the actions that are
+ *  associated with the joined transitions.
+ *
+ *  \param[in] name     entry point name.
+ *  \param[in] act		pointer to transition action function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] ts		pointer to target state.
+ *  \param[in] subm		pointer to submachine state machine.
+ *
+ *	\sa
+ *	RKH_ENPCN_T structure definition for more information.
+ *
+ *  \code
+ *  RKH_CREATE_REF_ENPNT(   show,
+ *                          2,
+ *                          &S2,
+ *                          &handle_error );
+ *  \endcode
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_REF_ENPNT(name, act, ts, subm) \
+                                                  \
+    RKHROM RKH_ENPCN_T name = \
+    { \
+        (RKH_TRN_ACT_T)act, (RKHROM struct RKH_ST_T *)ts \
+    }
+
+/**
+ *  \brief
+ *	This macro creates a state transition table. 
+ *  
+ *  \param[in] name		state name.
+ *
+ *	\note
+ *	This macro is not terminated with the semicolon.
+ *  
+ *  \usage
+ *  This table have the general structure shown below:
+ *	\code
+ *	RKH_CREATE_TRANS_TABLE( state_name )		// transition table begin
+ *		RKH_TRxx( ... )							// transition
+ *		RKH_TRxx( ... )							// transition
+ *		...
+ *	RKH_END_TRANS_TABLE							// transition table end
+ *	\endcode
+ *  Each transition table always begins with the macro RKH_CREATE_TRANS_TABLE()
+ *  and ends with the macro RKH_END_TRANS_TABLE().
+ *	As noted above, sandwiched between these macros are the transitions macros
+ *	that actually represent behavior of state.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_TRANS_TABLE(name) \
+                                     \
+    RKHROM RKH_TR_T name##_trtbl[]= \
+    {
+
+/**
+ *  \brief
+ *	This macro defines a regular state transition.
+ *
+ *	The general syntax of an expression labelling a transition in a
+ *	statechart is \e "i[c]/a" where \e i is the input that triggers the
+ *	transition, \e c is a condition that guards the transition from being
+ *	taken unless it is true when \e i occurs, and \e a is an action that
+ *	is carried out if and when the transition is taken. All of these parts
+ *	are optional.
+ *
+ *  \param[in] evt_	    triggering event.
+ *  \param[in] guard_	pointer to guard function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] effect_	pointer to action function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] target_	pointer to target state.
+ *
+ *	\sa
+ *	RKH_TR_T structure definition for more information.
+ *
+ *  \usage
+ *	\code
+ *	RKH_TRREG(  TOUT0,              // triggering event
+ *				is_full,            // guard function
+ *				drop_frame,         // action function
+ *				&WAIT_SYNC )		// next state
+ *	\endcode
+ */
+#define RKH_TRREG(evt_, guard_, effect_, target_) \
+            MKTRN(evt_, guard_, effect_, target_)
+
+/**
+ *  \brief
+ *	This macro defines an internal state transition.
+ *	Internal transitions are simple reactions to events that never lead
+ *	to change of state and consequently never cause execution of exit
+ *	actions, entry actions, or initial transitions.
+ *
+ *  \param[in] e    triggering event.
+ *  \param[in] g	pointer to guard function.
+ *  \param[in] a	pointer to action function.
+ *
+ *	\sa
+ *	RKH_TR_T structure definition for more information.
+ *
+ *  \usage
+ *	\code
+ *	RKH_TRINT(  RCV_DATA,           // triggering event
+ *				is_sync,            // guard function
+ *				store_data )        // action function
+ *	\endcode
+ */
+#define RKH_TRINT(e, g, a)    {e, (RKH_GUARD_T)g, (RKH_TRN_ACT_T)a, NULL}
+
+/**
+ *  \brief
+ *	This macro defines a completion transition.
+ *
+ *  A special kind of transition is a completion transition, which has an 
+ *  implicit trigger. The event that enables this trigger is called a 
+ *  completion event and it signifies that all behaviors associated with the 
+ *  source state of the completion transition have completed execution. 
+ *  In case of simple states, a completion event is generated when the 
+ *  associated entry behavior have completed executing. If no such behaviors 
+ *  are defined, the completion event is generated upon entry into the state. 
+ *  For composite state, a completion event is generated under the following 
+ *  circumstances:
+ *  - All internal activities (e.g., entry behavior) have completed execution, 
+ *  and
+ *  - its region have reached a finalState.
+ *
+ *  \param[in] guard_	pointer to guard function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] effect_	pointer to effect function. This argument is
+ *					    optional, thus it could be declared as NULL.
+ *  \param[in] target_	pointer to target vertex (state or pseudostate).
+ *
+ *	\sa
+ *	RKH_TR_T structure definition for more information.
+ *
+ *  \usage
+ *	\code
+ *	RKH_TRCOMPLETION(isFull,        // guard function
+ *				     dropFrame,     // effect function
+ *				     &waitSync),    // next state
+ *	\endcode
+ */
+#define RKH_TRCOMPLETION(guard_, effect_, target_) \
+    {RKH_COMPLETION_EVENT, \
+     (RKH_GUARD_T)guard_, (RKH_TRN_ACT_T)effect_, target_}
+
+/**
+ *  \brief
+ *	This macro is used to terminate a state transition table.
+ *	This table have the general structure shown below:
+ *	\code
+ *	RKH_CREATE_TRANS_TABLE( state_name )		// transition table begin
+ *		RKH_TRxx( ... )							// transition
+ *		RKH_TRxx( ... )							// transition
+ *		...
+ *	RKH_END_TRANS_TABLE							// transition table end
+ *	\endcode
+ *
+ *  Each transition table always begins with the macro RKH_CREATE_TRANS_TABLE()
+ *  and ends with the macro RKH_END_TRANS_TABLE().
+ *	As noted above, sandwiched between these macros are the transitions macros
+ *	that actually represent behavior of state.
+ *
+ *	\note
+ *	This macro is not terminated with the semicolon.
+ */
+#define RKH_END_TRANS_TABLE     {RKH_ANY, NULL, NULL, NULL}};
+
+/**
+ *	This macro creates a branch table. 
+ *
+ *  \param[in] name		conditional pseudostate name.
+ *
+ *	\sa
+ *	This macro is not terminated with the semicolon.
+ *	Use rkh_sm_else() when if all the guards on the other branches are false.
+ *
+ *  \usage
+ *	This table have the general structure shown below:
+ *	\code
+ *	RKH_CREATE_BRANCH_TABLE( C2 )
+ *		RKH_BRANCH( is_power_ok,    enable_process,	&power		),
+ *		RKH_BRANCH( is_switch_off,  turnoff,		&wait		),
+ *		RKH_BRANCH( ELSE,           abort,			&aborted	),
+ *	RKH_END_BRANCH_TABLE
+ *	\endcode
+ *  Each branch table always begins with the macro RKH_CREATE_BRANCH_TABLE()
+ *  and ends with the macro RKH_END_BRANCH_TABLE().
+ *  In RKH branches are defined by the macro RKH_BRANCH().
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_BRANCH_TABLE(name) \
+                                      \
+    RKH_CREATE_TRANS_TABLE(name)
+
+/**
+ *  \brief
+ *	This macro defines a branch in the branch table.
+ *
+ *	Each condition connector can have one special branch with a guard
+ *	labeled rkh_sm_else, which is taken if all the guards on the other
+ *	branches are false.
+ *	The general syntax of an expression labelling a branch in a statechart is
+ *	\e "[c]/a" where \e c is a condition that guards the transition from
+ *	being taken unless it is true, and \e a is an action that is carried out
+ *	if and when the transition is taken. All of these parts are optional.
+ *
+ *  \param[in] guard_	branch guard function. Branches are labeled with guards
+ *                      that determine which one is to be actually taken. Use
+ *                      ELSE macro when if all the guards on the other branches
+ *                      are false.
+ *  \param[in] effect_	pointer to transition action. This argument is 
+ *                      optional, thus it could be declared as NULL.
+ *  \param[in] target_	pointer to target state.
+ *
+ *	\sa
+ *	RKH_TR_T structure definition for more information.
+ *
+ *  \usage
+ *	\code
+ *	RKH_CREATE_BRANCH_TABLE( C2 )
+ *		RKH_BRANCH( is_power_ok,    enable_process,	&power		),
+ *		RKH_BRANCH( is_switch_off,  turnoff,		&wait		),
+ *		RKH_BRANCH( ELSE,           abort,			&aborted	),
+ *	RKH_END_BRANCH_TABLE
+ *	\endcode
+ */
+#define RKH_BRANCH(guard_, effect_, target_) \
+            MKTRN(0, guard_, effect_, target_)
+
+/**
+ *  \brief
+ *  Define a RAM storage to mantain the last visited state of a composite 
+ *  state (history pseudostate).
+ *
+ *  Frequently, it's used before of RKH_CREATE_COMP_REGION_STATE() macro to 
+ *  define the dynamic storage of a history pseudostate.
+ *
+ *  \param[in] compStateName    pointer to the composite state that contains 
+ *                              this history pseudostate.
+ *
+ *  \ingroup apiSM
+ */
+#define RKH_CREATE_HISTORY_STORAGE(compStateName) \
+    static RKHROM RKH_ST_T *ramHist_##compStateName
+
+/**
+ *  \brief
+ *  Return the history storage address of a composite state. 
+ *
+ *  Frequently, it's used in the hRamMem parameter of 
+ *  RKH_CREATE_COMP_REGION_STATE() macro to define the dynamic storage of a 
+ *  history pseudostate.
+ *
+ *  \param[in] compStateName    pointer to the composite state that contains 
+ *                              this history pseudostate.
+ */
+#define RKH_GET_HISTORY_STORAGE(compStateName) \
+    &ramHist_##compStateName
+
+/*
+ *  This macro is internal to RKH and the user application should
+ *  not call it.
+ */
+#define RKH_EBTBL               {RKH_ANY, NULL, NULL, NULL}
+
+/**
+ *  \brief
+ *	This macro is used to terminate a state transition table.
+ *	This table have the general structure shown below:
+ *	\code
+ *	RKH_CREATE_BRANCH_TABLE( C2 )
+ *		RKH_BRANCH( is_power_ok,    enable_process,	&power		),
+ *		RKH_BRANCH( is_switch_off,  turnoff,		&wait		),
+ *		RKH_BRANCH( ELSE,           abort,			&aborted	),
+ *	RKH_END_BRANCH_TABLE
+ *	\endcode
+ *
+ *  Each branch table always begins with the macro RKH_CREATE_BRANCH_TABLE()
+ *  and ends with the macro RKH_END_BRANCH_TABLE().
+ *
+ *	\sa
+ *	This macro is not terminated with the semicolon.
+ */
+#define RKH_END_BRANCH_TABLE    RKH_EBTBL};
+
+/**
+ *  \brief
+ *	This macro indicates the root state of a state machine.
+ */
+#define RKH_ROOT                RKH_NULL
+
+/**
+ *  \brief
+ *  This macro declares an opaque pointer to previously created state machine
+ *  to be used as a global object.
+ *
+ *  This global pointer represent the state machine in the application.
+ *  The state machine pointers are "opaque" because they cannot access the
+ *  whole state machine structure, but only the part inherited from the
+ *  RKH_SM_T structure. The power of an "opaque" pointer is that it allows
+ *  to completely hide the definition of the state machine structure and make
+ *  it inaccessible to the rest of the application.
+ *
+ *  \param[in] me_	Pointer to previously created state machine.
+ *
+ *	\note
+ *  Generally, this macro is used in the SMA's header file.
+ *
+ *  \sa
+ *  RKH_SMA_CREATE(), RKH_SM_CREATE().
+ *
+ *  \usage
+ *  \code
+ *  // ColorRegion.h: state machine's header file
+ *
+ *  RKH_SM_DCLR_TYPE(ColorRegion, color);
+ *  \endcode
+ */
+#define RKH_SM_DCLR(me_) \
+            RKH_DCLR_PTR_TYPE(RKH_SM_T, me_)
+
+/**
+ *  \brief
+ *  This macro declares a typed pointer to previously created state machine
+ *  to be used as a global and public object.
+ *
+ *  \param[in] type_
+ *                  Data type of the state machine, derived from RKH_SM_T. 
+ *  \param[in] me_	Pointer to previously created state machine.
+ *
+ *	\note
+ *  Generally, this macro is used in the SMA's header file.
+ *
+ *  \sa
+ *  RKH_SMA_CREATE(), RKH_SM_CREATE().
+ *
+ *  \usage
+ *  \code
+ *  // ColorRegion.h: state machine's header file
+ *
+ *  RKH_SM_DCLR_TYPE(ColorRegion, color);
+ *  \endcode
+ */
+#define RKH_SM_DCLR_TYPE(type_, me_) \
+            RKH_DCLR_PTR_TYPE(type_, me_)
+
+/**@{
+ *
+ *  \brief
+ *  Declares a previously created state/pseudostate to be used
+ *  as a global object.
+ *
+ *  \note
+ *  Generally, this macro is used in the state-machine's header file.
+ */
+#define RKH_DCLR_COMP_STATE     extern RKHROM RKH_SCMP_T
+#define RKH_DCLR_BASIC_STATE    extern RKHROM RKH_SBSC_T
+#define RKH_DCLR_FINAL_STATE    extern RKHROM RKH_FINAL_T
+#define RKH_DCLR_COND_STATE     extern RKHROM RKH_SCOND_T
+#define RKH_DCLR_CHOICE_STATE   extern RKHROM RKH_SCHOICE_T
+#define RKH_DCLR_DHIST_STATE    extern RKHROM RKH_SHIST_T
+#define RKH_DCLR_SHIST_STATE    extern RKHROM RKH_SHIST_T
+#define RKH_DCLR_SUBM_STATE     extern RKHROM RKH_SSBM_T
+#define RKH_DCLR_REF_SUBM       extern RKHROM RKH_RSM_T
+#define RKH_DCLR_ENPNT          extern RKHROM RKH_SENP_T
+#define RKH_DCLR_REF_EXPNT      extern RKHROM RKH_SEXP_T
+#define RKH_DCLR_REF_ENPNT      extern RKHROM RKH_ENPCN_T
+/**@}*/
+
+/**
+ *  \brief
+ *  Declares a state transition table.
+ *
+ *  \param[in] name			name of state (basic or composite) object.
+ */
+#define RKH_DECLARE_TR_TBL(name) \
+    extern RKHROM RKH_TR_T name##_trtbl[]
+
+/**
+ *  \brief
+ *  Declares a previously created SMA to be used as a global object.
+ *
+ *  \param[in] sma_t		data type of SMA.
+ *  \param[in] sm			name of previously created SMA.
+ *  \param[in] gob			name of global object.
+ *
+ *  \note
+ *  Generally, this macro is used in the state-machine's module.
+ *
+ *	\sa
+ *	RKH_SMA_T structure definition for more information. Also,
+ *	\link RKH_EVT_T single inheritance in C \endlink, and
+ *	\link RKH_CREATE_BASIC_STATE another example \endlink.
+ *
+ *  \usage
+ *	\code
+ *	//	g_my: global pointer to SMA "my".
+ *	RKH_DCLR_SM_GLOBAL( MYSM_T, my, g_my );
+ *	\endcode
+ */
+#define RKH_DCLR_SM_GLOBAL(sma_t, sm, gob) \
+    sma_t * const gob = &s_##sm;
+
+/**
+ *  \brief
+ *	Initializes the parameters (attibutes) of a basic state object.
+ *
+ *	By means of single inheritance in C it could be used to associate data
+ *	to a basic state. Moreover, implementing the single inheritance in C
+ *	is very simply by literally embedding the base type, RKH_SBSC_T in this
+ *	case, as the first member of the derived structure. The following
+ *	listing shows an example:
+ *
+ *	\sa
+ *	See #RKH_CREATE_BASIC_STATE() macro for more information.
+ *
+ *  \usage
+ *	\code
+ *	(1) typedef struct MENU_ST_T
+ *		{
+ *	(2)		RKHROM RKH_SBSC_T base;
+ *	(3)		const char *title;
+ *		} MENU_ST_T;
+ *
+ *	...
+ *
+ *	(4) #define MENU_BASIC_STATE( type_t, name, en, ex, parent, title ) \
+ *	(5)				RKH_DECLARE_TR_TBL( name ); \
+ *					\
+ *	(6)				RKHROM type_t name = \
+ *					{ \
+ *	(7)					RKH_INIT_BASIC_STATE( name, en, ex, parent, NULL ), \
+ *	(8)					title \
+ *					}
+ *
+ *	(9) MENU_BASIC_STATE( MENU_ST_T, menu_cfg,  NULL, NULL, RKH_ROOT,
+ *												"Menu 1" );
+ *		RKH_CREATE_TRANS_TABLE( menu_cfg )
+ *			RKH_TRREG( TIMEOUT, NULL, mc_title, &menu_cfg_resume ),
+ *			...
+ *		RKH_END_TRANS_TABLE
+ *
+ *  ...
+ *
+ *
+ *	(10) void
+ *		 mc_title( const struct RKH_SMA_T *me )
+ *		 {
+ *		    ...
+ *			lcd_print("%s\n", 
+ *			          ((MENU_ST_T *)(((RKH_SM_T *)me)->state))->title);
+ *		 }
+ *	\endcode
+ *
+ *	(1)  Defines MENU_ST_T as a derived structure from the basic state
+ *		 structure. It could be used to associate data to a basic state
+ *		 objects. \n
+ *	(2)	 Implementing the single inheritance in C is very simply by literally
+ *		 embedding the base type, RKH_SBSC_T in this case, as the first
+ *		 member of the derived structure.  \n
+ *	(3)  Private members of MENU_ST_T derived structure. \n
+ *	(4)  Defines a simple macro to instantiate the derived state object.
+ *		 It is not strictly necessary.  \n
+ *	(4)	 Declares the transtion table by means of RKH_DECLARE_TR_TBL() macro
+ *		 provided by the framework. \n
+ *	(6)  Instantiates the derived state structure. \n
+ *	(7)  Initializes the base structure, basic state in this case, using the
+ *		 RKH_INIT_BASIC_STATE() macro provided by the framework. \n
+ *	(8)  Initializes the private member of derived state. \n
+ *	(9)  Invokes the BLINKY_BASIC_STATE() macro to instantiate the
+ *		 derived state object, menu_cfg. Note that the "Menu 1" string is
+ *		 associated to the state machine context, menu_cfg state in this
+ *		 case. \n
+ *	(10) Lastly, on the transtion action mc_title(), or any other action, is
+ *		 used the state data after casting the active object state to
+ *		 derived state object.
+ *
+ *  The following listing shows another example for derived state structure,
+ *  which access to RAM from ROM object (state structure).
+ *
+ *	\code
+ *	    typedef struct XY_T
+ *		{
+ *			int x;
+ *			int y;
+ *		} XY_T;
+ *
+ *	(1) typedef struct NUM_STATE_T
+ *		{
+ *	(2)		RKHROM RKH_SBSC_T base;
+ *	(3)     XY_T *p_ram_xy;
+ *		} NUM_STATE_T;
+ *
+ *	(4) #define NUM_BASIC_STATE( name, en, ex, parent, p_xy ) \
+ *	                RKH_DECLARE_TR_TBL( name ); \
+ *					\
+ *	                RKHROM NUM_STATE_T name = \
+ *					{ \
+ *	                    RKH_INIT_BASIC_STATE( name, en, ex, parent, NULL ), \
+ *	(5)					p_xy \
+ *					}
+ *
+ *		static XY_T xy;
+ *	(6) NUM_BASIC_STATE( num, NULL, NULL, RKH_ROOT, &xy );
+ *
+ *	    void
+ *		num_inc( const struct RKH_SMA_T *me )
+ *		{
+ *	(7)		((NUM_STATE_T *)(((RKH_SM_T *)me)->state))->p_ram_xy++;
+ *			...
+ *		}
+ *	\endcode
+ *
+ *	(1)  Defines NUM_STATE_T as a derived structure from the basic state
+ *		 structure. \n
+ *	(2)	 Implementing the single inheritance in C is very simply by literally
+ *		 embedding the base type, RKH_SBSC_T in this case, as the first
+ *		 member of the derived structure. \n
+ *	(3)  Private members of NUM_STATE_T derived structure. It allows to
+ *		 acccess to RAM locations from this object (NUM_STATE_ST) allocated
+ *		 in ROM. \n
+ *	(4)  Defines a simple macro to instantiate the derived state object. \n
+ *	(5)  Initializes the private member of derived state. \n
+ *	(6,7)Invokes the NUM_BASIC_STATE() macro to instantiate the derived
+ *		 state object, num. Note that the variable xy is allocated in RAM
+ *		 but it is access to read and write from ROM object. \n
+ */
+#define RKH_INIT_BASIC_STATE(name, en, ex, parent, prepro) \
+    { \
+        { \
+            MKBASE(RKH_BASIC, name),    /* RKH_BASE_T */ \
+            MKST(en, ex, parent) \
+        },                              /* RKH_ST_T */ \
+        MKBASIC(name, prepro) \
+    } /* RKH_SBSC_T */ \
+
+
+/**
+ *  \brief
+ *	Initializes the parameters (attibutes) of a composite state object.
+ *
+ *	By means of single inheritance in C it could be used to associate data
+ *	to a basic state. Moreover, implementing the single inheritance in C
+ *	is very simply by literally embedding the base type, RKH_SCMP_T in this
+ *	case, as the first member of the derived structure.
+ *
+ *	\note
+ *	See RKH_INIT_BASIC_STATE() and RKH_CREATE_COMP_STATE() macros to more
+ *	information.
+ */
+#define RKH_INIT_COMPOSITE_STATE(name, en, ex, parent, \
+                                 defchild, history) \
+    { \
+        { \
+            MKBASE(RKH_COMPOSITE, name),    /* RKH_BASE_T */ \
+            MKST(en, ex, parent) \
+        },                                  /* RKH_ST_T */ \
+        MKCOMP(name, defchild, history) \
+    }                                       /* RKH_SCMP_T */ \
+
+/**
+ *  \brief
+ *  This values are retrived by guard functions.
+ *
+ *  A guard is a boolean condition that returns a true or false value that
+ *  controls whether or not a transition is taken following the receipt of
+ *  a triggering event.
+ */
+#define RKH_GFALSE      RKH_FALSE   /**< False condition */
+#define RKH_GTRUE       RKH_TRUE    /**< True condition */
+
+/**
+ *  \brief
+ *  Use it to allocate a state machine regardless of an active object.
+ *
+ *  \param[in] type 	Data type of the SMA. Could be derived from RKH_SMA_T.
+ *  \param[in] name		Name of state machine application. Also, it represents 
+ *                      the top state of state diagram.
+ *  \param[in] prio		State machine application priority. A unique priority
+ *                      number must be assigned to each SMA from 0 to
+ *                      RKH_LOWEST_PRIO. The lower the number, the higher the
+ *                      priority.
+ *  \param[in] ppty		State machine properties. The available properties are
+ *                      enumerated in RKH_HPPTY_T enumeration in the rkh.h
+ *                      file.
+ *  \param[in] initialState
+ *                      Pointer to initial state. This state could be defined
+ *                      either composite or basic (not pseudo-state).
+ *  \param[in] initialAction
+ *                      Pointer to initialization action (optional). The
+ *                      function prototype is defined as RKH_INIT_ACT_T. This
+ *                      argument is optional, thus it could be declared as
+ *                      NULL.
+ *  \param[in] initialEvt
+ *                      Pointer to an event that will be passed to state
+ *                      machine application when it starts. Could be used to
+ *                      pass arguments to the state machine like an argc/argv.
+ *                      This argument is optional, thus it could be declared
+ *                      as NULL or eliminated in compile-time with
+ *                      RKH_CFG_SMA_INIT_EVT_EN = 0.
+ *
+ *  \sa RKH_SM_CONST_CREATE, RKH_SM_GET_CONST, RKH_SM_GET_CONST
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SM_CREATE(type, name, prio, ppty, initialState, \
+                          initialAction, initialEvt) \
+        RKH_SM_CONST_CREATE(name, prio, ppty, initialState, initialAction, \
+                            initialEvt); \
+        static type s_##name = {MKSM(&RKH_SM_CONST_NAME(name), initialState)}
+#else
+    #define RKH_SM_CREATE(type, name, prio, ppty, initialState, \
+                          initialAction, initialEvt) \
+        static type RKH_SMA_NAME(name) = {MKSM(name, prio, ppty, initialState, \
+                                               initialAction, initialEvt)}
+#endif
+
+/**
+ *  \brief
+ *  Initialize (at runtime) a previously created state machine object.
+ *
+ *  \param[in] me_		Name of state machine. Also, it represents the top 
+ *                      state of state diagram.
+ *  \param[in] nameSMConst_  
+ *                      Describe it 
+ *  \param[in] prio_	State machine application priority. A unique priority
+ *                      number must be assigned to each SMA from 0 to
+ *                      RKH_LOWEST_PRIO. The lower the number, the higher the
+ *                      priority.
+ *  \param[in] ppty_	State machine properties. The available properties are
+ *                      enumerated in RKH_HPPTY_T enumeration in the rkh.h
+ *                      file.
+ *  \param[in] initialState_ 
+ *                      Pointer to initial state. This state could be defined
+ *                      either composite or basic (not pseudo-state).
+ *  \param[in] initialAction_ 
+ *                      Pointer to initialization action (optional). The
+ *                      function prototype is defined as RKH_INIT_ACT_T. This
+ *                      argument is optional, thus it could be declared as
+ *                      NULL.
+ *  \param[in] initialEvt_ 
+ *                      Pointer to an event that will be passed to state
+ *                      machine application when it starts. Could be used to
+ *                      pass arguments to the state machine like an argc/argv.
+ *                      This argument is optional, thus it could be declared
+ *                      as NULL or eliminated in compile-time with
+ *                      RKH_CFG_SMA_INIT_EVT_EN = 0.
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SM_INIT(me_, nameSMConst_, prio_, ppty_, initialState_, \
+                        initialAction_, initialEvt_) \
+        ((RKH_SM_T *)me_)->romrkh = \
+            (RKHROM RKH_ROM_T *)(RKH_SM_GET_CONST_OBJ(nameSMConst_)); \
+        ((RKH_SM_T *)me_)->state = \
+            (RKHROM struct RKH_ST_T *) \
+                ((RKH_SM_GET_CONST_OBJ(nameSMConst_))->istate)
+#else
+    #define RKH_SM_INIT(sm, name, prio, ppty, initialState, \
+                        initialAction, initialEvt) \
+        MKRT_SM(sm, name, prio, ppty, initialState, initialAction, initialEvt)
+#endif
+
+/**
+ *  \brief
+ *  Allocates and then initializes the constant part (in ROM) of the state 
+ *  machine.
+ *
+ *  \param[in] name		Name of state machine application. Also, it represents 
+ *                      the top state of state diagram.
+ *  \param[in] prio		State machine application priority. A unique priority
+ *                      number must be assigned to each SMA from 0 to
+ *                      RKH_LOWEST_PRIO. The lower the number, the higher the
+ *                      priority.
+ *  \param[in] ppty		State machine properties. The available properties are
+ *                      enumerated in RKH_HPPTY_T enumeration in the rkh.h
+ *                      file.
+ *  \param[in] initialState
+ *                      Pointer to initial state. This state could be defined
+ *                      either composite or basic (not pseudo-state).
+ *  \param[in] initialAction
+ *                      Pointer to initialization action (optional). The
+ *                      function prototype is defined as RKH_INIT_ACT_T. This
+ *                      argument is optional, thus it could be declared as
+ *                      NULL.
+ *  \param[in] initialEvt
+ *                      Pointer to an event that will be passed to state
+ *                      machine application when it starts. Could be used to
+ *                      pass arguments to the state machine like an argc/argv.
+ *                      This argument is optional, thus it could be declared
+ *                      as NULL or eliminated in compile-time with
+ *                      RKH_CFG_SMA_INIT_EVT_EN = 0.
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SM_CONST_CREATE(name, prio, ppty, initialState, \
+                                initialAction, initialEvt) \
+       static RKHROM RKH_ROM_T RKH_SM_CONST_NAME(name) = \
+                                                MKRRKH(name, \
+                                                       prio, \
+                                                       ppty, \
+                                                       initialState, \
+                                                       initialAction, \
+                                                       initialEvt)
+#else
+    #define RKH_SM_CONST_CREATE(name, prio, ppty, initialState, \
+                                initialAction, initialEvt)
+#endif
+
+/**
+ *  \brief
+ *  Return the address of the constant part from a previously created and 
+ *  initializated state machine.
+ *
+ *  \param[in] sm   Name of state machine.
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SM_GET_CONST(sm) \
+        ((RKH_SM_T *)sm)->romrkh
+#else
+    #define RKH_SM_GET_CONST(sm) \
+        ((RKH_SM_T *)sm)
+#endif
+
+/**
+ *  \brief
+ *  Return the address of the constant part of a state machine.
+ *
+ *  \param[in] sm   Name of state machine.
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SM_GET_CONST_OBJ(sm) \
+        &RKH_SM_CONST_NAME(sm)
+#else
+    #define RKH_SM_GET_CONST_OBJ(sm) \
+        ((RKH_SM_T *)sm)
+#endif
+
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+    #define RKH_SM_GET_OBJ(type, sm)
+#else
+    #define RKH_SM_GET_OBJ(type, sm) \
+        (type *)&RKH_SM_NAME(sm)
+#endif
+
+/**
+ *  \brief
+ *  Declare an opaque pointer pointing to a previously created state 
+ *  machine.
+ *
+ *  \param[in] sm   Name of state machine.
+ *
+ *  \sa RKH_SMA_DCLR()
+ */
+#define RKH_SM_DEF_PTR(sm) \
+    RKH_SM_T *const sm = (RKH_SM_T *)&RKH_SM_NAME(sm)
+
+/**
+ *  \brief
+ *  Declare a pointer of specified type pointing to a previously created 
+ *  state machine.
+ *  
+ *  The pointer could be used to hide (opaque) or to publish the internals of 
+ *  the class of the state machine. 
+ *
+ *  \param[in] type Data type of the state machine. Could be derived from 
+ *                  RKH_SM_T.
+ *  \param[in] sm   Name of state machine.
+ *
+ *  \sa RKH_SMA_DCLR()
+ */
+#define RKH_SM_DEF_PTR_TYPE(type, sm) \
+    type *const sm = (type *)&RKH_SM_NAME(sm)
+
+/**
+ *  \brief
+ *  This macro retrieves the state ID of SMA.
+ *
+ *  \param[in] me	pointer to previously created state machine application.
+ *
+ *  \return
+ *  Id of current state.
+ */
+#define RKH_GET_CSTATE_ID(me) \
+    ((RKH_BASE_T *)(((RKH_SM_T *)me)->state))->id
+
+#if R_TRC_AO_NAME_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *  This macro retrieves the name of a vertex.
+     *
+     *  \param[in] vx		pointer to previously created vertex object.
+     *
+     *  \return
+     *  Name of vertex object.
+     */
+    #define RKH_GET_VERTEX_NAME(vx) \
+        ((struct RKH_BASE_T *)(vx))->name
+#else
+    #define RKH_GET_VERTEX_NAME(vx)       noname
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  \brief
+ *  Return codes from rkh_sm_dispatch() function.
+ *
+ *  \ingroup apiSM
+ */
+typedef enum RKH_RCODE_T
+{
+    /**
+     *  The arrived event was succesfully processed and HSM
+     *  resides in an allowed state.
+     */
+    RKH_EVT_PROC,
+
+    /**
+     *  The arrived event was't founded in the transition table.
+     */
+    RKH_EVT_NFOUND,
+
+    /**
+     *  The branch function returned a value not founded
+     *  in the branch table.
+     */
+    RKH_CND_NFOUND,
+
+    /**
+     *  The transition was cancelled by guard function.
+     */
+    RKH_GRD_FALSE,
+
+    /**
+     *  Unknown state.
+     */
+    RKH_UNKN_STATE,
+
+    /**
+     *  The transition exceeded the allowed hierarchical level.
+     */
+    RKH_EX_HLEVEL,
+
+    /**
+     *  The transition exceeded the allowed number of segments
+     *  within a compound transtion.
+     */
+    RKH_EX_TSEG,
+    RKH_NUM_CODES
+} RKH_RCODE_T;
+
+/**
+ *  \brief
+ *  State machine properties.
+ *
+ *  \ingroup apiSM
+ */
+typedef enum
+{
+    /**
+     *  Used as state machine property.
+     *  This macro enables state nesting in a particular state machine.
+     */
+    HCAL,
+
+    /**
+     *  Used as state machine property.
+     *  This macro disables state nesting in a particular state machine.
+     *  When FLAT is used in RKH_SMA_CREATE() macro some important features of
+     *  RKH are	not included: state nesting, composite state, history
+     *  (shallow and deep) pseudostate, entry action, and exit action.
+     */
+    FLAT,
+
+    /** Number of state machines properties */
+    RKH_NUM_HPPTY
+} RKH_HPPTY_T;
+
+/**
+ *  \brief
+ *  Initialization action.
+ *
+ *  Frequently, the state transition originating at the black ball is called
+ *  the initial transition. Such transition designates the first active state
+ *  after the state machine object is created. An initial transition can have
+ *  associated actions, which in the UML notation are enlisted after the
+ *  forward slash (/). In RKH framework, the application code must trigger
+ *  the initial transition explicitly by invoking rkh_sma_activate() function.
+ */
+#if (RKH_CFG_SMA_INIT_ARG_SMA_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED)
+    typedef void (*RKH_INIT_ACT_T)(const RKH_SM_T *me,
+                                   const struct RKH_EVT_T *e);
+#elif (RKH_CFG_SMA_INIT_ARG_SMA_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_INIT_EVT_EN == RKH_DISABLED)
+    typedef void (*RKH_INIT_ACT_T)(const RKH_SM_T *me);
+#elif (RKH_CFG_SMA_INIT_ARG_SMA_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED)
+    typedef void (*RKH_INIT_ACT_T)(const struct RKH_EVT_T *e);
+#else
+    typedef void (*RKH_INIT_ACT_T)(void);
+#endif
+
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+/**
+ *  \brief
+ *  Constant parameters of state machine.
+ *
+ *	The constant key parameters of a state machine are allocated within.
+ *
+ *	\sa
+ *	RKH_SMA_T structure definition for more information. Also,
+ *	\link RKH_EVT_T single inheritance in C \endlink, and
+ *	\link RKH_CREATE_BASIC_STATE another example \endlink.
+ */
+struct RKH_ROM_T
+{
+    /**
+     *  \brief
+     *  SMA (a.k.a Active Object) priority.
+     *
+     *  A unique priority number must be assigned to each SMA from 0 to
+     *  RKH_LOWEST_PRIO. The lower the number, the higher the priority.
+     */
+    rui8_t prio;
+
+    /**
+     *  \brief
+     *  State machine properties.
+     *
+     *  The available properties are enumerated in RKH_HPPTY_T enumeration in
+     *  the rkh.h file.
+     */
+    rui8_t ppty;
+
+    /**
+     *  \brief
+     *  Name of State Machine Application (a.k.a Active Object).
+     *
+     *  Pointer to an ASCII string (NULL terminated) to assign a name to the
+     *	State Machine Application (a.k.a Active Object). The name can be
+     *	displayed by debuggers or by Trazer.
+     */
+#if R_TRC_AO_NAME_EN == RKH_ENABLED
+    const char *name;
+#endif
+
+    /**
+     *  \brief
+     *  Points to initial state.
+     *
+     *  This state could be defined either composite or basic
+     *  (not pseudo-state).
+     */
+    RKHROM RKH_ST_T *istate;
+
+    /**
+     *  \brief
+     *  Points to initializing action (optional).
+     *
+     *  The function prototype is defined as RKH_INIT_ACT_T. This argument is
+     *  optional, thus it could be declared as NULL.
+     */
+    RKH_INIT_ACT_T iaction;
+
+    /**
+     *  \brief
+     *	Pointer to an event that will be passed to state machine application
+     *	when it starts. Could be used to pass arguments to the state machine
+     *	like an argc/argv. This argument is optional, thus it could be
+     *	declared as NULL or eliminated in compile-time with
+     *	RKH_CFG_SMA_INIT_EVT_EN = 0.
+     */
+#if RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED
+    const RKH_EVT_T *ievent;
+#endif
+};
+#endif
+
+/**
+ *  \brief
+ *  Describes the state machine.
+ *
+ *  RKH_SM_T is not intended to be instantiated directly, but rather
+ *  serves as the base structure for derivation of state machines in the
+ *  application code. Also, is the base structure of active object structure 
+ *  RKH_SMA_T.
+ *
+ *  \ingroup apiSM
+ */
+#if RKH_CFG_SMA_SM_CONST_EN == RKH_ENABLED
+struct RKH_SM_T
+{
+    /**
+     *  \brief
+     *  Points to constant parameters of state machine.
+     */
+    RKHROM RKH_ROM_T *romrkh;
+
+    /**
+     *  \brief
+     *  Points to current stable state (simple or final state).
+     */
+    RKHROM RKH_ST_T *state;
+};
+#else
+struct RKH_SM_T
+{
+    /**
+     *  \brief
+     *  SMA (a.k.a Active Object) priority.
+     *
+     *  A unique priority number must be assigned to each SMA from 0 to
+     *  RKH_LOWEST_PRIO. The lower the number, the higher the priority.
+     */
+    rui8_t prio;
+
+    /**
+     *  \brief
+     *  State machine properties.
+     *
+     *  The available properties are enumerated in RKH_HPPTY_T enumeration in
+     *  the rkh.h file.
+     */
+    rui8_t ppty;
+
+    /**
+     *  \brief
+     *  Name of State Machine Application (a.k.a Active Object).
+     *
+     *  Pointer to an ASCII string (NULL terminated) to assign a name to the
+     *	State Machine Application (a.k.a Active Object). The name can be
+     *	displayed by debuggers or by Trazer.
+     */
+#if R_TRC_AO_NAME_EN == RKH_ENABLED
+    const char *name;
+#endif
+
+    /**
+     *  \brief
+     *  Points to initial state.
+     *
+     *  This state could be defined either composite or basic
+     *  (not pseudo-state).
+     */
+    RKHROM RKH_ST_T *istate;
+
+    /**
+     *  \brief
+     *  Points to initializing action (optional).
+     *
+     *  The function prototype is defined as RKH_INIT_ACT_T. This argument is
+     *  optional, thus it could be declared as NULL.
+     */
+    RKH_INIT_ACT_T iaction;
+
+    /**
+     *  \brief
+     *	Pointer to an event that will be passed to state machine application
+     *	when it starts. Could be used to pass arguments to the state machine
+     *	like an argc/argv. This argument is optional, thus it could be
+     *	declared as NULL or eliminated in compile-time with
+     *	RKH_CFG_SMA_INIT_EVT_EN = 0.
+     */
+#if RKH_CFG_SMA_INIT_EVT_EN == RKH_ENABLED
+    const RKH_EVT_T *ievent;
+#endif
+
+    /**
+     *  \brief
+     *  Points to current stable state (simple or final state).
+     */
+    RKHROM RKH_ST_T *state;
+};
+#endif
+
+/**
+ *  \brief
+ *  Entry action.
+ *
+ *  The actions that are always executed when a state is entered
+ *  should be specified as entry actions. UML statecharts provide optional
+ *  entry and exit actions, which are associated with states rather than
+ *  transitions, as in a Moore automaton.
+ *  An entry function takes the state machine pointer as argument.
+ *  This argument is optional, thus it could be eliminated in
+ *  compile-time by means of RKH_CFG_SMA_ENT_ARG_SMA_EN.
+ *
+ *  The RKH implementation preserves the transition sequence imposed by
+ *  Harel's Statechart and UML. Specifically, the implemented transition
+ *  sequence is as follows:
+ *
+ *  - Execute exit actions of the source state.
+ *  - Execute the transition actions.
+ *  - Execute entry actions of the target state.
+ *
+ *  \note
+ *  This callback is referenced from RKH_CREATE_COMP_STATE() and
+ *  RKH_CREATE_BASIC_STATE() macros.
+ *  \b RKH_CFG_SMA_ENT_ARG_SMA_EN macro.
+ */
+
+#if RKH_CFG_SMA_ENT_ARG_SMA_EN == RKH_ENABLED
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+    typedef void (*RKH_ENT_ACT_T)(const RKH_SM_T *me,
+                                  const RKH_ST_T *state);
+    #else
+    typedef void (*RKH_ENT_ACT_T)(const RKH_SM_T *me);
+    #endif
+#else
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+    typedef void (*RKH_ENT_ACT_T)(const RKH_ST_T *state);
+    #else
+    typedef void (*RKH_ENT_ACT_T)(void);
+    #endif
+#endif
+
+/**
+ *  \brief
+ *  Exit action.
+ *
+ *  The actions that are always execute when a state is exited should be
+ *  exit actions. UML statecharts provide optional entry and exit actions,
+ *  which are associated with states rather than transitions, as in a
+ *  Moore automaton.
+ *  An exit function takes the state machine pointer as argument.
+ *  This argument is optional, thus it could be eliminated in
+ *  compile-time by means of RKH_CFG_SMA_EXT_ARG_SMA_EN.
+ *
+ *  The RKH implementation preserves the transition sequence imposed by
+ *  Harel's Statechart and UML. Specifically, the implemented transition
+ *  sequence is as follows:
+ *
+ *  - Execute exit actions of the source state.
+ *  - Execute the transition actions.
+ *  - Execute entry actions of the target state.
+ *
+ *  \note
+ *  This callback is referenced from RKH_CREATE_COMP_STATE() and
+ *  RKH_CREATE_BASIC_STATE() macros.
+ */
+
+#if RKH_CFG_SMA_EXT_ARG_SMA_EN == RKH_ENABLED
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+    typedef void (*RKH_EXT_ACT_T)(const RKH_SM_T *me,
+                                  const RKH_ST_T *state);
+    #else
+    typedef void (*RKH_EXT_ACT_T)(const RKH_SM_T *me);
+    #endif
+#else
+    #if RKH_CFG_SMA_ENT_ARG_STATE_EN == RKH_ENABLED
+    typedef void (*RKH_EXT_ACT_T)(const RKH_ST_T *state);
+    #else
+    typedef void (*RKH_EXT_ACT_T)(void);
+    #endif
+#endif
+
+/**
+ *  \brief
+ *  Event preprocessor.
+ *
+ *  Before sending the arrived event to state machine, it can be previously
+ *  processed using the	event preprocessor function.
+ *  The RKH framework provides optional event preprocessor
+ *  action, which are associated with states rather than transitions,
+ *  as in a Moore automaton.
+ *  This action takes the state machine pointer and the event
+ *  pointer as arguments.
+ *  This argument is optional, thus it could be eliminated in
+ *  compile-time by means of RKH_CFG_SMA_PPRO_ARG_SMA_EN.
+ *
+ *  \note
+ *  This callback is referenced from RKH_CREATE_COMP_STATE() and
+ *  RKH_CREATE_BASIC_STATE() macros.
+ */
+#if RKH_CFG_SMA_PPRO_ARG_SMA_EN == RKH_ENABLED
+    typedef RKH_SIG_T (*RKH_PPRO_T)(const RKH_SM_T *sma,
+                                    RKH_EVT_T *pe);
+#else
+    typedef RKH_SIG_T (*RKH_PPRO_T)(RKH_EVT_T *pe);
+#endif
+
+/**
+ *  \brief
+ *  Transition action.
+ *
+ *  Transition actions are small atomic behaviors executed at specified points
+ *  in a state machine. This actions are assumed to take an insignificant
+ *  amount of time to execute and are noninterruptible. UML statecharts
+ *  are extended state machines with characteristics of both Mealy and
+ *  Moore automata. In statecharts, actions generally depend on both
+ *  the state of the system and the triggering event, as in a Mealy
+ *  automaton. Additionally, UML statecharts provide optional entry and
+ *  exit actions, which are associated with states rather than transitions,
+ *  as in a Moore automaton.
+ *  An action function takes the state machine pointer and the event
+ *  pointer as arguments.
+ *  These arguments are optional, thus they could be eliminated in
+ *  compile-time by means of RKH_CFG_SMA_ACT_ARG_EVT_EN and \b
+ *  RKH_CFG_SMA_ACT_ARG_SMA_EN.
+ *
+ *  The RKH implementation preserves the transition sequence imposed by
+ *  Harel's Statechart and UML. Specifically, the implemented transition
+ *  sequence is as follows:
+ *
+ *  - Execute exit actions of the source state.
+ *  - Execute the transition actions.
+ *  - Execute entry actions of the target state.
+ *
+ *  \note
+ *  This callback is referenced from RKH_TRREG() and RKH_TRINT()macro.
+ */
+
+#if (RKH_CFG_SMA_ACT_ARG_EVT_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_ACT_ARG_SMA_EN == RKH_ENABLED)
+    typedef void (*RKH_TRN_ACT_T)(const RKH_SM_T *me,
+                                  RKH_EVT_T *pe);
+#elif (RKH_CFG_SMA_ACT_ARG_EVT_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_ACT_ARG_SMA_EN == RKH_DISABLED)
+    typedef void (*RKH_TRN_ACT_T)(RKH_EVT_T *pe);
+#elif (RKH_CFG_SMA_ACT_ARG_EVT_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_ACT_ARG_SMA_EN == RKH_ENABLED)
+    typedef void (*RKH_TRN_ACT_T)(const RKH_SM_T *me);
+#else
+    typedef void (*RKH_TRN_ACT_T)(void);
+#endif
+
+/**
+ *  \brief
+ *  Guard.
+ *
+ *	A guard is a boolean condition that returns a true (RKH_GTRUE) or
+ *	false (RKH_GFALSE) value that controls whether or not a transition
+ *	is taken following the receipt of a triggering event. A transition
+ *	with a guard is only take if the triggering event occurs and the
+ *	guard evaluates to true. As long as the guard evaluated to false,
+ *	the triggering event would be discarded and the transition would
+ *	not be taken.
+ *	Each condition connector can have one special branch with a guard
+ *	labeled rkh_sm_else, which is taken if all the guards on the other
+ *	branches are false.
+ *  A guard function takes the state machine pointer and the event
+ *  pointer as arguments.
+ *  These arguments are optional, thus they could be eliminated in
+ *  compile-time by means of \b RKH_CFG_SMA_GRD_ARG_EVT_EN and
+ *  \b RKH_CFG_SMA_GRD_ARG_SMA_EN.
+ *
+ *  \note
+ *  This callback is referenced from RKH_BRANCH() macro.
+ */
+
+#if (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+
+    typedef rbool_t (*RKH_GUARD_T)(const RKH_SM_T *me,
+                                   RKH_EVT_T *pe);
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_DISABLED)
+    typedef rbool_t (*RKH_GUARD_T)(RKH_EVT_T *pe);
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+    typedef rbool_t (*RKH_GUARD_T)(const RKH_SM_T *me);
+#else
+    typedef rbool_t (*RKH_GUARD_T)(void);
+#endif
+
+/**
+ *  \brief
+ *  Maintains the basic information of a state.
+ */
+struct RKH_BASE_T
+{
+    /**
+     *  \brief
+     *  State type.
+     *
+     *	Contains the type of a particular state and can have
+     *	the following values:
+     *
+     *	- \b RKH_COMPOSITE:     composite state.
+     *	- \b RKH_BASIC:         basic state.
+     *	- \b RKH_CHOICE:        choice pseudostate.
+     *	- \b RKH_CONDITIONAL:   conditional pseudostate.
+     *	- \b RKH_SHISTORY:      shadow history pseudostate.
+     *	- \b RKH_DHISTORY:      deep history pseudostate.
+     */
+    ruint type;
+
+    /**
+     *  \brief
+     *  Name of state or pseudostate.
+     *
+     *  Pointer to an ASCII string (NULL terminated) to assign a name to the
+     *	state object or pseudostate object. The name can be displayed by
+     *	debuggers or by Trazer.
+     */
+#if R_TRC_AO_NAME_EN == RKH_ENABLED
+    const char *name;
+#endif
+};
+
+/**
+ *  \brief
+ *  Describes the state transition.
+ *
+ *  Transitions represent the response of a state machine to events.
+ *  Any event that is not explicitly listed as causing an event to occur
+ *  in a given state is quietly discarded should it occur.
+ */
+struct RKH_TR_T
+{
+    /**
+     *  \brief
+     *  Triggering event.
+     */
+    RKH_SIG_T event;
+
+    /**
+     *  \brief
+     *	Points to guard function.
+     */
+    RKH_GUARD_T guard;
+
+    /**
+     *  \brief
+     *  Points to transition action.
+     */
+    RKH_TRN_ACT_T action;
+
+    /**
+     *  \brief
+     *  Points to target state.
+     */
+    RKHROM void *target;
+};
+
+/**
+ *	\brief
+ *  Describes the common properties of regular states (basic, composite,
+ *  and submachine).
+ */
+struct RKH_ST_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *	Points to entry action.
+     */
+    RKH_ENT_ACT_T enter;
+
+    /**
+     *  \brief
+     *	Points to exit action.
+     */
+    RKH_EXT_ACT_T exit;
+
+    /**
+     *  \brief
+     *	Points to state's parent.
+     */
+    RKHROM RKH_ST_T *parent;
+#endif
+};
+
+/**
+ *	\brief
+ *  Describes a basic state.
+ */
+struct RKH_SBSC_T
+{
+    RKH_ST_T st;
+
+    /**
+     *  \brief
+     *	Points to state transition table.
+     */
+    RKHROM RKH_TR_T *trtbl;
+
+    /**
+     *  \brief
+     *	Points to event preprocessor.
+     *
+     *	Aditionally, by means of single inheritance in C it could be
+     *	used as state's abstract data.
+     *	Aditionally, implementing the single inheritance in C is very
+     *	simply by literally embedding the base type, RKH_PPRO_T in
+     *	this case, as the first member of the derived structure.
+     *
+     *	This argument is optional, thus it could be declared as NULL.
+     *
+     *	Example:
+     *
+     *  \code
+     *	static
+     *	RKH_SIG_T
+     *	preprocessor(RKH_EVT_T *pe)
+     *	{
+     *		...
+     *	}
+     *
+     *	typedef struct
+     *	{
+     *		RKH_PPRO_T prepro;  // extend the RKH_PPRO_T class
+     *		unsigned min:4;
+     *		unsigned max:4;
+     *		char *buff;
+     *	} SDATA_T;
+     *
+     *	static const SDATA_T option = {preprocessor, 4, 8, token1};
+     *
+     *	RKH_CREATE_BASIC_STATE(S111, set_x_1,
+     *						   NULL, &S11, preprocessor);
+     *	RKH_CREATE_BASIC_STATE(S22, set_x_4,
+     *						   NULL, &S2, (RKH_PPRO_T*)&option);
+     * \endcode
+     */
+#if RKH_CFG_SMA_PPRO_EN == RKH_ENABLED
+    RKH_PPRO_T prepro;
+#endif
+};
+
+/**
+ *	\brief
+ *  Describes a composite state.
+ */
+struct RKH_SCMP_T
+{
+    RKH_ST_T st;
+
+    /**
+     *  \brief
+     *	Points to state transition table.
+     */
+    RKHROM RKH_TR_T *trtbl;
+
+    /**
+     *  \brief
+     *	Points to event preprocessor.
+     *
+     *	Aditionally, by means of single inheritance in C it could be
+     *	used as state's abstract data.
+     *	Aditionally, implementing the single inheritance in C is very
+     *	simply by literally embedding the base type, RKH_PPRO_T in
+     *	this case, as the first member of the derived structure.
+     *
+     *	This argument is optional, thus it could be declared as NULL.
+     *
+     *	Example:
+     *
+     *  \code
+     *	static
+     *	RKH_SIG_T
+     *	preprocessor( RKH_EVT_T *pe )
+     *	{
+     *		...
+     *	}
+     *
+     *	typedef struct
+     *	{
+     *		RKH_PPRO_T prepro;  // extend the RKH_PPRO_T class
+     *		unsigned min:4;
+     *		unsigned max:4;
+     *		char *buff;
+     *	} SDATA_T;
+     *
+     *	static const SDATA_T option = { preprocessor, 4, 8, token1 };
+     *
+     *	RKH_CREATE_BASIC_STATE( S111, set_x_1,
+     *							NULL, &S11, preprocessor );
+     *	RKH_CREATE_BASIC_STATE( S22, set_x_4,
+     *							NULL, &S2, (RKH_PPRO_T*)&option );
+     * \endcode
+     */
+#if RKH_CFG_SMA_PPRO_EN == RKH_ENABLED
+    RKH_PPRO_T prepro;
+#endif
+
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *	Points to state's default child.
+     */
+    RKHROM void *defchild;
+
+    /**
+     *  \brief
+     *  Points to state's initial action.
+     */
+    RKH_INIT_ACT_T initialAction;
+
+    /**
+     *  \brief
+     *	Points to state's history.
+     */
+#if defined(RKH_HISTORY_ENABLED)
+    RKHROM RKH_SHIST_T *history;
+#endif
+#endif
+};
+
+/**
+ *	\brief
+ *  Describes a final state.
+ */
+struct RKH_FINAL_T
+{
+    /**
+     *  \note
+     *  A final state has neither exit behavior nor entry behavior.
+     */
+    RKH_ST_T st;
+
+    /**
+     *  \note
+     *	A final state cannot have any outgoing transitions.
+     */
+    RKHROM RKH_TR_T *trtbl;
+
+    /**
+     *  \note
+     *	A final state cannot have any outgoing transitions.
+     */
+#if RKH_CFG_SMA_PPRO_EN == RKH_ENABLED
+    RKH_PPRO_T prepro;
+#endif
+};
+
+/**
+ *  \brief
+ *  Describes the exit point connection.
+ */
+#if defined(RKH_SUBMACHINE_ENABLED)
+struct RKH_EXPCN_T
+{
+    /**
+     *  \brief
+     *  Points to transition action.
+     */
+    RKH_TRN_ACT_T action;
+
+     /**
+     *  \brief
+     *  Points to target state.
+     */
+    RKHROM void *target;
+};
+
+/**
+ *  \brief
+ *  Describes the entry point connection.
+ */
+struct RKH_ENPCN_T
+{
+    /**
+     *  \brief
+     *  Points to transition action.
+     */
+    RKH_TRN_ACT_T action;
+
+    /**
+     *  \brief
+     *  Points to target state.
+     */
+    RKHROM void *target;
+};
+
+/**
+ *	\brief
+ *  Describes a submachine state.
+ *
+ *  A submachine state is a kind of a state that actually refers to
+ *  another defined state machine.
+ *  A submachine state is logically equivalent to the insertion of the
+ *  referenced state machine as a composite state in the place of
+ *  the submachine state. Consequently, every entrance to a submachine
+ *  state is equivalent to the corresponding entrance to the inserted
+ *  (referenced) composite state. In particular, it can be entered
+ *  thruough its initial pseudostate (as any other composite state), or
+ *  through one of its entry points.
+ *
+ *  Similary, every exit from a submachine state is equivalent to the
+ *  corresponding exit from the inserted composite state. It can be exited
+ *  through one of its exit points. When it is exited through its exit point
+ *  the effect of the transition targeting the exit point is executed first,
+ *  followed by the exit behavior of the composite state.
+ *
+ *  The entry, exit, and behavior actions and internal transitions are
+ *  defined as part of the state. Submachine state is a decomposition
+ *  mechanism that allows factoring of common behaviors and their reuse.
+ *
+ *  The purpose od defining submachine states is to decompose and localize
+ *  repetitive parts because the same state machine can be referenced from
+ *  more than one submachine state.
+ *
+ *	The diagram in following figure shows a fragment from a state machine
+ *	diagram in which a submachine state (the \c SB) is referenced.
+ *
+ *	\anchor fig_sbm1
+ *	\image html sbm1.png "Submachine state"
+ *
+ *	In the above example, the transition triggered by event \c TWO will
+ *	terminate on entry point \c ENS12 of the \c SB state machine.
+ *	The \c ONE transition implies taking of the default transition of the
+ *	\c SB and executes the \c act5() action. The transition emanating from
+ *	the \c EX1S12 exit point of the submachine will execute the \c act1()
+ *	behavior in addition to what is executed within the \c SB state machine.
+ *	Idem transition emanating from the \c EX2S12.
+ *	This transition must have been triggered within the \c SB state machine.
+ *	Finally, the transition emanating from the edge of the submachine state
+ *	is triggered by event \c THREE.
+ *
+ *	The following figure is an example of a state machine \c SB defined with
+ *	two exit points, \c EXPNT1 and \c EXPNT2, and one entry point \c ENPNT.
+ *
+ *	\anchor fig_sbm2
+ *	\image html sbm2.png "State machine with two exit points and one entry
+ *point"
+ *
+ *	In the following figure the state machine shown above is referenced twice in
+ *	a submachine state \c S12 and \c S2.
+ *
+ *	\anchor fig_sbm3
+ *	\image html sbm3.png "Submachine state with usage of exit and entry points"
+ */
+struct RKH_SSBM_T
+{
+    RKH_ST_T st;
+
+    /**
+     *  \brief
+     *	Points to state transition table.
+     */
+    RKHROM RKH_TR_T *trtbl;
+
+    /**
+     *  \brief
+     *	Points to state transition table.
+     */
+    RKHROM RKH_EXPCN_T *exptbl;
+
+    /**
+     *  \brief
+     *	Points to submachine object.
+     */
+    RKHROM RKH_RSM_T *sbm;
+};
+
+/**
+ *	\brief
+ *  Describes a (referenced) submachine state machine.
+ */
+struct RKH_RSM_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+    /**
+     *  \brief
+     *	Points to state's default child.
+     */
+    RKHROM void *defchild;
+
+    /**
+     *  \brief
+     *  Points to initializing action (optional).
+     *
+     *  The function prototype is defined as RKH_TRN_ACT_T. This argument is
+     *  optional, thus it could be declared as NULL.
+     */
+    RKH_TRN_ACT_T iaction;
+
+    /**
+     *  \brief
+     *	Points to RAM memory location which stores
+     *	the dynamic parent.
+     */
+    RKHROM RKH_ST_T * *dyp;
+};
+
+/**
+ *  \brief
+ *  Describes the entry point pseudostate.
+ *
+ *  An entry pseudostate is used to join an external transition terminating
+ *  on that entry point to an internal transition emanating from that entry
+ *  point.
+ *  The main purpose of such entry and exit points is to execute the state
+ *  entry and exit actions respectively in between the actions that are
+ *  associated with the joined transitions.
+ */
+struct RKH_SENP_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+    /**
+     *  \brief
+     *	Points to entry point connection.
+     */
+    RKHROM RKH_ENPCN_T *enpcn;
+
+    /**
+     *  \brief
+     *	Points to state's parent (submachine state).
+     */
+    RKHROM RKH_ST_T *parent;
+};
+
+/**
+ *  \brief
+ *  Describes the exit point pseudostate.
+ *
+ *  An exit pseudostate is used to join an internal transition terminating on
+ *  that exit point to an external transition emanating from that exit point.
+ *  The main purpose of such entry and exit points is to execute the state
+ *  entry and exit actions respectively in between the actions that are
+ *  associated with the joined transitions.
+ */
+struct RKH_SEXP_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+    /**
+     *  \brief
+     *	Index of exit point table.
+     */
+    rui8_t ix;
+
+    /**
+     *  \brief
+     *	Points to state's parent (referenced submachine).
+     */
+    RKHROM RKH_RSM_T *parent;
+};
+#endif
+
+/**
+ *  \brief
+ *  Describes the conditional pseudostate.
+ */
+#if defined(RKH_CHOICE_OR_CONDITIONAL_ENABLED)
+struct RKH_SCOND_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+    /**
+     *  \brief
+     *	Points to branch table.
+     */
+    RKHROM RKH_TR_T *trtbl;
+};
+#endif
+
+/**
+ *  \brief
+ *  Describes the choice pseudostate.
+ */
+#if defined(RKH_CHOICE_ENABLED)
+struct RKH_SCHOICE_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+    /**
+     *  \brief
+     *	Points to branch table.
+     */
+    RKHROM RKH_TR_T *trtbl;
+};
+#endif
+
+/**
+ *  \brief
+ *  Describes the history pseudostate
+ *
+ *  It can be either be shallow or deep.
+ */
+struct RKH_SHIST_T
+{
+    /**
+     *  \brief
+     *	Maintains the basic information of state.
+     */
+    RKH_BASE_T base;
+
+    /**
+     *  \brief
+     *	Points to state's parent.
+     */
+    RKHROM RKH_ST_T *parent;
+
+    /**
+     *  \brief
+     *	Points to RAM memory location which stores
+     *	the state's history.
+     */
+    RKHROM RKH_ST_T **target;
+    
+    /**
+     *  \brief
+     *  History default transition.
+     */
+    RKHROM RKH_TR_T trn;
+};
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Inits a previously created state machine calling its initializing action.
+ *
+ *  \param[in] me  pointer to previously created state machine.
+ *
+ *  \ingroup apiSM
+ */
+void rkh_sm_init(RKH_SM_T *me);
+
+/**
+ *  \brief
+ *	Executes a state machine in a run-to-completation (RTC) model.
+ *
+ *	In this model, before the system handles a new event it can store it
+ *	until the previous event has completed processing. This model is
+ *	called run to completion or RTC. Thus, the system processes events in
+ *	discrete, indivisible RTC steps. An RTC step is the period of time in
+ *	which events are accepted and acted upon. Processing an event always
+ *	completes within a single model step, including exiting the source
+ *	state, executing any associated actions, and entering the target state.
+ *  The RKH implementation preserves the transition sequence imposed by
+ *  Harel's Statechart and UML. Specifically, the implemented transition
+ *  sequence is as follows:
+ *
+ *  - Execute exit actions of the source state.
+ *  - Execute the transition actions.
+ *  - Execute entry actions of the target state.
+ *
+ *  Here now are the details of the main part of this algorithm
+ *  (rkh_sm_dispatch()), in which an event is processed by the statechart.
+ *
+ *  \li	Determine the compound transition (CT) that will fire in response
+ *      to the event: traverse the states in the active configuration from
+ *      lowest states in the hierarchy upwards. A CT is enabled if its
+ *      trigger is the dispatched event, and the guard evaluates to true.
+ *      Once an enabled transition is found with a given source state stop
+ *      traversing the states that are higher than this state in the
+ *      hierarchy.
+ *  \li	Perform the CT that we found should fire.
+ *      For each transition do:
+ *      -	Update histories of exited states.
+ *      -   Perform the exit actions of the exited states according to the
+ *          order states are exited, from low state to high state.
+ *      -	Perform the actions on the CT sequentially according to the
+ *          order in which they are written on the transition, from the
+ *          action closest to source state to the action closest to target
+ *          state.
+ *      -	Perform the entry actions of the entered states according to
+ *          the order states are entered, from high state to low state.
+ *      -	For lowest level states that were entered, which are not basic
+ *          states, perform default transitions (recursively) until the
+ *          statechart reaches basic states.
+ *      -	Update the active configuration.
+ *  \li	Wrap up: once a stable configuration is reached, the reaction to the
+ *      event is completed, control returns to the dispatcher and new events
+ *      can be dispatched.
+ *
+ *  \param[in] me   pointer to previously created state machine application.
+ *	\param[in] e	pointer to arrived event. It's used as state-machine's
+ *					input alphabet.
+ *
+ *	\return         Result #RKH_RCODE_T code.
+ *
+ *  \ingroup apiSM
+ */
+ruint rkh_sm_dispatch(RKH_SM_T *me, RKH_EVT_T *e);
+
+/**
+ *  \brief
+ *  Initializes the attributes of the state machine instance.
+ *
+ *  \param[in] me  pointer to previously created state machine.
+ *
+ *  \note
+ *  The initializer assumes that memory has previously been allocated for the 
+ *  object (either statically or dynamically).
+ *
+ *  \ingroup apiSM
+ */
+void rkh_sm_ctor(RKH_SM_T *me);
+
+/**
+ *  \brief
+ *  Erase the history of a state. It can be a shallow or deep history.
+ *
+ *  \param[in] h    pointer to history pseudostate.
+ *
+ *  \ingroup apiSM
+ */
+void rkh_sm_clear_history(RKHROM RKH_SHIST_T *h);
+
+#if (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+rbool_t rkh_sm_else(const RKH_SM_T *sma, RKH_EVT_T *pe);
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_DISABLED)
+rbool_t rkh_sm_else(RKH_EVT_T *pe);
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+rbool_t rkh_sm_else(const RKH_SM_T *sma);
+#else
+rbool_t rkh_sm_else(void);
+#endif
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkht.h ./rkh/inc/rkht.h
--- a_qSC69Z/rkh/inc/rkht.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkht.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,103 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkht.h
+ * 	\brief 		ARM Cortex-M MCU's, LPCXpresso port
+ *  \ingroup    port
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  Daba  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ *  DaBa  Dario Baliña       dariosb@gmail.com
+ */
+
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHT_H__
+#define __RKHT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/*
+ * 	The RKH uses a set of integer quantities. That maybe machine or 
+ * 	compiler dependent.
+ */
+
+typedef signed char 	ri8_t;
+typedef signed short 	ri16_t;
+typedef signed long		ri32_t;
+typedef unsigned char 	rui8_t;
+typedef unsigned short 	rui16_t;
+typedef unsigned long	rui32_t;
+
+/*
+ * 	The 'ruint' and 'rint' will normally be the natural size for a 
+ * 	particular machine. These types designates an integer type that is 
+ * 	usually fastest to operate with among all integer types.
+ */
+
+typedef unsigned int	ruint;
+typedef signed int		rint;
+
+/*
+ * 	Boolean data type and constants.
+ *
+ * 	\note
+ * 	The true (RKH_TRUE) and false (RKH_FALSE) values as defined as macro 
+ * 	definitions in \c rkhdef.h file.
+ */
+
+typedef unsigned int	rbool_t;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ File footer ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtmr.h ./rkh/inc/rkhtmr.h
--- a_qSC69Z/rkh/inc/rkhtmr.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtmr.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,465 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtmr.h
+ *  \brief      Platform - independent interface for supporting software timer
+ *              services.
+ *
+ *  \ingroup    apiTmr
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiTmr Timer
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTMR_H__
+#define __RKHTMR_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if defined(RKH_USE_TRC_SENDER)
+/**
+ *  \brief
+ *  Invoke the system clock tick processing rkh_tmr_tick().
+ *
+ *  This macro is the recommended way of invoke the clock tick processing,
+ *  because it provides the vital information for software tracing and
+ *  avoids any overhead when the tracing is disabled.
+ *
+ *  \param[in] _sender	pointer to the sender object. Typically
+ *                      RKH_TIM_TICK() will be called from an interrupt,
+ *                      in which case it would create a unique object
+ *                      just to unambiguously identify the ISR as the
+ *                      sender of the time events.
+ *	\sa
+ *	rkh_tmr_tick().
+ *
+ *	\ingroup apiBSPHook
+ */
+    #define RKH_TIM_TICK(_sender)     rkh_tmr_tick(_sender)
+#else
+    #define RKH_TIM_TICK(dummy_)      rkh_tmr_tick()
+#endif
+
+/**
+ *  \brief
+ *	Initializes the previously allocated timer structure RKH_TMR_T.
+ *
+ *  A timer is declared with the RKH_TMR_T data type and is defined with
+ *  the RKH_TMR_INIT() service.
+ *	The timer is initialized in a non-active state (stopped). In this
+ *	case, a subsequent start service call is necessary to get the timer
+ *	actually started.
+ *  The following listing creates an application timer that executes
+ *  "my_timer_hook" and send the event signal "TOUT" to "pwr" SMA after
+ *  100 timer-ticks.
+ *
+ *	\param[in] t_	pointer to previously allocated timer structure. Any
+ *					software module intending to install a software timer
+ *					must first allocate a timer structure RKH_TMR_T.
+ *	\param[in] e_	event to be directly posted (using the FIFO policy)
+ *					into the event queue of the target agreed state
+ *					machine application at the timer expiration.
+ *	\param[in] th_  hook function to be called at the timer expiration.
+ *					This argument is optional, thus it could be declared
+ *					as NULL or eliminated in compile-time with
+ *					RKH_CFG_TMR_HOOK_EN.
+ *
+ *	\note
+ *	See RKH_TMR_T structure for more information.
+ *
+ *  \usage
+ *  \code
+ *	#define MY_TICK				100
+ *
+ *	static RKH_TMR_T my_timer;
+ *	static RKH_ROM_STATIC_EVENT( e_timer, TOUT );
+ *
+ *  ...
+ *  RKH_TMR_INIT( &my_timer, &e_timer, my_timer_hook );
+ *  RKH_TMR_ONESHOT( &my_timer, pwr, MY_TICK );
+ *  \endcode
+ *
+ *  \ingroup apiTmr
+ */
+#if RKH_CFG_TMR_HOOK_EN == RKH_ENABLED
+    #define RKH_TMR_INIT(t_, e_, th_) \
+        rkh_tmr_init_((t_), (e_), (th_))
+#else
+    #define RKH_TMR_INIT(t_, e_, th_) \
+        rkh_tmr_init_((t_), (e_))
+#endif
+
+/**
+ *  \brief
+ *  Start a timer as one-shot timer.
+ *
+ *  This operation installs a previously created timer into	the
+ *  timer-handling facility. The timer begins running at the completion of
+ *  this operation. The timer won't be re-started automatically.
+ *  The following listing creates an application timer that executes
+ *  "my_timer_hook" and send the event signal "TOUT" to "pwr" SMA after 100
+ *  timer-ticks.
+ *
+ *	\param[in] t	    pointer to previously created timer structure.
+ *	\param[in] sma	    state machine application (SMA) that receives the timer
+ *					    event.
+ *  \param[in] itick    number of ticks for timer expiration.
+ *
+ *  \usage
+ *  \code
+ *	#define MY_TICK				100
+ *
+ *	static RKH_TMR_T my_timer;
+ *	static RKH_ROM_STATIC_EVENT( e_timer, TOUT );
+ *
+ *  ...
+ *  RKH_TMR_INIT( &my_timer, e_timer, my_timer_hook );
+ *  RKH_TMR_ONESHOT( &my_timer, pwr, MY_TICK );
+ *  \endcode
+ *
+ *  \ingroup apiTmr
+ */
+#define RKH_TMR_ONESHOT(t, sma, itick) \
+    (t)->period = 0; \
+    rkh_tmr_start(t, sma, itick)
+
+/**
+ *  \brief
+ *  Start a timer as periodic timer.
+ *
+ *  This operation installs a previously created timer into	the
+ *  timer-handling facility. The timer begins running at the completion of
+ *  this operation. Once the timeout will expire the timer will be
+ *  re-started (re-triggered) again automatically.
+ *  The following listing creates an application timer that executes
+ *  "my_timer_hook" and send the event signal "TOUT" to "pwr" SMA after 100
+ *  timer-ticks initially and then after every 25 timer-ticks.
+ *
+ *	\param[in] t		pointer to previously created timer structure.
+ *	\param[in] sma		state machine application (SMA) that receives the timer
+ *					    event.
+ *  \param[in] itick    number initial of ticks for timer expiration.
+ *  \param[in] per	    number of ticks for all timer expirations after the 
+ *                      first (expiration period). A zero for this parameter 
+ *                      makes the timer a one-shot timer, otherwise, for 
+ *                      periodic timers, any value in range.
+ *
+ *  \usage
+ *  \code
+ *	#define MY_TICK			100
+ *
+ *	static RKH_TMR_T my_timer;
+ *	static RKH_ROM_STATIC_EVENT( e_timer, TOUT );
+ *
+ *  ...
+ *  RKH_TMR_INIT( &my_timer, &e_timer, my_timer_hook );
+ *  RKH_TMR_PERIODIC( &my_timer, pwr, MY_TICK, MY_TICK/4 );
+ *  \endcode
+ *
+ *  \ingroup apiTmr
+ */
+#define RKH_TMR_PERIODIC(t, sma, itick, per) \
+    (t)->period = (per); \
+    rkh_tmr_start((t), (sma), (itick))
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  \brief
+ *  The prototype of callback function (hook) to call when the timer expires.
+ *
+ *  \param[in] t		pointer to elapsed timer (RKH_TMR_T data structure).
+ */
+typedef void (*RKH_THK_T)(void *t);
+
+/**
+ *  \brief
+ *  This data type defines the dynamic range of the time delays measured in
+ *  clock ticks (maximum number of ticks).
+ *
+ *	The valid values [in bits] are 8, 16 or 32. Default is 8. This type is
+ *	configurable via the preprocessor switch RKH_CFG_TMR_SIZEOF_NTIMER.
+ */
+#if RKH_CFG_TMR_SIZEOF_NTIMER == 8
+typedef rui8_t RKH_TNT_T;
+#elif RKH_CFG_TMR_SIZEOF_NTIMER == 16
+typedef rui16_t RKH_TNT_T;
+#elif RKH_CFG_TMR_SIZEOF_NTIMER == 32
+typedef rui32_t RKH_TNT_T;
+#else
+typedef rui8_t RKH_TNT_T;
+#endif
+
+/**
+ *  \brief
+ *  Defines the data structure into which the performance information for
+ *  software timers is stored.
+ *
+ *	The application must allocate an RKH_TINFO_T data structure used to
+ *	receive information. The performance information is available during
+ *	run-time for each of the RKH services. This can be useful in determining
+ *	whether the application is performing properly, as well as helping to
+ *	optimize the application.
+ */
+typedef struct RKH_TINFO_T
+{
+    rui16_t nexp;       /** # of expirations */
+    rui16_t nstart;     /**	# of start requests */
+    rui16_t nstop;      /**	# of stop requests */
+} RKH_TINFO_T;
+
+typedef struct RKH_TMR_T RKH_TMR_T;
+
+/**
+ *  \brief
+ *  Defines the data structure used to maintain information that allows the
+ *  timer-handling facility to update and expire software timers.
+ *
+ *  RKH software timers enables to execute application C functions and/or
+ *  send an event to application state machine (SMA) at specific intervals of
+ *  time. It can also set an application timer to expire only once. This type
+ *  of timer is called a one-shot timer, while repeating interval timers are
+ *  called periodic timers. Each application timer is a public resource.
+ *	Time intervals are measured by periodic timer interrupts. Each timer
+ *	interrupt is called a timer-tick. The actual time between timer-ticks is
+ *	specified by the application. On the other hand, application timers
+ *	execute in the order in which they become active.
+ *
+ *	\note
+ *  RKH prohibits an application from explicitly modifying the RKH_TMR_T
+ *  structure. The RKH's timer structures can be located anywhere in memory,
+ *  but it is most common to make it a global structure by defining it
+ *  outside the scope of any function.
+ *  An RKH timer is created when an application timer is declared with the
+ *  RKH_TMR_T data type. The following listing declares "my_timer" timer:
+ *
+ *  \code
+ *  RKH_TMR_T my_timer;
+ *  \endcode
+ *
+ *  \ingroup apiTmr
+ */
+struct RKH_TMR_T
+{
+    /**
+     *  Points to timer event.
+     */
+    RKH_EVT_T *evt;
+
+    /**
+     *  Points to next timer structure in the doubly linked list.
+     */
+    RKH_TMR_T *tnext;
+
+    /**
+     *  \brief
+     *  State machine application (a.k.a Active Object) that receives the
+     *  timer event.
+     */
+    const struct RKH_SMA_T *sma;
+
+    /**
+     *  \brief
+     *  Tick down-counter.
+     */
+    RKH_TNT_T ntick;
+
+    /**
+     *  \brief
+     *  Number of ticks for all timer expirations after the first (expiration
+     *  period). A zero for this parameter makes the timer a one-shot timer,
+     *  otherwise, for periodic timers, any value in range.
+     */
+    RKH_TNT_T period;
+
+    /**
+     *  A non-zero value indicates that the timer is linked.
+     */
+    rui8_t used;
+
+    /**
+     *	Hook function to call when the timer expires. This member is optional,
+     *	thus it could be declared as NULL or eliminated in compile-time with
+     *	RKH_CFG_TMR_HOOK_EN.
+     */
+#if RKH_CFG_TMR_HOOK_EN == RKH_ENABLED
+    RKH_THK_T timhk;
+#endif
+
+    /**
+     *  Performance information. This member is optional, thus it could be
+     *  eliminated in compile-time with RKH_CFG_TMR_GET_INFO_EN.
+     */
+#if RKH_CFG_TMR_GET_INFO_EN == RKH_ENABLED
+    RKH_TINFO_T info;
+#endif
+};
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+#if RKH_CFG_TMR_HOOK_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *	Initializes the previously allocated timer structure RKH_TMR_T.
+     */
+    void rkh_tmr_init_(RKH_TMR_T *t, const RKH_EVT_T *e, RKH_THK_T thk);
+#else
+    void rkh_tmr_init_(RKH_TMR_T *t, const RKH_EVT_T *e);
+#endif
+
+/**
+ *  \brief
+ *  Start a timer.
+ *
+ *  This operation installs a previously created timer into	the
+ *  timer-handling facility. The timer begins running at the completion of
+ *  this operation.
+ *
+ *	\param[in] t		pointer to previously created timer structure.
+ *	\param[in] sma		state machine application (SMA) that receives the 
+ *	                    timer event.
+ *  \param[in] itick    number of ticks for timer expiration.
+ *
+ *  \ingroup apiTmr
+ */
+void rkh_tmr_start(RKH_TMR_T *t,   const struct RKH_SMA_T *sma,
+                   RKH_TNT_T itick);
+
+/**
+ *  \brief
+ *	Stops a running timer.
+ *
+ *	This operation stops a timer by removing the currently running timer from
+ *	the timer-handling facility. If the timer is already stopped, this
+ *	service has no effect.
+ *
+ *	\param[in] t		pointer to previously created timer structure.
+ *
+ *  \ingroup apiTmr
+ */
+void rkh_tmr_stop(RKH_TMR_T *t);
+
+/**
+ *  \brief
+ *  Retrieves performance information for a particular software timer.
+ *
+ *	The user application must allocate an RKH_TINFO_T data structure used
+ *	to receive data. The performance information is available during run-time
+ *	for each of the RKH services. This can be useful in determining whether
+ *	the application is performing properly, as well as helping to optimize
+ *	the application. This information provides a "snapshot" a particular
+ *	instant in time, i.e., when the service is invoked.
+ *
+ *	\param[in] t		pointer to previously created timer structure.
+ *  \param[in] info		pointer to the buffer into which the performance
+ *                      information will be copied by reference.
+ *
+ *  \note
+ *  See RKH_TINFO_T structure for more information. This function is
+ *  optional, thus it could be eliminated in compile-time with
+ *  RKH_CFG_TMR_GET_INFO_EN.
+ *
+ *  \ingroup apiTmr
+ */
+void rkh_tmr_get_info(RKH_TMR_T *t, RKH_TINFO_T *info);
+
+/**
+ *  \brief
+ *  Clear performance information for a particular software timer.
+ *
+ *	\param[in] t		pointer to previously created timer structure.
+ *
+ *  \note
+ *  See RKH_TINFO_T structure for more information. This function is
+ *  optional, thus it could be eliminated in compile-time with
+ *  RKH_CFG_TMR_GET_INFO_EN.
+ *
+ *  \ingroup apiTmr
+ */
+void rkh_tmr_clear_info(RKH_TMR_T *t);
+
+#if defined(RKH_USE_TRC_SENDER)
+/**
+ *  \brief
+ *  Keep tracks and updates the started timers.
+ *
+ *	Time intervals are measured by periodic timer interrupts. Each timer
+ *	interrupt is called a timer-tick. The actual time between timer-ticks
+ *	is specified by the application.
+ *  This function must be placed where will be incrementing the system
+ *  tick. Normally this function is placed in a timer ISR routine.
+ *  If one or more timers expires the assigned event is directly posted
+ *  into the state machine application (SMA) queue and associated hook
+ *  function is executed (if it's used). The expiration events of timers
+ *  that expire at the same time are executed in the order they were
+ *  started.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it. Instead, use #RKH_TIM_TICK() macro.
+ */
+void rkh_tmr_tick(const void *const sender);
+#else
+void rkh_tmr_tick(void);
+#endif
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtrc_define.h ./rkh/inc/rkhtrc_define.h
--- a_qSC69Z/rkh/inc/rkhtrc_define.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtrc_define.h	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,1298 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_define.h
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    apiTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTRC_DEF_H__
+#define __RKHTRC_DEF_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ * 	Specify the size of the trace event identification. The valid values 
+ * 	[in bits] are 8, 16 or 32. Default is 8. 
+ *
+ * 	\sa #RKH_TE_ID_T data type.
+ *
+ *  \note In the future releases, it should be defined in the configuration 
+ *  file of the RKH framework.
+ */
+#define RKH_CFG_TRC_SIZEOF_TE_ID        8
+
+#if RKH_CFG_TRC_SIZEOF_TE_ID == 8
+        #define RKH_TRC_TE_ID(teid) \
+            RKH_TRC_UI8(teid)
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 16
+        #define RKH_TRC_TE_ID(teid) \
+            RKH_TRC_UI16(teid)
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 32
+        #define RKH_TRC_TE_ID(teid) \
+            RKH_TRC_UI32(teid)
+#else
+        #define RKH_TRC_TE_ID(teid) \
+            RKH_TRC_UI8(teid)
+#endif
+
+/**
+ *  \brief
+ *  Test the state machine application (SMA) filter condition.
+ *
+ *  \param[in] prio		SMA priority.
+ *
+ *	\return
+ *  '1' (RKH_TRUE) if the SMA is not filtered, otherwise '0' (RKH_FALSE).
+ *
+ *	\note
+ *  This macro is internal to RKH and the user application should not call
+ *  it.
+ */
+#if RKH_CFG_TRC_RTFIL_SMA_EN == RKH_ENABLED
+    #define RKH_TRC_AO_ISOFF(prio) \
+            && rkh_trc_symFil_isoff(RKHFilterSma, (RKH_TRC_FSLOT)(prio))
+#else
+    #define RKH_TRC_AO_ISOFF(prio)
+#endif
+
+/**
+ */
+#define RKH_TRC_IS_RESERVED_SIG(sig) \
+    (sig == RKH_COMPLETION_EVENT) 
+    
+/**
+ *  \brief
+ *  Test the event signal filter condition.
+ *
+ *  \param[in] sig		event signal.
+ *
+ *	\return
+ *  '1' (RKH_TRUE) if the signal is not filtered, otherwise '0' (RKH_FALSE).
+ *
+ *	\note
+ *  This macro is internal to RKH and the user application should not call
+ *  it.
+ */
+#if RKH_CFG_TRC_RTFIL_SIGNAL_EN == RKH_ENABLED
+    #define RKH_TRC_SIG_ISOFF(sig) \
+            && (RKH_TRC_IS_RESERVED_SIG(sig) || \
+            rkh_trc_symFil_isoff(RKHFilterSignal, (RKH_TRC_FSLOT)(sig)))
+#else
+    #define RKH_TRC_SIG_ISOFF(sig)
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+#if RKH_CFG_TRC_SIZEOF_TE_ID == 8
+        #define RKH_NBITS_GROUP             3
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 16
+        #define RKH_NBITS_GROUP             8
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 32
+        #define RKH_NBITS_GROUP             8
+#else
+        #define RKH_NBITS_GROUP             3
+#endif
+
+#define RKH_NBIT_EVENT_PER_GROUP   (RKH_CFG_TRC_SIZEOF_TE_ID - \
+                                        RKH_NBITS_GROUP)
+#define RKH_TRC_MAX_GROUPS          RKH_BIT(RKH_NBITS_GROUP)
+#define RKH_MAX_NUM_TE_PER_GROUP    RKH_BIT(RKH_NBIT_EVENT_PER_GROUP)
+#define NGSH                        RKH_NBIT_EVENT_PER_GROUP
+#define RKH_GRP_MASK \
+        (RKH_TE_ID_T)((RKH_BIT(RKH_NBITS_GROUP) - 1) << \
+                       RKH_NBIT_EVENT_PER_GROUP)
+#define RKH_TE_MASK \
+        (RKH_TE_ID_T)(RKH_BIT(RKH_NBIT_EVENT_PER_GROUP) - 1)
+
+/**
+ *	Specify the maximum number of trace events, this number is direclty
+ *	related with the RKH_TE_<group>_<event> definitions. The smaller this 
+ *	number, the lower the RAM consumption.
+ *	See \c trceftbl table.
+ */
+#define RKH_TRC_MAX_EVENTS \
+        (RKH_MAX_NUM_TE_PER_GROUP * RKH_TRC_MAX_GROUPS)
+
+#if ((RKH_CFG_FWK_MAX_SMA & (8 - 1)) == 0)
+        /**
+         *  \brief
+         *  The size of trcsmaftbl[] (trace SMA filter table) depends on
+         *  #RKH_CFG_FWK_MAX_SMA (see rkhcfg.h).
+         */
+        #define RKH_TRC_MAX_SMA     (RKH_CFG_FWK_MAX_SMA / 8)
+#else
+        #define RKH_TRC_MAX_SMA     (RKH_CFG_FWK_MAX_SMA / 8 + 1)
+#endif
+
+#if ((RKH_CFG_FWK_MAX_SIGNALS & (8 - 1)) == 0)
+        /**
+         *  \brief
+         *  The size of trcsigftbl[] (trace signal filter table) depends on
+         *  #RKH_CFG_FWK_MAX_SIGNALS and #RKH_CFG_FWK_SIZEOF_EVT (see rkhcfg.h).
+         */
+        #define RKH_TRC_MAX_SIGNALS (RKH_CFG_FWK_MAX_SIGNALS / 8)
+#else
+        #define RKH_TRC_MAX_SIGNALS (RKH_CFG_FWK_MAX_SIGNALS / 8 + 1)
+#endif
+
+/**@{
+ *
+ *  \brief
+ *  Trace event offset.
+ *
+ *  The trace event ID is arranged as:
+ *
+ *  event number = | G | G | G | E | E | E | E | E |\n
+ *
+ *  G's:	group number.\n
+ *  E's:	event's group.\n
+ *
+ *  The lower 5 bits (E's) of the event ID are used to determine
+ *  the trace event, while the next three most significant bits
+ *  (G's) are used to determine the corresponding group.
+ *  Therefore, is able to define 8 groups and 32 events per group.
+ */
+#define RKH_MP_START                GRPLSH(RKH_TG_MP)
+#define RKH_QUE_START                GRPLSH(RKH_TG_QUE)
+#define RKH_SMA_START               GRPLSH(RKH_TG_SMA)
+#define RKH_SM_START                GRPLSH(RKH_TG_SM)
+#define RKH_TMR_START               GRPLSH(RKH_TG_TMR)
+#define RKH_FWK_START               GRPLSH(RKH_TG_FWK)
+#define RKH_USR_START               GRPLSH(RKH_TG_USR)
+#define RKH_UT_START                GRPLSH(RKH_TG_UT)
+/*@}*/
+
+/**@{
+ *  Max. number of used trace events in a particular group in octets, thus
+ *  the desired value must be divided by 8 (1 -> 8 events).
+ *  \note
+ *  Must be less than or equal to RKH_MAX_NUM_TE_PER_GROUP/8.
+ */
+#define RKH_MP_TTBL_RANGE           1
+#define RKH_QUE_TTBL_RANGE           1
+#define RKH_SMA_TTBL_RANGE          2
+#define RKH_SM_TTBL_RANGE           3
+#define RKH_TIM_TTBL_RANGE          1
+#define RKH_FWK_TTBL_RANGE          3
+#define RKH_USR_TTBL_RANGE          4
+#define RKH_UT_TTBL_RANGE           2
+/*@}*/
+
+/**
+ *  Defines the total number of trace events.
+ */
+#define RKH_TOT_NUM_TRC_EVTS \
+        (RKH_MP_TTBL_RANGE   + \
+         RKH_QUE_TTBL_RANGE   + \
+         RKH_SMA_TTBL_RANGE  + \
+         RKH_SM_TTBL_RANGE   + \
+         RKH_TIM_TTBL_RANGE  + \
+         RKH_FWK_TTBL_RANGE  + \
+         RKH_USR_TTBL_RANGE  + \
+         RKH_UT_TTBL_RANGE)
+
+/**
+ *  \brief
+ *  Defines the size of trace filter table according to RKH_TOT_NUM_TRC_EVTS
+ *  and RKH_TRC_MAX_EVENTS.
+ */
+#if (RKH_TOT_NUM_TRC_EVTS <= RKH_TOT_NUM_TRC_EVTS)
+        #define RKH_TRC_MAX_EVENTS_IN_BYTES     RKH_TOT_NUM_TRC_EVTS
+#else
+        #error  "rkhtrc.h, the total number of trace events represented"
+        #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#define RKH_MP_TTBL_OFFSET          0
+#define RKH_QUE_TTBL_OFFSET          (RKH_MP_TTBL_OFFSET + RKH_MP_TTBL_RANGE)
+#define RKH_SMA_TTBL_OFFSET         (RKH_QUE_TTBL_OFFSET + RKH_QUE_TTBL_RANGE)
+#define RKH_SM_TTBL_OFFSET          (RKH_SMA_TTBL_OFFSET + RKH_SMA_TTBL_RANGE)
+#define RKH_TIM_TTBL_OFFSET         (RKH_SM_TTBL_OFFSET + RKH_SM_TTBL_RANGE)
+#define RKH_FWK_TTBL_OFFSET         (RKH_TIM_TTBL_OFFSET + RKH_TIM_TTBL_RANGE)
+#define RKH_USR_TTBL_OFFSET         (RKH_FWK_TTBL_OFFSET + RKH_FWK_TTBL_RANGE)
+#define RKH_UT_TTBL_OFFSET          (RKH_USR_TTBL_OFFSET + RKH_USR_TTBL_RANGE)
+
+#define GRPLSH(grp) \
+        /*(RKH_TE_ID_T)(((grp) & (rui8_t)(RKH_TRC_MAX_GROUPS - 1)) << NGSH)*/ \
+        (((grp) & (RKH_TRC_MAX_GROUPS - 1)) << NGSH)
+
+#define EXTE(te, grp) \
+        (RKH_TE_ID_T)((te) - GRPLSH(grp))
+
+#define GETGRP(e) \
+        (RKH_TG_T)(((e) & RKH_GRP_MASK) >> RKH_NBIT_EVENT_PER_GROUP)
+#define GETEVT(e) \
+        (RKH_TE_ID_T)((e) & RKH_TE_MASK)
+
+#define ECHANGE                     0
+#define EUNCHANGE                   1
+
+/**
+ *  \brief
+ *  Emit or suppress tracing for all groups and events.
+ */
+#define RKH_TRC_ALL_GROUPS      RKH_TG_NGROUP
+
+/**
+ *  \brief
+ *  Emit or suppress all trace events.
+ */
+#define RKH_TRC_ALL_EVENTS      RKH_TE_NEVENT
+
+/**
+ *  \brief
+ *  Emit or supress tracing for all signal/active objects.
+ */
+#define RKH_TRC_SET_ALL(mode_) \
+        ((mode_) | RKH_TRC_ALL_FILTERS)
+
+#define RKH_TRC_ALL_FILTERS     0x80
+#define RKH_FILTER_MODE_MASK    ~RKH_TRC_ALL_FILTERS
+
+/** x-ored byte for stuffing a single byte */
+#define RKH_XOR     0x20
+
+/** flag byte, used as a trace event delimiter */
+#define RKH_FLG     0x7E
+
+/** escape byte stuffing a single byte */
+#define RKH_ESC     0x7D
+
+/* --- RKH group of trace events ------------------------------------------- */
+/** \brief  Memory Pool group (MP) */
+#define RKH_TG_MP           0
+
+/** \brief  Reference Queue group (QUE) */
+#define RKH_TG_QUE           1
+
+/** \brief  State Machine Application group (SMA) */
+#define RKH_TG_SMA          2
+
+/** \brief  State Machine group (SM) */
+#define RKH_TG_SM           3
+
+/** \brief  Timer group (TIM) */
+#define RKH_TG_TMR          4
+
+/** \brief  Framework RKH group (FWK) */
+#define RKH_TG_FWK          5
+
+/** \brief  User group (USR) */
+#define RKH_TG_USR          6
+
+/** \brief  Unit test harness group (UT) */
+#define RKH_TG_UT           7
+
+/** \brief  Number of trace groups */
+#define RKH_TG_NGROUP       8
+
+/* --- Memory Pool events (MP group) --------------------------------------- */
+/** \copybrief RKH_TR_MP_INIT */
+#define RKH_TE_MP_INIT          RKH_MP_START
+/** \copybrief RKH_TR_MP_GET */
+#define RKH_TE_MP_GET           (RKH_TE_MP_INIT + 1)
+/** \copybrief RKH_TR_MP_PUT */
+#define RKH_TE_MP_PUT           (RKH_TE_MP_GET + 1)
+#define RKH_MP_END              RKH_TE_MP_PUT
+
+/* --- Queue events (QUE group) --------------------------------------------- */
+/** \copybrief RKH_TR_QUE_INIT */
+#define RKH_TE_QUE_INIT          RKH_QUE_START         
+/** \copybrief RKH_TR_QUE_GET */
+#define RKH_TE_QUE_GET           (RKH_TE_QUE_INIT + 1)
+/** \copybrief RKH_TR_QUE_FIFO */
+#define RKH_TE_QUE_FIFO          (RKH_TE_QUE_GET + 1)
+/** \copybrief RKH_TR_QUE_LIFO */
+#define RKH_TE_QUE_LIFO          (RKH_TE_QUE_FIFO + 1)
+/** \copybrief RKH_TR_QUE_FULL */
+#define RKH_TE_QUE_FULL          (RKH_TE_QUE_LIFO + 1)
+/** \copybrief RKH_TR_QUE_DPT */
+#define RKH_TE_QUE_DPT           (RKH_TE_QUE_FULL + 1)
+/** \copybrief RKH_TR_QUE_GET_LAST */
+#define RKH_TE_QUE_GET_LAST      (RKH_TE_QUE_DPT +1 )
+#define RKH_QUE_END              RKH_TE_QUE_GET_LAST
+
+/* --- State Machine Application events (SMA group) ------------------------ */
+/** \copybrief RKH_TR_SMA_ACT */
+#define RKH_TE_SMA_ACT          RKH_SMA_START
+/** \copybrief RKH_TR_SMA_TERM */
+#define RKH_TE_SMA_TERM         (RKH_TE_SMA_ACT + 1)
+/** \copybrief RKH_TR_SMA_GET */
+#define RKH_TE_SMA_GET          (RKH_TE_SMA_TERM + 1)
+/** \copybrief RKH_TR_SMA_FIFO */
+#define RKH_TE_SMA_FIFO         (RKH_TE_SMA_GET + 1)
+/** \copybrief RKH_TR_SMA_LIFO */
+#define RKH_TE_SMA_LIFO         (RKH_TE_SMA_FIFO + 1)
+/** \copybrief RKH_TR_SMA_REG */
+#define RKH_TE_SMA_REG          (RKH_TE_SMA_LIFO + 1)
+/** \copybrief RKH_TR_SMA_UNREG */
+#define RKH_TE_SMA_UNREG        (RKH_TE_SMA_REG + 1)
+/** \copybrief RKH_TR_SMA_DEFER */
+#define RKH_TE_SMA_DEFER        (RKH_TE_SMA_UNREG + 1)
+/** \copybrief RKH_TR_SMA_RCALL */
+#define RKH_TE_SMA_RCALL        (RKH_TE_SMA_DEFER + 1)
+#define RKH_SMA_END             RKH_TE_SMA_RCALL
+
+/* --- State machine events (SM group) ------------------------------------- */
+/** \copybrief RKH_TR_SM_INIT */
+#define RKH_TE_SM_INIT          RKH_SM_START
+/** \copybrief RKH_TR_SM_CLRH */
+#define RKH_TE_SM_CLRH          (RKH_TE_SM_INIT + 1)
+/** \copybrief RKH_TR_SM_TRN */
+#define RKH_TE_SM_TRN           (RKH_TE_SM_CLRH + 1)
+/** \copybrief RKH_TR_SM_STATE */
+#define RKH_TE_SM_STATE         (RKH_TE_SM_TRN + 1)
+/** \copybrief RKH_TR_SM_ENSTATE */
+#define RKH_TE_SM_ENSTATE       (RKH_TE_SM_STATE + 1)
+/** \copybrief RKH_TR_SM_EXSTATE */
+#define RKH_TE_SM_EXSTATE       (RKH_TE_SM_ENSTATE + 1)
+/** \copybrief RKH_TR_SM_NENEX */
+#define RKH_TE_SM_NENEX         (RKH_TE_SM_EXSTATE + 1)
+/** \copybrief RKH_TR_SM_NTRNACT */
+#define RKH_TE_SM_NTRNACT       (RKH_TE_SM_NENEX + 1)
+/** \copybrief RKH_TR_SM_TS_STATE */
+#define RKH_TE_SM_TS_STATE      (RKH_TE_SM_NTRNACT + 1)
+/** \copybrief RKH_TR_SM_EVT_PROC */
+#define RKH_TE_SM_EVT_PROC      (RKH_TE_SM_TS_STATE + 1)
+/** \copybrief RKH_TR_SM_EVT_NFOUND */
+#define RKH_TE_SM_EVT_NFOUND    (RKH_TE_SM_EVT_PROC + 1)
+/** \copybrief RKH_TR_SM_GRD_FALSE */
+#define RKH_TE_SM_GRD_FALSE     (RKH_TE_SM_EVT_NFOUND + 1)
+/** \copybrief RKH_TR_SM_CND_NFOUND */
+#define RKH_TE_SM_CND_NFOUND    (RKH_TE_SM_GRD_FALSE + 1)
+/** \copybrief RKH_TR_SM_UNKN_STATE */
+#define RKH_TE_SM_UNKN_STATE    (RKH_TE_SM_CND_NFOUND + 1)
+/** \copybrief RKH_TR_SM_EX_HLEVEL */
+#define RKH_TE_SM_EX_HLEVEL     (RKH_TE_SM_UNKN_STATE + 1)
+/** \copybrief RKH_TR_SM_EX_TSEG */
+#define RKH_TE_SM_EX_TSEG       (RKH_TE_SM_EX_HLEVEL + 1)
+/** \copybrief RKH_TR_SM_EXE_ACT */
+#define RKH_TE_SM_EXE_ACT       (RKH_TE_SM_EX_TSEG + 1)
+/** \copybrief RKH_TR_SM_DCH */
+#define RKH_TE_SM_DCH           (RKH_TE_SM_EXE_ACT + 1)
+#define RKH_SM_END              RKH_TE_SM_DCH
+
+/* --- Timer events (TMR group) -------------------------------------------- */
+/** \copybrief RKH_TR_TMR_INIT */
+#define RKH_TE_TMR_INIT         RKH_TMR_START
+/** \copybrief RKH_TR_TMR_START */
+#define RKH_TE_TMR_START        (RKH_TE_TMR_INIT + 1)
+/** \copybrief RKH_TR_TMR_STOP */
+#define RKH_TE_TMR_STOP         (RKH_TE_TMR_START + 1)
+/** \copybrief RKH_TR_TMR_TOUT */
+#define RKH_TE_TMR_TOUT         (RKH_TE_TMR_STOP + 1)
+/** \copybrief RKH_TR_TMR_REM */
+#define RKH_TE_TMR_REM          (RKH_TE_TMR_TOUT + 1)
+#define RKH_TMR_END             RKH_TE_TMR_REM
+
+/* --- Framework and misc. events (FWK group) ------------------------------ */
+/** \copybrief RKH_TR_FWK_EN */
+#define RKH_TE_FWK_EN           RKH_FWK_START
+/** \copybrief RKH_TR_FWK_EX */
+#define RKH_TE_FWK_EX           (RKH_TE_FWK_EN + 1)
+/** \copybrief RKH_TR_FWK_EPREG */
+#define RKH_TE_FWK_EPREG        (RKH_TE_FWK_EX + 1)
+/** \copybrief RKH_TR_FWK_AE */
+#define RKH_TE_FWK_AE           (RKH_TE_FWK_EPREG + 1)
+/** \copybrief RKH_TR_FWK_GC */
+#define RKH_TE_FWK_GC           (RKH_TE_FWK_AE + 1)
+/** \copybrief RKH_TR_FWK_GCR */
+#define RKH_TE_FWK_GCR          (RKH_TE_FWK_GC + 1)
+/** \copybrief RKH_TR_FWK_OBJ */
+#define RKH_TE_FWK_OBJ          (RKH_TE_FWK_GCR + 1)
+/** \copybrief RKH_TR_FWK_SIG */
+#define RKH_TE_FWK_SIG          (RKH_TE_FWK_OBJ + 1)
+/** \copybrief RKH_TR_FWK_FUN */
+#define RKH_TE_FWK_FUN          (RKH_TE_FWK_SIG + 1)
+/** \copybrief RKH_TR_FWK_EXE_FUN */
+#define RKH_TE_FWK_EXE_FUN      (RKH_TE_FWK_FUN + 1)
+/** \copybrief RKH_TR_FWK_SYNC_EVT */
+#define RKH_TE_FWK_SYNC_EVT     (RKH_TE_FWK_EXE_FUN + 1)
+/** \copybrief RKH_TR_FWK_TUSR */
+#define RKH_TE_FWK_TUSR         (RKH_TE_FWK_SYNC_EVT + 1)
+/** \copybrief RKH_TR_FWK_TCFG */
+#define RKH_TE_FWK_TCFG         (RKH_TE_FWK_TUSR + 1)
+/** \copybrief RKH_TR_FWK_ASSERT */
+#define RKH_TE_FWK_ASSERT       (RKH_TE_FWK_TCFG + 1)
+/** \copybrief RKH_TR_FWK_AO */
+#define RKH_TE_FWK_AO           (RKH_TE_FWK_ASSERT + 1)
+/** \copybrief RKH_TR_FWK_STATE */
+#define RKH_TE_FWK_STATE        (RKH_TE_FWK_AO + 1)
+/** \copybrief RKH_TR_FWK_PSTATE */
+#define RKH_TE_FWK_PSTATE       (RKH_TE_FWK_STATE + 1)
+/** \copybrief RKH_TR_FWK_TIMER */
+#define RKH_TE_FWK_TIMER        (RKH_TE_FWK_PSTATE + 1)
+/** \copybrief RKH_TR_FWK_EPOOL */
+#define RKH_TE_FWK_EPOOL        (RKH_TE_FWK_TIMER + 1)
+/** \copybrief RKH_TR_FWK_QUEUE */
+#define RKH_TE_FWK_QUEUE        (RKH_TE_FWK_EPOOL + 1)
+/** \copybrief RKH_TR_FWK_ACTOR */
+#define RKH_TE_FWK_ACTOR        (RKH_TE_FWK_QUEUE + 1)
+#define RKH_FWK_END             RKH_TE_FWK_ACTOR
+
+/* --- User events (USR group) --------------------------------------------- */
+#define RKH_TE_USER             RKH_USR_START
+
+/* --- Unit test harness events (UT group) --------------------------------- */
+#define RKH_TE_UT_INIT          RKH_UT_START
+#define RKH_TE_UT_CLEANUP       (RKH_TE_UT_INIT + 1)
+#define RKH_TE_UT_VERIFY        (RKH_TE_UT_CLEANUP + 1)
+#define RKH_TE_UT_IGNORE_GROUP  (RKH_TE_UT_VERIFY + 1)
+#define RKH_TE_UT_EXPECT        (RKH_TE_UT_IGNORE_GROUP + 1)
+#define RKH_TE_UT_EXPECT_ANYARGS    (RKH_TE_UT_EXPECT + 1)
+#define RKH_TE_UT_IGNORE        (RKH_TE_UT_EXPECT_ANYARGS + 1)
+#define RKH_TE_UT_IGNORE_ARG    (RKH_TE_UT_IGNORE + 1)
+#define RKH_TE_UT_SUCCESS       (RKH_TE_UT_IGNORE_ARG + 1)
+#define RKH_TE_UT_FAIL          (RKH_TE_UT_SUCCESS + 1)
+#define RKH_UT_END              RKH_TE_UT_IGNORE_ARG
+
+/* The last trace event */
+#define RKH_TE_NEVENT           (RKH_UT_END + 1)
+
+/* ------------------------- Configuration errors -------------------------- */
+/*
+ *  LOOK FOR WRONG #define CONSTANTS
+ *
+ *  This section is used to generate ERROR messages at compile time if
+ *  certain #define constants are WRONG in rkhtrc.h.  This allows you to
+ *  quickly determine the source of the error.
+ *
+ *  You SHOULD NOT change this section UNLESS you would like to add more
+ *  comments as to the source of the compile time error.
+ */
+#if ((RKH_MP_END - RKH_MP_START) > ((RKH_MP_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if ((RKH_QUE_END - RKH_QUE_START) > ((RKH_QUE_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if ((RKH_SMA_END - RKH_SMA_START) > ((RKH_SMA_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if ((RKH_SM_END - RKH_SM_START) > ((RKH_SM_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if ((RKH_TMR_END - RKH_TMR_START) > ((RKH_TIM_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if ((RKH_FWK_END - RKH_FWK_START) > ((RKH_FWK_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if ((RKH_UT_END - RKH_UT_START) > ((RKH_UT_TTBL_RANGE * 8) - 1))
+    #error  "rkhtrc.h, the total number of trace events represented"
+    #error  "by RKH_TOT_NUM_TRC_EVTS must be <= RKH_TRC_MAX_EVENTS"
+#endif
+
+#if RKH_CFG_TRC_RTFIL_EN == RKH_ENABLED
+        /**
+         *	Each trace event always begins with the macro RKH_TRC_BEGIN()
+         *	and ends with the matching macro RKH_TRC_END(). These macros are
+         *	not terminated with the semicolon.
+         *  This pair of macros locks interrupts at the beginning and unlocks
+         *  at the end of each record.
+         *
+         *	\param[in] eid_		is the trace event ID.
+         *	                    See RKH_TE_<group>_<event> definitions.
+         *	\param[in] prio_	priority of active object.
+         *	\param[in] sig_		signal.
+         *
+         *  \note
+         *  Both arguments are used in the on/off filter.
+         *  \note
+         *  The runtime filter is optional and could be enabled or
+         *  disabled with the RKH_CFG_TRC_RTFIL_EN in the rkhcfg.h file.
+         *  \note
+         *  This macro always invokes the rkh_trc_begin() function.
+         */
+        #define RKH_TRC_BEGIN(eid_, prio_, sig_)  \
+            if (rkh_trc_isoff_(eid_) \
+                RKH_TRC_AO_ISOFF(prio_) \
+                RKH_TRC_SIG_ISOFF(sig_)) \
+            { \
+                RKH_ENTER_CRITICAL_(); \
+                rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOAO(eid_, sig_) \
+            if (rkh_trc_isoff_(eid_) \
+                RKH_TRC_SIG_ISOFF(sig_)) \
+            { \
+                RKH_ENTER_CRITICAL_(); \
+                rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOSIG(eid_, prio_) \
+            if (rkh_trc_isoff_(eid_) \
+                RKH_TRC_AO_ISOFF(prio_)) \
+            { \
+                RKH_ENTER_CRITICAL_(); \
+                rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOAOSIG(eid_) \
+            if (rkh_trc_isoff_(eid_)) \
+            { \
+                RKH_ENTER_CRITICAL_(); \
+                rkh_trc_begin(eid_);
+
+        /**
+         *	Each trace event always begins with the macro RKH_TRC_BEGIN()
+         *	and ends with the matching macro RKH_TRC_END(). These macros are
+         *	not terminated with the semicolon.
+         *  This pair of macros locks interrupts at the beginning and unlocks
+         *  at the end of each record.
+         *
+         *  \note
+         *  This macro always invokes the rkh_trc_end() function.
+         */
+        #define RKH_TRC_END() \
+            rkh_trc_end(); \
+            RKH_EXIT_CRITICAL_(); \
+            }
+
+        /**
+         *  Idem RKH_TRC_BEGIN() macro but without entering critical section.
+         *
+         *	\param[in] eid_		is the trace event ID.
+         *	                    See RKH_TE_<group>_<event> definitions.
+         *	\param[in] prio_	priority of active object.
+         *	\param[in] sig_		signal.
+         */
+        #define RKH_TRC_BEGIN_NOCRIT(eid_, prio_, sig_) \
+            if (rkh_trc_isoff_(eid_) \
+                RKH_TRC_AO_ISOFF(prio_) \
+                RKH_TRC_SIG_ISOFF(sig_)) \
+            { \
+                rkh_trc_begin(eid_);
+
+        /**
+         *  Idem RKH_TRC_BEGIN_WOAO() macro but without entering critical
+         *  section.
+         *
+         *	\param[in] eid_		is the trace event ID.
+         *	                    See RKH_TE_<group>_<event> definitions.
+         *	\param[in] sig_		signal.
+         */
+        #define RKH_TRC_BEGIN_WOAO_NOCRIT(eid_, sig_) \
+            if (rkh_trc_isoff_(eid_) \
+                RKH_TRC_SIG_ISOFF(sig_)) \
+            { \
+                rkh_trc_begin(eid_);
+
+        /**
+         *  Idem RKH_TRC_BEGIN_WOSIG() macro but without entering critical
+         *  section.
+         *
+         *	\param[in] eid_		is the trace event ID.
+         *	                    See RKH_TE_<group>_<event> definitions.
+         *	\param[in] prio_	priority of active object.
+         */
+        #define RKH_TRC_BEGIN_WOSIG_NOCRIT(eid_, prio_) \
+            if (rkh_trc_isoff_(eid_) \
+                RKH_TRC_AO_ISOFF(prio_)) \
+            { \
+                rkh_trc_begin(eid_);
+
+        /**
+         *  Idem RKH_TRC_BEGIN_WOAOSIG() macro but without entering critical
+         *  section.
+         *
+         *	\param[in] eid_		is the trace event ID.
+         *	                    See RKH_TE_<group>_<event> definitions.
+         */
+        #define RKH_TRC_BEGIN_WOAOSIG_NOCRIT(eid_) \
+            if (rkh_trc_isoff_(eid_)) \
+            { \
+                rkh_trc_begin(eid_);
+
+        /**
+         *  Idem RKH_TRC_EXIT() macro but without exiting critical section.
+         */
+        #define RKH_TRC_END_NOCRIT() \
+            rkh_trc_end(); \
+            }
+#else
+        #define RKH_TRC_BEGIN(eid_, prio_, sig_) \
+            RKH_ENTER_CRITICAL_(); \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOAO(eid_, sig_) \
+            RKH_ENTER_CRITICAL_(); \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOSIG(eid_, prio_) \
+            RKH_ENTER_CRITICAL_(); \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOAOSIG(eid_) \
+            RKH_ENTER_CRITICAL_(); \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_END() \
+            rkh_trc_end();  \
+            RKH_EXIT_CRITICAL_();
+
+        #define RKH_TRC_BEGIN_NOCRIT(eid_, prio_, sig_) \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOAO_NOCRIT(eid_, sig_) \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOSIG_NOCRIT(eid_, prio_) \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_BEGIN_WOAOSIG_NOCRIT(eid_) \
+            rkh_trc_begin(eid_);
+
+        #define RKH_TRC_END_NOCRIT() \
+            rkh_trc_end();
+#endif
+
+/**
+ *  Idem RKH_TRC_BEGIN() macro but use it for trace events that are
+ *  independent of any runtime filter.
+ */
+#define RKH_TRC_BEGIN_WOFIL(eid_) \
+        RKH_SR_ALLOC(); \
+        RKH_ENTER_CRITICAL_(); \
+        rkh_trc_begin(eid_);
+
+/**
+ *  Idem RKH_TRC_END() macro but use it for trace events that are
+ *  independent of any runtime filter.
+ */
+#define RKH_TRC_END_WOFIL() \
+        rkh_trc_end(); \
+        RKH_EXIT_CRITICAL_();
+
+/**
+ *  Idem RKH_TRC_BEGIN_WOFIL() macro but without entering critical section.
+ */
+#define RKH_TRC_BEGIN_WOFIL_NOCRIT(eid_) \
+        rkh_trc_begin(eid_);
+
+/**
+ *  Idem RKH_TRC_END_WOFIL_NOCRIT() macro but without entering critical
+ *  section.
+ */
+#define RKH_TRC_END_WOFIL_NOCRIT() \
+        rkh_trc_end();  \
+
+/**
+ *  Idem RKH_TRC_BEGIN() macro with default configuration, i.e.
+ *  without timestamp, and number of sequence, but with 8-bit checksum.
+ */
+#define RKH_TRC_BEGIN_DFT(eid_) \
+        RKH_SR_ALLOC(); \
+        RKH_ENTER_CRITICAL_(); \
+        rkh_trc_clear_chk(); \
+        RKH_TRC_TE_ID(eid_);
+
+/**
+ *  Idem RKH_TRC_END() macro but use it for trace events that are
+ *  independent of any runtime filter.
+ */
+#define RKH_TRC_END_DFT() \
+        rkh_trc_end(); \
+        RKH_EXIT_CRITICAL_();
+
+/**
+ *  \brief
+ *  Insert a 1-byte without escaping it.
+ */
+#define RKH_TRC_U8_RAW(d) \
+        rkh_trc_put((d))
+
+/**
+ *  \brief
+ *  Insert a 1-byte data.
+ */
+#define RKH_TRC_UI8(d) \
+        rkh_trc_u8((rui8_t)(d))
+
+/**
+ *  \brief
+ *  Insert a 2-byte data.
+ */
+#define RKH_TRC_UI16(d) \
+        rkh_trc_u16((d))
+
+/**
+ *  \brief
+ *  Insert a 4-byte data.
+ */
+#define RKH_TRC_UI32(d) \
+        rkh_trc_u32((d))
+
+/**
+ *  \brief
+ *  Insert a string.
+ */
+#define RKH_TRC_STR(s) \
+        rkh_trc_str((s))
+
+#if RKH_CFG_TRC_USER_TRACE_EN == RKH_ENABLED
+        /**
+         *  Idem RKH_TRC_BEGIN() macro but use it for user trace events.
+         */
+        #define RKH_TRC_USR_BEGIN(eid_) \
+            RKH_SR_ALLOC(); \
+            if (rkh_trc_isoff_(eid_)) \
+            { \
+                RKH_ENTER_CRITICAL_(); \
+                rkh_trc_begin(eid_);
+
+        /**
+         *  Idem RKH_TRC_END() macro but use it for user trace events.
+         */
+        #define RKH_TRC_USR_END() \
+            rkh_trc_end(); \
+            RKH_EXIT_CRITICAL_(); \
+            }
+
+        /**
+         *  Idem RKH_TRC_USR_BEGIN() macro but without entering critical 
+         *  section.
+         */
+        #define RKH_TRC_USR_BEGIN_NOCRIT(eid_) \
+            if (rkh_trc_isoff_(eid_)) \
+            { \
+                rkh_trc_begin(eid_);
+
+        /**
+         *  Idem RKH_TRC_USR_END() macro but without exiting critical section.
+         */
+        #define RKH_TRC_USR_END_NOCRIT() \
+            rkh_trc_end(); \
+            }
+
+        /**
+         *  \brief
+         *  Output formatted ri8_t to the trace record.
+         */
+        #define RKH_TUSR_I8(w_, d_) \
+            rkh_trc_fmt_u8((rui8_t)(((w_) << 4)) | (rui8_t)RKH_I8_T, \
+                           (d_))
+
+        /**
+         *  \brief
+         *  Output formatted rui8_t to the trace record.
+         */
+        #define RKH_TUSR_UI8(w_, d_) \
+            rkh_trc_fmt_u8((rui8_t)(((w_) << 4)) | (rui8_t)RKH_UI8_T, \
+                           (d_))
+
+        /**
+         *  \brief
+         *  Output formatted ri16_t to the trace record.
+         */
+        #define RKH_TUSR_I16(w_, d_) \
+            rkh_trc_fmt_u16((rui8_t)(((w_) << 4)) | (rui8_t)RKH_I16_T, \
+                            (d_))
+
+        /**
+         *  \brief
+         *  Output formatted rui16_t to the trace record.
+         */
+        #define RKH_TUSR_UI16(w_, d_) \
+            rkh_trc_fmt_u16((rui8_t)(((w_) << 4)) | (rui8_t)RKH_UI16_T, \
+                            (d_))
+
+        /**
+         *  \brief
+         *  Output formatted ri32_t to the trace record.
+         */
+        #define RKH_TUSR_I32(w_, d_) \
+            rkh_trc_fmt_u32((rui8_t)(((w_) << 4)) | (rui8_t)RKH_I32_T, \
+                            (d_))
+
+        /**
+         *  \brief
+         *  Output formatted rui32_t to the trace record.
+         */
+        #define RKH_TUSR_UI32(w_, d_) \
+            rkh_trc_fmt_u32((rui8_t)(((w_) << 4)) | (rui8_t)RKH_UI32_T, \
+                            (d_))
+
+        /**
+         *  \brief
+         *  Output formatted rui32_t to the trace record.
+         */
+        #define RKH_TUSR_X32(w_, d_) \
+            rkh_trc_fmt_u32((rui8_t)(((w_) << 4)) | (rui8_t)RKH_X32_T, \
+                            (d_))
+
+        /**
+         *  \brief
+         *  Output formatted zero-terminated ASCII string to the trace record.
+         */
+        #define RKH_TUSR_STR(s_) \
+            rkh_trc_fmt_str((s_))
+
+        /**
+         *  \brief
+         *  Output formatted memory block of up to 255 bytes to the trace 
+         *  record.
+         */
+        #define RKH_TUSR_MEM(mem_, size_) \
+            rkh_trc_fmt_mem((mem_), (size_))
+
+        /**
+         *  \brief
+         *  Output formatted object pointer to the trace record.
+         */
+        #if RKH_CFGPORT_TRC_SIZEOF_PTR == 16
+            #define RKH_TUSR_OBJ(obj_)    \
+                rkh_trc_fmt_u16((rui8_t)RKH_OBJ_T, (rui16_t)(obj_))
+        #elif RKH_CFGPORT_TRC_SIZEOF_PTR == 32
+            #define RKH_TUSR_OBJ(obj_)    \
+                rkh_trc_fmt_u32((rui8_t)RKH_OBJ_T, (rui32_t)(obj_))
+        #else
+            #define RKH_TUSR_OBJ(obj_)    \
+                rkh_trc_fmt_u32((rui8_t)RKH_OBJ_T, (rui32_t)(obj_))
+        #endif
+
+        /**
+         *  \brief
+         *  Output formatted function pointer to the trace record.
+         */
+        #if RKH_CFGPORT_TRC_SIZEOF_FUN_PTR == 16u
+            #define RKH_TUSR_FUN(fun_)    \
+                rkh_trc_fmt_u16((rui8_t)RKH_FUN_T, (rui16_t)(fun_))
+        #elif RKH_CFGPORT_TRC_SIZEOF_FUN_PTR == 32
+            #define RKH_TUSR_FUN(fun_)    \
+                rkh_trc_fmt_u32((rui8_t)RKH_FUN_T, (rui32_t)(fun_))
+        #else
+            #define RKH_TUSR_FUN(fun_)    \
+                rkh_trc_fmt_u32((rui8_t)RKH_FUN_T, (rui32_t)(fun_))
+        #endif
+
+        /**
+         *  \brief
+         *  Output formatted event signal to the trace record.
+         */
+        #if RKH_CFG_FWK_SIZEOF_EVT == 8
+            #define RKH_TUSR_SIG(sig_) \
+                rkh_trc_fmt_u8((rui8_t)RKH_ESIG_T, (rui8_t)(sig_))
+        #elif RKH_CFG_FWK_SIZEOF_EVT == 16
+            #define RKH_TUSR_SIG(sig_) \
+                rkh_trc_fmt_u16((rui8_t)RKH_ESIG_T, (rui16_t)(sig_))
+        #elif RKH_CFG_FWK_SIZEOF_EVT == 32
+            #define RKH_TUSR_SIG(sig_) \
+                rkh_trc_fmt_u32((rui8_t)RKH_ESIG_T, (rui32_t)(sig_))
+        #else
+            #define RKH_TUSR_SIG(sig_) \
+                rkh_trc_fmt_u8((rui8_t)RKH_ESIG_T, (rui8_t)(sig_))
+        #endif
+#else
+        #define RKH_TRC_USR_BEGIN(eid_)           (void)0;
+        #define RKH_TRC_USR_END()                 (void)0
+        #define RKH_TRC_USR_BEGIN_NOCRIT(eid_)    (void)0
+        #define RKH_TRC_USR_END_NOCRIT()          (void)0
+        #define RKH_TUSR_I8(w_, d_)               (void)0
+        #define RKH_TUSR_UI8(w_, d_)              (void)0
+        #define RKH_TUSR_I16(w_, d_)              (void)0
+        #define RKH_TUSR_UI16(w_, d_)             (void)0
+        #define RKH_TUSR_I32(w_, d_)              (void)0
+        #define RKH_TUSR_UI32(w_, d_)             (void)0
+        #define RKH_TUSR_X32(w_, d_)              (void)0
+        #define RKH_TUSR_STR(s_)                  (void)0
+        #define RKH_TUSR_MEM(mem_, size_)         (void)0
+        #define RKH_TUSR_OBJ(obj_)                (void)0
+        #define RKH_TUSR_FUN(fun_)                (void)0
+        #define RKH_TUSR_SIG(sig_)                (void)0
+#endif
+
+/**
+ *  \brief
+ *  Insert a object address as trace record argument.
+ */
+#if RKH_CFGPORT_TRC_SIZEOF_PTR == 16
+        #define RKH_TRC_SYM(sym)  \
+            RKH_TRC_UI16((rui16_t)sym)
+#elif RKH_CFGPORT_TRC_SIZEOF_PTR == 32
+        #define RKH_TRC_SYM(sym)  \
+            RKH_TRC_UI32((rui32_t)sym)
+#else
+        #define RKH_TRC_SYM(sym)  \
+            RKH_TRC_UI32((rui32_t)sym)
+#endif
+
+/**
+ *  \brief
+ *  Insert a sender object address as trace record argument.
+ */
+#if defined(RKH_USE_TRC_SENDER)
+        #define RKH_TRC_SNDR(sym) \
+            RKH_TRC_SYM(sym)
+#else
+        #define RKH_TRC_SNDR(sym)
+#endif
+
+/**
+ *  \brief
+ *  Insert a function address as trace record argument.
+ */
+#if RKH_CFGPORT_TRC_SIZEOF_FUN_PTR == 16
+        #define RKH_TRC_FUN(sym)  \
+            RKH_TRC_UI16((rui16_t)sym)
+#elif RKH_CFGPORT_TRC_SIZEOF_FUN_PTR == 32
+        #define RKH_TRC_FUN(sym)  \
+            RKH_TRC_UI32((rui32_t)sym)
+#else
+        #define RKH_TRC_FUN(sym)  \
+            RKH_TRC_UI32((rui32_t)sym)
+#endif
+
+/**
+ *  Insert a ntick value as trace record argument.
+ */
+#if RKH_CFG_TMR_SIZEOF_NTIMER == 8
+        #define RKH_TRC_NTICK(nt) \
+            RKH_TRC_UI8(nt)
+#elif RKH_CFG_TMR_SIZEOF_NTIMER == 16
+        #define RKH_TRC_NTICK(nt) \
+            RKH_TRC_UI16(nt)
+#elif RKH_CFG_TMR_SIZEOF_NTIMER == 32
+        #define RKH_TRC_NTICK(nt) \
+            RKH_TRC_UI32(nt)
+#else
+        #define RKH_TRC_NTICK(nt) \
+            RKH_TRC_UI8(nt)
+#endif
+
+/**
+ *  Insert a nblock value as trace record argument.
+ */
+#if RKH_CFG_MP_SIZEOF_NBLOCK == 8
+        #define RKH_TRC_NBLK(nb) \
+            RKH_TRC_UI8(nb)
+        #if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED
+            #define RKH_TRC_MP_NMIN(nm) \
+                RKH_TRC_UI8(nm)
+        #else
+            #define RKH_TRC_MP_NMIN(nm)
+        #endif
+#elif RKH_CFG_MP_SIZEOF_NBLOCK == 16
+        #define RKH_TRC_NBLK(nb) \
+            RKH_TRC_UI16(nb)
+        #if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED
+            #define RKH_TRC_MP_NMIN(nm) \
+                RKH_TRC_UI16(nm)
+        #else
+            #define RKH_TRC_MP_NMIN(nm)
+        #endif
+#elif RKH_CFG_MP_SIZEOF_NBLOCK == 32
+        #define RKH_TRC_NBLK(nb) \
+            RKH_TRC_UI32(nb)
+        #if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED
+            #define RKH_TRC_MP_NMIN(nm) \
+                RKH_TRC_UI32(nm)
+        #else
+            #define RKH_TRC_MP_NMIN(nm)
+        #endif
+#else
+        #define RKH_TRC_NBLK(nb) \
+            RKH_TRC_UI8(nb)
+        #if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED
+            #define RKH_TRC_MP_NMIN(nm) \
+                RKH_TRC_UI8(nm)
+        #else
+            #define RKH_TRC_MP_NMIN(nm)
+        #endif
+#endif
+
+/**
+ *  Insert the block size value as trace record argument.
+ */
+#if RKH_CFG_MP_SIZEOF_BSIZE == 8
+        #define RKH_TRC_BSIZE(bs) \
+            RKH_TRC_UI8(bs)
+#elif RKH_CFG_MP_SIZEOF_BSIZE == 16
+        #define RKH_TRC_BSIZE(bs) \
+            RKH_TRC_UI16(bs)
+#elif RKH_CFG_MP_SIZEOF_BSIZE == 32
+        #define RKH_TRC_BSIZE(bs) \
+            RKH_TRC_UI32(bs)
+#else
+        #define RKH_TRC_BSIZE(bs) \
+            RKH_TRC_UI8(bs)
+#endif
+
+/**
+ *  Insert a nelem value as trace record argument.
+ */
+#if RKH_CFG_QUE_SIZEOF_NELEM == 8
+        #define RKH_TRC_NE(ne) \
+            RKH_TRC_UI8(ne)
+        #if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+            #define RKH_TRC_QUE_NMIN(nm) \
+                RKH_TRC_UI8(nm)
+        #else
+            #define RKH_TRC_QUE_NMIN(nm)
+        #endif
+#elif RKH_CFG_QUE_SIZEOF_NELEM == 16
+        #define RKH_TRC_NE(ne) \
+            RKH_TRC_UI16(ne)
+        #if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+            #define RKH_TRC_QUE_NMIN(nm) \
+                RKH_TRC_UI16(nm)
+        #else
+            #define RKH_TRC_QUE_NMIN(nm)
+        #endif
+#elif RKH_CFG_QUE_SIZEOF_NELEM == 32
+        #define RKH_TRC_NE(ne) \
+            RKH_TRC_UI32(ne)
+        #if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+            #define RKH_TRC_QUE_NMIN(nm) \
+                RKH_TRC_UI32(nm)
+        #else
+            #define RKH_TRC_QUE_NMIN(nm)
+        #endif
+#else
+        #define RKH_TRC_NE(ne) \
+            RKH_TRC_UI8(ne)
+        #if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+            #define RKH_TRC_QUE_NMIN(nm) \
+                RKH_TRC_UI8(nm)
+        #else
+            #define RKH_TRC_QUE_NMIN(nm)
+        #endif
+#endif
+
+/**
+ *  Insert a signal number as trace record argument.
+ */
+#if RKH_CFG_FWK_SIZEOF_EVT == 8
+        #define RKH_TRC_SIG(e) \
+            RKH_TRC_UI8(e)
+#elif RKH_CFG_FWK_SIZEOF_EVT == 16
+        #define RKH_TRC_SIG(e) \
+            RKH_TRC_UI16(e)
+#elif RKH_CFG_FWK_SIZEOF_EVT == 32
+        #define RKH_TRC_SIG(e) \
+            RKH_TRC_UI32(e)
+#else
+        #define RKH_TRC_SIG(e) \
+            RKH_TRC_UI8(e)
+#endif
+
+/**
+ *  Insert an event size value as trace record argument.
+ */
+#if RKH_CFG_FWK_SIZEOF_EVT_SIZE == 8
+        #define RKH_TRC_ES(es) \
+            RKH_TRC_UI8(es)
+#elif RKH_CFG_FWK_SIZEOF_EVT_SIZE == 16
+        #define RKH_TRC_ES(es) \
+            RKH_TRC_UI16(es)
+#elif RKH_CFG_FWK_SIZEOF_EVT_SIZE == 32
+        #define RKH_TRC_ES(es) \
+            RKH_TRC_UI32(es)
+#else
+        #define RKH_TRC_ES(es) \
+            RKH_TRC_UI8(es)
+#endif
+
+/**
+ *  \brief
+ *  Enumerates data formats recognized by Trazer.
+ *
+ *  Trazer uses this enumeration is used only internally for the formatted
+ *  user data elements.
+ */
+enum RKH_TRC_FMT
+{
+    RKH_I8_T,       /**< signed 8-bit integer format */
+    RKH_UI8_T,      /**< unsigned 8-bit integer format */
+    RKH_I16_T,      /**< signed 16-bit integer format */
+    RKH_UI16_T,     /**< unsigned 16-bit integer format */
+    RKH_I32_T,      /**< signed 32-bit integer format */
+    RKH_UI32_T,     /**< unsigned 16-bit integer format */
+    RKH_X32_T,      /**< signed 16-bit integer in hex format */
+    RKH_STR_T,      /**< zero-terminated ASCII string format */
+    RKH_MEM_T,      /**< up to 255-bytes memory block format */
+    RKH_OBJ_T,      /**< object pointer format */
+    RKH_FUN_T,      /**< function pointer format */
+    RKH_ESIG_T      /**< event signal format */
+};
+
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  \brief
+ *  Describes a trace event identification (ID).
+ *
+ *  The trace event ID is arranged as:
+ *  event number = | G | G | G | E | E | E | E | E |\n
+ *
+ *  G's:	group number.\n
+ *  E's:	event's group.\n
+ *
+ *  Where the lower 5 bits (E's) of the event ID are used to determine
+ *  the trace event, while the next three most significant bits
+ *  (G's) are used to determine the corresponding group.
+ *  Therefore, is able to define 8 groups and 32 events per group.
+ *
+ *  Trace events are binary data consisting of a trace header and its
+ *  associated event data. Every trace header is made up of a ID and a
+ *  timestamp. The number of bytes used by the timestamp is configurable by
+ *  RKH_TRC_SIZEOF_TS (1, 2 or 4 bytes). After the timestamp follows the
+ *  event data. The content and size of the data portion of a trace event is
+ *  determined by the event ID.
+ *	All types of events are stored in a single ring buffer, called trace
+ *	stream, using a variable event size. In this manner the recorder always
+ *	holds the most recent history.
+ *	On the other hand, all data are stored in little-endian order (least
+ *	significant byte first). Also, they are stored into the trace stream 1
+ *	byte at a time, thus avoiding any potential data misalignment problems.
+ *
+ *	\note
+ *	The timestamp is optional, thus it could be eliminated from the trace
+ *	event in compile-time with RKH_CFG_TRC_TSTAMP_EN = 0.
+ */
+#if RKH_CFG_TRC_SIZEOF_TE_ID == 8
+    typedef rui8_t RKH_TE_ID_T;
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 16
+    typedef rui16_t RKH_TE_ID_T;
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 32
+    typedef rui32_t RKH_TE_ID_T;
+#else
+    typedef rui8_t RKH_TE_ID_T;
+#endif
+
+/**
+ *  \brief
+ *  Defines the size of trace timestamp.
+ *
+ *  The valid values [in bits] are 8, 16 or 32. Default is 16. This type is
+ *  configurable via the RKH_CFGPORT_TRC_SIZEOF_TSTAMP preprocessor option.
+ */
+#if RKH_CFG_TRC_TSTAMP_EN == RKH_ENABLED
+    #if RKH_CFGPORT_TRC_SIZEOF_TSTAMP == 8
+        typedef rui8_t RKH_TS_T;
+    #elif RKH_CFGPORT_TRC_SIZEOF_TSTAMP == 16
+        typedef rui16_t RKH_TS_T;
+    #elif RKH_CFGPORT_TRC_SIZEOF_TSTAMP == 32
+        typedef rui32_t RKH_TS_T;
+    #else
+        typedef rui16_t RKH_TS_T;
+    #endif
+#else
+    typedef rui16_t RKH_TS_T;
+#endif
+
+#if RKH_CFG_TRC_SIZEOF_STREAM < 255u
+    typedef rui8_t TRCQTY_T;
+#else
+    typedef rui16_t TRCQTY_T;
+#endif
+
+/**
+ *  \brief
+ *  Group of events 
+ */
+typedef rui8_t RKH_TG_T;
+
+/**
+ *  \brief
+ *  Sub-event of RKH_TE_SM_EXE_ACT event.
+ */
+typedef enum RKH_SUBTE_SM_EXE_ACT
+{
+    RKH_SUBTE_SM_EXE_ACT_EFF,       /**< \copybrief RKH_TR_SM_EXE_ACT */
+    RKH_SUBTE_SM_EXE_ACT_EN,        /**< \copybrief RKH_TR_SM_EXE_ACT */
+    RKH_SUBTE_SM_EXE_ACT_EX,        /**< \copybrief RKH_TR_SM_EXE_ACT */
+    RKH_SUBTE_SM_EXE_ACT_INI,       /**< \copybrief RKH_TR_SM_EXE_ACT */
+    RKH_SUBTE_SM_EXE_ACT_PP,        /**< \copybrief RKH_TR_SM_EXE_ACT */
+    RKH_SUBTE_SM_EXE_ACT_GRD        /**< \copybrief RKH_TR_SM_EXE_ACT */
+} RKH_SUBTE_SM_EXE_ACT;
+
+#if RKH_CFG_TRC_SIZEOF_TE_ID == 8
+typedef rui8_t RKH_GM_OFFSET_T;
+typedef rui8_t RKH_GM_RANGE_T;
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 16
+typedef rui16_t RKH_GM_OFFSET_T;
+typedef rui8_t RKH_GM_RANGE_T;
+#elif RKH_CFG_TRC_SIZEOF_TE_ID == 32
+typedef rui32_t RKH_GM_OFFSET_T;
+typedef rui32_t RKH_GM_RANGE_T;
+#else
+typedef rui8_t RKH_GM_OFFSET_T;
+typedef rui8_t RKH_GM_RANGE_T;
+#endif
+
+typedef struct
+{
+    RKH_GM_OFFSET_T offset;
+    RKH_GM_RANGE_T range;
+} RKH_GMTBL_T;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtrc_filter.h ./rkh/inc/rkhtrc_filter.h
--- a_qSC69Z/rkh/inc/rkhtrc_filter.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtrc_filter.h	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,451 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_filter.h
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    apiTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTRC_FILTER_H__
+#define __RKHTRC_FILTER_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_define.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if RKH_CFG_TRC_EN == RKH_ENABLED && RKH_CFG_TRC_RTFIL_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *  Suppress the enabled trace events from a specific group.
+     *  Use the RKH_TRC_ALL_GROUPS to disable all groups.
+     *
+     *  \ingroup apiTrc 
+     */
+    #define RKH_FILTER_ON_GROUP(grp) \
+        rkh_trc_filter_group_(FILTER_ON, (grp), EUNCHANGE)
+
+    /**
+     *  \brief
+     *  Emit the enabled trace events from a specific group.
+     *  Use the RKH_TRC_ALL_GROUPS to enable all groups.
+     *
+     *  \ingroup apiTrc 
+     */
+    #define RKH_FILTER_OFF_GROUP(grp) \
+        rkh_trc_filter_group_(FILTER_OFF, (grp), EUNCHANGE)
+
+    /**
+     *  \brief
+     *  Suppress (disable) one trace event.
+     *  Use the RKH_TRC_ALL_EVENTS to disable all trace events.
+     *
+     *  \ingroup apiTrc 
+     */
+    #define RKH_FILTER_ON_EVENT(evt) \
+        rkh_trc_filter_event_(FILTER_ON, (evt))
+
+    /**
+     *  \brief
+     *  Emit (enable) one trace event.
+     *  Use the RKH_TRC_ALL_EVENTS to enable all trace events.
+     *
+     *  \note
+     *	The container group is enabled, reglardless of its previous status.
+     *
+     *  \ingroup apiTrc 
+     */
+    #define RKH_FILTER_OFF_EVENT(evt) \
+        rkh_trc_filter_event_(FILTER_OFF, (evt))
+
+    /**
+     *  \brief
+     *  Suppress (disable) all events in a specific group.
+     *
+     *  \ingroup apiTrc 
+     */
+    #define RKH_FILTER_ON_GROUP_ALL_EVENTS(grp) \
+        rkh_trc_filter_group_(FILTER_ON, (grp), ECHANGE)
+
+    /**
+     *  \brief
+     *  Emit (enable) all events in a specific group.
+     *
+     *  \note
+     *	The container group is enabled, reglardless of its previous status.
+     *
+     *  \ingroup apiTrc 
+     */
+    #define RKH_FILTER_OFF_GROUP_ALL_EVENTS(grp) \
+        rkh_trc_filter_group_(FILTER_OFF, (grp), ECHANGE)
+
+    #if RKH_CFG_TRC_RTFIL_SMA_EN == RKH_ENABLED
+
+    /**
+     *  \brief
+     *  Suppress the enable trace events related to a specified active
+     *  object.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_ON_SMA(sma) \
+            rkh_trc_symFil(RKHFilterSma, RKH_SMA_ACCESS_CONST(sma, prio), \
+                           FILTER_ON)
+
+    /**
+     *  \brief
+     *  Suppress all enabled trace events related to active objects.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_ON_ALL_SMA() \
+            rkh_trc_symFil(RKHFilterSma, 0, RKH_TRC_SET_ALL(FILTER_ON))
+
+    /**
+     *  \brief
+     *  Emmit the enabled trace events related to a specified active
+     *  object.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_OFF_SMA(sma) \
+            rkh_trc_symFil(RKHFilterSma, RKH_SMA_ACCESS_CONST(sma, prio), \
+                           FILTER_OFF)
+
+    /**
+     *  \brief
+     *  Emmit all enabled trace events related to active objects.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_OFF_ALL_SMA() \
+            rkh_trc_symFil(RKHFilterSma, 0, RKH_TRC_SET_ALL(FILTER_OFF))
+
+    #else
+        #define RKH_FILTER_ON_SMA(sma)          (void)0
+        #define RKH_FILTER_ON_ALL_SMA()         (void)0
+        #define RKH_FILTER_OFF_SMA(sma)         (void)0
+        #define RKH_FILTER_OFF_ALL_SMA()        (void)0
+    #endif
+
+    #if RKH_CFG_TRC_RTFIL_SIGNAL_EN == RKH_ENABLED
+    /**
+     *  \brief
+     *  Suppress the enabled trace events related to a specified event
+     *  signal.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_ON_SIGNAL(sig) \
+            rkh_trc_symFil(RKHFilterSignal, (sig), FILTER_ON)
+
+    /**
+     *  \brief
+     *  Suppress all enabled trace events related to signals.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_ON_ALL_SIGNALS() \
+            rkh_trc_symFil(RKHFilterSignal, 0, RKH_TRC_SET_ALL(FILTER_ON))
+
+    /**
+     *  \brief
+     *  Emmit the enabled trace events related to a specified event
+     *  signal.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_OFF_SIGNAL(sig) \
+            rkh_trc_symFil(RKHFilterSignal, (sig), FILTER_OFF)
+
+    /**
+     *  \brief
+     *  Emmit all enabled trace events related to signals.
+     *
+     *  \ingroup apiTrc 
+     */
+        #define RKH_FILTER_OFF_ALL_SIGNALS() \
+            rkh_trc_symFil(RKHFilterSignal, 0, RKH_TRC_SET_ALL(FILTER_OFF))
+    #else
+        #define RKH_FILTER_ON_SIGNAL(sig)       (void)0
+        #define RKH_FILTER_ON_ALL_SIGNALS()     (void)0
+        #define RKH_FILTER_OFF_SIGNAL(sig)      (void)0
+        #define RKH_FILTER_OFF_ALL_SIGNALS()    (void)0
+    #endif
+#else
+    #define RKH_FILTER_ON_GROUP(grp)                (void)0
+    #define RKH_FILTER_OFF_GROUP(grp)               (void)0
+    #define RKH_FILTER_ON_EVENT(evt)                (void)0
+    #define RKH_FILTER_OFF_EVENT(evt)               (void)0
+    #define RKH_FILTER_ON_GROUP_ALL_EVENTS(grp)     (void)0
+    #define RKH_FILTER_OFF_GROUP_ALL_EVENTS(grp)    (void)0
+    #define RKH_FILTER_ON_SMA(sma)                  (void)0
+    #define RKH_FILTER_ON_ALL_SMA()                 (void)0
+    #define RKH_FILTER_OFF_SMA(sma)                 (void)0
+    #define RKH_FILTER_OFF_ALL_SMA()                (void)0
+    #define RKH_FILTER_ON_SIGNAL(sig)               (void)0
+    #define RKH_FILTER_ON_ALL_SIGNALS()             (void)0
+    #define RKH_FILTER_OFF_SIGNAL(sig)              (void)0
+    #define RKH_FILTER_OFF_ALL_SIGNALS()            (void)0
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/**
+ *  \brief
+ *  This data type defines the size of filter table for AO and signals.
+ */
+#if RKH_TRC_MAX_SMA > RKH_TRC_MAX_SIGNALS
+    #if (RKH_TRC_MAX_SMA * 8) <= RKH_BIT(8)
+        typedef rui8_t RKH_TRC_FSLOT;
+    #elif (RKH_TRC_MAX_SMA * 8) <= RKH_BIT(16)
+        typedef rui16_t RKH_TRC_FSLOT;
+    #elif (RKH_TRC_MAX_SMA * 8) <= RKH_BIT(32)
+        typedef rui32_t RKH_TRC_FSLOT;
+    #else
+        typedef rui8_t RKH_TRC_FSLOT;
+    #endif
+#else
+    #if (RKH_TRC_MAX_SIGNALS * 8) <= RKH_BIT(8)
+        typedef rui8_t RKH_TRC_FSLOT;
+    #elif (RKH_TRC_MAX_SIGNALS * 8) <= RKH_BIT(16)
+        typedef rui16_t RKH_TRC_FSLOT;
+    #elif (RKH_TRC_MAX_SIGNALS * 8) <= RKH_BIT(32)
+        typedef rui32_t RKH_TRC_FSLOT;
+    #else
+        typedef rui8_t RKH_TRC_FSLOT;
+    #endif
+#endif
+
+/**
+ *  \brief
+ *	Represents the filter of signal and active object.
+ */
+typedef struct RKH_TRC_FIL_T
+{
+    RKH_TRC_FSLOT size;     /** Size of filter table in bytes */
+    rui8_t *const tbl;      /** Points to filter table in RAM */
+} RKH_TRC_FIL_T;
+
+typedef enum
+{
+    FILTER_ON, FILTER_OFF
+} RKH_TRC_FOPT;
+
+typedef enum RKHFilter
+{
+    RKHFilterTrcEvt, RKHFilterSignal, RKHFilterSma,
+    RKHFilterNums
+} RKHFilter;
+
+typedef struct RKH_FilterTbl
+{
+    const RKH_TRC_FIL_T *signal;
+    const RKH_TRC_FIL_T *ao;
+    rui8_t *event;
+    rui8_t *group;
+    const RKH_GMTBL_T *grpFilMap;
+} RKH_FilterTbl;
+
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Emit or suppress all trace events from a specific group.
+ *
+ *  The stream is initially created with an empty filter (that is, without
+ *  filtering any event type). If this is not the required behavior, the
+ *  application can build a set of event types, include the appropriate event
+ *  types in it, and apply it as a filter to the stream. After that, the
+ *  stream will reject any event whose type is in the filter set.
+ *
+ *	Gathering many events generates a lot of data, which requires memory and
+ *	processor time. It also makes the task of interpreting the data more
+ *	difficult. Because the amount of data that the instrumented framework
+ *	generates can be overwhelming, the RKH supports several types of filters
+ *	that can use it to reduce the amount of data to be processed. The
+ *	available groups are enumerated in RKH_TG_<group> definitions.
+ *
+ *  \param[in] ctrl	filter option, the available options are FILTER_ON or
+ *                  FILTER_OFF.
+ *  \param[in] grp	trace group. The available groups are enumerated in
+ *                  RKH_TG_<group> definitions.
+ *  \param[in] mode	filter mode. ECHANGE indicates that the all event's group
+ *                  are accordingly changed as filter option value, otherwise
+ *                  EUNCHANGE.
+ *
+ *  \usage
+ *  \code
+ *  void
+ *  some_function(...)
+ *  {
+ *      RKH_FILTER_ON_GROUP(RKH_TRC_ALL_GROUPS);
+ *      RKH_FILTER_ON_EVENT(RKH_TRC_ALL_EVENTS);
+ *      ...
+ *  }
+ *  \endcode
+ *
+ *	\note
+ *  This function is internal to RKH and the user application should not call
+ *  it. Please use RKH_FILTER_ON_GROUP(), or RKH_FILTER_OFF_GROUP() macros
+ *  instead.
+ */
+void rkh_trc_filter_group_(rui8_t ctrl, RKH_TG_T grp, rui8_t mode);
+
+/**
+ *  \brief
+ *  Emit or suppress a specific event.
+ *
+ *  The stream is initially created with an empty filter (that is, without
+ *  filtering any event type). If this is not the required behavior, the
+ *  application can build a set of event types, include the appropriate event
+ *  types in it, and apply it as a filter to the stream. After that, the
+ *  stream will reject any event whose type is in the filter set.
+ *
+ *	Gathering many events generates a lot of data, which requires memory and
+ *	processor time. It also makes the task of interpreting the data more
+ *	difficult. Because the amount of data that the instrumented framework
+ *	generates can be overwhelming, the RKH supports several types of filters
+ *	that can use it to reduce the amount of data to be processed. The
+ *	available events are enumerated in RKH_TE_<group>_<event> definitions.
+ *
+ *  \param[in] ctrl		filter option, the available options are FILTER_ON or
+ *                      FILTER_OFF.
+ *  \param[in] evt		trace event. The available events are enumerated in
+ *                      RKH_TE_<group>_<event> definitions.
+ *
+ *  \usage
+ *  \code
+ *  void
+ *  some_function(...)
+ *  {
+ *      RKH_FILTER_OFF_EVENT(RKH_TE_MP_INIT);
+ *      RKH_FILTER_OFF_EVENT(RKH_TE_SMA_DCH);
+ *      RKH_FILTER_OFF_EVENT(RKH_TE_FWK_OBJ);
+ *      RKH_FILTER_OFF_EVENT(RKH_TE_FWK_SIG);
+ *      RKH_FILTER_OFF_EVENT(RKH_TE_TMR_START);
+ *      RKH_FILTER_OFF_EVENT(RKH_TE_TMR_TOUT);
+ *      ...
+ *	}
+ *  \endcode
+ *
+ *	\note
+ *  This function is internal to RKH and the user application should not call
+ *  it. Please use RKH_FILTER_ON_EVENT(), or RKH_FILTER_OFF_EVENT() macros
+ *  instead.
+ */
+void rkh_trc_filter_event_(rui8_t ctrl, RKH_TE_ID_T evt);
+
+/**
+ *  \brief
+ *  Test the group and event filter condition.
+ *
+ *  \param[in] e	trace event ID. The available events are enumerated in
+ *                  RKH_TE_<group>_<event> definitions.
+ *
+ *	\return
+ *  '1' (RKH_TRUE) if the group and event is not filtered,
+ *  otherwise '0' (RKH_FALSE).
+ *
+ *	\note
+ *  This function is internal to RKH and the user application should not call
+ *  it.
+ */
+rbool_t rkh_trc_isoff_(RKH_TE_ID_T e);
+
+/**
+ *  \brief
+ *  Emmit or suppresse trace events related to a particular active
+ *  object or event signal.
+ *
+ *  \param[in] fd    	filter type.
+ *  \param[in] slot		indicates the filter slot to be applied.
+ *  \param[in] mode		filter option, the available options are FILTER_ON or
+ *                      FILTER_OFF.
+ *
+ *	\note
+ *  This function is internal to RKH and the user application should not call
+ *  it. Please use RKH_FILTER_ON_SMA()/RKH_FILTER_ON_SIGNAL(), or
+ *  RKH_FILTER_OFF_SMA()/RKH_FILTER_OFF_SIGNAL() macros instead.
+ */
+void rkh_trc_symFil(RKHFilter fd, RKH_TRC_FSLOT slot, rui8_t mode);
+
+/**
+ *  \brief
+ *  Test the active objecto or signal filter condition.
+ *
+ *  \param[in] fd    	filter type.
+ *  \param[in] slot		indicates the filter slot to be applied.
+ *
+ *	\return
+ *  '1' (RKH_TRUE) if the group and event is not filtered,
+ *  otherwise '0' (RKH_FALSE).
+ *
+ *	\note
+ *  This function is internal to RKH and the user application should not call
+ *  it.
+ */
+rbool_t rkh_trc_symFil_isoff(RKHFilter fd, RKH_TRC_FSLOT slot);
+
+/**
+ *  \brief
+ *  Get a memory reference to every trace filter table.
+ *
+ *  \param[out] outFilterTbl   pointer to every filter table.
+ */
+void rkh_trc_filter_get(RKH_FilterTbl *outFilterTbl);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtrc.h ./rkh/inc/rkhtrc.h
--- a_qSC69Z/rkh/inc/rkhtrc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtrc.h	2018-01-19 23:55:11.004319089 -0300
@@ -0,0 +1,270 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc.h
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *
+ *  <EM>RKH trace event structure</EM>
+ *
+ *	\code
+ *	(1) RKH_TRC_BEGIN(trc_evt, ao_prio, signal)	\
+ *	(2)		RKH_TRC_ARG0(arg0);                   \
+ *	(3)		RKH_TRC_ARG1(arg1);                   \
+ *	(4)		RKH_TRC_....(...);                    \
+ *	(5)	RKH_TRC_END()
+ *	\endcode
+ *
+ *	\li (1,5)	Each trace event always begins with the macro 
+ *	            RKH_TRC_BEGIN() and ends with the matching macro 
+ *	            RKH_TRC_END(). These macros are not terminated with the 
+ *	            semicolon. The record-begin macro RKH_TRC_BEGIN() takes 
+ *	            three arguments.
+ *			    The first argument 'trc_evt' is the trace event ID, the
+ *			    second argument 'ao_prio' is the active object priority,
+ *			    and the third argument 'signal' is the event signal number.
+ *			    These arguments are used in the on/off filters.
+ *			    The runtime filter is optional and could be enabled or
+ *			    disabled with the #RKH_CFG_TRC_RTFIL_EN in the
+ *			    \b rkhcfg.h file. This pair of macros locks interrupts at
+ *			    the beginning and unlocks at the end of each record.
+ *	\li (2-4)   Sandwiched between these two macros are the
+ *				argument-generating macros that actually insert individual
+ *				event argument elements into the trace stream.
+ *
+ *  Example:
+ *
+ *	\code
+ *	#define RKH_TR_QUE_INIT(q, ao, nelem) \
+ *				RKH_TRC_BEGIN_WOAOSIG(RKH_TE_QUE_INITS) \
+ *					RKH_TRC_SYM(q); \
+ *					RKH_TRC_SYM(ao); \
+ *					RKH_TRC_NE(nelem); \
+ *				RKH_TRC_END()
+ *
+ *  #define RKH_TR_SMA_FIFO(actObj_, evt_, sender_, poolID_, refCntr_, \
+ *                          nElem_, nMin_) \
+ *      RKH_TRC_BEGIN_NOCRIT(RKH_TE_SMA_FIFO, \
+ *                           RKH_SMA_ACCESS_CONST(actObj_, prio), \
+ *                          (evt_)->e) \
+ *          RKH_TRC_SYM(actObj_); \
+ *          RKH_TRC_SIG((evt_)->e); \
+ *          RKH_TRC_SNDR(sender_); \
+ *          RKH_TRC_UI8(poolID_); \
+ *          RKH_TRC_UI8(refCntr_); \
+ *          RKH_TRC_NE(nElem_); \
+ *          RKH_TRC_QUE_NMIN(nMin_); \
+ *      RKH_TRC_END_NOCRIT()
+ *	\endcode
+ *
+ *	Each trace event and its arguments are placed in the trace stream like a
+ *	simple data protocol frame. The protocol has been specifically designed
+ *	to simplify the data management overhead in the target yet allow
+ *	detection of any data dropouts due to the trace buffer overruns.
+ *	The protocol has not only provisions for detecting gaps in the data and
+ *	other errors but allows for instantaneous resynchronization after any
+ *	error, to minimize data loss. [MS]
+ *
+ *	\a Frame
+ *
+ *  \code
+ *      | ...               |
+ *  (1) | event ID          | 1,2,4-byte
+ *  (2) | sequence number   | 1-byte
+ *  (3) | timestamp         | 2,4-bytes
+ *  (4) | args              | n-byte
+ *  (5) | checksum          | 1-byte
+ *  (6) | flag              | 1-byte
+ *      | ...               |
+ *	\endcode
+ *
+ *	-   (1) Each frame starts with the <B>trace event ID</B> bytes, which is
+ *		one of the predefined RKH records or an application-specific record.
+ *	-   (2) Following the <B>sequence number</B> is the sequence number 
+ *	        byte.
+ *		    The target component increments this number for every frame 
+ *		    inserted into the stream. The sequence number allows the 
+ *		    trazer tool to detect any data discontinuities. If the 
+ *		    #RKH_CFG_TRC_NSEQ_EN is set to 1 then RKH will add to the 
+ *		    trace record the sequence number.
+ *	-	(3) Following the sequence number is the <B>timestamp</B>. The 
+ *	        number of bytes used by the timestamp is configurable by the 
+ *	        macro #RKH_CFGPORT_TRC_SIZEOF_TSTAMP.
+ *		    If the #RKH_CFG_TRC_TSTAMP_EN is set to 1 then RKH will add to 
+ *		    the trace record the timestamp field.
+ *	-   (4) Following the timestamp is zero or more data bytes for
+ *		    <B>args</B>.
+ *	-   (5) Following the data is the <B>checksum</B> byte. The checksum is
+ *		computed over the sequence number, the trace event ID, and all the
+ *		data bytes.
+ *		If the #RKH_CFG_TRC_CHK_EN is set to 1 then RKH will add to the 
+ *		trace record a checksum byte.
+ *	-   (6) Following the checksum is the <B>flag</B> byte, which delimits
+ *		the frame. The flag is the 0x7E. Only one flag is inserted between
+ *		frames.
+ *
+ *	To avoid confusing unintentional flag bytes that can naturally occur in
+ *	the data stream with an intentionally sent flag, the protocol uses a
+ *	technique known as byte stuffing or escaping to make the flag bytes
+ *	transparent during the transmission.
+ *	Whenever the transmitter encounters a flag byte in the data, it inserts
+ *	a 2-byte escape sequence to the output stream. The first byte is the
+ *	escape byte, defined as binary 0x7D. The second byte is the original
+ *	byte XOR-ed with 0x20.
+ *	The transmitter computes the checksum over the sequence number, the
+ *	trace event ID, and all data bytes before performing any byte stuffing.
+ *
+ *  <em>User trace events</em>
+ *
+ *  The user application could defined its own trace events to be placed
+ *  at anywhere in the application level. Allowing to generate tracing
+ *  information from the application-level code like a "printf" but with
+ *  much less overhead.
+ *
+ *	\code
+ *	(1) RKH_TRC_USR_BEGIN(MY_TRACE)	\
+ *	(2)		RKH_TRC_ARG0(arg0); \
+ *	(3)		RKH_TRC_ARG1(arg1); \
+ *	(4)		RKH_TRC_....(...); \
+ *	(5)	RKH_TRC_USR_END();
+ *	\endcode
+ *
+ *	\li (1,5)	Each trace event always begins with the macro
+ *				RKH_TRC_USR_BEGIN() and ends with the matching macro
+ *				RKH_TRC_USR_END(). The record-begin macro 
+ *				RKH_TRC_USR_BEGIN() takes one argument, 'eid_' is the 
+ *				user trace event ID, from the RKH_TE_USER value. This pair 
+ *				of macros locks interrupts at the beginning and unlocks at 
+ *				the end of each record.
+ *	\li (2-4)   Sandwiched between these two macros are the
+ *				argument-generating macros that actually insert individual
+ *				event argument elements into the trace stream.
+ *
+ *	Argument-generating macros for building user trace events:
+ *
+ *	\li RKH_TUSR_I8()   \copydoc RKH_TUSR_I8
+ *	\li RKH_TUSR_UI8()  \copydoc RKH_TUSR_UI8
+ *	\li RKH_TUSR_I16()  \copydoc RKH_TUSR_I16
+ *	\li RKH_TUSR_UI16() \copydoc RKH_TUSR_UI16
+ *	\li RKH_TUSR_I32()  \copydoc RKH_TUSR_I32
+ *	\li RKH_TUSR_UI32() \copydoc RKH_TUSR_UI32
+ *	\li RKH_TUSR_X32()  \copydoc RKH_TUSR_X32
+ *	\li RKH_TUSR_STR()  \copydoc RKH_TUSR_STR
+ *	\li RKH_TUSR_MEM()  \copydoc RKH_TUSR_MEM
+ *	\li RKH_TUSR_OBJ()  \copydoc RKH_TUSR_OBJ
+ *	\li RKH_TUSR_FUN()  \copydoc RKH_TUSR_FUN
+ *	\li RKH_TUSR_SIG()  \copydoc RKH_TUSR_SIG
+ *
+ *  Example:
+ *
+ *	\code
+ *	enum
+ *	{
+ *		LOWPWR_USR_TRACE = RKH_TE_USER,
+ *		DISCONNECTED_USR_TRACE
+ *		...
+ *	};
+ *
+ *	void
+ *	some_function(...)
+ *	{
+ *		rui8_t d1 = 255;
+ *		rui16_t d2 = 65535;
+ *		rui32_t d3 = 65535;
+ *		char *str = "hello";
+ *
+ *		RKH_TRC_USR_BEGIN(LOWPWR_USR_TRACE)
+ *			RKH_TUSR_I8(3, d1);
+ *			RKH_TUSR_UI8(3, d1);
+ *			RKH_TUSR_I16(4, d2);
+ *			RKH_TUSR_UI16(4, d2);
+ *			RKH_TUSR_I32(5, d3);
+ *			RKH_TUSR_UI32(5, d3);
+ *			RKH_TUSR_X32(4, d3);
+ *			RKH_TUSR_STR(str);
+ *			RKH_TUSR_MEM((rui8_t*)&d3, sizeof(rui32_t));
+ *			RKH_TUSR_OBJ(my);
+ *			RKH_TUSR_FUN(main);
+ *			RKH_TUSR_SIG(ZERO);
+ *		RKH_TRC_USR_END();
+ *	}
+ *	\endcode
+ *
+ *	\sa RKH_TRC_END()
+ *  \ingroup    apiTrc
+ *
+ *  \addtogroup api
+ *  @{
+ *  \addtogroup apiTrc Trace
+ *  @{@}
+ *  @}
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTRC_H__
+#define __RKHTRC_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtrc_out.h ./rkh/inc/rkhtrc_out.h
--- a_qSC69Z/rkh/inc/rkhtrc_out.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtrc_out.h	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,285 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_out.h
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    apiTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTRC_OUT_H__
+#define __RKHTRC_OUT_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_define.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/**
+ *  \brief
+ *	Open the tracing session.
+ *
+ *	This function is application-specific and the user needs to
+ *	define it. At a minimum, this function must initialize and/or
+ *	configure the trace stream by calling rkh_trc_init() and
+ *	RKH_TRC_SEND_CFG() respectively.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application
+ *  should not call it. Instead, use #RKH_TRC_OPEN() macro.
+ *
+ *  \sa \b rkhtrc.h file.
+ *
+ *	\usage
+ *
+ *	\code
+ *	#define BSP_SIZEOF_TS		32u
+ *	#define BSP_TS_RATE_HZ		CLOCK_PER_SEC
+ *
+ *	void
+ *	rkh_trc_open( void )
+ *	{
+ *		rkh_trc_init();
+ *
+ *		FTBIN_OPEN();
+ *		TCP_TRACE_OPEN();
+ *		RKH_TRC_SEND_CFG( BSP_SIZEOF_TS, BSP_TS_RATE_HZ );
+ *
+ *		if(( idle_thread = CreateThread( NULL, 1024,
+ *				&idle_thread_function, (void *)0,
+ *				CREATE_SUSPENDED, NULL )) == (HANDLE)0 )
+ *			fprintf( stderr, "Cannot create the thread: [%d]
+ *													line from %s "
+ *				"file\n", __LINE__, __FILE__ );
+ *	}
+ *	\endcode
+ *
+ *	\ingroup apiBSPTrc
+ */
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    #define RKH_TRC_OPEN()      rkh_trc_open()
+#else
+    #define RKH_TRC_OPEN()      (void)0
+#endif
+
+/**
+ *  \brief
+ *	Close the tracing session.
+ *
+ *	This function is application-specific and the user needs to
+ *	define it.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application
+ *  should not call it. Instead, use #RKH_TRC_CLOSE() macro.
+ *
+ *  \sa \b rkhtrc.h file.
+ *
+ *	\usage
+ *
+ *	\code
+ *	void
+ *	rkh_trc_close( void )
+ *	{
+ *		fclose( fdbg );
+ *	}
+ *	\endcode
+ *
+ *	\ingroup apiBSPTrc
+ */
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    #define RKH_TRC_CLOSE()     rkh_trc_close()
+#else
+    #define RKH_TRC_CLOSE()     (void)0
+#endif
+
+/**
+ *  \brief
+ *	Platform-dependent macro flushing the trace stream.
+ *
+ *	This function is application-specific and the user needs to define
+ *	it. When the RKH trace an event, all the information related to it
+ *	has to be stored somewhere before it can be retrieved, in order to
+ *	be analyzed.
+ *  This place is a trace stream. Frequently, events traced are stored
+ *  in the stream until it is flushed.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it. Instead, use #RKH_TRC_FLUSH() macro.
+ *
+ *  \sa \b rkhtrc.h file.
+ *
+ *	\usage
+ *	\code
+ *  void
+ *  rkh_trc_flush( void )
+ *  {
+ *      rui8_t *blk;
+ *      TRCQTY_T nbytes;
+ *      RKH_SR_ALLOC();
+ *
+ *      FOREVER
+ *      {
+ *          nbytes = (TRCQTY_T)1024;
+ *
+ *          RKH_ENTER_CRITICAL_();
+ *          blk = rkh_trc_get_block( &nbytes );
+ *          RKH_EXIT_CRITICAL_();
+ *
+ *          if((blk != (rui8_t *)0))
+ *          {
+ *              FTBIN_FLUSH( blk, nbytes );
+ *              TCP_TRACE_SEND_BLOCK( blk, nbytes );
+ *          }
+ *          else
+ *              break;
+ *      }
+ *  }
+ *	\endcode
+ *
+ *	\ingroup apiBSPTrc
+ */
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    #define RKH_TRC_FLUSH()     rkh_trc_flush()
+#else
+    #define RKH_TRC_FLUSH()     (void)0
+#endif
+
+/**
+ *  \brief
+ *  Send the trace facility configuration to host application software
+ *  Trazer.
+ *
+ *  Trazer is designed to work with all possible target CPU, which
+ *  requires a wide range of configurability. For example, for any
+ *  given target CPU, Trazer must "know" the size of object pointers,
+ *  event size, timestamp size and so on. This configurations could be
+ *  provided through "trazer.cfg" file in the host or invoking
+ *  RKH_TRC_SEND_CFG() macro from the application-specific
+ *  rkh_trc_open() function.
+ *
+ *  \param[in] ts_hz		clocks per second of trace timestamp.
+ *
+ *  \note
+ *	Frequently, this macro is called from the rkh_trc_open() function,
+ *	which is provided by user application program, more specifically
+ *	the board support package (BSP).
+ *
+ *  \sa RKH_TRC_OPEN() macro.
+ *
+ *	\ingroup apiBSPTrc
+ */
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    #define RKH_TRC_SEND_CFG(ts_hz) \
+        RKH_TR_FWK_TCFG(ts_hz)
+#else
+    #define RKH_TRC_SEND_CFG(ts_hz)     (void)0
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Open the tracing session.
+ *
+ *	\ingroup apiBSPTrc
+ */
+void rkh_trc_open(void);
+
+/**
+ *  \brief
+ *	Close the tracing session.
+ *
+ *	\ingroup apiBSPTrc
+ */
+void rkh_trc_close(void);
+
+/**
+ *  \brief
+ *	Platform-dependent macro flushing the trace stream.
+ *
+ *	\ingroup apiBSPTrc
+ */
+void rkh_trc_flush(void);
+
+/**
+ *  \brief
+ *	Retrieves a timestamp to be placed in a trace event.
+ *
+ *	This function is application-specific and the user needs to define it.
+ *	The data returned is defined in compile-time by means of
+ *	RKH_SIZEOF_TSTAMP.
+ *
+ *  \return     Timestamp (RKH_TS_T data type).
+ *
+ *  \sa \b rkhtrc.h file.
+ *
+ *  \usage
+ *	\code
+ *	RKH_TS_T
+ *	rkh_trc_getts( void )
+ *	{
+ *		return ( RKH_TS_T )clock();
+ *	}
+ *	\endcode
+ *
+ *	\ingroup apiBSPTrc
+ */
+RKH_TS_T rkh_trc_getts(void);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtrc_record.h ./rkh/inc/rkhtrc_record.h
--- a_qSC69Z/rkh/inc/rkhtrc_record.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtrc_record.h	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,2146 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_record.h
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    apiTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTRC_RECORD_H__
+#define __RKHTRC_RECORD_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_stream.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    /* --- Memory Pool (MP) ------------------------------------------------ */
+    #if RKH_CFG_TRC_ALL_EN == RKH_ENABLED || \
+        RKH_CFG_TRC_MP_EN == RKH_ENABLED
+        /**
+         *  \addtogroup trc
+         *  @{
+         *  \addtogroup traceMP Traces of memory pool services
+         *  @{
+         *  \brief      Macros for tracing the memory pool execution
+         */
+
+        /**
+         *  \brief
+         *  \copybrief rkh_memPool_init
+         *
+         *  \description    Initialize a memory block pool
+         *  \trcGroup       RKH_TG_MP
+         *  \trcEvent       RKH_TE_MP_INIT
+         *
+         *  \param[in] memPool_     Memory pool
+         *  \param[in] nBlocks_     Total number of blocks in bytes
+         *  \param[in] blockSize_   Maximum block size in bytes
+         */
+        #define RKH_TR_MP_INIT(memPool_, nBlocks_, blockSize_) \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_MP_INIT) \
+                RKH_TRC_SYM(memPool_); \
+                RKH_TRC_NBLK(nBlocks_); \
+                RKH_TRC_BSIZE(blockSize_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_memPool_get
+         *
+         *  \description    Get a block from the pool
+         *  \trcGroup       RKH_TG_MP
+         *  \trcEvent       RKH_TE_MP_GET
+         *
+         *  \param[in] memPool_     Memory pool
+         *  \param[in] nFree_       Number of free blocks remaining
+         *  \param[in] nMin_        Minimum number of free blocks ever in 
+         *                          this pool, i.e. holds the lowest 
+         *                          number of free blocks ever present in 
+         *                          the pool.
+         */
+        #define RKH_TR_MP_GET(memPool_, nFree_, nMin_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_MP_GET) \
+                RKH_TRC_SYM(memPool_); \
+                RKH_TRC_NBLK(nFree_); \
+                RKH_TRC_MP_NMIN(nMin_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_memPool_put
+         *
+         *  \description    Put the block to the pool
+         *  \trcGroup       RKH_TG_MP
+         *  \trcEvent       RKH_TE_MP_PUT
+         *
+         *  \param[in] memPool_     Memory pool
+         *  \param[in] nFree_       Number of free blocks remaining
+         */
+        #define RKH_TR_MP_PUT(memPool_, nFree_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_MP_PUT) \
+                RKH_TRC_SYM(memPool_); \
+                RKH_TRC_NBLK(nFree_); \
+            RKH_TRC_END_NOCRIT()
+
+        /** @} doxygen end group definition */
+        /** @} doxygen end group definition */
+    #else
+        #define RKH_TR_MP_INIT(memPool_, nBlocks_, blockSize_)  (void)0
+        #define RKH_TR_MP_GET(memPool_, nFree_, nMin_)          (void)0
+        #define RKH_TR_MP_PUT(memPool_, nFree_)                 (void)0
+    #endif
+
+    /* --- Queue (QUE) ------------------------------------------------------ */
+    #if RKH_CFG_TRC_ALL_EN == RKH_ENABLED || RKH_CFG_TRC_QUE_EN == RKH_ENABLED
+        /**
+         *  \addtogroup trc
+         *  @{
+         *  \addtogroup traceQ Traces of event queue services
+         *  @{
+         *  \brief      Macros for tracing the event queue execution
+         */
+
+        /**
+         *  \brief
+         *	\copybrief rkh_queue_init
+         *
+         *  \description    Initialize a event queue
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_INIT
+         *
+         *  \param[in] queue_   Event queue
+         *  \param[in] actObj_  Associated active object that receives the 
+         *                      equeued events.
+         *  \param[in] nElem_   Storage size [in the units of void pointers]
+         */
+        #define RKH_TR_QUE_INIT(queue_, actObj_, nElem_) \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_QUE_INIT) \
+                RKH_TRC_SYM(queue_); \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_NE(nElem_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_queue_get
+         *
+         *  \description    Get and remove an element from a queue
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_GET
+         *
+         *  \param[in] queue_   Event queue
+         *  \param[in] nElem_   Number of elements currently in the queue
+         */
+        #define RKH_TR_QUE_GET(queue_, nElem_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_QUE_GET) \
+                RKH_TRC_SYM(queue_); \
+                RKH_TRC_NE(nElem_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_queue_put_fifo
+         *
+         *  \description    Puts an element on a queue in a FIFO manner
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_FIFO
+         *
+         *  \param[in] queue_   Event queue
+         *  \param[in] nElem_   Number of elements currently in the queue
+         *  \param[in] nMin_    Minimum number of free elements ever in 
+         *                      this queue
+         */
+        #define RKH_TR_QUE_FIFO(queue_, nElem_, nMin_) \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_QUE_FIFO) \
+                RKH_TRC_SYM(queue_); \
+                RKH_TRC_NE(nElem_); \
+                RKH_TRC_QUE_NMIN(nMin_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_queue_put_lifo
+         *
+         *  \description    Puts an element on a queue in a LIFO manner
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_LIFO
+         *
+         *  \param[in] queue_   Event queue
+         *  \param[in] nElem_   Number of elements currently in the queue
+         *  \param[in] nMin_    Minimum number of free elements ever in 
+         *                      this queue
+         */
+        #define RKH_TR_QUE_LIFO(queue_, nElem_, nMin_) \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_QUE_LIFO) \
+                RKH_TRC_SYM(queue_); \
+                RKH_TRC_NE(nElem_); \
+                RKH_TRC_QUE_NMIN(nMin_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  Queue is full.
+         *
+         *  \description    Queue is full
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_FULL
+         *
+         *  \param[in] queue_   Event queue
+         */
+        #define RKH_TR_QUE_FULL(queue_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_QUE_FULL) \
+                RKH_TRC_SYM(queue_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_queue_deplete
+         *
+         *  \description    Depletes a queue
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_DPT
+         *
+         *  \param[in] queue_   Event queue
+         */
+        #define RKH_TR_QUE_DPT(queue_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_QUE_DPT) \
+                RKH_TRC_SYM(queue_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  Get the last element from the queue
+         *
+         *  \description    Get the last element from the queue
+         *  \trcGroup       RKH_TG_QUE
+         *  \trcEvent       RKH_TE_QUE_GET_LAST
+         *
+         *  \param[in] queue_   Event queue
+         */
+        #define RKH_TR_QUE_GET_LAST(queue_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_QUE_GET_LAST)  \
+                RKH_TRC_SYM(queue_); \
+            RKH_TRC_END_NOCRIT()
+
+        /** @} doxygen end group definition */
+        /** @} doxygen end group definition */
+    #else
+        #define RKH_TR_QUE_INIT(queue_, actObj_, nElem_)     (void)0
+        #define RKH_TR_QUE_GET(queue_, nElem_)               (void)0
+        #define RKH_TR_QUE_FIFO(queue_, nElem_, nMin_)       (void)0
+        #define RKH_TR_QUE_LIFO(queue_, nElem_, nMin_)       (void)0
+        #define RKH_TR_QUE_FULL(queue_)                      (void)0
+        #define RKH_TR_QUE_DPT(queue_)                       (void)0
+        #define RKH_TR_QUE_GET_LAST(queue_)                  (void)0
+    #endif
+
+    /* --- State Machine Application (SMA) --------------------------------- */
+    #if RKH_CFG_TRC_ALL_EN == RKH_ENABLED || \
+        RKH_CFG_TRC_SMA_EN == RKH_ENABLED
+        /**
+         *  \addtogroup trc
+         *  @{
+         *  \addtogroup traceAO Traces of active objects
+         *  @{
+         *  \brief      Macros for tracing the active object execution
+         */
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_activate
+         *
+         *  \description    Activate an active object
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_ACT
+         *
+         *  \param[in] actObj_          Active object
+         *  \param[in] actObjPrio_      Active object priority
+         *  \param[in] actObjQueSize_   Size of active object queue
+         */
+        #define RKH_TR_SMA_ACT(actObj_, actObjPrio_, actObjQueSize_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SMA_ACT, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_UI8(actObjPrio_); \
+                RKH_TRC_UI8(actObjQueSize_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_terminate
+         *
+         *  \description    Terminate an active object
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_TERM
+         *
+         *  \param[in] actObj_   Active object
+         *  \param[in] actObjPrio_    Active object priority
+         */
+        #define RKH_TR_SMA_TERM(actObj_, actObjPrio_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SMA_TERM, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_UI8(actObjPrio_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  Get an event from the active object's queue.
+         *
+         *  \description    
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_GET
+         *
+         *  \param[in] actObj_      Get an event from the active object 
+         *                          queue
+         *  \param[in] evt_         Event signal
+         *  \param[in] poolID_      Pool ID (for dynamic events) 
+         *  \param[in] refCntr_     Reference count (for dynamic events)
+         *  \param[in] nElem_       Number of elements currently in the 
+         *                          queue
+         *  \param[in] nMin_        Minimum number of free elements ever 
+         *                          in this queue
+         */
+        #define RKH_TR_SMA_GET(actObj_, evt_, poolID_, refCntr_, \
+                               nElem_, nMin_) \
+            RKH_TRC_BEGIN(RKH_TE_SMA_GET, \
+                          RKH_SMA_ACCESS_CONST(actObj_, prio), (evt_)->e) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_UI8(poolID_); \
+                RKH_TRC_UI8(refCntr_); \
+                RKH_TRC_NE(nElem_); \
+                RKH_TRC_QUE_NMIN(nMin_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_post_fifo
+         *
+         *  \description    Send a event to SMA's queue in a FIFO manner
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_FIFO
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] evt_     Event signal
+         *  \param[in] sender_  Event sender
+         *  \param[in] poolID_  Pool ID (for dynamic events) 
+         *  \param[in] refCntr_ Reference count (for dynamic events)
+         *  \param[in] nElem_   Number of elements currently in the 
+         *                      queue
+         *  \param[in] nMin_    Minimum number of free elements ever 
+         *                      in this queue
+         */
+        #define RKH_TR_SMA_FIFO(actObj_, evt_, sender_, poolID_, refCntr_, \
+                                nElem_, nMin_) \
+            RKH_TRC_BEGIN_NOCRIT(RKH_TE_SMA_FIFO, \
+                                 RKH_SMA_ACCESS_CONST(actObj_, prio), \
+                                 (evt_)->e) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_SNDR(sender_); \
+                RKH_TRC_UI8(poolID_); \
+                RKH_TRC_UI8(refCntr_); \
+                RKH_TRC_NE(nElem_); \
+                RKH_TRC_QUE_NMIN(nMin_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_post_lifo
+         *
+         *  \description    Send a event to SMA's queue in a LIFO manner
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_LIFO
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] evt_     Event signal
+         *  \param[in] sender_  Event sender
+         *  \param[in] poolID_  Pool ID (for dynamic events) 
+         *  \param[in] refCntr_ Reference count (for dynamic events)
+         *  \param[in] nElem_   Number of elements currently in the 
+         *                      queue
+         *  \param[in] nMin_    Minimum number of free elements ever 
+         *                      in this queue
+         */
+        #define RKH_TR_SMA_LIFO(actObj_, evt_, sender_, poolID_, refCntr_, \
+                                nElem_, nMin_) \
+            RKH_TRC_BEGIN_NOCRIT(RKH_TE_SMA_LIFO, \
+                                 RKH_SMA_ACCESS_CONST(actObj_, prio), \
+                                 (evt_)->e) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_SNDR(sender_); \
+                RKH_TRC_UI8(poolID_); \
+                RKH_TRC_UI8(refCntr_); \
+                RKH_TRC_NE(nElem_); \
+                RKH_TRC_QUE_NMIN(nMin_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_register
+         *
+         *  \description    Register an active object
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_REG
+         *
+         *  \param[in] actObj_      Active object
+         *  \param[in] actObjPrio_  Active object priority
+         */
+        #define RKH_TR_SMA_REG(actObj_, actObjPrio_) \
+            RKH_TRC_BEGIN_WOSIG_NOCRIT(RKH_TE_SMA_REG, \
+                                       RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_UI8(actObjPrio_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_unregister
+         *
+         *  \description    Unregister an active object
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_UNREG
+         *
+         *  \param[in] actObj_      Active object
+         *  \param[in] actObjPrio_  Active object priority
+         */
+        #define RKH_TR_SMA_UNREG(actObj_, actObjPrio_) \
+            RKH_TRC_BEGIN_WOSIG_NOCRIT(RKH_TE_SMA_UNREG, \
+                                       RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_UI8(actObjPrio_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_defer
+         *
+         *  \description    Defer an event
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_DEFER
+         *
+         *  \param[in] queue_    Target queue to store deferred event
+         *  \param[in] evt_   Event
+         */
+        #define RKH_TR_SMA_DEFER(queue_, evt_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_SMA_DEFER) \
+                RKH_TRC_SYM(queue_); \
+                RKH_TRC_SIG((evt_)->e); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sma_recall
+         *
+         *  \description    Recall an event
+         *  \trcGroup       RKH_TG_SMA
+         *  \trcEvent       RKH_TE_SMA_RCALL
+         *
+         *  \param[in] actObj_   Active object
+         *  \param[in] evt_   Event
+         */
+        #define RKH_TR_SMA_RCALL(actObj_, evt_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_SMA_RCALL) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SIG((evt_)->e); \
+            RKH_TRC_END_NOCRIT()
+
+        /** @} doxygen end group definition */
+        /** @} doxygen end group definition */
+    #else
+        #define RKH_TR_SMA_ACT(actObj_, actObjPrio_, actObjQueSize_) \
+            (void)0
+        #define RKH_TR_SMA_TERM(actObj_, actObjPrio_) \
+            (void)0
+        #define RKH_TR_SMA_GET(actObj_, evt_, poolID_, refCntr_, nElem_, \
+                               nMin_) \
+            (void)0
+        #define RKH_TR_SMA_FIFO(actObj_, evt_, sender_, poolID_, \
+                                refCntr_, nElem_, nMin_) \
+            (void)0
+        #define RKH_TR_SMA_LIFO(actObj_, evt_, sender_, poolID_, \
+                                refCntr_, nElem_, nMin_) \
+            (void)0
+        #define RKH_TR_SMA_REG(actObj_, actObjPrio_) \
+            (void)0
+        #define RKH_TR_SMA_UNREG(actObj_, actObjPrio_) \
+            (void)0
+        #define RKH_TR_SMA_DEFER(queue_, evt_) \
+            (void)0
+        #define RKH_TR_SMA_RCALL(actObj_, evt_) \
+            (void)0
+    #endif
+
+    /* --- State machine (SM) ---------------------------------------------- */
+    #if RKH_CFG_TRC_ALL_EN == RKH_ENABLED || \
+        RKH_CFG_TRC_SM_EN == RKH_ENABLED
+        /**
+         *  \addtogroup trc
+         *  @{
+         *  \addtogroup traceSM Traces of state machine
+         *  @{
+         *  \brief      Macros for tracing the state machine execution
+         */
+        /**
+         *  \brief
+         *  \copybrief rkh_sm_init
+         *
+         *  \description    Initialize a state machine
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_INIT
+         *
+         *  \param[in] actObj_      Active object
+         *  \param[in] initState_   Initial state of state machine
+         */
+        #if RKH_CFG_TRC_SM_INIT_EN == RKH_ENABLED
+            #define RKH_TR_SM_INIT(actObj_, initState_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_INIT, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                    RKH_TRC_SYM(actObj_); \
+                    RKH_TRC_SYM(initState_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_INIT(actObj_, initState_)     (void)0
+        #endif
+
+        /**
+         *  \brief
+         *	\copybrief rkh_sm_clear_history
+         *
+         *  Desc    = clear history pseudostate\n
+         *  Group   = RKH_TG_SM\n
+         *  Id      = RKH_TE_SM_CLRH\n
+         *  Args	= actObj_, history pseudostate\n
+         *
+         *  \description    Clear a history pseudostate
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_CLRH
+         *
+         *  \param[in] actObj_      Active object
+         *  \param[in] history_     History pseudostate
+         */
+        #if RKH_CFG_TRC_SM_CLRH_EN == RKH_ENABLED
+            #define RKH_TR_SM_CLRH(actObj_, history_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_CLRH, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(history_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_CLRH(actObj_, history_)       (void)0
+        #endif
+
+        /**
+         *  \brief
+         *  \copybrief rkh_sm_dispatch
+         *
+         *  \description    Dispatch an event to a state machine
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_DCH
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] evt_     Dispatched event
+         *  \param[in] state_   Current state
+         */
+        #if RKH_CFG_TRC_SM_DCH_EN == RKH_ENABLED
+            #define RKH_TR_SM_DCH(actObj_, evt_, state_) \
+                RKH_TRC_BEGIN(RKH_TE_SM_DCH, \
+                              RKH_SMA_ACCESS_CONST(actObj_, prio), \
+                              (evt_)->e) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_SYM(state_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_DCH(actObj_, evt_, state_)   (void)0
+        #endif
+
+        /**
+         *  \brief
+         *	Source and target state of the transition. The target could be
+         *	either basic state, composite state or pseudostate.
+         *
+         *  \description    Source and target state of transition
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_TRN
+         *
+         *  \param[in] actObj_          Active object
+         *  \param[in] sourceState_     Source state
+         *  \param[in] targetState_     Target state
+         */
+        #if RKH_CFG_TRC_SM_TRN_EN == RKH_ENABLED
+            #define RKH_TR_SM_TRN(actObj_, sourceState_, targetState_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_TRN, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(sourceState_); \
+                RKH_TRC_SYM(targetState_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_TRN(actObj_, sourceState_, targetState_)           (void)0
+        #endif
+
+        /**
+         *  \brief
+         *	Legal, stable and final state of transition.
+         *
+         *  \description    Main target state of transition
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_STATE
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] state_   Target state of transition
+         */
+        #if RKH_CFG_TRC_SM_STATE_EN == RKH_ENABLED
+            #define RKH_TR_SM_STATE(actObj_, state_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_STATE, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(state_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_STATE(actObj_, state_)        (void)0
+        #endif
+
+        /**
+         *  \brief
+         *  Entered state.
+         *
+         *  \description    Entry state
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_ENSTATE
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] state_   Entry state
+         */
+        #if RKH_CFG_TRC_SM_ENSTATE_EN == RKH_ENABLED
+            #define RKH_TR_SM_ENSTATE(actObj_, state_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_ENSTATE, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(state_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_ENSTATE(actObj_, state_)      (void)0
+        #endif
+
+        /**
+         *  \brief
+         *  Exited state.
+         *
+         *  \description    Exit state
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_EXSTATE
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] state_   Exit state
+         */
+        #if RKH_CFG_TRC_SM_EXSTATE_EN == RKH_ENABLED
+            #define RKH_TR_SM_EXSTATE(actObj_, state_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_EXSTATE, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(state_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_EXSTATE(actObj_, state_)      (void)0
+        #endif
+
+        /**
+         *  \brief
+         *	Number of entry and exit states in transition.
+         *
+         *  \description    Number of entry and exit states in transition
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_NENEX
+         *
+         *  \param[in] actObj_      Active object
+         *  \param[in] nEnState_    Number of entry states  
+         *  \param[in] nExState_    Number of exit states
+         */
+        #if RKH_CFG_TRC_SM_NENEX_EN == RKH_ENABLED
+            #define RKH_TR_SM_NENEX(actObj_, nEnState_, nExState_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_NENEX, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_UI8(nEnState_); \
+                RKH_TRC_UI8(nExState_); \
+        RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_NENEX(actObj_, nEnState_, nExState_) \
+                (void)nEnState_
+        #endif
+
+        /**
+         *  \brief
+         *	Number of executed actions and segments of the transition.
+         *
+         *  \description    Number of executed actions in transition
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_NTRNACT
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] nta      Number of executed effect action 
+         *  \param[in] nts      Number of transition segments
+         */
+        #if RKH_CFG_TRC_SM_NTRNACT_EN == RKH_ENABLED
+            #define RKH_TR_SM_NTRNACT(actObj_, nta, nts) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_NTRNACT, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_UI8(nta); \
+                RKH_TRC_UI8(nts); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_NTRNACT(actObj_, nta, nts)    (void)0
+        #endif
+
+        /**
+         *  \brief
+         *	Destination state or pseudostate of a transition segment.
+         *
+         *  \description    Next vertex in a compound transition
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_TS_STATE
+         *
+         *  \param[in] actObj_  Active object
+         *  \param[in] state_   Target state of transition segment
+         */
+        #if RKH_CFG_TRC_SM_TS_STATE_EN == RKH_ENABLED
+            #define RKH_TR_SM_TS_STATE(actObj_, state_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_TS_STATE, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(state_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_TS_STATE(actObj_, state_)     (void)0
+        #endif
+
+        #if RKH_CFG_TRC_SM_PROCESS_EN == RKH_ENABLED
+
+        /**
+         *  \brief
+         *	The arrived event was succesfully processed and HSM resides in 
+         *	an allowed state
+         *
+         *  \description    The ocurred event was succesfully processed and 
+         *                  the state machine resides in a stable state
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_EVT_PROC
+         *
+         *  \param[in] actObj_   Active object
+         */
+        #define RKH_TR_SM_EVT_PROC(actObj_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_EVT_PROC, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *	The arrived event was't founded in the transition table.
+         *
+         *  \description    the arrived event was't founded in the 
+         *                  transition table
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_EVT_NFOUND
+         *
+         *  \param[in] actObj_   Active object
+         *  \param[in] evt_   Dispatched event 
+         */
+        #define RKH_TR_SM_EVT_NFOUND(actObj_, evt_) \
+            RKH_TRC_BEGIN(RKH_TE_SM_EVT_NFOUND, \
+                          RKH_SMA_ACCESS_CONST(actObj_, prio), \
+                          (evt_)->e) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_SIG((evt_)->e); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *	The transition was cancelled by guard function.
+         *
+         *  \description    The transition was cancelled by a guard 
+         *                  function 
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_GRD_FALSE
+         *
+         *  \param[in] actObj_   Active object
+         */
+        #define RKH_TR_SM_GRD_FALSE(actObj_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_GRD_FALSE, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *	The branch function returned a value not founded in the branch
+         *	table.
+         *
+         *  \description    The branch function returned a value not founded
+         *                  in the branch table
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_CND_NFOUND
+         *
+         *  \param[in] actObj_   Active object
+         */
+        #define RKH_TR_SM_CND_NFOUND(actObj_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_CND_NFOUND, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *	Unknown state.
+         *
+         *  \description    Unknown state
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_UNKN_STATE
+         *
+         *  \param[in] actObj_   Active object
+         */
+
+        #define RKH_TR_SM_UNKN_STATE(actObj_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_UNKN_STATE, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *	The transition exceeded the allowed hierarchical level.
+         *
+         *  \description    The transition exceeded the allowed hierarchical
+         *                  level
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_EX_HLEVEL
+         *
+         *  \param[in] actObj_   Active object
+         */
+        #define RKH_TR_SM_EX_HLEVEL(actObj_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_EX_HLEVEL, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *	The transition exceeded the allowed number of segments within a
+         *	compound transtion.
+         *
+         *  \description    The transition exceeded the allowed number of
+         *                  segments within a compound transtion
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_EX_TSEG
+         *
+         *  \param[in] actObj_   Active object
+         */
+        #define RKH_TR_SM_EX_TSEG(actObj_) \
+            RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_EX_TSEG, \
+                                RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+            RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_EVT_PROC(actObj_)             (void)0
+            #define RKH_TR_SM_EVT_NFOUND(actObj_, evt_)     (void)0
+            #define RKH_TR_SM_CND_NFOUND(actObj_)           (void)0
+            #define RKH_TR_SM_GRD_FALSE(actObj_)            (void)0
+            #define RKH_TR_SM_UNKN_STATE(actObj_)           (void)0
+            #define RKH_TR_SM_EX_HLEVEL(actObj_)            (void)0
+            #define RKH_TR_SM_EX_TSEG(actObj_)              (void)0
+        #endif
+
+        /**
+         *  \brief
+         *	Executes a behavior (action) of state machine, it could be an 
+         *	entry, exit, effect, init, preprocessor or guard.
+         *
+         *  \description    Executed behavior of state machine
+         *  \trcGroup       RKH_TG_SM
+         *  \trcEvent       RKH_TE_SM_EXE_ACT
+         *
+         *  \param[in] actionType_  Action type
+         *  \param[in] actObj_      Active object
+         *  \param[in] state_       State
+         *  \param[in] action_      Action
+         */
+        #if RKH_CFG_TRC_SM_EXE_ACT_EN == RKH_ENABLED
+            #define RKH_TR_SM_EXE_ACT(actionType_, actObj_, state_, action_) \
+                RKH_TRC_BEGIN_WOSIG(RKH_TE_SM_EXE_ACT, \
+                                    RKH_SMA_ACCESS_CONST(actObj_, prio)) \
+                RKH_TRC_UI8(actionType_); \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_SYM(state_); \
+                RKH_TRC_FUN(action_); \
+                RKH_TRC_END()
+        #else
+            #define RKH_TR_SM_EXE_ACT(actionType_, actObj_, state_, action_)     (void)0
+        #endif
+
+        /** @} doxygen end group definition */
+        /** @} doxygen end group definition */
+    #else
+        #define RKH_TR_SM_INIT(actObj_, initState_)     (void)0
+        #define RKH_TR_SM_CLRH(actObj_, history_)       (void)0
+        #define RKH_TR_SM_DCH(actObj_, evt_, state_)   (void)0
+        #define RKH_TR_SM_TRN(actObj_, sourceState_, targetState_) \
+            (void)0
+        #define RKH_TR_SM_STATE(actObj_, state_)        (void)0
+        #define RKH_TR_SM_ENSTATE(actObj_, state_)      (void)0
+        #define RKH_TR_SM_EXSTATE(actObj_, state_)      (void)0
+        #define RKH_TR_SM_NENEX(actObj_, nEnState_, nExState_) \
+            (void)0
+        #define RKH_TR_SM_NTRNACT(actObj_, nta, nts)    (void)0
+        #define RKH_TR_SM_TS_STATE(aaost)               (void)0
+        #define RKH_TR_SM_EVT_PROC(actObj_)             (void)0
+        #define RKH_TR_SM_EVT_NFOUND(actObj_, evt_)     (void)0
+        #define RKH_TR_SM_GRD_FALSE(actObj_)            (void)0
+        #define RKH_TR_SM_CND_NFOUND(actObj_)           (void)0
+        #define RKH_TR_SM_UNKN_STATE(actObj_)           (void)0
+        #define RKH_TR_SM_EX_HLEVEL(actObj_)            (void)0
+        #define RKH_TR_SM_EX_TSEG(actObj_)              (void)0
+        #define RKH_TR_SM_EXE_ACT(actionType_, actObj_, state_, action_) \
+            (void)0
+    #endif
+
+    /* --- Timer (TIM) ----------------------------------------------------- */
+    #if RKH_CFG_TRC_ALL_EN == RKH_ENABLED || \
+        RKH_CFG_TRC_TMR_EN == RKH_ENABLED
+        /**
+         *  \addtogroup trc
+         *  @{
+         *  \addtogroup traceTMR Traces of timer services
+         *  @{
+         *  \brief      Macros for tracing the timer execution
+         */
+        /**
+         *  \brief
+         *  \copybrief RKH_TMR_INIT
+         *
+         *  \description    Initialize a timer
+         *  \trcGroup       RKH_TG_TMR
+         *  \trcEvent       RKH_TE_TMR_INIT
+         *
+         *  \param[in] timer_    Timer
+         *  \param[in] signal_  Event to enqueued 
+         */
+        #define RKH_TR_TMR_INIT(timer_, signal_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_TMR_INIT) \
+                RKH_TRC_SYM(timer_); \
+                RKH_TRC_SIG(signal_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_tmr_start
+         *
+         *  \description    Start a timer
+         *  \trcGroup       RKH_TG_TMR
+         *  \trcEvent       RKH_TE_TMR_START
+         *
+         *  \param[in] timer_    Timer
+         *  \param[in] actObj_   Active object target
+         *  \param[in] nTicks_   Load in ticks
+         *  \param[in] period_  Period in ticks
+         */
+        #define RKH_TR_TMR_START(timer_, actObj_, nTicks_, period_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_TMR_START) \
+                RKH_TRC_SYM(timer_); \
+                RKH_TRC_SYM(actObj_); \
+                RKH_TRC_NTICK(nTicks_); \
+                RKH_TRC_NTICK(period_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_tmr_stop
+         *
+         *  \description    Stop a timer
+         *  \trcGroup       RKH_TG_TMR
+         *  \trcEvent       RKH_TE_TMR_STOP
+         *
+         *  \param[in] timer_    Timer
+         *  \param[in] nTicks_   Load in ticks
+         *  \param[in] period_  Period in ticks
+         */
+        #define RKH_TR_TMR_STOP(timer_, nTicks_, period_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_TMR_STOP) \
+                RKH_TRC_SYM(timer_); \
+                RKH_TRC_NTICK(nTicks_); \
+                RKH_TRC_NTICK(period_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  Timer expired.
+         *
+         *  \description    Timer has expired
+         *  \trcGroup       RKH_TG_TMR
+         *  \trcEvent       RKH_TE_TMR_TOUT
+         *
+         *  \param[in] timer_    Timer
+         *  \param[in] signal_  Event to enqueued 
+         *  \param[in] actObj_   Active object target
+         */
+        #define RKH_TR_TMR_TOUT(timer_, signal_, actObj_) \
+            RKH_TRC_BEGIN_NOCRIT(RKH_TE_TMR_TOUT, \
+                                 RKH_SMA_ACCESS_CONST(actObj_, prio), \
+                                 signal_) \
+                RKH_TRC_SYM(timer_); \
+                RKH_TRC_SIG(signal_); \
+                RKH_TRC_SYM(actObj_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *	Removes timer from the active timer list.
+         *
+         *  \description    Remove timer from the active timer list
+         *  \trcGroup       RKH_TG_TMR
+         *  \trcEvent       RKH_TE_TMR_REM
+         *
+         *  \param[in] timer_    Timer
+         */
+        #define RKH_TR_TMR_REM(timer_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_TMR_REM) \
+                RKH_TRC_SYM(timer_); \
+            RKH_TRC_END_NOCRIT()
+
+        /** @} doxygen end group definition */
+        /** @} doxygen end group definition */
+    #else
+        #define RKH_TR_TMR_INIT(timer_, signal_)                    (void)0
+        #define RKH_TR_TMR_START(timer_, actObj_, nTicks_, period_) (void)0
+        #define RKH_TR_TMR_STOP(timer_, nTicks_, period_)           (void)0
+        #define RKH_TR_TMR_TOUT(timer_, signal_, actObj_)           (void)0
+        #define RKH_TR_TMR_REM(timer_)                              (void)0
+    #endif
+
+    /* --- Framework (RKH) ------------------------------------------------- */
+    #if RKH_CFG_TRC_ALL_EN == RKH_ENABLED || \
+        RKH_CFG_TRC_FWK_EN == RKH_ENABLED
+        /**
+         *  \addtogroup trc
+         *  @{
+         *  \addtogroup traceFWK Traces of miscellaneous framework
+         *  @{
+         *  \brief Macros for tracing the framework execution
+         */
+        /**
+         *  \brief
+         *  \copybrief rkh_fwk_init
+         *
+         *  \description    Initialize the RKH framework
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_EN
+         */
+        #define RKH_TR_FWK_EN() \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_FWK_EN) \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_fwk_exit
+         *
+         *  \description    Terminate the RKH framework
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_EX
+         */
+        #define RKH_TR_FWK_EX() \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_FWK_EX) \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_fwk_epool_register
+         *
+         *  \description    Register an event pool
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_EPREG
+         *
+         *  \param[in] evtPool_     Event pool id
+         *  \param[in] storageSize_ Storage size
+         *  \param[in] evtSize_     Event size
+         *  \param[in] poolSize_    Total number of blocks
+         */
+        #define RKH_TR_FWK_EPREG(evtPool_, storageSize_, evtSize_, \
+                                 poolSize_) \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_FWK_EPREG) \
+                RKH_TRC_UI8(evtPool_); \
+                RKH_TRC_UI32(storageSize_); \
+                RKH_TRC_ES(evtSize_); \
+                RKH_TRC_NBLK(poolSize_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  \copybrief rkh_fwk_ae
+         *
+         *  \description    Allocate an event from pool
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_AE
+         *
+         *  \param[in] evtSize_ Event size
+         *  \param[in] evt_     Pointer to event object
+         *  \param[in] nUsed_   Current number of memory blocks used 
+         *  \param[in] nMin_    Lowest number of free blocks ever present 
+         *  \param[in] sender_  Pointer to the actor that request a memory
+         *                      block. It is not necessarily a pointer to
+         *                      an active object. In fact, if 
+         *                      RKH_ALLOC_EVT() is called from an 
+         *                      interrupt or other context, it can create 
+         *                      a unique object just to unambiguously 
+         *                      identify the publisher of the event.
+         */
+        #define RKH_TR_FWK_AE(evtSize_, evt_, nUsed_, nMin_, sender_) \
+            RKH_TRC_BEGIN_WOAOSIG(RKH_TE_FWK_AE) \
+                RKH_TRC_ES(evtSize_); \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_UI8((evt_)->pool - 1); \
+                RKH_TRC_UI8((evt_)->nref); \
+                RKH_TRC_NBLK(nUsed_); \
+                RKH_TRC_MP_NMIN(nMin_); \
+                RKH_TRC_SYM(sender_); \
+            RKH_TRC_END()
+
+        /**
+         *  \brief
+         *  Attempt to recycle an event.
+         *
+         *  \description    Attempt to recycle an event
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_GC
+         *
+         *  \param[in] evt_   Event
+         *  \param[in] poolID_  Event pool id
+         *  \param[in] refCnt_   Reference count
+         */
+        #define RKH_TR_FWK_GC(evt_, poolID_, refCnt_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_FWK_GC) \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_UI8(poolID_); \
+                RKH_TRC_UI8(refCnt_); \
+            RKH_TRC_END_NOCRIT()
+
+        /**
+         *  \brief
+         *  Effective recycling event.
+         *
+         *  \description    Effective recycling of event
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_GCR
+         *
+         *  \param[in] evt_     Pointer to event object
+         *  \param[in] nUsed_   Current number of memory blocks used 
+         *  \param[in] nMin_    Lowest number of free blocks ever present 
+         *  \param[in] sender_  Pointer to the actor that request a memory
+         *                      block. It is not necessarily a pointer to
+         *                      an active object. In fact, if 
+         *                      RKH_ALLOC_EVT() is called from an 
+         *                      interrupt or other context, it can create 
+         *                      a unique object just to unambiguously 
+         *                      identify the publisher of the event.
+         */
+        #define RKH_TR_FWK_GCR(evt_, nUsed_, nMin_, sender_) \
+            RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_FWK_GCR) \
+                RKH_TRC_SIG((evt_)->e); \
+                RKH_TRC_UI8((evt_)->pool - 1); \
+                RKH_TRC_UI8((evt_)->nref); \
+                RKH_TRC_NBLK(nUsed_); \
+                RKH_TRC_MP_NMIN(nMin_); \
+                RKH_TRC_SYM(sender_); \
+            RKH_TRC_END_NOCRIT()
+
+        /* --- Symbol entry table for objects -------------------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for memory object.
+         *
+         *  \description    Entry symbol table for memory object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] obj_  Object address
+         *
+         *  e.g.\n
+         *  Associates the address of the object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  ...
+         *  static int g_status;
+         *  static RKH_TMR_T tdll;
+         *
+         *  RKH_TR_FWK_OBJ(&g_status);
+         *  RKH_TR_FWK_OBJ(&tdll);
+         *  \endcode
+         */
+        #define RKH_TR_FWK_OBJ(obj_) \
+            do \
+            { \
+                static RKHROM char __o_n[] = # obj_; \
+                rkh_trc_obj(RKH_TE_FWK_OBJ, (rui8_t *)obj_, \
+                            __o_n); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for objects with name ---------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for memory object. Very similar to
+         *	RKH_TR_FWK_OBJ() but the name of object must be explicitely
+         *	defined.
+         *
+         *  \description    Entry symbol table for memory object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] obj_  Object address
+         *  \param[in] name_  Name of object
+         *
+         *	\note
+         *	This macro uses the same trace event that RKH_TR_FWK_OBJ().
+         *	Use when the object name is very long and the Trazer's view is
+         *	unclear.
+         *
+         *  e.g.\n
+         *  Associates the address of the object, in memory with a name.
+         *
+         *  \code
+         *  ...
+         *  RKH_TR_FWK_OBJ_NAME(&RKH_CAST(CLI_T, sma)->cli_utmr, "cliutmr");
+         *  \endcode
+         */
+        #define RKH_TR_FWK_OBJ_NAME(obj_, name_) \
+            do \
+            { \
+                rkh_trc_obj(RKH_TE_FWK_OBJ, (rui8_t *)obj_, name_); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for event signals -------------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for event signal.
+         *
+         *  \description    Entry symbol table for signal
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_SIG
+         *
+         *  \param[in] stateObj_  Signal
+         *
+         *  e.g.\n
+         *  Associates the numerical value of the event signal to the
+         *  symbolic name of the signal.
+         *
+         *  \code
+         *  // in the dedicated application header file resides the signal
+         *  // enumeration
+         *
+         *  enum
+         *  {
+         *      ...
+         *      PWR_FAIL,
+         *      PRESS_ENTER,
+         *      ...
+         *  };
+         *
+         *  // frequently, the macro RKH_TR_FWK_SIG() is used in the
+         *  // \b main.c file.
+         *
+         *  RKH_TR_FWK_SIG(PWR_FAIL);
+         *  RKH_TR_FWK_SIG(PRESS_ENTER);
+         *  \endcode
+         */
+        #define RKH_TR_FWK_SIG(stateObj_) \
+            do \
+            { \
+                static RKHROM char __s_n[] = # stateObj_; \
+                rkh_trc_sig(stateObj_, __s_n); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for functions ------------------------ */
+
+        /**
+         *  \brief
+         *	Entry symbol table for function object.
+         *
+         *  \description    Entry symbol table for function
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_FUN
+         *
+         *  \param[in] function_  Function address
+         *
+         *  e.g.\n
+         *  Associates the address of the function in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  // frequently, the macro RKH_TR_FWK_FUN() is used in the
+         *  // \b main.c file.
+         *
+         *  RKH_TR_FWK_FUN(my_init);
+         *  RKH_TR_FWK_FUN(set_x_1);
+         *  RKH_TR_FWK_FUN(set_x_2);
+         *  RKH_TR_FWK_FUN(set_x_3);
+         *  RKH_TR_FWK_FUN(set_y_0);
+         *  RKH_TR_FWK_FUN(dummy_exit);
+         *  ...
+         *  \endcode
+         */
+        #define RKH_TR_FWK_FUN(function_) \
+            do \
+            { \
+                static RKHROM char __f_n[] = #function_; \
+                rkh_trc_obj(RKH_TE_FWK_FUN, (rui8_t *)function_, \
+                            __f_n); \
+            } \
+            while (0)
+
+        /**
+         *  \brief
+         *  The function was executed.
+         *
+         *  \description    Executed function
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_EXE_FUN
+         *
+         *  \param[in] function_   Function address
+         *
+         *  Example:
+         *
+         *  \code
+         *  void
+         *  my_init(const void *sma)
+         *  {
+         *      CMY(sma)->x = CMY(sma)->y = 0;
+         *      RKH_TR_FWK_EXE_FUN(my_init);
+         *  }
+         *  \endcode
+         */
+        #define RKH_TR_FWK_EXE_FUN(function_) \
+            RKH_TRC_BEGIN_WOFIL(RKH_TE_FWK_EXE_FUN) \
+                RKH_TRC_FUN(function_); \
+            RKH_TRC_END_WOFIL()
+
+        /**
+         *  \brief
+         *  The function was synchronously executed. It is not explicitely
+         *  used by the RKH, instead it's frequently placed on application
+         *  source code.
+         *
+         *  \description    Function was synchronously executed
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_SYNC_EVT
+         *
+         *  \param[in] function_   Function address
+         *  \param[in] senderObj_  Sender object
+         *  \param[in] receiverObj_  Receiver object
+         *
+         *  Example:
+         *
+         *  \code
+         *  void
+         *  Gas_setCommandedFlow(Gas *me, unsigned int p_commandedFlow)
+         *  {
+         *      (void)pe;
+         *      Valve_setAperture(me->itsValve, 0);
+         *      RKH_TR_FWK_SYNC_EVT(Valve_setAperture, &itsGas, 
+         *                          me->itsValve);
+         *  }
+         *  \endcode
+         */
+        #define RKH_TR_FWK_SYNC_EVT(function_, senderObj_, receiverObj_) \
+            RKH_TRC_BEGIN_WOFIL(RKH_TE_FWK_SYNC_EVT) \
+                RKH_TRC_FUN(function_); \
+                RKH_TRC_SNDR(senderObj_); \
+                RKH_TRC_SNDR(receiverObj_); \
+            RKH_TRC_END_WOFIL()
+
+        /* --- Symbol entry table for user user-defined trace events --- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for user-defined trace events.
+         *
+         *  \description    Entry symbol table for user-defined trace events
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_TUSR
+         *
+         *  \param[in] __e  User trace event ID
+         *
+         *  e.g.\n
+         *  Associates the numerical value of the user-defined trace event 
+         *  to the symbolic name of that.
+         *
+         *  \code
+         *  ...
+         *  // frequently, the macro RKH_TR_FWK_TUSR() is used in the
+         *  // \b main.c file.
+         *
+         *	enum // define the user trace events
+         *	{
+         *		LOWPWR_USRT = RKH_TE_USER,
+         *		DISCONNECTED_USRT,
+         *		...
+         *	};
+         *
+         *  void
+         *  main(void)
+         *  {
+         *      RKH_TR_FWK_TUSR(LOWPWR_USRT);
+         *      RKH_TR_FWK_TUSR(DISCONNECTED_USRT);
+         *      ...
+         *  }
+         *  \endcode
+         */
+        #define RKH_TR_FWK_TUSR(__e) \
+            do \
+            { \
+                static RKHROM char __e_n[] = # __e; \
+                RKH_TRC_BEGIN_WOFIL(RKH_TE_FWK_TUSR) \
+                    RKH_TRC_TE_ID(EXTE(__e, RKH_TG_USR)); \
+                    RKH_TRC_STR(__e_n); \
+                    RKH_TRC_END_WOFIL() \
+                RKH_TRC_FLUSH(); \
+            } \
+            while (0)
+
+        /* --- Trace configuration ------------------------------------- */
+
+        /**
+         *  \brief
+         *	Send trace configuration to Trazer.
+         *
+         *  \description    Send trace configuration table to Trazer
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_TCFG
+         *
+         *  \param[in] timeStamp_    Trace timestamp in Hz [ticks per 
+         *                          second]
+         *
+         *  \note
+         *  The following table shows the format of RKH_TE_FWK_TCFG 
+         *  arguments.
+         *  The first column means ["byte index", "bit index":"# of 
+         *  bits"] in the data stream.
+         *
+         *  [byte_index:size in bits] \n
+         *  [ 0, 0:16] - RKH_VERSION_CODE \n
+         *  [ 2, 0: 1] - RKH_CFG_SMA_TRC_SNDR_EN \n
+         *  [ 2, 1: 1] - RKH_CFG_TRC_RTFIL_EN \n
+         *  [ 2, 2: 1] - RKH_CFG_TRC_USER_TRACE_EN \n
+         *  [ 2, 3: 1] - RKH_CFG_TRC_ALL_EN \n
+         *  [ 2, 4: 1] - RKH_CFG_TRC_MP_EN \n
+         *  [ 2, 5: 1] - RKH_CFG_TRC_QUE_EN \n
+         *  [ 2, 6: 1] - RKH_CFG_TRC_SMA_EN \n
+         *  [ 2, 7: 1] - RKH_CFG_TRC_TMR_EN \n
+         *  [ 3, 8: 1] - RKH_CFG_TRC_SM_EN \n
+         *  [ 3, 9: 1] - RKH_CFG_TRC_FWK_EN \n
+         *  [ 3,10: 1] - RKH_CFG_TRC_ASSERT_EN \n
+         *  [ 3,11: 1] - RKH_CFG_QUE_GET_LWMARK_EN \n
+         *  [ 3,12: 1] - RKH_CFG_MP_GET_LWM_EN \n
+         *  [ 3,13: 1] - RKH_CFG_TRC_RTFIL_SMA_EN \n
+         *  [ 3,14: 1] - RKH_CFG_TRC_RTFIL_SIGNAL_EN \n
+         *  [ 3,15: 1] - RKH_CFG_TRC_NSEQ_EN \n
+         *  [ 4,16: 1] - RKH_CFG_TRC_TSTAMP_EN \n
+         *  [ 4,17: 1] - RKH_CFG_TRC_CHK_EN \n
+         *  [ 4,18:14] - 0 (Reserved) \n
+         *  [ 6, 0: 4] - RKH_CFG_FWK_SIZEOF_EVT \n
+         *  [ 6, 4: 4] - RKH_CFGPORT_TRC_SIZEOF_TSTAMP \n
+         *  [ 7, 0: 4] - RKH_CFGPORT_TRC_SIZEOF_PTR \n
+         *  [ 7, 4: 4] - RKH_CFG_TMR_SIZEOF_NTIMER \n
+         *  [ 8, 0: 4] - RKH_CFG_MP_SIZEOF_NBLOCK \n
+         *  [ 8, 4: 4] - RKH_CFG_QUE_SIZEOF_NELEM \n
+         *  [ 9, 0: 4] - RKH_CFG_FWK_SIZEOF_EVT_SIZE \n
+         *  [ 9, 4: 4] - 0 (Reserved) \n
+         *  [10, 0: 4] - RKH_CFG_MP_SIZEOF_BSIZE \n
+         *  [10, 4: 4] - RKH_CFG_FWK_MAX_EVT_POOL \n
+         *  [11, 0:16] - Timestamp HZ (ticks per second)
+         */
+        #define RKH_TR_FWK_TCFG(timeStamp_) \
+            RKH_TRC_BEGIN_DFT(RKH_TE_FWK_TCFG) \
+                RKH_TRC_UI16((rui16_t)RKH_VERSION_CODE); \
+                RKH_TRC_UI32( \
+                    (rui32_t)( \
+                        ((rui32_t)RKH_CFG_SMA_TRC_SNDR_EN) | \
+                        ((rui32_t)RKH_CFG_TRC_RTFIL_EN << 1) | \
+                        ((rui32_t)RKH_CFG_TRC_USER_TRACE_EN << 2) | \
+                        ((rui32_t)RKH_CFG_TRC_ALL_EN << 3) | \
+                        ((rui32_t)RKH_CFG_TRC_MP_EN << 4) | \
+                        ((rui32_t)RKH_CFG_TRC_QUE_EN << 5) | \
+                        ((rui32_t)RKH_CFG_TRC_SMA_EN << 6) | \
+                        ((rui32_t)RKH_CFG_TRC_TMR_EN << 7) | \
+                        ((rui32_t)RKH_CFG_TRC_SM_EN << 8) | \
+                        ((rui32_t)RKH_CFG_TRC_FWK_EN << 9) | \
+                        ((rui32_t)RKH_CFG_TRC_ASSERT_EN << 10) | \
+                        ((rui32_t)RKH_CFG_QUE_GET_LWMARK_EN << 11) | \
+                        ((rui32_t)RKH_CFG_MP_GET_LWM_EN << 12) | \
+                        ((rui32_t)RKH_CFG_TRC_RTFIL_SMA_EN << 13) | \
+                        ((rui32_t)RKH_CFG_TRC_RTFIL_SIGNAL_EN << 14) | \
+                        ((rui32_t)RKH_CFG_TRC_NSEQ_EN << 15) | \
+                        ((rui32_t)RKH_CFG_TRC_TSTAMP_EN << 16) | \
+                        ((rui32_t)RKH_CFG_TRC_CHK_EN << 17))); \
+                RKH_TRC_UI8( \
+                    (rui8_t)((RKH_CFG_FWK_SIZEOF_EVT / 8 << 4) | \
+                             RKH_CFGPORT_TRC_SIZEOF_TSTAMP / 8)); \
+                RKH_TRC_UI8( \
+                    (rui8_t)((RKH_CFGPORT_TRC_SIZEOF_PTR / 8 << 4) | \
+                             RKH_CFG_TMR_SIZEOF_NTIMER / 8)); \
+                RKH_TRC_UI8( \
+                    (rui8_t)((RKH_CFG_MP_SIZEOF_NBLOCK / 8 << 4) | \
+                             RKH_CFG_QUE_SIZEOF_NELEM / 8)); \
+                RKH_TRC_UI8( \
+                    (rui8_t)(RKH_CFG_FWK_SIZEOF_EVT_SIZE / 8)); \
+                RKH_TRC_UI8( \
+                    (rui8_t)((RKH_CFG_MP_SIZEOF_BSIZE / 8 << 4) | \
+                             RKH_CFG_FWK_MAX_EVT_POOL)); \
+                RKH_TRC_UI16( \
+                    (rui16_t)(timeStamp_)); \
+            RKH_TRC_END_DFT() \
+            RKH_TRC_FLUSH()
+
+        /* --- Assertion ----------------------------------------------- */
+
+        /**
+         *  \brief
+         *	Assertion expression was evaluated to false.
+         *
+         *  \description    Assertion expression was evaluated to false
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_EXE_ASSERT
+         *
+         *  \param[in] mod_ Module name (*.c)
+         *  \param[in] ln_  Line of code
+         */
+        #if RKH_CFG_TRC_ASSERT_EN == RKH_ENABLED
+            #define RKH_TR_FWK_ASSERT(mod_, ln_) \
+                RKH_TRC_BEGIN_WOAOSIG_NOCRIT(RKH_TE_FWK_ASSERT) \
+                    RKH_TRC_STR((RKHROM char *)mod_); \
+                    RKH_TRC_UI16((rui16_t)ln_); \
+                    RKH_TRC_END_NOCRIT() \
+                RKH_TRC_FLUSH()
+        #else
+            #define RKH_TR_FWK_ASSERT(mod_, ln_)      (void)0
+        #endif
+
+        /* --- Symbol entry table for active objects ------------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for active object.
+         *
+         *  \description    Entry symbol table for active object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] actObj_ Active object address
+         *
+         *  e.g.\n
+         *  Associates the address of the active object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  ...
+         *  typedef struct
+         *  {
+         *      RKH_SMA_T actObj_;
+         *      rui8_t x;
+         *      rui8_t y;
+         *  } AO_T;
+         *
+         *  RKH_SMA_CREATE(AO_T, actObj_, 0, HCAL, &S1, ao_init, NULL);
+         *  RKH_TR_FWK_OBJ(&actObj_);
+         *  \endcode
+         */
+        #define RKH_TR_FWK_AO(actObj_) \
+            do \
+            { \
+                rkh_trc_ao((struct RKH_SMA_T *)actObj_); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for state objects -------------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for state object.
+         *
+         *  \description    Entry symbol table for state object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] actObj_ Active object address
+         *  \param[in] stateObj_ State object address
+         *
+         *  e.g.\n
+         *  Associates the address of the state object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  ...
+         *  RKH_CREATE_COMP_STATE(S1, en, ex, RKH_ROOT, &S11);
+         *  RKH_CREATE_TRANS_TABLE(S1)
+         *      RKH_TRINT(SIX,     NULL,       show_data),
+         *      RKH_TRREG(TWO,     NULL,       set_y_2,	&S2),
+         *  RKH_END_TRANS_TABLE
+         *
+         *  ...
+         *  RKH_TR_FWK_STATE(my, &S1);
+         *  \endcode
+         */
+        #define RKH_TR_FWK_STATE(actObj_, stateObj_) \
+            do \
+            { \
+                rkh_trc_state((struct RKH_SMA_T *)actObj_, \
+                              (rui8_t *)stateObj_); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for pseudostate objects -------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for pseudostate object.
+         *
+         *  \description    Entry symbol table for pseudostate object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] actObj_     Active object address
+         *  \param[in] pseudoStObj_    Pseudostate object address
+         *
+         *  e.g.\n
+         *  Associates the address of the pseudostate object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  ...
+         *  RKH_CREATE_COND_STATE(C1, 12);
+         *  RKH_CREATE_BRANCH_TABLE(C1)
+         *      RKH_BRANCH(y_1,    NULL,           &H),
+         *      RKH_BRANCH(y_2,    dummy_act,      &DH),
+         *      RKH_BRANCH(y_0,    NULL,           &S1),
+         *  RKH_END_BRANCH_TABLE
+         *
+         *  ...
+         *  RKH_TR_FWK_PSTATE(my, &C1);
+         *  \endcode
+         */
+        #define RKH_TR_FWK_PSTATE(actObj_, pseudoStObj_) \
+            do \
+            { \
+                rkh_trc_state((struct RKH_SMA_T *)actObj_, \
+                              (rui8_t *)pseudoStObj_); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for timer objects -------------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for timer object.
+         *
+         *  \description    Entry symbol table for timer object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] timerObj_ Timer object address
+         *
+         *  e.g.\n
+         *  Associates the address of the timer object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  ...
+         *  static RKH_TMR_T bky_tmr;
+         *
+         *  RKH_TR_FWK_TIMER(&bky_tmr);
+         *  \endcode
+         */
+        #define RKH_TR_FWK_TIMER(timerObj_) \
+            do \
+            { \
+                static RKHROM char __to_n[] = # timerObj_; \
+                rkh_trc_obj(RKH_TE_FWK_TIMER, (rui8_t *)timerObj_, \
+                            __to_n); \
+            } \
+            while (0)
+
+        /* --- Symbol entry table for event pool objects --------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for event pool object.
+         *
+         *  \description    Entry symbol table for event pool object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] poolId_   Event pool ID (index of event pool list)
+         *  \param[in] poolName_ String terminated in '\\0'.
+         *
+         *  e.g.\n
+         *  Associates the ID of the event pool, with a symbolic name.
+         *
+         *  \code
+         *	...
+         *	rkh_fwk_epool_register(ep0_sto,	SIZEOF_EP0STO,
+         *						   SIZEOF_EP0_BLOCK);
+         *	rkh_fwk_epool_register(ep1_sto, SIZEOF_EP1STO,
+         *						   SIZEOF_EP1_BLOCK);
+         *	rkh_fwk_epool_register(ep2_sto, SIZEOF_EP2STO,
+         *						   SIZEOF_EP2_BLOCK);
+         *
+         *  RKH_TR_FWK_EPOOL(0, "ep0");
+         *  RKH_TR_FWK_EPOOL(1, "ep1");
+         *  RKH_TR_FWK_EPOOL(2, "ep2");
+         *	...
+         *  \endcode
+         */
+        #define RKH_TR_FWK_EPOOL(poolId_, poolName_) \
+            RKH_TRC_BEGIN_WOFIL(RKH_TE_FWK_EPOOL) \
+                RKH_TRC_UI8(poolId_); \
+                RKH_TRC_STR(poolName_); \
+            RKH_TRC_END_WOFIL() \
+            RKH_TRC_FLUSH();
+
+        /* --- Symbol entry table for queue objects -------------------- */
+
+        /**
+         *  \brief
+         *	Entry symbol table for queue object.
+         *
+         *  \description    Entry symbol table for queue object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_OBJ
+         *
+         *  \param[in] queueObj_ Queue object address
+         *
+         *  e.g.\n
+         *  Associates the address of the queue object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  ...
+         *  #define QSTO_SIZE			4
+         *  static RKH_EVT_T *qsto[QSTO_SIZE];
+         *
+         *  ...
+         *  RKH_TR_FWK_QUEUE(&blinky->equeue);
+         *  rkh_sma_activate(blinky, (const RKH_EVT_T **)qsto,
+         *                   QSTO_SIZE, CV(0), 0);
+         *	...
+         *  \endcode
+         */
+        #define RKH_TR_FWK_QUEUE(queueObj_) \
+            do \
+            { \
+                static RKHROM char __qo_n[] = #queueObj_; \
+                rkh_trc_obj(RKH_TE_FWK_QUEUE, (rui8_t *)queueObj_, \
+                            __qo_n); \
+            } \
+            while (0)
+
+        /**
+         *  \brief
+         *	Entry symbol table for actor object.
+         *
+         *  \description    Entry symbol table for actor object
+         *  \trcGroup       RKH_TG_FWK
+         *  \trcEvent       RKH_TE_FWK_ACTOR
+         *
+         *  \param[in] actorObj_    Actor object address. Generally, it's 
+         *                          used for active object and ISR, i.e. 
+         *                          event producers.
+         *  \param[in] nm_          String terminated in '\\0'
+         *
+         *  e.g.\n
+         *  Associates the address of an actor object, in memory
+         *  with its symbolic name.
+         *
+         *  \code
+         *  RKH_TR_FWK_ACTOR(blinky, RKH_GET_AO_NAME(blinky));
+         *  ...
+         *  static int buttonManager;
+         *
+         *  RKH_TR_FWK_ACTOR(&buttonManager, "buttonManager");
+         *  \endcode
+         */
+        #define RKH_TR_FWK_ACTOR(actorObj_, nm_) \
+            do \
+            { \
+                rkh_trc_obj(RKH_TE_FWK_ACTOR, (rui8_t *)actorObj_, nm_); \
+            } \
+            while (0)
+
+        /** @} doxygen end group definition */
+        /** @} doxygen end group definition */
+    #else
+        #define RKH_TR_FWK_EN()                                     (void)0
+        #define RKH_TR_FWK_EX()                                     (void)0
+        #define RKH_TR_FWK_EPREG(evtPool_, storageSize_, evtSize_, \
+                                 poolSize_)                         (void)0
+        #define RKH_TR_FWK_AE(evtSize_, evt_, nUsed_, nMin_, sndr_) (void)0
+        #define RKH_TR_FWK_GC(evt_, poolID_, refCnt_)               (void)0
+        #define RKH_TR_FWK_GCR(evt_, nUsed_, nMin_, sndr_)          (void)0
+        #define RKH_TR_FWK_OBJ(obj_)                                (void)0
+        #define RKH_TR_FWK_OBJ_NAME(obj_, name_)                    (void)0
+        #define RKH_TR_FWK_SIG(stateObj_)                           (void)0
+        #define RKH_TR_FWK_FUN(stateObj_)                           (void)0
+        #define RKH_TR_FWK_EXE_FUN(function_)                       (void)0
+        #define RKH_TR_FWK_SYNC_EVT(function_, senderObj_, \
+                                    receiverObj_)                   (void)0
+        #define RKH_TR_FWK_TUSR(__e)                                (void)0
+        #define RKH_TR_FWK_TCFG(timeStamp_)                         (void)0
+        #define RKH_TR_FWK_ASSERT(mod_, ln_)                        (void)0
+        #define RKH_TR_FWK_AO(actObj_)                              (void)0
+        #define RKH_TR_FWK_STATE(actObj_, stateObj_)                (void)0
+        #define RKH_TR_FWK_PSTATE(actObj_, pseudoStObj_)            (void)0
+        #define RKH_TR_FWK_TIMER(timerObj_)                         (void)0
+        #define RKH_TR_FWK_EPOOL(evtPoolObj_)                       (void)0
+        #define RKH_TR_FWK_QUEUE(queueObj_)                         (void)0
+        #define RKH_TR_FWK_ACTOR(actObj_, nm_)                      (void)0
+    #endif
+#else
+    /* --- Memory Pool (MP) -------------------------------------------- */
+    #define RKH_TR_MP_INIT(mp, nb, bs)                (void)0
+    #define RKH_TR_MP_GET(mp, nfree, nmin)            (void)0
+    #define RKH_TR_MP_PUT(mp, nfree)                  (void)0
+
+    /* --- Queue (QUE) -------------------------------------------------- */
+    #define RKH_TR_QUE_INIT(q, ao, nelem)              (void)0
+    #define RKH_TR_QUE_GET(q, nelem)                   (void)0
+    #define RKH_TR_QUE_FIFO(q, nelem, nmin)            (void)0
+    #define RKH_TR_QUE_LIFO(q, nelem, nmin)            (void)0
+    #define RKH_TR_QUE_FULL(q)                         (void)0
+    #define RKH_TR_QUE_DPT(q)                          (void)0
+    #define RKH_TR_QUE_GET_LAST(q)                     (void)0
+
+    /* --- State Machine Application (SMA) ----------------------------- */
+    #define RKH_TR_SMA_ACT(ao, p, s)                  (void)0
+    #define RKH_TR_SMA_TERM(ao, p)                    (void)0
+    #define RKH_TR_SMA_GET(ao, ev, pid, rc, ne, nm)   (void)0
+    #define RKH_TR_SMA_FIFO(ao, ev, snr, pid, rc, ne, \
+                            nm)                       (void)0
+    #define RKH_TR_SMA_LIFO(ao, ev, snr, pid, rc, ne, \
+                            nm)                       (void)0
+    #define RKH_TR_SMA_REG(ao, actObjPrio_)           (void)0
+    #define RKH_TR_SMA_UNREG(ao, actObjPrio_)         (void)0
+    #define RKH_TR_SMA_DEFER(queue_, evt_)            (void)0
+    #define RKH_TR_SMA_RCALL(actObj_, evt_)           (void)0
+
+    /* --- State machine (SM) ------------------------------------------ */
+    #define RKH_TR_SM_INIT(ao, ist)                   (void)0
+    #define RKH_TR_SM_CLRH(ao, h)                     (void)0
+    #define RKH_TR_SM_DCH(ao, ev, st)                 (void)0
+    #define RKH_TR_SM_TRN(ao, sst, tst)               (void)0
+    #define RKH_TR_SM_STATE(ao, st)                   (void)0
+    #define RKH_TR_SM_ENSTATE(ao, st)                 (void)0
+    #define RKH_TR_SM_EXSTATE(ao, st)                 (void)0
+    #define RKH_TR_SM_NENEX(ao, nen, nex)             (void)0
+    #define RKH_TR_SM_NTRNACT(ao, nta, nts)           (void)0
+    #define RKH_TR_SM_TS_STATE(ao, st)                (void)0
+    #define RKH_TR_SM_EVT_PROC(ao)                    (void)0
+    #define RKH_TR_SM_EVT_NFOUND(ao, ev)              (void)0
+    #define RKH_TR_SM_GRD_FALSE(ao)                   (void)0
+    #define RKH_TR_SM_CND_NFOUND(ao)                  (void)0
+    #define RKH_TR_SM_UNKN_STATE(ao)                  (void)0
+    #define RKH_TR_SM_EX_HLEVEL(ao)                   (void)0
+    #define RKH_TR_SM_EX_TSEG(ao)                     (void)0
+    #define RKH_TR_SM_EXE_ACT(act_t, ao, st, act)     (void)0
+
+    /* --- Timer (TIM) ------------------------------------------------- */
+    #define RKH_TR_TMR_INIT(t, sig)                   (void)0
+    #define RKH_TR_TMR_START(t, ao, nt, per)          (void)0
+    #define RKH_TR_TMR_STOP(t, nt, per)               (void)0
+    #define RKH_TR_TMR_TOUT(t, sig, ao)               (void)0
+    #define RKH_TR_TMR_REM(t)                         (void)0
+
+    /* --- Framework (RKH) --------------------------------------------- */
+    #define RKH_TR_FWK_EN()                           (void)0
+    #define RKH_TR_FWK_EX()                           (void)0
+    #define RKH_TR_FWK_EPREG(ep, ss, es, poolSize_)   (void)0
+    #define RKH_TR_FWK_AE(es, ev, nUsed_, nMin_, \
+                          sndr_)                      (void)0
+    #define RKH_TR_FWK_GC(ev, pid, rc)                (void)0
+    #define RKH_TR_FWK_GCR(ev, nUsed_, nMin_, sndr_)  (void)0
+    #define RKH_TR_FWK_OBJ(__o)                       (void)0
+    #define RKH_TR_FWK_OBJ_NAME(__o, __n)             (void)0
+    #define RKH_TR_FWK_SIG(__s)                       (void)0
+    #define RKH_TR_FWK_FUN(__f)                       (void)0
+    #define RKH_TR_FWK_EXE_FUN(__f)                   (void)0
+    #define RKH_TR_FWK_SYNC_EVT(fn, snr, rcr)         (void)0
+    #define RKH_TR_FWK_TUSR(__e)                      (void)0
+    #define RKH_TR_FWK_TCFG(ts_hz)                    (void)0
+    #define RKH_TR_FWK_ASSERT(mod_, ln_)              (void)0
+    #define RKH_TR_FWK_AO(__ao)                       (void)0
+    #define RKH_TR_FWK_STATE(__ao, __so)              (void)0
+    #define RKH_TR_FWK_PSTATE(__ao, __pso)            (void)0
+    #define RKH_TR_FWK_TIMER(__to)                    (void)0
+    #define RKH_TR_FWK_EPOOL(__epo)                   (void)0
+    #define RKH_TR_FWK_QUEUE(__qo)                    (void)0
+    #define RKH_TR_FWK_ACTOR(actObj_, nm_)            (void)0
+#endif
+
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Initializes the RKH's trace record service.
+ *
+ *  \note
+ *  rkh_trc_init() is NOT protected with a critical section.
+ */
+void rkh_trc_init(void);
+
+/**
+ *  \brief
+ *  Store the trace record header in the stream.
+ *
+ *	- Trace event ID [n-bytes]. The number of bytes that it uses is specified 
+ *	by the size of RKH_TE_ID_T data type.
+ *
+ *	- Sequence number [1-byte]. If the RKH_CFG_TRC_NSEQ_EN is set to 1 then
+ *	RKH will add to the trace record an incremental number (1-byte), used
+ *	like a sequence number.
+ *
+ *	- Timestamp [1, 2 or 4 bytes]. If the RKH_CFG_TRC_TSTAMP_EN is set to 1
+ *	then RKH will add to the trace record a timestamp field. It's
+ *	configurable by means of RKH_CFGPORT_TRC_SIZEOF_TSTAMP.
+ *
+ *	\param[in] eid		trace event ID. The available events are
+ *                      enumerated in RKH_TE_<group>_<event> definitions.
+ *
+ *  \note
+ *	This function should be called indirectly through the macro
+ *	RKH_TRC_BEGIN.
+ */
+void rkh_trc_begin(RKH_TE_ID_T eid);
+
+/**
+ *  \brief
+ *  Terminate the recorded trace event.
+ *
+ *	This function inserts a the flag byte, which delimits the frame.
+ *	The flag is the 0x7E.
+ *
+ *  \note
+ *	This function should be called indirectly through the macro
+ *	RKH_TRC_END.
+ */
+void rkh_trc_end(void);
+
+/**
+ *  \brief
+ *  Clear to zero the trace record checksum.
+ *
+ *  \note
+ *	This function should be called indirectly through the macro
+ *	RKH_TRC_BEGIN_DFT().
+ */
+void rkh_trc_clear_chk(void);
+
+/**
+ *  \brief
+ *  Store a 8-bit data into the current trace event buffer without format
+ *  information.
+ *
+ *  \param[in] d		data
+ */
+void rkh_trc_u8(rui8_t d);
+
+/**
+ *  \brief
+ *  Store a 16-bit data into the current trace event buffer without format
+ *  information.
+ *
+ *  \param[in] d		data
+ */
+void rkh_trc_u16(rui16_t d);
+
+/**
+ *  \brief
+ *  Store a 32-bit data into the current trace event buffer without format
+ *  information.
+ *
+ *  \param[in] d		data
+ */
+void rkh_trc_u32(rui32_t d);
+
+/**
+ *  \brief
+ *  Store a string terminated in '\\0' into the current trace event buffer
+ *  without format information.
+ *
+ *  \param[in] s		pointer to string treminated in '\\0'
+ */
+void rkh_trc_str(const char *s);
+
+/**
+ *  \brief
+ *  Output object symbol record.
+ *
+ *  \param[in] tre		trace event ID. The available events are enumerated in
+ *                      RKH_TE_<group>_<event> definitions.
+ *  \param[in] obj		address of the object in memory.
+ *  \param[in] obj_name	string terminated in '\\0'.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it.
+ */
+void rkh_trc_obj(RKH_TE_ID_T tre, rui8_t *obj, const char *obj_name);
+
+/**
+ *  \brief
+ *  Output signal symbol record.
+ *
+ *  \param[in] sig		signal number.
+ *  \param[in] sig_name	string terminated in '\\0'.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it.
+ */
+void rkh_trc_sig(RKH_SIG_T sig, const char *sig_name);
+
+/**
+ *  \brief
+ *  Output active object (AO) symbol record.
+ *
+ *  \param[in] ao		address of active object symbol.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it.
+ */
+void rkh_trc_ao(void *ao);
+
+/**
+ *  \brief
+ *  Output state symbol record.
+ *
+ *  \param[in] ao		address of active object symbol.
+ *  \param[in] state	address of state symbol.
+ *
+ *  \note
+ *  This function is internal to RKH and the user application should
+ *  not call it.
+ */
+void rkh_trc_state(void *ao, rui8_t *state);
+
+/**
+ *  \brief
+ *  Store a 8-bit data into the current trace event buffer with format
+ *  information.
+ *
+ *  \param[in] fmt		format information
+ *  \param[in] d		data
+ */
+void rkh_trc_fmt_u8(rui8_t fmt, rui8_t d);
+
+/**
+ *  \brief
+ *  Store a 16-bit data into the current trace event buffer with format
+ *  information.
+ *
+ *  \param[in] fmt		format information
+ *  \param[in] d		data
+ */
+void rkh_trc_fmt_u16(rui8_t fmt, rui16_t d);
+
+/**
+ *  \brief
+ *  Store a 32-bit data into the current trace event buffer with format
+ *  information.
+ *
+ *  \param[in] fmt		format information
+ *  \param[in] d		data
+ */
+void rkh_trc_fmt_u32(rui8_t fmt, rui32_t d);
+
+/**
+ *  \brief
+ *  Store a string terminated in '\\0' into the current trace event buffer
+ *  with format information.
+ *
+ *  \param[in] s		pointer to string terminated in '\\0'
+ */
+void rkh_trc_fmt_str(const char *s);
+
+/**
+ *  \brief
+ *  Output memory block of up to 255-bytes with format information.
+ *
+ *  \param[in] mem		pointer to memory block.
+ *  \param[in] size		size of memory block.
+ */
+void rkh_trc_fmt_mem(rui8_t const *mem, rui8_t size);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtrc_stream.h ./rkh/inc/rkhtrc_stream.h
--- a_qSC69Z/rkh/inc/rkhtrc_stream.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtrc_stream.h	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,141 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_stream.h
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    apiTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTRC_STREAM_H__
+#define __RKHTRC_STREAM_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_out.h"
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/**
+ *  \brief
+ *  Initializes the RKH's trace stream.
+ *
+ *  \note
+ *  rkh_trcStream_init() is NOT protected with a critical section.
+ */
+void rkh_trcStream_init(void);
+
+/**
+ *  \brief
+ *	Retrieves a pointer to oldest stored byte in the trace stream.
+ *	Frequently, this function is used by the called trace analyzer.
+ *
+ *  \note
+ *  The data is stored in a single ring buffer, called trace stream. In this
+ *	manner the recorder always holds the most recent history.
+ *  rkh_trc_get() is NOT protected with a critical section.
+ *
+ *  \returns
+ *  A pointer to the oldest stored byte if trace stream was not empty,
+ *  otherwise NULL pointer.
+ */
+rui8_t *rkh_trc_get(void);
+
+/**
+ *  \brief
+ *  Retrieves a pointer to a contiguous block of data from the trace stream.
+ *
+ *  The function returns the pointer to the beginning of the block, and writes
+ *  the number of bytes in the block to the location pointed to by \a nget.
+ *  The argument \a nget is also used as input to provide the maximum size
+ *  of the data block that the caller can accept.
+ *	Frequently, this function is used by the called trace analyzer.
+ *
+ *  \param[in] nget	when this function is invoked \a nget is used as an input
+ *                  to provide the maximum size of the data block to be
+ *                  retrieved. Also, it is used as an output retrieving the
+ *                  size of block.
+ *
+ *  \returns
+ *  The pointer to the beginning of the block, and writes the number of bytes
+ *  in the block to the location pointed to by \a nget. If this number
+ *  differs from the \a nget parameter, the end-of-stream was reached. If
+ *  the trace stream is empty, the function returns NULL and the content
+ *  pointed by \a nget is set to zero.
+ *
+ *  \note
+ *  The data is stored in a single ring buffer, called trace stream. In this
+ *	manner the recorder always holds the most recent history.
+ *  rkh_trc_get_block() is NOT protected with a critical section.
+ */
+rui8_t *rkh_trc_get_block(TRCQTY_T *nget);
+
+/**
+ *  \brief
+ *  Put a data byte into the trace stream.
+ *
+ *  \param[in] b	data to be written in the trace stream.
+ *
+ *  \note
+ *  The data is stored in a single ring buffer, called trace stream. In this
+ *	manner the recorder always holds the most recent history.
+ *  rkh_trc_put() is NOT protected with a critical section.
+ */
+void rkh_trc_put(rui8_t b);
+
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/inc/rkhtype.h ./rkh/inc/rkhtype.h
--- a_qSC69Z/rkh/inc/rkhtype.h	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/inc/rkhtype.h	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,125 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtype.h
+ *  \brief      Defines the data types that uses RKH.
+ *
+ *  \ingroup    apiPortMisc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* --------------------------------- Module -------------------------------- */
+#ifndef __RKHTYPE_H__
+#define __RKHTYPE_H__
+
+/* ----------------------------- Include files ----------------------------- */
+#ifdef __W32STVC__
+    #include "..\..\portable\80x86\win32_st\vc\rkht.h"
+#endif
+
+#ifdef __W32MTVC__
+    #include "..\..\portable\80x86\win32_mt\vc\rkht.h"
+#endif
+
+#ifdef __LNXGNU__
+    #include "../../portable/80x86/linux_st/gnu/rkht.h"
+#endif
+
+#ifdef __S08CW63__
+    #include "..\..\portable\s08\rkhs\cw6_3\rkht.h"
+#endif
+
+#ifdef __CFV1CW63__
+    #include "..\..\portable\cfv1\rkhs\cw6_3\rkht.h"
+#endif
+
+#ifdef __ARM_CM0CW10__
+    #include "../../portable/arm-cortex/rkhs/arm_cm0/cw_v10/rkht.h"
+#endif
+
+#ifdef __ARM_CM4FCW10__
+    #include "../../portable/arm-cortex/rkhs/arm_cm4f/cw_v10/rkht.h"
+#endif
+
+#ifdef __KSDK_KDS__
+    #include "..\..\portable\arm-cortex\rkhs\ksdk\kds\rkht.h"
+#endif
+
+#ifdef __KSDK_OS_KDS__
+    #include "..\..\portable\arm-cortex\ksdk_os\ucosiii\kds\rkht.h"
+#endif
+
+#ifdef __UCOS_V3_03_01__
+    #include "..\..\portable\ucos\v3.03.01\rkht.h"
+#endif
+
+#ifdef __ARM_CM3XPRESSO___
+    #include "../../portable/arm-cortex/rkhs/arm_cm3/codered/rkht.h"
+#endif
+
+#ifdef __EDUCIAA_EID__
+    #include "rkht.h"
+#endif
+
+#ifdef __TEST__
+    #include "..\..\portable\test\rkht.h"
+#endif
+
+/* ---------------------- External C language linkage ---------------------- */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------- Macros -------------------------------- */
+/* -------------------------------- Constants ------------------------------ */
+/* ------------------------------- Data types ------------------------------ */
+/* -------------------------- External variables --------------------------- */
+/* -------------------------- Function prototypes -------------------------- */
+/* -------------------- External C language linkage end -------------------- */
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ Module end ------------------------------- */
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhfwk_bittbl.c ./rkh/src/rkhfwk_bittbl.c
--- a_qSC69Z/rkh/src/rkhfwk_bittbl.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhfwk_bittbl.c	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,111 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_bittbl.c
+ *  \ingroup    sch
+ *
+ *  \brief      Declares the mapping tables to deal with priority algorithm.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhfwk_bittbl.h"
+#include "rkhitl.h"
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/**
+ *  \brief
+ *  bitMaskTbl[] is a table in ROM, used to equate an index from 0 to 7 to a
+ *  bit mask.
+ */
+static RKHROM rui8_t bitMaskTbl[] =
+{
+    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
+};
+
+/**
+ *  \brief
+ *  leastBitSetTbl[] is a table in ROM, used to return the bit position of the
+ *  highest priority bit set - a number between 0 and 7.
+ */
+static RKHROM rui8_t leastBitSetTbl[] =
+{
+    0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x00 to 0x0F */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x10 to 0x1F */
+    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x20 to 0x2F */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x30 to 0x3F */
+    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x40 to 0x4F */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x50 to 0x5F */
+    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x60 to 0x6F */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x70 to 0x7F */
+    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x80 to 0x8F */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0x90 to 0x9F */
+    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0xA0 to 0xAF */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0xB0 to 0xBF */
+    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0xC0 to 0xCF */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0xD0 to 0xDF */
+    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,     /* 0xE0 to 0xEF */
+    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0      /* 0xF0 to 0xFF */
+};
+
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+rui8_t 
+rkh_bittbl_getBitMask(rui8_t bitPos)
+{
+    return (bitPos < 8) ? bitMaskTbl[bitPos] : RKH_INVALID_BITPOS;
+}
+
+rui8_t 
+rkh_bittbl_getLeastBitSetPos(rui8_t value)
+{
+    return leastBitSetTbl[value];
+}
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhfwk_dynevt.c ./rkh/src/rkhfwk_dynevt.c
--- a_qSC69Z/rkh/src/rkhfwk_dynevt.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhfwk_dynevt.c	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,174 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_dynevt.c
+ *  \ingroup    fwk
+ *
+ *  \brief      Dynamic event (event with parameters) support.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+#include "rkhassert.h"
+#include "rkhfwk_dynevt.h"
+
+RKH_MODULE_NAME(rkhfwk_dynevt)
+
+#if RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+static RKHEvtPoolMgr evtPools[RKH_CFG_FWK_MAX_EVT_POOL];
+
+/* ---------------------------- Local variables ---------------------------- */
+/**
+ *  \brief
+ *  Number of registered event pools.
+ */
+static rui8_t nextFreeEvtPool;
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_fwk_gc(RKH_EVT_T *e, const void *const sender)
+{
+    RKHEvtPoolMgr * ep;
+
+    if (e->nref != 0)       /* is it a dynamic event? */
+    {
+        RKH_ENTER_CRITICAL_();
+
+        if (e->nref > 1)    /* isn't this the last ref? */
+        {
+            --e->nref;      /* decrement the reference counter */
+            RKH_TR_FWK_GC(e, e->pool, e->nref);
+            RKH_EXIT_CRITICAL_();
+        }
+        else    /* this is the last reference to this event, recycle it */
+        {
+            rui8_t evtPoolIdx = (rui8_t)(e->pool - 1);
+
+            RKH_REQUIRE(evtPoolIdx < nextFreeEvtPool); /* cannot wrap around */
+            ep = &evtPools[evtPoolIdx]; 
+            RKH_TR_FWK_GCR(e, rkh_evtPool_getNumUsed(ep->evtPool) - 1, 
+                           rkh_evtPool_getNumMin(ep->evtPool), sender);
+            RKH_EXIT_CRITICAL_();
+
+            rkh_evtPool_put(ep->evtPool, e);
+        }
+    }
+}
+
+void
+rkh_fwk_reserve(RKH_EVT_T *e)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ENTER_CRITICAL_();
+    RKH_INC_REF(e);
+    RKH_EXIT_CRITICAL_();
+}
+
+RKH_EVT_T *
+rkh_fwk_ae(RKH_ES_T esize, RKH_SIG_T e, const void *const sender)
+{
+    rint i;
+    RKHEvtPoolMgr *ep;
+    RKH_EVT_T *evt;
+
+    /* find the pool index that fits the requested event size ... */
+    for (i = 0, ep = evtPools; 
+         (i < nextFreeEvtPool) && 
+         (esize > rkh_evtPool_getBlockSize(ep->evtPool)); 
+         ++ep, ++i)
+    {
+        ;
+    }
+    RKH_ENSURE(i < nextFreeEvtPool);    /* cannot run out of registered pools */
+    evt = rkh_evtPool_get(ep->evtPool);
+    RKH_ENSURE(evt != RKH_EVT_CAST(0));  /* pool must not run out of events */
+
+    evt->e = e;                          /* set signal for this event */
+    evt->nref = (rui8_t)0;               /* Store the dynamic attributes of */
+                                         /* the event: the pool ID and the */
+    evt->pool = (rui8_t)(i + (rui8_t)1); /* reference counter = 0 */
+                                         
+    RKH_TR_FWK_AE(esize, evt, rkh_evtPool_getNumUsed(ep->evtPool), 
+                  rkh_evtPool_getNumMin(ep->evtPool), sender);
+    return evt;
+}
+
+void
+rkh_fwk_registerEvtPool(void *sstart, rui32_t ssize, RKH_ES_T esize)
+{
+    RKHEvtPool *ep;
+    RKH_SR_ALLOC();
+
+    RKH_REQUIRE((nextFreeEvtPool + 1) <= RKH_CFG_FWK_MAX_EVT_POOL);
+    ep = rkh_evtPool_getPool(sstart, (rui16_t)ssize, esize);
+    RKH_ENSURE(ep != (RKHEvtPool *)0);
+    evtPools[nextFreeEvtPool].evtPool = ep;
+    ++nextFreeEvtPool;
+    RKH_TR_FWK_EPREG(nextFreeEvtPool, ssize, esize, 
+                     rkh_evtPool_getNumBlock(ep));
+}
+
+void
+rkh_dynEvt_init(void)
+{
+    rint i;
+    RKHEvtPoolMgr *ep;
+
+    nextFreeEvtPool = 0;
+    for (i = 0, ep = evtPools; i < RKH_CFG_FWK_MAX_EVT_POOL; ++i)
+    {
+        ep->evtPool = (RKHEvtPool *)0;
+    }
+}
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhfwk_evtpool.c ./rkh/src/rkhfwk_evtpool.c
--- a_qSC69Z/rkh/src/rkhfwk_evtpool.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhfwk_evtpool.c	2018-01-19 23:55:11.008319160 -0300
@@ -0,0 +1,151 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_evtpool.c
+ *  \ingroup    fwk
+ *  \brief      Implements the event pool manager for supporting dynamic 
+ *              events based on native memory pool module (rkhmempool).
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.05.09  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhassert.h"
+#include "rkhfwk_dynevt.h"
+#include "rkhmempool.h"
+
+RKH_MODULE_NAME(rkhfwk_evtpool)
+
+#if ((RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED) && \
+     (RKH_CFGPORT_NATIVE_DYN_EVT_EN == RKH_ENABLED))
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+struct RKHEvtPool
+{
+    RKH_MEMPOOL_T memPool;
+};
+
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static RKHEvtPool evtPools[RKH_CFG_FWK_MAX_EVT_POOL];
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_evtPool_init(void)
+{
+    rint i;
+    RKHEvtPool *ep;
+
+    for (i = 0, ep = evtPools; i < RKH_CFG_FWK_MAX_EVT_POOL; ++i, ++ep)
+    {
+        ((RKH_MEMPOOL_T *)ep)->nblocks = 0;
+    }
+}
+
+RKHEvtPool *
+rkh_evtPool_getPool(void *stoStart, rui16_t stoSize, RKH_ES_T evtSize)
+{
+    rint i;
+    RKHEvtPool *ep;
+
+    for (i = 0, ep = evtPools; i < RKH_CFG_FWK_MAX_EVT_POOL; ++i, ++ep)
+    {
+        if (((RKH_MEMPOOL_T *)ep)->nblocks == 0)
+        {
+            rkh_memPool_init((RKH_MEMPOOL_T *)ep, stoStart, stoSize, 
+                        (RKH_MPBS_T)evtSize);
+            return ep;
+        }
+    }
+    return (RKHEvtPool *)0;
+}
+
+rui8_t 
+rkh_evtPool_getBlockSize(RKHEvtPool *const me)
+{
+    RKH_REQUIRE(me != (RKHEvtPool *)0);
+    return (rui8_t)((RKH_MEMPOOL_T *)me)->bsize;
+    /* return (rui8_t)rkh_memPool_get_bsize((RKH_MEMPOOL_T *)me); */
+}
+
+RKH_EVT_T *
+rkh_evtPool_get(RKHEvtPool *const me)
+{
+    RKH_REQUIRE(me != (RKHEvtPool *)0);
+    return (RKH_EVT_T *)rkh_memPool_get((RKH_MEMPOOL_T *)me);
+}
+
+void 
+rkh_evtPool_put(RKHEvtPool *const me, RKH_EVT_T *evt)
+{
+    RKH_REQUIRE(me != (RKHEvtPool *)0);
+    rkh_memPool_put((RKH_MEMPOOL_T *)me, evt);
+}
+
+rui8_t 
+rkh_evtPool_getNumUsed(RKHEvtPool *const me)
+{
+    RKH_REQUIRE(me != (RKHEvtPool *)0);
+    return (rui8_t)(((RKH_MEMPOOL_T *)me)->nblocks - ((RKH_MEMPOOL_T *)me)->nfree);
+}
+
+rui8_t 
+rkh_evtPool_getNumMin(RKHEvtPool *const me)
+{
+    RKH_REQUIRE(me != (RKHEvtPool *)0);
+    return (rui8_t)(((RKH_MEMPOOL_T *)me)->nmin);
+    /* return (rui8_t)rkh_memPool_get_low_wmark((RKH_MEMPOOL_T *)me); */
+}
+
+rui8_t 
+rkh_evtPool_getNumBlock(RKHEvtPool *const me)
+{
+    RKH_REQUIRE(me != (RKHEvtPool *)0);
+    return (rui8_t)(((RKH_MEMPOOL_T *)me)->nblocks);
+}
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhfwk_sched.c ./rkh/src/rkhfwk_sched.c
--- a_qSC69Z/rkh/src/rkhfwk_sched.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhfwk_sched.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,150 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_sched.c
+ *  \brief      Implements a native, simple and cooperative scheduler called 
+ *              RKS to deal with multiple event - driven state machines.
+ *  \ingroup    fwk
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05 LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhfwk_module.h"
+#include "rkhitl.h"
+#include "rkhfwk_sched.h"
+#include "rkhsma_prio.h"
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+#include "rkhsma.h"
+#include "rkhfwk_dynevt.h"
+#include "rkhfwk_hook.h"
+#include "rkhsm.h"
+
+#if (RKH_CFGPORT_NATIVE_SCHEDULER_EN == RKH_ENABLED)
+
+RKH_MODULE_NAME(rkhfwk_sched)
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+void 
+rkh_fwk_init(void)
+{
+}
+
+/**
+ *  \brief
+ *  This function executes one state machine application or active object 
+ *  at a time in the infinite loop (similar to the "superloop").
+ *
+ *  \details
+ *	The RKS executes one state machine application or active object at a time
+ *	in the infinite loop (similar to the "superloop"). The RKS is engaged
+ *	after each event is processed in the run-to-completion (RTC) fashion to
+ *	choose the next highest-priority active object ready to process the next
+ *	event. The RKS scheduler is cooperative, which means that all active
+ *	objects cooperate to share a single CPU and implicitly yield to each other
+ *	after every RTC step. The kernel is nonpreemptive, meaning that every
+ *	active object must completely process an event before any other active
+ *	object can start processing another event. The ISRs can preempt the
+ *	execution of active objects at any time, but due to the simplistic nature
+ *	of the RKS, every ISR returns to exactly the preemption point. If the ISR
+ *	posts an event to any active object, the processing of this event won't
+ *	start until the current RTC step completes. The maximum time an event for
+ *	the highest-priority active object can be delayed this way is called the
+ *	task-level response. With the nonpreemptive RKS, the task-level response
+ *	is equal to the longest RTC step of all active objects in the system.
+ */
+void 
+rkh_fwk_enter(void)
+{
+    rui8_t prio;
+    RKH_SMA_T *sma;
+    RKH_EVT_T *e;
+    RKH_SR_ALLOC();
+
+    RKH_HOOK_START();
+    RKH_TR_FWK_EN();
+
+    FOREVER
+    {
+        RKH_DIS_INTERRUPT();
+        if (rkh_smaPrio_isReady())
+        {
+            prio = rkh_smaPrio_findHighest();
+            sma = rkh_sptbl[prio];
+            RKH_ENA_INTERRUPT();
+
+            e = rkh_sma_get(sma);
+            (void)rkh_sm_dispatch((RKH_SM_T *)sma, e);
+            RKH_FWK_GC(e, sma);
+        }
+        else
+        {
+            /*
+             * rkh_hook_idle() must be called with interrupts DISABLED because
+             * the determination of the idle condition (no events in the queues)
+             * can change at any time by an interrupt posting events to a queue.
+             * The rkh_hook_idle() MUST enable interrups internally, perhaps at
+             * the same time as putting the CPU into a power-saving mode.
+             */
+            rkh_hook_idle();
+        }
+    }
+}
+
+void 
+rkh_fwk_exit(void)
+{
+    RKH_TR_FWK_EX();
+}
+
+#endif
+
+/* ---------------------------- Global functions --------------------------- */
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhfwk_version.c ./rkh/src/rkhfwk_version.c
--- a_qSC69Z/rkh/src/rkhfwk_version.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhfwk_version.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,72 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhfwk_version.c
+ *  \ingroup    fkw
+ *  \brief      RKH version
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhplat.h"
+#include "rkhfwk_version.h"
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+RKHROM char rkh_version[] =     /* String describing the RKH version */
+{
+    (char)((rui8_t)((RKH_VERSION_CODE >> 12) & 0x0F) + (rui8_t)'0'),
+    (char)'.',
+    (char)((rui8_t)((RKH_VERSION_CODE >>  8) & 0x0F) + (rui8_t)'0'),
+    (char)'.',
+    (char)((rui8_t)((RKH_VERSION_CODE >>  4) & 0x0F) + (rui8_t)'0'),
+    (char)((rui8_t)(RKH_VERSION_CODE         & 0x0F) + (rui8_t)'0'),
+    (char)'\0',
+};
+
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhmempool.c ./rkh/src/rkhmempool.c
--- a_qSC69Z/rkh/src/rkhmempool.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhmempool.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,283 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhmempool.c
+ *  \ingroup    mp
+ *
+ *  \brief      Implements a pool of fixed-size memory blocks.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+#include "rkhmempool.h"
+#include "rkhassert.h"
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+
+#if RKH_CFG_MP_EN == RKH_ENABLED
+
+RKH_MODULE_NAME(rkhmempool)
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/*
+ *  Structure representing a free block.
+ */
+typedef struct rkh_free_blk_t
+{
+    struct rkh_free_blk_t *next;
+} RKH_FREE_BLK_T;
+
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_memPool_init(RKH_MEMPOOL_T *mp, void *sstart, rui16_t ssize,
+            RKH_MPBS_T bsize)
+{
+    RKH_FREE_BLK_T *fb;
+    RKH_MPNB_T nblocks;
+    RKH_SR_ALLOC();
+
+    /*
+     * The memory block must be valid and the pool size (\a ssize) must fit
+     * at least one free block and the block size (\a bsize) must not be too
+     * close to the top of the dynamic range.
+     */
+    RKH_ASSERT(sstart != RKH_NULL &&
+               ssize >= sizeof(RKH_FREE_BLK_T) &&
+               (RKH_MPBS_T)(bsize + sizeof(RKH_FREE_BLK_T)) > bsize);
+
+    mp->free = (void *)(sstart);
+
+    /*
+     * (1) Round up the 'bsize' to fit an integer # free blocks, no division.
+     */
+    mp->bsize = sizeof(RKH_FREE_BLK_T);               /* start with just one */
+    nblocks = 1;               /* # free blocks that fit in one memory block */
+
+    while (mp->bsize < bsize)
+    {
+        mp->bsize += sizeof(RKH_FREE_BLK_T);
+        ++nblocks;
+    }
+
+    bsize = mp->bsize;               /* use the rounded-up value from now on */
+
+    /* The pool buffer must fit at least one rounded-up block. */
+    RKH_ASSERT(ssize >= (rui16_t)bsize);
+
+    /* Chain all blocks together in a free-list...*/
+    ssize -= (rui16_t)bsize;               /* don't count the last block */
+    mp->nblocks = 1;                   /* the last block already in the pool */
+    fb = (RKH_FREE_BLK_T *)mp->free;    /*start at the head of the free list */
+
+    while (ssize >= (rui16_t)bsize)
+    {
+        fb->next = &fb[nblocks];    /* point the next link to the next block */
+        fb = fb->next;              /* advance to the next block */
+        ssize -= (rui16_t)bsize;    /* reduce the available pool size */
+        ++mp->nblocks;              /* increment the number of blocks so far */
+    }
+
+    fb->next  = (RKH_FREE_BLK_T *)0;         /* the last link points to NULL */
+    mp->nfree = mp->nblocks;                          /* all blocks are free */
+#if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED && \
+    RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+    mp->nmin  = mp->nblocks;            /* the minimum number of free blocks */
+#endif
+#if RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+    mp->start = sstart;               /* the original start this pool buffer */
+    mp->end   = fb;                           /* the last block in this pool */
+#endif
+    RKH_TR_MP_INIT(mp, mp->nblocks, mp->bsize);
+}
+
+void *
+rkh_memPool_get(RKH_MEMPOOL_T *mp)
+{
+    RKH_FREE_BLK_T *fb;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0 && mp->bsize != 0);
+
+    RKH_ENTER_CRITICAL_();
+
+    fb = (RKH_FREE_BLK_T *)mp->free;            /* get a free block or NULL */
+    if (fb != RKH_NULL)                            /* free block available? */
+    {
+        mp->free = fb->next;     /* adjust list head to the next free block */
+        RKH_ASSERT(mp->nfree > (RKH_MPNB_T)0);    /* at least one free block */
+        --mp->nfree;                                 /* one less free block */
+#if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED && \
+        RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+        if (mp->nmin > mp->nfree)
+        {
+            mp->nmin = mp->nfree;            /* remember the minimum so far */
+        }
+#endif
+    }
+
+#if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED && \
+        RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+    RKH_TR_MP_GET(mp, mp->nfree, mp->nmin);
+#else
+    RKH_TR_MP_GET(mp, mp->nfree, mp->nfree);
+#endif
+    RKH_EXIT_CRITICAL_();
+    return fb;            /* return the block or NULL pointer to the caller */
+}
+
+void
+rkh_memPool_put(RKH_MEMPOOL_T *mp, void *blk)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0);
+    RKH_ASSERT(mp->bsize != 0);
+
+#if RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+    RKH_ASSERT(mp->start <= blk &&                       /* must be in range */
+               blk <= mp->end &&
+               mp->nfree < mp->nblocks);    /* # free blocks must be < total */
+#else
+    RKH_ASSERT(mp->nfree < mp->nblocks);    /* # free blocks must be < total */
+#endif
+
+    RKH_ENTER_CRITICAL_();
+
+    /* link into free list */
+    ((RKH_FREE_BLK_T *)blk)->next = (RKH_FREE_BLK_T *)mp->free;
+    mp->free = blk;                      /* set as new head of the free list */
+    ++mp->nfree;                         /* one more free block in this pool */
+
+    RKH_TR_MP_PUT(mp, mp->nfree);
+    RKH_EXIT_CRITICAL_();
+}
+
+#if RKH_CFG_MP_GET_BSIZE_EN == RKH_ENABLED
+RKH_MPBS_T
+rkh_memPool_get_bsize(RKH_MEMPOOL_T *mp)
+{
+    RKH_MPBS_T bs;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0);
+
+    RKH_ENTER_CRITICAL_();
+    bs = mp->bsize;
+    RKH_EXIT_CRITICAL_();
+
+    return bs;
+}
+#endif
+
+#if RKH_CFG_MP_GET_NFREE_EN == RKH_ENABLED
+RKH_MPNB_T
+rkh_memPool_get_nfree(RKH_MEMPOOL_T *mp)
+{
+    RKH_MPNB_T nfree;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0);
+
+    RKH_ENTER_CRITICAL_();
+    nfree = mp->nfree;
+    RKH_EXIT_CRITICAL_();
+
+    return nfree;
+}
+#endif
+
+#if RKH_CFG_MP_GET_LWM_EN == RKH_ENABLED && \
+    RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+RKH_MPNB_T
+rkh_memPool_get_low_wmark(RKH_MEMPOOL_T *mp)
+{
+    RKH_MPNB_T nmin;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0);
+
+    RKH_ENTER_CRITICAL_();
+    nmin = mp->nmin;
+    RKH_EXIT_CRITICAL_();
+
+    return nmin;
+}
+#endif
+
+#if RKH_CFG_MP_GET_INFO_EN == RKH_ENABLED && \
+    RKH_CFG_MP_REDUCED_EN == RKH_DISABLED
+void
+rkh_memPool_get_info(RKH_MEMPOOL_T *mp, RKH_MPI_T *mpi)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0 && mpi != (RKH_MPI_T *)0);
+
+    RKH_ENTER_CRITICAL_();
+    *mpi = mp->mpi;
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+rkh_memPool_clear_info(RKH_MEMPOOL_T *mp)
+{
+    RKH_MPI_T *pmpi;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(mp != (RKH_MEMPOOL_T *)0);
+    pmpi = &mp->mpi;
+
+    RKH_ENTER_CRITICAL_();
+    pmpi->inits = pmpi->gets = pmpi->puts = pmpi->free = pmpi->full = 0;
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+#endif
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhport.c ./rkh/src/rkhport.c
--- a_qSC69Z/rkh/src/rkhport.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhport.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,114 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhport.c
+ *  \brief      ARM Cortex-M MCU's, LPCXpresso port
+ *  \ingroup    port
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  DaBa  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ *  DaBa  Dario Baliï¿½a       dariosb@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkh.h"
+#include "sapi.h"
+#include "bsp.h"
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+RKH_MODULE_NAME(rkhport)
+RKH_MODULE_VERSION(rkhport, 1.00)
+RKH_MODULE_DESC(rkhport, "ARM Cortex-M, LPCXpresso")
+
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static ruint critical_nesting;
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+const
+char *
+rkhport_get_version(void)
+{
+    return RKH_MODULE_GET_VERSION();
+}
+
+const
+char *
+rkhport_get_desc(void)
+{
+    return RKH_MODULE_GET_DESC();
+}
+
+void
+rkhport_enter_critical(void)
+{
+    __asm volatile
+    (
+        "	mov r0, %0 \n"
+        "	msr basepri, r0	\n"
+        ::"i" (((HIGHEST_IRQ_PRI << (8 - __NVIC_PRIO_BITS)) & 0xFF)) : "r0"
+    );
+
+    critical_nesting++;
+}
+
+void
+rkhport_exit_critical(void)
+{
+    critical_nesting--;
+
+    if (critical_nesting != 0)
+    {
+        return;
+    }
+
+    __asm volatile
+    (
+        "	mov r0, #0					\n"
+        "	msr basepri, r0				\n"
+        ::: "r0"
+    );
+}
+
+/* ------------------------------ File footer ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhqueue.c ./rkh/src/rkhqueue.c
--- a_qSC69Z/rkh/src/rkhqueue.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhqueue.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,357 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhqueue.c
+ *  \ingroup    apiQueue
+ *
+ *  \brief      Implements a queue (by reference) services.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.17.05  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhqueue.h"
+#include "rkhassert.h"
+#include "rkhsma_prio.h"
+#include "rkhsma_sync.h"
+#include "rkhfwk_module.h"
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+
+#if RKH_CFG_QUE_EN == RKH_ENABLED
+
+RKH_MODULE_NAME(rkhqueue)
+
+/* ----------------------------- Local macros ------------------------------ */
+#if RKH_CFG_QUE_GET_INFO_EN == RKH_ENABLED
+    #define RKH_IUPDT_PUT(q)          ++ q->rqi.nputs
+    #define RKH_IUPDT_GET(q)          ++ q->rqi.ngets
+    #define RKH_IUPDT_EMPTY(q)        ++ q->rqi.nempty
+    #define RKH_IUPDT_FULL(q)         ++ q->rqi.nfull
+    #define RKH_IUPDT_READ(q)         ++ q->rqi.nreads
+#else
+    #define RKH_IUPDT_PUT(q)
+    #define RKH_IUPDT_GET(q)
+    #define RKH_IUPDT_EMPTY(q)
+    #define RKH_IUPDT_FULL(q)
+    #define RKH_IUPDT_READ(q)
+#endif
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_queue_init(RKH_QUEUE_T *q, const void * *sstart, RKH_QUENE_T ssize,
+            void *sma)
+{
+    RKH_SR_ALLOC();
+
+    q->pstart = sstart;
+    q->pin = q->pout = (void * *)sstart;
+    q->nelems = ssize;
+    q->qty = 0;
+    q->pend = (void * *)&sstart[ssize];
+    q->sma = (const struct RKH_SMA_T *)sma;
+#if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+    q->nmin = q->nelems;
+#endif
+#if RKH_CFG_QUE_GET_INFO_EN == RKH_ENABLED
+    q->rqi.nputs = q->rqi.ngets = q->rqi.nreads = q->rqi.nempty = 
+                                                  q->rqi.nfull = 0;
+#endif
+    RKH_TR_QUE_INIT(q, (const struct RKH_SMA_T *)sma, ssize);
+}
+
+#if RKH_CFG_QUE_IS_FULL_EN == RKH_ENABLED
+rbool_t
+rkh_queue_is_full(RKH_QUEUE_T *q)
+{
+    RKH_QUENE_T qty;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != (RKH_QUEUE_T *)0);
+
+    RKH_ENTER_CRITICAL_();
+    qty = q->qty;
+    RKH_EXIT_CRITICAL_();
+
+    return qty == q->nelems;
+}
+#endif
+
+#if RKH_CFG_QUE_GET_NELEMS_EN == RKH_ENABLED
+RKH_QUENE_T
+rkh_queue_get_num(RKH_QUEUE_T *q)
+{
+    RKH_QUENE_T qty;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0));
+
+    RKH_ENTER_CRITICAL_();
+    qty = q->qty;
+    RKH_EXIT_CRITICAL_();
+
+    return qty;
+}
+#endif
+
+#if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+RKH_QUENE_T
+rkh_queue_get_lwm(RKH_QUEUE_T *q)
+{
+    RKH_QUENE_T nmin;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0));
+
+    RKH_ENTER_CRITICAL_();
+    nmin = q->nmin;
+    RKH_EXIT_CRITICAL_();
+
+    return nmin;
+}
+#endif
+
+void *
+rkh_queue_get(RKH_QUEUE_T *q)
+{
+    void *e = CV(0);
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0));
+    RKH_ENTER_CRITICAL_();
+
+    if (q->sma != CSMA(0))
+    {
+        rkh_sma_block((RKH_SMA_T *)(q->sma));
+    }
+    else if (q->qty == 0)
+    {
+        RKH_IUPDT_EMPTY(q);
+        RKH_EXIT_CRITICAL_();
+        return e;
+    }
+
+    e = *q->pout++;
+    --q->qty;
+
+    if (q->pout == q->pend)
+    {
+        q->pout = (void * *)q->pstart;
+    }
+
+    RKH_IUPDT_GET(q);
+
+    if ((q->sma != CSMA(0)) && (q->qty == 0))
+    {
+        rkh_sma_setUnready((RKH_SMA_T *)(q->sma));
+        RKH_TR_QUE_GET_LAST(q);
+        RKH_EXIT_CRITICAL_();
+    }
+    else
+    {
+        RKH_TR_QUE_GET(q, q->qty);
+        RKH_EXIT_CRITICAL_();
+    }
+    return e;
+}
+
+void
+rkh_queue_put_fifo(RKH_QUEUE_T *q, const void *pe)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0) && pe != (const void *)0);
+    /*RKH_ENTER_CRITICAL_();*/
+    RKH_ASSERT(q->qty < q->nelems);
+
+    if (q->qty >= q->nelems)
+    {
+        RKH_IUPDT_FULL(q);
+        RKH_TR_QUE_FULL(q);
+        /*RKH_EXIT_CRITICAL_();*/
+        return;
+    }
+
+    *q->pin++ = (char *)pe;
+    ++q->qty;
+
+    if (q->pin == q->pend)
+    {
+        q->pin = (void * *)q->pstart;
+    }
+
+    if (q->sma != CSMA(0))
+    {
+        rkh_sma_setReady((RKH_SMA_T *)(q->sma));
+    }
+
+#if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+    if (q->nmin > (RKH_QUENE_T)(q->nelems - q->qty))
+    {
+        q->nmin = (RKH_QUENE_T)(q->nelems - q->qty);
+    }
+#endif
+    RKH_IUPDT_PUT(q);
+    /*RKH_EXIT_CRITICAL_();*/
+    RKH_TR_QUE_FIFO(q, q->qty, q->nmin);
+}
+
+#if RKH_CFG_QUE_PUT_LIFO_EN == RKH_ENABLED
+void
+rkh_queue_put_lifo(RKH_QUEUE_T *q, const void *pe)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0) && pe != (const void *)0);
+    /*RKH_ENTER_CRITICAL_();*/
+    RKH_ASSERT(q->qty < q->nelems);
+
+    if (q->qty >= q->nelems)
+    {
+        RKH_IUPDT_FULL(q);
+        RKH_TR_QUE_FULL(q);
+        /*RKH_EXIT_CRITICAL_();*/
+        return;
+    }
+
+    if (q->pout == (void * *)q->pstart)
+    {
+        q->pout = q->pend;
+    }
+
+    --q->pout;
+    *q->pout = CV(pe);
+    ++q->qty;
+
+    RKH_IUPDT_PUT(q);
+
+    if (q->sma != CSMA(0))
+    {
+        rkh_sma_setReady((RKH_SMA_T *)(q->sma));
+    }
+
+#if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+    if (q->nmin > (RKH_QUENE_T)(q->nelems - q->qty))
+    {
+        q->nmin = (RKH_QUENE_T)(q->nelems - q->qty);
+    }
+#endif
+    /*RKH_EXIT_CRITICAL_();*/
+    RKH_TR_QUE_LIFO(q, q->qty, q->nmin);
+}
+#endif
+
+#if RKH_CFG_QUE_DEPLETE_EN == RKH_ENABLED
+void
+rkh_queue_deplete(RKH_QUEUE_T *q)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0));
+    RKH_ENTER_CRITICAL_();
+    q->qty = 0;
+    q->pin = q->pout = (void * *)q->pstart;
+    if (q->sma != CSMA(0))
+    {
+        rkh_sma_setUnready((RKH_SMA_T *)(q->sma));
+    }
+    RKH_TR_QUE_DPT(q);
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+#if RKH_CFG_QUE_READ_EN == RKH_ENABLED
+ruint
+rkh_queue_read(RKH_QUEUE_T *q, void *pe)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(q != CQ(0) && pe != (const void *)0);
+    RKH_ENTER_CRITICAL_();
+
+    if (q->qty == 0)
+    {
+        RKH_IUPDT_EMPTY(q);
+        RKH_EXIT_CRITICAL_();
+        return RKH_QUE_EMPTY;
+    }
+
+    pe = *q->pout;
+
+    RKH_IUPDT_READ(q);
+    RKH_EXIT_CRITICAL_();
+    return RKH_QUE_OK;
+}
+#endif
+
+#if RKH_CFG_QUE_GET_INFO_EN == RKH_ENABLED
+void
+rkh_queue_get_info(RKH_QUEUE_T *q, RKH_QUEI_T *pqi)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ENTER_CRITICAL_();
+    *pqi = q->rqi;
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+rkh_queue_clear_info(RKH_QUEUE_T *q)
+{
+    RKH_QUEI_T *prqi;
+    RKH_SR_ALLOC();
+
+    prqi = &q->rqi;
+
+    RKH_ENTER_CRITICAL_();
+    prqi->nputs = prqi->ngets = prqi->nreads = prqi->nempty = prqi->nfull = 0;
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+#endif
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhsma.c ./rkh/src/rkhsma.c
--- a_qSC69Z/rkh/src/rkhsma.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhsma.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,305 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsma.c
+ *  \ingroup    sch
+ *
+ *  \brief      Implements the SMA(active object) registration.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhassert.h"
+#include "rkhitl.h"
+#include "rkhsma.h"
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+#include "rkhfwk_hook.h"
+
+RKH_MODULE_NAME(rkhsma)
+
+/* ----------------------------- Local macros ------------------------------ */
+#if RKH_CFG_QUE_GET_LWMARK_EN == RKH_ENABLED
+    #define RKH_SMA_GET_NMIN(ao)    (ao)->equeue.nmin
+#else
+    #define RKH_SMA_GET_NMIN(ao)    0
+#endif
+
+/* ------------------------------- Constants ------------------------------- */
+#if R_TRC_AO_NAME_EN == RKH_DISABLED
+RKHROM char noname[] = "null";
+#endif
+
+/** Default virtual table for the RKH_SMA_T structure */
+#if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+const RKHSmaVtbl rkhSmaVtbl = 
+{
+    rkh_sma_activate,
+    NULL,
+    rkh_sma_post_fifo,
+    rkh_sma_post_lifo
+};
+#endif
+
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+RKH_SMA_T *rkh_sptbl[RKH_CFG_FWK_MAX_SMA];  /* registered SMA table */
+
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_sma_register(RKH_SMA_T *sma)
+{
+    rui8_t prio = RKH_GET_PRIO(sma);
+    RKH_SR_ALLOC();
+
+    RKH_REQUIRE((prio <= (rui8_t)RKH_LOWEST_PRIO) &&
+                (rkh_sptbl[prio] == (RKH_SMA_T *)0));
+
+    RKH_ENTER_CRITICAL_();
+    rkh_sptbl[prio] = sma;
+    RKH_TR_SMA_REG(sma, prio);
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+rkh_sma_unregister(RKH_SMA_T *sma)
+{
+    rui8_t prio = RKH_GET_PRIO(sma);
+    RKH_SR_ALLOC();
+
+    RKH_REQUIRE((prio <= (rui8_t)RKH_CFG_FWK_MAX_SMA) &&
+                (rkh_sptbl[prio] == sma));
+
+    RKH_ENTER_CRITICAL_();
+    rkh_sptbl[prio] = (RKH_SMA_T *)0;
+    RKH_TR_SMA_UNREG(sma, prio);
+    RKH_EXIT_CRITICAL_();
+}
+
+#if RKH_CFG_SMA_RT_CTOR_EN == RKH_ENABLED
+void 
+rkh_sma_ctor(RKH_SMA_T *me, const RKHSmaVtbl *vtbl)
+{
+    rkh_sm_ctor(&me->sm);   /* Call base object constructor */
+                            /* (in fact an initializer operation) */
+
+    /* Link vptr to virtual table of me */
+#if RKH_CFG_SMA_VFUNCT_EN == RKH_ENABLED
+    me->vptr = (vtbl != (const RKHSmaVtbl *)0) ? vtbl : &rkhSmaVtbl;
+#endif
+}
+#endif
+
+#if RKH_CFGPORT_NATIVE_SCHEDULER_EN == RKH_ENABLED
+void
+rkh_sma_terminate(RKH_SMA_T *sma)
+{
+    RKH_SR_ALLOC();
+
+    rkh_sma_unregister(sma);
+    RKH_TR_SMA_TERM(sma, RKH_GET_PRIO(sma));
+}
+
+void
+rkh_sma_activate(RKH_SMA_T *sma, const RKH_EVT_T * *qs, RKH_QUENE_T qsize,
+                 void *stks, rui32_t stksize)
+{
+    (void)stks;
+    (void)stksize;
+    RKH_SR_ALLOC();
+
+    RKH_REQUIRE((qs != (const RKH_EVT_T * *)0) && (qsize != (RKH_QUENE_T)0));
+
+    rkh_queue_init(&sma->equeue, (const void * *)qs, qsize, sma);
+    rkh_sma_register(sma);
+    rkh_sm_init((RKH_SM_T *)sma);
+    RKH_TR_SMA_ACT(sma, RKH_GET_PRIO(sma), qsize);
+}
+#endif
+
+#if RKH_CFGPORT_NATIVE_EQUEUE_EN == RKH_ENABLED
+void
+#if defined(RKH_USE_TRC_SENDER)
+rkh_sma_post_fifo(RKH_SMA_T *sma, const RKH_EVT_T *e,
+                  const void *const sender)
+#else
+rkh_sma_post_fifo(RKH_SMA_T * sma, const RKH_EVT_T * e)
+#endif
+{
+    RKH_SR_ALLOC();
+
+    RKH_HOOK_SIGNAL(e);
+    RKH_ENTER_CRITICAL_();
+
+    RKH_INC_REF(e);
+    rkh_queue_put_fifo(&sma->equeue, e);
+    RKH_TR_SMA_FIFO(sma, e, sender, e->pool, e->nref, sma->equeue.qty, 
+                    RKH_SMA_GET_NMIN(sma));
+
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+#if RKH_CFGPORT_NATIVE_EQUEUE_EN == RKH_ENABLED && \
+    RKH_CFG_QUE_PUT_LIFO_EN == RKH_ENABLED
+void
+#if defined(RKH_USE_TRC_SENDER)
+rkh_sma_post_lifo(RKH_SMA_T *sma, const RKH_EVT_T *e,
+                  const void *const sender)
+#else
+rkh_sma_post_lifo(RKH_SMA_T * sma, const RKH_EVT_T * e)
+#endif
+{
+    RKH_SR_ALLOC();
+
+    RKH_HOOK_SIGNAL(e);
+    RKH_ENTER_CRITICAL_();
+
+    RKH_INC_REF(e);
+    rkh_queue_put_lifo(&sma->equeue, e);
+    RKH_TR_SMA_LIFO(sma, e, sender, e->pool, e->nref, sma->equeue.qty, 
+                    RKH_SMA_GET_NMIN(sma));
+
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+#if RKH_CFGPORT_NATIVE_EQUEUE_EN == RKH_ENABLED
+RKH_EVT_T *
+rkh_sma_get(RKH_SMA_T *sma)
+{
+    RKH_EVT_T *e;
+    RKH_SR_ALLOC();
+
+    e = rkh_queue_get(&sma->equeue);
+
+    RKH_ASSERT(e != (RKH_EVT_T *)0);
+    /* Because the variables are obtained outside critical section could be */
+    /* a race condition */
+    RKH_TR_SMA_GET(sma, e, e->pool, e->nref, 
+                   sma->equeue.qty, RKH_SMA_GET_NMIN(sma));
+    return e;
+}
+#endif
+
+#if RKH_CFG_FWK_DEFER_EVT_EN == RKH_ENABLED
+void
+rkh_sma_defer(RKH_QUEUE_T *q, const RKH_EVT_T *e)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ENTER_CRITICAL_();
+
+    RKH_INC_REF(e);
+    rkh_queue_put_fifo(q, e);
+    RKH_TR_SMA_DEFER(q, e);
+
+    RKH_EXIT_CRITICAL_();
+}
+
+RKH_EVT_T *
+rkh_sma_recall(RKH_SMA_T *sma, RKH_QUEUE_T *q)
+{
+    RKH_EVT_T *e;
+    RKH_SR_ALLOC();
+
+    e = rkh_queue_get(q);          /* get an event from deferred queue */
+    if (e != RKH_EVT_CAST(0))   /* event available? */
+    {
+        /* post it to the front of the SMA's queue */
+        RKH_SMA_POST_LIFO(sma, e, sma);
+        RKH_ENTER_CRITICAL_();
+        RKH_TR_SMA_RCALL(sma, e);
+
+#if RKH_CFG_FWK_DYN_EVT_EN == RKH_ENABLED
+        if (e->nref != 0)   /* is it a dynamic event? */
+        {
+            /*
+             * After posting to the SMA's queue the event must be referenced
+             * at least twice: once in the deferred event queue (eq->get()
+             * did NOT decrement the reference counter) and once in the
+             * SMA's event queue.
+             */
+            RKH_ASSERT(e->nref > 1);
+
+            /*
+             * We need to decrement the reference counter once, to account
+             * for removing the event from the deferred event queue.
+             */
+            --e->nref;
+        }
+#endif
+        RKH_EXIT_CRITICAL_();
+    }
+    return e;
+}
+#endif
+
+#if RKH_CFG_SMA_GET_INFO_EN == RKH_ENABLED
+void
+rkh_sma_clear_info(RKH_SMA_T *sma)
+{
+    RKH_SMAI_T *psi;
+    RKH_SR_ALLOC();
+
+    psi = &sma->sinfo;
+
+    RKH_ENTER_CRITICAL_();
+    sma->sinfo.ndevt = sma->sinfo.exectr = 0;
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+rkh_sma_get_info(RKH_SMA_T *sma, RKH_SMAI_T *psi)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ENTER_CRITICAL_();
+    *psi = sma->sinfo;
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhsma_prio.c ./rkh/src/rkhsma_prio.c
--- a_qSC69Z/rkh/src/rkhsma_prio.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhsma_prio.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,198 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsma_prio.c
+ *  \brief      Native priority mechanism for active object scheduling
+ *  \ingroup    sma
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.15  LeFr  v2.4.05  ---
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhsma_prio.h"
+#include "rkhfwk_bittbl.h"
+#include "rkhassert.h"
+#include "rkhfwk_module.h"
+#include "rkhitl.h"
+
+RKH_MODULE_NAME(rkhsma_prio)
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+#if RKH_CFG_FWK_MAX_SMA <= 8
+    #define RKH_NUM_RDYGRP      1
+#elif RKH_CFG_FWK_MAX_SMA > 8 && RKH_CFG_FWK_MAX_SMA <= 16
+    #define RKH_NUM_RDYGRP      2
+#elif RKH_CFG_FWK_MAX_SMA > 16 && RKH_CFG_FWK_MAX_SMA <= 24
+    #define RKH_NUM_RDYGRP      3
+#elif RKH_CFG_FWK_MAX_SMA > 24 && RKH_CFG_FWK_MAX_SMA <= 32
+    #define RKH_NUM_RDYGRP      4
+#elif RKH_CFG_FWK_MAX_SMA > 32 && RKH_CFG_FWK_MAX_SMA <= 40
+    #define RKH_NUM_RDYGRP      5
+#elif RKH_CFG_FWK_MAX_SMA > 40 && RKH_CFG_FWK_MAX_SMA <= 48
+    #define RKH_NUM_RDYGRP      6
+#elif RKH_CFG_FWK_MAX_SMA > 48 && RKH_CFG_FWK_MAX_SMA <= 56
+    #define RKH_NUM_RDYGRP      7
+#elif RKH_CFG_FWK_MAX_SMA > 56 && RKH_CFG_FWK_MAX_SMA <= 64
+    #define RKH_NUM_RDYGRP      8
+#endif
+
+/* ---------------------------- Local data types --------------------------- */
+/**
+ *  \brief
+ *	SMA ready table.
+ *
+ *  Each SMA is assigned a unique priority level between 0 and
+ *  RKH_LOWEST_PRIO.
+ *  Each SMA that is ready to run is placed in a ready list consisting of two
+ *  variables, rkhrg.grp and rkhrg.tbl[]. SMA priorities are grouped
+ *  (8 SMA per group) in rkhrg.grp. Each bit in rkhrg.grp is used to
+ *  indicate whenever any SMA in a group is ready to run. When a task
+ *  is ready to run it also sets its corresponding bit in the ready table,
+ *  rkhrg.tbl[]. The size of rkhrg.tbl[] depends on RKH_LOWEST_PRIO
+ *  (see rkhcfg.h).
+ *
+ *  SMA's priority = | 0 | 0 | Y | Y | Y | X | X | X |
+ *
+ *  Y's:	bit position in rkhrg.grp and
+ *          index into rkhrg.tbl[RKH_LOWEST_PRIO / 8 + 1]\n
+ *  X's:	bit position in rkhrg.tbl[RKH_LOWEST_PRIO / 8 + 1]
+ *
+ *  The lower 3 bits (X's) of the SMA's priority are used to determine the
+ *  bit position in rkhrg.tbl[], while the next three most significant bits
+ *  (Y's) are used to determine the index into rkhrg.tbl[].
+ *
+ *  To determine which priority (and thus which SMA) will run next, the
+ *  scheduler determines the lowest priority number that has its bit set in
+ *  rkhrg.tbl[]. The relationship between rkhrg.grp and rkhrg.tbl[] is
+ *  given by the following rules:
+ *
+ *  Bit 0 in rkhrg.grp is 1 when any bit in rkhrg.tbl[0] is 1.\n
+ *  Bit 1 in rkhrg.grp is 1 when any bit in rkhrg.tbl[1] is 1.\n
+ *  Bit 2 in rkhrg.grp is 1 when any bit in rkhrg.tbl[2] is 1.\n
+ *  Bit 3 in rkhrg.grp is 1 when any bit in rkhrg.tbl[3] is 1.\n
+ *  Bit 4 in rkhrg.grp is 1 when any bit in rkhrg.tbl[4] is 1.\n
+ *  Bit 5 in rkhrg.grp is 1 when any bit in rkhrg.tbl[5] is 1.\n
+ *  Bit 6 in rkhrg.grp is 1 when any bit in rkhrg.tbl[6] is 1.\n
+ *  Bit 7 in rkhrg.grp is 1 when any bit in rkhrg.tbl[7] is 1.
+ *
+ *  [JL]
+ */
+typedef struct
+{
+    /**
+     *  \brief
+     *  Each bit in rkhrg.grp is used to indicate whenever any SMA in a group
+     *  is ready to run.
+     */
+    rui8_t grp;
+
+    /**
+     *  \brief
+     *  When a task is ready to run it also sets its corresponding bit in the
+     *  ready table, rkhrg.tbl[].
+     */
+    unsigned char tbl[RKH_NUM_RDYGRP];
+} RKH_RG_T;
+
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static RKH_RG_T readyGroup;  /* ready group of active objects */
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void 
+rkh_smaPrio_init(void)
+{
+    unsigned char *pTbl, i;
+
+    readyGroup.grp = 0;
+    for (pTbl = readyGroup.tbl, i = 0; i < RKH_NUM_RDYGRP; ++i, ++pTbl)
+    {
+        *pTbl = 0;
+    }
+}
+
+rbool_t 
+rkh_smaPrio_isNotReady(void)
+{
+    return readyGroup.grp == 0;
+}
+
+rbool_t 
+rkh_smaPrio_isReady(void)
+{
+    return readyGroup.grp != 0;
+}
+
+void 
+rkh_smaPrio_setReady(rui8_t prio)
+{
+    RKH_REQUIRE(prio < RKH_CFG_FWK_MAX_SMA);
+    readyGroup.grp |= rkh_bittbl_getBitMask(prio >> 3);
+    readyGroup.tbl[prio >> 3] |= rkh_bittbl_getBitMask(prio & 0x07);
+}
+
+void 
+rkh_smaPrio_setUnready(rui8_t prio)
+{
+    RKH_REQUIRE(prio < RKH_CFG_FWK_MAX_SMA);
+    if ((readyGroup.tbl[prio >> 3] &= ~rkh_bittbl_getBitMask(prio & 0x07)) == 0)
+    {
+        readyGroup.grp &= ~rkh_bittbl_getBitMask(prio >> 3);
+    }
+}
+
+rui8_t 
+rkh_smaPrio_findHighest(void)
+{
+    rui8_t prio;
+
+    prio = rkh_bittbl_getLeastBitSetPos(readyGroup.grp);
+    prio = (rui8_t)((prio << 3) +
+                    (rui8_t)rkh_bittbl_getLeastBitSetPos(readyGroup.tbl[prio]));
+    return prio;
+}
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhsma_sync.c ./rkh/src/rkhsma_sync.c
--- a_qSC69Z/rkh/src/rkhsma_sync.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhsma_sync.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,89 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsma_sync.c
+ *  \brief      ...
+ *  \ingroup    sma
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.05.15  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhsma_sync.h"
+#include "rkhassert.h"
+#include "rkhsma_prio.h"
+
+#if ((RKH_CFGPORT_NATIVE_EQUEUE_EN == RKH_ENABLED) ||  \
+     (RKH_CFGPORT_NATIVE_SCHEDULER_EN == RKH_ENABLED))
+
+RKH_MODULE_NAME(rkhsma_sync)
+
+/* ----------------------------- Local macros ------------------------------ */
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void 
+rkh_sma_block(RKH_SMA_T *const me)
+{
+    RKH_ASSERT(me->equeue.qty != 0);
+}
+
+void 
+rkh_sma_setReady(RKH_SMA_T *const me)
+{
+    rkh_smaPrio_setReady(RKH_SMA_ACCESS_CONST(me, prio));
+}
+
+void 
+rkh_sma_setUnready(RKH_SMA_T *const me)
+{
+    rkh_smaPrio_setUnready(RKH_SMA_ACCESS_CONST(me, prio));
+}
+
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhsm.c ./rkh/src/rkhsm.c
--- a_qSC69Z/rkh/src/rkhsm.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhsm.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,748 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhsm.c
+ *  \brief      Platform - independent interface for supporting state-machines. 
+ *
+ *  \ingroup    sm
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.04.14  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhitl.h"
+#include "rkhsm.h"
+#include "rkhassert.h"
+#include "rkhfwk_hook.h"
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+#include "rkhfwk_dynevt.h"
+
+RKH_MODULE_NAME(rkhsm)
+
+/* ----------------------------- Local macros ------------------------------ */
+#define IS_NOT_INTERNAL_TRANSITION()    (inttr == 0)
+#define IS_INTERNAL_TRANSITION(s)       ((s) == CST(0))
+#define IS_EMPTY_HISTORY(s)             (*(CH(s))->target == (RKHROM void *)0)
+#define IS_FOUND_TRN(t)                 ((t)->event != RKH_ANY)
+#define IS_NOT_FOUND_TRN(t)             ((t)->event == RKH_ANY)
+#define IS_VALID_GUARD(t)               ((t)->guard != CG(0))
+#define IS_PSEUDO(s)                    ((CB((s))->type & RKH_REGULAR) == 0)
+#define IS_COMPOSITE(s)                 (CB((s))->type == RKH_COMPOSITE)
+#define IS_SUBMACHINE(s)                (CB((s))->type == RKH_SUBMACHINE)
+#define IS_REF_SUBMACHINE(s)            (CB((s))->type == RKH_REF_SUBMACHINE)
+#define IS_SIMPLE(s)                    (CB((s))->type == RKH_BASIC)
+#define IS_FINAL(s)                     (CB((s))->type == RKH_FINAL)
+
+#if RKH_CFGPORT_NATIVE_SCHEDULER_EN == RKH_ENABLED || \
+    RKH_CFGPORT_REENTRANT_EN == RKH_DISABLED
+    #define RKH_RAM     static
+#else
+    /* allocate the automatic variables of rkh_sm_dispatch() */
+    /* function on the stack. */
+    /* Therefore, the code is reentrant. */
+    #define RKH_RAM
+#endif
+
+#define FIND_TRN(me_, evt_, trn_, trnTbl_, signal_) \
+    for ((trn_) = (trnTbl_); ((trn_)->event != RKH_ANY); ++(trn_)) \
+    { \
+        if (((trn_)->event == signal_)) \
+        { \
+            if (IS_VALID_GUARD(trn_)) /* is enabled transition? */ \
+            { \
+                if (RKH_EXEC_GUARD((trn_), (me_), (evt_)) == RKH_GTRUE) \
+                { \
+                    break; /* Enabled transition */\
+                } \
+                else \
+                { \
+                    /* Disabled transition. Transitions that have a guard */ \
+                    /* which evaluates to false are disabled */ \
+                    RKH_TR_SM_GRD_FALSE(me_); \
+                } \
+            } \
+            else \
+            { \
+                break; /* Enabled transition. A transition that does not */ \
+                       /* have an associated guard is treated as if it */ \
+                       /* has a guard that is always true */ \
+            } \
+        } \
+    }
+
+#if defined(RKH_SHALLOW_ENABLED)
+    #if RKH_CFG_SMA_SUBMACHINE_EN == RKH_ENABLED
+    #define RKH_UPDATE_SHALLOW_HIST(s, h) \
+    if (CST((s))->parent != CST(0) && \
+        IS_COMPOSITE((s)->parent) && \
+        ((h) = CCMP(CST((s))->parent)->history) != CH(0) && \
+        CB((h))->type == RKH_SHISTORY) \
+        *(h)->target = (s)
+    #else
+    #define RKH_UPDATE_SHALLOW_HIST(s, h) \
+    if (CST((s))->parent != CST(0) && \
+        ((h) = CCMP(CST((s))->parent)->history) != CH(0) && \
+        CB((h))->type == RKH_SHISTORY) \
+        *(h)->target = (s)
+    #endif
+#else
+    #define RKH_UPDATE_SHALLOW_HIST(s, h)         ((void)0)
+#endif
+
+#if RKH_CFG_SMA_PPRO_EN == RKH_ENABLED
+    #define RKH_PROCESS_INPUT(s, h, pe) \
+    (RKH_SIG_T)(((s)->prepro != CPP(0)) ? \
+                RKH_EXEC_PREPRO((s),(h),(pe)) : (pe)->e)
+#else
+    #define RKH_PROCESS_INPUT(s, h, pe) \
+    (RKH_SIG_T)((pe)->e)
+#endif
+
+#define FIND_BRANCH(btbl, t, sma, pe) \
+    for ((t) = (btbl); (t)->event != RKH_ANY; ++(t)) \
+        if (IS_VALID_GUARD((t)) && \
+            RKH_EXEC_GUARD((t), (sma), (pe)) == RKH_GTRUE) \
+        { \
+            break; \
+        }
+
+#define RKH_EXEC_TRANSITION(sma, e) \
+    for (pal = al; nal != 0; ++pal, --nal) \
+    { \
+        RKH_EXEC_EFF(*pal, (sma), (e)); \
+    } \
+    pal = al
+
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    #define RKH_CLR_STEP()          (step = 0)
+    #define RKH_INC_STEP()          ++ step
+    #define RKH_GET_STEP()          step
+#else
+    #define RKH_CLR_STEP()          ((void)0)
+    #define RKH_INC_STEP()          ((void)0)
+    #define RKH_GET_STEP()          ((void)0)
+#endif
+
+#if RKH_CFG_SMA_GET_INFO_EN == RKH_ENABLED
+    #define INFO_RCV_EVENTS(p)      ++ (p)->hinfo.rcvevt
+    #define INFO_EXEC_TRS(p)        ++ (p)->hinfo.exectr
+#else
+    #define INFO_RCV_EVENTS(p)      ((void)0)
+    #define INFO_EXEC_TRS(p)        ((void)0)
+#endif
+
+#if defined(RKH_SUBMACHINE_ENABLED)
+    #define UPDATE_PARENT(s) \
+    (s) = (s)->parent; \
+    if ((s) != CST(0) && IS_REF_SUBMACHINE((s))) \
+        (s) = *CRSM((s))->dyp
+    #define UPDATE_IN_PARENT(s) \
+    (s) = (s)->parent; \
+    if ((s) != CST(0) && IS_REF_SUBMACHINE((s))) \
+        (s) = *CRSM((s))->dyp
+#else
+    #define UPDATE_PARENT(s) \
+    (s) = (s)->parent
+    #define UPDATE_IN_PARENT(s) \
+    (s) = (s)->parent
+#endif
+
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    #define RKH_EXEC_EXIT_ACTION(src, tgt, sma, nex) \
+    for (ix_n = 0, ix_x = islca = 0, stx = src; \
+         stx != CST(0); ++ix_x) \
+    { \
+        for (ix_n = 0, snl = sentry, stn = tgt; \
+             stn != CST(0); ++snl, ++ix_n) \
+        { \
+            if (stx == stn) \
+            { \
+                islca = 1;      /* found LCA */ \
+                break; \
+            } \
+            else if (ix_n < RKH_CFG_SMA_MAX_HCAL_DEPTH) \
+            { \
+                *snl = stn;     /* add state in entry state list */ \
+            } \
+            else \
+            { \
+                RKH_TR_SM_EX_HLEVEL(sma); \
+                RKH_ERROR(); \
+                return RKH_EX_HLEVEL; \
+            } \
+            UPDATE_PARENT(stn); \
+        } \
+        if (islca == 0 || ix_x == 0) \
+        { \
+            /* perform the exit actions of the exited states */ \
+            RKH_EXEC_EXIT(stx, CM(sma)); \
+            /* update histories of exited states */ \
+            RKH_UPDATE_SHALLOW_HIST(stx, h); \
+            RKH_TR_SM_EXSTATE(sma,      /* this state machine object */ \
+                              stx);     /* exited state */ \
+            if (islca == 1) \
+            { \
+                *snl = stn; \
+                ++ix_n; \
+                ++ix_x; \
+                break; \
+            } \
+        } \
+        else \
+        { \
+            break; \
+        } \
+        UPDATE_PARENT(stx); \
+    } \
+    /* save the # of entered states */ \
+    nex = ix_n
+#else
+    #define RKH_EXEC_EXIT_ACTION(src, tgt, sma, nex) \
+    stx = src; \
+    nex = ix_n = ix_x = (rui8_t)(stx != tgt)
+#endif
+
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    #define RKH_EXEC_ENTRY_ACTION(nen, sma, stn, snl, ix_n) \
+    if (ix_n == ix_x && ix_x == 0)      /* local transition */ \
+    { \
+    } \
+    else \
+    { \
+        for (ix_n = nen, snl = &sentry[ix_n]; ix_n != 0; --ix_n) \
+        { \
+            --snl; \
+            RKH_EXEC_ENTRY(*snl, CM(sma)); \
+            isCompletionEvent  = isCompletionTrn(*snl); \
+            RKH_TR_SM_ENSTATE(sma, *snl); \
+        } \
+        stn = *snl; \
+        while (IS_COMPOSITE(stn)) \
+        { \
+            stn = CCMP(stn)->defchild; \
+            RKH_EXEC_ENTRY(stn, CM(sma)); \
+            isCompletionEvent = isCompletionTrn(stn); \
+            RKH_EXEC_STATE_INIT(sma, CCMP(stn->parent)->initialAction); \
+            RKH_TR_SM_ENSTATE(sma, stn); \
+            ++nen; \
+        } \
+    }
+#else
+    #define RKH_EXEC_ENTRY_ACTION(nen, sma, stn, snl, ix_n) \
+    nen = 0; \
+    if (ix_n == ix_x && ix_x == 0) \
+    { \
+    } \
+    else \
+    { \
+        stn = ets; \
+    }
+#endif
+
+/* ------------------------------- Constants ------------------------------- */
+RKH_ROM_STATIC_EVENT(evCompletion, RKH_COMPLETION_EVENT);
+
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+static rbool_t
+findCompletionTrn(RKHROM RKH_TR_T *trnTable)
+{
+    RKHROM RKH_TR_T *trn;
+    rbool_t res; 
+
+    for (res = RKH_FALSE, trn = trnTable; trn->event != RKH_ANY; ++trn)
+    {
+        if (trn->event == RKH_COMPLETION_EVENT)
+        {
+            res = RKH_TRUE;
+            break;
+        }
+    }
+    return res;
+}
+
+static rbool_t
+isCompletionTrn(RKHROM RKH_ST_T *state)
+{
+    if ((IS_SIMPLE(state) && findCompletionTrn(CBSC(state)->trtbl)) ||
+        IS_FINAL(state))
+        return RKH_TRUE;
+    else
+        return RKH_FALSE;
+}
+
+static rbool_t
+rkh_add_tr_action(RKH_TRN_ACT_T * *list, RKH_TRN_ACT_T act, rui8_t *num)
+{
+    if (*num >= RKH_CFG_SMA_MAX_TRC_SEGS)
+    {
+        return 1;
+    }
+
+    if (act != CTA(0))
+    {
+        **list = act;                       /* store a new transition action */
+        ++(*list);                     /* increment the pointer to next slot */
+        ++(*num);            /* increment the counter of actions in the list */
+    }
+    return 0;
+}
+
+#if defined(RKH_DEEP_ENABLED)
+static void
+rkh_update_deep_hist(RKHROM RKH_ST_T *from)
+{
+    RKHROM RKH_ST_T *s;
+    RKHROM RKH_SHIST_T *h;
+
+    for (s = from->parent;
+         s != (RKHROM RKH_ST_T *)0; s = s->parent)
+    {
+#if defined(RKH_SUBMACHINE_ENABLED)
+        if (IS_REF_SUBMACHINE(s))
+        {
+            s = *CRSM(s)->dyp;
+            continue;
+        }
+#endif
+        if (((h = CCMP(s)->history) != (RKHROM RKH_SHIST_T *)0) &&
+            (CB(h)->type == RKH_DHISTORY))
+        {
+            *h->target = from;
+        }
+    }
+}
+#else
+    #define rkh_update_deep_hist(f)       ((void)0)
+#endif
+
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_sm_init(RKH_SM_T *me)
+{
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    RKHROM RKH_ST_T *s;
+#endif
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(me &&
+               RKH_SMA_ACCESS_CONST(me, istate) != (RKHROM RKH_ST_T *)0);
+    RKH_EXEC_INIT(me, RKH_SMA_ACCESS_CONST(me, iaction));
+    RKH_TR_SM_INIT(me, RKH_SMA_ACCESS_CONST(me, istate));
+
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    for (s = CST(RKH_SMA_ACCESS_CONST(me, istate));; )
+    {
+        RKH_EXEC_ENTRY(s, CM(me));
+        RKH_TR_SM_ENSTATE(me, s);
+
+        if (IS_COMPOSITE(s))
+        {
+            s = CST(CCMP(s)->defchild);
+        }
+        else
+        {
+            break;
+        }
+    }
+    ((RKH_SM_T *)me)->state = s;
+    rkh_update_deep_hist(((RKH_SM_T *)me)->state);
+#endif
+}
+
+#if defined(RKH_HISTORY_ENABLED)
+void
+rkh_sm_clear_history(RKHROM RKH_SHIST_T *h)
+{
+    *h->target = (RKHROM void *)0;
+}
+#endif
+
+ruint
+rkh_sm_dispatch(RKH_SM_T *me, RKH_EVT_T *pe)
+{
+    RKHROM RKH_ST_T *cs, *ts;
+    RKHROM void *ets;
+    RKHROM RKH_TR_T *tr;
+    rbool_t inttr, isCompletionEvent;
+    RKH_SIG_T in;
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+    rui8_t step;
+#endif
+#if defined(RKH_SHALLOW_ENABLED)
+    RKHROM RKH_SHIST_T *h;
+#endif
+#if defined(RKH_SUBMACHINE_ENABLED)
+    RKHROM RKH_SSBM_T *dp;
+#endif
+    /* to deal with Statechart's transition sequence */
+    RKH_RAM RKHROM RKH_ST_T *stn, *stx;
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    RKH_RAM RKHROM RKH_ST_T * *snl;
+    RKH_RAM rui8_t islca;
+#endif
+    RKH_RAM rui8_t ix_n, ix_x, nn;
+    /* set of entered states */
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    RKH_RAM RKHROM RKH_ST_T *sentry[RKH_CFG_SMA_MAX_HCAL_DEPTH];
+#endif
+    /* set of executed transition actions */
+    RKH_RAM RKH_TRN_ACT_T al[RKH_CFG_SMA_MAX_TRC_SEGS];
+    /* pointer to transition action set */
+    RKH_RAM RKH_TRN_ACT_T *pal;
+    /* # of executed transition actions */
+    RKH_RAM rui8_t nal;
+    RKH_SR_ALLOC();
+
+    RKH_ASSERT(me && pe);
+
+    isCompletionEvent = inttr = 0;
+    INFO_RCV_EVENTS(me);
+    RKH_HOOK_DISPATCH(me, pe);
+
+    do
+    {
+    /* ---- Stage 1 -------------------------------------------------------- */
+    cs = ((RKH_SM_T *)me)->state;                      /* get current state */
+
+    /* ---- Stage 2 -------------------------------------------------------- */
+    /* Determine the (compound) transition (CT) that will fire in response */
+    /* to the event: traverse the states in the active configuration from */
+    /* lowest states in the hierarchy upwards. A CT is enabled if its */
+    /* trigger is the dispatched event, and the guard evaluates to true. */
+    /* Once an enabled transition is found with a given source state */
+    /* stop traversing the states that are higher than this state in the */
+    /* hierarchy. */
+    if (isCompletionEvent)
+    {
+        pe = (RKH_EVT_T *)&evCompletion;
+        isCompletionEvent = RKH_FALSE;
+    }
+#if RKH_CFG_SMA_HCAL_EN == RKH_ENABLED
+    for (stn = cs, tr = CT(0); stn != CST(0); UPDATE_IN_PARENT(stn))
+    {
+        in = RKH_PROCESS_INPUT(stn, me, pe);
+        FIND_TRN(me, pe, tr, CBSC(stn)->trtbl, in);
+        if (IS_FOUND_TRN(tr))
+        {
+            break;
+        }
+        /* UPDATE_IN_PARENT(stn); */
+    }
+#else
+    stn = cs;
+    in = RKH_PROCESS_INPUT(stn, me, pe);
+    FIND_TRN(me, pe, tr, CBSC(stn)->trtbl, in);
+#endif
+
+    RKH_TR_SM_DCH(me,                           /* this state machine object */
+                  pe,                                               /* event */
+                  cs);                                      /* current state */
+    if (IS_NOT_FOUND_TRN(tr))                           /* transition taken? */
+    {
+        RKH_TR_SM_EVT_NFOUND(me,                /* this state machine object */
+                             pe);                                   /* event */
+        return RKH_EVT_NFOUND;
+    }
+
+    ets = tr->target;       /* temporarily save the target of the transition */
+    ts = CST(ets);
+
+    nal = 0;                            /* initialize transition action list */
+    pal = al;
+    RKH_CLR_STEP();
+    RKH_TR_SM_TRN(me,                           /* this state machine object */
+                  stn,                            /* transition source state */
+                  ts);                            /* transition target state */
+
+    /* Add action of the transition segment in the list */
+    if (rkh_add_tr_action(&pal, tr->action, &nal))
+    {
+        RKH_TR_SM_EX_TSEG(me);
+        RKH_ERROR();
+        return RKH_EX_TSEG;
+    }
+
+    RKH_INC_STEP();            /* increment the number of transition segment */
+    inttr = IS_INTERNAL_TRANSITION(ets);       /* is an internal transition? */
+
+    if (IS_NOT_INTERNAL_TRANSITION())
+    {
+        /* ---- Stage 3 ---------------------------------------------------- */
+        RKH_TR_SM_TS_STATE(me,                 /* this state machine object */
+                                   /* target state of the transition segment */
+                           ets);
+
+        /* ... traverses the taken transition until */
+        /* the segment target state (ets) == simple state */
+#if RKH_PSEUDOSTATE == RKH_ENABLED
+        while (IS_PSEUDO(ets) || IS_SUBMACHINE(ets))
+        {
+            switch (CB(ets)->type)
+            {
+#if defined(RKH_CHOICE_ENABLED)
+                case RKH_CHOICE:
+                    /* perform the actions on the transition sequentially */
+                    /* according to the order in which they are written on */
+                    /* the transition, from the action closest to source */
+                    /* state to the action closest to target state. */
+                    RKH_TR_SM_NTRNACT(me,     /* this state machine object */
+                                      nal,     /* # executed actions */
+                                               /* # transition segments */
+                                       RKH_GET_STEP());
+                    RKH_EXEC_TRANSITION(me, pe);
+#endif
+#if defined(RKH_CHOICE_OR_CONDITIONAL_ENABLED)
+                case RKH_CONDITIONAL:
+                    /* evaluates the guards of its outgoing transitions */
+                    FIND_BRANCH(CCD(ets)->trtbl, tr, me, pe);
+
+                    if (IS_NOT_FOUND_TRN(tr))
+                    {
+                        RKH_TR_SM_CND_NFOUND(me);
+                        return RKH_CND_NFOUND;
+                    }
+
+                    if (rkh_add_tr_action(&pal, tr->action, &nal))
+                    {
+                        RKH_TR_SM_EX_TSEG(me);
+                        RKH_ERROR();
+                        return RKH_EX_TSEG;
+                    }
+                    /* another transition segment */
+                    RKH_INC_STEP();
+                    ets = tr->target;
+                    break;
+#endif
+#if defined(RKH_HISTORY_ENABLED)
+                case RKH_SHISTORY:
+                case RKH_DHISTORY:
+                    /* found a shallow or deep history pseudostate */
+                    /* in the compound transition */
+                    RKH_REQUIRE((CH(ets)->parent != (RKHROM RKH_ST_T *)0) &&
+                                (CCMP(CH(ets)->parent)->history !=
+                                (RKHROM RKH_SHIST_T *)0));
+                    if (IS_EMPTY_HISTORY(ets))
+                    {
+                        if (CH(ets)->trn.target)
+                        {
+                            if (IS_VALID_GUARD(&(CH(ets)->trn)) && 
+                                (RKH_EXEC_GUARD(&(CH(ets)->trn), me, pe) 
+                                 == RKH_GFALSE))
+                            {
+                                RKH_TR_SM_GRD_FALSE(me);
+                                return RKH_GRD_FALSE;
+                            }
+                            /* Add action of the transition segment into the */
+                            /* list */
+                            if (rkh_add_tr_action(&pal, 
+                                                  CH(ets)->trn.action,
+                                                  &nal))
+                            {
+                                RKH_TR_SM_EX_TSEG(me);
+                                RKH_ERROR();
+                                return RKH_EX_TSEG;
+                            }
+                            ets = CH(ets)->trn.target;
+                        }
+                        else
+                        {
+                            ets = CH(ets)->parent;
+                        }
+                    }
+                    else
+                    {
+                        ets = *(CH(ets))->target;
+                    }
+                    break;
+#endif
+#if defined(RKH_SUBMACHINE_ENABLED)
+                case RKH_SUBMACHINE:
+                    /* found a submachine state */
+                    *CSBM(ets)->sbm->dyp = ets;
+                    if (rkh_add_tr_action(&pal, CSBM(ets)->sbm->iaction,
+                                          &nal))
+                    {
+                        RKH_TR_SM_EX_TSEG(me);
+                        RKH_ERROR();
+                        return RKH_EX_TSEG;
+                    }
+                    ets = CSBM(ets)->sbm->defchild;
+                    break;
+                case RKH_ENPOINT:
+                    /* found an entry point pseudostate */
+                    /* in the compound transition */
+                    *CSBM(CENP(ets)->parent)->sbm->dyp = CENP(ets)->parent;
+                    if (rkh_add_tr_action(&pal, CENP(ets)->enpcn->action,
+                                          &nal))
+                    {
+                        RKH_TR_SM_EX_TSEG(me);
+                        RKH_ERROR();
+                        return RKH_EX_TSEG;
+                    }
+                    ets = CENP(ets)->enpcn->target;
+                    break;
+                case RKH_EXPOINT:
+                    /* found an exit point pseudostate */
+                    /* in the compound transition */
+                    dp = CSBM(*CEXP(ets)->parent->dyp);
+                    ets = CST(&(dp->exptbl[CEXP(ets)->ix]));
+                    if (rkh_add_tr_action(&pal, CEXPCN(ets)->action, &nal))
+                    {
+                        RKH_TR_SM_EX_TSEG(me);
+                        RKH_ERROR();
+                        return RKH_EX_TSEG;
+                    }
+                    ets = CEXPCN(ets)->target;
+                    break;
+#endif
+                default:
+                    /* fatal error: unknown state... */
+                    RKH_TR_SM_UNKN_STATE(me);
+                    RKH_ERROR();
+                    return RKH_UNKN_STATE;
+            }
+            RKH_TR_SM_TS_STATE(me, ets);
+        }
+#endif
+    }
+
+    if (IS_NOT_INTERNAL_TRANSITION())
+    {
+        ts = CST(ets);                 /* finally, set the main target state */
+    }
+    if (IS_NOT_INTERNAL_TRANSITION())
+    {
+        /* ---- Stage 4 ---------------------------------------------------- */
+        /* first of all, find the LCA then */
+        /* perform the exit actions of the exited states according */
+        /* to the order states are exited, from low state to high state, */
+        /* update histories of exited states, */
+        /* and, generate the set of entered states */
+        RKH_EXEC_EXIT_ACTION(cs, ts, me, nn);
+    }
+    /* ---- Stage 5 -------------------------------------------------------- */
+    /* perform the actions on the transition sequentially */
+    /* according to the order in which they are written on */
+    /* the transition, from the action closest to source */
+    /* state to the action closest to target state. */
+    RKH_TR_SM_NTRNACT(me,                      /* this state machine object */
+                      nal,                             /* # executed actions */
+                      RKH_GET_STEP());              /* # transition segments */
+    RKH_EXEC_TRANSITION(me, pe);
+
+    if (IS_NOT_INTERNAL_TRANSITION())
+    {
+        /* ---- Stage 6 ---------------------------------------------------- */
+        /* perform the entry actions of the entered states */
+        /* according to the order states are entered, */
+        /* from high state to low state. */
+        /* For lowest level states that were entered, which are not */
+        /* basic states, perform default transitions (recursively) */
+        /* until the statechart reaches basic states. */
+        /* Also, update 'stn' with the target state */
+        RKH_EXEC_ENTRY_ACTION(nn, me, stn, snl, ix_n);
+        RKH_TR_SM_NENEX(me,                    /* this state machine object */
+                        nn,                              /* # entered states */
+                        ix_x);                            /* # exited states */
+ 
+        /* ---- Stage 7 ---------------------------------------------------- */
+        /* update deep history */
+        rkh_update_deep_hist(CST(stn));
+        /* ---- Stage 8 ---------------------------------------------------- */
+        ((RKH_SM_T *)me)->state = CST(stn);     /* update the current state */
+        RKH_TR_SM_STATE(me,                    /* this state machine object */
+                        stn);                               /* current state */
+    }
+
+    RKH_TR_SM_EVT_PROC(me);
+    } while (isCompletionEvent);
+
+    INFO_EXEC_TRS(me);
+    return RKH_EVT_PROC;
+}
+
+#if RKH_CFG_SMA_RT_CTOR_EN == RKH_ENABLED
+void 
+rkh_sm_ctor(RKH_SM_T *me)
+{
+    (void)me;
+}
+#endif
+
+#if (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+     RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+rbool_t
+rkh_sm_else(const struct RKH_SM_T *sma, RKH_EVT_T *pe)
+{
+    (void)sma;
+    (void)pe;
+    return RKH_GTRUE;
+}
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_ENABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_DISABLED)
+rbool_t
+rkh_sm_else(RKH_EVT_T *pe)
+{
+    (void)pe;
+    return RKH_GTRUE;
+}
+#elif (RKH_CFG_SMA_GRD_ARG_EVT_EN == RKH_DISABLED && \
+       RKH_CFG_SMA_GRD_ARG_SMA_EN == RKH_ENABLED)
+rbool_t
+rkh_sm_else(const struct RKH_SM_T *sma)
+{
+    (void)sma;
+    return RKH_GTRUE;
+}
+#else
+rbool_t
+rkh_sm_else(void)
+{
+    return RKH_GTRUE;
+}
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhtmr.c ./rkh/src/rkhtmr.c
--- a_qSC69Z/rkh/src/rkhtmr.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhtmr.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,244 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtmr.c
+ *  \ingroup    apiTmr
+ *
+ *  \brief      Implements the software timer.
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2015.10.24  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtmr.h"
+#include "rkhassert.h"
+#include "rkhfwk_hook.h"
+#include "rkhsma.h"
+#include "rkhtrc_record.h"
+#include "rkhtrc_filter.h"
+
+#if RKH_CFG_TMR_EN == RKH_ENABLED
+
+RKH_MODULE_NAME(rkhtmr)
+
+/* ----------------------------- Local macros ------------------------------ */
+#define CPTIM(p)        ((RKH_TMR_T *)(p))
+
+#if RKH_CFG_TMR_HOOK_EN == RKH_ENABLED
+    #define RKH_EXEC_THOOK() \
+    if (t->timhk != (RKH_THK_T)0) \
+        (*t->timhk)(t)
+    #define RKH_SET_THOOK(t, hk) \
+    (t)->timhk = (hk)
+#else
+    #define RKH_EXEC_THOOK()          (void)0
+    #define RKH_SET_THOOK(t, hk)      (void)0
+#endif
+
+#define add_to_list(t) \
+    (t)->tnext = thead; \
+    thead = (t); \
+    (t)->used = 1
+
+#if defined(RKH_USE_TRC_SENDER)
+    #define RKH_TICK_POST(t_, sender_) \
+    RKH_SMA_POST_FIFO((RKH_SMA_T *)t_->sma, t_->evt, \
+                      sender_ != (const void *)0 ? sender_ : t_)
+#else
+    #define RKH_TICK_POST(t_, sender_) \
+    RKH_SMA_POST_FIFO((RKH_SMA_T *)t_->sma, t_->evt, sender_)
+#endif
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static RKH_TMR_T * thead;
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+static void
+rem_from_list(RKH_TMR_T *t, RKH_TMR_T *tprev)
+{
+    if (thead == t)             /* is first timer in the list? */
+    {
+        thead = t->tnext;
+    }
+    else
+    {
+        tprev->tnext = t->tnext;
+    }
+    t->used = 0;
+    RKH_TR_TMR_REM(t);
+}
+
+/* ---------------------------- Global functions --------------------------- */
+void
+#if defined(RKH_USE_TRC_SENDER)
+rkh_tmr_tick(const void *const sender)
+#else
+rkh_tmr_tick(void)
+#endif
+{
+    RKH_TMR_T *t, *tprev;
+    RKH_SR_ALLOC();
+
+    RKH_HOOK_TIMETICK();            /* call user definable hook */
+
+    RKH_ENTER_CRITICAL_();
+    if (thead == CPTIM(0))      /* is empty list? */
+    {
+        RKH_EXIT_CRITICAL_();
+        return;
+    }
+
+    for (tprev = CPTIM(0), t = thead; t != CPTIM(0); t = t->tnext)
+        if (t->ntick == 0)
+        {
+            rem_from_list(t, tprev);
+        }
+        else
+        {
+            if (!--t->ntick)
+            {
+                RKH_TR_TMR_TOUT(t, t->evt->e, t->sma);
+                if (t->period == 0)
+                {
+                    rem_from_list(t, tprev);
+                }
+                else
+                {
+                    t->ntick = t->period;
+                    tprev = t;
+                }
+                RKH_HOOK_TIMEOUT(t);
+                RKH_EXEC_THOOK();
+                RKH_TICK_POST(t, sender);
+            }
+            else
+            {
+                tprev = t;
+            }
+        }
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+#if RKH_CFG_TMR_HOOK_EN == RKH_DISABLED
+rkh_tmr_init_(RKH_TMR_T *t, const RKH_EVT_T *e)
+#else
+rkh_tmr_init_(RKH_TMR_T * t, const RKH_EVT_T * e, RKH_THK_T thk)
+#endif
+{
+    RKH_SR_ALLOC();
+    RKH_REQUIRE(t != CPTIM(0) && e != CCE(0));
+
+    RKH_ENTER_CRITICAL_();
+    t->ntick = 0;
+    t->used = 0;
+    t->evt = CE(e);
+    RKH_TR_TMR_INIT(t, t->evt->e);
+    RKH_EXIT_CRITICAL_();
+
+    RKH_SET_THOOK(t, thk);
+}
+
+void
+rkh_tmr_start(RKH_TMR_T *t, const struct RKH_SMA_T *sma, RKH_TNT_T itick)
+{
+    RKH_SR_ALLOC();
+
+    RKH_REQUIRE(t != CPTIM(
+                    0) && sma != (const struct RKH_SMA_T *)0 && itick != 0);
+    RKH_ENTER_CRITICAL_();
+
+    t->sma = sma;
+    t->ntick = itick;
+    if (t->used == 0)
+    {
+        add_to_list(t);
+    }
+
+    RKH_TR_TMR_START(t, sma, itick, t->period);
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+rkh_tmr_stop(RKH_TMR_T *t)
+{
+    RKH_SR_ALLOC();
+
+    RKH_REQUIRE(t != CPTIM(0));
+
+    RKH_ENTER_CRITICAL_();
+    t->ntick = 0;
+    RKH_TR_TMR_STOP(t, t->ntick, t->period);
+    RKH_EXIT_CRITICAL_();
+
+}
+
+#if RKH_CFG_TMR_GET_INFO_EN == RKH_ENABLED
+void
+rkh_tmr_get_info(RKH_TMR_T *t, RKH_TINFO_T *info)
+{
+    RKH_SR_ALLOC();
+
+    RKH_ENTER_CRITICAL_();
+    *info = t->info;
+    RKH_EXIT_CRITICAL_();
+}
+
+void
+rkh_tmr_clear_info(RKH_TMR_T *t)
+{
+    RKH_TINFO_T *pi;
+    RKH_SR_ALLOC();
+
+    pi = &t->info;
+
+    RKH_ENTER_CRITICAL_();
+    pi->nexp = pi->nstart = pi->nstop = 0;
+    RKH_EXIT_CRITICAL_();
+}
+#endif
+
+#endif
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhtrc_filter.c ./rkh/src/rkhtrc_filter.c
--- a_qSC69Z/rkh/src/rkhtrc_filter.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhtrc_filter.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,324 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_filter.c
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    aptTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.21.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_filter.h"
+#include "rkhfwk_bittbl.h"
+#include "rkhassert.h"
+
+#if RKH_CFG_TRC_RTFIL_EN == RKH_ENABLED
+/* ----------------------------- Local macros ------------------------------ */
+/*
+ * This macro is needed only if the module requires to check expressions 
+ * that ought to be true as long as the program  is running.
+ */
+RKH_MODULE_NAME(rkhtrc_filter)
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+/**
+ *  \brief
+ *  Filter table of trace events.
+ *
+ *  The trace filter management is similar to the native priority scheme.
+ *  In this case, each trace event is assigned a unique number
+ *  (See RKH_TE_<group>_<event> definitions). When a event is ready to record 
+ *  a trace its corresponding bit in the filter table must be clear. The size 
+ *  of trceftbl[] depends on #RKH_TOT_NUM_TRC_EVTS.
+ *
+ *  Trace event number = | 0 | Y | Y | Y | Y | X | X | X |\n
+ *
+ *  Y's:	index into trceftbl[ #RKH_TRC_MAX_EVENTS_IN_BYTES ] table.\n
+ *  X's:	bit position in trceftbl[ Y's ].\n
+ *
+ *  The lower 3 bits (X's) of the trace event number are used to determine
+ *  the bit position in trceftbl[], while the next four most significant bits
+ *  (Y's) are used to determine the index into trceftbl[].
+ */
+static rui8_t trceftbl[RKH_TRC_MAX_EVENTS_IN_BYTES];
+
+/**
+ *  \brief
+ *  Filter table of trace groups.
+ *
+ *  Each bit in #trcgfilter is used to indicate whenever any trace group
+ *  is filtered out its events. See RKH_TG_<group> and RKH_TG_T.
+ *
+ *  \code
+ *  bit position =   7   6   5   4   3   2   1   0   -- Groups
+ *  trcgfilter   = | Y | Y | Y | Y | Y | Y | Y | Y |
+ *                           |		         |   |___ RKH_TG_MP
+ *						     |			     |_______ RKH_TG_QUE
+ *                           |				          ...
+ *                           |_______________________ RKH_TG_FWK
+ *	\endcode
+ */
+static rui8_t trcgfilter;
+
+/**
+ *  \brief
+ *  Filter table of trace points associated with the SMA (AO).
+ *
+ *  The trace filter management is similar to the native priority scheme.
+ *  In this case, each SMA is assigned a unique priority number. When a SMA
+ *  is ready to record a trace its corresponding bit in the filter table
+ *  must be clear. The size of #trcsmaftbl[] depends on
+ *  #RKH_CFG_FWK_MAX_SMA (see rkhcfg.h).
+ *
+ *  SMA priority number = | Y | Y | Y | Y | Y | X | X | X |\n
+ *
+ *  Y's:	index into trcsmaftbl[ #RKH_TRC_MAX_SMA ] table.\n
+ *  X's:	bit position in trcsmaftbl[ Y's ].\n
+ *
+ *  The lower 3 bits (X's) of the SMA priority number are used to determine
+ *  the bit position in trcsmaftbl[], while the next five most significant bits
+ *  (Y's) are used to determine the index into trcsmaftbl[].
+ */
+static rui8_t trcsmaftbl[RKH_TRC_MAX_SMA];
+
+/**
+ *  \brief
+ *  Filter table of trace points associated with the event signals.
+ *	Similar to trcsmaftbl[].
+ *
+ *  Signal number = | Y | ... | Y | Y | Y | X | X | X |\n
+ *
+ *  Y's:	index into trcsigftbl[ #RKH_TRC_MAX_SIGNALS ] table.\n
+ *  X's:	bit position in trcsigftbl[ Y's ].\n
+ *
+ *  The lower 3 bits (X's) of the event signal are used to determine the bit
+ *  position in trcsigftbl[], while the next most significant bits (Y's) are
+ *  used to determine the index into trcsigftbl[].
+ */
+static rui8_t trcsigftbl[RKH_TRC_MAX_SIGNALS];
+
+/** 
+ *  \brief
+ *  Map a trace event ID to its corresponding filter.
+ */
+static RKHROM RKH_GMTBL_T trcgmtbl[] =
+{
+    {RKH_MP_TTBL_OFFSET,    RKH_MP_TTBL_RANGE},
+    {RKH_QUE_TTBL_OFFSET,    RKH_QUE_TTBL_RANGE},
+    {RKH_SMA_TTBL_OFFSET,   RKH_SMA_TTBL_RANGE},
+    {RKH_SM_TTBL_OFFSET,    RKH_SM_TTBL_RANGE},
+    {RKH_TIM_TTBL_OFFSET,   RKH_TIM_TTBL_RANGE},
+    {RKH_FWK_TTBL_OFFSET,   RKH_FWK_TTBL_RANGE},
+    {RKH_USR_TTBL_OFFSET,   RKH_USR_TTBL_RANGE},
+    {RKH_UT_TTBL_OFFSET,    RKH_UT_TTBL_RANGE}
+};
+
+/**
+ *  \brief
+ *  The tables to filter trace events related to signal and active objects.
+ */
+static const RKH_TRC_FIL_T fsig = {RKH_TRC_MAX_SIGNALS,   trcsigftbl};
+static const RKH_TRC_FIL_T fsma = {RKH_TRC_MAX_SMA,       trcsmaftbl};
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+static void
+setAllFilters(rui8_t *filterTbl, rui8_t value, ruint size)
+{
+    rui8_t *ft, ix, c;
+
+    for (ft = filterTbl, ix = 0,
+         c = (rui8_t)((value == FILTER_OFF) ? 0xFF : 0);
+         ix < size; ++ix, ++ft)
+    {
+        *ft = c;
+    }
+}
+
+static void
+setOneFilter(rui8_t *filterByte, rui8_t value, rui8_t bitPos)
+{
+    if (value == FILTER_OFF)
+    {
+        *filterByte |= rkh_bittbl_getBitMask(bitPos);
+    }
+    else
+    {
+        *filterByte &= ~rkh_bittbl_getBitMask(bitPos);
+    }
+}
+
+static rbool_t
+isOffFilter(rui8_t *filterTbl, RKH_TE_ID_T filter)
+{
+    rui8_t x;
+    RKH_TE_ID_T y;
+
+    y = filter >> 3;
+    x = (rui8_t)(filter & 7);
+    return (*(filterTbl + y) & rkh_bittbl_getBitMask(x)) != 0;
+}
+
+static const RKH_TRC_FIL_T *
+getFilterTable(RKHFilter fd)
+{
+    RKH_REQUIRE(fd < RKHFilterNums);
+    return (fd == RKHFilterSignal) ? &fsig : &fsma;
+}
+
+/* ---------------------------- Global functions --------------------------- */
+void 
+rkh_trc_filter_group_(rui8_t ctrl, RKH_TG_T grp, rui8_t mode)
+{
+    RKH_GM_OFFSET_T offset;
+    RKH_GM_RANGE_T range;
+
+    if (grp == RKH_TRC_ALL_GROUPS)
+    {
+        trcgfilter = (rui8_t)((ctrl == FILTER_OFF) ? 0xFF : 0);
+        return;
+    }
+
+    setOneFilter(&trcgfilter, ctrl, grp);
+
+    if (mode == ECHANGE)
+    {
+        offset = trcgmtbl[grp].offset;
+        range = trcgmtbl[grp].range;
+        setAllFilters(&trceftbl[offset], ctrl, range);
+    }
+}
+
+void 
+rkh_trc_filter_event_(rui8_t ctrl, RKH_TE_ID_T evt)
+{
+    RKH_TG_T grp;
+    RKH_TE_ID_T e;
+    RKH_GM_OFFSET_T offset;
+
+    RKH_ASSERT(evt <= RKH_TRC_ALL_EVENTS);
+
+    if (evt == RKH_TRC_ALL_EVENTS)
+    {
+        setAllFilters(trceftbl, ctrl, RKH_TRC_MAX_EVENTS_IN_BYTES);
+        trcgfilter = (rui8_t)((ctrl == FILTER_OFF) ? 0xFF : 0);
+    }
+    else
+    {
+        e = GETEVT(evt);
+        grp = GETGRP(evt);
+        offset = (RKH_GM_OFFSET_T)(trcgmtbl[grp].offset + (e >> 3));
+
+        setOneFilter(&trceftbl[offset], ctrl, e & 7);
+        if (ctrl == FILTER_OFF)
+        {
+            trcgfilter |= rkh_bittbl_getBitMask(grp);
+        }
+    }
+}
+
+rbool_t 
+rkh_trc_isoff_(RKH_TE_ID_T e)
+{
+    RKH_TE_ID_T evt;
+    RKH_TG_T grp;
+    RKH_GM_OFFSET_T offset;
+
+    evt = GETEVT(e);
+    grp = GETGRP(e);
+    offset = trcgmtbl[grp].offset;
+
+    return (((trcgfilter & rkh_bittbl_getBitMask(grp)) != 0) && 
+              isOffFilter(&trceftbl[offset], evt));
+}
+
+void 
+rkh_trc_symFil(RKHFilter fd, RKH_TRC_FSLOT slot, rui8_t mode)
+{
+    rui8_t x, onoff;
+    RKH_TRC_FSLOT y;
+    const RKH_TRC_FIL_T *filter;
+
+    filter = getFilterTable(fd);
+    RKH_REQUIRE(slot <= (filter->size << 3));
+    onoff = (rui8_t)(mode & RKH_FILTER_MODE_MASK);
+
+    if (mode & RKH_TRC_ALL_FILTERS)
+    {
+        setAllFilters(filter->tbl, onoff, filter->size);
+    }
+    else
+    {
+        y = (RKH_TRC_FSLOT)(slot >> 3);
+        x = (rui8_t)(slot & 7);
+        setOneFilter(filter->tbl + y, onoff, x);
+    }
+}
+
+rbool_t 
+rkh_trc_symFil_isoff(RKHFilter fd, RKH_TRC_FSLOT slot)
+{
+    const RKH_TRC_FIL_T *filter;
+
+    filter = getFilterTable(fd);
+    RKH_REQUIRE(slot <= (filter->size << 3));
+    return isOffFilter(filter->tbl, (RKH_TE_ID_T)slot);
+}
+
+void 
+rkh_trc_filter_get(RKH_FilterTbl *outFilterTbl)
+{
+    if (outFilterTbl == (RKH_FilterTbl *)0)
+        return;
+    outFilterTbl->signal = &fsig;
+    outFilterTbl->ao = &fsma;
+    outFilterTbl->event = trceftbl;
+    outFilterTbl->group = &trcgfilter;
+    outFilterTbl->grpFilMap = trcgmtbl;
+}
+
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhtrc_record.c ./rkh/src/rkhtrc_record.c
--- a_qSC69Z/rkh/src/rkhtrc_record.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhtrc_record.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,268 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_record.c
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    aptTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.20.04  LeFr  v2.4.05  ---
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_record.h"
+#include "rkhtrc_stream.h"
+#include "rkhtrc_filter.h"
+#include "rkhassert.h"
+#include "rkhsma.h"
+#include "rkhfwk_hook.h"
+
+#if RKH_CFG_TRC_EN == RKH_ENABLED
+
+/* ----------------------------- Local macros ------------------------------ */
+/*
+ * This macro is needed only if the module requires to check expressions 
+ * that ought to be true as long as the program  is running.
+ */
+RKH_MODULE_NAME(rkhtrc_record)
+
+#if RKH_CFG_TRC_TSTAMP_EN == RKH_ENABLED
+    #if RKH_CFGPORT_TRC_SIZEOF_TSTAMP == 8
+        #define RKH_TRC_TSTAMP() \
+            RKH_TRC_UI8(rkh_trc_getts())
+    #elif RKH_CFGPORT_TRC_SIZEOF_TSTAMP == 16
+        #define RKH_TRC_TSTAMP() \
+            RKH_TRC_UI16(rkh_trc_getts())
+    #elif RKH_CFGPORT_TRC_SIZEOF_TSTAMP == 32
+        #define RKH_TRC_TSTAMP() \
+            RKH_TRC_UI32(rkh_trc_getts())
+    #else
+        #define RKH_TRC_TSTAMP() \
+            RKH_TRC_UI16(rkh_trc_getts())
+    #endif
+#else
+    #define RKH_TRC_TSTAMP()
+#endif
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static rui8_t chk;
+static rui8_t nseq;
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void
+rkh_trc_init(void)
+{
+    rkh_trcStream_init();
+    nseq = 0;
+    chk = 0;
+}
+
+void
+rkh_trc_begin(RKH_TE_ID_T eid)
+{
+    chk = 0;            /* Initialize the trace record checksum */
+    RKH_TRC_TE_ID(eid); /* Insert the event ID */
+#if RKH_CFG_TRC_NSEQ_EN == RKH_ENABLED
+    rkh_trc_u8((rui8_t)(nseq)); /* Insert the sequence number */
+    ++nseq;
+#endif
+    RKH_TRC_TSTAMP();   /* Insert the timestamp */
+}
+
+void
+rkh_trc_end(void)
+{
+#if RKH_CFG_TRC_CHK_EN == RKH_ENABLED
+    chk = (rui8_t)(~chk + 1);   /* Inserts the previously calculated */
+    rkh_trc_u8(chk);            /* checksum as: */
+                                /* checksum = 0 - sum mod-256 -> */
+                                /* ~(sum mod-256) + 1 */
+#endif
+    rkh_trc_put(RKH_FLG);   /* Inserts directly into the trace stream the */
+                            /* flag byte in a raw (without escaped sequence) */
+                            /* manner */
+    RKH_HOOK_PUT_TRCEVT();
+}
+
+void
+rkh_trc_clear_chk(void)
+{
+    chk = 0;
+}
+
+void
+rkh_trc_u8(rui8_t d)
+{
+    chk = (rui8_t)(chk + d);
+    if ((d == RKH_FLG) || (d == RKH_ESC))
+    {
+        rkh_trc_put(RKH_ESC);
+        rkh_trc_put((rui8_t)(d ^ RKH_XOR));
+    }
+    else
+    {
+        rkh_trc_put(d);
+    }
+}
+
+void
+rkh_trc_u16(rui16_t d)
+{
+    rkh_trc_u8((rui8_t)d);
+    d >>= 8;
+    rkh_trc_u8((rui8_t)d);
+}
+
+void
+rkh_trc_u32(rui32_t d)
+{
+    rkh_trc_u8((rui8_t)d);
+    d >>= 8;
+    rkh_trc_u8((rui8_t)d);
+    d >>= 8;
+    rkh_trc_u8((rui8_t)d);
+    d >>= 8;
+    rkh_trc_u8((rui8_t)d);
+}
+
+void
+rkh_trc_str(const char *s)
+{
+    while (*s != '\0')
+        rkh_trc_u8((rui8_t)*s++);
+    rkh_trc_u8('\0');
+}
+
+void
+rkh_trc_obj(RKH_TE_ID_T tre, rui8_t *obj, const char *obj_name)
+{
+    RKH_TRC_BEGIN_WOFIL(tre)
+        RKH_TRC_SYM(obj);
+        RKH_TRC_STR(obj_name);
+    RKH_TRC_END_WOFIL()
+    RKH_TRC_FLUSH();
+}
+
+void
+rkh_trc_sig(RKH_SIG_T sig, const char *sig_name)
+{
+    RKH_TRC_BEGIN_WOFIL(RKH_TE_FWK_SIG)
+        RKH_TRC_SIG(sig);
+        RKH_TRC_STR(sig_name);
+    RKH_TRC_END_WOFIL()
+    RKH_TRC_FLUSH();
+}
+
+void
+rkh_trc_ao(void *ao)
+{
+    RKH_TRC_BEGIN_WOFIL(RKH_TE_FWK_AO)
+        RKH_TRC_SYM(ao);
+        RKH_TRC_STR(RKH_GET_AO_NAME((RKH_SMA_T *)ao));
+    RKH_TRC_END_WOFIL()
+    RKH_TRC_FLUSH();
+}
+
+void
+rkh_trc_state(void *ao, rui8_t *state)
+{
+    
+    RKH_TRC_BEGIN_WOFIL((CB((state))->type & RKH_REGULAR) == 0 ? 
+                                                        RKH_TE_FWK_PSTATE:
+                                                        RKH_TE_FWK_STATE)
+        RKH_TRC_SYM(ao);
+        RKH_TRC_SYM(state);
+        RKH_TRC_STR(RKH_GET_VERTEX_NAME(state));
+    RKH_TRC_END_WOFIL()
+    RKH_TRC_FLUSH();
+}
+
+#if RKH_CFG_TRC_USER_TRACE_EN == RKH_ENABLED
+void
+rkh_trc_fmt_u8(rui8_t fmt, rui8_t d)
+{
+    rkh_trc_u8(fmt);
+    rkh_trc_u8(d);
+}
+
+void
+rkh_trc_fmt_u16(rui8_t fmt, rui16_t d)
+{
+    rkh_trc_u8(fmt);
+    rkh_trc_u16(d);
+}
+
+void
+rkh_trc_fmt_u32(rui8_t fmt, rui32_t d)
+{
+    rkh_trc_u8(fmt);
+    rkh_trc_u32(d);
+}
+
+void
+rkh_trc_fmt_str(const char *s)
+{
+    rkh_trc_u8((rui8_t)RKH_STR_T);
+    while (*s != '\0')
+        rkh_trc_u8((rui8_t)*s++);
+    rkh_trc_u8('\0');
+}
+
+void
+rkh_trc_fmt_mem(const rui8_t *mem, rui8_t size)
+{
+    rkh_trc_u8((rui8_t)RKH_MEM_T);
+    rkh_trc_u8(size);
+    while (size != 0)
+    {
+        rkh_trc_u8((rui8_t)*mem++);
+        --size;
+    }
+}
+
+#endif
+#endif
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/rkh/src/rkhtrc_stream.c ./rkh/src/rkhtrc_stream.c
--- a_qSC69Z/rkh/src/rkhtrc_stream.c	1969-12-31 21:00:00.000000000 -0300
+++ ./rkh/src/rkhtrc_stream.c	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,157 @@
+/*
+ *  --------------------------------------------------------------------------
+ *
+ *                                Framework RKH
+ *                                -------------
+ *
+ *            State-machine framework for reactive embedded systems
+ *
+ *                      Copyright (C) 2010 Leandro Francucci.
+ *          All rights reserved. Protected by international copyright laws.
+ *
+ *
+ *  RKH is free software: you can redistribute it and/or modify it under the
+ *  terms of the GNU General Public License as published by the Free Software
+ *  Foundation, either version 3 of the License, or (at your option) any
+ *  later version.
+ *
+ *  RKH is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with RKH, see copying.txt file.
+ *
+ *  Contact information:
+ *  RKH web site:   http://sourceforge.net/projects/rkh-reactivesys/
+ *  e-mail:         francuccilea@gmail.com
+ *  ---------------------------------------------------------------------------
+ */
+
+/**
+ *  \file       rkhtrc_stream.c
+ *  \brief      Platform - independent interface for RKH trace facility.
+ *  \ingroup    aptTrc
+ */
+
+/* -------------------------- Development history -------------------------- */
+/*
+ *  2017.21.04  LeFr  v2.4.05  Initial version
+ */
+
+/* -------------------------------- Authors -------------------------------- */
+/*
+ *  LeFr  Leandro Francucci  francuccilea@gmail.com
+ */
+
+/* --------------------------------- Notes --------------------------------- */
+/* ----------------------------- Include files ----------------------------- */
+#include "rkhtrc_stream.h"
+#include "rkhfwk_bittbl.h"
+#include "rkhassert.h"
+
+/* ----------------------------- Local macros ------------------------------ */
+/*
+ * This macro is needed only if the module requires to check expressions 
+ * that ought to be true as long as the program  is running.
+ */
+RKH_MODULE_NAME(rkhtrc_stream)
+
+/* ------------------------------- Constants ------------------------------- */
+/* ---------------------------- Local data types --------------------------- */
+/* ---------------------------- Global variables --------------------------- */
+/* ---------------------------- Local variables ---------------------------- */
+static rui8_t trcstm[RKH_CFG_TRC_SIZEOF_STREAM];
+static rui8_t *trcin, *trcout, *trcend;
+static TRCQTY_T trcqty;
+
+/* ----------------------- Local function prototypes ----------------------- */
+/* ---------------------------- Local functions ---------------------------- */
+/* ---------------------------- Global functions --------------------------- */
+void 
+rkh_trcStream_init(void)
+{
+    trcin = trcout = trcstm;
+    trcqty = 0;
+    trcend = &trcstm[RKH_CFG_TRC_SIZEOF_STREAM];
+    RKH_TRC_U8_RAW(RKH_FLG);
+}
+
+rui8_t *
+rkh_trc_get(void)
+{
+    rui8_t *trByte = (rui8_t *)0;
+
+    if (trcqty == 0)
+    {
+        return trByte;
+    }
+
+    trByte = trcout++;
+    --trcqty;
+
+    if (trcout >= trcend)
+    {
+        trcout = trcstm;
+    }
+
+    return trByte;
+}
+
+rui8_t *
+rkh_trc_get_block(TRCQTY_T *nget)
+{
+    rui8_t *trByte = (rui8_t *)0;
+    TRCQTY_T n;
+
+    if (trcqty == (TRCQTY_T)0)
+    {
+        *nget = (TRCQTY_T)0;
+        return trByte;
+    }
+
+    trByte = trcout;
+
+    /* Calculates the number of bytes to be retrieved */
+    n = (TRCQTY_T)(trcend - trcout);    /* bytes until the end */
+    if (n > trcqty)
+    {
+        n = trcqty;
+    }
+    if (n > *nget)
+    {
+        n = *nget;
+    }
+
+    *nget = n;
+    trcout += n;
+    trcqty -= n;
+
+    if (trcout >= trcend)
+    {
+        trcout = trcstm;
+    }
+
+    return trByte;
+}
+
+void 
+rkh_trc_put(rui8_t b)
+{
+    *trcin++ = b;
+    ++trcqty;
+
+    if (trcin == trcend)
+    {
+        trcin = trcstm;
+    }
+
+    if (trcqty >= RKH_CFG_TRC_SIZEOF_STREAM)
+    {
+        trcqty = RKH_CFG_TRC_SIZEOF_STREAM;
+        trcout = trcin;
+    }
+}
+
+/* ------------------------------ End of file ------------------------------ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_7_segment_display.h ./sapi/inc/sapi_7_segment_display.h
--- a_qSC69Z/sapi/inc/sapi_7_segment_display.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_7_segment_display.h	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,87 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _SAPI_7_SEGMENT_DISPLAY_H_
+#define _SAPI_7_SEGMENT_DISPLAY_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[macros]=================================================*/
+
+#define DISPLAY_OFF 25
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/* Test 7-segment display connected pins */
+/*
+----------------+------------+-----------+------------
+ Segment ON     | BIN Value  | HEX Value | Output pin
+----------------+------------+-----------+------------
+ Segment 'a' ON | 0b00000001 |   0x20    | ..... (to be complete)
+ Segment 'b' ON | 0b00000010 |   0x80    | .....
+ Segment 'c' ON | 0b00000100 |   0x40    | .....
+ Segment 'd' ON | 0b00001000 |   0x02    | .....
+ Segment 'e' ON | 0b00010000 |   0x04    | .....
+ Segment 'f' ON | 0b00100000 |   0x10    | .....
+ Segment 'g' ON | 0b01000000 |   0x08    | .....
+ Segment 'h' ON | 0b10000000 |   0x80    | .....
+----------------+------------+-----------+------------
+
+                a
+              -----
+          f /     / b
+	   /  g  /
+	   -----
+       e /     / c
+	/  d  /
+	-----    O h = dp (decimal pint).
+
+*/
+void display7SegmentTestPins( gpioMap_t* display7SegmentPins, gpioMap_t pin );
+
+/* Configure 7-segment display GPIOs as Outputs */
+void display7SegmentPinConfig( gpioMap_t* display7SegmentPins );
+
+/* Write a symbol on 7-segment display */
+void display7SegmentWrite( gpioMap_t* display7SegmentPins, uint8_t symbolIndex );
+
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_7_SEGMENT_DISPLAY_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_adc.h ./sapi/inc/sapi_adc.h
--- a_qSC69Z/sapi/inc/sapi_adc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_adc.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,74 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+#ifndef SAPI_ADC_H_
+#define SAPI_ADC_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   ADC_ENABLE, ADC_DISABLE
+} adcConfig_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void adcConfig( adcConfig_t config );
+
+uint16_t adcRead( adcMap_t analogInput );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef SAPI_ADC_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_board.h ./sapi/inc/sapi_board.h
--- a_qSC69Z/sapi/inc/sapi_board.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_board.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,66 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_BOARD_H_
+#define _SAPI_BOARD_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void boardConfig(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_BOARD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_dac.h ./sapi/inc/sapi_dac.h
--- a_qSC69Z/sapi/inc/sapi_dac.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_dac.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,74 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+#ifndef SAPI_DAC_H_
+#define SAPI_DAC_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   DAC_ENABLE, DAC_DISABLE
+} dacConfig_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void dacConfig( dacConfig_t config );
+
+void dacWrite( dacMap_t analogOutput, uint16_t value );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_DAC_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_datatypes.h ./sapi/inc/sapi_datatypes.h
--- a_qSC69Z/sapi/inc/sapi_datatypes.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_datatypes.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,116 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_DATATYPES_H_
+#define _SAPI_DATATYPES_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "stdint.h"
+#include "chip.h"
+#include "board.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+/* Functional states */
+#ifndef ON
+   #define ON     1
+#endif
+#ifndef OFF
+   #define OFF    0
+#endif
+
+/* Electrical states */
+#ifndef HIGH
+   #define HIGH   1
+#endif
+#ifndef LOW
+   #define LOW    0
+#endif
+
+/* Logical states */
+
+#ifndef FALSE
+   #define FALSE  0
+#endif
+#ifndef TRUE
+   #define TRUE   (!FALSE)
+#endif
+
+/*==================[typedef]================================================*/
+
+/* Define Boolean Data Type */
+typedef uint8_t bool_t;
+
+/* Define real Data Types (floating point) */
+//typedef real32_t float;
+//typedef real64_t double;
+
+/* Define Tick Data Type */
+typedef uint64_t tick_t;
+
+/*
+ * Function Pointer definition
+ * --------------------------------------
+ * param:  void * - For passing arguments
+ * return: bool_t - For Error Reports
+ */
+typedef bool_t (*sAPI_FuncPtr_t)(void *);
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * Null Function Pointer definition
+ * --------------------------------------
+ * param:  void * - Not used
+ * return: bool_t - Return always true
+ */
+bool_t sAPI_NullFuncPtr(void *);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_DATATYPES_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_delay.h ./sapi/inc/sapi_delay.h
--- a_qSC69Z/sapi/inc/sapi_delay.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_delay.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,86 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_DELAY_H_
+#define _SAPI_DELAY_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/* Define the number of cycles for 1ms */
+#define INACCURATE_TO_MS       20400
+#define INACCURATE_TO_US_x10   204
+
+/*==================[typedef]================================================*/
+
+typedef struct{
+   tick_t startTime;
+   tick_t duration;
+   bool_t running;
+} delay_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/* ---- Inaccurate Delay ---- */
+void delayInaccurate( tick_t delay );
+void delayInaccurateUs(tick_t delay_us);
+
+/* ---- Blocking Delay ---- */
+void delay ( tick_t delay );
+
+/* ---- Non Blocking Delay ---- */
+void delayConfig( delay_t * delay, tick_t duration );
+bool_t delayRead( delay_t * delay );
+void delayWrite( delay_t * delay, tick_t duration );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_DELAY_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_gpio.h ./sapi/inc/sapi_gpio.h
--- a_qSC69Z/sapi/inc/sapi_gpio.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_gpio.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,101 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_GPIO_H_
+#define _SAPI_GPIO_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/* Pin modes */
+/*
+ *  INPUT  =  0    (No PULLUP or PULLDOWN)
+ *  OUTPUT =  1
+ *  INPUT_PULLUP
+ *  INPUT_PULLDOWN
+ *  INPUT_REPEATER (PULLUP and PULLDOWN)
+ *  INITIALIZE
+ */
+typedef enum{
+   GPIO_INPUT, GPIO_OUTPUT,
+   GPIO_INPUT_PULLUP, GPIO_INPUT_PULLDOWN,
+   GPIO_INPUT_PULLUP_PULLDOWN,
+   GPIO_ENABLE
+} gpioConfig_t;
+
+
+/* ----- Begin Pin Config Structs NXP LPC4337 ----- */
+
+typedef struct{
+   int8_t port;
+   int8_t pin;
+} gpioConfigLpc4337_t;
+
+typedef struct{
+    pinConfigLpc4337_t pinName;
+                int8_t func;
+   gpioConfigLpc4337_t gpio;
+} pinConfigGpioLpc4337_t;
+
+/* ------ End Pin Config Structs NXP LPC4337 ------ */
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t gpioConfig( gpioMap_t pin, gpioConfig_t config );
+bool_t gpioRead( gpioMap_t pin );
+bool_t gpioWrite( gpioMap_t pin, bool_t value );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_GPIO_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi.h ./sapi/inc/sapi.h
--- a_qSC69Z/sapi/inc/sapi.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi.h	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,86 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_H_
+#define _SAPI_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+//#include "sapi_isr_vector.h"
+
+#include "sapi_board.h"
+#include "sapi_tick.h"
+#include "sapi_gpio.h"
+#include "sapi_uart.h"
+#include "sapi_adc.h"
+#include "sapi_dac.h"
+#include "sapi_i2c.h"
+#include "sapi_rtc.h"
+#include "sapi_sleep.h"
+
+#include "sapi_delay.h"             // Use Tick module
+
+#include "sapi_7_segment_display.h" // Use GPIO and Delay modules
+#include "sapi_keypad.h"            // Use GPIO and Delay modules
+#include "sapi_pwm.h"               // Use SCT and GPIO modules
+#include "sapi_servo.h"             // Use Timer and GPIO modules
+#include "sapi_hmc5883l.h"          // Use I2C module
+
+/* External Peripherals */
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_hmc5883l.h ./sapi/inc/sapi_hmc5883l.h
--- a_qSC69Z/sapi/inc/sapi_hmc5883l.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_hmc5883l.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,154 @@
+/* Copyright 2016, Alejandro Permingeat
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-06-27 */
+
+#ifndef _SAPI_HMC5883L_H_
+#define _SAPI_HMC5883L_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define HMC5883L_ADD              0x1E
+
+#define HMC5883L_REG_CONFIG_A     0x00
+#define HMC5883L_REG_CONFIG_B     0x01
+
+#define HMC5883L_REG_MODE         0x02
+
+#define HMC5883L_REG_X_MSB        0x03
+#define HMC5883L_REG_X_LSB        0x04
+
+#define HMC5883L_REG_Z_MSB        0x05
+#define HMC5883L_REG_Z_LSB        0x06
+
+#define HMC5883L_REG_Y_MSB        0x07
+#define HMC5883L_REG_Y_LSB        0x08
+
+#define HMC5883L_REG_STATUS       0x09
+
+#define HMC5883L_REG_ID_REG_A     0x0A
+#define HMC5883L_REG_ID_REG_B     0x0B
+#define HMC5883L_REG_ID_REG_C     0x0C
+
+#define HMC5883L_VALUE_ID_REG_A   0x48
+#define HMC5883L_VALUE_ID_REG_B   0x34
+#define HMC5883L_VALUE_ID_REG_C   0x33
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+   HMC5883L_1_sample = 0,
+   HMC5883L_2_sample = 1,
+   HMC5883L_4_sample = 2,
+   HMC5883L_8_sample = 3,
+   HMC5883L_DEFAULT_sample = HMC5883L_1_sample
+} HMC5883L_samples_t;
+
+typedef enum {
+   HMC5883L_0_75_Hz = 0,
+   HMC5883L_1_50_Hz = 1,
+   HMC5883L_3_Hz    = 2,
+   HMC5883L_7_50_Hz = 3,
+   HMC5883L_15_Hz   = 4,
+   HMC5883L_30_Hz   = 5,
+   HMC5883L_75_Hz   = 6,
+   HMC5883L_DEFAULT_rate = HMC5883L_15_Hz
+} HMC5883L_rate_t;
+
+typedef enum {
+   HMC5883L_normal   = 0,
+   HMC5883L_positive = 1,
+   HMC5883L_regative = 2,
+   HMC5883L_DEFAULT_messurement = HMC5883L_normal
+} HMC5883L_messurement_t;
+
+typedef enum {
+   HMC5883L_1370 = 0, /* Â± 0.88 Ga */
+   HMC5883L_1090 = 1, /* Â± 1.3 Ga  */
+   HMC5883L_820  = 2, /* Â± 1.9 Ga  */
+   HMC5883L_660  = 3, /* Â± 2.5 Ga  */
+   HMC5883L_440  = 4, /* Â± 4.0 Ga  */
+   HMC5883L_390  = 5, /* Â± 4.7 Ga  */
+   HMC5883L_330  = 6, /* Â± 5.6 Ga  */
+   HMC5883L_230  = 7, /* Â± 8.1 Ga  */
+   HMC5883L_DEFAULT_gain = HMC5883L_1090
+} HMC5883L_gain_t;
+
+typedef enum {
+   HMC5883L_continuous_measurement = 0,
+   HMC5883L_single_measurement = 1,
+   HMC5883L_idle = 2,
+   HMC5883L_DEFAULT_mode = HMC5883L_single_measurement
+} HMC5883L_mode_t;
+
+typedef struct{
+   HMC5883L_samples_t samples; /*number of samples averaged (1 to 8) per measurement output.*/
+   HMC5883L_rate_t    rate;    /* Data Output Rate Bits. These bits set the rate at which data
+                                * is written to all three data output registers.*/
+   HMC5883L_messurement_t meassurement; /*Measurement Configuration Bits. These bits define the
+                                         * measurement flow of the device, specifically whether or not
+                                         * to incorporate an applied bias into the measurement.*/
+   HMC5883L_gain_t gain; /* Gain Configuration Bits. These bits configure the gain for
+                          * the device. The gain configuration is common for all
+                          * channels.*/
+   HMC5883L_mode_t mode;
+} HMC5883L_config_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t hmc5883lIsAlive(void);
+bool_t hmc5883lPrepareDefaultConfig( HMC5883L_config_t * config );
+bool_t hmc5883lConfig( HMC5883L_config_t config );
+bool_t hmc5883lRead( int16_t * x, int16_t * y, int16_t * z );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_HMC5883L_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_i2c.h ./sapi/inc/sapi_i2c.h
--- a_qSC69Z/sapi/inc/sapi_i2c.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_i2c.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,133 @@
+/* Copyright 2016, Eric Pernia
+ * Copyright 2016, Alejandro Permingeat.
+ * Copyright 2016, Eric Pernia
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+ /*
+  * Date:
+  * 2016-05-02 Eric Pernia - Only define API
+  * 2016-06-23 Alejandro Permingeat - First functional version
+  * 2016-08-07 Eric Pernia - Improve names
+  * 2016-09-10 Eric Pernia - Add unlimited buffer transfer
+  * 2016-11-20 Eric Pernia - Software I2C
+  */
+
+#ifndef _SAPI_I2C_H_
+#define _SAPI_I2C_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define I2C_SOFTWARE_SDA_DIR   GPIO7
+#define I2C_SOFTWARE_SDA_IN    GPIO7
+#define I2C_SOFTWARE_SDA_OUT   GPIO7
+
+#define I2C_SOFTWARE_SCL_DIR   GPIO8
+#define I2C_SOFTWARE_SCL_IN    GPIO8
+#define I2C_SOFTWARE_SCL_OUT   GPIO8
+
+#define I2C_SOFTWARE           0
+#define SOFTWARE_I2C_DEBUG     0
+
+/*==================[typedef]================================================*/
+
+#if( I2C_SOFTWARE == 1 )
+typedef enum{
+   I2C_SOFTWARE_WRITE = 0,
+   I2C_SOFTWARE_READ  = 1
+} I2C_Software_rw_t;
+
+typedef enum{
+   I2C_SOFTWARE_NACK = 0,
+   I2C_SOFTWARE_ACK  = 1
+} I2C_Software_ack_t;
+#endif
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t i2cConfig( i2cMap_t i2cNumber, uint32_t clockRateHz );
+
+bool_t i2cRead( i2cMap_t  i2cNumber,
+                uint8_t  i2cSlaveAddress,
+                uint8_t* dataToReadBuffer,
+                uint16_t dataToReadBufferSize,
+                bool_t   sendWriteStop,
+                uint8_t* receiveDataBuffer,
+                uint16_t receiveDataBufferSize,
+                bool_t   sendReadStop );
+
+bool_t i2cWrite( i2cMap_t  i2cNumber,
+                 uint8_t  i2cSlaveAddress,
+                 uint8_t* transmitDataBuffer,
+                 uint16_t transmitDataBufferSize,
+                 bool_t   sendWriteStop );
+
+
+// Software Master I2C
+
+#if( SOFTWARE_I2C_DEBUG == 1 )
+   void i2cSoftwareMasterPinTestConfig( void );
+   void i2cSoftwareMasterPinTest( void );
+#endif
+
+#if( I2C_SOFTWARE == 1 )
+   void i2cSoftwareDelay( tick_t duration );
+
+   void i2cSoftwareMasterWriteStart( void );
+
+   void i2cSoftwareMasterWriteStop( void );
+
+   bool_t i2cSoftwareMasterWriteAddress( uint8_t i2cSlaveAddress,
+                                         I2C_Software_rw_t readOrWrite );
+
+   bool_t i2cSoftwareMasterWriteByte( uint8_t dataByte );
+
+   uint8_t i2cSoftwareMasterReadByte( bool_t ack );
+#endif
+
+/*==================[ISR external functions declaration]=====================*/
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_I2C_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_keypad.h ./sapi/inc/sapi_keypad.h
--- a_qSC69Z/sapi/inc/sapi_keypad.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_keypad.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,67 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _SAPI_KEYPAD_H_
+#define _SAPI_KEYPAD_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+typedef struct{
+   gpioMap_t* keypadRowPins;
+   uint8_t keypadRowSize;
+   gpioMap_t* keypadColPins;
+   uint8_t keypadColSize;
+} keypad_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/* Configure keypad pins */
+bool_t keypadConfig( keypad_t* keypad,
+                     gpioMap_t* keypadRowPins, uint8_t keypadRowSize,
+                     gpioMap_t* keypadColPins, uint8_t keypadColSize );
+
+/* Return TRUE if any key is pressed or FALSE (0) in other cases.
+ * If exist key pressed write pressed key on key variable */
+bool_t keypadRead( keypad_t* keypad, uint16_t* key );
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_KEYPAD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_peripheral_map.h ./sapi/inc/sapi_peripheral_map.h
--- a_qSC69Z/sapi/inc/sapi_peripheral_map.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_peripheral_map.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,170 @@
+/* Copyright 2015, Eric Pernia.
+ * Copyright 2016, Ian Olivieri.
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_PERIPHERALMAP_H_
+#define _SAPI_PERIPHERALMAP_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/* ----- Begin Pin Config Structs NXP LPC4337 ----- */
+
+typedef struct{
+   int8_t port;
+   int8_t pin;
+} pinConfigLpc4337_t;
+
+/* ------ End Pin Config Structs NXP LPC4337 ------ */
+
+
+/* ------- Begin EDU-CIAA-NXP Peripheral Map ------ */
+
+/* Defined for sapi_gpio.h */
+typedef enum{
+   /* EDU-CIAA-NXP */
+
+   // P1 header
+   T_FIL1,    T_COL2,    T_COL0,    T_FIL2,      T_FIL3,  T_FIL0,     T_COL1,
+   CAN_TD,    CAN_RD,    RS232_TXD, RS232_RXD,
+
+   // P2 header
+   GPIO8,     GPIO7,     GPIO5,     GPIO3,       GPIO1,
+   LCD1,      LCD2,      LCD3,      LCDRS,       LCD4,
+   SPI_MISO,
+   ENET_TXD1, ENET_TXD0, ENET_MDIO, ENET_CRS_DV, ENET_MDC, ENET_TXEN, ENET_RXD1,
+   GPIO6,     GPIO4,     GPIO2,     GPIO0,
+   LCDEN,
+   SPI_MOSI,
+   ENET_RXD0,
+
+   // Switches
+   // 36     37     38     39
+   TEC1,  TEC2,  TEC3,  TEC4,
+
+   // Leds
+   // 40     41     42     43     44     45
+   LED1,  LED2,  LED3,  LEDR,  LEDG,  LEDB,
+
+   /* CIAA-NXP */
+ /* 46     47     48     49     50     51     52     53 */
+   DI0,   DI1,   DI2,   DI3,   DI4,   DI5,   DI6,   DI7,
+ /* 54     55     56     57     58     59     60     61 */
+   DO0,   DO1,   DO2,   DO3,   DO4,   DO5,   DO6,   DO7
+} gpioMap_t;
+
+/* Defined for sapi_adc.h */
+typedef enum{
+/* 62         63       64        65       */
+   AI3 = 62, AI2 = 63, AI1 = 64, AI0 = 65,
+             CH3 = 63, CH2 = 64, CH1 = 65
+/*  46        47   48  49 */
+// AI2 = 46, AI1, AI0, AO
+} adcMap_t;
+
+/* Defined for sapi_dac.h */
+typedef enum{
+/* 66 */
+   AO = 66,
+   DAC = 66
+} dacMap_t;
+
+/* Defined for sapi_uart.h */
+typedef enum{
+   UART_USB, UART_232, UART_485
+} uartMap_t;
+
+/*Defined for sapi_timer.h*/
+//NOTE: if servo is enable (servoConfig used) the only available timer to use is TIMER0
+typedef enum{
+   TIMER0, TIMER1, TIMER2, TIMER3
+} timerMap_t;
+typedef enum{
+   TIMERCOMPAREMATCH0, TIMERCOMPAREMATCH1, TIMERCOMPAREMATCH2, TIMERCOMPAREMATCH3
+} timerCompareMatch_t;
+
+/*Defined for sapi_sct.h*/
+// NOTE: CTOUT11 has no SCT mode associated, so it can't be used!
+// NOTE: if pwm is enable (pwmConfig used) there will be no sct channels available
+typedef enum{
+   CTOUT0, CTOUT1, CTOUT2, CTOUT3, CTOUT4, CTOUT5, CTOUT6, CTOUT7, CTOUT8,
+   CTOUT9, CTOUT10, CTOUT11, CTOUT12, CTOUT13
+} sctMap_t;
+
+/*Defined for sapi_pwm.h*/
+typedef enum{
+   PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6, PWM7, PWM8, PWM9, PWM10
+} pwmMap_t;
+
+/*Defined for sapi_servo.h*/
+typedef enum{
+   SERVO0, SERVO1, SERVO2, SERVO3, SERVO4, SERVO5, SERVO6, SERVO7, SERVO8
+} servoMap_t;
+
+/*Defined for sapi_i2c.h*/
+/* Comment because already defined in "i2c_18xx_43xx.h"*/
+/*
+typedef enum{
+   I2C0 // TODO: Add support for I2C1
+} i2cMap_t;
+*/
+typedef uint8_t i2cMap_t;
+
+/* ------- End EDU-CIAA-NXP Peripheral Map -------- */
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_PERIPHERALMAP_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_pwm.h ./sapi/inc/sapi_pwm.h
--- a_qSC69Z/sapi/inc/sapi_pwm.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_pwm.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,102 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef PWM_DRIVER_H_
+#define PWM_DRIVER_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   PWM_ENABLE, PWM_DISABLE,
+   PWM_ENABLE_OUTPUT, PWM_DISABLE_OUTPUT
+} pwmConfig_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Initializes the pwm peripheral.
+ * @param  uint8_t pwmNumber
+ * @param  uint8_t config
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t pwmConfig( pwmMap_t pwmNumber, pwmConfig_t config);
+
+/*
+ * @brief:   Tells if the pwm is currently active, and its position
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   position (1 ~ PWM_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t pwmIsAttached( pwmMap_t pwmNumber );
+
+/*
+ * @brief:   read the value of the pwm in the pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   value of the pwm in the pin (0 ~ 255).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint8_t pwmRead( pwmMap_t pwmNumber );
+
+/*
+ * @brief:   change the value of the pwm at the selected pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @param:   value:   8bit value, from 0 to 255
+ * @return:   True if the value was successfully changed, False if not.
+ */
+bool_t pwmWrite( pwmMap_t pwmNumber, uint8_t percent );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* PWM_DRIVER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_rtc.h ./sapi/inc/sapi_rtc.h
--- a_qSC69Z/sapi/inc/sapi_rtc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_rtc.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,97 @@
+/* Copyright 2011, ChaN.
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-03-07 */
+
+#ifndef _SAPI_RTC_H_
+#define _SAPI_RTC_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+typedef struct {
+   uint16_t year;	 /* 1 to 4095 */
+   uint8_t  month; /* 1 to 12   */
+   uint8_t  mday;	 /* 1 to 31   */
+   uint8_t  wday;	 /* 1 to 7    */
+   uint8_t  hour;	 /* 0 to 23   */
+   uint8_t  min;	 /* 0 to 59   */
+   uint8_t  sec;	 /* 0 to 59   */
+} rtc_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Configure RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcConfig( rtc_t * rtc );
+
+/*
+ * @Brief: Get time from RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcRead( rtc_t * rtc );
+
+/*
+ * @Brief: Set time on RTC peripheral.
+ * @param  RTC_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcWrite( rtc_t * rtc );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* _SAPI_RTC_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_sct.h ./sapi/inc/sapi_sct.h
--- a_qSC69Z/sapi/inc/sapi_sct.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_sct.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,108 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef SAPI_SCT_H_
+#define SAPI_SCT_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+/*  SCT names are defined in sAPI_PeripheralMap.h:
+ * NOTE: CTOUT11 has no SCT mode associated, so it can't be used!
+
+typedef enum{
+   CTOUT0, CTOUT1, CTOUT2, CTOUT3, CTOUT4, CTOUT5, CTOUT6, CTOUT7, CTOUT8,
+   CTOUT9, CTOUT10, CTOUT11, CTOUT12, CTOUT13
+} SctMap_t;
+*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+/*
+ * @brief:   Initialize the SCT peripheral with the given frequency
+ * @param:   frequency:   value in Hz
+ * @note:   there can only be 1 frequency in all the SCT peripheral.
+ */
+void Sct_Init(uint32_t frequency);
+
+/*
+ * @brief	Enables pwm function for the given pin
+ * @param	sctNumber:   pin where the pwm signal will be generated
+ */
+void Sct_EnablePwmFor(uint8_t sctNumber);
+
+/*
+ * @brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   value:   8bit value, from 0 to 255
+ * @return   Equivalent in Ticks for the LPC4337
+ */
+uint32_t Sct_Uint8ToTicks(uint8_t value);
+
+/*
+ * @brief:   Sets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @param	value:   8bit value, from 0 to 255
+ * @note   For the 'ticks' parameter, see function Sct_Uint8ToTicks
+ */
+void Sct_SetDutyCycle(uint8_t sctNumber, uint8_t value);
+
+/*
+ * @brief:   Gets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @return:   duty cycle of the channel, from 0 to 255
+ */
+uint8_t Sct_GetDutyCycle(uint8_t sctNumber);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_SCT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_servo.h ./sapi/inc/sapi_servo.h
--- a_qSC69Z/sapi/inc/sapi_servo.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_servo.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,105 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef SAPI_SERVO_H_
+#define SAPI_SERVO_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   SERVO_ENABLE, SERVO_DISABLE,
+   SERVO_ENABLE_OUTPUT, SERVO_DISABLE_OUTPUT
+} servoConfig_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Initializes the servo peripheral
+ * @param  uint8_t servoNumber
+ * @param  uint8_t config
+ * @return bool_t true (1) if config it is ok
+ * @IMPORTANT:   this function uses Timer 1, 2 and 3 to generate the servo signals, so
+ *   they won't be available to use.
+ */
+bool_t servoConfig( servoMap_t servoNumber, servoConfig_t config );
+
+/*
+ * @brief:   Tells if the servo is currently active, and its position
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return:   position (1 ~ SERVO_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t servoIsAttached( servoMap_t servoNumber);
+
+/*
+ * @brief: read the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @return: value of the servo (0 ~ 180).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint16_t servoRead( servoMap_t servoNumber);
+
+/*
+ * @brief: change the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return: True if the value was successfully changed, False if not.
+ */
+bool_t servoWrite( servoMap_t servoNumber, uint16_t angle );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_SERVO_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_sleep.h ./sapi/inc/sapi_sleep.h
--- a_qSC69Z/sapi/inc/sapi_sleep.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_sleep.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,72 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-08-15 */
+
+#ifndef SAPI_SCT_H_
+#define SAPI_SCT_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Sleep mode, sleep until next interrupt occur.
+ * @param  nothing
+ * @return nothing
+ */
+void sleepUntilNextInterrupt( void );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_SCT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_spi.h ./sapi/inc/sapi_spi.h
--- a_qSC69Z/sapi/inc/sapi_spi.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_spi.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,67 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-05-02 */
+
+#ifndef _SAPI_SPI_H_
+#define _SAPI_SPI_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[ISR external functions definition]======================*/
+
+/*==================[external functions definition]==========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_SPI_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_tick.h ./sapi/inc/sapi_tick.h
--- a_qSC69Z/sapi/inc/sapi_tick.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_tick.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,77 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_TICK_H_
+#define _SAPI_TICK_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[ISR external functions definition]======================*/
+
+/*==================[external functions definition]==========================*/
+
+bool_t tickConfig( tick_t tickRateMS, sAPI_FuncPtr_t tickHook );
+
+tick_t tickRead( void );
+
+void tickWrite( tick_t ticks );
+
+/*==================[ISR external functions declaration]======================*/
+
+/* SysTick Timer ISR Handler */
+void SysTick_Handler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_TICK_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_timer.h ./sapi/inc/sapi_timer.h
--- a_qSC69Z/sapi/inc/sapi_timer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_timer.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,128 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef SAPI_TIMER_H_
+#define SAPI_TIMER_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+typedef void (*voidFunctionPointer_t)(void);
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+/*
+ * @Brief   Initialize Timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   ticks:   Number of ticks required to finish the cycle.
+ * @param   voidFunctionPointer:   function to be executed at the end of the timer cycle
+ * @return   nothing
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_Init(uint8_t timerNumber , uint32_t ticks, voidFunctionPointer_t voidFunctionPointer);
+
+/*
+ * @Brief   Disables timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @return   nothing
+ */
+void Timer_DeInit(uint8_t timerNumber);
+
+/*
+ * @Brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   uS:   Value in microseconds
+ * @return   Equivalent in Ticks for the LPC4337
+ * @note   Can be used for the second parameter in the Timer_init
+ */
+uint32_t Timer_microsecondsToTicks(uint32_t uS);
+
+/*
+ * @Brief   Enables a compare match in a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @param   ticks:   Number of ticks required to reach the compare match.
+ * @param   voidFunctionPointer: function to be executed when the compare match is reached
+ * @return   None
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_EnableCompareMatch(uint8_t timerNumber, uint8_t compareMatchNumber , uint32_t ticks, voidFunctionPointer_t voidFunctionPointer);
+
+/*
+ * @brief   Disables a compare match of a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @return   None
+ */
+void Timer_DisableCompareMatch(uint8_t timerNumber, uint8_t compareMatchNumber);
+
+/*
+ * @Purpose:   Allows the user to change the compare value n? 'compareMatchNumber' of timer 'timerNumber'.
+ *    This is specially useful to generate square waves if used in the function for the TIMERCOMPAREMATCH0 (because
+ *    that compare match resets the timer counter), which will be passed as a parameter when initializing a timer
+ * @note:  The selected time (3rd parameter) must be less than TIMERCOMPAREMATCH0's compareMatchTime_uS
+ *   for the compare match to make the interruption
+ */
+void Timer_SetCompareMatch(uint8_t timerNumber, uint8_t compareMatchNumber,uint32_t ticks);
+
+/*==================[ISR external functions declaration]=====================*/
+/*
+ * @Brief:   Executes the functions passed by parameter in the Timer_init,
+ *   at the chosen frequencies
+ */
+void TIMER0_IRQHandler(void);
+void TIMER1_IRQHandler(void);
+void TIMER2_IRQHandler(void);
+void TIMER3_IRQHandler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_TIMER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/inc/sapi_uart.h ./sapi/inc/sapi_uart.h
--- a_qSC69Z/sapi/inc/sapi_uart.h	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/inc/sapi_uart.h	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,104 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-26 */
+
+#ifndef _SAPI_UART_H_
+#define _SAPI_UART_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_delay.h"
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   UART_RECEIVE_STRING_CONFIG,
+   UART_RECEIVE_STRING_RECEIVING,
+   UART_RECEIVE_STRING_RECEIVED_OK,
+   UART_RECEIVE_STRING_TIMEOUT
+} waitForReceiveStringOrTimeoutState_t;
+
+typedef struct{
+   waitForReceiveStringOrTimeoutState_t state;
+   char*    string;
+   uint16_t stringSize;
+   uint16_t stringIndex;
+   tick_t   timeout;
+   delay_t  delay;
+} waitForReceiveStringOrTimeout_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+waitForReceiveStringOrTimeoutState_t waitForReceiveStringOrTimeout(
+   uartMap_t uart, waitForReceiveStringOrTimeout_t* instance );
+
+bool_t waitForReceiveStringOrTimeoutBlocking(
+   uartMap_t uart, char* string, uint16_t stringSize, tick_t timeout );
+
+void uartConfig( uartMap_t uart, uint32_t baudRate );
+
+bool_t uartReadByte( uartMap_t uart, uint8_t* receivedByte );
+void uartWriteByte( uartMap_t uart, uint8_t byte );
+
+void uartWriteString( uartMap_t uart, char* str );
+
+/*==================[ISR external functions declaration]======================*/
+
+/* 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24) */
+void UART0_IRQHandler(void);
+/* 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26) */
+void UART2_IRQHandler(void);
+/* 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27) */
+void UART3_IRQHandler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* _SAPI_UART_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/LICENSE ./sapi/LICENSE
--- a_qSC69Z/sapi/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/LICENSE	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,27 @@
+Copyright (c) 2016, Eric Pernia
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of sAPI nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/README.md ./sapi/README.md
--- a_qSC69Z/sapi/README.md	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/README.md	2018-01-19 23:55:11.012319231 -0300
@@ -0,0 +1,54 @@
+# sAPI library for microcontrollers
+
+This library implements a simple API that acts as a HAL (Hardware Abstraction
+Layer) for microcontrollers.
+
+It takes ideas from *Wiring library*, but use the concept of *peripheral* instead
+the concept of *pin*, making the API regardless of the number of pins that use
+certain peripheral.
+
+## Documentation
+
+**NOTE:** Always use the [released versions](../../releases) because these are tested all examples and the API documentation is consistent. The master branch may contain inconsistencies because this library is currently under development.
+
+### Included modules
+
+**Internal Peripherals**
+
+- Data types.
+- Peripheral Map.
+- ISR Vector.
+- Board.
+- Tick.
+- GPIO.
+- UART.
+- ADC.
+- DAC.
+- I2C.
+- RTC.
+- Sleep.
+- PWM.
+
+**Delays**
+
+- Delay.
+
+**External Peripherals**
+
+- 7-segment display.
+- Keypad.
+- Angular Servo (0 to 180Â°).
+- Magnetometer (compass) sensor HMC5883L.
+
+Every module includes an example.
+
+### Software layers
+
+![ "sapi-modulos-capas.png" image not found](docs/assets/img/sapi-modulos-capas.png "Modules an layers of sAPI library")
+
+### Boards
+
+Now available for boards:
+
+- EDU-CIAA-NXP (NXP LPC4337 microcontroller). [Download documentation.](docs/assets/pdf/EDU-CIAA-NXP_sAPI_bm_A4_v1r0_ES.pdf)
+- CIAA-NXP (NXP LPC4337 microcontroller).
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_7_segment_display.c ./sapi/src/sapi_7_segment_display.c
--- a_qSC69Z/sapi/src/sapi_7_segment_display.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_7_segment_display.c	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,200 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Date: 2016-07-28
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_7_segment_display.h"   /* <= own header */
+
+#include "sapi_delay.h"               /* <= delay header */
+#include "sapi_gpio.h"                /* <= GPIO header */
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+
+// Symbols formed by segmens
+/*
+------------+------+---------
+  Segmentos | HEX  | Simbolo
+------------+------+---------
+   hgfedcba |      |
+ 0b00111111 | 0x0F |   0
+ 0b00000110 | 0x00 |   1
+ 0b01011011 | 0x00 |   2
+ 0b01001111 | 0x00 |   3
+ 0b01100110 | 0x00 |   4
+ 0b01101101 | 0x00 |   5
+ 0b01111101 | 0x00 |   6
+ 0b00000111 | 0x00 |   7
+ 0b01111111 | 0x00 |   8
+ 0b01101111 | 0x00 |   9
+
+ 0b01011111 | 0x00 |   a
+ 0b01111100 | 0x00 |   b
+ 0b01011000 | 0x00 |   c
+ 0b01011110 | 0x00 |   d
+ 0b01111011 | 0x00 |   e
+ 0b01110001 | 0x00 |   F
+
+ 0b01110111 | 0x00 |   A
+ 0b00111001 | 0x00 |   C
+ 0b01111001 | 0x00 |   E
+ 0b01110110 | 0x00 |   H
+ 0b00011110 | 0x00 |   J
+ 0b00111000 | 0x00 |   L
+ 0b01110011 | 0x00 |   P
+ 0b00111110 | 0x00 |   U
+
+ 0b10000000 | 0x00 |   .
+
+             a
+           -----
+       f /     / b
+        /  g  /
+        -----
+    e /     / c
+     /  d  /
+     -----    O h = dp
+
+*/
+uint8_t display7SegmentOutputs[26] = {
+   0b00111111, // 0
+   0b00000110, // 1
+   0b01011011, // 2
+   0b01001111, // 3
+   0b01100110, // 4
+   0b01101101, // 5
+   0b01111101, // 6
+   0b00000111, // 7
+   0b01111111, // 8
+   0b01101111, // 9
+
+   0b01011111, // a
+   0b01111100, // b
+   0b01011000, // c
+   0b01011110, // d
+   0b01111011, // e
+   0b01110001, // f
+
+   0b01110111, // A
+   0b00111001, // C
+   0b01111001, // E
+   0b01110110, // H
+   0b00011110, // J
+   0b00111000, // L
+   0b01110011, // P
+   0b00111110, // U
+
+   0b10000000, // .
+
+   0b00000000  // display off
+};
+
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* Test 7-segment display connected pins */
+/*
+----------------+------------+-----------+------------
+ Segment ON     | BIN Value  | HEX Value | Output pin
+----------------+------------+-----------+------------
+ Segment 'a' ON | 0b00000001 |   0x20    | ..... (to be complete)
+ Segment 'b' ON | 0b00000010 |   0x80    | .....
+ Segment 'c' ON | 0b00000100 |   0x40    | .....
+ Segment 'd' ON | 0b00001000 |   0x02    | .....
+ Segment 'e' ON | 0b00010000 |   0x04    | .....
+ Segment 'f' ON | 0b00100000 |   0x10    | .....
+ Segment 'g' ON | 0b01000000 |   0x08    | .....
+ Segment 'h' ON | 0b10000000 |   0x80    | .....
+----------------+------------+-----------+------------
+
+                a
+              -----
+	  f /     / b
+	   /  g  /
+	   -----
+       e /     / c
+	/  d  /
+	-----    O h = dp (decimal pint).
+
+*/
+void display7SegmentTestPins( gpioMap_t* display7SegmentPins, gpioMap_t pin ){
+
+   uint8_t i = 0;
+
+   for(i=0;i<=7;i++){
+      gpioWrite( display7SegmentPins[i], ON  );
+      if( i == 0 )
+         gpioWrite( pin, ON );
+      delay(1000);
+      gpioWrite( display7SegmentPins[i], OFF );
+      if( i == 0 )
+         gpioWrite( pin, OFF );
+   }
+
+}
+
+
+/* Configure 7-segment display GPIOs as Outputs */
+void display7SegmentPinConfig( gpioMap_t* display7SegmentPins ){
+
+   uint8_t i = 0;
+
+   for( i=0; i<=7; i++ )
+      gpioConfig( display7SegmentPins[i], GPIO_OUTPUT );
+}
+
+
+/* Write a symbol on 7-segment display */
+void display7SegmentWrite( gpioMap_t* display7SegmentPins, uint8_t symbolIndex ){
+
+   uint8_t i = 0;
+
+   for( i=0; i<=7; i++ )
+      gpioWrite( display7SegmentPins[i], display7SegmentOutputs[symbolIndex] & (1<<i) );
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_adc.c ./sapi/src/sapi_adc.c
--- a_qSC69Z/sapi/src/sapi_adc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_adc.c	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,132 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_adc.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @brief:  enable/disable the ADC and DAC peripheral
+ * @param:  ADC_ENABLE, ADC_DISABLE
+ * @return: none
+*/
+void adcConfig( adcConfig_t config ){
+
+   switch(config){
+
+      case ADC_ENABLE: {
+
+         /* Config ADC0 sample mode */
+         /*
+         ADC_CLOCK_SETUP_T ADCSetup = {
+            400000,   // ADC rate
+            10,       // ADC bit accuracy
+            0         // ADC Burt Mode (true or false)
+         };
+         */
+         ADC_CLOCK_SETUP_T ADCSetup;
+
+         /* Initialized to default values:
+		   *   - Sample rate:ADC_MAX_SAMPLE_RATE=400KHz
+		   *   - resolution: ADC_10BITS
+		   *   - burst mode: DISABLE */
+         Chip_ADC_Init( LPC_ADC0, &ADCSetup );
+         /* Disable burst mode */
+         Chip_ADC_SetBurstCmd( LPC_ADC0, DISABLE );
+         /* Set sample rate to 200KHz */
+         Chip_ADC_SetSampleRate( LPC_ADC0, &ADCSetup, ADC_MAX_SAMPLE_RATE/2 );
+         /* Disable all channels */
+         Chip_ADC_EnableChannel( LPC_ADC0,ADC_CH1, DISABLE );
+         Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH1, DISABLE );
+
+         Chip_ADC_EnableChannel( LPC_ADC0, ADC_CH2, DISABLE );
+         Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH2, DISABLE );
+
+         Chip_ADC_EnableChannel( LPC_ADC0, ADC_CH3, DISABLE );
+         Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH3, DISABLE );
+
+         Chip_ADC_EnableChannel( LPC_ADC0, ADC_CH4, DISABLE );
+         Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH4, DISABLE );
+      }
+      break;
+
+      case ADC_DISABLE:
+         /* Disable ADC peripheral */
+         Chip_ADC_DeInit( LPC_ADC0 );
+      break;
+   }
+
+}
+
+
+/*
+ * @brief   Get the value of one ADC channel. Mode: BLOCKING
+ * @param   AI0 ... AIn
+ * @return  analog value
+ */
+uint16_t adcRead( adcMap_t analogInput ){
+
+   uint8_t lpcAdcChannel = 66 - analogInput;
+   uint16_t analogValue = 0;
+
+   Chip_ADC_EnableChannel(LPC_ADC0, lpcAdcChannel, ENABLE);
+   Chip_ADC_SetStartMode(LPC_ADC0, ADC_START_NOW, ADC_TRIGGERMODE_RISING);
+
+   while(
+      (Chip_ADC_ReadStatus(LPC_ADC0, lpcAdcChannel, ADC_DR_DONE_STAT) != SET)
+   );
+   Chip_ADC_ReadValue( LPC_ADC0, lpcAdcChannel, &analogValue );
+
+   Chip_ADC_EnableChannel( LPC_ADC0, lpcAdcChannel, DISABLE );
+
+   return analogValue;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_board.c ./sapi/src/sapi_board.c
--- a_qSC69Z/sapi/src/sapi_board.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_board.c	2018-01-19 23:55:11.016319302 -0300
@@ -0,0 +1,64 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_board.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* Set up and initialize board hardware */
+void boardConfig(void) {
+
+   /* Read clock settings and update SystemCoreClock variable */
+   SystemCoreClockUpdate();
+
+   Board_Init(); // From Board module (modules/lpc4337_m4/board)
+
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_dac.c ./sapi/src/sapi_dac.c
--- a_qSC69Z/sapi/src/sapi_dac.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_dac.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,100 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_dac.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @brief:  enable/disable the ADC and DAC peripheral
+ * @param:  DAC_ENABLE, DAC_DISABLE
+ * @return: none
+*/
+void dacConfig( dacConfig_t config ){
+
+   switch(config){
+
+      case DAC_ENABLE:
+         /* Initialize the DAC peripheral */
+         Chip_DAC_Init(LPC_DAC);
+
+         /* Enables the DMA operation and controls DMA timer */
+         Chip_DAC_ConfigDAConverterControl(LPC_DAC, DAC_DMA_ENA);
+                                                 /* DCAR DMA access */
+         /* Update value to DAC buffer*/
+         Chip_DAC_UpdateValue(LPC_DAC, 0);
+      break;
+
+      case DAC_DISABLE:
+         /* Disable DAC peripheral */
+         Chip_DAC_DeInit( LPC_DAC );
+      break;
+   }
+
+}
+
+
+/*
+ * @brief   Write a value in the DAC.
+ * @param   analogOutput: AO0 ... AOn
+ * @param   value: analog value to be writen in the DAC, from 0 to 1023
+ * @return  none
+ */
+void dacWrite( dacMap_t analogOutput, uint16_t value ){
+
+   if( analogOutput == AO ){
+      if( value > 1023 ){
+         value = 1023;
+      }
+      Chip_DAC_UpdateValue( LPC_DAC, value );
+   }
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_datatypes.c ./sapi/src/sapi_datatypes.c
--- a_qSC69Z/sapi/src/sapi_datatypes.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_datatypes.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,90 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+ 
+/* Date: 2016-06-05 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* 
+ * Null Function Pointer definition
+ * --------------------------------------
+ * param:  void * - Not used
+ * return: bool_t - Return always true
+ */
+bool_t sAPI_NullFuncPtr(void *ptr){
+   return 1;
+}
+
+/*==================[ISR external functions definition]======================*/
+
+/*
+// FUNCTION POINTER VECTOR EXAMPLE
+
+// FunciÃ³n para no tener NULL pointer
+   void dummy(void){
+   }
+ 
+// DefiniciÃ³n de un tipo con typedef.
+   typedef void (*voidFunctionPointer_t)(void);
+ 
+// DefiniciÃ³n de una variable con el tipo de typedef, incializo en dummy (NULL)
+   voidFunctionPointer_t voidFunctionPointer[2] = {dummy, dummy};
+
+// Ejecuto la funcion
+   (* voidFunctionPointer[0] )();
+   (* voidFunctionPointer[1] )();
+      
+// Asigno una funcion a cada posiciÃ³n del vector
+   voidFunctionPointer[0] = ledB;
+   voidFunctionPointer[1] = led1;
+*/      
+
+
+/** @} doxygen end group definition */
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_delay.c ./sapi/src/sapi_delay.c
--- a_qSC69Z/sapi/src/sapi_delay.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_delay.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,116 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_delay.h"
+#include "sapi_tick.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+extern volatile tick_t tickRateMS;
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* ---- Inaccurate Blocking Delay ---- */
+
+void delayInaccurate(tick_t delay_ms) {
+   volatile tick_t i;
+   volatile tick_t delay;
+
+   delay = INACCURATE_TO_MS * delay_ms;
+
+   for( i=delay; i>0; i-- );
+}
+
+void delayInaccurateUs(tick_t delay_us) {
+   volatile tick_t i;
+   volatile tick_t delay;
+
+   delay = (INACCURATE_TO_US_x10 * delay_us) / 10;
+
+   for( i=delay; i>0; i-- );
+}
+
+/* ---- Blocking Delay ---- */
+
+// delay( 1, DELAY_US );
+
+void delay (tick_t time){
+    tick_t curTicks = tickRead();
+    while ( (tickRead() - curTicks) < time/tickRateMS );
+ }
+
+
+/* ---- Non Blocking Delay ---- */
+
+void delayConfig( delay_t * delay, tick_t duration ){
+   delay->duration = duration/tickRateMS;
+   delay->running = 0;
+}
+
+bool_t delayRead( delay_t * delay ){
+
+   bool_t timeArrived = 0;
+
+   if( !delay->running ){
+      delay->startTime = tickRead();
+      delay->running = 1;
+   }
+   else{
+      if ( (tickRead() - delay->startTime) >= delay->duration ){
+         timeArrived = 1;
+         delay->running = 0;
+      }
+   }
+
+   return timeArrived;
+}
+
+void delayWrite( delay_t * delay, tick_t duration ){
+   delay->duration = duration/tickRateMS;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_gpio.c ./sapi/src/sapi_gpio.c
--- a_qSC69Z/sapi/src/sapi_gpio.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_gpio.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,331 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_gpio.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+const pinConfigGpioLpc4337_t gpioPinsConfig[] = {
+
+	/*{ {PinNamePortN ,PinNamePinN}, PinFUNC, {GpioPortN, GpioPinN} }*/
+
+   /* --------------------------------------------------------------- */
+	/*                           EDU-CIAA-NXP                          */
+   /* --------------------------------------------------------------- */
+   /*                             Snap  sAPI   Connector  Serigraphy  */
+   /* --------------------------------------------------------------- */
+
+   // { {1,15}, FUNC0, {0, 2} },   /*  0   DIO0    CON2_09   ENET_RXD0   */
+
+   // { {1, 4}, FUNC0, {0,11} },   /*  1   DIO1    CON2_21   SPI_MOSI    */
+   // { {4, 9}, FUNC4, {5,13} },   /*  2   DIO2    CON2_23   LCD_EN      */
+
+   // { {6, 1}, FUNC0, {3, 0} },   /*  3   DIO3    CON2_29   GPIO0       */
+   // { {6, 5}, FUNC0, {3, 4} },   /*  4   DIO4    CON2_31   GPIO2       */
+   // { {6, 8}, FUNC4, {5,16} },   /*  5   DIO5    CON2_33   GPIO4       */
+   // { {6,10}, FUNC0, {3, 6} },   /*  6   DIO6    CON2_35   GPIO6       */
+
+   // { {0, 0}, FUNC0, {0, 0} },   /*  7   DIO7    CON2_04   ENET_RXD1   */
+   // { {0, 1}, FUNC0, {0, 1} },   /*  8   DIO8    CON2_06   ENET_TXEN   */
+   // { {7, 7}, FUNC0, {3,15} },   /*  9   DIO9    CON2_08   ENET_MDC    */
+   // { {1,16}, FUNC0, {0, 3} },   /* 10   DIO10   CON2_10   ENET_CRS_DV */
+   // { {1,17}, FUNC0, {0,12} },   /* 11   DIO11   CON2_12   ENET_MDIO   */
+   // { {1,18}, FUNC0, {0,13} },   /* 12   DIO12   CON2_14   ENET_TXD0   */
+   // { {1,20}, FUNC0, {0,15} },   /* 13   DIO13   CON2_16   ENET_TXD1   */
+   // { {1, 3}, FUNC0, {0,10} },   /* 14   DIO14   CON2_18   SPI_MISO    */
+
+   // { {4,10}, FUNC4, {5,14} },   /* 15   DIO15   CON2_22   LCD4        */
+   // { {4, 8}, FUNC4, {5,12} },   /* 16   DIO16   CON2_24   LCDRS       */
+   // { {4, 6}, FUNC0, {2, 6} },   /* 17   DIO17   CON2_26   LCD3        */
+   // { {4, 5}, FUNC0, {2, 5} },   /* 18   DIO18   CON2_28   LCD2        */
+   // { {4, 4}, FUNC0, {2, 4} },   /* 19   DIO19   CON2_30   LCD1        */
+
+   // { {6, 4}, FUNC0, {3, 3} },   /* 20   DIO20   CON2_32   GPIO1       */
+   // { {6, 7}, FUNC4, {5,15} },   /* 21   DIO21   CON2_34   GPIO3       */
+   // { {6, 9}, FUNC0, {3, 5} },   /* 22   DIO22   CON2_36   GPIO5       */
+   // { {6,11}, FUNC0, {3, 7} },   /* 23   DIO23   CON2_38   GPIO7       */
+   // { {6,12}, FUNC0, {2, 8} },   /* 24   DIO24   CON2_40   GPIO8       */
+
+   // { {2, 4}, FUNC4, {5, 4} },   /* 25   DIO25   CON1_23   RS232_RXD   */
+   // { {2, 3}, FUNC4, {5, 3} },   /* 26   DIO26   CON1_25   RS232_TXD   */
+   // { {3, 1}, FUNC4, {5, 8} },   /* 27   DIO27   CON1_27   CAN_RD      */
+   // { {3, 2}, FUNC4, {5, 9} },   /* 28   DIO28   CON1_29   CAN_TD      */
+   // { {7, 4}, FUNC0, {3,12} },   /* 29   DIO29   CON1_31   T_COL1      */
+   // { {4, 0}, FUNC0, {2, 0} },   /* 30   DIO30   CON1_33   T_FIL0      */
+   // { {4, 3}, FUNC0, {2, 3} },   /* 31   DIO31   CON1_35   T_FIL3      */
+   // { {4, 2}, FUNC0, {2, 2} },   /* 32   DIO32   CON1_37   T_FIL2      */
+   // { {1, 5}, FUNC0, {1, 8} },   /* 33   DIO33   CON1_39   T_COL0      */
+
+   // { {7, 5}, FUNC0, {3,13} },   /* 34   DIO34   CON1_34   T_COL2      */
+   // { {4, 1}, FUNC0, {2, 1} },   /* 35   DIO35   CON1_36   T_FIL1      */
+
+
+   { {4, 1}, FUNC0, {2, 1} },   /*   0   CON1_36   T_FIL1           */
+   { {7, 5}, FUNC0, {3,13} },   /*   1   CON1_34   T_COL2           */
+
+   { {1, 5}, FUNC0, {1, 8} },   /*   2   CON1_39   T_COL0           */
+   { {4, 2}, FUNC0, {2, 2} },   /*   3   CON1_37   T_FIL2           */
+   { {4, 3}, FUNC0, {2, 3} },   /*   4   CON1_35   T_FIL3           */
+   { {4, 0}, FUNC0, {2, 0} },   /*   5   CON1_33   T_FIL0           */
+   { {7, 4}, FUNC0, {3,12} },   /*   6   CON1_31   T_COL1           */
+
+   { {3, 2}, FUNC4, {5, 9} },   /*   7   CON1_29   CAN_TD           */
+   { {3, 1}, FUNC4, {5, 8} },   /*   8   CON1_27   CAN_RD           */
+
+   { {2, 3}, FUNC4, {5, 3} },   /*   9   CON1_25   RS232_TXD        */
+   { {2, 4}, FUNC4, {5, 4} },   /*  10   CON1_23   RS232_RXD        */
+
+   { {6,12}, FUNC0, {2, 8} },   /*  11   CON2_40   GPIO8            */
+   { {6,11}, FUNC0, {3, 7} },   /*  12   CON2_38   GPIO7            */
+   { {6, 9}, FUNC0, {3, 5} },   /*  13   CON2_36   GPIO5            */
+   { {6, 7}, FUNC4, {5,15} },   /*  14   CON2_34   GPIO3            */
+   { {6, 4}, FUNC0, {3, 3} },   /*  15   CON2_32   GPIO1            */
+
+   { {4, 4}, FUNC0, {2, 4} },   /*  16   CON2_30   LCD1             */
+   { {4, 5}, FUNC0, {2, 5} },   /*  17   CON2_28   LCD2             */
+   { {4, 6}, FUNC0, {2, 6} },   /*  18   CON2_26   LCD3             */
+   { {4, 8}, FUNC4, {5,12} },   /*  19   CON2_24   LCDRS            */
+   { {4,10}, FUNC4, {5,14} },   /*  20   CON2_22   LCD4             */
+
+   { {1, 3}, FUNC0, {0,10} },   /*  21   CON2_18   SPI_MISO         */
+
+   { {1,20}, FUNC0, {0,15} },   /*  22   CON2_16   ENET_TXD1        */
+   { {1,18}, FUNC0, {0,13} },   /*  23   CON2_14   ENET_TXD0        */
+   { {1,17}, FUNC0, {0,12} },   /*  24   CON2_12   ENET_MDIO        */
+   { {1,16}, FUNC0, {0, 3} },   /*  25   CON2_10   ENET_CRS_DV      */
+   { {7, 7}, FUNC0, {3,15} },   /*  26   CON2_08   ENET_MDC         */
+   { {0, 1}, FUNC0, {0, 1} },   /*  27   CON2_06   ENET_TXEN        */
+   { {0, 0}, FUNC0, {0, 0} },   /*  28   CON2_04   ENET_RXD1        */
+
+   { {6,10}, FUNC0, {3, 6} },   /*  29   CON2_35   GPIO6            */
+   { {6, 8}, FUNC4, {5,16} },   /*  30   CON2_33   GPIO4            */
+   { {6, 5}, FUNC0, {3, 4} },   /*  31   CON2_31   GPIO2            */
+   { {6, 1}, FUNC0, {3, 0} },   /*  32   CON2_29   GPIO0            */
+
+   { {4, 9}, FUNC4, {5,13} },   /*  33   CON2_23   LCDEN            */
+
+   { {1, 4}, FUNC0, {0,11} },   /*  34   CON2_21   SPI_MOSI         */
+
+   { {1,15}, FUNC0, {0, 2} },   /*  35   CON2_09   ENET_RXD0        */
+
+
+   { {1, 0}, FUNC0, {0, 4} },   /* 36   TEC1    TEC_1                 */
+   { {1, 1}, FUNC0, {0, 8} },   /* 37   TEC2    TEC_2                 */
+   { {1, 2}, FUNC0, {0, 9} },   /* 38   TEC3    TEC_3                 */
+   { {1, 6}, FUNC0, {1, 9} },   /* 39   TEC4    TEC_4                 */
+
+   { {2,10}, FUNC0, {0,14} },   /* 40   LED1    LED1                  */
+   { {2,11}, FUNC0, {1,11} },   /* 41   LED2    LED2                  */
+   { {2,12}, FUNC0, {1,12} },   /* 42   LED3    LED3                  */
+   { {2, 0}, FUNC4, {5, 0} },   /* 43   LEDR    LED0_R                */
+   { {2, 1}, FUNC4, {5, 1} },   /* 44   LEDG    LED0_G                */
+   { {2, 2}, FUNC4, {5, 2} },   /* 45   LEDB    LED0_B                */
+
+
+   /* --------------------------------------------------------------- */
+	/*                             CIAA-NXP                            */
+   /* --------------------------------------------------------------- */
+   /*                             Snap  sAPI   Connector  Serigraphy  */
+   /* --------------------------------------------------------------- */
+
+   { {4, 0}, FUNC0, {2, 0} },   /* 46   DI0     BORN_24   DIN0        */
+   { {4, 1}, FUNC0, {2, 1} },   /* 47   DI1     BORN_25   DIN1        */
+   { {4, 2}, FUNC0, {2, 2} },   /* 48   DI2     BORN_26   DIN2        */
+   { {4, 3}, FUNC0, {2, 3} },   /* 49   DI3     BORN_27   DIN3        */
+   { {7, 3}, FUNC0, {3,11} },   /* 50   DI4     BORN_28   DIN4        */
+   { {7, 4}, FUNC0, {3,12} },   /* 51   DI5     BORN_29   DIN5        */
+   { {7, 5}, FUNC0, {3,13} },   /* 52   DI6     BORN_30   DIN6        */
+   { {7, 6}, FUNC0, {3,14} },   /* 53   DI7     BORN_31   DIN7        */
+
+   { {2, 1}, FUNC4, {5, 1} },   /* 54   DO0     BORN_14   DOUT0       */
+   { {4, 6}, FUNC0, {2, 6} },   /* 55   DO1     BORN_06   DOUT1       */
+   { {4, 5}, FUNC0, {2, 5} },   /* 56   DO2     BORN_08   DOUT2       */
+   { {4, 4}, FUNC0, {2, 4} },   /* 57   DO3     BORN_10   DOUT3       */
+   { {4, 8}, FUNC4, {5,12} },   /* 58   DO4     BORN_14   DOUT4       */
+   { {4, 9}, FUNC4, {5,13} },   /* 59   DO5     BORN_15   DOUT5       */
+   { {4,10}, FUNC4, {5,14} },   /* 60   DO6     BORN_16   DOUT6       */
+   { {1, 5}, FUNC0, {1, 8} }    /* 61   DO7     BORN_17   DOUT7       */
+};
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+static void gpioObtainPinConfig( gpioMap_t pin,
+                                int8_t *pinNamePort, int8_t *pinNamePin,
+																int8_t *func, int8_t *gpioPort,
+																int8_t *gpioPin ){
+
+   *pinNamePort = gpioPinsConfig[pin].pinName.port;
+   *pinNamePin  = gpioPinsConfig[pin].pinName.pin;
+   *func        = gpioPinsConfig[pin].func;
+   *gpioPort    = gpioPinsConfig[pin].gpio.port;
+   *gpioPin     = gpioPinsConfig[pin].gpio.pin;
+}
+
+/*==================[external functions definition]==========================*/
+
+bool_t gpioConfig( gpioMap_t pin, gpioConfig_t config ){
+
+   bool_t ret_val     = 1;
+
+   int8_t pinNamePort = 0;
+   int8_t pinNamePin  = 0;
+
+   int8_t func        = 0;
+
+   int8_t gpioPort    = 0;
+   int8_t gpioPin     = 0;
+
+   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
+                           &gpioPort, &gpioPin );
+
+   switch(config){
+
+      case GPIO_ENABLE:
+		   /* Initializes GPIO */
+		   Chip_GPIO_Init(LPC_GPIO_PORT);
+	   break;
+
+      case GPIO_INPUT:
+         Chip_SCU_PinMux(
+            pinNamePort,
+            pinNamePin,
+            SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+            func
+         );
+         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+
+      case GPIO_INPUT_PULLUP:
+         Chip_SCU_PinMux(
+            pinNamePort,
+            pinNamePin,
+            SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+            func
+         );
+         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+
+      case GPIO_INPUT_PULLDOWN:
+         Chip_SCU_PinMux(
+            pinNamePort,
+            pinNamePin,
+            SCU_MODE_PULLDOWN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+            func
+         );
+         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+      case GPIO_INPUT_PULLUP_PULLDOWN:
+         Chip_SCU_PinMux(
+            pinNamePort,
+            pinNamePin,
+            SCU_MODE_REPEATER | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+            func
+         );
+         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+
+      case GPIO_OUTPUT:
+         Chip_SCU_PinMux(
+            pinNamePort,
+            pinNamePin,
+            SCU_MODE_INACT | SCU_MODE_ZIF_DIS,
+            func
+         );
+         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_OUTPUT );
+         Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, 0);
+      break;
+
+      default:
+         ret_val = 0;
+      break;
+   }
+
+   return ret_val;
+
+}
+
+
+bool_t gpioWrite( gpioMap_t pin, bool_t value ){
+
+   bool_t ret_val     = 1;
+
+   int8_t pinNamePort = 0;
+   int8_t pinNamePin  = 0;
+
+   int8_t func        = 0;
+
+   int8_t gpioPort    = 0;
+   int8_t gpioPin     = 0;
+
+   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
+                           &gpioPort, &gpioPin );
+
+   Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, value);
+
+   return ret_val;
+}
+
+
+bool_t gpioRead( gpioMap_t pin ){
+
+   bool_t ret_val     = OFF;
+
+   int8_t pinNamePort = 0;
+   int8_t pinNamePin  = 0;
+
+   int8_t func        = 0;
+
+   int8_t gpioPort    = 0;
+   int8_t gpioPin     = 0;
+
+   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
+                           &gpioPort, &gpioPin );
+
+   ret_val = (bool_t) Chip_GPIO_ReadPortBit( LPC_GPIO_PORT, gpioPort, gpioPin );
+
+   return ret_val;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_hmc5883l.c ./sapi/src/sapi_hmc5883l.c
--- a_qSC69Z/sapi/src/sapi_hmc5883l.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_hmc5883l.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,154 @@
+/* Copyright 2016, Alejandro Permingeat
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-06-27 */
+
+#include "sapi_hmc5883l.h"         /* <= sAPI HMC5883L header */
+#include "sapi_i2c.h"         	   /* <= sAPI I2C header */
+
+bool_t hmc5883lIsAlive( void ){
+
+   uint8_t idRegister[3];
+
+   // i2cRead( I2C0, HMC5883L_ADD, HMC5883L_REG_ID_REG_A, &idRegister, 3 );
+
+   if( (HMC5883L_VALUE_ID_REG_A == idRegister[0]) &&
+       (HMC5883L_VALUE_ID_REG_B == idRegister[1]) &&
+       (HMC5883L_VALUE_ID_REG_C == idRegister[2])
+     ){
+      return (TRUE);
+   }
+   else{
+      return (FALSE);
+   }
+}
+
+bool_t hmc5883lPrepareDefaultConfig( HMC5883L_config_t * config ){
+
+   config->gain = HMC5883L_DEFAULT_gain;
+   config->meassurement = HMC5883L_DEFAULT_messurement;
+   config->rate = HMC5883L_DEFAULT_rate;
+   config->samples = HMC5883L_DEFAULT_sample;
+   config->mode = HMC5883L_DEFAULT_mode;
+
+   return (TRUE);
+}
+
+
+bool_t hmc5883lConfig( HMC5883L_config_t config ){
+
+   uint8_t registerA, registerB, registerMode;
+
+   uint8_t transmitDataBuffer[2];
+
+   registerA = config.samples;
+   registerA = registerA<<3;
+   registerA |= config.rate;
+   registerA = registerA<<2;
+   registerA |= config.meassurement;
+
+   registerB = config.gain;
+   registerB = registerB << 5;
+
+   registerMode = config.mode;
+
+   i2cConfig( I2C0, 100000 );
+
+   transmitDataBuffer[0] = HMC5883L_REG_CONFIG_A;
+   transmitDataBuffer[1] = registerA;
+   i2cWrite( I2C0, HMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   transmitDataBuffer[0] = HMC5883L_REG_CONFIG_B;
+   transmitDataBuffer[1] = registerB;
+   i2cWrite( I2C0, HMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   transmitDataBuffer[0] = HMC5883L_REG_MODE;
+   transmitDataBuffer[1] = registerMode;
+   i2cWrite( I2C0, HMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   return ( hmc5883lIsAlive() );
+}
+
+
+bool_t hmc5883lRead( int16_t * x, int16_t * y, int16_t * z ){
+
+   bool_t result = TRUE;
+
+   uint8_t x_MSB, x_LSB;
+   uint8_t y_MSB, y_LSB;
+   uint8_t z_MSB, z_LSB;
+
+   uint8_t dataToReadBuffer;
+
+   dataToReadBuffer = HMC5883L_REG_X_MSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &x_MSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_X_LSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &x_LSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Y_MSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &y_MSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Y_LSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &y_LSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Z_MSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &z_MSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Z_LSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &z_LSB, 1, TRUE );
+
+   *x = x_MSB;
+   *x = (*x << 8)|x_LSB;
+
+   *y = y_MSB;
+   *y = (*y << 8)|y_LSB;
+
+   *z = z_MSB;
+   *z = (*z << 8)|z_LSB;
+
+   return(result); /** TODO: return value must reflect the result of the operation */
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_i2c.c ./sapi/src/sapi_i2c.c
--- a_qSC69Z/sapi/src/sapi_i2c.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_i2c.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,770 @@
+/* Copyright 2016, Eric Pernia
+ * Copyright 2016, Alejandro Permingeat.
+ * Copyright 2016, Eric Pernia
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+ /*
+  * Date:
+  * 2016-05-02 Eric Pernia - Only define API
+  * 2016-06-23 Alejandro Permingeat - First functional version
+  * 2016-08-07 Eric Pernia - Improve names
+  * 2016-09-10 Eric Pernia - Add unlimited buffer transfer
+  * 2016-11-20 Eric Pernia - Software I2C
+  */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_i2c.h"
+#include "sapi_gpio.h"
+#include "sapi_delay.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+#if( I2C_SOFTWARE == 1 )
+
+   static bool_t i2cSoftwareConfig( i2cMap_t i2cNumber, uint32_t clockRateHz );
+
+   static bool_t i2cSoftwareRead( i2cMap_t  i2cNumber,
+                                  uint8_t  i2cSlaveAddress,
+                                  uint8_t* dataToReadBuffer,
+                                  uint16_t dataToReadBufferSize,
+                                  bool_t   sendWriteStop,
+                                  uint8_t* receiveDataBuffer,
+                                  uint16_t receiveDataBufferSize,
+                                  bool_t   sendReadStop );
+
+   static bool_t i2cSoftwareWrite( i2cMap_t  i2cNumber,
+                                   uint8_t  i2cSlaveAddress,
+                                   uint8_t* transmitDataBuffer,
+                                   uint16_t transmitDataBufferSize,
+                                   bool_t   sendWriteStop );
+
+   static void i2cSoftwarePinConfig( gpioMap_t pin, uint8_t mode );
+   static void i2cSoftwarePinWrite( gpioMap_t pin, bool_t value );
+   static bool_t i2cSoftwarePinRead( gpioMap_t pin );
+
+#else
+
+   static bool_t i2cHardwareConfig( i2cMap_t i2cNumber, uint32_t clockRateHz );
+
+   static bool_t i2cHardwareRead( i2cMap_t  i2cNumber,
+                                  uint8_t  i2cSlaveAddress,
+                                  uint8_t* dataToReadBuffer,
+                                  uint16_t dataToReadBufferSize,
+                                  bool_t   sendWriteStop,
+                                  uint8_t* receiveDataBuffer,
+                                  uint16_t receiveDataBufferSize,
+                                  bool_t   sendReadStop );
+
+   static bool_t i2cHardwareWrite( i2cMap_t  i2cNumber,
+                                   uint8_t  i2cSlaveAddress,
+                                   uint8_t* transmitDataBuffer,
+                                   uint16_t transmitDataBufferSize,
+                                   bool_t   sendWriteStop );
+
+#endif
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+#if( I2C_SOFTWARE == 1 )
+
+   static bool_t i2cSoftwareConfig( i2cMap_t i2cNumber, uint32_t clockRateHz ){
+
+      bool_t retVal = TRUE;
+
+      i2cSoftwarePinConfig( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT_PULLUP );
+      i2cSoftwarePinConfig( I2C_SOFTWARE_SCL_DIR, GPIO_INPUT_PULLUP );
+
+      return retVal;
+   }
+
+   static bool_t i2cSoftwareRead( i2cMap_t  i2cNumber,
+                                  uint8_t  i2cSlaveAddress,
+                                  uint8_t* dataToReadBuffer,
+                                  uint16_t dataToReadBufferSize,
+                                  bool_t   sendWriteStop,
+                                  uint8_t* receiveDataBuffer,
+                                  uint16_t receiveDataBufferSize,
+                                  bool_t   sendReadStop ){
+
+      bool_t retVal = TRUE;
+      uint16_t i = 0;
+
+      // Check Errors
+      if( (dataToReadBuffer == NULL)  || (dataToReadBufferSize < 0) ||
+          (receiveDataBuffer == NULL) || (receiveDataBufferSize <= 0) ){
+         return FALSE;
+      }
+
+      // First Write
+
+      if( dataToReadBufferSize > 0 ){
+         retVal &= i2cSoftwareWrite( i2cNumber,
+                                     i2cSlaveAddress,
+                                     dataToReadBuffer,
+                                     dataToReadBufferSize,
+                                     sendWriteStop );
+      }
+
+      // Then Read
+
+      // Start condition
+      i2cSoftwareMasterWriteStart();
+      // 7 bit address + Read = 1
+      i2cSoftwareMasterWriteAddress( i2cSlaveAddress, I2C_SOFTWARE_READ );
+      // Write all data buffer
+      for( i=0; i<receiveDataBufferSize; i++ ){
+         receiveDataBuffer[i] = i2cSoftwareMasterReadByte( TRUE ); // TRUE send ACK, FALSE not
+      }
+      // Send Stop condition
+      if( sendReadStop ){
+         i2cSoftwareMasterWriteStop();
+      }
+      return retVal;
+   }
+
+   static bool_t i2cSoftwareWrite( i2cMap_t  i2cNumber,
+                                   uint8_t  i2cSlaveAddress,
+                                   uint8_t* transmitDataBuffer,
+                                   uint16_t transmitDataBufferSize,
+                                   bool_t   sendWriteStop ){
+
+      bool_t retVal = TRUE;
+      uint16_t i = 0;
+
+      // Check Errors
+      if( (transmitDataBuffer == NULL) || (transmitDataBufferSize <= 0) ){
+         return FALSE;
+      }
+      // Start condition
+      i2cSoftwareMasterWriteStart();
+      // 7 bit address + Write = 0
+      i2cSoftwareMasterWriteAddress( i2cSlaveAddress, I2C_SOFTWARE_WRITE );
+      // Write all data buffer
+      for( i=0; i<transmitDataBufferSize; i++ ){
+         i2cSoftwareMasterWriteByte( transmitDataBuffer[i] );
+      }
+      // Send Stop condition
+      if(sendWriteStop){
+         i2cSoftwareMasterWriteStop();
+      }
+
+      return retVal;
+   }
+
+
+   // Point of contact with sapi_gpio module
+
+   static void i2cSoftwarePinConfig( uint8_t pin, uint8_t mode ){
+
+      if( pin == I2C_SOFTWARE_SDA_DIR ){
+         if( mode == GPIO_OUTPUT ){
+            //IO_DIR_PORT_PIN( OCM_DATA_PORT, OCM_DATA_PIN, IO_OUT );
+            gpioConfig( I2C_SOFTWARE_SDA_DIR, GPIO_OUTPUT );
+         }else if( mode == GPIO_INPUT_PULLUP ){
+            // Seteo de pines como ENTRADA
+            //IO_DIR_PORT_PIN( OCM_DATA_PORT, OCM_DATA_PIN, IO_IN );
+            // Seteo de pines con pull-up
+            //IO_PUD_PORT( OCM_DATA_PORT, IO_PUP );
+            gpioConfig( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT );
+         }
+      }else if( pin == I2C_SOFTWARE_SCL_DIR ){
+         if( mode == GPIO_OUTPUT ){
+            //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_OUT );
+            gpioConfig( I2C_SOFTWARE_SCL_DIR, GPIO_OUTPUT );
+         }else if( mode == GPIO_INPUT_PULLUP ){
+            // Seteo de pines como ENTRADA
+            //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_IN );
+            // Seteo de pines con pull-up
+            //IO_PUD_PORT( OCM_CLK_PORT, IO_PUP );
+            gpioConfig( I2C_SOFTWARE_SCL_DIR, GPIO_INPUT );
+         }
+      }
+
+   }
+   static void i2cSoftwarePinWrite( uint8_t pin, bool_t value ){
+
+      if( pin == I2C_SOFTWARE_SDA_OUT ){
+         gpioWrite( I2C_SOFTWARE_SDA_OUT, value );
+      }else if( pin == I2C_SOFTWARE_SCL_OUT ){
+         if(value){
+            //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_IN );
+            gpioConfig( I2C_SOFTWARE_SCL_DIR, GPIO_INPUT );
+            while( !gpioRead( I2C_SOFTWARE_SCL_IN ) );   // Espera hasta que el clock este en alto
+            i2cSoftwareDelay(1); // 1 clock time delay
+         }else{
+            //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_OUT );
+            //OCM_SCL = 0;                //Setea el clock a LOW
+            gpioConfig( I2C_SOFTWARE_SCL_DIR, GPIO_OUTPUT );
+            gpioWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+         }
+         // 1 clock time delay
+         i2cSoftwareDelay(1);
+      }
+   }
+
+
+   static bool_t i2cSoftwarePinRead( uint8_t pin ){
+
+      bool_t retVal = 0;
+
+      retVal = gpioRead( (int8_t)pin );
+      return retVal;
+   }
+#else
+
+   static bool_t i2cHardwareConfig( i2cMap_t i2cNumber, uint32_t clockRateHz ){
+
+      // Configuracion de las lineas de SDA y SCL de la placa
+      Chip_SCU_I2C0PinConfig( I2C0_STANDARD_FAST_MODE );
+
+      // Inicializacion del periferico
+      Chip_I2C_Init( i2cNumber );
+      // Seleccion de velocidad del bus
+      Chip_I2C_SetClockRate( i2cNumber, clockRateHz );
+      // Configuracion para que los eventos se resuelvan por polliong
+      // (la otra opcion es por interrupcion)
+      Chip_I2C_SetMasterEventHandler( i2cNumber, Chip_I2C_EventHandlerPolling );
+
+      return TRUE;
+   }
+
+   static bool_t i2cHardwareRead( i2cMap_t  i2cNumber,
+                                  uint8_t  i2cSlaveAddress,
+                                  uint8_t* dataToReadBuffer,
+                                  uint16_t dataToReadBufferSize,
+                                  bool_t   sendWriteStop,
+                                  uint8_t* receiveDataBuffer,
+                                  uint16_t receiveDataBufferSize,
+                                  bool_t   sendReadStop ){
+
+   //TODO: ver i2cData.options si se puede poner la condicion opcional de stop
+
+      I2CM_XFER_T i2cData;
+
+      i2cData.slaveAddr = i2cSlaveAddress;
+      i2cData.options   = 0;
+      i2cData.status    = 0;
+      i2cData.txBuff    = dataToReadBuffer;
+      i2cData.txSz      = dataToReadBufferSize;
+      i2cData.rxBuff    = receiveDataBuffer;
+      i2cData.rxSz      = receiveDataBufferSize;
+
+      if( Chip_I2CM_XferBlocking( LPC_I2C0, &i2cData ) == 0 ) {
+         return FALSE;
+      }
+
+      return TRUE;
+   }
+
+   static bool_t i2cHardwareWrite( i2cMap_t  i2cNumber,
+                                   uint8_t  i2cSlaveAddress,
+                                   uint8_t* transmitDataBuffer,
+                                   uint16_t transmitDataBufferSize,
+                                   bool_t   sendWriteStop ){
+
+      //TODO: ver i2cData.options si se puede poner la condicion opcional de stop
+
+      I2CM_XFER_T i2cData;
+
+      if( i2cNumber != I2C0 ){
+         return FALSE;
+      }
+
+      // Prepare the i2cData register
+      i2cData.slaveAddr = i2cSlaveAddress;
+      i2cData.options   = 0;
+      i2cData.status    = 0;
+      i2cData.txBuff    = transmitDataBuffer;
+      i2cData.txSz      = transmitDataBufferSize;
+      i2cData.rxBuff    = 0;
+      i2cData.rxSz      = 0;
+
+      /* Send the i2c data */
+      if( Chip_I2CM_XferBlocking( LPC_I2C0, &i2cData ) == 0 ){
+         return FALSE;
+      }
+
+      /* *** TEST I2C Response ***
+
+      Chip_I2CM_XferBlocking( LPC_I2C0, &i2cData );
+
+      if( i2cData.status == I2CM_STATUS_OK){
+         while(1){
+            gpioWrite( LEDB, ON );
+            delay(100);
+            gpioWrite( LEDB, OFF );
+            delay(100);
+         }
+      }
+
+    *** END - TEST I2C Response *** */
+
+      return TRUE;
+   }
+
+#endif
+
+
+/*==================[external functions definition]==========================*/
+
+bool_t i2cConfig( i2cMap_t i2cNumber, uint32_t clockRateHz ){
+
+   bool_t retVal = FALSE;
+
+   if( i2cNumber != I2C0 ){
+      return FALSE;
+   }
+
+   #if( I2C_SOFTWARE == 1 )
+      retVal = i2cSoftwareConfig( i2cNumber, clockRateHz );
+   #else
+      retVal = i2cHardwareConfig( i2cNumber, clockRateHz );
+   #endif
+
+   return retVal;
+}
+
+
+bool_t i2cRead( i2cMap_t  i2cNumber,
+                uint8_t  i2cSlaveAddress,
+                uint8_t* dataToReadBuffer,
+                uint16_t dataToReadBufferSize,
+                bool_t   sendWriteStop,
+                uint8_t* receiveDataBuffer,
+                uint16_t receiveDataBufferSize,
+                bool_t   sendReadStop ){
+
+   bool_t retVal = FALSE;
+
+   if( i2cNumber != I2C0 ){
+      return FALSE;
+   }
+
+   #if( I2C_SOFTWARE == 1 )
+      retVal = i2cSoftwareRead( i2cNumber,
+                                i2cSlaveAddress,
+                                dataToReadBuffer,
+                                dataToReadBufferSize,
+                                sendWriteStop,
+                                receiveDataBuffer,
+                                receiveDataBufferSize,
+                                sendReadStop );
+   #else
+      retVal = i2cHardwareRead( i2cNumber,
+                                i2cSlaveAddress,
+                                dataToReadBuffer,
+                                dataToReadBufferSize,
+                                sendWriteStop,
+                                receiveDataBuffer,
+                                receiveDataBufferSize,
+                                sendReadStop );
+   #endif
+
+   return retVal;
+}
+
+
+bool_t i2cWrite( i2cMap_t  i2cNumber,
+                 uint8_t  i2cSlaveAddress,
+                 uint8_t* transmitDataBuffer,
+                 uint16_t transmitDataBufferSize,
+                 bool_t   sendWriteStop ){
+
+   bool_t retVal = FALSE;
+
+   if( i2cNumber != I2C0 ){
+      return FALSE;
+   }
+
+   #if( I2C_SOFTWARE == 1 )
+      retVal = i2cSoftwareWrite( i2cNumber,
+                                 i2cSlaveAddress,
+                                 transmitDataBuffer,
+                                 transmitDataBufferSize,
+                                 sendWriteStop );
+   #else
+      retVal = i2cHardwareWrite( i2cNumber,
+                                 i2cSlaveAddress,
+                                 transmitDataBuffer,
+                                 transmitDataBufferSize,
+                                 sendWriteStop );
+   #endif
+
+   return retVal;
+}
+
+
+#if( I2C_SOFTWARE == 1 )
+   // Software Master I2C
+
+   void i2cSoftwareDelay( tick_t duration ){
+      volatile tick_t i;
+
+      duration = 13 * duration;
+      for( i=duration; i>0; i-- );
+   }
+
+   // Ver!!!
+   // communication reset: DATA-line=1 and at least 9 SCK cycles followed by transstart
+   //       _____________________________________________________         ________
+   // DATA:                                                      |_______|
+   //          _    _    _    _    _    _    _    _    _        ___     ___
+   // SCK : __| |__| |__| |__| |__| |__| |__| |__| |__| |______|   |___|   |______
+
+
+   // Generates a transmission start bit sequence
+   //      ________
+   // SCL:         |_
+   //      _____
+   // SDA:      |____
+   //
+   void i2cSoftwareMasterWriteStart( void ){
+
+      // Clock (SCL) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+      // Data (SDA) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, HIGH );
+      // 1 clock time delay
+      i2cSoftwareDelay(10);
+
+      // Data (SDA) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+      // 1/2 clock time delay
+      i2cSoftwareDelay(5);
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 3/10 clock time delay
+      i2cSoftwareDelay(3);
+   }
+
+   // Generates a transmission stop bit sequence
+   //        ________
+   // SCL: _|
+   //           _____
+   // SDA: ____|
+
+   void i2cSoftwareMasterWriteStop( void ){
+      // Data (SDA) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 1/5 clock time delay
+      i2cSoftwareDelay(2);
+
+      // Clock (SCL) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+      // 1/2 clock time delay
+      i2cSoftwareDelay(5);
+
+      // Data (SDA) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, HIGH );
+      // 1 clock time delay
+      i2cSoftwareDelay(10);
+   }
+
+   // Write data byte
+   //          ___     ___     ___     ___     ___     ___     ___     ___     ___
+   // SCL: ___| 1 |___| 2 |___| 3 |___| 4 |___| 5 |___| 6 |___| 7 |___| 8 |___| 9 |___
+   //         _______ _______ _______ _______ _______ _______ _______ _______
+   // SDA: __|   D7  |   D6  |   D5  |   D4  |   D3  |   D2  |   D1  |   D0  |__ACK?__
+   //
+   bool_t i2cSoftwareMasterWriteByte( uint8_t dataByte ){
+
+      uint8_t i;
+      static bool_t ackOrNack;
+
+      for( i=8; i>0; i-- ) {
+
+         // Clock (SCL) pin LOW
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+         // Data (SDA) pin with MSB bit value of dataByte
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, (dataByte & 0x80) );
+         // 1/5 clock time delay
+         i2cSoftwareDelay(2);
+
+         // Clock (SCL) pin HIGH
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+         // 1/2 clock time delay
+         i2cSoftwareDelay(5);
+
+         // Clock (SCL) pin LOW
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+         // 3/10 clock time delay
+         i2cSoftwareDelay(3);
+
+         // left shift dataByte
+         dataByte <<= 1;
+     }
+
+      // Maintain SCL LOW for 1/10 clock time delay
+      i2cSoftwareDelay(1);
+      // Configure SDA pin as input
+      i2cSoftwarePinConfig( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT_PULLUP );
+      // Maintain SCL LOW for 1/10 clock time delay more
+      i2cSoftwareDelay(1);
+
+      // Clock (SCL) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+      // 1/10 clock time delay
+      i2cSoftwareDelay(1);
+      // Read Data (SDA) pin for possible ACK bit
+      ackOrNack = i2cSoftwarePinRead( I2C_SOFTWARE_SDA_IN );
+      // 2/5 clock time delay
+      i2cSoftwareDelay(4);
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 1/5 clock time delay
+      i2cSoftwareDelay(2);
+      // Configure SDA pin as output. This prevent that SCL master, the
+      // microcontroller, and SCL Slave, device, both OUTPUT at the same time.
+      // This Output-Output condition can damage devices.
+      i2cSoftwarePinConfig( I2C_SOFTWARE_SDA_DIR, GPIO_OUTPUT );
+      // 1/10 clock time delay
+      i2cSoftwareDelay(1);
+
+     return ackOrNack;
+   }
+
+   // Read data byte
+   //          ___     ___     ___     ___     ___     ___     ___     ___     ___
+   // SCL: ___| 1 |___| 2 |___| 3 |___| 4 |___| 5 |___| 6 |___| 7 |___| 8 |___| 9 |___
+   //         _______ _______ _______ _______ _______ _______ _______ _______
+   // SDA: __|   D7  |   D6  |   D5  |   D4  |   D3  |   D2  |   D1  |   D0  |__ACK?__
+   //
+   uint8_t i2cSoftwareMasterReadByte( bool_t ack ){
+
+      uint8_t i, receivedData = 0;
+      bool_t receivedBit = 0;
+
+      // Configure SDA pin as input
+      i2cSoftwarePinConfig( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT_PULLUP );
+
+      for( i=8; i>0; i-- ) {
+
+         // Clock (SCL) pin LOW
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+         // 1/5 clock time delay
+         i2cSoftwareDelay(2);
+
+         //do{
+            // Clock (SCL) pin HIGH
+            i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+         //}while( SCL_IN == 0 );    // wait for any SCL clock stretching
+         // 1/10 clock time delay
+         i2cSoftwareDelay(1);
+         // Read Data (SDA) pin
+         receivedBit = i2cSoftwarePinRead( I2C_SOFTWARE_SDA_IN );
+         // 2/5 clock time delay
+         i2cSoftwareDelay(4);
+
+         // Shift left receivedData
+         receivedData <<= 1;
+
+         if( receivedBit ){
+            receivedData |= 0x01;
+         }
+
+         // Clock (SCL) pin LOW
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+         // 3/10 clock time delay
+         i2cSoftwareDelay(3);
+      }
+
+      // Maintain SCL LOW for 1/10 clock time delay
+      i2cSoftwareDelay(1);
+      // Configure SDA pin as output
+      i2cSoftwarePinConfig( I2C_SOFTWARE_SDA_DIR, GPIO_OUTPUT );
+
+      // send (N)ACK bit (ACK=LOW, NACK=HIGH)
+      if( ack ){
+         // Data (SDA) pin LOW
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+      }else{
+         // Data (SDA) pin HIGH
+         i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, HIGH );
+      }
+      // Maintain SCL LOW for 1/10 clock time delay more
+      i2cSoftwareDelay(1);
+
+      // Clock (SCL) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+      // 1/2 clock time delay
+      i2cSoftwareDelay(5);
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 1/10 clock time delay
+      i2cSoftwareDelay(1);
+      // Data (SDA) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+      // 1/5 clock time delay
+      i2cSoftwareDelay(2);
+
+      return receivedData;
+   }
+   /* That's almost it for simple I2C communications, but there is one more
+    * complication. When the master is reading from the slave, its the slave that
+    * places the data on the SDA line, but its the master that controls the clock.
+    * What if the slave is not ready to send the data! With devices such as
+    * EEPROMs this is not a problem, but when the slave device is actually a
+    * microprocessor with other things to do, it can be a problem. The
+    * microprocessor on the slave device will need to go to an interrupt routine,
+    * save its working registers, find out what address the master wants to read
+    * from, get the data and place it in its transmission register. This can take
+    * many uS to happen, meanwhile the master is blissfully sending out clock
+    * pulses on the SCL line that the slave cannot respond to. The I2C protocol
+    * provides a solution to this: the slave is allowed to hold the SCL line low!
+    * This is called clock stretching. When the slave gets the read command from
+    * the master it holds the clock line low. The microprocessor then gets the
+    * requested data, places it in the transmission register and releases the
+    * clock line allowing the pull-up resistor to finally pull it high. From the
+    * masters point of view, it will issue the first clock pulse of the read by
+    * making SCL high and then check to see if it really has gone high. If its
+    * still low then its the slave that holding it low and the master should wait
+    * until it goes high before continuing. Luckily the hardware I2C ports on
+    * most microprocessors will handle this automatically.
+    *
+    * Sometimes however, the master I2C is just a collection of subroutines and
+    * there are a few implementations out there that completely ignore clock
+    * stretching. They work with things like EEPROM's but not with microprocessor
+    * slaves that use clock stretching. The result is that erroneous data is read
+    * from the slave. Beware!
+    *
+    * http://www.robot-electronics.co.uk/i2c-tutorial
+    */
+
+
+   // Write 7 bit address + R or W bit
+   //              ___
+   // SDA: _______|
+   //          _______
+   // SCL: ___|
+   //
+   bool_t i2cSoftwareMasterWriteAddress( uint8_t i2cSlaveAddress,
+                                         I2C_Software_rw_t readOrWrite ){
+
+      bool_t ackOrNack = FALSE;
+
+      if( readOrWrite == I2C_SOFTWARE_WRITE ){
+         // 7 bit address + Write = 0
+         i2cSlaveAddress <<= 1;
+         ackOrNack = i2cSoftwareMasterWriteByte( i2cSlaveAddress );
+
+      } else if( readOrWrite == I2C_SOFTWARE_READ ){
+         // 7 bit address + Read = 1
+         i2cSlaveAddress <<= 1;
+         i2cSlaveAddress |= 0x01;
+         ackOrNack = i2cSoftwareMasterWriteByte( i2cSlaveAddress );
+      }
+
+      return ackOrNack;
+   }
+#endif
+
+
+#if( SOFTWARE_I2C_DEBUG == 1 )
+
+   /*
+    * ConexiÃ³n:
+    *
+    * Se debe conectar un led al pin elegido como SCL con una R de 470ohm.
+    * Otro led al pin elegido como SDA con una R de 470ohm.
+    * Una R de pull-up de 4K7 entre VDD=+3.3V y SDA.
+    * Un pulsador entre GND y SDA.
+    *
+    * Funcionamiento:
+    *
+    * Cada 10 segundos toglea el modo del pin SDA entre Input y Output.
+    * Mientras SDA es input escribe el valor del pulsador en el pin SCL.
+    * Cada 500ms se toglea una variable llamada clockStatus.
+    * Mientras el pin SDA es Output se escribe en el led conectado a SDA
+    * el valor de la variable clockStatus.
+    */
+
+    //#include "sapi_delay.h"
+
+    // Test vars
+    bool_t clockStatus = FALSE;
+    delay_t clockDelay;
+    bool_t direction = FALSE;
+    delay_t delayDir;
+
+    void i2cSoftwareMasterPinTestConfig( void ){
+       delayConfig( &clockDelay, 500 );
+       delayConfig( &delayDir, 10000 );
+    }
+
+    void i2cSoftwareMasterPinTest( void ){
+
+       if( delayRead( &delayDir ) ){
+          if( direction ){
+             direction = FALSE;
+          } else{
+             direction = TRUE;
+          }
+//          I2C_SOFTWARE_SDA_DIR = direction;
+       }
+
+       if( delayRead( &clockDelay ) ){
+          if( clockStatus ){
+             clockStatus = FALSE;
+          } else{
+             clockStatus = TRUE;
+          }
+          //I2C_SOFTWARE_SCL_OUT = clockStatus;
+       }
+
+       if( direction ){ // Input
+          //I2C_SOFTWARE_SCL_OUT = I2C_SOFTWARE_SDA_IN;
+          i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, I2C_SOFTWARE_SDA_IN );
+       } else{          // Output
+          //I2C_SOFTWARE_SDA_OUT = clockStatus;
+          i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, clockStatus );
+       }
+    }
+#endif
+
+/*==================[ISR external functions definition]======================*/
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_keypad.c ./sapi/src/sapi_keypad.c
--- a_qSC69Z/sapi/src/sapi_keypad.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_keypad.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,158 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Date: 2016-07-28
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_keypad.h"       /* <= own header */
+
+#include "sapi_delay.h"               /* <= delay header */
+#include "sapi_gpio.h"                /* <= GPIO header */
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+
+/* Configure keypad pins */
+bool_t keypadConfig( keypad_t* keypad,
+                     gpioMap_t* keypadRowPins, uint8_t keypadRowSize,
+                     gpioMap_t* keypadColPins, uint8_t keypadColSize ){
+
+   bool_t retVal = TRUE;
+
+   uint8_t i = 0;
+
+   // Check if values are not invalid
+   if( keypadRowPins == NULL || keypadColPins == NULL ||
+       keypadRowSize <= 0 || keypadColSize <= 0  ){
+      retVal = FALSE;
+   }
+
+   // Configure keypad instance
+   keypad->keypadRowPins = keypadRowPins;
+   keypad->keypadRowSize = keypadRowSize;
+   keypad->keypadColPins = keypadColPins;
+   keypad->keypadColSize = keypadColSize;
+
+   // Configure Rows as Outputs
+   for( i=0; i<keypadRowSize; i++ ){
+      gpioConfig( keypad->keypadRowPins[i], GPIO_OUTPUT );
+   }
+
+   // Configure Columns as Inputs with pull-up resistors enable
+   for( i=0; i<keypadColSize; i++ ){
+      gpioConfig( keypad->keypadColPins[i], GPIO_INPUT_PULLUP );
+   }
+
+   return retVal;
+}
+
+
+/* Return TRUE if any key is pressed or FALSE (0) in other cases.
+ * If exist key pressed write pressed key on key variable */
+bool_t keypadRead( keypad_t* keypad, uint16_t* key ){
+
+   bool_t retVal = FALSE;
+
+   uint8_t r = 0; // Rows
+   uint8_t c = 0; // Columns
+
+   // Put all Rows in LOW state
+   for( r=0; r<keypad->keypadRowSize; r++ ){
+      gpioWrite( keypad->keypadRowPins[r], LOW );
+   }
+
+   // Check all Columns to search if any key is pressed
+   for( c=0; c<keypad->keypadColSize; c++ ){
+
+      // If reads a LOW state in a column then that key may be pressed
+      if( !gpioRead( keypad->keypadColPins[c] ) ){
+
+         delay( 50 ); // Debounce 50 ms
+
+         // Put all Rows in HIGH state except first one
+         for( r=1; r<keypad->keypadRowSize; r++ ){
+            gpioWrite( keypad->keypadRowPins[r], HIGH );
+         }
+
+         // Search what key are pressed
+         for( r=0; r<keypad->keypadRowSize; r++ ){
+
+            // Put the Row[r-1] in HIGH state and the Row[r] in LOW state
+            if( r>0 ){ // Prevents negative index in array
+               gpioWrite( keypad->keypadRowPins[r-1], HIGH );
+            }
+            gpioWrite( keypad->keypadRowPins[r], LOW );
+
+            // Check Columns[c] at Row[r] to search if the key is pressed
+            // if that key is pressed (LOW state) then retuns the key
+            if( !gpioRead( keypad->keypadColPins[c] ) ){
+               *key = (uint16_t)r * (uint16_t)(keypad->keypadColSize) + (uint16_t)c;
+               retVal = TRUE;
+               return retVal;
+            }
+         }
+
+      }
+   }
+
+   /*
+      4 rows * 5 columns Keypad
+
+         c0 c1 c2 c3 c4
+      r0  0  1  2  3  4
+      r1  5  6  7  8  9    Press r[i] c[j] => (i) * amountOfColumns + (j)
+      r2 10 11 12 13 14
+      r3 15 16 17 18 19
+   */
+
+   // if no key are pressed then retun FALSE
+   return retVal;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_pwm.c ./sapi/src/sapi_pwm.c
--- a_qSC69Z/sapi/src/sapi_pwm.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_pwm.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,273 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/* TODO: hacer una forma de buscar las funciones que tocan el modulo siguiente
+ * All functions relative to the microcontroller */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_pwm.h"
+#include "sapi_sct.h"
+
+/*==================[macros and definitions]=================================*/
+
+#ifndef EMPTY_POSITION
+   #define EMPTY_POSITION 255
+#endif
+
+#define PWM_TOTALNUMBER   11   /* From PWM0 to PWM10 */
+
+#define PWM_FREC          1000 /* 1Khz */
+#define PWM_PERIOD        1000 /* 1000uS = 1ms*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*
+ * @Brief: Initializes the pwm timers.
+ * @param  none
+ * @return nothing
+ */
+static void pwmInitTimers(void);
+
+/*
+ * @brief:   adds pwm to the the list of working pwms
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   True if pwm was successfully attached, False if not.
+ */
+static bool_t pwmAttach( pwmMap_t pwmNumber );
+
+/*
+ * @brief:   removes pwm (attached to pwmNumber) from the list
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:    True if pwm was successfully detached, False if not.
+ */
+static bool_t pwmDetach( pwmMap_t pwmNumber );
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/* Enter a pwm number, get a sct number
+ * Since this module works with pwm numbers, but uses sct channels to generate
+ * the signal, its necessary to connect pwm number with the SctMap_t (sAPI_PeripheralMap.h).
+ * This way the user sets "pwms", while using the sct peripheral internally*/
+static const uint8_t pwmMap[PWM_TOTALNUMBER] = {
+   /* PWM0 */  CTOUT1,  /* T_FIL1 */
+   /* PWM1 */  CTOUT12, /* T_COL2 */
+   /* PWM2 */  CTOUT10, /* T_COL0 */
+   /* PWM3 */  CTOUT0,  /* T_FIL2 */
+   /* PWM4 */  CTOUT3,  /* T_FIL3 */
+   /* PWM5 */  CTOUT13, /* T_COL1 */
+   /* PWM6 */  CTOUT7,  /* GPIO8  */
+   /* PWM7 */  CTOUT2,  /* LED1   */
+   /* PWM8 */  CTOUT5,  /* LED2   */
+   /* PWM9 */  CTOUT4,  /* LED3   */
+   /* PWM10 */ CTOUT6   /* GPIO2  */
+};
+
+/*when the user adds a pwm with pwmAttach the list updates with the pin number of the element*/
+static uint8_t AttachedPWMList[PWM_TOTALNUMBER] = {
+/*Position | Pwm Number*/
+   /*0*/  EMPTY_POSITION,
+   /*1*/  EMPTY_POSITION,
+   /*2*/  EMPTY_POSITION,
+   /*3*/  EMPTY_POSITION,
+   /*4*/  EMPTY_POSITION,
+   /*5*/  EMPTY_POSITION,
+   /*6*/  EMPTY_POSITION,
+   /*7*/  EMPTY_POSITION,
+   /*8*/  EMPTY_POSITION,
+   /*9*/	EMPTY_POSITION,
+   /*10*/ EMPTY_POSITION,
+};
+
+/*==================[internal functions definition]==========================*/
+
+/*
+ * @Brief:   Initializes the pwm timers.
+ * @param   none
+ * @return   nothing
+ */
+static void pwmInitTimers(void){
+   Sct_Init(PWM_FREC);
+}
+
+/*
+ * @brief:   adds pwm to the the list of working pwms
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   True if pwm was successfully attached, False if not.
+ */
+static bool_t pwmAttach( pwmMap_t pwmNumber){
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = pwmIsAttached(pwmNumber);
+   if(position==0){
+      position = pwmIsAttached(EMPTY_POSITION); /* Searches for the first empty position */
+      if(position){ /* if position==0 => there is no room in the list for another pwm */
+         AttachedPWMList[position-1] = pwmNumber;
+         Sct_EnablePwmFor(pwmMap[pwmNumber]);
+         success = TRUE;
+      }
+   }
+   return success;
+}
+
+/*
+ * @brief:   removes pwm (attached to pwmNumber) from the list
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:    True if pwm was successfully detached, False if not.
+ */
+static bool_t pwmDetach( pwmMap_t pwmNumber ){
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = pwmIsAttached(pwmNumber);
+
+   if(position){
+      AttachedPWMList[position-1] = EMPTY_POSITION;
+      success = TRUE;
+   }
+   return success;
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @brief:   change the value of the pwm at the selected pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @param:   value:   8bit value, from 0 to 255
+ * @return:   True if the value was successfully changed, False if not.
+ */
+bool_t pwmWrite( pwmMap_t pwmNumber, uint8_t value ){
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = pwmIsAttached(pwmNumber);
+
+   if(position){
+      Sct_SetDutyCycle(pwmMap[pwmNumber], value);
+      success = TRUE;
+   }
+
+   return success;
+}
+
+/*
+ * @brief:   read the value of the pwm in the pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   value of the pwm in the pin (0 ~ 255).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint8_t pwmRead( pwmMap_t pwmNumber ){
+
+   uint8_t position = 0, value = 0;
+   position = pwmIsAttached(pwmNumber);
+
+   if(position){
+      value = Sct_GetDutyCycle(pwmMap[pwmNumber]);
+   }else{
+      value = EMPTY_POSITION;
+   }
+
+   return value;
+}
+
+
+/*
+ * @Brief: Initializes the pwm peripheral.
+ * @param  uint8_t pwmNumber
+ * @param  uint8_t config
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t pwmConfig( pwmMap_t pwmNumber, pwmConfig_t config){
+
+   bool_t ret_val = 1;
+
+   switch(config){
+
+      case PWM_ENABLE:
+         pwmInitTimers();
+      break;
+
+      case PWM_DISABLE:
+         ret_val = 0;
+      break;
+
+      case PWM_ENABLE_OUTPUT:
+         ret_val = pwmAttach( pwmNumber );
+      break;
+
+      case PWM_DISABLE_OUTPUT:
+         ret_val = pwmDetach( pwmNumber );
+      break;
+
+      default:
+         ret_val = 0;
+      break;
+   }
+
+   return ret_val;
+}
+
+/*
+ * @brief:   Tells if the pwm is currently active, and its position
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   position (1 ~ PWM_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t pwmIsAttached( pwmMap_t pwmNumber )
+{
+   uint8_t position = 0, positionInList = 0;
+   while ( (position < PWM_TOTALNUMBER) &&
+           (pwmNumber != AttachedPWMList[position]) ) {
+      position++;
+   }
+
+   if (position < PWM_TOTALNUMBER){
+      positionInList = position + 1;
+   } else{
+      positionInList = 0;
+   }
+
+   return positionInList;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_rtc.c ./sapi/src/sapi_rtc.c
--- a_qSC69Z/sapi/src/sapi_rtc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_rtc.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,146 @@
+/* Copyright 2011, ChaN.
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-03-07 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_rtc.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief: Configure RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcConfig( rtc_t * rtc ){
+
+   bool_t ret_val = 1;
+
+   static bool_t init;
+   RTC_TIME_T rtcTime;
+
+   if( init ){
+      /* Already initialized */
+      ret_val = 0;
+   } else {
+
+      /* RTC Block section ------------------------- */
+      Chip_RTC_Init(LPC_RTC);
+
+      /* Set current time for RTC */
+      /* Current time is 22:00:00 , 2016-07-02 */
+      /*
+      rtcTime.time[RTC_TIMETYPE_SECOND]     = 0;
+      rtcTime.time[RTC_TIMETYPE_MINUTE]     = 0;
+      rtcTime.time[RTC_TIMETYPE_HOUR]       = 22;
+      rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = 2;
+      rtcTime.time[RTC_TIMETYPE_MONTH]      = 7;
+      rtcTime.time[RTC_TIMETYPE_YEAR]       = 2016;
+      Chip_RTC_SetFullAlarmTime(LPC_RTC, &rtcTime);
+      */
+      rtcWrite( rtc );
+
+      /* Enable rtc (starts increase the tick counter
+         and second counter register) */
+      Chip_RTC_Enable(LPC_RTC, ENABLE);
+
+      init = 1;
+   }
+
+   return ret_val;
+}
+
+/*
+ * @Brief: Get time from RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcRead( rtc_t * rtc ){
+
+   bool_t ret_val = 1;
+
+   RTC_TIME_T rtcTime;
+
+   Chip_RTC_GetFullTime(LPC_RTC, &rtcTime);
+
+   rtc->sec = rtcTime.time[RTC_TIMETYPE_SECOND];
+   rtc->min = rtcTime.time[RTC_TIMETYPE_MINUTE];
+   rtc->hour = rtcTime.time[RTC_TIMETYPE_HOUR];
+   rtc->wday = rtcTime.time[RTC_TIMETYPE_DAYOFWEEK];
+   rtc->mday = rtcTime.time[RTC_TIMETYPE_DAYOFMONTH];
+   rtc->month = rtcTime.time[RTC_TIMETYPE_MONTH];
+   rtc->year = rtcTime.time[RTC_TIMETYPE_YEAR];
+
+   return ret_val;
+}
+
+/*
+ * @Brief: Set time on RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcWrite( rtc_t * rtc ){
+
+   bool_t ret_val = 1;
+
+   RTC_TIME_T rtcTime;
+
+   rtcTime.time[RTC_TIMETYPE_SECOND]     = rtc->sec;
+   rtcTime.time[RTC_TIMETYPE_MINUTE]     = rtc->min;
+   rtcTime.time[RTC_TIMETYPE_HOUR]       = rtc->hour;
+   rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->wday;
+   rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->mday;
+   rtcTime.time[RTC_TIMETYPE_MONTH]      = rtc->month;
+   rtcTime.time[RTC_TIMETYPE_YEAR]	     = rtc->year;
+
+   Chip_RTC_SetFullTime(LPC_RTC, &rtcTime);
+
+   return ret_val;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_sct.c ./sapi/src/sapi_sct.c
--- a_qSC69Z/sapi/src/sapi_sct.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_sct.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,167 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/*The SCT (State Configurable Timer) is a feature included in some of LPC's microcontrollers
+ * that provides a high resolution PWM (or just another timer).
+ * It's like a normal timer but with multiple Compare Match values (16),
+ * and can be therefore used to generate several PWM signals with THE SAME PERIOD
+ * For more information about the STCPWM peripheral, refer to the Chapter 39 of
+ * the LPC43xx user manual
+ */
+
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_sct.h"
+
+/* Specific modules used:
+   #include "scu_18xx_43xx.h" for Chip_SCU funtions
+   #include "sct_pwm_18xx_43xx.h" for Chip_SCTPWM funtions
+*/
+
+/*==================[macros and definitions]=================================*/
+
+/* Because all pins have their CTOUT in the FUNC1 there is no need to
+   save the same number for every pin in this case. */
+#define CTOUT_FUNC   FUNC1
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+/*
+ * List of ports and pins corresponding to the sct channels.
+ * Each channel is asociated with a CTOUT number. Some pins, like
+ * LED 1 and LCD1, have the same channel, so you can only generate 1 signal
+ * for both. Because of that only one of them will be used.
+ */
+static pinConfigLpc4337_t SCTdataList[] =
+{
+/* Sct nÂ° | port | pin | name in board */
+/* CTOUT0 */ { 4 , 2 }, /* T_FIL2 */
+/* CTOUT1 */ { 4 , 1 }, /* T_FIL1 */
+/* CTOUT2 */ { 2 , 10 }, /* LED1 (also for LCD1) */
+/* CTOUT3 */ { 4 , 3 }, /* T_FIL3 */
+/* CTOUT4 */ { 2 , 12 }, /* LED3 (also for LCD3) */
+/* CTOUT5 */ { 2 , 11 }, /* LED2 (also for LCD2) */
+/* CTOUT6 */ { 6 , 5 }, /* GPIO2 */
+/* CTOUT7 */ { 6 , 12 }, /* GPIO8 */
+/* CTOUT8 */ { 1 , 3 }, /* MDC / SPI_MISO */
+/* CTOUT9 */ { 1 , 4 }, /* SPI_MOSI */
+/* CTOUT10 */ { 1 , 5 }, /* T_COL0 */
+/* CTOUT11 */ { 0 , 0 }, /* DO NOT USE */
+/* CTOUT12 */ { 7 , 5 }, /* T_COL2 */
+/* CTOUT13 */ { 7 , 4 } /* T_COL1 */
+};
+
+/*Configuration data for LCD1, LCD2 and LCD3:
+ CTOUT_2 { 4 , 4 }, LCD1
+ CTOUT_5 { 4 , 5 }, LCD2
+ CTOUT_4 { 4 , 6 }, LCD3
+ */
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+/*
+ * @brief:   Initialize the SCT peripheral with the given frequency
+ * @param:   frequency:   value in Hz
+ * @note:   there can only be 1 frequency in all the SCT peripheral.
+ */
+void Sct_Init(uint32_t frequency)
+{
+   /* Source: https://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen */
+   /* Initialize the SCT as PWM and set frequency */
+   Chip_SCTPWM_Init(LPC_SCT);
+   Chip_SCTPWM_SetRate(LPC_SCT, frequency);
+
+   Chip_SCTPWM_Start(LPC_SCT);
+}
+
+/*
+ * @brief	Enables pwm function for the given pin
+ * @param	sctNumber:   pin where the pwm signal will be generated
+ */
+void Sct_EnablePwmFor(uint8_t sctNumber)
+{
+   /*Enable SCT function on pin*/
+   Chip_SCU_PinMux(SCTdataList[sctNumber].port , SCTdataList[sctNumber].pin , SCU_MODE_INACT , CTOUT_FUNC);
+   /*Sets pin as PWM output and gives it an index (SCTdataList[sctNumber].mode+1)*/
+   Chip_SCTPWM_SetOutPin(LPC_SCT, sctNumber+1, sctNumber);
+
+   /* Start with 0% duty cycle */
+   Sct_SetDutyCycle(sctNumber, Chip_SCTPWM_PercentageToTicks(LPC_SCT,0));
+}
+
+/*
+ * @brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   value:   8bit value, from 0 to 255
+ * @return   Equivalent in Ticks for the LPC4337
+ */
+uint32_t Sct_Uint8ToTicks(uint8_t value)
+{
+   return ( (Chip_SCTPWM_GetTicksPerCycle(LPC_SCT) * value)/ 255 );
+}
+
+
+/*
+ * @brief:   Sets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @param	value:   8bit value, from 0 to 255
+ * @note   For the 'ticks' parameter, see function Sct_Uint8ToTicks
+ */
+void Sct_SetDutyCycle(uint8_t sctNumber, uint8_t value)
+{
+   Chip_SCTPWM_SetDutyCycle(LPC_SCT, sctNumber+1, Sct_Uint8ToTicks(value));
+}
+
+/*
+ * @brief:   Gets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @return:   duty cycle of the channel, from 0 to 255
+ */
+ /* TODO: function not tested */
+uint8_t Sct_GetDutyCycle(uint8_t sctNumber)
+{
+   uint8_t value = 0;
+
+   value = (uint8_t) ((Chip_SCTPWM_GetDutyCycle(LPC_SCT, sctNumber+1)*255)/Chip_SCTPWM_GetTicksPerCycle(LPC_SCT));
+
+   return value;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_servo.c ./sapi/src/sapi_servo.c
--- a_qSC69Z/sapi/src/sapi_servo.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_servo.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,421 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/*TODO: make a graphic and explanation of the timer ramp and compare match values
+ to make everything clear */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_gpio.h"
+#include "sapi_servo.h"
+#include "sapi_timer.h"
+
+/*==================[macros and definitions]=================================*/
+
+#define EMPTY_POSITION   255
+#define SERVO_TOTALNUMBER   9
+#define SERVO_COMPLETECYCLE_PERIOD   20000  /*value in uSec */
+#define SERVO_MAXUPTIME_PERIOD   2000  /*value in uSec */
+#define SERVO_MINUPTIME_PERIOD   500 /*value in uSec */
+
+/*==================[internal data declaration]==============================*/
+
+typedef struct
+{
+   uint8_t servo; /*Servo number. It's mapped to the DIOMap_t in the servoMap*/
+   uint8_t value; /*Value of the servo*/
+   /*To manage each servo more efficiently, every one of them has a default
+   * timer, match number and function associated depending of their position in the list
+   * This can be done because all timers initialize with the same period (20ms). So,  if
+   * you need different frequencies for different timers you will have to change that since
+   * it won't be the same to attach a servo in one position or another in the list*/
+   uint8_t associatedTimer;
+   uint8_t associatedCompareMatch;
+   voidFunctionPointer_t associatedFunction;
+
+}attachedServo_t;
+
+/*==================[internal functions declaration]=========================*/
+
+static uint32_t valueToMicroseconds(uint8_t );
+
+static void timer1CompareMatch0func(void);
+static void timer1CompareMatch1func(void);
+static void timer1CompareMatch2func(void);
+static void timer1CompareMatch3func(void);
+
+static void timer2CompareMatch0func(void);
+static void timer2CompareMatch1func(void);
+static void timer2CompareMatch2func(void);
+static void timer2CompareMatch3func(void);
+
+static void timer3CompareMatch0func(void);
+static void timer3CompareMatch1func(void);
+static void timer3CompareMatch2func(void);
+static void timer3CompareMatch3func(void);
+
+static void servoInitTimers( void );
+static bool_t servoAttach( servoMap_t servoNumber );
+static bool_t servoDetach( servoMap_t servoNumber );
+
+/*==================[internal data definition]===============================*/
+
+/* Enter a servo number, get a Gpio number
+ * Since this module works with servo numbers, but uses gpio pins to generate
+ * the signal, its necessary to connect servo number with the DIOMap_t (sAPI_PeripheralMap.h).
+ * This way the user sets "servos", while using gpio outputs internally so the gpioWrite()
+ * function can be easily used*/
+static const uint8_t servoMap[SERVO_TOTALNUMBER] =
+{
+   /* Servo name | DIOMap name | Name in the board*/
+   /* SERVO0 */ T_FIL1, /* T_FIL1 */
+   /* SERVO1 */ T_COL0, /* T_COL0 */
+   /* SERVO2 */ T_FIL2, /* T_FIL2 */
+   /* SERVO3 */ T_FIL3, /* T_FIL3 */
+   /* SERVO4 */ GPIO8,  /* GPIO8  */
+   /* SERVO5 */ LCD1,   /* LCD1   */
+   /* SERVO6 */ LCD2,   /* LCD2   */
+   /* SERVO7 */ LCD3,   /* LCD3   */
+   /* SERVO8 */ GPIO2   /* GPIO2  */
+};
+
+/*when the user adds a servo with servoAttach the list updates with the servo number*/
+static attachedServo_t AttachedServoList[SERVO_TOTALNUMBER] =
+{
+/*position |Servo number | value | asociatedTimer | associatedCompareMatch | associatedFunction*/
+   /*0*/	{EMPTY_POSITION , 0,  TIMER1 , TIMERCOMPAREMATCH1 , timer1CompareMatch1func},
+   /*1*/	{EMPTY_POSITION , 0 , TIMER1 , TIMERCOMPAREMATCH2 , timer1CompareMatch2func},
+   /*2*/	{EMPTY_POSITION , 0 , TIMER1 , TIMERCOMPAREMATCH3 , timer1CompareMatch3func},
+   /*3*/	{EMPTY_POSITION , 0 , TIMER2 , TIMERCOMPAREMATCH1 , timer2CompareMatch1func},
+   /*4*/	{EMPTY_POSITION , 0 , TIMER2 , TIMERCOMPAREMATCH2 , timer2CompareMatch2func},
+   /*5*/	{EMPTY_POSITION , 0 , TIMER2 , TIMERCOMPAREMATCH3 , timer2CompareMatch3func},
+   /*6*/	{EMPTY_POSITION , 0 , TIMER3 , TIMERCOMPAREMATCH1 , timer3CompareMatch1func},
+   /*7*/	{EMPTY_POSITION , 0 , TIMER3 , TIMERCOMPAREMATCH2 , timer3CompareMatch2func},
+   /*8*/	{EMPTY_POSITION , 0 , TIMER3 , TIMERCOMPAREMATCH3 , timer3CompareMatch3func}
+};
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*
+ * @brief   Converts a value in value to micro seconds for a specific type of servo (see the defines)
+ * @param   value:   value of the servo, from 0 to 180
+ * @return   Equivalent in microseconds for a specific type of servo (see the defines)
+ * @note   Should be used with Timer_microsecondsToTicks to use some of
+ *   the functions in the sAPI_Timer that requires ticks as a parameter
+*/
+static uint32_t valueToMicroseconds(uint8_t value){
+
+   return (SERVO_MINUPTIME_PERIOD+(value*SERVO_MAXUPTIME_PERIOD)/180);
+}
+
+/*
+ * @brief:	compare match 0 function. The one that is executed when the cycle ends
+ * (to visualize it, think about the 'timer ramp')
+ * @note:   this function can't be generalized because sAPI_Timer functions expect void-void function pointers
+ */
+static void timer1CompareMatch0func(void)
+{
+   uint8_t servoListPosition= 0;
+
+   for(servoListPosition=0;servoListPosition<3;servoListPosition++)
+   {
+      if(AttachedServoList[servoListPosition].servo != EMPTY_POSITION)
+      {
+         gpioWrite(servoMap[AttachedServoList[servoListPosition].servo],TRUE);
+         Timer_SetCompareMatch( 	AttachedServoList[servoListPosition].associatedTimer,
+                                    AttachedServoList[servoListPosition].associatedCompareMatch,
+                                    Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[servoListPosition].value)));
+      }
+   }
+}
+
+static void timer1CompareMatch1func(void)
+{
+   gpioWrite(servoMap[AttachedServoList[0].servo],FALSE);
+}
+
+static void timer1CompareMatch2func(void)
+{
+   gpioWrite(servoMap[AttachedServoList[1].servo],FALSE);
+}
+
+static void timer1CompareMatch3func(void)
+{
+   gpioWrite(servoMap[AttachedServoList[2].servo],FALSE);
+}
+
+static void timer2CompareMatch0func(void)
+{
+   uint8_t servoListPosition= 3;
+
+   for(servoListPosition=3;servoListPosition<6;servoListPosition++)
+   {
+      if(AttachedServoList[servoListPosition].servo != EMPTY_POSITION)
+      {
+         gpioWrite(servoMap[AttachedServoList[servoListPosition].servo],TRUE);
+         Timer_SetCompareMatch( AttachedServoList[servoListPosition].associatedTimer,
+                                 AttachedServoList[servoListPosition].associatedCompareMatch,
+                                 Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[servoListPosition].value)));
+		}
+	}
+}
+
+static void timer2CompareMatch1func(void){
+   gpioWrite(servoMap[AttachedServoList[3].servo],FALSE);
+}
+
+static void timer2CompareMatch2func(void){
+   gpioWrite(servoMap[AttachedServoList[4].servo],FALSE);
+}
+
+static void timer2CompareMatch3func(void){
+   gpioWrite(servoMap[AttachedServoList[5].servo],FALSE);
+}
+
+static void timer3CompareMatch0func(void){
+
+   uint8_t servoListPosition= 6;
+
+   for(servoListPosition=6;servoListPosition<9;servoListPosition++)
+   {
+      if(AttachedServoList[servoListPosition].servo != EMPTY_POSITION)
+      {
+         gpioWrite(servoMap[AttachedServoList[servoListPosition].servo],TRUE);
+         Timer_SetCompareMatch( AttachedServoList[servoListPosition].associatedTimer,
+                                 AttachedServoList[servoListPosition].associatedCompareMatch,
+                                 Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[servoListPosition].value)));
+      }
+   }
+}
+
+static void timer3CompareMatch1func(void){
+   gpioWrite(servoMap[AttachedServoList[6].servo],FALSE);
+}
+
+static void timer3CompareMatch2func(void){
+   gpioWrite(servoMap[AttachedServoList[7].servo],FALSE);
+}
+
+static void timer3CompareMatch3func(void){
+   gpioWrite(servoMap[AttachedServoList[8].servo],FALSE);
+}
+
+
+/*
+ * @Brief: Initializes the servo peripheral
+ * @param   none
+ * @return   nothing
+ * @IMPORTANT:   this function uses Timer 1, 2 and 3 to generate the servo signals, so
+ *   they won't be available to use.
+ */
+static void servoInitTimers(void){
+   Timer_Init( TIMER1,
+               Timer_microsecondsToTicks(SERVO_COMPLETECYCLE_PERIOD),
+               timer1CompareMatch0func
+              );
+   Timer_Init( TIMER2,
+               Timer_microsecondsToTicks(SERVO_COMPLETECYCLE_PERIOD),
+               timer2CompareMatch0func
+             );
+   Timer_Init( TIMER3,
+               Timer_microsecondsToTicks(SERVO_COMPLETECYCLE_PERIOD),
+               timer3CompareMatch0func
+             );
+}
+
+/*
+ * @brief: adds a servo to the active servos list
+ * @param   servoNumber:   ID of the servo, from 0 to 8
+ * @return: True if servo was successfully attached, False if not.
+ */
+static bool_t servoAttach( servoMap_t servoNumber)
+{
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   /* Pin must b config as Output */
+   gpioConfig( (gpioMap_t)servoNumber, GPIO_OUTPUT );
+
+   position = servoIsAttached(servoNumber);
+   if(position==0)
+   {
+      position = servoIsAttached(EMPTY_POSITION); /* Searches for the first empty position */
+      if(position) /* if position==0 => there is no room in the list for another servo */
+      {
+         AttachedServoList[position-1].servo = servoNumber;
+         /* Enables the compare match interrupt */
+         Timer_EnableCompareMatch( AttachedServoList[position-1].associatedTimer,
+                                    AttachedServoList[position-1].associatedCompareMatch,
+                                    Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[position-1].value)),
+                                    AttachedServoList[position-1].associatedFunction
+                                 );
+         success = TRUE;
+      }
+   }
+
+   return success;
+}
+
+/*
+ * @brief: removes a servo from the active servos list
+ * @param   servoNumber:   ID of the servo, from 0 to 8
+ * @return: True if servo was successfully detached, False if not.
+ */
+static bool_t servoDetach( servoMap_t servoNumber )
+{
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = servoIsAttached(servoNumber);
+
+   if(position)
+   {
+      AttachedServoList[position-1].servo = EMPTY_POSITION;
+      AttachedServoList[position-1].value = 0;
+      Timer_DisableCompareMatch( AttachedServoList[position-1].associatedTimer,
+                                 AttachedServoList[position-1].associatedCompareMatch);
+      success = TRUE;
+   }
+   return success;
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief: Initializes the servo peripheral
+ * @param  uint8_t servoNumber
+ * @param  uint8_t config
+ * @return   nothing
+ * @IMPORTANT:   this function uses Timer 1, 2 and 3 to generate the servo signals, so
+ *   they won't be available to use.
+ */
+bool_t servoConfig( servoMap_t servoNumber, servoConfig_t config ){
+
+   bool_t ret_val = 1;
+
+   switch(config){
+
+      case SERVO_ENABLE:
+         servoInitTimers();
+      break;
+
+      case SERVO_DISABLE:
+         ret_val = 0;
+      break;
+
+      case SERVO_ENABLE_OUTPUT:
+         ret_val = servoAttach( servoNumber );
+      break;
+
+      case SERVO_DISABLE_OUTPUT:
+         ret_val = servoDetach( servoNumber );
+      break;
+
+      default:
+         ret_val = 0;
+      break;
+   }
+
+   return ret_val;
+}
+
+/*
+ * @brief:   Tells if the servo is currently active, and its position
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return:   position (1 ~ SERVO_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t servoIsAttached( servoMap_t servoNumber ){
+
+   uint8_t position = 0, positionInList = 0;
+   while ( (position < SERVO_TOTALNUMBER) &&
+           (servoNumber != AttachedServoList[position].servo) ){
+      position++;
+   }
+
+   if (position < SERVO_TOTALNUMBER){
+      positionInList = position + 1;
+   } else{
+      positionInList = 0;
+   }
+
+   return positionInList;
+}
+
+/*
+ * @brief: read the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @return: value of the servo (0 ~ 180).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint16_t servoRead( servoMap_t servoNumber){
+
+   uint8_t position = 0, value = 0;
+   position = servoIsAttached(servoNumber);
+
+   if(position){
+      value = AttachedServoList[position-1].value;
+   }
+   else{
+      value = EMPTY_POSITION;
+   }
+   return value;
+}
+
+/*
+ * @brief: change the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return: True if the value was successfully changed, False if not.
+ */
+bool_t servoWrite( servoMap_t servoNumber, uint16_t angle ){
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = servoIsAttached(servoNumber);
+
+   if(position && (angle>=0 && angle<=180)){
+      AttachedServoList[position-1].value = angle;
+      success = TRUE;
+   }
+
+   return success;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_sleep.c ./sapi/src/sapi_sleep.c
--- a_qSC69Z/sapi/src/sapi_sleep.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_sleep.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,66 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-08-15 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_sleep.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief: Sleep mode, sleep until next interrupt occur.
+ * @param  nothing
+ * @return nothing
+ */
+void sleepUntilNextInterrupt( void ){
+
+   /* Instert an assembly instruction wfi (wait for interrupt) */
+   __asm volatile( "wfi" );
+
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_spi.c ./sapi/src/sapi_spi.c
--- a_qSC69Z/sapi/src/sapi_spi.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_spi.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,79 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/** @brief Brief for this file.
+ **
+ **/
+
+/** \addtogroup groupName Group Name
+ ** @{ */
+
+/*
+ * Initials     Name
+ * ---------------------------
+ * ENP          Eric Pernia
+ *
+ *  */
+
+/*
+ * modification history (new versions first)
+ * -----------------------------------------------------------
+ * 2016-05-02   v0.0.1   ENP   First version
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_spi.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+
+
+/*==================[ISR external functions definition]======================*/
+
+
+
+/** @} doxygen end group definition */
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_tick.c ./sapi/src/sapi_tick.c
--- a_qSC69Z/sapi/src/sapi_tick.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_tick.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,116 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_tick.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/* This global variable holds the tick count */
+volatile tick_t tickCounter;
+volatile tick_t tickRateMS;
+volatile sAPI_FuncPtr_t tickHookFunction = sAPI_NullFuncPtr;
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* Tick rate configuration 1 to 50 ms */
+bool_t tickConfig(tick_t tickRateMSvalue, sAPI_FuncPtr_t tickHook ) {
+
+   bool_t ret_val = 1;
+   tick_t tickRateHz = 0;
+
+   if( tickHook ){
+      tickHookFunction = tickHook;
+   }
+
+   if( (tickRateMSvalue >= 1) && (tickRateMSvalue <= 50) ){
+
+		tickRateMS = tickRateMSvalue;
+
+      /*
+      tickRateHz = 1000 => 1000 ticks per second =>  1 ms tick
+      tickRateHz =  200 =>  200 ticks per second =>  5 ms tick
+      tickRateHz =  100 =>  100 ticks per second => 10 ms tick
+      tickRateHz =   20 =>   20 ticks per second => 50 ms tick
+      */
+      tickRateHz = 1000 / tickRateMSvalue;
+
+      /* Init SysTick interrupt, tickRateHz ticks per second */
+      SysTick_Config( SystemCoreClock / tickRateHz);
+   }
+   else{
+      /* Error, tickRateMS variable not in range (1 <= tickRateMS <= 50) */
+      ret_val = 0;
+   }
+
+   return ret_val;
+}
+
+
+/* Read Tick Counter */
+tick_t tickRead( void ) {
+   return tickCounter;
+}
+
+
+/* Write Tick Counter */
+void tickWrite( tick_t ticks ) {
+   tickCounter = ticks;
+}
+
+/*==================[ISR external functions definition]======================*/
+
+//__attribute__ ((section(".after_vectors")))
+
+/* SysTick Timer ISR Handler */
+void SysTick_Handler(void) {
+   tickCounter++;
+
+	/* Execute Tick Hook function */
+	(* tickHookFunction )( 0 );
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_timer.c ./sapi/src/sapi_timer.c
--- a_qSC69Z/sapi/src/sapi_timer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_timer.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,289 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/*
+ * For more information about the Timer peripheral, refer to the Chapter 32 of
+ * the LPC43xx user manual
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_timer.h"
+
+//#include "chip.h"
+//#include "timer_18xx_43xx.h"
+/* Specific modules used:
+   #include "timer_18xx_43xx.h" for Chip_TIMER functions
+   #include "rgu_18xx_43xx.h" for Chip_RGU functions
+   #include "core_cm4.h" for NVIC functions
+*/
+
+/*==================[macros and definitions]=================================*/
+
+#define LPC4337_MAX_FREC 204000000 /* Microcontroller frequency */
+#define MAX_SYSCALL_INTERRUPT_PRIORITY 5
+
+/*==================[internal data declaration]==============================*/
+
+typedef struct{
+   LPC_TIMER_T *name;
+   uint32_t RGU; /* Reset Generator Unit */
+   uint32_t IRQn;
+} timerStaticData_t;
+
+typedef struct{
+   voidFunctionPointer_t timerCompareMatchFunctionPointer[4];
+} timerDinamicData_t;
+
+/*==================[internal functions declaration]=========================*/
+
+static void errorOcurred(void);
+static void doNothing(void);
+
+/*==================[internal data definition]===============================*/
+
+/*Timers Static Data, given by the uC libraries*/
+static const timerStaticData_t timer_sd[4] = {
+   { LPC_TIMER0, RGU_TIMER0_RST, TIMER0_IRQn },
+   { LPC_TIMER1, RGU_TIMER1_RST, TIMER1_IRQn },
+   { LPC_TIMER2, RGU_TIMER2_RST, TIMER2_IRQn },
+   { LPC_TIMER3, RGU_TIMER3_RST, TIMER3_IRQn }
+};
+
+/*Timers dynamic data. Function pointers and Compare match frequencies, which can vary.
+ * This is the default initialization*/
+static timerDinamicData_t timer_dd[4] = {
+   {doNothing,errorOcurred,errorOcurred,errorOcurred},
+   {doNothing,errorOcurred,errorOcurred,errorOcurred},
+   {doNothing,errorOcurred,errorOcurred,errorOcurred},
+   {doNothing,errorOcurred,errorOcurred,errorOcurred}
+};
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/* Causes:
+ * User forgot to initialize the functions for the compare match interrupt on Timer_init call
+ */
+static void errorOcurred(void){
+   while(1);
+}
+
+static void doNothing(void){
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief   Initialize Timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   ticks:   Number of ticks required to finish the cycle.
+ * @param   voidFunctionPointer:   function to be executed at the end of the timer cycle
+ * @return   nothing
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_Init( uint8_t timerNumber, uint32_t ticks,
+                 voidFunctionPointer_t voidFunctionPointer){
+   /* Source:
+   http://docs.lpcware.com/lpcopen/v1.03/lpc18xx__43xx_2examples_2periph_2periph__blinky_2blinky_8c_source.html */
+
+   /*If timer period = CompareMatch0 Period = 0 => ERROR*/
+   if (ticks==0){
+      errorOcurred();
+   }
+
+   /* Enable timer clock and reset it */
+   Chip_TIMER_Init(timer_sd[timerNumber].name);
+   Chip_RGU_TriggerReset(timer_sd[timerNumber].RGU);
+   while (Chip_RGU_InReset(timer_sd[timerNumber].RGU)) {}
+   Chip_TIMER_Reset(timer_sd[timerNumber].name);
+
+   /* Update the defalut function pointer name of the Compare match 0*/
+   timer_dd[timerNumber].timerCompareMatchFunctionPointer[TIMERCOMPAREMATCH0] = voidFunctionPointer;
+
+   /* Initialize compare match with the specified ticks (number of counts needed to clear the match counter) */
+   Chip_TIMER_MatchEnableInt(timer_sd[timerNumber].name, TIMERCOMPAREMATCH0);
+   Chip_TIMER_SetMatch(timer_sd[timerNumber].name, TIMERCOMPAREMATCH0, ticks);
+
+   /* Makes Timer Match 0 period the timer period*/
+   Chip_TIMER_ResetOnMatchEnable(timer_sd[timerNumber].name, TIMERCOMPAREMATCH0);
+
+   /*Enable timer*/
+   Chip_TIMER_Enable(timer_sd[timerNumber].name);
+
+   /* Enable timer interrupt */
+   NVIC_SetPriority(timer_sd[timerNumber].IRQn, MAX_SYSCALL_INTERRUPT_PRIORITY+1);
+   NVIC_EnableIRQ(timer_sd[timerNumber].IRQn);
+   NVIC_ClearPendingIRQ(timer_sd[timerNumber].IRQn);
+}
+
+/*
+ * @Brief   Disables timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @return   nothing
+ */
+void Timer_DeInit(uint8_t timerNumber){
+   NVIC_DisableIRQ(timer_sd[timerNumber].IRQn);
+   Chip_TIMER_Disable(timer_sd[timerNumber].name);
+   Chip_TIMER_DeInit(timer_sd[timerNumber].name);
+}
+
+/*
+ * @Brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   uS:   Value in microseconds
+ * @return   Equivalent in Ticks for the LPC4337
+ * @note   Can be used for the second parameter in the Timer_init
+ */
+uint32_t Timer_microsecondsToTicks(uint32_t uS){
+   return (uS*(LPC4337_MAX_FREC/1000000));
+}
+
+/*
+ * @Brief   Enables a compare match in a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @param   ticks:   Number of ticks required to reach the compare match.
+ * @param   voidFunctionPointer: function to be executed when the compare match is reached
+ * @return   None
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_EnableCompareMatch( uint8_t timerNumber, uint8_t compareMatchNumber,
+                               uint32_t ticks,
+                               voidFunctionPointer_t voidFunctionPointer){
+
+   timer_dd[timerNumber].timerCompareMatchFunctionPointer[compareMatchNumber] = voidFunctionPointer;
+
+   Chip_TIMER_MatchEnableInt(timer_sd[timerNumber].name, compareMatchNumber);
+   Chip_TIMER_SetMatch(timer_sd[timerNumber].name, compareMatchNumber, ticks);
+}
+
+/*
+ * @brief   Disables a compare match of a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @return   None
+ */
+void Timer_DisableCompareMatch( uint8_t timerNumber,
+                                uint8_t compareMatchNumber ){
+
+   timer_dd[timerNumber].timerCompareMatchFunctionPointer[compareMatchNumber] = errorOcurred;
+
+   Chip_TIMER_ClearMatch(timer_sd[timerNumber].name, compareMatchNumber);
+   Chip_TIMER_MatchDisableInt(timer_sd[timerNumber].name, compareMatchNumber);
+}
+
+/*
+ * @Purpose:   Allows the user to change the compare value nÂº
+ *    'compareMatchNumber' of timer 'timerNumber'.  This is specially useful to
+ *    generate square waves if used in the function for the TIMERCOMPAREMATCH0
+ *    (because that compare match resets the timer counter), which will be
+ *    passed as a parameter when initializing a timer
+ * @note:  The selected time (3rd parameter) must be less than
+ *    TIMERCOMPAREMATCH0's compareMatchTime_uS for the compare match to make the
+ *    interruption
+ */
+void Timer_SetCompareMatch( uint8_t timerNumber,
+                            uint8_t compareMatchNumber,
+                            uint32_t ticks){
+   Chip_TIMER_SetMatch(timer_sd[timerNumber].name, compareMatchNumber,ticks);
+}
+
+/*==================[ISR external functions definition]======================*/
+/*
+ * @Brief:   Executes the functions passed by parameter in the Timer_init,
+ *   at the chosen frequencies
+ */
+void TIMER0_IRQHandler(void){
+
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ){
+      if( Chip_TIMER_MatchPending(LPC_TIMER0, compareMatchNumber) ){
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER0].timerCompareMatchFunctionPointer[compareMatchNumber])();
+         Chip_TIMER_ClearMatch(LPC_TIMER0, compareMatchNumber);
+      }
+   }
+}
+
+void TIMER1_IRQHandler( void ){
+
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ){
+      if( Chip_TIMER_MatchPending(LPC_TIMER1, compareMatchNumber) ){
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER1].timerCompareMatchFunctionPointer[compareMatchNumber])();
+         Chip_TIMER_ClearMatch(LPC_TIMER1, compareMatchNumber);
+      }
+   }
+}
+
+void TIMER2_IRQHandler( void ){
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ){
+      if( Chip_TIMER_MatchPending(LPC_TIMER2, compareMatchNumber) ){
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER2].timerCompareMatchFunctionPointer[compareMatchNumber])();
+         Chip_TIMER_ClearMatch(LPC_TIMER2, compareMatchNumber);
+      }
+   }
+}
+
+/*fixme __attribute__ ((section(".after_vectors")))*/
+void TIMER3_IRQHandler( void ){
+
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ){
+      if (Chip_TIMER_MatchPending(LPC_TIMER3, compareMatchNumber)){
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER3].timerCompareMatchFunctionPointer[compareMatchNumber])();
+         Chip_TIMER_ClearMatch(LPC_TIMER3, compareMatchNumber);
+      }
+   }
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_qSC69Z/sapi/src/sapi_uart.c ./sapi/src/sapi_uart.c
--- a_qSC69Z/sapi/src/sapi_uart.c	1969-12-31 21:00:00.000000000 -0300
+++ ./sapi/src/sapi_uart.c	2018-01-19 23:55:11.020319373 -0300
@@ -0,0 +1,249 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-26 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_uart.h"
+
+#include "string.h"
+
+/*==================[macros]=================================================*/
+
+#define UART_485_LPC LPC_USART0  /* UART0 (RS485/Profibus) */
+#define UART_USB_LPC LPC_USART2  /* UART2 (USB-UART) */
+#define UART_232_LPC LPC_USART3  /* UART3 (RS232) */
+
+/*==================[typedef]================================================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+waitForReceiveStringOrTimeoutState_t waitForReceiveStringOrTimeout(
+   uartMap_t uart, waitForReceiveStringOrTimeout_t* instance ){
+
+   uint8_t receiveByte;
+
+   switch( instance->state ){
+
+      case UART_RECEIVE_STRING_CONFIG:
+
+         delayConfig( &(instance->delay), instance->timeout );
+
+         instance->stringIndex = 0;
+
+         instance->state = UART_RECEIVE_STRING_RECEIVING;
+
+      break;
+
+      case UART_RECEIVE_STRING_RECEIVING:
+
+         if( uartReadByte( uart, &receiveByte ) ){
+
+            // TODO: DEBUG
+            uartWriteByte( UART_USB, receiveByte );
+
+            if( (instance->string)[(instance->stringIndex)] == receiveByte ){
+
+               (instance->stringIndex)++;
+
+               if( (instance->stringIndex) == (instance->stringSize - 1) ){
+                  instance->state = UART_RECEIVE_STRING_RECEIVED_OK;
+               }
+
+            }
+
+         }
+
+         if( delayRead( &(instance->delay) ) ){
+            instance->state = UART_RECEIVE_STRING_TIMEOUT;
+         }
+
+      break;
+
+      case UART_RECEIVE_STRING_RECEIVED_OK:
+         instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+      case UART_RECEIVE_STRING_TIMEOUT:
+         instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+      default:
+         instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+   }
+
+   return instance->state;
+}
+
+
+
+bool_t waitForReceiveStringOrTimeoutBlocking(
+   uartMap_t uart, char* string, uint16_t stringSize, tick_t timeout ){
+
+   bool_t retVal = TRUE; // True if OK
+
+   waitForReceiveStringOrTimeout_t waitText;
+   waitForReceiveStringOrTimeoutState_t waitTextState;
+
+   waitTextState = UART_RECEIVE_STRING_CONFIG;
+
+   waitText.state = UART_RECEIVE_STRING_CONFIG;
+   waitText.string =  string;
+   waitText.stringSize = stringSize;
+   waitText.timeout = timeout;
+
+   while( waitTextState != UART_RECEIVE_STRING_RECEIVED_OK &&
+          waitTextState != UART_RECEIVE_STRING_TIMEOUT ){
+      waitTextState = waitForReceiveStringOrTimeout( uart, &waitText );
+   }
+
+   if( waitTextState == UART_RECEIVE_STRING_TIMEOUT ){
+      retVal = FALSE;
+   }
+
+   return retVal;
+}
+
+
+void uartConfig( uartMap_t uart, uint32_t baudRate ){
+   switch(uart){
+   case UART_USB:
+      Chip_UART_Init(UART_USB_LPC);
+      Chip_UART_SetBaud(UART_USB_LPC, baudRate);  /* Set Baud rate */
+      Chip_UART_SetupFIFOS(UART_USB_LPC, UART_FCR_FIFO_EN | UART_FCR_TRG_LEV0); /* Modify FCR (FIFO Control Register)*/
+      Chip_UART_TXEnable(UART_USB_LPC); /* Enable UART Transmission */
+      Chip_SCU_PinMux(7, 1, MD_PDN, FUNC6);              /* P7_1,FUNC6: UART2_TXD */
+      Chip_SCU_PinMux(7, 2, MD_PLN|MD_EZI|MD_ZI, FUNC6); /* P7_2,FUNC6: UART2_RXD */
+
+      //Enable UART Rx Interrupt
+      //   Chip_UART_IntEnable(UART_USB_LPC,UART_IER_RBRINT );   //Receiver Buffer Register Interrupt
+      // Enable UART line status interrupt
+      //   Chip_UART_IntEnable(UART_USB_LPC,UART_IER_RLSINT ); //LPC43xx User manual page 1118
+      //   NVIC_SetPriority(USART2_IRQn, 6);
+      // Enable Interrupt for UART channel
+      //   NVIC_EnableIRQ(USART2_IRQn);
+   break;
+   case UART_232:
+      Chip_UART_Init(UART_232_LPC);
+      Chip_UART_SetBaud(UART_232_LPC, baudRate);  /* Set Baud rate */
+      Chip_UART_SetupFIFOS(UART_232_LPC, UART_FCR_FIFO_EN | UART_FCR_TRG_LEV0); /* Modify FCR (FIFO Control Register)*/
+      Chip_UART_TXEnable(UART_232_LPC); /* Enable UART Transmission */
+      Chip_SCU_PinMux(2, 3, MD_PDN, FUNC2);              /* P2_3,FUNC2: UART3_TXD */
+      Chip_SCU_PinMux(2, 4, MD_PLN|MD_EZI|MD_ZI, FUNC2); /* P2_4,FUNC2: UART3_RXD */
+   break;
+   case UART_485:
+
+   break;
+   }
+}
+
+
+bool_t uartReadByte( uartMap_t uart, uint8_t* receivedByte ){
+
+   bool_t retVal = TRUE;
+
+   switch(uart){
+   case UART_USB:
+      if ( Chip_UART_ReadLineStatus(UART_USB_LPC) & UART_LSR_RDR ) {
+         *receivedByte = Chip_UART_ReadByte(UART_USB_LPC);
+      } else{
+         retVal = FALSE;
+      }
+   break;
+   case UART_232:
+      if ( Chip_UART_ReadLineStatus(UART_232_LPC) & UART_LSR_RDR ) {
+         *receivedByte = Chip_UART_ReadByte(UART_232_LPC);
+      } else{
+         retVal = FALSE;
+      }
+   break;
+   case UART_485:
+   break;
+   }
+
+   return retVal;
+}
+
+
+void uartWriteByte( uartMap_t uart, uint8_t byte ){
+
+   switch(uart){
+   case UART_USB:
+      while ((Chip_UART_ReadLineStatus(UART_USB_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
+      Chip_UART_SendByte(UART_USB_LPC, byte);
+   break;
+   case UART_232:
+      while ((Chip_UART_ReadLineStatus(UART_232_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
+      Chip_UART_SendByte(UART_232_LPC, byte);
+   break;
+   case UART_485:
+   break;
+   }
+}
+
+
+void uartWriteString( uartMap_t uart, char* str ){
+   while(*str != 0){
+	  uartWriteByte( uart, (uint8_t)*str );
+	  str++;
+   }
+}
+
+/*==================[ISR external functions definition]======================*/
+
+__attribute__ ((section(".after_vectors")))
+
+/* 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24) */
+void UART0_IRQHandler(void){
+}
+
+/* 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26) */
+void UART2_IRQHandler(void){
+}
+
+/* 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27) */
+void UART3_IRQHandler(void){
+   //if (Chip_UART_ReadLineStatus(UART_232) & UART_LSR_RDR) {
+//      receivedByte = Chip_UART_ReadByte(UART_232);
+   //}
+}
+
+/*==================[end of file]============================================*/
