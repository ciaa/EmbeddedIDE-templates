<h1 style="margin: 0; padding: 0; text-align: center;">CAPSE 6Co 2019: EDU-CIAA-NXP</h1>
<h2 style="margin: 0; padding: 0; text-align: center;">con bibliotecas LPCOpen, sAPI y FreeRTOS</h2>
<h3 style="color: blue;">por Eric Pernia y Martin Ribelotta</h3>
<p>Esta plantilla incluye:</p>
<ul>
   <li>Ejemplo basico de programa en C.</li>
   <li> Bibliotecas:
      <ul>
         <li>LPCOpen v3.01</li>
         <li>sAPI v0.5.1+</li>
         <li>FreeRTOS Kernel V10.0.1</li>
         <li>Elm-Chan FatFS (SSP y USB)</li>
      </ul>
   </li>
   <li>
      openocd.cfg, un script para OpenOCD con el microcontrolador LPC4337 y el debugger FTDI FT2232.
   </li>
</ul>
<p>Placas soportadas:</p>
<ul>
   <li>CIAA-NXP (LPC4337)</li>
   <li>EDU-CIAA-NXP (LPC4337)</li>
</ul>
<p>Toolchain soportado:</p>
<ul>
   <li>gcc-arm-none-eabi</li>
</ul>
<p>A&ntilde;adir una nueva biblioteca:</p>
<p>La carpeta libs permite incluir 2 tipos de bibliotecas:</p>
<ul>
   <li>Biblioteca simple: consiste en una carpeta que incluye 2 subcarpetas llamadas src e inc. Se compila automaticamente por el Makefile.</li>
   <li>Biblioteca avanzada: estas consisten de una estructura complicada de directorios, se debe especificar un makefile. Ver el de sapai como ejemplo.</li>
</ul>
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/app/config.mk ./app/config.mk
--- a_bRU7kv/app/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./app/config.mk	2018-12-01 18:02:19.488743291 -0300
@@ -0,0 +1,20 @@
+# Compile options
+
+VERBOSE=n
+OPT=s
+USE_NANO=y
+SEMIHOST=n
+USE_FPU=y
+
+# Libraries
+
+USE_LPCOPEN=y
+USE_SAPI=y
+
+USE_FATFS_SSP=n
+USE_FATFS_USB=n
+
+USE_FREERTOS=n
+FREERTOS_HEAP_TYPE=5
+
+USE_RAM=n
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/app/inc/app.h ./app/inc/app.h
--- a_bRU7kv/app/inc/app.h	1969-12-31 21:00:00.000000000 -0300
+++ ./app/inc/app.h	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,32 @@
+/*============================================================================
+ * Licencia:
+ * Autor:
+ * Fecha:
+ *===========================================================================*/
+
+#ifndef _APP_H_
+#define _APP_H_
+
+/*==================[inclusiones]============================================*/
+
+/*==================[c++]====================================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[tipos de datos declarados por el usuario]===============*/
+
+/*==================[declaraciones de datos externos]========================*/
+
+/*==================[declaraciones de funciones externas]====================*/
+
+/*==================[c++]====================================================*/
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* _APP_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/app/src/app.c ./app/src/app.c
--- a_bRU7kv/app/src/app.c	1969-12-31 21:00:00.000000000 -0300
+++ ./app/src/app.c	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,77 @@
+/*============================================================================
+ * Autor:
+ * Licencia:
+ * Fecha:
+ *===========================================================================*/
+
+// Inlcusiones
+
+#include "app.h"         // <= Su propia cabecera
+#include "sapi.h"        // <= Biblioteca sAPI
+
+// FUNCION PRINCIPAL, PUNTO DE ENTRADA AL PROGRAMA LUEGO DE ENCENDIDO O RESET.
+int main( void )
+{
+   // ---------- CONFIGURACIONES ------------------------------
+
+   // Inicializar y configurar la plataforma
+   boardConfig();
+
+   // Crear varias variables del tipo booleano
+   bool_t buttonValue = OFF;
+   bool_t ledValue    = OFF;
+   // Crear variable del tipo tick_t para contar tiempo
+   tick_t timeCount   = 0;
+
+   // ---------- REPETIR POR SIEMPRE --------------------------
+   while( TRUE ) {
+
+      /* Retardo bloqueante durante 100ms */
+      
+      delay( 100 );
+      
+      /* Si pasaron 10 segundos comienza a funcionar el programa que copia las
+         acciones en BOTON al LED. Mientras espera titila el LED.  */
+      
+      timeCount++;      
+      
+      if( timeCount == 100 ){ // 100ms * 100 = 10s
+         
+         while( TRUE ) {
+            
+            /* Si se presiona CIAA_BOARD_BUTTON, enciende el CIAA_BOARD_LED */
+
+            // Leer pin conectado al boton.
+            buttonValue = gpioRead( CIAA_BOARD_BUTTON );
+            // Invertir el valor leido, pues lee un 0 (OFF) con boton
+            // presionado y 1 (ON) al liberarla.
+            buttonValue = !buttonValue;
+            // Escribir el valor leido en el LED correspondiente.
+            gpioWrite( CIAA_BOARD_LED, buttonValue );
+
+            /* Enviar a la salida estandar (UART_DEBUG) el estado del LED */
+            
+            // Leer el estado del pin conectado al led
+            ledValue = gpioRead( CIAA_BOARD_LED );
+            // Chequear si el valor leido es encedido
+            if( ledValue == ON ) {
+               // Si esta encendido mostrar por UART_USB "LED encendido."
+               printf( "LED encendido.\r\n" );
+            } else {
+               // Si esta apagado mostrar por UART_USB "LED apagado."
+               printf( "LED apagado.\r\n" );
+            }
+            delay( 250 );
+            
+         }
+      } else {
+         // Intercambiar el valor de CIAA_BOARD_LED
+         gpioToggle(CIAA_BOARD_LED);
+      }
+   }
+
+   // NO DEBE LLEGAR NUNCA AQUI, debido a que a este programa se ejecuta
+   // directamenteno sobre un microcontroladore y no es llamado por ningun
+   // Sistema Operativo, como en el caso de un programa para PC.
+   return 0;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/diskio.h ./libs/elm-chan-FatFs/fatfs_ssp/inc/diskio.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/diskio.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/inc/diskio.h	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,88 @@
+/*-----------------------------------------------------------------------
+/  Low level disk interface modlue include file   (C)ChaN, 2012
+/-----------------------------------------------------------------------*/
+
+#ifndef _DISKIO_DEFINED
+#define _DISKIO_DEFINED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _USE_WRITE	1	/* 1: Enable disk_write function */
+#define _USE_IOCTL	1	/* 1: Enable disk_ioctl fucntion */
+
+#include "integer.h"
+
+
+/* Status of Disk Functions */
+typedef BYTE	DSTATUS;
+
+/* Results of Disk Functions */
+typedef enum {
+	RES_OK = 0,		/* 0: Successful */
+	RES_ERROR,		/* 1: R/W Error */
+	RES_WRPRT,		/* 2: Write Protected */
+	RES_NOTRDY,		/* 3: Not Ready */
+	RES_PARERR		/* 4: Invalid Parameter */
+} DRESULT;
+
+
+/*---------------------------------------*/
+/* Prototypes for disk control functions */
+
+
+DSTATUS disk_initialize (BYTE);
+DSTATUS disk_status (BYTE);
+DRESULT disk_read (BYTE, BYTE*, DWORD, UINT);
+DRESULT disk_write (BYTE, const BYTE*, DWORD, UINT);
+DRESULT disk_ioctl (BYTE, BYTE, void*);
+
+
+/* Disk Status Bits (DSTATUS) */
+#define STA_NOINIT		0x01	/* Drive not initialized */
+#define STA_NODISK		0x02	/* No medium in the drive */
+#define STA_PROTECT		0x04	/* Write protected */
+
+
+/* Command code for disk_ioctrl fucntion */
+
+/* Generic command (used by FatFs) */
+#define CTRL_SYNC			0	/* Flush disk cache (for write functions) */
+#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
+#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
+#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
+#define CTRL_ERASE_SECTOR	4	/* Force erased a block of sectors (for only _USE_ERASE) */
+
+/* Generic command (not used by FatFs) */
+#define CTRL_POWER			5	/* Get/Set power status */
+#define CTRL_LOCK			6	/* Lock/Unlock media removal */
+#define CTRL_EJECT			7	/* Eject media */
+#define CTRL_FORMAT			8	/* Create physical format on the media */
+
+/* MMC/SDC specific ioctl command */
+#define MMC_GET_TYPE		10	/* Get card type */
+#define MMC_GET_CSD			11	/* Get CSD */
+#define MMC_GET_CID			12	/* Get CID */
+#define MMC_GET_OCR			13	/* Get OCR */
+#define MMC_GET_SDSTAT		14	/* Get SD status */
+
+/* ATA/CF specific ioctl command */
+#define ATA_GET_REV			20	/* Get F/W revision */
+#define ATA_GET_MODEL		21	/* Get model name */
+#define ATA_GET_SN			22	/* Get serial number */
+
+
+/* MMC card type flags (MMC_GET_TYPE) */
+#define CT_MMC		0x01		/* MMC ver 3 */
+#define CT_SD1		0x02		/* SD ver 1 */
+#define CT_SD2		0x04		/* SD ver 2 */
+#define CT_SDC		(CT_SD1|CT_SD2)	/* SD */
+#define CT_BLOCK	0x08		/* Block addressing */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/ffconf.h ./libs/elm-chan-FatFs/fatfs_ssp/inc/ffconf.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/ffconf.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/inc/ffconf.h	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,265 @@
+/*---------------------------------------------------------------------------/
+/  FatFs - FAT file system module configuration file
+/---------------------------------------------------------------------------*/
+
+#define _FFCONF 80186	/* Revision ID */
+
+/*---------------------------------------------------------------------------/
+/ Function Configurations
+/---------------------------------------------------------------------------*/
+
+#define _FS_READONLY	0
+/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
+/  Read-only configuration removes writing API functions, f_write(), f_sync(),
+/  f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(), f_getfree()
+/  and optional writing functions as well. */
+
+
+#define _FS_MINIMIZE	0
+/* This option defines minimization level to remove some basic API functions.
+/
+/   0: All basic functions are enabled.
+/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename()
+/      are removed.
+/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
+/   3: f_lseek() function is removed in addition to 2. */
+
+
+#define	_USE_STRFUNC	0
+/* This option switches string functions, f_gets(), f_putc(), f_puts() and
+/  f_printf().
+/
+/  0: Disable string functions.
+/  1: Enable without LF-CRLF conversion.
+/  2: Enable with LF-CRLF conversion. */
+
+
+#define _USE_FIND		0
+/* This option switches filtered directory read functions, f_findfirst() and
+/  f_findnext(). (0:Disable, 1:Enable 2:Enable with matching altname[] too) */
+
+
+#define	_USE_MKFS		0
+/* This option switches f_mkfs() function. (0:Disable or 1:Enable) */
+
+
+#define	_USE_FASTSEEK	0
+/* This option switches fast seek function. (0:Disable or 1:Enable) */
+
+
+#define	_USE_EXPAND		0
+/* This option switches f_expand function. (0:Disable or 1:Enable) */
+
+
+#define _USE_CHMOD		0
+/* This option switches attribute manipulation functions, f_chmod() and f_utime().
+/  (0:Disable or 1:Enable) Also _FS_READONLY needs to be 0 to enable this option. */
+
+
+#define _USE_LABEL		0
+/* This option switches volume label functions, f_getlabel() and f_setlabel().
+/  (0:Disable or 1:Enable) */
+
+
+#define	_USE_FORWARD	0
+/* This option switches f_forward() function. (0:Disable or 1:Enable) */
+
+
+/*---------------------------------------------------------------------------/
+/ Locale and Namespace Configurations
+/---------------------------------------------------------------------------*/
+
+#define _CODE_PAGE	1
+/* This option specifies the OEM code page to be used on the target system.
+/  Incorrect setting of the code page can cause a file open failure.
+/
+/   1   - ASCII (No extended character. Non-LFN cfg. only)
+/   437 - U.S.
+/   720 - Arabic
+/   737 - Greek
+/   771 - KBL
+/   775 - Baltic
+/   850 - Latin 1
+/   852 - Latin 2
+/   855 - Cyrillic
+/   857 - Turkish
+/   860 - Portuguese
+/   861 - Icelandic
+/   862 - Hebrew
+/   863 - Canadian French
+/   864 - Arabic
+/   865 - Nordic
+/   866 - Russian
+/   869 - Greek 2
+/   932 - Japanese (DBCS)
+/   936 - Simplified Chinese (DBCS)
+/   949 - Korean (DBCS)
+/   950 - Traditional Chinese (DBCS)
+*/
+
+
+#define	_USE_LFN	0
+#define	_MAX_LFN	255
+/* The _USE_LFN switches the support of long file name (LFN).
+/
+/   0: Disable support of LFN. _MAX_LFN has no effect.
+/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
+/   2: Enable LFN with dynamic working buffer on the STACK.
+/   3: Enable LFN with dynamic working buffer on the HEAP.
+/
+/  To enable the LFN, Unicode handling functions (option/unicode.c) must be added
+/  to the project. The working buffer occupies (_MAX_LFN + 1) * 2 bytes and
+/  additional 608 bytes at exFAT enabled. _MAX_LFN can be in range from 12 to 255.
+/  It should be set 255 to support full featured LFN operations.
+/  When use stack for the working buffer, take care on stack overflow. When use heap
+/  memory for the working buffer, memory management functions, ff_memalloc() and
+/  ff_memfree(), must be added to the project. */
+
+
+#define	_LFN_UNICODE	0
+/* This option switches character encoding on the API. (0:ANSI/OEM or 1:UTF-16)
+/  To use Unicode string for the path name, enable LFN and set _LFN_UNICODE = 1.
+/  This option also affects behavior of string I/O functions. */
+
+
+#define _STRF_ENCODE	3
+/* When _LFN_UNICODE == 1, this option selects the character encoding ON THE FILE to
+/  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
+/
+/  0: ANSI/OEM
+/  1: UTF-16LE
+/  2: UTF-16BE
+/  3: UTF-8
+/
+/  This option has no effect when _LFN_UNICODE == 0. */
+
+
+#define _FS_RPATH	0
+/* This option configures support of relative path.
+/
+/   0: Disable relative path and remove related functions.
+/   1: Enable relative path. f_chdir() and f_chdrive() are available.
+/   2: f_getcwd() function is available in addition to 1.
+*/
+
+
+/*---------------------------------------------------------------------------/
+/ Drive/Volume Configurations
+/---------------------------------------------------------------------------*/
+
+#define _VOLUMES	1
+/* Number of volumes (logical drives) to be used. */
+
+
+#define _STR_VOLUME_ID	0
+#define _VOLUME_STRS	"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"
+/* _STR_VOLUME_ID switches string support of volume ID.
+/  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
+/  number in the path name. _VOLUME_STRS defines the drive ID strings for each
+/  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
+/  the drive ID strings are: A-Z and 0-9. */
+
+
+#define	_MULTI_PARTITION	0
+/* This option switches support of multi-partition on a physical drive.
+/  By default (0), each logical drive number is bound to the same physical drive
+/  number and only an FAT volume found on the physical drive will be mounted.
+/  When multi-partition is enabled (1), each logical drive number can be bound to
+/  arbitrary physical drive and partition listed in the VolToPart[]. Also f_fdisk()
+/  funciton will be available. */
+
+
+#define	_MIN_SS		512
+#define	_MAX_SS		512
+/* These options configure the range of sector size to be supported. (512, 1024,
+/  2048 or 4096) Always set both 512 for most systems, all type of memory cards and
+/  harddisk. But a larger value may be required for on-board flash memory and some
+/  type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured
+/  to variable sector size and GET_SECTOR_SIZE command must be implemented to the
+/  disk_ioctl() function. */
+
+
+#define	_USE_TRIM	0
+/* This option switches support of ATA-TRIM. (0:Disable or 1:Enable)
+/  To enable Trim function, also CTRL_TRIM command should be implemented to the
+/  disk_ioctl() function. */
+
+
+#define _FS_NOFSINFO	0
+/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
+/  option, and f_getfree() function at first time after volume mount will force
+/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
+/
+/  bit0=0: Use free cluster count in the FSINFO if available.
+/  bit0=1: Do not trust free cluster count in the FSINFO.
+/  bit1=0: Use last allocated cluster number in the FSINFO if available.
+/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
+*/
+
+
+
+/*---------------------------------------------------------------------------/
+/ System Configurations
+/---------------------------------------------------------------------------*/
+
+#define	_FS_TINY	0
+/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
+/  At the tiny configuration, size of the file object (FIL) is reduced _MAX_SS bytes.
+/  Instead of private sector buffer eliminated from the file object, common sector
+/  buffer in the file system object (FATFS) is used for the file data transfer. */
+
+
+#define _FS_EXFAT	0
+/* This option switches support of exFAT file system in addition to the traditional
+/  FAT file system. (0:Disable or 1:Enable) To enable exFAT, also LFN must be enabled.
+/  Note that enabling exFAT discards C89 compatibility. */
+
+
+#define _FS_NORTC	1
+#define _NORTC_MON	1
+#define _NORTC_MDAY	1
+#define _NORTC_YEAR	2016
+/* The option _FS_NORTC switches timestamp functiton. If the system does not have
+/  any RTC function or valid timestamp is not needed, set _FS_NORTC = 1 to disable
+/  the timestamp function. All objects modified by FatFs will have a fixed timestamp
+/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR in local time.
+/  To enable timestamp function (_FS_NORTC = 0), get_fattime() function need to be
+/  added to the project to get current time form real-time clock. _NORTC_MON,
+/  _NORTC_MDAY and _NORTC_YEAR have no effect. 
+/  These options have no effect at read-only configuration (_FS_READONLY = 1). */
+
+
+#define	_FS_LOCK	0
+/* The option _FS_LOCK switches file lock function to control duplicated file open
+/  and illegal operation to open objects. This option must be 0 when _FS_READONLY
+/  is 1.
+/
+/  0:  Disable file lock function. To avoid volume corruption, application program
+/      should avoid illegal open, remove and rename to the open objects.
+/  >0: Enable file lock function. The value defines how many files/sub-directories
+/      can be opened simultaneously under file lock control. Note that the file
+/      lock control is independent of re-entrancy. */
+
+
+#define _FS_REENTRANT	0
+#define _FS_TIMEOUT		1000
+#define	_SYNC_t			HANDLE
+/* The option _FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs
+/  module itself. Note that regardless of this option, file access to different
+/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
+/  and f_fdisk() function, are always not re-entrant. Only file/directory access
+/  to the same volume is under control of this function.
+/
+/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
+/   1: Enable re-entrancy. Also user provided synchronization handlers,
+/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
+/      function, must be added to the project. Samples are available in
+/      option/syscall.c.
+/
+/  The _FS_TIMEOUT defines timeout period in unit of time tick.
+/  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
+/  SemaphoreHandle_t and etc.. A header file for O/S definitions needs to be
+/  included somewhere in the scope of ff.c. */
+
+
+/*--- End of configuration options ---*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/ff.h ./libs/elm-chan-FatFs/fatfs_ssp/inc/ff.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/ff.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/inc/ff.h	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,366 @@
+/*----------------------------------------------------------------------------/
+/  FatFs - Generic FAT file system module  R0.12a                             /
+/-----------------------------------------------------------------------------/
+/
+/ Copyright (C) 2016, ChaN, all right reserved.
+/
+/ FatFs module is an open source software. Redistribution and use of FatFs in
+/ source and binary forms, with or without modification, are permitted provided
+/ that the following condition is met:
+
+/ 1. Redistributions of source code must retain the above copyright notice,
+/    this condition and the following disclaimer.
+/
+/ This software is provided by the copyright holder and contributors "AS IS"
+/ and any warranties related to this software are DISCLAIMED.
+/ The copyright owner or contributors be NOT LIABLE for any damages caused
+/ by use of this software.
+/----------------------------------------------------------------------------*/
+
+
+#ifndef _FATFS
+#define _FATFS	80186	/* Revision ID */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "integer.h"	/* Basic integer types */
+#include "ffconf.h"		/* FatFs configuration options */
+
+#if _FATFS != _FFCONF
+#error Wrong configuration file (ffconf.h).
+#endif
+
+
+
+/* Definitions of volume management */
+
+#if _MULTI_PARTITION		/* Multiple partition configuration */
+typedef struct {
+	BYTE pd;	/* Physical drive number */
+	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
+} PARTITION;
+extern PARTITION VolToPart[];	/* Volume - Partition resolution table */
+#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
+#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
+
+#else							/* Single partition configuration */
+#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
+#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
+
+#endif
+
+
+
+/* Type of path name strings on FatFs API */
+
+#if _LFN_UNICODE			/* Unicode (UTF-16) string */
+#if _USE_LFN == 0
+#error _LFN_UNICODE must be 0 at non-LFN cfg.
+#endif
+#ifndef _INC_TCHAR
+typedef WCHAR TCHAR;
+#define _T(x) L ## x
+#define _TEXT(x) L ## x
+#endif
+#else						/* ANSI/OEM string */
+#ifndef _INC_TCHAR
+typedef char TCHAR;
+#define _T(x) x
+#define _TEXT(x) x
+#endif
+#endif
+
+
+
+/* Type of file size variables */
+
+#if _FS_EXFAT
+#if _USE_LFN == 0
+#error LFN must be enabled when enable exFAT
+#endif
+typedef QWORD FSIZE_t;
+#else
+typedef DWORD FSIZE_t;
+#endif
+
+
+
+/* File system object structure (FATFS) */
+
+typedef struct {
+	BYTE	fs_type;		/* File system type (0:N/A) */
+	BYTE	drv;			/* Physical drive number */
+	BYTE	n_fats;			/* Number of FATs (1 or 2) */
+	BYTE	wflag;			/* win[] flag (b0:dirty) */
+	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
+	WORD	id;				/* File system mount ID */
+	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
+	WORD	csize;			/* Cluster size [sectors] */
+#if _MAX_SS != _MIN_SS
+	WORD	ssize;			/* Sector size (512, 1024, 2048 or 4096) */
+#endif
+#if _USE_LFN != 0
+	WCHAR*	lfnbuf;			/* LFN working buffer */
+#endif
+#if _FS_EXFAT
+	BYTE*	dirbuf;			/* Directory entry block scratchpad buffer */
+#endif
+#if _FS_REENTRANT
+	_SYNC_t	sobj;			/* Identifier of sync object */
+#endif
+#if !_FS_READONLY
+	DWORD	last_clst;		/* Last allocated cluster */
+	DWORD	free_clst;		/* Number of free clusters */
+#endif
+#if _FS_RPATH != 0
+	DWORD	cdir;			/* Current directory start cluster (0:root) */
+#if _FS_EXFAT
+	DWORD	cdc_scl;		/* Containing directory start cluster (invalid when cdir is 0) */
+	DWORD	cdc_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status */
+	DWORD	cdc_ofs;		/* Offset in the containing directory (invalid when cdir is 0) */
+#endif
+#endif
+	DWORD	n_fatent;		/* Number of FAT entries (number of clusters + 2) */
+	DWORD	fsize;			/* Size of an FAT [sectors] */
+	DWORD	volbase;		/* Volume base sector */
+	DWORD	fatbase;		/* FAT base sector */
+	DWORD	dirbase;		/* Root directory base sector/cluster */
+	DWORD	database;		/* Data base sector */
+	DWORD	winsect;		/* Current sector appearing in the win[] */
+	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
+} FATFS;
+
+
+
+/* Object ID and allocation information (_FDID) */
+
+typedef struct {
+	FATFS*	fs;			/* Pointer to the owner file system object */
+	WORD	id;			/* Owner file system mount ID */
+	BYTE	attr;		/* Object attribute */
+	BYTE	stat;		/* Object chain status (b1-0: =0:not contiguous, =2:contiguous (no data on FAT), =3:got flagmented, b2:sub-directory stretched) */
+	DWORD	sclust;		/* Object start cluster (0:no cluster or root directory) */
+	FSIZE_t	objsize;	/* Object size (valid when sclust != 0) */
+#if _FS_EXFAT
+	DWORD	n_cont;		/* Size of coutiguous part, clusters - 1 (valid when stat == 3) */
+	DWORD	c_scl;		/* Containing directory start cluster (valid when sclust != 0) */
+	DWORD	c_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status (valid when c_scl != 0) */
+	DWORD	c_ofs;		/* Offset in the containing directory (valid when sclust != 0) */
+#endif
+#if _FS_LOCK != 0
+	UINT	lockid;		/* File lock ID origin from 1 (index of file semaphore table Files[]) */
+#endif
+} _FDID;
+
+
+
+/* File object structure (FIL) */
+
+typedef struct {
+	_FDID	obj;			/* Object identifier */
+	BYTE	flag;			/* File status flags */
+	BYTE	err;			/* Abort flag (error code) */
+	FSIZE_t	fptr;			/* File read/write pointer (Zeroed on file open) */
+	DWORD	clust;			/* Current cluster of fpter (invalid when fprt is 0) */
+	DWORD	sect;			/* Sector number appearing in buf[] (0:invalid) */
+#if !_FS_READONLY
+	DWORD	dir_sect;		/* Sector number containing the directory entry */
+	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
+#endif
+#if _USE_FASTSEEK
+	DWORD*	cltbl;			/* Pointer to the cluster link map table (nulled on open, set by application) */
+#endif
+#if !_FS_TINY
+	BYTE	buf[_MAX_SS];	/* File private data read/write window */
+#endif
+} FIL;
+
+
+
+/* Directory object structure (DIR) */
+
+typedef struct {
+	_FDID	obj;			/* Object identifier */
+	DWORD	dptr;			/* Current read/write offset */
+	DWORD	clust;			/* Current cluster */
+	DWORD	sect;			/* Current sector */
+	BYTE*	dir;			/* Pointer to the directory item in the win[] */
+	BYTE	fn[12];			/* SFN (in/out) {body[8],ext[3],status[1]} */
+#if _USE_LFN != 0
+	DWORD	blk_ofs;		/* Offset of current entry block being processed (0xFFFFFFFF:Invalid) */
+#endif
+#if _USE_FIND
+	const TCHAR* pat;		/* Pointer to the name matching pattern */
+#endif
+} DIR;
+
+
+
+/* File information structure (FILINFO) */
+
+typedef struct {
+	FSIZE_t	fsize;			/* File size */
+	WORD	fdate;			/* Modified date */
+	WORD	ftime;			/* Modified time */
+	BYTE	fattrib;		/* File attribute */
+#if _USE_LFN != 0
+	TCHAR	altname[13];			/* Altenative file name */
+	TCHAR	fname[_MAX_LFN + 1];	/* Primary file name */
+#else
+	TCHAR	fname[13];		/* File name */
+#endif
+} FILINFO;
+
+
+
+/* File function return code (FRESULT) */
+
+typedef enum {
+	FR_OK = 0,				/* (0) Succeeded */
+	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
+	FR_INT_ERR,				/* (2) Assertion failed */
+	FR_NOT_READY,			/* (3) The physical drive cannot work */
+	FR_NO_FILE,				/* (4) Could not find the file */
+	FR_NO_PATH,				/* (5) Could not find the path */
+	FR_INVALID_NAME,		/* (6) The path name format is invalid */
+	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
+	FR_EXIST,				/* (8) Access denied due to prohibited access */
+	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
+	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
+	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
+	FR_NOT_ENABLED,			/* (12) The volume has no work area */
+	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
+	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any problem */
+	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
+	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
+	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
+	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
+	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
+} FRESULT;
+
+
+
+/*--------------------------------------------------------------*/
+/* FatFs module application interface                           */
+
+FRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
+FRESULT f_close (FIL* fp);											/* Close an open file object */
+FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from the file */
+FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to the file */
+FRESULT f_lseek (FIL* fp, FSIZE_t ofs);								/* Move file pointer of the file object */
+FRESULT f_truncate (FIL* fp);										/* Truncate the file */
+FRESULT f_sync (FIL* fp);											/* Flush cached data of the writing file */
+FRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
+FRESULT f_closedir (DIR* dp);										/* Close an open directory */
+FRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
+FRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);	/* Find first file */
+FRESULT f_findnext (DIR* dp, FILINFO* fno);							/* Find next file */
+FRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
+FRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
+FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
+FRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
+FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);			/* Change attribute of a file/dir */
+FRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change timestamp of a file/dir */
+FRESULT f_chdir (const TCHAR* path);								/* Change current directory */
+FRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
+FRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
+FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
+FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
+FRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
+FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
+FRESULT f_expand (FIL* fp, FSIZE_t szf, BYTE opt);					/* Allocate a contiguous block to the file */
+FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
+FRESULT f_mkfs (const TCHAR* path, BYTE opt, DWORD au, void* work, UINT len);	/* Create a FAT volume */
+FRESULT f_fdisk (BYTE pdrv, const DWORD* szt, void* work);			/* Divide a physical drive into some partitions */
+int f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
+int f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
+int f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
+TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
+
+#define f_eof(fp) ((int)((fp)->fptr == (fp)->obj.objsize))
+#define f_error(fp) ((fp)->err)
+#define f_tell(fp) ((fp)->fptr)
+#define f_size(fp) ((fp)->obj.objsize)
+#define f_rewind(fp) f_lseek((fp), 0)
+#define f_rewinddir(dp) f_readdir((dp), 0)
+
+#ifndef EOF
+#define EOF (-1)
+#endif
+
+
+
+
+/*--------------------------------------------------------------*/
+/* Additional user defined functions                            */
+
+/* RTC function */
+#if !_FS_READONLY && !_FS_NORTC
+DWORD get_fattime (void);
+#endif
+
+/* Unicode support functions */
+#if _USE_LFN != 0						/* Unicode - OEM code conversion */
+WCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
+WCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
+#if _USE_LFN == 3						/* Memory functions */
+void* ff_memalloc (UINT msize);			/* Allocate memory block */
+void ff_memfree (void* mblock);			/* Free memory block */
+#endif
+#endif
+
+/* Sync functions */
+#if _FS_REENTRANT
+int ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
+int ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
+void ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
+int ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
+#endif
+
+
+
+
+/*--------------------------------------------------------------*/
+/* Flags and offset address                                     */
+
+
+/* File access mode and open method flags (3rd argument of f_open) */
+#define	FA_READ				0x01
+#define	FA_WRITE			0x02
+#define	FA_OPEN_EXISTING	0x00
+#define	FA_CREATE_NEW		0x04
+#define	FA_CREATE_ALWAYS	0x08
+#define	FA_OPEN_ALWAYS		0x10
+#define	FA_OPEN_APPEND		0x30
+
+/* Fast seek controls (2nd argument of f_lseek) */
+#define CREATE_LINKMAP	((FSIZE_t)0 - 1)
+
+/* Format options (2nd argument of f_mkfs) */
+#define FM_FAT		0x01
+#define FM_FAT32	0x02
+#define FM_EXFAT	0x04
+#define FM_ANY		0x07
+#define FM_SFD		0x08
+
+/* Filesystem type (FATFS.fs_type) */
+#define FS_FAT12	1
+#define FS_FAT16	2
+#define FS_FAT32	3
+#define FS_EXFAT	4
+
+/* File attribute bits for directory entry (FILINFO.fattrib) */
+#define	AM_RDO	0x01	/* Read only */
+#define	AM_HID	0x02	/* Hidden */
+#define	AM_SYS	0x04	/* System */
+#define AM_DIR	0x10	/* Directory */
+#define AM_ARC	0x20	/* Archive */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FATFS */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/integer.h ./libs/elm-chan-FatFs/fatfs_ssp/inc/integer.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/integer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/inc/integer.h	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,38 @@
+/*-------------------------------------------*/
+/* Integer type definitions for FatFs module */
+/*-------------------------------------------*/
+
+#ifndef _FF_INTEGER
+#define _FF_INTEGER
+
+#ifdef _WIN32	/* FatFs development platform */
+
+#include <windows.h>
+#include <tchar.h>
+typedef unsigned __int64 QWORD;
+
+
+#else			/* Embedded platform */
+
+/* These types MUST be 16-bit or 32-bit */
+typedef int				INT;
+typedef unsigned int	UINT;
+
+/* This type MUST be 8-bit */
+typedef unsigned char	BYTE;
+
+/* These types MUST be 16-bit */
+typedef short			SHORT;
+typedef unsigned short	WORD;
+typedef unsigned short	WCHAR;
+
+/* These types MUST be 32-bit */
+typedef long			LONG;
+typedef unsigned long	DWORD;
+
+/* This type MUST be 64-bit (Remove this for C89 compatibility) */
+typedef unsigned long long QWORD;
+
+#endif
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/rtc.h ./libs/elm-chan-FatFs/fatfs_ssp/inc/rtc.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/inc/rtc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/inc/rtc.h	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,20 @@
+#ifndef _RTC_DEFINED
+#define _RTC_DEFINED
+
+#include "integer.h"
+
+typedef struct {
+	WORD	year;	/* 1..4095 */
+	BYTE	month;	/* 1..12 */
+	BYTE	mday;	/* 1.. 31 */
+	BYTE	wday;	/* 1..7 */
+	BYTE	hour;	/* 0..23 */
+	BYTE	min;	/* 0..59 */
+	BYTE	sec;	/* 0..59 */
+} RTC;
+
+int rtc_initialize (void);		/* Initialize RTC */
+int rtc_gettime (RTC*);			/* Get time */
+int rtc_settime (const RTC*);	/* Set time */
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/src/ff.c ./libs/elm-chan-FatFs/fatfs_ssp/src/ff.c
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/src/ff.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/src/ff.c	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,6032 @@
+/*----------------------------------------------------------------------------/
+/  FatFs - Generic FAT file system module  R0.12a                             /
+/-----------------------------------------------------------------------------/
+/
+/ Copyright (C) 2016, ChaN, all right reserved.
+/
+/ FatFs module is an open source software. Redistribution and use of FatFs in
+/ source and binary forms, with or without modification, are permitted provided
+/ that the following condition is met:
+
+/ 1. Redistributions of source code must retain the above copyright notice,
+/    this condition and the following disclaimer.
+/
+/ This software is provided by the copyright holder and contributors "AS IS"
+/ and any warranties related to this software are DISCLAIMED.
+/ The copyright owner or contributors be NOT LIABLE for any damages caused
+/ by use of this software.
+/----------------------------------------------------------------------------*/
+
+
+#include "ff.h"			/* Declarations of FatFs API */
+#include "diskio.h"		/* Declarations of device I/O functions */
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Definitions
+
+---------------------------------------------------------------------------*/
+
+#if _FATFS != 80186	/* Revision ID */
+#error Wrong include file (ff.h).
+#endif
+
+
+#define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
+
+
+/* Reentrancy related */
+#if _FS_REENTRANT
+#if _USE_LFN == 1
+#error Static LFN work area cannot be used at thread-safe configuration
+#endif
+#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
+#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
+#else
+#define	ENTER_FF(fs)
+#define LEAVE_FF(fs, res)	return res
+#endif
+
+
+
+/* Definitions of sector size */
+#if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
+#error Wrong sector size configuration
+#endif
+#if _MAX_SS == _MIN_SS
+#define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
+#else
+#define	SS(fs)	((fs)->ssize)	/* Variable sector size */
+#endif
+
+
+/* Timestamp */
+#if _FS_NORTC == 1
+#if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
+#error Invalid _FS_NORTC settings
+#endif
+#define GET_FATTIME()	((DWORD)(_NORTC_YEAR - 1980) << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
+#else
+#define GET_FATTIME()	get_fattime()
+#endif
+
+
+/* File lock controls */
+#if _FS_LOCK != 0
+#if _FS_READONLY
+#error _FS_LOCK must be 0 at read-only configuration
+#endif
+typedef struct {
+	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
+	DWORD clu;		/* Object ID 2, directory (0:root) */
+	DWORD ofs;		/* Object ID 3, directory offset */
+	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
+} FILESEM;
+#endif
+
+
+
+/* DBCS code ranges and SBCS upper conversion tables */
+
+#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
+#define _DF1S	0x81	/* DBC 1st byte range 1 start */
+#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
+#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
+#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
+#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
+#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
+#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
+#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
+
+#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0x80
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 949	/* Korean */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x41
+#define _DS1E	0x5A
+#define _DS2S	0x61
+#define _DS2E	0x7A
+#define _DS3S	0x81
+#define _DS3E	0xFE
+
+#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0xA1
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 437	/* U.S. */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 720	/* Arabic */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 737	/* Greek */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
+				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 771	/* KBL */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
+
+#elif _CODE_PAGE == 775	/* Baltic */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
+				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 850	/* Latin 1 */
+#define _DF1S	0
+#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
+				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
+				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 852	/* Latin 2 */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
+				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
+
+#elif _CODE_PAGE == 855	/* Cyrillic */
+#define _DF1S	0
+#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
+				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
+				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
+				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
+				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 857	/* Turkish */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 860	/* Portuguese */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
+				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 861	/* Icelandic */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 862	/* Hebrew */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 863	/* Canadian-French */
+#define _DF1S	0
+#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
+				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
+				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 864	/* Arabic */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 865	/* Nordic */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 866	/* Russian */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 869	/* Greek 2 */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
+				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
+				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
+				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
+#if _USE_LFN != 0
+#error Cannot enable LFN without valid code page.
+#endif
+#define _DF1S	0
+
+#else
+#error Unknown code page
+
+#endif
+
+
+/* Character code support macros */
+#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
+#define IsLower(c)	(((c)>='a')&&((c)<='z'))
+#define IsDigit(c)	(((c)>='0')&&((c)<='9'))
+
+#if _DF1S != 0	/* Code page is DBCS */
+
+#ifdef _DF2S	/* Two 1st byte areas */
+#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
+#else			/* One 1st byte area */
+#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
+#endif
+
+#ifdef _DS3S	/* Three 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
+#else			/* Two 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
+#endif
+
+#else			/* Code page is SBCS */
+
+#define IsDBCS1(c)	0
+#define IsDBCS2(c)	0
+
+#endif /* _DF1S */
+
+
+/* File attribute bits (internal use) */
+#define	AM_VOL		0x08	/* Volume label */
+#define AM_LFN		0x0F	/* LFN entry */
+#define AM_MASK		0x3F	/* Mask of defined bits */
+
+
+/* File access control and file status flags (internal use) */
+#define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
+#define FA_MODIFIED	0x40	/* File has been modified */
+#define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
+
+
+/* Name status flags */
+#define NSFLAG		11		/* Index of name status byte in fn[] */
+#define NS_LOSS		0x01	/* Out of 8.3 format */
+#define NS_LFN		0x02	/* Force to create LFN entry */
+#define NS_LAST		0x04	/* Last segment */
+#define NS_BODY		0x08	/* Lower case flag (body) */
+#define NS_EXT		0x10	/* Lower case flag (ext) */
+#define NS_DOT		0x20	/* Dot entry */
+#define NS_NOLFN	0x40	/* Do not find LFN */
+#define NS_NONAME	0x80	/* Not followed */
+
+
+/* Limits and boundaries (differ from specs but correct for real DOS/Windows) */
+#define MAX_FAT12	0xFF5			/* Maximum number of FAT12 clusters */
+#define	MAX_FAT16	0xFFF5			/* Maximum number of FAT16 clusters */
+#define	MAX_FAT32	0xFFFFFF5		/* Maximum number of FAT32 clusters */
+#define	MAX_EXFAT	0x7FFFFFFD		/* Maximum number of exFAT clusters (limited by implementation) */
+#define MAX_DIR		0x200000		/* Maximum size of FAT directory */
+#define MAX_DIR_EX	0x10000000		/* Maximum size of exFAT directory */
+
+
+/* FatFs refers the members in the FAT structures as byte array instead of
+/ structure members because the structure is not binary compatible between
+/ different platforms */
+
+#define BS_JmpBoot			0		/* x86 jump instruction (3-byte) */
+#define BS_OEMName			3		/* OEM name (8-byte) */
+#define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
+#define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
+#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
+#define BPB_NumFATs			16		/* Number of FATs (BYTE) */
+#define BPB_RootEntCnt		17		/* Size of root directory area for FAT12/16 [entry] (WORD) */
+#define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
+#define BPB_Media			21		/* Media descriptor (BYTE) */
+#define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
+#define BPB_SecPerTrk		24		/* Track size for int13h [sector] (WORD) */
+#define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
+#define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
+#define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
+#define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
+#define BS_NTres			37		/* Error flag (BYTE) */
+#define BS_BootSig			38		/* Extended boot signature (BYTE) */
+#define BS_VolID			39		/* Volume serial number (DWORD) */
+#define BS_VolLab			43		/* Volume label string (8-byte) */
+#define BS_FilSysType		54		/* File system type string (8-byte) */
+#define BS_BootCode			62		/* Boot code (448-byte) */
+
+#define BPB_FATSz32			36		/* FAT32: FAT size [sector] (DWORD) */
+#define BPB_ExtFlags32		40		/* FAT32: Extended flags (WORD) */
+#define BPB_FSVer32			42		/* FAT32: File system version (WORD) */
+#define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
+#define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
+#define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
+#define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
+#define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
+#define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
+#define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
+#define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
+#define BS_FilSysType32		82		/* FAT32: File system type string (8-byte) */
+#define BS_BootCode32		90		/* FAT32: Boot code (420-byte) */
+
+#define BPB_ZeroedEx		11		/* exFAT: MBZ field (53-byte) */
+#define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
+#define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
+#define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
+#define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
+#define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
+#define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
+#define BPB_RootClusEx		96		/* exFAT: Root directory cluster (DWORD) */
+#define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
+#define BPB_FSVerEx			104		/* exFAT: File system version (WORD) */
+#define BPB_VolFlagEx		106		/* exFAT: Volume flags (BYTE) */
+#define BPB_ActFatEx		107		/* exFAT: Active FAT flags (BYTE) */
+#define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in byte (BYTE) */
+#define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in sector (BYTE) */
+#define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
+#define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
+#define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
+#define	BPB_RsvdEx			113		/* exFAT: Reserved (7-byte) */
+#define BS_BootCodeEx		120		/* exFAT: Boot code (390-byte) */
+
+#define	FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
+#define	FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
+#define	FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
+#define	FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
+
+#define MBR_Table			446		/* MBR: Offset of partition table in the MBR */
+#define	SZ_PTE				16		/* MBR: Size of a partition table entry */
+#define PTE_Boot			0		/* MBR PTE: Boot indicator */
+#define PTE_StHead			1		/* MBR PTE: Start head */
+#define PTE_StSec			2		/* MBR PTE: Start sector */
+#define PTE_StCyl			3		/* MBR PTE: Start cylinder */
+#define PTE_System			4		/* MBR PTE: System ID */
+#define PTE_EdHead			5		/* MBR PTE: End head */
+#define PTE_EdSec			6		/* MBR PTE: End sector */
+#define PTE_EdCyl			7		/* MBR PTE: End cylinder */
+#define PTE_StLba			8		/* MBR PTE: Start in LBA */
+#define PTE_SizLba			12		/* MBR PTE: Size in LBA */
+
+#define BS_55AA				510		/* Signature word (WORD) */
+
+#define	DIR_Name			0		/* Short file name (11-byte) */
+#define	DIR_Attr			11		/* Attribute (BYTE) */
+#define	DIR_NTres			12		/* Lower case flag (BYTE) */
+#define DIR_CrtTime10		13		/* Created time sub-second (BYTE) */
+#define	DIR_CrtTime			14		/* Created time (DWORD) */
+#define DIR_LstAccDate		18		/* Last accessed date (WORD) */
+#define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
+#define	DIR_ModTime			22		/* Modified time (DWORD) */
+#define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
+#define	DIR_FileSize		28		/* File size (DWORD) */
+#define	LDIR_Ord			0		/* LFN entry order and LLE flag (BYTE) */
+#define	LDIR_Attr			11		/* LFN attribute (BYTE) */
+#define	LDIR_Type			12		/* LFN type (BYTE) */
+#define	LDIR_Chksum			13		/* Checksum of the SFN entry (BYTE) */
+#define	LDIR_FstClusLO		26		/* Must be zero (WORD) */
+#define	XDIR_Type			0		/* Type of exFAT directory entry (BYTE) */
+#define	XDIR_NumLabel		1		/* Number of volume label characters (BYTE) */
+#define	XDIR_Label			2		/* Volume label (11-WORD) */
+#define	XDIR_CaseSum		4		/* Sum of case conversion table (DWORD) */
+#define	XDIR_NumSec			1		/* Number of secondary entries (BYTE) */
+#define	XDIR_SetSum			2		/* Sum of the set of directory entries (WORD) */
+#define	XDIR_Attr			4		/* File attribute (WORD) */
+#define	XDIR_CrtTime		8		/* Created time (DWORD) */
+#define	XDIR_ModTime		12		/* Modified time (DWORD) */
+#define	XDIR_AccTime		16		/* Last accessed time (DWORD) */
+#define	XDIR_CrtTime10		20		/* Created time subsecond (BYTE) */
+#define	XDIR_ModTime10		21		/* Modified time subsecond (BYTE) */
+#define	XDIR_CrtTZ			22		/* Created timezone (BYTE) */
+#define	XDIR_ModTZ			23		/* Modified timezone (BYTE) */
+#define	XDIR_AccTZ			24		/* Last accessed timezone (BYTE) */
+#define	XDIR_GenFlags		33		/* Gneral secondary flags (WORD) */
+#define	XDIR_NumName		35		/* Number of file name characters (BYTE) */
+#define	XDIR_NameHash		36		/* Hash of file name (WORD) */
+#define XDIR_ValidFileSize	40		/* Valid file size (QWORD) */
+#define	XDIR_FstClus		52		/* First cluster of the file data (DWORD) */
+#define	XDIR_FileSize		56		/* File/Directory size (QWORD) */
+
+#define	SZDIRE				32		/* Size of a directory entry */
+#define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
+#define	DDEM				0xE5	/* Deleted directory entry mark set to DIR_Name[0] */
+#define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
+
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Work Area
+
+---------------------------------------------------------------------------*/
+
+/* Remark: Variables here without initial value shall be guaranteed zero/null
+/  at start-up. If not, either the linker or start-up routine being used is
+/  not compliance with C standard. */
+
+#if _VOLUMES < 1 || _VOLUMES > 9
+#error Wrong _VOLUMES setting
+#endif
+static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
+static WORD Fsid;				/* File system mount ID */
+
+#if _FS_RPATH != 0 && _VOLUMES >= 2
+static BYTE CurrVol;			/* Current drive */
+#endif
+
+#if _FS_LOCK != 0
+static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
+#endif
+
+#if _USE_LFN == 0			/* Non-LFN configuration */
+#define	DEF_NAMBUF
+#define INIT_NAMBUF(fs)
+#define	FREE_NAMBUF()
+#else
+#if _MAX_LFN < 12 || _MAX_LFN > 255
+#error Wrong _MAX_LFN setting
+#endif
+
+#if _USE_LFN == 1		/* LFN enabled with static working buffer */
+#if _FS_EXFAT
+static BYTE	DirBuf[SZDIRE*19];	/* Directory entry block scratchpad buffer (19 entries in size) */
+#endif
+static WCHAR LfnBuf[_MAX_LFN+1];	/* LFN enabled with static working buffer */
+#define	DEF_NAMBUF
+#define INIT_NAMBUF(fs)
+#define	FREE_NAMBUF()
+
+#elif _USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
+#if _FS_EXFAT
+#define	DEF_NAMBUF		WCHAR lbuf[_MAX_LFN+1]; BYTE dbuf[SZDIRE*19];
+#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }
+#define	FREE_NAMBUF()
+#else
+#define	DEF_NAMBUF		WCHAR lbuf[_MAX_LFN+1];
+#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
+#define	FREE_NAMBUF()
+#endif
+
+#elif _USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
+#if _FS_EXFAT
+#define	DEF_NAMBUF		WCHAR *lfn;
+#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((_MAX_LFN+1)*2 + SZDIRE*19); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+_MAX_LFN+1); }
+#define	FREE_NAMBUF()	ff_memfree(lfn)
+#else
+#define	DEF_NAMBUF		WCHAR *lfn;
+#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }
+#define	FREE_NAMBUF()	ff_memfree(lfn)
+#endif
+
+#else
+#error Wrong _USE_LFN setting
+#endif
+#endif
+
+#ifdef _EXCVT
+static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for SBCS extended characters */
+#endif
+
+
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Functions
+
+---------------------------------------------------------------------------*/
+
+
+/*-----------------------------------------------------------------------*/
+/* Load/Store multi-byte word in the FAT structure                       */
+/*-----------------------------------------------------------------------*/
+
+static
+WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
+{
+	WORD rv;
+
+	rv = ptr[1];
+	rv = rv << 8 | ptr[0];
+	return rv;
+}
+
+static
+DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
+{
+	DWORD rv;
+
+	rv = ptr[3];
+	rv = rv << 8 | ptr[2];
+	rv = rv << 8 | ptr[1];
+	rv = rv << 8 | ptr[0];
+	return rv;
+}
+
+#if _FS_EXFAT
+static
+QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
+{
+	QWORD rv;
+
+	rv = ptr[7];
+	rv = rv << 8 | ptr[6];
+	rv = rv << 8 | ptr[5];
+	rv = rv << 8 | ptr[4];
+	rv = rv << 8 | ptr[3];
+	rv = rv << 8 | ptr[2];
+	rv = rv << 8 | ptr[1];
+	rv = rv << 8 | ptr[0];
+	return rv;
+}
+#endif
+
+#if !_FS_READONLY
+static
+void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
+{
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val;
+}
+
+static
+void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
+{
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val;
+}
+
+#if _FS_EXFAT
+static
+void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
+{
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val; val >>= 8;
+	*ptr++ = (BYTE)val;
+}
+#endif
+#endif	/* !_FS_READONLY */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* String functions                                                      */
+/*-----------------------------------------------------------------------*/
+
+/* Copy memory to memory */
+static
+void mem_cpy (void* dst, const void* src, UINT cnt) {
+	BYTE *d = (BYTE*)dst;
+	const BYTE *s = (const BYTE*)src;
+
+	if (cnt) {
+		do *d++ = *s++; while (--cnt);
+	}
+}
+
+/* Fill memory block */
+static
+void mem_set (void* dst, int val, UINT cnt) {
+	BYTE *d = (BYTE*)dst;
+
+	do *d++ = (BYTE)val; while (--cnt);
+}
+
+/* Compare memory block */
+static
+int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
+	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
+	int r = 0;
+
+	do {
+		r = *d++ - *s++;
+	} while (--cnt && r == 0);
+
+	return r;
+}
+
+/* Check if chr is contained in the string */
+static
+int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
+	while (*str && *str != chr) str++;
+	return *str;
+}
+
+
+
+
+#if _FS_REENTRANT
+/*-----------------------------------------------------------------------*/
+/* Request/Release grant to access the volume                            */
+/*-----------------------------------------------------------------------*/
+static
+int lock_fs (
+	FATFS* fs		/* File system object */
+)
+{
+	return ff_req_grant(fs->sobj);
+}
+
+
+static
+void unlock_fs (
+	FATFS* fs,		/* File system object */
+	FRESULT res		/* Result code to be returned */
+)
+{
+	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
+		ff_rel_grant(fs->sobj);
+	}
+}
+
+#endif
+
+
+
+#if _FS_LOCK != 0
+/*-----------------------------------------------------------------------*/
+/* File lock control functions                                           */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT chk_lock (	/* Check if the file can be accessed */
+	DIR* dp,		/* Directory object pointing the file to be checked */
+	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
+)
+{
+	UINT i, be;
+
+	/* Search file semaphore table */
+	for (i = be = 0; i < _FS_LOCK; i++) {
+		if (Files[i].fs) {	/* Existing entry */
+			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
+				Files[i].clu == dp->obj.sclust &&
+				Files[i].ofs == dp->dptr) break;
+		} else {			/* Blank entry */
+			be = 1;
+		}
+	}
+	if (i == _FS_LOCK) {	/* The object is not opened */
+		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
+	}
+
+	/* The object has been opened. Reject any open against writing file and all write mode open */
+	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
+}
+
+
+static
+int enq_lock (void)	/* Check if an entry is available for a new object */
+{
+	UINT i;
+
+	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
+	return (i == _FS_LOCK) ? 0 : 1;
+}
+
+
+static
+UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
+	DIR* dp,	/* Directory object pointing the file to register or increment */
+	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
+)
+{
+	UINT i;
+
+
+	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
+		if (Files[i].fs == dp->obj.fs &&
+			Files[i].clu == dp->obj.sclust &&
+			Files[i].ofs == dp->dptr) break;
+	}
+
+	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
+		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
+		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
+		Files[i].fs = dp->obj.fs;
+		Files[i].clu = dp->obj.sclust;
+		Files[i].ofs = dp->dptr;
+		Files[i].ctr = 0;
+	}
+
+	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
+
+	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
+
+	return i + 1;
+}
+
+
+static
+FRESULT dec_lock (	/* Decrement object open counter */
+	UINT i			/* Semaphore index (1..) */
+)
+{
+	WORD n;
+	FRESULT res;
+
+
+	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
+		n = Files[i].ctr;
+		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
+		if (n > 0) n--;				/* Decrement read mode open count */
+		Files[i].ctr = n;
+		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
+		res = FR_OK;
+	} else {
+		res = FR_INT_ERR;			/* Invalid index nunber */
+	}
+	return res;
+}
+
+
+static
+void clear_lock (	/* Clear lock entries of the volume */
+	FATFS *fs
+)
+{
+	UINT i;
+
+	for (i = 0; i < _FS_LOCK; i++) {
+		if (Files[i].fs == fs) Files[i].fs = 0;
+	}
+}
+
+#endif	/* _FS_LOCK != 0 */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Move/Flush disk access window in the file system object               */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
+	FATFS* fs			/* File system object */
+)
+{
+	DWORD wsect;
+	UINT nf;
+	FRESULT res = FR_OK;
+
+
+	if (fs->wflag) {	/* Write back the sector if it is dirty */
+		wsect = fs->winsect;	/* Current sector number */
+		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
+			res = FR_DISK_ERR;
+		} else {
+			fs->wflag = 0;
+			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
+				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
+					wsect += fs->fsize;
+					disk_write(fs->drv, fs->win, wsect, 1);
+				}
+			}
+		}
+	}
+	return res;
+}
+#endif
+
+
+static
+FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
+	FATFS* fs,			/* File system object */
+	DWORD sector		/* Sector number to make appearance in the fs->win[] */
+)
+{
+	FRESULT res = FR_OK;
+
+
+	if (sector != fs->winsect) {	/* Window offset changed? */
+#if !_FS_READONLY
+		res = sync_window(fs);		/* Write-back changes */
+#endif
+		if (res == FR_OK) {			/* Fill sector window with new data */
+			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
+				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
+				res = FR_DISK_ERR;
+			}
+			fs->winsect = sector;
+		}
+	}
+	return res;
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Synchronize file system and strage device                             */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
+	FATFS* fs		/* File system object */
+)
+{
+	FRESULT res;
+
+
+	res = sync_window(fs);
+	if (res == FR_OK) {
+		/* Update FSInfo sector if needed */
+		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
+			/* Create FSInfo structure */
+			mem_set(fs->win, 0, SS(fs));
+			st_word(fs->win + BS_55AA, 0xAA55);
+			st_dword(fs->win + FSI_LeadSig, 0x41615252);
+			st_dword(fs->win + FSI_StrucSig, 0x61417272);
+			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
+			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
+			/* Write it into the FSInfo sector */
+			fs->winsect = fs->volbase + 1;
+			disk_write(fs->drv, fs->win, fs->winsect, 1);
+			fs->fsi_flag = 0;
+		}
+		/* Make sure that no pending write process in the physical drive */
+		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
+	}
+
+	return res;
+}
+
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get sector# from cluster#                                             */
+/*-----------------------------------------------------------------------*/
+
+static
+DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
+	FATFS* fs,		/* File system object */
+	DWORD clst		/* Cluster# to be converted */
+)
+{
+	clst -= 2;
+	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
+	return clst * fs->csize + fs->database;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT access - Read value of a FAT entry                                */
+/*-----------------------------------------------------------------------*/
+
+static
+DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
+	_FDID* obj,	/* Corresponding object */
+	DWORD clst	/* Cluster number to get the value */
+)
+{
+	UINT wc, bc;
+	DWORD val;
+	FATFS *fs = obj->fs;
+
+
+	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
+		val = 1;	/* Internal error */
+
+	} else {
+		val = 0xFFFFFFFF;	/* Default value falls on disk error */
+
+		switch (fs->fs_type) {
+		case FS_FAT12 :
+			bc = (UINT)clst; bc += bc / 2;
+			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
+			wc = fs->win[bc++ % SS(fs)];
+			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
+			wc |= fs->win[bc % SS(fs)] << 8;
+			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
+			break;
+
+		case FS_FAT16 :
+			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
+			val = ld_word(fs->win + clst * 2 % SS(fs));
+			break;
+
+		case FS_FAT32 :
+			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
+			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
+			break;
+#if _FS_EXFAT
+		case FS_EXFAT :
+			if (obj->objsize) {
+				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
+				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
+
+				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
+					if (cofs <= clen) {
+						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
+						break;
+					}
+				}
+				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the contiguous part? */
+					val = clst + 1; 	/* Generate the value */
+					break;
+				}
+				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
+					if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
+					val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
+					break;
+				}
+			}
+			/* go next */
+#endif
+		default:
+			val = 1;	/* Internal error */
+		}
+	}
+
+	return val;
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* FAT access - Change value of a FAT entry                              */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
+	FATFS* fs,		/* Corresponding file system object */
+	DWORD clst,		/* FAT index number (cluster number) to be changed */
+	DWORD val		/* New value to be set to the entry */
+)
+{
+	UINT bc;
+	BYTE *p;
+	FRESULT res = FR_INT_ERR;
+
+
+	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
+		switch (fs->fs_type) {
+		case FS_FAT12 :	/* Bitfield items */
+			bc = (UINT)clst; bc += bc / 2;
+			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = fs->win + bc++ % SS(fs);
+			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
+			fs->wflag = 1;
+			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = fs->win + bc % SS(fs);
+			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
+			fs->wflag = 1;
+			break;
+
+		case FS_FAT16 :	/* WORD aligned items */
+			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
+			if (res != FR_OK) break;
+			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
+			fs->wflag = 1;
+			break;
+
+		case FS_FAT32 :	/* DWORD aligned items */
+#if _FS_EXFAT
+		case FS_EXFAT :
+#endif
+			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
+			if (res != FR_OK) break;
+			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
+				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
+			}
+			st_dword(fs->win + clst * 4 % SS(fs), val);
+			fs->wflag = 1;
+			break;
+		}
+	}
+	return res;
+}
+
+#endif /* !_FS_READONLY */
+
+
+
+
+#if _FS_EXFAT && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* exFAT: Accessing FAT and Allocation Bitmap                            */
+/*-----------------------------------------------------------------------*/
+
+/*---------------------------------------------*/
+/* exFAT: Find a contiguous free cluster block */
+/*---------------------------------------------*/
+
+static
+DWORD find_bitmap (	/* 0:No free cluster, 2..:Free cluster found, 0xFFFFFFFF:Disk error */
+	FATFS* fs,	/* File system object */
+	DWORD clst,	/* Cluster number to scan from */
+	DWORD ncl	/* Number of contiguous clusters to find (1..) */
+)
+{
+	BYTE bm, bv;
+	UINT i;
+	DWORD val, scl, ctr;
+
+
+	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
+	if (clst >= fs->n_fatent - 2) clst = 0;
+	scl = val = clst; ctr = 0;
+	for (;;) {
+		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
+		i = val / 8 % SS(fs); bm = 1 << (val % 8);
+		do {
+			do {
+				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
+				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
+					val = 0; bm = 0; i = 4096;
+				}
+				if (!bv) {	/* Is it a free cluster? */
+					if (++ctr == ncl) return scl + 2;	/* Check run length */
+				} else {
+					scl = val; ctr = 0;		/* Encountered a live cluster, restart to scan */
+				}
+				if (val == clst) return 0;	/* All cluster scanned? */
+			} while (bm);
+			bm = 1;
+		} while (++i < SS(fs));
+	}
+}
+
+
+/*------------------------------------*/
+/* exFAT: Set/Clear a block of bitmap */
+/*------------------------------------*/
+
+static
+FRESULT change_bitmap (
+	FATFS* fs,	/* File system object */
+	DWORD clst,	/* Cluster number to change from */
+	DWORD ncl,	/* Number of clusters to be changed */
+	int bv		/* bit value to be set (0 or 1) */
+)
+{
+	BYTE bm;
+	UINT i;
+	DWORD sect;
+
+
+	clst -= 2;	/* The first bit corresponds to cluster #2 */
+	sect = fs->database + clst / 8 / SS(fs);	/* Sector address */
+	i = clst / 8 % SS(fs);						/* Byte offset in the sector */
+	bm = 1 << (clst % 8);						/* Bit mask in the byte */
+	for (;;) {
+		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
+		do {
+			do {
+				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
+				fs->win[i] ^= bm;	/* Flip the bit */
+				fs->wflag = 1;
+				if (--ncl == 0) return FR_OK;	/* All bits processed? */
+			} while (bm <<= 1);		/* Next bit */
+			bm = 1;
+		} while (++i < SS(fs));		/* Next byte */
+	}
+}
+
+
+/*---------------------------------------------*/
+/* Complement contiguous part of the FAT chain */
+/*---------------------------------------------*/
+
+static
+FRESULT fill_fat_chain (
+	_FDID* obj	/* Pointer to the corresponding object */
+)
+{
+	FRESULT res;
+	DWORD cl, n;
+
+	if (obj->stat == 3) {	/* Has the object been changed 'fragmented'? */
+		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
+			res = put_fat(obj->fs, cl, cl + 1);
+			if (res != FR_OK) return res;
+		}
+		obj->stat = 0;	/* Change status 'FAT chain is valid' */
+	}
+	return FR_OK;
+}
+
+#endif	/* _FS_EXFAT && !_FS_READONLY */
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Remove a cluster chain                                 */
+/*-----------------------------------------------------------------------*/
+static
+FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
+	_FDID* obj,			/* Corresponding object */
+	DWORD clst,			/* Cluster to remove a chain from */
+	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
+)
+{
+	FRESULT res = FR_OK;
+	DWORD nxt;
+	FATFS *fs = obj->fs;
+#if _FS_EXFAT || _USE_TRIM
+	DWORD scl = clst, ecl = clst;
+#endif
+#if _USE_TRIM
+	DWORD rt[2];
+#endif
+
+	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
+
+	/* Mark the previous cluster 'EOC' on the FAT if it exists */
+	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
+		res = put_fat(fs, pclst, 0xFFFFFFFF);
+		if (res != FR_OK) return res;
+	}
+
+	/* Remove the chain */
+	do {
+		nxt = get_fat(obj, clst);			/* Get cluster status */
+		if (nxt == 0) break;				/* Empty cluster? */
+		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
+		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
+		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
+			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
+			if (res != FR_OK) return res;
+		}
+		if (fs->free_clst != 0xFFFFFFFF) {	/* Update FSINFO */
+			fs->free_clst++;
+			fs->fsi_flag |= 1;
+		}
+#if _FS_EXFAT || _USE_TRIM
+		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
+			ecl = nxt;
+		} else {				/* End of contiguous cluster block */ 
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
+				if (res != FR_OK) return res;
+			}
+#endif
+#if _USE_TRIM
+			rt[0] = clust2sect(fs, scl);					/* Start sector */
+			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
+			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
+#endif
+			scl = ecl = nxt;
+		}
+#endif
+		clst = nxt;					/* Next cluster */
+	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {
+		if (pclst == 0) {	/* Does object have no chain? */
+			obj->stat = 0;		/* Change the object status 'initial' */
+		} else {
+			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain got contiguous? */
+				obj->stat = 2;	/* Change the object status 'contiguous' */
+			}
+		}
+	}
+#endif
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Stretch a chain or Create a new chain                  */
+/*-----------------------------------------------------------------------*/
+static
+DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
+	_FDID* obj,			/* Corresponding object */
+	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
+)
+{
+	DWORD cs, ncl, scl;
+	FRESULT res;
+	FATFS *fs = obj->fs;
+
+
+	if (clst == 0) {	/* Create a new chain */
+		scl = fs->last_clst;				/* Get suggested cluster to start at */
+		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
+	}
+	else {				/* Stretch current chain */
+		cs = get_fat(obj, clst);			/* Check the cluster status */
+		if (cs < 2) return 1;				/* Invalid value */
+		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
+		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
+		scl = clst;
+	}
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
+		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
+		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
+		if (res == FR_INT_ERR) return 1;
+		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
+		if (clst == 0) {							/* Is it a new chain? */
+			obj->stat = 2;							/* Set status 'contiguous chain' */
+		} else {									/* This is a stretched chain */
+			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
+				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
+				obj->stat = 3;						/* Change status 'just fragmented' */
+			}
+		}
+	} else
+#endif
+	{	/* At the FAT12/16/32 */
+		ncl = scl;	/* Start cluster */
+		for (;;) {
+			ncl++;							/* Next cluster */
+			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
+				ncl = 2;
+				if (ncl > scl) return 0;	/* No free cluster */
+			}
+			cs = get_fat(obj, ncl);			/* Get the cluster status */
+			if (cs == 0) break;				/* Found a free cluster */
+			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
+			if (ncl == scl) return 0;		/* No free cluster */
+		}
+	}
+
+	if (_FS_EXFAT && fs->fs_type == FS_EXFAT && obj->stat == 2) {	/* Is it a contiguous chain? */
+		res = FR_OK;						/* FAT does not need to be written */
+	} else {
+		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
+		if (res == FR_OK && clst) {
+			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
+		}
+	}
+
+	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
+		fs->last_clst = ncl;
+		if (fs->free_clst < fs->n_fatent - 2) fs->free_clst--;
+		fs->fsi_flag |= 1;
+	} else {
+		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Create error status */
+	}
+
+	return ncl;		/* Return new cluster number or error status */
+}
+
+#endif /* !_FS_READONLY */
+
+
+
+
+#if _USE_FASTSEEK
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Convert offset into cluster with link map table        */
+/*-----------------------------------------------------------------------*/
+
+static
+DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
+	FIL* fp,		/* Pointer to the file object */
+	FSIZE_t ofs		/* File offset to be converted to cluster# */
+)
+{
+	DWORD cl, ncl, *tbl;
+	FATFS *fs = fp->obj.fs;
+
+
+	tbl = fp->cltbl + 1;	/* Top of CLMT */
+	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
+	for (;;) {
+		ncl = *tbl++;			/* Number of cluters in the fragment */
+		if (ncl == 0) return 0;	/* End of table? (error) */
+		if (cl < ncl) break;	/* In this fragment? */
+		cl -= ncl; tbl++;		/* Next fragment */
+	}
+	return cl + *tbl;	/* Return the cluster number */
+}
+
+#endif	/* _USE_FASTSEEK */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Set directory index                              */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
+	DIR* dp,		/* Pointer to directory object */
+	DWORD ofs		/* Offset of directory table */
+)
+{
+	DWORD csz, clst;
+	FATFS *fs = dp->obj.fs;
+
+
+	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
+		return FR_INT_ERR;
+	}
+	dp->dptr = ofs;				/* Set current offset */
+	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
+	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
+		clst = fs->dirbase;
+		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
+	}
+
+	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
+		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
+		dp->sect = fs->dirbase;
+
+	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
+		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
+		while (ofs >= csz) {				/* Follow cluster chain */
+			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
+			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
+			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
+			ofs -= csz;
+		}
+		dp->sect = clust2sect(fs, clst);
+	}
+	dp->clust = clst;					/* Current cluster# */
+	if (!dp->sect) return FR_INT_ERR;
+	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
+	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Move directory table index next                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
+	DIR* dp,		/* Pointer to the directory object */
+	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
+)
+{
+	DWORD ofs, clst;
+	FATFS *fs = dp->obj.fs;
+#if !_FS_READONLY
+	UINT n;
+#endif
+
+	ofs = dp->dptr + SZDIRE;	/* Next entry */
+	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
+
+	if (ofs % SS(fs) == 0) {	/* Sector changed? */
+		dp->sect++;				/* Next sector */
+
+		if (!dp->clust) {		/* Static table */
+			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
+				dp->sect = 0; return FR_NO_FILE;
+			}
+		}
+		else {					/* Dynamic table */
+			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
+				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
+				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
+				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
+				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
+#if !_FS_READONLY
+					if (!stretch) {								/* If no stretch, report EOT */
+						dp->sect = 0; return FR_NO_FILE;
+					}
+					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
+					if (clst == 0) return FR_DENIED;			/* No free cluster */
+					if (clst == 1) return FR_INT_ERR;			/* Internal error */
+					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
+					/* Clean-up the stretched table */
+					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
+					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
+					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
+					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
+						fs->wflag = 1;
+						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
+					}
+					fs->winsect -= n;							/* Restore window offset */
+#else
+					if (!stretch) dp->sect = 0;					/* If no stretch, report EOT (this is to suppress warning) */
+					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
+#endif
+				}
+				dp->clust = clst;		/* Initialize data for new cluster */
+				dp->sect = clust2sect(fs, clst);
+			}
+		}
+	}
+	dp->dptr = ofs;						/* Current entry */
+	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
+
+	return FR_OK;
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Reserve a block of directory entries             */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
+	DIR* dp,		/* Pointer to the directory object */
+	UINT nent		/* Number of contiguous entries to allocate */
+)
+{
+	FRESULT res;
+	UINT n;
+	FATFS *fs = dp->obj.fs;
+
+
+	res = dir_sdi(dp, 0);
+	if (res == FR_OK) {
+		n = 0;
+		do {
+			res = move_window(fs, dp->sect);
+			if (res != FR_OK) break;
+#if _FS_EXFAT
+			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
+#else
+			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
+#endif
+				if (++n == nent) break;	/* A block of contiguous free entries is found */
+			} else {
+				n = 0;					/* Not a blank entry. Restart to search */
+			}
+			res = dir_next(dp, 1);
+		} while (res == FR_OK);	/* Next entry with table stretch enabled */
+	}
+
+	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
+	return res;
+}
+
+#endif	/* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT: Directory handling - Load/Store start cluster number             */
+/*-----------------------------------------------------------------------*/
+
+static
+DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
+	FATFS* fs,		/* Pointer to the fs object */
+	const BYTE* dir	/* Pointer to the key entry */
+)
+{
+	DWORD cl;
+
+	cl = ld_word(dir + DIR_FstClusLO);
+	if (fs->fs_type == FS_FAT32) {
+		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
+	}
+
+	return cl;
+}
+
+
+#if !_FS_READONLY
+static
+void st_clust (
+	FATFS* fs,	/* Pointer to the fs object */
+	BYTE* dir,	/* Pointer to the key entry */
+	DWORD cl	/* Value to be set */
+)
+{
+	st_word(dir + DIR_FstClusLO, (WORD)cl);
+	if (fs->fs_type == FS_FAT32) {
+		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
+	}
+}
+#endif
+
+
+
+#if _USE_LFN != 0
+/*------------------------------------------------------------------------*/
+/* FAT-LFN: LFN handling                                                  */
+/*------------------------------------------------------------------------*/
+static
+const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
+
+
+/*--------------------------------------------------------*/
+/* FAT-LFN: Compare a part of file name with an LFN entry */
+/*--------------------------------------------------------*/
+static
+int cmp_lfn (				/* 1:matched, 0:not matched */
+	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
+	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
+)
+{
+	UINT i, s;
+	WCHAR wc, uc;
+
+
+	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
+
+	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
+
+	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
+		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
+		if (wc) {
+			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
+				return 0;					/* Not matched */
+			}
+			wc = uc;
+		} else {
+			if (uc != 0xFFFF) return 0;		/* Check filler */
+		}
+	}
+
+	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
+
+	return 1;		/* The part of LFN matched */
+}
+
+
+#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
+/*-----------------------------------------------------*/
+/* FAT-LFN: Pick a part of file name from an LFN entry */
+/*-----------------------------------------------------*/
+static
+int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
+	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
+	BYTE* dir			/* Pointer to the LFN entry */
+)
+{
+	UINT i, s;
+	WCHAR wc, uc;
+
+
+	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
+
+	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
+
+	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
+		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
+		if (wc) {
+			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
+			lfnbuf[i++] = wc = uc;			/* Store it */
+		} else {
+			if (uc != 0xFFFF) return 0;		/* Check filler */
+		}
+	}
+
+	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
+		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
+		lfnbuf[i] = 0;
+	}
+
+	return 1;		/* The part of LFN is valid */
+}
+#endif
+
+
+#if !_FS_READONLY
+/*-----------------------------------------*/
+/* FAT-LFN: Create an entry of LFN entries */
+/*-----------------------------------------*/
+static
+void put_lfn (
+	const WCHAR* lfn,	/* Pointer to the LFN */
+	BYTE* dir,			/* Pointer to the LFN entry to be created */
+	BYTE ord,			/* LFN order (1-20) */
+	BYTE sum			/* Checksum of the corresponding SFN */
+)
+{
+	UINT i, s;
+	WCHAR wc;
+
+
+	dir[LDIR_Chksum] = sum;			/* Set checksum */
+	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
+	dir[LDIR_Type] = 0;
+	st_word(dir + LDIR_FstClusLO, 0);
+
+	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
+	s = wc = 0;
+	do {
+		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
+		st_word(dir + LfnOfs[s], wc);		/* Put it */
+		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
+	} while (++s < 13);
+	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
+	dir[LDIR_Ord] = ord;			/* Set the LFN order */
+}
+
+#endif	/* !_FS_READONLY */
+#endif	/* _USE_LFN != 0 */
+
+
+
+#if _USE_LFN != 0 && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* FAT-LFN: Create a Numbered SFN                                        */
+/*-----------------------------------------------------------------------*/
+
+static
+void gen_numname (
+	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
+	const BYTE* src,	/* Pointer to SFN */
+	const WCHAR* lfn,	/* Pointer to LFN */
+	UINT seq			/* Sequence number */
+)
+{
+	BYTE ns[8], c;
+	UINT i, j;
+	WCHAR wc;
+	DWORD sr;
+
+
+	mem_cpy(dst, src, 11);
+
+	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
+		sr = seq;
+		while (*lfn) {	/* Create a CRC */
+			wc = *lfn++;
+			for (i = 0; i < 16; i++) {
+				sr = (sr << 1) + (wc & 1);
+				wc >>= 1;
+				if (sr & 0x10000) sr ^= 0x11021;
+			}
+		}
+		seq = (UINT)sr;
+	}
+
+	/* itoa (hexdecimal) */
+	i = 7;
+	do {
+		c = (seq % 16) + '0';
+		if (c > '9') c += 7;
+		ns[i--] = c;
+		seq /= 16;
+	} while (seq);
+	ns[i] = '~';
+
+	/* Append the number */
+	for (j = 0; j < i && dst[j] != ' '; j++) {
+		if (IsDBCS1(dst[j])) {
+			if (j == i - 1) break;
+			j++;
+		}
+	}
+	do {
+		dst[j++] = (i < 8) ? ns[i++] : ' ';
+	} while (j < 8);
+}
+#endif	/* _USE_LFN != 0 && !_FS_READONLY */
+
+
+
+#if _USE_LFN != 0
+/*-----------------------------------------------------------------------*/
+/* FAT-LFN: Calculate checksum of an SFN entry                           */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE sum_sfn (
+	const BYTE* dir		/* Pointer to the SFN entry */
+)
+{
+	BYTE sum = 0;
+	UINT n = 11;
+
+	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
+	return sum;
+}
+
+#endif	/* _USE_LFN != 0 */
+
+
+
+#if _FS_EXFAT
+/*-----------------------------------------------------------------------*/
+/* exFAT: Checksum                                                       */
+/*-----------------------------------------------------------------------*/
+
+static
+WORD xdir_sum (			/* Get checksum of the directoly block */
+	const BYTE* dir		/* Directory entry block to be calculated */
+)
+{
+	UINT i, szblk;
+	WORD sum;
+
+
+	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
+	for (i = sum = 0; i < szblk; i++) {
+		if (i == XDIR_SetSum) {	/* Skip sum field */
+			i++;
+		} else {
+			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
+		}
+	}
+	return sum;
+}
+
+
+
+static
+WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
+	const WCHAR* name	/* File name to be calculated */
+)
+{
+	WCHAR chr;
+	WORD sum = 0;
+
+
+	while ((chr = *name++) != 0) {
+		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
+		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
+		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
+	}
+	return sum;
+}
+
+
+#if !_FS_READONLY && _USE_MKFS
+static
+DWORD xsum32 (
+	BYTE  dat,	/* Data to be sumed */
+	DWORD sum	/* Previous value */
+)
+{
+	sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
+	return sum;
+}
+#endif
+
+
+#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
+/*------------------------------------------------------*/
+/* exFAT: Get object information from a directory block */
+/*------------------------------------------------------*/
+
+static
+void get_xdir_info (
+	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
+	FILINFO* fno		/* Buffer to store the extracted file information */
+)
+{
+	UINT di, si;
+	WCHAR w;
+#if !_LFN_UNICODE
+	UINT nc;
+#endif
+
+	/* Get file name */
+#if _LFN_UNICODE
+	if (dirb[XDIR_NumName] <= _MAX_LFN) {
+		for (si = SZDIRE * 2, di = 0; di < dirb[XDIR_NumName]; si += 2, di++) {
+			if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
+			w = ld_word(dirb + si);				/* Get a character */
+			fno->fname[di] = w;					/* Store it */
+		}
+	} else {
+		di = 0;	/* Buffer overflow and inaccessible object */
+	}
+#else
+	for (si = SZDIRE * 2, di = nc = 0; nc < dirb[XDIR_NumName]; si += 2, nc++) {
+		if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
+		w = ld_word(dirb + si);				/* Get a character */
+		w = ff_convert(w, 0);				/* Unicode -> OEM */
+		if (w == 0) { di = 0; break; }		/* Could not be converted and inaccessible object */
+		if (_DF1S && w >= 0x100) {			/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
+			fno->fname[di++] = (char)(w >> 8);
+		}
+		if (di >= _MAX_LFN) { di = 0; break; }	/* Buffer overflow and inaccessible object */
+		fno->fname[di++] = (char)w;
+	}
+#endif
+	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object? */
+	fno->fname[di] = 0;						/* Terminate file name */
+
+	fno->altname[0] = 0;							/* No SFN */
+	fno->fattrib = dirb[XDIR_Attr];					/* Attribute */
+	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
+	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
+	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
+}
+
+#endif	/* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
+
+
+/*-----------------------------------*/
+/* exFAT: Get a directry entry block */
+/*-----------------------------------*/
+
+static
+FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
+	DIR* dp			/* Pointer to the reading direcotry object pointing the 85 entry */
+)
+{
+	FRESULT res;
+	UINT i, nent;
+	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
+
+
+	/* Load 85 entry */
+	res = move_window(dp->obj.fs, dp->sect);
+	if (res != FR_OK) return res;
+	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
+	mem_cpy(dirb, dp->dir, SZDIRE);
+	nent = dirb[XDIR_NumSec] + 1;
+
+	/* Load C0 entry */
+	res = dir_next(dp, 0);
+	if (res != FR_OK) return res;
+	res = move_window(dp->obj.fs, dp->sect);
+	if (res != FR_OK) return res;
+	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
+	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
+
+	/* Load C1 entries */
+	if (nent < 3 || nent > 19) return FR_NO_FILE;
+	i = SZDIRE * 2; nent *= SZDIRE;
+	do {
+		res = dir_next(dp, 0);
+		if (res != FR_OK) return res;
+		res = move_window(dp->obj.fs, dp->sect);
+		if (res != FR_OK) return res;
+		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
+		mem_cpy(dirb + i, dp->dir, SZDIRE);
+		i += SZDIRE;
+	} while (i < nent);
+
+	/* Sanity check */
+	if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
+
+	return FR_OK;
+}
+
+
+#if !_FS_READONLY || _FS_RPATH != 0 
+/*------------------------------------------------*/
+/* exFAT: Load the object's directory entry block */
+/*------------------------------------------------*/
+static
+FRESULT load_obj_dir (	
+	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
+	const _FDID* obj	/* Object with containing directory information */
+)
+{
+	FRESULT res;
+
+
+	/* Open object containing directory */
+	dp->obj.fs = obj->fs;
+	dp->obj.sclust = obj->c_scl;
+	dp->obj.stat = (BYTE)obj->c_size;
+	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
+	dp->blk_ofs = obj->c_ofs;
+
+	res = dir_sdi(dp, dp->blk_ofs);	/* Goto the block location */
+	if (res == FR_OK) {
+		res = load_xdir(dp);		/* Load the object's entry block */
+	}
+	return res;
+}
+#endif
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------*/
+/* exFAT: Store the directory block to the media */
+/*-----------------------------------------------*/
+static
+FRESULT store_xdir (
+	DIR* dp				/* Pointer to the direcotry object */
+)
+{
+	FRESULT res;
+	UINT nent;
+	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
+
+	/* Create set sum */
+	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
+	nent = dirb[XDIR_NumSec] + 1;
+
+	/* Store the set of directory to the volume */
+	res = dir_sdi(dp, dp->blk_ofs);
+	while (res == FR_OK) {
+		res = move_window(dp->obj.fs, dp->sect);
+		if (res != FR_OK) break;
+		mem_cpy(dp->dir, dirb, SZDIRE);
+		dp->obj.fs->wflag = 1;
+		if (--nent == 0) break;
+		dirb += SZDIRE;
+		res = dir_next(dp, 0);
+	}
+	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
+}
+
+
+
+/*-------------------------------------------*/
+/* exFAT: Create a new directory enrty block */
+/*-------------------------------------------*/
+
+static
+void create_xdir (
+	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
+	const WCHAR* lfn	/* Pointer to the nul terminated file name */
+)
+{
+	UINT i;
+	BYTE nb, nc;
+	WCHAR chr;
+
+
+	mem_set(dirb, 0, 2 * SZDIRE);			/* Initialize 85+C0 entry */
+	dirb[XDIR_Type] = 0x85;
+	dirb[XDIR_Type + SZDIRE] = 0xC0;
+	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
+
+	i = SZDIRE * 2;	/* C1 offset */
+	nc = 0; nb = 1; chr = 1;
+	do {
+		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
+		do {	/* Fill name field */
+			if (chr && (chr = lfn[nc]) != 0) nc++;	/* Get a character if exist */
+			st_word(dirb + i, chr); i += 2;	/* Store it */
+		} while (i % SZDIRE);
+		nb++;
+	} while (lfn[nc]);	/* Fill next entry if any char follows */
+
+	dirb[XDIR_NumName] = nc;	/* Set name length */
+	dirb[XDIR_NumSec] = nb;		/* Set number of C0+C1s */
+}
+
+#endif	/* !_FS_READONLY */
+#endif	/* _FS_EXFAT */
+
+
+
+#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
+/*-----------------------------------------------------------------------*/
+/* Read an object from the directory                                     */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_read (
+	DIR* dp,		/* Pointer to the directory object */
+	int vol			/* Filtered by 0:file/directory or 1:volume label */
+)
+{
+	FRESULT res = FR_NO_FILE;
+	FATFS *fs = dp->obj.fs;
+	BYTE a, c;
+#if _USE_LFN != 0
+	BYTE ord = 0xFF, sum = 0xFF;
+#endif
+
+	while (dp->sect) {
+		res = move_window(fs, dp->sect);
+		if (res != FR_OK) break;
+		c = dp->dir[DIR_Name];	/* Test for the entry type */
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of the directory */
+#if _FS_EXFAT
+		if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+			if (_USE_LABEL && vol) {
+				if (c == 0x83) break;	/* Volume label entry? */
+			} else {
+				if (c == 0x85) {		/* Start of the file entry block? */
+					dp->blk_ofs = dp->dptr;	/* Get location of the block */
+					res = load_xdir(dp);	/* Load the entry block */
+					if (res == FR_OK) {
+						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
+					}
+					break;
+				}
+			}
+		} else
+#endif
+		{	/* At the FAT12/16/32 */
+			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
+#if _USE_LFN != 0	/* LFN configuration */
+			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
+				ord = 0xFF;
+			} else {
+				if (a == AM_LFN) {			/* An LFN entry is found */
+					if (c & LLEF) {			/* Is it start of an LFN sequence? */
+						sum = dp->dir[LDIR_Chksum];
+						c &= ~LLEF; ord = c;
+						dp->blk_ofs = dp->dptr;
+					}
+					/* Check LFN validity and capture it */
+					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
+				} else {					/* An SFN entry is found */
+					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
+						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
+					}
+					break;
+				}
+			}
+#else		/* Non LFN configuration */
+			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
+				break;
+			}
+#endif
+		}
+		res = dir_next(dp, 0);		/* Next entry */
+		if (res != FR_OK) break;
+	}
+
+	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
+	return res;
+}
+
+#endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Find an object in the directory                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
+	DIR* dp			/* Pointer to the directory object with the file name */
+)
+{
+	FRESULT res;
+	FATFS *fs = dp->obj.fs;
+	BYTE c;
+#if _USE_LFN != 0
+	BYTE a, ord, sum;
+#endif
+
+	res = dir_sdi(dp, 0);			/* Rewind directory object */
+	if (res != FR_OK) return res;
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		BYTE nc;
+		UINT di, ni;
+		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
+
+		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
+			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip the comparison if hash value mismatched */
+			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
+				if ((di % SZDIRE) == 0) di += 2;
+				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
+			}
+			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
+		}
+		return res;
+	}
+#endif
+	/* At the FAT12/16/32 */
+#if _USE_LFN != 0
+	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
+#endif
+	do {
+		res = move_window(fs, dp->sect);
+		if (res != FR_OK) break;
+		c = dp->dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN != 0	/* LFN configuration */
+		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
+		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
+					if (c & LLEF) {		/* Is it start of LFN sequence? */
+						sum = dp->dir[LDIR_Chksum];
+						c &= ~LLEF; ord = c;	/* LFN start order */
+						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
+					}
+					/* Check validity of the LFN entry and compare it with given name */
+					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
+				}
+			} else {					/* An SFN entry is found */
+				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
+				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
+				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
+			}
+		}
+#else		/* Non LFN configuration */
+		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
+		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
+#endif
+		res = dir_next(dp, 0);	/* Next entry */
+	} while (res == FR_OK);
+
+	return res;
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Register an object to the directory                                   */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
+	DIR* dp				/* Target directory with object name to be created */
+)
+{
+	FRESULT res;
+	FATFS *fs = dp->obj.fs;
+#if _USE_LFN != 0	/* LFN configuration */
+	UINT n, nlen, nent;
+	BYTE sn[12], sum;
+
+
+	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
+	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		DIR dj;
+
+		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
+		res = dir_alloc(dp, nent);		/* Allocate entries */
+		if (res != FR_OK) return res;
+		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);			/* Set block position */
+
+		if (dp->obj.stat & 4) {			/* Has the sub-directory been stretched? */
+			dp->obj.stat &= 3;
+			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase object size by cluster size */
+			res = fill_fat_chain(&dp->obj);	/* Complement FAT chain if needed */
+			if (res != FR_OK) return res;
+			res = load_obj_dir(&dj, &dp->obj);
+			if (res != FR_OK) return res;	/* Load the object status */
+			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
+			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
+			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
+			res = store_xdir(&dj);			/* Store the object status */
+			if (res != FR_OK) return res;
+		}
+
+		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
+		return FR_OK;
+	}
+#endif
+	/* At the FAT12/16/32 */
+	mem_cpy(sn, dp->fn, 12);
+	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
+		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
+		for (n = 1; n < 100; n++) {
+			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
+			res = dir_find(dp);				/* Check if the name collides with existing SFN */
+			if (res != FR_OK) break;
+		}
+		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
+		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
+		dp->fn[NSFLAG] = sn[NSFLAG];
+	}
+
+	/* Create an SFN with/without LFNs. */
+	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
+	res = dir_alloc(dp, nent);		/* Allocate entries */
+	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
+		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
+		if (res == FR_OK) {
+			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
+			do {					/* Store LFN entries in bottom first */
+				res = move_window(fs, dp->sect);
+				if (res != FR_OK) break;
+				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
+				fs->wflag = 1;
+				res = dir_next(dp, 0);	/* Next entry */
+			} while (res == FR_OK && --nent);
+		}
+	}
+
+#else	/* Non LFN configuration */
+	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
+
+#endif
+
+	/* Set SFN entry */
+	if (res == FR_OK) {
+		res = move_window(fs, dp->sect);
+		if (res == FR_OK) {
+			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
+			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
+#if _USE_LFN != 0
+			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
+#endif
+			fs->wflag = 1;
+		}
+	}
+
+	return res;
+}
+
+#endif /* !_FS_READONLY */
+
+
+
+#if !_FS_READONLY && _FS_MINIMIZE == 0
+/*-----------------------------------------------------------------------*/
+/* Remove an object from the directory                                   */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
+	DIR* dp				/* Directory object pointing the entry to be removed */
+)
+{
+	FRESULT res;
+	FATFS *fs = dp->obj.fs;
+#if _USE_LFN != 0	/* LFN configuration */
+	DWORD last = dp->dptr;
+
+	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
+	if (res == FR_OK) {
+		do {
+			res = move_window(fs, dp->sect);
+			if (res != FR_OK) break;
+			/* Mark an entry 'deleted' */
+			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+				dp->dir[XDIR_Type] &= 0x7F;
+			} else {									/* At the FAT12/16/32 */
+				dp->dir[DIR_Name] = DDEM;
+			}
+			fs->wflag = 1;
+			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
+			res = dir_next(dp, 0);	/* Next entry */
+		} while (res == FR_OK);
+		if (res == FR_NO_FILE) res = FR_INT_ERR;
+	}
+#else			/* Non LFN configuration */
+
+	res = move_window(fs, dp->sect);
+	if (res == FR_OK) {
+		dp->dir[DIR_Name] = DDEM;
+		fs->wflag = 1;
+	}
+#endif
+
+	return res;
+}
+
+#endif /* !_FS_READONLY && _FS_MINIMIZE == 0 */
+
+
+
+#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
+/*-----------------------------------------------------------------------*/
+/* Get file information from directory entry                             */
+/*-----------------------------------------------------------------------*/
+
+static
+void get_fileinfo (		/* No return code */
+	DIR* dp,			/* Pointer to the directory object */
+	FILINFO* fno	 	/* Pointer to the file information to be filled */
+)
+{
+	UINT i, j;
+	TCHAR c;
+	DWORD tm;
+#if _USE_LFN != 0
+	WCHAR w, lfv;
+	FATFS *fs = dp->obj.fs;
+#endif
+
+
+	fno->fname[0] = 0;		/* Invaidate file info */
+	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
+
+#if _USE_LFN != 0	/* LFN configuration */
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		get_xdir_info(fs->dirbuf, fno);
+		return;
+	} else
+#endif
+	{	/* At the FAT12/16/32 */
+		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
+			i = j = 0;
+			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
+#if !_LFN_UNICODE
+				w = ff_convert(w, 0);		/* Unicode -> OEM */
+				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
+				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
+					fno->fname[i++] = (char)(w >> 8);
+				}
+#endif
+				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
+				fno->fname[i++] = (char)w;
+			}
+			fno->fname[i] = 0;	/* Terminate the LFN */
+		}
+	}
+
+	i = j = 0;
+	lfv = fno->fname[i];	/* LFN is exist if non-zero */
+	while (i < 11) {		/* Copy name body and extension */
+		c = (TCHAR)dp->dir[i++];
+		if (c == ' ') continue;				/* Skip padding spaces */
+		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
+		if (i == 9) {						/* Insert a . if extension is exist */
+			if (!lfv) fno->fname[j] = '.';
+			fno->altname[j++] = '.';
+		}
+#if _LFN_UNICODE
+		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
+			c = c << 8 | dp->dir[i++];
+		}
+		c = ff_convert(c, 1);	/* OEM -> Unicode */
+		if (!c) c = '?';
+#endif
+		fno->altname[j] = c;
+		if (!lfv) {
+			if (IsUpper(c) && (dp->dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY))) {
+				c += 0x20;			/* To lower */
+			}
+			fno->fname[j] = c;
+		}
+		j++;
+	}
+	if (!lfv) {
+		fno->fname[j] = 0;
+		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
+	}
+	fno->altname[j] = 0;	/* Terminate the SFN */
+
+#else	/* Non-LFN configuration */
+	i = j = 0;
+	while (i < 11) {		/* Copy name body and extension */
+		c = (TCHAR)dp->dir[i++];
+		if (c == ' ') continue;				/* Skip padding spaces */
+		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
+		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
+		fno->fname[j++] = c;
+	}
+	fno->fname[j] = 0;
+#endif
+
+	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
+	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
+	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
+	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
+}
+
+#endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
+
+
+
+#if _USE_FIND && _FS_MINIMIZE <= 1
+/*-----------------------------------------------------------------------*/
+/* Pattern matching                                                      */
+/*-----------------------------------------------------------------------*/
+
+static
+WCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
+	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
+)
+{
+#if !_LFN_UNICODE
+	WCHAR chr;
+
+	chr = (BYTE)*(*ptr)++;					/* Get a byte */
+	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
+#ifdef _EXCVT
+	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
+#else
+	if (IsDBCS1(chr) && IsDBCS2(**ptr)) {		/* Get DBC 2nd byte if needed */
+		chr = chr << 8 | (BYTE)*(*ptr)++;
+	}
+#endif
+	return chr;
+#else
+	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
+#endif
+}
+
+
+static
+int pattern_matching (	/* 0:not matched, 1:matched */
+	const TCHAR* pat,	/* Matching pattern */
+	const TCHAR* nam,	/* String to be tested */
+	int skip,			/* Number of pre-skip chars (number of ?s) */
+	int inf				/* Infinite search (* specified) */
+)
+{
+	const TCHAR *pp, *np;
+	WCHAR pc, nc;
+	int nm, nx;
+
+
+	while (skip--) {				/* Pre-skip name chars */
+		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
+	}
+	if (!*pat && inf) return 1;		/* (short circuit) */
+
+	do {
+		pp = pat; np = nam;			/* Top of pattern and name to match */
+		for (;;) {
+			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
+				nm = nx = 0;
+				do {				/* Analyze the wildcard chars */
+					if (*pp++ == '?') nm++; else nx = 1;
+				} while (*pp == '?' || *pp == '*');
+				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
+				nc = *np; break;	/* Branch mismatched */
+			}
+			pc = get_achar(&pp);	/* Get a pattern char */
+			nc = get_achar(&np);	/* Get a name char */
+			if (pc != nc) break;	/* Branch mismatched? */
+			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
+		}
+		get_achar(&nam);			/* nam++ */
+	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
+
+	return 0;
+}
+
+#endif /* _USE_FIND && _FS_MINIMIZE <= 1 */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Pick a top segment and create the object name in directory form       */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
+	DIR* dp,			/* Pointer to the directory object */
+	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
+)
+{
+#if _USE_LFN != 0	/* LFN configuration */
+	BYTE b, cf;
+	WCHAR w, *lfn;
+	UINT i, ni, si, di;
+	const TCHAR *p;
+
+	/* Create LFN in Unicode */
+	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
+	for (;;) {
+		w = p[si++];					/* Get a character */
+		if (w < ' ') break;				/* Break if end of the path name */
+		if (w == '/' || w == '\\') {	/* Break if a separator is found */
+			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
+			break;
+		}
+		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
+#if !_LFN_UNICODE
+		w &= 0xFF;
+		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
+			b = (BYTE)p[si++];			/* Get 2nd byte */
+			w = (w << 8) + b;			/* Create a DBC */
+			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
+		}
+		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
+		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
+#endif
+		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
+		lfn[di++] = w;					/* Store the Unicode character */
+	}
+	*path = &p[si];						/* Return pointer to the next segment */
+	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
+#if _FS_RPATH != 0
+	if ((di == 1 && lfn[di - 1] == '.') ||
+		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
+		lfn[di] = 0;
+		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
+			dp->fn[i] = (i < di) ? '.' : ' ';
+		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
+		return FR_OK;
+	}
+#endif
+	while (di) {						/* Snip off trailing spaces and dots if exist */
+		w = lfn[di - 1];
+		if (w != ' ' && w != '.') break;
+		di--;
+	}
+	lfn[di] = 0;						/* LFN is created */
+	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
+
+	/* Create SFN in directory form */
+	mem_set(dp->fn, ' ', 11);
+	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
+	if (si) cf |= NS_LOSS | NS_LFN;
+	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
+
+	b = i = 0; ni = 8;
+	for (;;) {
+		w = lfn[si++];					/* Get an LFN character */
+		if (!w) break;					/* Break on end of the LFN */
+		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
+			cf |= NS_LOSS | NS_LFN; continue;
+		}
+
+		if (i >= ni || si == di) {		/* Extension or end of SFN */
+			if (ni == 11) {				/* Long extension */
+				cf |= NS_LOSS | NS_LFN; break;
+			}
+			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
+			if (si > di) break;			/* No extension */
+			si = di; i = 8; ni = 11;	/* Enter extension section */
+			b <<= 2; continue;
+		}
+
+		if (w >= 0x80) {				/* Non ASCII character */
+#ifdef _EXCVT
+			w = ff_convert(w, 0);		/* Unicode -> OEM code */
+			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
+#else
+			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
+#endif
+			cf |= NS_LFN;				/* Force create LFN entry */
+		}
+
+		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
+			if (i >= ni - 1) {
+				cf |= NS_LOSS | NS_LFN; i = ni; continue;
+			}
+			dp->fn[i++] = (BYTE)(w >> 8);
+		} else {						/* SBC */
+			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
+				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
+			} else {
+				if (IsUpper(w)) {		/* ASCII large capital */
+					b |= 2;
+				} else {
+					if (IsLower(w)) {	/* ASCII small capital */
+						b |= 1; w -= 0x20;
+					}
+				}
+			}
+		}
+		dp->fn[i++] = (BYTE)w;
+	}
+
+	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
+
+	if (ni == 8) b <<= 2;
+	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
+	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
+		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
+		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
+	}
+
+	dp->fn[NSFLAG] = cf;	/* SFN is created */
+
+	return FR_OK;
+
+
+#else	/* _USE_LFN != 0 : Non-LFN configuration */
+	BYTE c, d, *sfn;
+	UINT ni, si, i;
+	const char *p;
+
+	/* Create file name in directory form */
+	p = *path; sfn = dp->fn;
+	mem_set(sfn, ' ', 11);
+	si = i = 0; ni = 8;
+#if _FS_RPATH != 0
+	if (p[si] == '.') { /* Is this a dot entry? */
+		for (;;) {
+			c = (BYTE)p[si++];
+			if (c != '.' || si >= 3) break;
+			sfn[i++] = c;
+		}
+		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
+		*path = p + si;								/* Return pointer to the next segment */
+		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
+		return FR_OK;
+	}
+#endif
+	for (;;) {
+		c = (BYTE)p[si++];
+		if (c <= ' ') break; 			/* Break if end of the path name */
+		if (c == '/' || c == '\\') {	/* Break if a separator is found */
+			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
+			break;
+		}
+		if (c == '.' || i >= ni) {		/* End of body or over size? */
+			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
+			i = 8; ni = 11;				/* Goto extension */
+			continue;
+		}
+		if (c >= 0x80) {				/* Extended character? */
+#ifdef _EXCVT
+			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
+#else
+#if !_DF1S
+			return FR_INVALID_NAME;		/* Reject extended characters (ASCII only cfg) */
+#endif
+#endif
+		}
+		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
+			d = (BYTE)p[si++];			/* Get 2nd byte */
+			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
+			sfn[i++] = c;
+			sfn[i++] = d;
+		} else {						/* SBC */
+			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
+			if (IsLower(c)) c -= 0x20;	/* To upper */
+			sfn[i++] = c;
+		}
+	}
+	*path = p + si;						/* Return pointer to the next segment */
+	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
+
+	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
+	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
+
+	return FR_OK;
+#endif /* _USE_LFN != 0 */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Follow a file path                                                    */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
+	DIR* dp,			/* Directory object to return last directory and found object */
+	const TCHAR* path	/* Full-path string to find a file or directory */
+)
+{
+	FRESULT res;
+	BYTE ns;
+	_FDID *obj = &dp->obj;
+	FATFS *fs = obj->fs;
+
+
+#if _FS_RPATH != 0
+	if (*path != '/' && *path != '\\') {	/* Without heading separator */
+		obj->sclust = fs->cdir;				/* Start from the current directory */
+	} else
+#endif
+	{										/* With heading separator */
+		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
+		obj->sclust = 0;					/* Start from the root directory */
+	}
+#if _FS_EXFAT && _FS_RPATH != 0
+	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
+		DIR dj;
+
+		obj->c_scl = fs->cdc_scl;
+		obj->c_size = fs->cdc_size;
+		obj->c_ofs = fs->cdc_ofs;
+		res = load_obj_dir(&dj, obj);
+		if (res != FR_OK) return res;
+		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
+		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
+	}
+#endif
+
+	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
+		dp->fn[NSFLAG] = NS_NONAME;
+		res = dir_sdi(dp, 0);
+
+	} else {								/* Follow path */
+		for (;;) {
+			res = create_name(dp, &path);	/* Get a segment name of the path */
+			if (res != FR_OK) break;
+			res = dir_find(dp);				/* Find an object with the segment name */
+			ns = dp->fn[NSFLAG];
+			if (res != FR_OK) {				/* Failed to find the object */
+				if (res == FR_NO_FILE) {	/* Object is not found */
+					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
+						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
+						dp->fn[NSFLAG] = NS_NONAME;
+						res = FR_OK;
+					} else {							/* Could not find the object */
+						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
+					}
+				}
+				break;
+			}
+			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
+			/* Get into the sub-directory */
+			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
+				res = FR_NO_PATH; break;
+			}
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				obj->c_scl = obj->sclust;		/* Save containing directory information for next dir */
+				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
+				obj->c_ofs = dp->blk_ofs;
+				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
+				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
+				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+			} else
+#endif
+			{
+				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
+			}
+		}
+	}
+
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get logical drive number from path name                               */
+/*-----------------------------------------------------------------------*/
+
+static
+int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
+	const TCHAR** path	/* Pointer to pointer to the path name */
+)
+{
+	const TCHAR *tp, *tt;
+	UINT i;
+	int vol = -1;
+#if _STR_VOLUME_ID		/* Find string drive id */
+	static const char* const str[] = {_VOLUME_STRS};
+	const char *sp;
+	char c;
+	TCHAR tc;
+#endif
+
+
+	if (*path) {	/* If the pointer is not a null */
+		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
+		if (*tt == ':') {	/* If a ':' is exist in the path name */
+			tp = *path;
+			i = *tp++ - '0'; 
+			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
+				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
+					vol = (int)i;
+					*path = ++tt;
+				}
+			}
+#if _STR_VOLUME_ID
+			 else {	/* No numeric drive number, find string drive id */
+				i = 0; tt++;
+				do {
+					sp = str[i]; tp = *path;
+					do {	/* Compare a string drive id with path name */
+						c = *sp++; tc = *tp++;
+						if (IsLower(tc)) tc -= 0x20;
+					} while (c && (TCHAR)c == tc);
+				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
+				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
+					vol = (int)i;
+					*path = tt;
+				}
+			}
+#endif
+			return vol;
+		}
+#if _FS_RPATH != 0 && _VOLUMES >= 2
+		vol = CurrVol;	/* Current drive */
+#else
+		vol = 0;		/* Drive 0 */
+#endif
+	}
+	return vol;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Load a sector and check if it is an FAT boot sector                   */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
+	FATFS* fs,	/* File system object */
+	DWORD sect	/* Sector# (lba) to check if it is an FAT-VBR or not */
+)
+{
+	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
+	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
+
+	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
+
+	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
+		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
+		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
+	}
+#if _FS_EXFAT
+	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
+#endif
+	return 2;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Find logical drive and check if the volume is mounted                 */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
+	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
+	FATFS** rfs,		/* Pointer to pointer to the found file system object */
+	BYTE mode			/* !=0: Check write protection for write access */
+)
+{
+	BYTE fmt, *pt;
+	int vol;
+	DSTATUS stat;
+	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
+	WORD nrsv;
+	FATFS *fs;
+	UINT i;
+
+
+	/* Get logical drive number from the path name */
+	*rfs = 0;
+	vol = get_ldnumber(path);
+	if (vol < 0) return FR_INVALID_DRIVE;
+
+	/* Check if the file system object is valid or not */
+	fs = FatFs[vol];					/* Get pointer to the file system object */
+	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
+
+	ENTER_FF(fs);						/* Lock the volume */
+	*rfs = fs;							/* Return pointer to the file system object */
+
+	mode &= ~FA_READ;					/* Desired access mode, write access or not */
+	if (fs->fs_type) {					/* If the volume has been mounted */
+		stat = disk_status(fs->drv);
+		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
+			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
+				return FR_WRITE_PROTECTED;
+			}
+			return FR_OK;				/* The file system object is valid */
+		}
+	}
+
+	/* The file system object is not valid. */
+	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
+
+	fs->fs_type = 0;					/* Clear the file system object */
+	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
+	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
+	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
+		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
+	}
+	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
+		return FR_WRITE_PROTECTED;
+	}
+#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
+	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
+	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
+#endif
+	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
+	bsect = 0;
+	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
+	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
+		for (i = 0; i < 4; i++) {			/* Get partition offset */
+			pt = fs->win + (MBR_Table + i * SZ_PTE);
+			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
+		}
+		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
+		if (i) i--;
+		do {								/* Find an FAT volume */
+			bsect = br[i];
+			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
+		} while (!LD2PT(vol) && fmt >= 2 && ++i < 4);
+	}
+	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
+	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
+
+	/* An FAT volume is found. Following code initializes the file system object */
+
+#if _FS_EXFAT
+	if (fmt == 1) {
+		QWORD maxlba;
+
+		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
+		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
+
+		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
+
+		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs))	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
+			return FR_NO_FILESYSTEM;
+
+		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
+		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
+
+		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
+
+		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
+		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
+
+		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
+		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
+
+		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
+		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
+		fs->n_fatent = nclst + 2;
+
+		/* Boundaries and Limits */
+		fs->volbase = bsect;
+		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
+		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
+		if (maxlba < fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
+		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
+
+		/* Check if bitmap location is in assumption (at the first cluster) */
+		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
+		for (i = 0; i < SS(fs); i += SZDIRE) {
+			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
+		}
+		if (i == SS(fs)) return FR_NO_FILESYSTEM;
+#if !_FS_READONLY
+		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
+#endif
+		fmt = FS_EXFAT;			/* FAT sub-type */
+	} else
+#endif	/* _FS_EXFAT */
+	{
+		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
+
+		fasize = ld_word(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
+		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
+		fs->fsize = fasize;
+
+		fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FATs */
+		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
+		fasize *= fs->n_fats;								/* Number of sectors for FAT area */
+
+		fs->csize = fs->win[BPB_SecPerClus];				/* Cluster size */
+		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
+
+		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
+		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
+
+		tsect = ld_word(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
+		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
+
+		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
+		if (nrsv == 0) return FR_NO_FILESYSTEM;				/* (Must not be 0) */
+
+		/* Determine the FAT sub type */
+		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
+		if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
+		nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
+		if (nclst == 0) return FR_NO_FILESYSTEM;			/* (Invalid volume size) */
+		fmt = FS_FAT32;
+		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
+		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
+
+		/* Boundaries and Limits */
+		fs->n_fatent = nclst + 2;							/* Number of FAT entries */
+		fs->volbase = bsect;								/* Volume start sector */
+		fs->fatbase = bsect + nrsv; 						/* FAT start sector */
+		fs->database = bsect + sysect;						/* Data start sector */
+		if (fmt == FS_FAT32) {
+			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
+			if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
+			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
+			szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
+		} else {
+			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
+			fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
+			szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
+				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
+		}
+		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
+
+#if !_FS_READONLY
+		/* Get FSINFO if available */
+		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
+		fs->fsi_flag = 0x80;
+#if (_FS_NOFSINFO & 3) != 3
+		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
+			&& ld_word(fs->win + BPB_FSInfo32) == 1
+			&& move_window(fs, bsect + 1) == FR_OK)
+		{
+			fs->fsi_flag = 0;
+			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
+				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
+				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
+			{
+#if (_FS_NOFSINFO & 1) == 0
+				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
+#endif
+#if (_FS_NOFSINFO & 2) == 0
+				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
+#endif
+			}
+		}
+#endif	/* (_FS_NOFSINFO & 3) != 3 */
+#endif	/* !_FS_READONLY */
+	}
+
+	fs->fs_type = fmt;	/* FAT sub-type */
+	fs->id = ++Fsid;	/* File system mount ID */
+#if _USE_LFN == 1
+	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
+#if _FS_EXFAT
+	fs->dirbuf = DirBuf;	/* Static directory block working buuffer */
+#endif
+#endif
+#if _FS_RPATH != 0
+	fs->cdir = 0;		/* Initialize current directory */
+#endif
+#if _FS_LOCK != 0		/* Clear file lock semaphores */
+	clear_lock(fs);
+#endif
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Check if the file/directory object is valid or not                    */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
+	void* dfp,		/* Pointer to the FIL/DIR object to check validity */
+	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
+)
+{
+	_FDID *obj = (_FDID*)dfp;	/* Assuming .obj in the FIL/DIR is the first member */
+	FRESULT res;
+
+
+	if (!dfp || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
+		*fs = 0;				/* The object is invalid */
+		res = FR_INVALID_OBJECT;
+	} else {
+		*fs = obj->fs;			/* Owner file sytem object */
+		ENTER_FF(obj->fs);		/* Lock file system */
+		res = FR_OK;
+	}
+	return res;
+}
+
+
+
+
+/*---------------------------------------------------------------------------
+
+   Public Functions (FatFs API)
+
+----------------------------------------------------------------------------*/
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Mount/Unmount a Logical Drive                                         */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mount (
+	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
+	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
+	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
+)
+{
+	FATFS *cfs;
+	int vol;
+	FRESULT res;
+	const TCHAR *rp = path;
+
+
+	vol = get_ldnumber(&rp);
+	if (vol < 0) return FR_INVALID_DRIVE;
+	cfs = FatFs[vol];					/* Pointer to fs object */
+
+	if (cfs) {
+#if _FS_LOCK != 0
+		clear_lock(cfs);
+#endif
+#if _FS_REENTRANT						/* Discard sync object of the current volume */
+		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
+#endif
+		cfs->fs_type = 0;				/* Clear old fs object */
+	}
+
+	if (fs) {
+		fs->fs_type = 0;				/* Clear new fs object */
+#if _FS_REENTRANT						/* Create sync object for the new volume */
+		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
+#endif
+	}
+	FatFs[vol] = fs;					/* Register new fs object */
+
+	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
+
+	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Open or Create a File                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_open (
+	FIL* fp,			/* Pointer to the blank file object */
+	const TCHAR* path,	/* Pointer to the file name */
+	BYTE mode			/* Access mode and file open mode flags */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+#if !_FS_READONLY
+	DWORD dw, cl, bcs, clst, sc;
+	FSIZE_t ofs;
+#endif
+	DEF_NAMBUF
+
+
+	if (!fp) return FR_INVALID_OBJECT;
+
+	/* Get logical drive number */
+	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
+	res = find_volume(&path, &fs, mode);
+	if (res == FR_OK) {
+		dj.obj.fs = fs;
+		INIT_NAMBUF(fs);
+		res = follow_path(&dj, path);	/* Follow the file path */
+#if !_FS_READONLY	/* R/W configuration */
+		if (res == FR_OK) {
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
+				res = FR_INVALID_NAME;
+			}
+#if _FS_LOCK != 0
+			else {
+				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+			}
+#endif
+		}
+		/* Create or Open a file */
+		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
+			if (res != FR_OK) {					/* No file, create new */
+				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
+#if _FS_LOCK != 0
+					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
+#else
+					res = dir_register(&dj);
+#endif
+				mode |= FA_CREATE_ALWAYS;		/* File is created */
+			}
+			else {								/* Any object is already existing */
+				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
+					res = FR_DENIED;
+				} else {
+					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
+				}
+			}
+			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
+				dw = GET_FATTIME();
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					/* Get current allocation info */
+					fp->obj.fs = fs;
+					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
+					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
+					/* Initialize directory entry block */
+					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
+					fs->dirbuf[XDIR_CrtTime10] = 0;
+					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
+					fs->dirbuf[XDIR_ModTime10] = 0;
+					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
+					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
+					st_qword(fs->dirbuf + XDIR_FileSize, 0);
+					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
+					fs->dirbuf[XDIR_GenFlags] = 1;
+					res = store_xdir(&dj);
+					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
+						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
+						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
+					}
+				} else
+#endif
+				{
+					/* Clean directory info */
+					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
+					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
+					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
+					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
+					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
+					st_dword(dj.dir + DIR_FileSize, 0);
+					fs->wflag = 1;
+
+					if (cl) {							/* Remove the cluster chain if exist */
+						dw = fs->winsect;
+						res = remove_chain(&dj.obj, cl, 0);
+						if (res == FR_OK) {
+							res = move_window(fs, dw);
+							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
+						}
+					}
+				}
+			}
+		}
+		else {	/* Open an existing file */
+			if (res == FR_OK) {					/* Following succeeded */
+				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
+					res = FR_NO_FILE;
+				} else {
+					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
+						res = FR_DENIED;
+					}
+				}
+			}
+		}
+		if (res == FR_OK) {
+			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
+				mode |= FA_MODIFIED;
+			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
+			fp->dir_ptr = dj.dir;
+#if _FS_LOCK != 0
+			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+			if (!fp->obj.lockid) res = FR_INT_ERR;
+#endif
+		}
+#else		/* R/O configuration */
+		if (res == FR_OK) {
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
+				res = FR_INVALID_NAME;
+			} else {
+				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
+					res = FR_NO_FILE;
+				}
+			}
+		}
+#endif
+
+		if (res == FR_OK) {
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Get allocation info */
+				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
+				fp->obj.c_scl = dj.obj.sclust;
+				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
+				fp->obj.c_ofs = dj.blk_ofs;
+			} else
+#endif
+			{
+				fp->obj.sclust = ld_clust(fs, dj.dir);				/* Get allocation info */
+				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
+			}
+#if _USE_FASTSEEK
+			fp->cltbl = 0;			/* Disable fast seek mode */
+#endif
+			fp->obj.fs = fs;	 	/* Validate the file object */
+			fp->obj.id = fs->id;
+			fp->flag = mode;		/* Set file access mode */
+			fp->err = 0;			/* Clear error flag */
+			fp->sect = 0;			/* Invalidate current data sector */
+			fp->fptr = 0;			/* Set file pointer top of the file */
+#if !_FS_READONLY
+#if !_FS_TINY
+			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
+#endif
+			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
+				fp->fptr = fp->obj.objsize;			/* Offset to seek */
+				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
+				clst = fp->obj.sclust;				/* Follow the cluster chain */
+				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
+					clst = get_fat(&fp->obj, clst);
+					if (clst <= 1) res = FR_INT_ERR;
+					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
+				}
+				fp->clust = clst;
+				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
+					if ((sc = clust2sect(fs, clst)) == 0) {
+						res = FR_INT_ERR;
+					} else {
+						fp->sect = sc + (DWORD)(ofs / SS(fs));
+#if !_FS_TINY
+						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
+#endif
+					}
+				}
+			}
+#endif
+		}
+
+		FREE_NAMBUF();
+	}
+
+	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read File                                                             */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_read (
+	FIL* fp, 	/* Pointer to the file object */
+	void* buff,	/* Pointer to data buffer */
+	UINT btr,	/* Number of bytes to read */
+	UINT* br	/* Pointer to number of bytes read */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD clst, sect;
+	FSIZE_t remain;
+	UINT rcnt, cc, csect;
+	BYTE *rbuff = (BYTE*)buff;
+
+
+	*br = 0;	/* Clear read byte counter */
+	res = validate(fp, &fs);
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
+	remain = fp->obj.objsize - fp->fptr;
+	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
+
+	for ( ;  btr;								/* Repeat until all data read */
+		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
+		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
+			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
+			if (csect == 0) {					/* On the cluster boundary? */
+				if (fp->fptr == 0) {			/* On the top of the file? */
+					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
+				} else {						/* Middle or end of the file */
+#if _USE_FASTSEEK
+					if (fp->cltbl) {
+						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
+					} else
+#endif
+					{
+						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
+					}
+				}
+				if (clst < 2) ABORT(fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+				fp->clust = clst;				/* Update current cluster */
+			}
+			sect = clust2sect(fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fs, FR_INT_ERR);
+			sect += csect;
+			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
+			if (cc) {							/* Read maximum contiguous sectors directly */
+				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
+					cc = fs->csize - csect;
+				}
+				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) {
+					ABORT(fs, FR_DISK_ERR);
+				}
+#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
+#if _FS_TINY
+				if (fs->wflag && fs->winsect - sect < cc) {
+					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
+				}
+#else
+				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
+					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
+				}
+#endif
+#endif
+				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
+				continue;
+			}
+#if !_FS_TINY
+			if (fp->sect != sect) {			/* Load data sector if not in cache */
+#if !_FS_READONLY
+				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
+					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+					fp->flag &= ~FA_DIRTY;
+				}
+#endif
+				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	{	/* Fill sector cache */
+					ABORT(fs, FR_DISK_ERR);
+				}
+			}
+#endif
+			fp->sect = sect;
+		}
+		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
+		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
+#if _FS_TINY
+		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
+		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
+#else
+		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
+#endif
+	}
+
+	LEAVE_FF(fs, FR_OK);
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Write File                                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_write (
+	FIL* fp,			/* Pointer to the file object */
+	const void* buff,	/* Pointer to the data to be written */
+	UINT btw,			/* Number of bytes to write */
+	UINT* bw			/* Pointer to number of bytes written */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD clst, sect;
+	UINT wcnt, cc, csect;
+	const BYTE *wbuff = (const BYTE*)buff;
+
+
+	*bw = 0;	/* Clear write byte counter */
+	res = validate(fp, &fs);
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
+
+	/* Check fptr wrap-around (file size cannot exceed the limit on each FAT specs) */
+	if ((_FS_EXFAT && fs->fs_type == FS_EXFAT && fp->fptr + btw < fp->fptr)
+		|| (DWORD)fp->fptr + btw < (DWORD)fp->fptr) {
+		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
+	}
+
+	for ( ;  btw;							/* Repeat until all data written */
+		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
+		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
+			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
+			if (csect == 0) {				/* On the cluster boundary? */
+				if (fp->fptr == 0) {		/* On the top of the file? */
+					clst = fp->obj.sclust;	/* Follow from the origin */
+					if (clst == 0) {		/* If no cluster is allocated, */
+						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
+					}
+				} else {					/* On the middle or end of the file */
+#if _USE_FASTSEEK
+					if (fp->cltbl) {
+						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
+					} else
+#endif
+					{
+						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
+					}
+				}
+				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
+				if (clst == 1) ABORT(fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+				fp->clust = clst;			/* Update current cluster */
+				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
+			}
+#if _FS_TINY
+			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
+#else
+			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+				fp->flag &= ~FA_DIRTY;
+			}
+#endif
+			sect = clust2sect(fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fs, FR_INT_ERR);
+			sect += csect;
+			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
+			if (cc) {						/* Write maximum contiguous sectors directly */
+				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
+					cc = fs->csize - csect;
+				}
+				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) {
+					ABORT(fs, FR_DISK_ERR);
+				}
+#if _FS_MINIMIZE <= 2
+#if _FS_TINY
+				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
+					fs->wflag = 0;
+				}
+#else
+				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
+					fp->flag &= ~FA_DIRTY;
+				}
+#endif
+#endif
+				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
+				continue;
+			}
+#if _FS_TINY
+			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling at growing edge */
+				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
+				fs->winsect = sect;
+			}
+#else
+			if (fp->sect != sect) {		/* Fill sector cache with file data */
+				if (fp->fptr < fp->obj.objsize &&
+					disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
+						ABORT(fs, FR_DISK_ERR);
+				}
+			}
+#endif
+			fp->sect = sect;
+		}
+		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
+		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
+#if _FS_TINY
+		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
+		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
+		fs->wflag = 1;
+#else
+		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
+		fp->flag |= FA_DIRTY;
+#endif
+	}
+
+	fp->flag |= FA_MODIFIED;						/* Set file change flag */
+
+	LEAVE_FF(fs, FR_OK);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Synchronize the File                                                  */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_sync (
+	FIL* fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD tm;
+	BYTE *dir;
+	DEF_NAMBUF
+
+
+	res = validate(fp, &fs);	/* Check validity of the object */
+	if (res == FR_OK) {
+		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
+#if !_FS_TINY
+			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
+				fp->flag &= ~FA_DIRTY;
+			}
+#endif
+			/* Update the directory entry */
+			tm = GET_FATTIME();				/* Modified time */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				res = fill_fat_chain(&fp->obj);	/* Create FAT chain if needed */
+				if (res == FR_OK) {
+					DIR dj;
+
+					INIT_NAMBUF(fs);
+					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
+					if (res == FR_OK) {
+						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive bit */
+						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation info */
+						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
+						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
+						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
+						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
+						fs->dirbuf[XDIR_ModTime10] = 0;
+						st_dword(fs->dirbuf + XDIR_AccTime, 0);
+						res = store_xdir(&dj);	/* Restore it to the directory */
+						if (res == FR_OK) {
+							res = sync_fs(fs);
+							fp->flag &= ~FA_MODIFIED;
+						}
+					}
+					FREE_NAMBUF();
+				}
+			} else
+#endif
+			{
+				res = move_window(fs, fp->dir_sect);
+				if (res == FR_OK) {
+					dir = fp->dir_ptr;
+					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
+					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
+					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
+					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
+					st_word(dir + DIR_LstAccDate, 0);
+					fs->wflag = 1;
+					res = sync_fs(fs);					/* Restore it to the directory */
+					fp->flag &= ~FA_MODIFIED;
+				}
+			}
+		}
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Close File                                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_close (
+	FIL* fp		/* Pointer to the file object to be closed */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+
+#if !_FS_READONLY
+	res = f_sync(fp);					/* Flush cached data */
+	if (res == FR_OK)
+#endif
+	{
+		res = validate(fp, &fs);	/* Lock volume */
+		if (res == FR_OK) {
+#if _FS_LOCK != 0
+			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
+			if (res == FR_OK)
+#endif
+			{
+				fp->obj.fs = 0;			/* Invalidate file object */
+			}
+#if _FS_REENTRANT
+			unlock_fs(fs, FR_OK);		/* Unlock volume */
+#endif
+		}
+	}
+	return res;
+}
+
+
+
+
+#if _FS_RPATH >= 1
+/*-----------------------------------------------------------------------*/
+/* Change Current Directory or Current Drive, Get Current Directory      */
+/*-----------------------------------------------------------------------*/
+
+#if _VOLUMES >= 2
+FRESULT f_chdrive (
+	const TCHAR* path		/* Drive number */
+)
+{
+	int vol;
+
+
+	vol = get_ldnumber(&path);
+	if (vol < 0) return FR_INVALID_DRIVE;
+
+	CurrVol = (BYTE)vol;
+
+	return FR_OK;
+}
+#endif
+
+
+FRESULT f_chdir (
+	const TCHAR* path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	DEF_NAMBUF
+
+	/* Get logical drive number */
+	res = find_volume(&path, &fs, 0);
+	if (res == FR_OK) {
+		dj.obj.fs = fs;
+		INIT_NAMBUF(fs);
+		res = follow_path(&dj, path);		/* Follow the path */
+		if (res == FR_OK) {					/* Follow completed */
+			if (dj.fn[NSFLAG] & NS_NONAME) {
+				fs->cdir = dj.obj.sclust;	/* It is the start directory itself */
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					fs->cdc_scl = dj.obj.c_scl;
+					fs->cdc_size = dj.obj.c_size;
+					fs->cdc_ofs = dj.obj.c_ofs;
+				}
+#endif
+			} else {
+				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
+#if _FS_EXFAT
+					if (fs->fs_type == FS_EXFAT) {
+						fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
+						fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
+						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
+						fs->cdc_ofs = dj.blk_ofs;
+					} else
+#endif
+					{
+						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
+					}
+				} else {
+					res = FR_NO_PATH;		/* Reached but a file */
+				}
+			}
+		}
+		FREE_NAMBUF();
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+#if _FS_RPATH >= 2
+FRESULT f_getcwd (
+	TCHAR* buff,	/* Pointer to the directory path */
+	UINT len		/* Size of path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	UINT i, n;
+	DWORD ccl;
+	TCHAR *tp;
+	FILINFO fno;
+	DEF_NAMBUF
+
+
+	*buff = 0;
+	/* Get logical drive number */
+	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
+	if (res == FR_OK) {
+		dj.obj.fs = fs;
+		INIT_NAMBUF(fs);
+		i = len;			/* Bottom of buffer (directory stack base) */
+		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
+			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
+			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
+				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
+				if (res != FR_OK) break;
+				res = move_window(fs, dj.sect);
+				if (res != FR_OK) break;
+				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
+				res = dir_sdi(&dj, 0);
+				if (res != FR_OK) break;
+				do {							/* Find the entry links to the child directory */
+					res = dir_read(&dj, 0);
+					if (res != FR_OK) break;
+					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
+					res = dir_next(&dj, 0);
+				} while (res == FR_OK);
+				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
+				if (res != FR_OK) break;
+				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
+				for (n = 0; fno.fname[n]; n++) ;
+				if (i < n + 3) {
+					res = FR_NOT_ENOUGH_CORE; break;
+				}
+				while (n) buff[--i] = fno.fname[--n];
+				buff[--i] = '/';
+			}
+		}
+		tp = buff;
+		if (res == FR_OK) {
+#if _VOLUMES >= 2
+			*tp++ = '0' + CurrVol;			/* Put drive number */
+			*tp++ = ':';
+#endif
+			if (i == len) {					/* Root-directory */
+				*tp++ = '/';
+			} else {						/* Sub-directroy */
+				do		/* Add stacked path str */
+					*tp++ = buff[i++];
+				while (i < len);
+			}
+		}
+		*tp = 0;
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif /* _FS_RPATH >= 2 */
+#endif /* _FS_RPATH >= 1 */
+
+
+
+#if _FS_MINIMIZE <= 2
+/*-----------------------------------------------------------------------*/
+/* Seek File R/W Pointer                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_lseek (
+	FIL* fp,		/* Pointer to the file object */
+	FSIZE_t ofs		/* File pointer from top of file */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD clst, bcs, nsect;
+	FSIZE_t ifptr;
+#if _USE_FASTSEEK
+	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
+#endif
+
+	res = validate(fp, &fs);		/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+#if _USE_FASTSEEK
+	if (fp->cltbl) {	/* Fast seek */
+		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
+			tbl = fp->cltbl;
+			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
+			cl = fp->obj.sclust;		/* Origin of the chain */
+			if (cl) {
+				do {
+					/* Get a fragment */
+					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
+					do {
+						pcl = cl; ncl++;
+						cl = get_fat(&fp->obj, cl);
+						if (cl <= 1) ABORT(fs, FR_INT_ERR);
+						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+					} while (cl == pcl + 1);
+					if (ulen <= tlen) {		/* Store the length and top of the fragment */
+						*tbl++ = ncl; *tbl++ = tcl;
+					}
+				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
+			}
+			*fp->cltbl = ulen;	/* Number of items used */
+			if (ulen <= tlen) {
+				*tbl = 0;		/* Terminate table */
+			} else {
+				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
+			}
+		} else {						/* Fast seek */
+			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
+			fp->fptr = ofs;				/* Set file pointer */
+			if (ofs) {
+				fp->clust = clmt_clust(fp, ofs - 1);
+				dsc = clust2sect(fs, fp->clust);
+				if (!dsc) ABORT(fs, FR_INT_ERR);
+				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
+				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
+#if !_FS_TINY
+#if !_FS_READONLY
+					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
+						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fp, FR_DISK_ERR);
+						fp->flag &= ~FA_DIRTY;
+					}
+#endif
+					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) {	/* Load current sector */
+						ABORT(fs, FR_DISK_ERR);
+					}
+#endif
+					fp->sect = dsc;
+				}
+			}
+		}
+	} else
+#endif
+
+	/* Normal Seek */
+	{
+		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
+			ofs = fp->obj.objsize;
+		}
+		ifptr = fp->fptr;
+		fp->fptr = nsect = 0;
+		if (ofs) {
+			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
+			if (ifptr > 0 &&
+				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
+				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
+				ofs -= fp->fptr;
+				clst = fp->clust;
+			} else {									/* When seek to back cluster, */
+				clst = fp->obj.sclust;					/* start from the first cluster */
+#if !_FS_READONLY
+				if (clst == 0) {						/* If no cluster chain, create a new chain */
+					clst = create_chain(&fp->obj, 0);
+					if (clst == 1) ABORT(fs, FR_INT_ERR);
+					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+					fp->obj.sclust = clst;
+				}
+#endif
+				fp->clust = clst;
+			}
+			if (clst != 0) {
+				while (ofs > bcs) {						/* Cluster following loop */
+#if !_FS_READONLY
+					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
+						clst = create_chain(&fp->obj, clst);	/* Force stretch if in write mode */
+						if (clst == 0) {				/* When disk gets full, clip file size */
+							ofs = bcs; break;
+						}
+					} else
+#endif
+						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
+					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
+					fp->clust = clst;
+					fp->fptr += bcs;
+					ofs -= bcs;
+				}
+				fp->fptr += ofs;
+				if (ofs % SS(fs)) {
+					nsect = clust2sect(fs, clst);	/* Current sector */
+					if (!nsect) ABORT(fs, FR_INT_ERR);
+					nsect += (DWORD)(ofs / SS(fs));
+				}
+			}
+		}
+		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
+#if !_FS_TINY
+#if !_FS_READONLY
+			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+				fp->flag &= ~FA_DIRTY;
+			}
+#endif
+			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) {	/* Fill sector cache */
+				ABORT(fs, FR_DISK_ERR);
+			}
+#endif
+			fp->sect = nsect;
+		}
+#if !_FS_READONLY
+		if (fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
+			fp->obj.objsize = fp->fptr;
+			fp->flag |= FA_MODIFIED;
+		}
+#endif
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+#if _FS_MINIMIZE <= 1
+/*-----------------------------------------------------------------------*/
+/* Create a Directory Object                                             */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_opendir (
+	DIR* dp,			/* Pointer to directory object to create */
+	const TCHAR* path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	_FDID *obj;
+	DEF_NAMBUF
+
+
+	if (!dp) return FR_INVALID_OBJECT;
+
+	/* Get logical drive number */
+	obj = &dp->obj;
+	res = find_volume(&path, &fs, 0);
+	if (res == FR_OK) {
+		obj->fs = fs;
+		INIT_NAMBUF(fs);
+		res = follow_path(dp, path);			/* Follow the path to the directory */
+		if (res == FR_OK) {						/* Follow completed */
+			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
+				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
+#if _FS_EXFAT
+					if (fs->fs_type == FS_EXFAT) {
+						obj->c_scl = obj->sclust;	/* Save containing directory inforamation */
+						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
+						obj->c_ofs = dp->blk_ofs;
+						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object location and status */
+						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
+					} else
+#endif
+					{
+						obj->sclust = ld_clust(fs, dp->dir);	/* Get object location */
+					}
+				} else {						/* This object is a file */
+					res = FR_NO_PATH;
+				}
+			}
+			if (res == FR_OK) {
+				obj->id = fs->id;
+				res = dir_sdi(dp, 0);			/* Rewind directory */
+#if _FS_LOCK != 0
+				if (res == FR_OK) {
+					if (obj->sclust) {
+						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
+						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
+					} else {
+						obj->lockid = 0;	/* Root directory need not to be locked */
+					}
+				}
+#endif
+			}
+		}
+		FREE_NAMBUF();
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
+	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Close Directory                                                       */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_closedir (
+	DIR *dp		/* Pointer to the directory object to be closed */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+
+
+	res = validate(dp, &fs);
+	if (res == FR_OK) {
+#if _FS_LOCK != 0
+		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
+			res = dec_lock(dp->obj.lockid);
+		}
+		if (res == FR_OK)
+#endif
+		{
+			dp->obj.fs = 0;			/* Invalidate directory object */
+		}
+#if _FS_REENTRANT
+		unlock_fs(fs, FR_OK);		/* Unlock volume */
+#endif
+	}
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Directory Entries in Sequence                                    */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_readdir (
+	DIR* dp,			/* Pointer to the open directory object */
+	FILINFO* fno		/* Pointer to file information to return */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DEF_NAMBUF
+
+
+	res = validate(dp, &fs);	/* Check validity of the object */
+	if (res == FR_OK) {
+		if (!fno) {
+			res = dir_sdi(dp, 0);			/* Rewind the directory object */
+		} else {
+			INIT_NAMBUF(fs);
+			res = dir_read(dp, 0);			/* Read an item */
+			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
+			if (res == FR_OK) {				/* A valid entry is found */
+				get_fileinfo(dp, fno);		/* Get the object information */
+				res = dir_next(dp, 0);		/* Increment index for next */
+				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
+			}
+			FREE_NAMBUF();
+		}
+	}
+	LEAVE_FF(fs, res);
+}
+
+
+
+#if _USE_FIND
+/*-----------------------------------------------------------------------*/
+/* Find Next File                                                        */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_findnext (
+	DIR* dp,		/* Pointer to the open directory object */
+	FILINFO* fno	/* Pointer to the file information structure */
+)
+{
+	FRESULT res;
+
+
+	for (;;) {
+		res = f_readdir(dp, fno);		/* Get a directory item */
+		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
+		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
+#if _USE_LFN != 0 && _USE_FIND == 2
+		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
+#endif
+	}
+	return res;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Find First File                                                       */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_findfirst (
+	DIR* dp,				/* Pointer to the blank directory object */
+	FILINFO* fno,			/* Pointer to the file information structure */
+	const TCHAR* path,		/* Pointer to the directory to open */
+	const TCHAR* pattern	/* Pointer to the matching pattern */
+)
+{
+	FRESULT res;
+
+
+	dp->pat = pattern;		/* Save pointer to pattern string */
+	res = f_opendir(dp, path);		/* Open the target directory */
+	if (res == FR_OK) {
+		res = f_findnext(dp, fno);	/* Find the first item */
+	}
+	return res;
+}
+
+#endif	/* _USE_FIND */
+
+
+
+#if _FS_MINIMIZE == 0
+/*-----------------------------------------------------------------------*/
+/* Get File Status                                                       */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_stat (
+	const TCHAR* path,	/* Pointer to the file path */
+	FILINFO* fno		/* Pointer to file information to return */
+)
+{
+	FRESULT res;
+	DIR dj;
+	DEF_NAMBUF
+
+
+	/* Get logical drive number */
+	res = find_volume(&path, &dj.obj.fs, 0);
+	if (res == FR_OK) {
+		INIT_NAMBUF(dj.obj.fs);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		if (res == FR_OK) {				/* Follow completed */
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
+				res = FR_INVALID_NAME;
+			} else {							/* Found an object */
+				if (fno) get_fileinfo(&dj, fno);
+			}
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(dj.obj.fs, res);
+}
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Get Number of Free Clusters                                           */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_getfree (
+	const TCHAR* path,	/* Path name of the logical drive number */
+	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
+	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD nfree, clst, sect, stat;
+	UINT i;
+	BYTE *p;
+	_FDID obj;
+
+
+	/* Get logical drive number */
+	res = find_volume(&path, &fs, 0);
+	if (res == FR_OK) {
+		*fatfs = fs;				/* Return ptr to the fs object */
+		/* If free_clst is valid, return it without full cluster scan */
+		if (fs->free_clst <= fs->n_fatent - 2) {
+			*nclst = fs->free_clst;
+		} else {
+			/* Get number of free clusters */
+			nfree = 0;
+			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
+				clst = 2; obj.fs = fs;
+				do {
+					stat = get_fat(&obj, clst);
+					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
+					if (stat == 1) { res = FR_INT_ERR; break; }
+					if (stat == 0) nfree++;
+				} while (++clst < fs->n_fatent);
+			} else {
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan bitmap table */
+					BYTE bm;
+					UINT b;
+
+					clst = fs->n_fatent - 2;
+					sect = fs->database;
+					i = 0;
+					do {
+						if (i == 0 && (res = move_window(fs, sect++)) != FR_OK) break;
+						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
+							if (!(bm & 1)) nfree++;
+							bm >>= 1;
+						}
+						i = (i + 1) % SS(fs);
+					} while (clst);
+				} else
+#endif
+				{	/* FAT16/32: Sector alighed FAT entries */
+					clst = fs->n_fatent; sect = fs->fatbase;
+					i = 0; p = 0;
+					do {
+						if (i == 0) {
+							res = move_window(fs, sect++);
+							if (res != FR_OK) break;
+							p = fs->win;
+							i = SS(fs);
+						}
+						if (fs->fs_type == FS_FAT16) {
+							if (ld_word(p) == 0) nfree++;
+							p += 2; i -= 2;
+						} else {
+							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
+							p += 4; i -= 4;
+						}
+					} while (--clst);
+				}
+			}
+			*nclst = nfree;			/* Return the free clusters */
+			fs->free_clst = nfree;	/* Now free_clst is valid */
+			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
+		}
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Truncate File                                                         */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_truncate (
+	FIL* fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD ncl;
+
+
+	res = validate(fp, &fs);	/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
+
+	if (fp->obj.objsize > fp->fptr) {
+		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
+			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
+			fp->obj.sclust = 0;
+		} else {				/* When truncate a part of the file, remove remaining clusters */
+			ncl = get_fat(&fp->obj, fp->clust);
+			res = FR_OK;
+			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
+			if (ncl == 1) res = FR_INT_ERR;
+			if (res == FR_OK && ncl < fs->n_fatent) {
+				res = remove_chain(&fp->obj, ncl, fp->clust);
+			}
+		}
+		fp->obj.objsize = fp->fptr;	/* Set file size to current R/W point */
+		fp->flag |= FA_MODIFIED;
+#if !_FS_TINY
+		if (res == FR_OK && (fp->flag & FA_DIRTY)) {
+			if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+				res = FR_DISK_ERR;
+			} else {
+				fp->flag &= ~FA_DIRTY;
+			}
+		}
+#endif
+		if (res != FR_OK) ABORT(fs, res);
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Delete a File/Directory                                               */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_unlink (
+	const TCHAR* path		/* Pointer to the file or directory path */
+)
+{
+	FRESULT res;
+	DIR dj, sdj;
+	DWORD dclst = 0;
+	FATFS *fs;
+#if _FS_EXFAT
+	_FDID obj;
+#endif
+	DEF_NAMBUF
+
+
+	/* Get logical drive number */
+	res = find_volume(&path, &fs, FA_WRITE);
+	dj.obj.fs = fs;
+	if (res == FR_OK) {
+		INIT_NAMBUF(fs);
+		res = follow_path(&dj, path);		/* Follow the file path */
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
+			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
+		}
+#if _FS_LOCK != 0
+		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
+#endif
+		if (res == FR_OK) {					/* The object is accessible */
+			if (dj.fn[NSFLAG] & NS_NONAME) {
+				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
+			} else {
+				if (dj.obj.attr & AM_RDO) {
+					res = FR_DENIED;		/* Cannot remove R/O object */
+				}
+			}
+			if (res == FR_OK) {
+#if _FS_EXFAT
+				obj.fs = fs;
+				if (fs->fs_type == FS_EXFAT) {
+					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
+					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
+				} else
+#endif
+				{
+					dclst = ld_clust(fs, dj.dir);
+				}
+				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory ? */
+#if _FS_RPATH != 0
+					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
+						res = FR_DENIED;
+					} else
+#endif
+					{
+						sdj.obj.fs = fs;						/* Open the sub-directory */
+						sdj.obj.sclust = dclst;
+#if _FS_EXFAT
+						if (fs->fs_type == FS_EXFAT) {
+							sdj.obj.objsize = obj.objsize;
+							sdj.obj.stat = obj.stat;
+						}
+#endif
+						res = dir_sdi(&sdj, 0);
+						if (res == FR_OK) {
+							res = dir_read(&sdj, 0);			/* Read an item */
+							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
+							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
+						}
+					}
+				}
+			}
+			if (res == FR_OK) {
+				res = dir_remove(&dj);			/* Remove the directory entry */
+				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
+#if _FS_EXFAT
+					res = remove_chain(&obj, dclst, 0);
+#else
+					res = remove_chain(&dj.obj, dclst, 0);
+#endif
+				}
+				if (res == FR_OK) res = sync_fs(fs);
+			}
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Create a Directory                                                    */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mkdir (
+	const TCHAR* path		/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	BYTE *dir;
+	UINT n;
+	DWORD dsc, dcl, pcl, tm;
+	DEF_NAMBUF
+
+
+	/* Get logical drive number */
+	res = find_volume(&path, &fs, FA_WRITE);
+	dj.obj.fs = fs;
+	if (res == FR_OK) {
+		INIT_NAMBUF(fs);
+		res = follow_path(&dj, path);			/* Follow the file path */
+		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
+		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
+			res = FR_INVALID_NAME;
+		}
+		if (res == FR_NO_FILE) {				/* Can create a new directory */
+			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
+			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
+			res = FR_OK;
+			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
+			if (dcl == 1) res = FR_INT_ERR;
+			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
+			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
+			tm = GET_FATTIME();
+			if (res == FR_OK) {					/* Initialize the new directory table */
+				dsc = clust2sect(fs, dcl);
+				dir = fs->win;
+				mem_set(dir, 0, SS(fs));
+				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
+					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
+					dir[DIR_Name] = '.';
+					dir[DIR_Attr] = AM_DIR;
+					st_dword(dir + DIR_ModTime, tm);
+					st_clust(fs, dir, dcl);
+					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
+					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
+					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
+					st_clust(fs, dir + SZDIRE, pcl);
+				}
+				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
+					fs->winsect = dsc++;
+					fs->wflag = 1;
+					res = sync_window(fs);
+					if (res != FR_OK) break;
+					mem_set(dir, 0, SS(fs));
+				}
+			}
+			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
+			if (res == FR_OK) {
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
+					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
+					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
+					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
+					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
+					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag (contiguous) */
+					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
+					res = store_xdir(&dj);
+				} else
+#endif
+				{
+					dir = dj.dir;
+					st_dword(dir + DIR_ModTime, tm);	/* Created time */
+					st_clust(fs, dir, dcl);				/* Table start cluster */
+					dir[DIR_Attr] = AM_DIR;				/* Attribute */
+					fs->wflag = 1;
+				}
+				if (res == FR_OK) res = sync_fs(fs);
+			} else {
+				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
+			}
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Rename a File/Directory                                               */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_rename (
+	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
+	const TCHAR* path_new	/* Pointer to the new name */
+)
+{
+	FRESULT res;
+	DIR djo, djn;
+	FATFS *fs;
+	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
+	DWORD dw;
+	DEF_NAMBUF
+
+
+	get_ldnumber(&path_new);						/* Ignore drive number of new name */
+	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive number of the old object */
+	if (res == FR_OK) {
+		djo.obj.fs = fs;
+		INIT_NAMBUF(fs);
+		res = follow_path(&djo, path_old);		/* Check old object */
+		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
+#if _FS_LOCK != 0
+		if (res == FR_OK) res = chk_lock(&djo, 2);
+#endif
+		if (res == FR_OK) {						/* Object to be renamed is found */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {	/* At exFAT */
+				BYTE nf, nn;
+				WORD nh;
+
+				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
+				mem_cpy(&djn, &djo, sizeof djo);
+				res = follow_path(&djn, path_new);	/* Make sure if new object name is not in use */
+				if (res == FR_OK) res = FR_EXIST;	/* Is new name already in use? */
+				if (res == FR_NO_FILE) { 			/* It is a valid path and no name collision */
+					res = dir_register(&djn);		/* Register the new entry */
+					if (res == FR_OK) {
+						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
+						nh = ld_word(fs->dirbuf + XDIR_NameHash);
+						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);
+						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
+						st_word(fs->dirbuf + XDIR_NameHash, nh);
+/* Start of critical section where any interruption can cause a cross-link */
+						res = store_xdir(&djn);
+					}
+				}
+			} else
+#endif
+			{	/* At FAT12/FAT16/FAT32 */
+				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
+				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
+				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
+				if (res == FR_OK) res = FR_EXIST;		/* Is new name already in use? */
+				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
+					res = dir_register(&djn);			/* Register the new entry */
+					if (res == FR_OK) {
+						dir = djn.dir;					/* Copy information about object except name */
+						mem_cpy(dir + 13, buf + 2, 19);
+						dir[DIR_Attr] = buf[0] | AM_ARC;
+						fs->wflag = 1;
+						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
+							dw = clust2sect(fs, ld_clust(fs, dir));
+							if (!dw) {
+								res = FR_INT_ERR;
+							} else {
+/* Start of critical section where any interruption can cause a cross-link */
+								res = move_window(fs, dw);
+								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
+								if (res == FR_OK && dir[1] == '.') {
+									st_clust(fs, dir, djn.obj.sclust);
+									fs->wflag = 1;
+								}
+							}
+						}
+					}
+				}
+			}
+			if (res == FR_OK) {
+				res = dir_remove(&djo);		/* Remove old entry */
+				if (res == FR_OK) {
+					res = sync_fs(fs);
+				}
+			}
+/* End of critical section */
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _FS_MINIMIZE == 0 */
+#endif /* _FS_MINIMIZE <= 1 */
+#endif /* _FS_MINIMIZE <= 2 */
+
+
+
+#if _USE_CHMOD && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Change Attribute                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_chmod (
+	const TCHAR* path,	/* Pointer to the file path */
+	BYTE attr,			/* Attribute bits */
+	BYTE mask			/* Attribute mask to change */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	DEF_NAMBUF
+
+
+	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
+	dj.obj.fs = fs;
+	if (res == FR_OK) {
+		INIT_NAMBUF(fs);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
+		if (res == FR_OK) {
+			mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
+				res = store_xdir(&dj);
+			} else
+#endif
+			{
+				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
+				fs->wflag = 1;
+			}
+			if (res == FR_OK) res = sync_fs(fs);
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change Timestamp                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_utime (
+	const TCHAR* path,	/* Pointer to the file/directory name */
+	const FILINFO* fno	/* Pointer to the time stamp to be set */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	DEF_NAMBUF
+
+
+	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
+	dj.obj.fs = fs;
+	if (res == FR_OK) {
+		INIT_NAMBUF(fs);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
+		if (res == FR_OK) {
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				st_dword(fs->dirbuf + XDIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
+				res = store_xdir(&dj);
+			} else
+#endif
+			{
+				st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
+				fs->wflag = 1;
+			}
+			if (res == FR_OK) res = sync_fs(fs);
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif	/* _USE_CHMOD && !_FS_READONLY */
+
+
+
+#if _USE_LABEL
+/*-----------------------------------------------------------------------*/
+/* Get Volume Label                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_getlabel (
+	const TCHAR* path,	/* Path name of the logical drive number */
+	TCHAR* label,		/* Pointer to a buffer to return the volume label */
+	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	UINT si, di;
+#if _LFN_UNICODE || _FS_EXFAT
+	WCHAR w;
+#endif
+
+	/* Get logical drive number */
+	res = find_volume(&path, &fs, 0);
+
+	/* Get volume label */
+	if (res == FR_OK && label) {
+		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
+		res = dir_sdi(&dj, 0);
+		if (res == FR_OK) {
+		 	res = dir_read(&dj, 1);			/* Find a volume label entry */
+		 	if (res == FR_OK) {
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					for (si = di = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
+						w = ld_word(dj.dir + XDIR_Label + si * 2);
+#if _LFN_UNICODE
+						label[di++] = w;
+#else
+						w = ff_convert(w, 0);	/* Unicode -> OEM */
+						if (w == 0) w = '?';	/* Replace wrong character */
+						if (_DF1S && w >= 0x100) label[di++] = (char)(w >> 8);
+						label[di++] = (char)w;
+#endif
+					}
+					label[di] = 0;
+				} else
+#endif
+				{
+					si = di = 0;		/* Extract volume label from AM_VOL entry with code comversion */
+					do {
+#if _LFN_UNICODE
+						w = (si < 11) ? dj.dir[si++] : ' ';
+						if (IsDBCS1(w) && si < 11 && IsDBCS2(dj.dir[si])) {
+							w = w << 8 | dj.dir[si++];
+						}
+						label[di++] = ff_convert(w, 1);	/* OEM -> Unicode */
+#else
+						label[di++] = dj.dir[si++];
+#endif
+					} while (di < 11);
+					do {				/* Truncate trailing spaces */
+						label[di] = 0;
+						if (di == 0) break;
+					} while (label[--di] == ' ');
+				}
+			}
+		}
+		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
+			label[0] = 0;
+			res = FR_OK;
+		}
+	}
+
+	/* Get volume serial number */
+	if (res == FR_OK && vsn) {
+		res = move_window(fs, fs->volbase);
+		if (res == FR_OK) {
+			switch (fs->fs_type) {
+			case FS_EXFAT: di = BPB_VolIDEx; break;
+			case FS_FAT32: di = BS_VolID32; break;
+			default:       di = BS_VolID;
+			}
+			*vsn = ld_dword(fs->win + di);
+		}
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Set Volume Label                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_setlabel (
+	const TCHAR* label	/* Pointer to the volume label to set */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	BYTE dirvn[22];
+	UINT i, j, slen;
+	WCHAR w;
+	static const char badchr[] = "\"*+,.:;<=>\?[]|\x7F";
+
+
+	/* Get logical drive number */
+	res = find_volume(&label, &fs, FA_WRITE);
+	if (res != FR_OK) LEAVE_FF(fs, res);
+	dj.obj.fs = fs;
+
+	/* Get length of given volume label */
+	for (slen = 0; (UINT)label[slen] >= ' '; slen++) ;	/* Get name length */
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		for (i = j = 0; i < slen; ) {	/* Create volume label in directory form */
+			w = label[i++];
+#if !_LFN_UNICODE
+			if (IsDBCS1(w)) {
+				w = (i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
+			}
+			w = ff_convert(w, 1);
+#endif
+			if (w == 0 || chk_chr(badchr, w) || j == 22) {	/* Check validity check validity of the volume label */
+				LEAVE_FF(fs, FR_INVALID_NAME);
+			}
+			st_word(dirvn + j, w); j += 2;
+		}
+		slen = j;
+	} else
+#endif
+	{	/* At the FAT12/16/32 */
+		for ( ; slen && label[slen - 1] == ' '; slen--) ;	/* Remove trailing spaces */
+		if (slen) {		/* Is there a volume label to be set? */
+			dirvn[0] = 0; i = j = 0;	/* Create volume label in directory form */
+			do {
+#if _LFN_UNICODE
+				w = ff_convert(ff_wtoupper(label[i++]), 0);
+#else
+				w = (BYTE)label[i++];
+				if (IsDBCS1(w)) {
+					w = (j < 10 && i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
+				}
+#if _USE_LFN != 0
+				w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
+#else
+				if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
+#ifdef _EXCVT
+				if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
+#else
+				if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
+#endif
+#endif
+#endif
+				if (w == 0 || chk_chr(badchr, w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
+					LEAVE_FF(fs, FR_INVALID_NAME);
+				}
+				if (w >= 0x100) dirvn[j++] = (BYTE)(w >> 8);
+				dirvn[j++] = (BYTE)w;
+			} while (i < slen);
+			while (j < 11) dirvn[j++] = ' ';	/* Fill remaining name field */
+			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
+		}
+	}
+
+	/* Set volume label */
+	dj.obj.sclust = 0;		/* Open root directory */
+	res = dir_sdi(&dj, 0);
+	if (res == FR_OK) {
+		res = dir_read(&dj, 1);	/* Get volume label entry */
+		if (res == FR_OK) {
+			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
+				dj.dir[XDIR_NumLabel] = slen / 2;	/* Change the volume label */
+				mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
+			} else {
+				if (slen) {
+					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
+				} else {
+					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
+				}
+			}
+			fs->wflag = 1;
+			res = sync_fs(fs);
+		} else {			/* No volume label entry is found or error */
+			if (res == FR_NO_FILE) {
+				res = FR_OK;
+				if (slen) {	/* Create a volume label entry */
+					res = dir_alloc(&dj, 1);	/* Allocate an entry */
+					if (res == FR_OK) {
+						mem_set(dj.dir, 0, SZDIRE);	/* Clear the entry */
+						if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
+							dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
+							dj.dir[XDIR_NumLabel] = slen / 2;
+							mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
+						} else {
+							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
+							mem_cpy(dj.dir, dirvn, 11);
+						}
+						fs->wflag = 1;
+						res = sync_fs(fs);
+					}
+				}
+			}
+		}
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _USE_LABEL */
+
+
+
+#if _USE_EXPAND && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Allocate a Contiguous Blocks to the File                              */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_expand (
+	FIL* fp,		/* Pointer to the file object */
+	FSIZE_t fsz,	/* File size to be expanded to */
+	BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD n, clst, stcl, scl, ncl, tcl, lclst;
+
+
+	res = validate(fp, &fs);		/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
+#if _FS_EXFAT
+	if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
+#endif
+	n = (DWORD)fs->csize * SS(fs);	/* Cluster size */
+	tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 0);	/* Number of clusters required */
+	stcl = fs->last_clst; lclst = 0;
+	if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {
+		scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
+		if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
+		if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
+		if (res == FR_OK) {
+			if (opt) {
+				res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
+				lclst = scl + tcl - 1;
+			} else {
+				lclst = scl - 1;
+			}
+		}
+	} else
+#endif
+	{
+		scl = clst = stcl; ncl = 0;
+		for (;;) {	/* Find a contiguous cluster block */
+			n = get_fat(&fp->obj, clst);
+			if (++clst >= fs->n_fatent) clst = 2;
+			if (n == 1) { res = FR_INT_ERR; break; }
+			if (n == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
+			if (n == 0) {	/* Is it a free cluster? */
+				if (++ncl == tcl) break;	/* Break if a contiguous cluster block is found */
+			} else {
+				scl = clst; ncl = 0;		/* Not a free cluster */
+			}
+			if (clst == stcl) { res = FR_DENIED; break; }	/* No contiguous cluster? */
+		}
+		if (res == FR_OK) {
+			if (opt) {
+				for (clst = scl; tcl; clst++, tcl--) {	/* Create a cluster chain on the FAT */
+					res = put_fat(fs, clst, (tcl == 1) ? 0xFFFFFFFF : clst + 1);
+					if (res != FR_OK) break;
+					lclst = clst;
+				}
+			} else {
+				lclst = scl - 1;
+			}
+		}
+	}
+
+	if (opt && res == FR_OK) {
+		fs->last_clst = lclst;		/* Set suggested start cluster to start next */
+		fp->obj.sclust = scl;		/* Update object allocation information */
+		fp->obj.objsize = fsz;
+		if (_FS_EXFAT) fp->obj.stat = 2;	/* Set status 'contiguous chain' */
+		fp->flag |= FA_MODIFIED;
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif /* _USE_EXPAND && !_FS_READONLY */
+
+
+
+#if _USE_FORWARD
+/*-----------------------------------------------------------------------*/
+/* Forward data to the stream directly                                   */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_forward (
+	FIL* fp, 						/* Pointer to the file object */
+	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
+	UINT btf,						/* Number of bytes to forward */
+	UINT* bf						/* Pointer to number of bytes forwarded */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD clst, sect;
+	FSIZE_t remain;
+	UINT rcnt, csect;
+	BYTE *dbuf;
+
+
+	*bf = 0;	/* Clear transfer byte counter */
+	res = validate(fp, &fs);		/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
+
+	remain = fp->obj.objsize - fp->fptr;
+	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
+
+	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream goes busy */
+		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
+		csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
+		if (fp->fptr % SS(fs) == 0) {				/* On the sector boundary? */
+			if (csect == 0) {						/* On the cluster boundary? */
+				clst = (fp->fptr == 0) ?			/* On the top of the file? */
+					fp->obj.sclust : get_fat(&fp->obj, fp->clust);
+				if (clst <= 1) ABORT(fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+				fp->clust = clst;					/* Update current cluster */
+			}
+		}
+		sect = clust2sect(fs, fp->clust);			/* Get current data sector */
+		if (!sect) ABORT(fs, FR_INT_ERR);
+		sect += csect;
+#if _FS_TINY
+		if (move_window(fs, sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window to the file data */
+		dbuf = fs->win;
+#else
+		if (fp->sect != sect) {		/* Fill sector cache with file data */
+#if !_FS_READONLY
+			if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+				fp->flag &= ~FA_DIRTY;
+			}
+#endif
+			if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+		}
+		dbuf = fp->buf;
+#endif
+		fp->sect = sect;
+		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
+		if (rcnt > btf) rcnt = btf;					/* Clip it by btr if needed */
+		rcnt = (*func)(dbuf + ((UINT)fp->fptr % SS(fs)), rcnt);	/* Forward the file data */
+		if (!rcnt) ABORT(fs, FR_INT_ERR);
+	}
+
+	LEAVE_FF(fs, FR_OK);
+}
+#endif /* _USE_FORWARD */
+
+
+
+#if _USE_MKFS && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Create FAT file system on the logical drive                           */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mkfs (
+	const TCHAR* path,	/* Logical drive number */
+	BYTE opt,			/* Format option */
+	DWORD au,			/* Size of allocation unit [byte] */
+	void* work,			/* Pointer to working buffer */
+	UINT len			/* Size of working buffer */
+)
+{
+	const UINT n_fats = 1;		/* Number of FATs for FAT12/16/32 volume (1 or 2) */
+	const UINT n_rootdir = 512;	/* Number of root directory entries for FAT12/16 volume */
+	static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};	/* Cluster size boundary for FAT12/16 volume (4KS unit) */
+	static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};	/* Cluster size boundary for FAT32 volume (128KS unit) */
+	BYTE fmt, sys, *buf, *pte, pdrv, part;
+	WORD ss;
+	DWORD n, pau, n_clst, sz_blk, sect, szb_buf, sz_buf;
+	DWORD b_vol, b_fat, b_data;				/* Base LBA for volume, fat, data */
+	DWORD sz_vol, sz_rsv, sz_fat, sz_dir;	/* Size for volume, fat, dir, data */
+	UINT i, ns;
+	int vol;
+	DSTATUS stat;
+#if _USE_TRIM || _FS_EXFAT
+	DWORD tbl[3];
+#endif
+
+
+	/* Check mounted drive and clear work area */
+	vol = get_ldnumber(&path);					/* Get target logical drive */
+	if (vol < 0) return FR_INVALID_DRIVE;
+	if (FatFs[vol]) FatFs[vol]->fs_type = 0;	/* Clear mounted volume */
+	pdrv = LD2PD(vol);	/* Physical drive */
+	part = LD2PT(vol);	/* Partition (0:create as new, 1-4:get by partition table) */
+
+	/* Check physical drive status */
+	stat = disk_initialize(pdrv);
+	if (stat & STA_NOINIT) return FR_NOT_READY;
+	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
+	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;
+#if _MAX_SS != _MIN_SS		/* Get sector size of the medium */
+	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;
+	if (ss > _MAX_SS || ss < _MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
+#else
+	ss = _MAX_SS;
+#endif
+	if ((au != 0 && au < ss) || (au & (au - 1))) return FR_INVALID_PARAMETER;	/* Check if au is valid */
+	au /= ss;	/* Cluster size in byte to in sector */
+	if (au > 32768) return FR_INVALID_PARAMETER;
+
+	/* Set size and pointer of the working buffer */
+	buf = (BYTE*)work;			/* Use given working buffer */
+	if (len < ss) return FR_MKFS_ABORTED;
+	szb_buf = len & ~(ss - 1);	/* Round-down by sector size [byte] */
+	sz_buf = szb_buf / ss;		/* Size of sector buffer [sector] */
+
+	/* Determine where the volume to be located (b_vol, sz_vol) */
+	if (_MULTI_PARTITION && part != 0) {
+		/* Get partition information from partition table in the MBR */
+		if (disk_read(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Load MBR */
+		if (ld_word(buf + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;	/* Check MBR is valid */
+		pte = buf + (MBR_Table + (part - 1) * SZ_PTE);
+		if (!pte[PTE_System]) return FR_MKFS_ABORTED;	/* No partition? */
+		b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
+		sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
+	} else {
+		/* Create a single-partition in this function */
+		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) return FR_DISK_ERR;
+		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
+		if (sz_vol < b_vol) return FR_MKFS_ABORTED;
+		sz_vol -= b_vol;						/* Volume size */
+	}
+	if (sz_vol < 128) return FR_MKFS_ABORTED;	/* Check volume size (>=128s) */
+
+	/* Pre-determine the FAT type by argument */
+	do {
+		if (_FS_EXFAT && (opt & FM_EXFAT)) {	/* exFAT possible? */
+			if ((opt & FM_ANY) == FM_EXFAT || sz_vol >= 0x4000000 || au >= 256) {	/* exFAT only, vol >= 64Ms or au >= 256s ? */
+				fmt = FS_EXFAT; break;
+			}
+		}
+		if (au >= 256) return FR_INVALID_PARAMETER;	/* Too large au for FAT/FAT32 */
+		if (opt & FM_FAT32) {	/* FAT32 possible? */
+			if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
+				fmt = FS_FAT32; break;
+			}
+		}
+		if (!(opt & FM_FAT)) return FR_INVALID_PARAMETER;	/* no-FAT? */
+		fmt = FS_FAT16;
+	} while (0);
+
+#if _FS_EXFAT
+	if (fmt == FS_EXFAT) {	/* Create an exFAT volume */
+		DWORD sum, szb_bit, szb_case;
+		WCHAR ch, si;
+		UINT j, st;
+		BYTE b;
+
+		if (sz_vol < 0x1000) return FR_MKFS_ABORTED;	/* Too small volume? */
+#if _USE_TRIM
+		tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area can be erased */
+		disk_ioctl(pdrv, CTRL_TRIM, tbl);
+#endif
+		/* Determine FAT location, data location and number of clusters */
+		if (!au) {	/* au auto-selection */
+			au = 8;
+			if (sz_vol >= 0x80000) au = 64;		/* >= 512KS */
+			if (sz_vol >= 0x4000000) au = 256;	/* >= 64MS */
+		}
+		b_fat = b_vol + 32;										/* FAT start at offset 32 */
+		sz_fat = ((sz_vol / au + 2) * 4 + ss - 1) / ss;			/* Numbef of FAT sectors */
+		b_data = (b_fat + sz_fat + sz_blk - 1) & ~(sz_blk - 1);	/* Align data area to the erase block boundary */
+		if (b_data >= sz_vol / 2) return FR_MKFS_ABORTED;		/* Too small volume? */
+		n_clst = (sz_vol - (b_data - b_vol)) / au;				/* Nunber of clusters */
+		if (n_clst <16) return FR_MKFS_ABORTED;					/* Too few clusters? */
+		if (n_clst > MAX_EXFAT) return FR_MKFS_ABORTED;			/* Too many clusters? */
+
+		szb_bit = (n_clst + 7) / 8;		/* Size of allocation bitmap */
+		tbl[0] = (szb_bit + au * ss - 1) / (au * ss);	/* Number of bitmap clusters */
+		tbl[2] = 1;										/* Number of rootdir clusters */
+
+		/* Create a compressed up-case table */
+		sect = b_data + au * tbl[0];	/* Table start sector */
+		sum = 0;						/* Table checksum to be stored in the 82 entry */
+		st = si = i = j = szb_case = 0;
+		do {
+			switch (st) {
+			case 0:
+				ch = ff_wtoupper(si);	/* Get an up-case char */
+				if (ch != si) {
+					si++; break;		/* Store the up-case char if exist */
+				}
+				for (j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;	/* Get run length of no-case block */
+				if (j >= 128) {
+					ch = 0xFFFF; st = 2; break;	/* Compress the no-case block if run is >= 128 */
+				}
+				st = 1;			/* Do not compress short run */
+				/* continue */
+			case 1:
+				ch = si++;		/* Fill the short run */
+				if (--j == 0) st = 0;
+				break;
+			default:
+				ch = (WCHAR)j; si += j;	/* Number of chars to skip */
+				st = 0;
+			}
+			sum = xsum32(buf[i + 0] = (BYTE)ch, sum);		/* Put it into the write buffer */
+			sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);
+			i += 2; szb_case += 2;
+			if (!si || i == szb_buf) {		/* Write buffered data when buffer full or end of process */
+				ns = (i + ss - 1) / ss;
+				if (disk_write(pdrv, buf, sect, ns) != RES_OK) return FR_DISK_ERR;
+				sect += ns; i = 0;
+			}
+		} while (si);
+		tbl[1] = (szb_case + au * ss - 1) / (au * ss);	/* Number of up-case clusters */
+
+		/* Initialize the allocation bitmap */
+		mem_set(buf, 0, szb_buf);	/* Set in-use flags of bitmap, up-case and root dir */
+		for (i = 0, n = tbl[0] + tbl[1] + tbl[2]; n >= 8; buf[i++] = 0xFF, n -= 8) ;
+		for (b = 1; n; buf[i] |= b, b <<= 1, n--) ;
+		sect = b_data; n = (szb_bit + ss - 1) / ss;		/* Start of bitmap and number of the sectors */
+		do {	/* Fill allocation bitmap sectors */
+			ns = (n > sz_buf) ? sz_buf : n;
+			if (disk_write(pdrv, buf, sect, ns) != RES_OK) return FR_DISK_ERR;
+			sect += ns;
+			mem_set(buf, 0, ss);
+		} while (n -= ns);
+
+		/* Initialize the FAT */
+		st_qword(buf, 0xFFFFFFFFFFFFFFF8);	/* Entry 0 and 1 */
+		for (j = 0, i = 2; j < 3; j++) {	/* Set entries of bitmap, up-case and root dir */
+			for (n = tbl[j]; n; n--) {
+				st_dword(buf + i * 4, (n >= 2) ? i + 1 : 0xFFFFFFFF);
+				i++;
+			}
+		}
+		sect = b_fat; n = sz_fat;	/* Start of FAT and number of the sectors */
+		do {	/* Fill FAT sectors */
+			ns = (n > sz_buf) ? sz_buf : n;
+			if (disk_write(pdrv, buf, sect, ns) != RES_OK) return FR_DISK_ERR;
+			sect += ns;
+			mem_set(buf, 0, ss);
+		} while (n -= ns);
+
+		/* Initialize the root directory */
+		mem_set(buf, 0, ss);
+		buf[SZDIRE * 0 + 0] = 0x83;		/* 83 entry (volume label) */
+		buf[SZDIRE * 1 + 0] = 0x81;		/* 81 entry (allocation bitmap) */
+		st_dword(buf + SZDIRE * 1 + 20, 2);
+		st_dword(buf + SZDIRE * 1 + 24, szb_bit);
+		buf[SZDIRE * 2 + 0] = 0x82;		/* 82 entry (up-case table) */
+		st_dword(buf + SZDIRE * 2 + 4, sum);
+		st_dword(buf + SZDIRE * 2 + 20, 2 + tbl[0]);
+		st_dword(buf + SZDIRE * 2 + 24, szb_case);
+		sect = b_data + au * (tbl[0] + tbl[1]);	n = au;	/* Start of directory and number of the sectors */
+		do {	/* Fill root direcotry sectors */
+			ns = (n > sz_buf) ? sz_buf : n;
+			if (disk_write(pdrv, buf, sect, ns) != RES_OK) return FR_DISK_ERR;
+			sect += ns;
+			mem_set(buf, 0, ss);
+		} while (n -= ns);
+
+		/* Create two set of the exFAT VBR blocks */
+		sect = b_vol;
+		for (n = 0; n < 2; n++) {
+			/* Main record (+0) */
+			mem_set(buf, 0, ss);
+			mem_cpy(buf + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11);	/* Boot jump code (x86), OEM name */
+			st_dword(buf + BPB_VolOfsEx, b_vol);					/* Volume offset in the physical drive [sector] */
+			st_dword(buf + BPB_TotSecEx, sz_vol);					/* Volume size [sector] */
+			st_dword(buf + BPB_FatOfsEx, b_fat - b_vol);			/* FAT offset [sector] */
+			st_dword(buf + BPB_FatSzEx, sz_fat);					/* FAT size [sector] */
+			st_dword(buf + BPB_DataOfsEx, b_data - b_vol);			/* Data offset [sector] */
+			st_dword(buf + BPB_NumClusEx, n_clst);					/* Number of clusters */
+			st_dword(buf + BPB_RootClusEx, 2 + tbl[0] + tbl[1]);	/* Root dir cluster # */
+			st_dword(buf + BPB_VolIDEx, GET_FATTIME());				/* VSN */
+			st_word(buf + BPB_FSVerEx, 0x100);						/* File system version (1.00) */
+			for (buf[BPB_BytsPerSecEx] = 0, i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;	/* Log2 of sector size [byte] */
+			for (buf[BPB_SecPerClusEx] = 0, i = au; i >>= 1; buf[BPB_SecPerClusEx]++) ;	/* Log2 of cluster size [sector] */
+			buf[BPB_NumFATsEx] = 1;					/* Number of FATs */
+			buf[BPB_DrvNumEx] = 0x80;				/* Drive number (for int13) */
+			st_word(buf + BS_BootCodeEx, 0xFEEB);	/* Boot code (x86) */
+			st_word(buf + BS_55AA, 0xAA55);			/* Signature (placed here regardless of sector size) */
+			for (i = sum = 0; i < ss; i++) {		/* VBR checksum */
+				if (i != BPB_VolFlagEx && i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum32(buf[i], sum);
+			}
+			if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
+			/* Extended bootstrap record (+1..+8) */
+			mem_set(buf, 0, ss);
+			st_word(buf + ss - 2, 0xAA55);	/* Signature (placed at end of sector) */
+			for (j = 1; j < 9; j++) {
+				for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
+				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
+			}
+			/* OEM/Reserved record (+9..+10) */
+			mem_set(buf, 0, ss);
+			for ( ; j < 11; j++) {
+				for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
+				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
+			}
+			/* Sum record (+11) */
+			for (i = 0; i < ss; i += 4) st_dword(buf + i, sum);		/* Fill with checksum value */
+			if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
+		}
+
+	} else
+#endif
+	{	/* Create an FAT12/16/32 volume */
+		do {
+			pau = au;
+			/* Pre-determine number of clusters and FAT sub-type */
+			if (fmt == FS_FAT32) {	/* FAT32 volume */
+				if (!pau) {	/* au auto-selection */
+					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
+					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
+				}
+				n_clst = sz_vol / pau;	/* Number of clusters */
+				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
+				sz_rsv = 32;	/* Number of reserved sectors */
+				sz_dir = 0;		/* No static directory */
+				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) return FR_MKFS_ABORTED;
+			} else {				/* FAT12/16 volume */
+				if (!pau) {	/* au auto-selection */
+					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
+					for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
+				}
+				n_clst = sz_vol / pau;
+				if (n_clst > MAX_FAT12) {
+					n = n_clst * 2 + 4;		/* FAT size [byte] */
+				} else {
+					fmt = FS_FAT12;
+					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
+				}
+				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
+				sz_rsv = 1;						/* Number of reserved sectors */
+				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
+			}
+			b_fat = b_vol + sz_rsv;						/* FAT base */
+			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
+
+			/* Align data base to erase block boundary (for flash memory media) */
+			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
+			if (fmt == FS_FAT32) {		/* FAT32: Move FAT base */
+				sz_rsv += n; b_fat += n;
+			} else {					/* FAT12/16: Expand FAT size */
+				sz_fat += n / n_fats;
+			}
+
+			/* Determine number of clusters and final check of validity of the FAT sub-type */
+			if (sz_vol < b_data + pau * 16 - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
+			n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
+			if (fmt == FS_FAT32) {
+				if (n_clst <= MAX_FAT16) {	/* Too few clusters for FAT32 */
+					if (!au && (au = pau / 2) != 0) continue;	/* Adjust cluster size and retry */
+					return FR_MKFS_ABORTED;
+				}
+			}
+			if (fmt == FS_FAT16) {
+				if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
+					if (!au && (pau * 2) <= 64) {
+						au = pau * 2; continue;		/* Adjust cluster size and retry */
+					}
+					if ((opt & FM_FAT32)) {
+						fmt = FS_FAT32; continue;	/* Switch type to FAT32 and retry */
+					}
+					if (!au && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
+					return FR_MKFS_ABORTED;
+				}
+				if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
+					if (!au && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
+					return FR_MKFS_ABORTED;
+				}
+			}
+			if (fmt == FS_FAT12 && n_clst > MAX_FAT12) return FR_MKFS_ABORTED;	/* Too many clusters for FAT12 */
+
+			/* Ok, it is the valid cluster configuration */
+			break;
+		} while (1);
+
+#if _USE_TRIM
+		tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area can be erased */
+		disk_ioctl(pdrv, CTRL_TRIM, tbl);
+#endif
+		/* Create FAT VBR */
+		mem_set(buf, 0, ss);
+		mem_cpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code (x86), OEM name */
+		st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
+		buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
+		st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
+		buf[BPB_NumFATs] = n_fats;						/* Number of FATs */
+		st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
+		if (sz_vol < 0x10000) {
+			st_word(buf + BPB_TotSec16, (WORD)sz_vol);	/* Volume size in 16-bit LBA */
+		} else {
+			st_dword(buf + BPB_TotSec32, sz_vol);		/* Volume size in 12-bit LBA */
+		}
+		buf[BPB_Media] = 0xF8;							/* Media descriptor */
+		st_word(buf + BPB_SecPerTrk, 63);				/* Number of sectors per track (for int13) */
+		st_word(buf + BPB_NumHeads, 255);				/* Number of heads (for int13) */
+		st_dword(buf + BPB_HiddSec, b_vol);				/* Volume offset in the physical drive [sector] */
+		if (fmt == FS_FAT32) {
+			st_dword(buf + BS_VolID32, GET_FATTIME());	/* VSN */
+			st_dword(buf + BPB_FATSz32, sz_fat);		/* FAT size [sector] */
+			st_dword(buf + BPB_RootClus32, 2);			/* Root directory cluster # (2) */
+			st_word(buf + BPB_FSInfo32, 1);				/* Offset of FSINFO sector (VBR + 1) */
+			st_word(buf + BPB_BkBootSec32, 6);			/* Offset of backup VBR (VBR + 6) */
+			buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
+			buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
+			mem_cpy(buf + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
+		} else {
+			st_dword(buf + BS_VolID, GET_FATTIME());	/* VSN */
+			st_word(buf + BPB_FATSz16, (WORD)sz_fat);	/* FAT size [sector] */
+			buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
+			buf[BS_BootSig] = 0x29;						/* Extended boot signature */
+			mem_cpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
+		}
+		st_word(buf + BS_55AA, 0xAA55);					/* Signature (offset is fixed here regardless of sector size) */
+		if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the VBR sector */
+
+		/* Create FSINFO record if needed */
+		if (fmt == FS_FAT32) {
+			disk_write(pdrv, buf, b_vol + 6, 1);		/* Write backup VBR (VBR + 6) */
+			mem_set(buf, 0, ss);
+			st_dword(buf + FSI_LeadSig, 0x41615252);
+			st_dword(buf + FSI_StrucSig, 0x61417272);
+			st_dword(buf + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
+			st_dword(buf + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
+			st_word(buf + BS_55AA, 0xAA55);
+			disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
+			disk_write(pdrv, buf, b_vol + 1, 1);		/* Write original FSINFO (VBR + 1) */
+		}
+
+		/* Initialize FAT area */
+		mem_set(buf, 0, szb_buf);
+		sect = b_fat;		/* Start sector */
+		for (i = 0; i < n_fats; i++) {			/* Initialize FATs each */
+			if (fmt == FS_FAT32) {
+				st_dword(buf + 0, 0xFFFFFFF8);	/* Entry 0 */
+				st_dword(buf + 4, 0xFFFFFFFF);	/* Entry 1 */
+				st_dword(buf + 8, 0x0FFFFFFF);	/* Entry 2 (root directory) */
+			} else {
+				st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* Entry 0 and 1 */
+			}
+			n = sz_fat;		/* Sector count of a FAT */
+			do {	/* Fill FAT sectors */
+				ns = (n > sz_buf) ? sz_buf : n;
+				if (disk_write(pdrv, buf, sect, ns) != RES_OK) return FR_DISK_ERR;
+				sect += ns;
+				mem_set(buf, 0, ss);
+			} while (n -= ns);
+		}
+
+		/* Initialize root directory (fill with zero) */
+		n = (fmt == FS_FAT32) ? pau : sz_dir;		/* Sector count of root directory */
+		do {
+			ns = (n > sz_buf) ? sz_buf : n;
+			if (disk_write(pdrv, buf, sect, ns) != RES_OK) return FR_DISK_ERR;
+			sect += ns;
+		} while (n -= ns);
+	}
+
+	/* Determine system ID in the partition table */
+	if (_FS_EXFAT && fmt == FS_EXFAT) {
+		sys = 0x07;			/* HPFS/NTFS/exFAT */
+	} else {
+		if (fmt == FS_FAT32) {
+			sys = 0x0C;		/* FAT32X */
+		} else {
+			if (sz_vol >= 0x10000) {
+				sys = 0x06;	/* FAT12/16 (>=64KS) */
+			} else {
+				sys = (fmt == FS_FAT16) ? 0x04 : 0x01;	/* FAT16 (<64KS) : FAT12 (<64KS) */
+			}
+		}
+	}
+
+	if (_MULTI_PARTITION && part != 0) {
+		/* Update system ID in the partition table */
+		if (disk_read(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Read the MBR */
+		buf[MBR_Table + (part - 1) * SZ_PTE + PTE_System] = sys;		/* Set system type */
+		if (disk_write(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it back to the MBR */
+	} else {
+		if (!(opt & FM_SFD)) {
+			/* Create partition table in FDISK format */
+			mem_set(buf, 0, ss);
+			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
+			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
+			pte[PTE_Boot] = 0;					/* Boot indicator */
+			pte[PTE_StHead] = 1;				/* Start head */
+			pte[PTE_StSec] = 1;					/* Start sector */
+			pte[PTE_StCyl] = 0;					/* Start cylinder */
+			pte[PTE_System] = sys;				/* System type */
+			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS is incorrect) */
+			pte[PTE_EdHead] = 254;				/* End head */
+			pte[PTE_EdSec] = (BYTE)(n >> 2 | 63);	/* End sector */
+			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
+			st_dword(pte + PTE_StLba, b_vol);	/* Start offset in LBA */
+			st_dword(pte + PTE_SizLba, sz_vol);	/* Size in sectors */
+			if (disk_write(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the MBR */
+		}
+	}
+
+	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) return FR_DISK_ERR;
+
+	return FR_OK;
+}
+
+
+
+#if _MULTI_PARTITION
+/*-----------------------------------------------------------------------*/
+/* Create partition table on the physical drive                          */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_fdisk (
+	BYTE pdrv,			/* Physical drive number */
+	const DWORD* szt,	/* Pointer to the size table for each partitions */
+	void* work			/* Pointer to the working buffer */
+)
+{
+	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
+	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
+	DSTATUS stat;
+	DWORD sz_disk, sz_part, s_part;
+
+
+	stat = disk_initialize(pdrv);
+	if (stat & STA_NOINIT) return FR_NOT_READY;
+	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
+	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
+
+	/* Determine the CHS without any care of the drive geometry */
+	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
+	if (n == 256) n--;
+	e_hd = n - 1;
+	sz_cyl = 63 * n;
+	tot_cyl = sz_disk / sz_cyl;
+
+	/* Create partition table */
+	mem_set(buf, 0, _MAX_SS);
+	p = buf + MBR_Table; b_cyl = 0;
+	for (i = 0; i < 4; i++, p += SZ_PTE) {
+		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
+		if (!p_cyl) continue;
+		s_part = (DWORD)sz_cyl * b_cyl;
+		sz_part = (DWORD)sz_cyl * p_cyl;
+		if (i == 0) {	/* Exclude first track of cylinder 0 */
+			s_hd = 1;
+			s_part += 63; sz_part -= 63;
+		} else {
+			s_hd = 0;
+		}
+		e_cyl = b_cyl + p_cyl - 1;
+		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
+
+		/* Set partition table */
+		p[1] = s_hd;						/* Start head */
+		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
+		p[3] = (BYTE)b_cyl;					/* Start cylinder */
+		p[4] = 0x06;						/* System type (temporary setting) */
+		p[5] = e_hd;						/* End head */
+		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
+		p[7] = (BYTE)e_cyl;					/* End cylinder */
+		st_dword(p + 8, s_part);			/* Start sector in LBA */
+		st_dword(p + 12, sz_part);			/* Partition size */
+
+		/* Next partition */
+		b_cyl += p_cyl;
+	}
+	st_word(p, 0xAA55);
+
+	/* Write it to the MBR */
+	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
+}
+
+#endif /* _MULTI_PARTITION */
+#endif /* _USE_MKFS && !_FS_READONLY */
+
+
+
+
+#if _USE_STRFUNC
+/*-----------------------------------------------------------------------*/
+/* Get a string from the file                                            */
+/*-----------------------------------------------------------------------*/
+
+TCHAR* f_gets (
+	TCHAR* buff,	/* Pointer to the string buffer to read */
+	int len,		/* Size of string buffer (characters) */
+	FIL* fp			/* Pointer to the file object */
+)
+{
+	int n = 0;
+	TCHAR c, *p = buff;
+	BYTE s[2];
+	UINT rc;
+
+
+	while (n < len - 1) {	/* Read characters until buffer gets filled */
+#if _LFN_UNICODE
+#if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
+		f_read(fp, s, 1, &rc);
+		if (rc != 1) break;
+		c = s[0];
+		if (c >= 0x80) {
+			if (c < 0xC0) continue;	/* Skip stray trailer */
+			if (c < 0xE0) {			/* Two-byte sequence */
+				f_read(fp, s, 1, &rc);
+				if (rc != 1) break;
+				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
+				if (c < 0x80) c = '?';
+			} else {
+				if (c < 0xF0) {		/* Three-byte sequence */
+					f_read(fp, s, 2, &rc);
+					if (rc != 2) break;
+					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
+					if (c < 0x800) c = '?';
+				} else {			/* Reject four-byte sequence */
+					c = '?';
+				}
+			}
+		}
+#elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
+		f_read(fp, s, 2, &rc);
+		if (rc != 2) break;
+		c = s[1] + (s[0] << 8);
+#elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
+		f_read(fp, s, 2, &rc);
+		if (rc != 2) break;
+		c = s[0] + (s[1] << 8);
+#else						/* Read a character in ANSI/OEM */
+		f_read(fp, s, 1, &rc);
+		if (rc != 1) break;
+		c = s[0];
+		if (IsDBCS1(c)) {
+			f_read(fp, s, 1, &rc);
+			if (rc != 1) break;
+			c = (c << 8) + s[0];
+		}
+		c = ff_convert(c, 1);	/* OEM -> Unicode */
+		if (!c) c = '?';
+#endif
+#else						/* Read a character without conversion */
+		f_read(fp, s, 1, &rc);
+		if (rc != 1) break;
+		c = s[0];
+#endif
+		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
+		*p++ = c;
+		n++;
+		if (c == '\n') break;		/* Break on EOL */
+	}
+	*p = 0;
+	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
+}
+
+
+
+
+#if !_FS_READONLY
+#include <stdarg.h>
+/*-----------------------------------------------------------------------*/
+/* Put a character to the file                                           */
+/*-----------------------------------------------------------------------*/
+
+typedef struct {
+	FIL *fp;		/* Ptr to the writing file */
+	int idx, nchr;	/* Write index of buf[] (-1:error), number of chars written */
+	BYTE buf[64];	/* Write buffer */
+} putbuff;
+
+
+static
+void putc_bfd (		/* Buffered write with code conversion */
+	putbuff* pb,
+	TCHAR c
+)
+{
+	UINT bw;
+	int i;
+
+
+	if (_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
+		putc_bfd(pb, '\r');
+	}
+
+	i = pb->idx;		/* Write index of pb->buf[] */
+	if (i < 0) return;
+
+#if _LFN_UNICODE
+#if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
+	if (c < 0x80) {				/* 7-bit */
+		pb->buf[i++] = (BYTE)c;
+	} else {
+		if (c < 0x800) {		/* 11-bit */
+			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
+		} else {				/* 16-bit */
+			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
+			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
+		}
+		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
+	}
+#elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
+	pb->buf[i++] = (BYTE)(c >> 8);
+	pb->buf[i++] = (BYTE)c;
+#elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
+	pb->buf[i++] = (BYTE)c;
+	pb->buf[i++] = (BYTE)(c >> 8);
+#else							/* Write a character in ANSI/OEM */
+	c = ff_convert(c, 0);	/* Unicode -> OEM */
+	if (!c) c = '?';
+	if (c >= 0x100)
+		pb->buf[i++] = (BYTE)(c >> 8);
+	pb->buf[i++] = (BYTE)c;
+#endif
+#else							/* Write a character without conversion */
+	pb->buf[i++] = (BYTE)c;
+#endif
+
+	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
+		f_write(pb->fp, pb->buf, (UINT)i, &bw);
+		i = (bw == (UINT)i) ? 0 : -1;
+	}
+	pb->idx = i;
+	pb->nchr++;
+}
+
+
+static
+int putc_flush (		/* Flush left characters in the buffer */
+	putbuff* pb
+)
+{
+	UINT nw;
+
+	if (   pb->idx >= 0	/* Flush buffered characters to the file */
+		&& f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK
+		&& (UINT)pb->idx == nw) return pb->nchr;
+	return EOF;
+}
+
+
+static
+void putc_init (		/* Initialize write buffer */
+	putbuff* pb,
+	FIL* fp
+)
+{
+	pb->fp = fp;
+	pb->nchr = pb->idx = 0;
+}
+
+
+
+int f_putc (
+	TCHAR c,	/* A character to be output */
+	FIL* fp		/* Pointer to the file object */
+)
+{
+	putbuff pb;
+
+
+	putc_init(&pb, fp);
+	putc_bfd(&pb, c);	/* Put the character */
+	return putc_flush(&pb);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a string to the file                                              */
+/*-----------------------------------------------------------------------*/
+
+int f_puts (
+	const TCHAR* str,	/* Pointer to the string to be output */
+	FIL* fp				/* Pointer to the file object */
+)
+{
+	putbuff pb;
+
+
+	putc_init(&pb, fp);
+	while (*str) putc_bfd(&pb, *str++);		/* Put the string */
+	return putc_flush(&pb);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a formatted string to the file                                    */
+/*-----------------------------------------------------------------------*/
+
+int f_printf (
+	FIL* fp,			/* Pointer to the file object */
+	const TCHAR* fmt,	/* Pointer to the format string */
+	...					/* Optional arguments... */
+)
+{
+	va_list arp;
+	putbuff pb;
+	BYTE f, r;
+	UINT i, j, w;
+	DWORD v;
+	TCHAR c, d, str[32], *p;
+
+
+	putc_init(&pb, fp);
+
+	va_start(arp, fmt);
+
+	for (;;) {
+		c = *fmt++;
+		if (c == 0) break;			/* End of string */
+		if (c != '%') {				/* Non escape character */
+			putc_bfd(&pb, c);
+			continue;
+		}
+		w = f = 0;
+		c = *fmt++;
+		if (c == '0') {				/* Flag: '0' padding */
+			f = 1; c = *fmt++;
+		} else {
+			if (c == '-') {			/* Flag: left justified */
+				f = 2; c = *fmt++;
+			}
+		}
+		while (IsDigit(c)) {		/* Precision */
+			w = w * 10 + c - '0';
+			c = *fmt++;
+		}
+		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
+			f |= 4; c = *fmt++;
+		}
+		if (!c) break;
+		d = c;
+		if (IsLower(d)) d -= 0x20;
+		switch (d) {				/* Type is... */
+		case 'S' :					/* String */
+			p = va_arg(arp, TCHAR*);
+			for (j = 0; p[j]; j++) ;
+			if (!(f & 2)) {
+				while (j++ < w) putc_bfd(&pb, ' ');
+			}
+			while (*p) putc_bfd(&pb, *p++);
+			while (j++ < w) putc_bfd(&pb, ' ');
+			continue;
+		case 'C' :					/* Character */
+			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
+		case 'B' :					/* Binary */
+			r = 2; break;
+		case 'O' :					/* Octal */
+			r = 8; break;
+		case 'D' :					/* Signed decimal */
+		case 'U' :					/* Unsigned decimal */
+			r = 10; break;
+		case 'X' :					/* Hexdecimal */
+			r = 16; break;
+		default:					/* Unknown type (pass-through) */
+			putc_bfd(&pb, c); continue;
+		}
+
+		/* Get an argument and put it in numeral */
+		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
+		if (d == 'D' && (v & 0x80000000)) {
+			v = 0 - v;
+			f |= 8;
+		}
+		i = 0;
+		do {
+			d = (TCHAR)(v % r); v /= r;
+			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
+			str[i++] = d + '0';
+		} while (v && i < sizeof str / sizeof str[0]);
+		if (f & 8) str[i++] = '-';
+		j = i; d = (f & 1) ? '0' : ' ';
+		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
+		do putc_bfd(&pb, str[--i]); while (i);
+		while (j++ < w) putc_bfd(&pb, d);
+	}
+
+	va_end(arp);
+
+	return putc_flush(&pb);
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _USE_STRFUNC */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/src/mmc.c ./libs/elm-chan-FatFs/fatfs_ssp/src/mmc.c
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/src/mmc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/src/mmc.c	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,636 @@
+/*-----------------------------------------------------------------------*/
+/* MMCv3/SDv1/SDv2 (in SPI mode) control module  (C)ChaN, 2007           */
+/*-----------------------------------------------------------------------*/
+/* Only rcvr_spi(), xmit_spi(), disk_timerproc() and some macros         */
+/* are platform dependent.                                               */
+/*-----------------------------------------------------------------------*/
+
+
+#include "board.h"
+#include "diskio.h"
+
+/* Definitions for MMC/SDC command */
+#define CMD0_	(0x40+0)	    /* GO_IDLE_STATE */
+#define CMD1	(0x40+1)	    /* SEND_OP_COND (MMC) */
+#define	ACMD41	(0xC0+41) /* SEND_OP_COND (SDC) */
+#define CMD8	(0x40+8)	    /* SEND_IF_COND */
+#define CMD9	(0x40+9)	    /* SEND_CSD */
+#define CMD10	(0x40+10)	 /* SEND_CID */
+#define CMD12	(0x40+12)	 /* STOP_TRANSMISSION */
+#define ACMD13	(0xC0+13)	 /* SD_STATUS (SDC) */
+#define CMD16	(0x40+16)	 /* SET_BLOCKLEN */
+#define CMD17	(0x40+17)	 /* READ_SINGLE_BLOCK */
+#define CMD18	(0x40+18)	 /* READ_MULTIPLE_BLOCK */
+#define CMD23	(0x40+23)	 /* SET_BLOCK_COUNT (MMC) */
+#define ACMD23 (0xC0+23)    /* SET_WR_BLK_ERASE_COUNT (SDC) */
+#define CMD24	(0x40+24)	 /* WRITE_BLOCK */
+#define CMD25	(0x40+25)	 /* WRITE_MULTIPLE_BLOCK */
+#define CMD55	(0x40+55)	 /* APP_CMD */
+#define CMD58	(0x40+58)	 /* READ_OCR */
+
+#define BOOL 	bool
+
+/* Port Controls  (Platform dependent) */
+#define CS_LOW()    Chip_GPIO_SetPinOutLow(LPC_GPIO_PORT, 3, 0)
+#define CS_HIGH()   Chip_GPIO_SetPinOutHigh(LPC_GPIO_PORT, 3, 0)
+
+#define	FCLK_SLOW()					/* Set slow clock (100k-400k) */
+#define	FCLK_FAST()					/* Set fast clock (depends on the CSD) */
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Functions
+
+---------------------------------------------------------------------------*/
+
+static volatile
+DSTATUS Stat = STA_NOINIT;	/* Disk status */
+
+static volatile
+BYTE Timer1, Timer2;	/* 100Hz decrement timer */
+
+static
+BYTE CardType;			/* Card type flags */
+
+static void SSPSend(uint8_t *buf, uint32_t Length)
+{
+    Chip_SSP_DATA_SETUP_T xferConfig;
+
+	xferConfig.tx_data = buf;
+	xferConfig.tx_cnt  = 0;
+	xferConfig.rx_data = NULL;
+	xferConfig.rx_cnt  = 0;
+	xferConfig.length  = Length;
+
+	Chip_SSP_RWFrames_Blocking(LPC_SSP1, &xferConfig);
+}
+
+void SSPReceive( uint8_t *buf, uint32_t Length )
+{
+    Chip_SSP_DATA_SETUP_T xferConfig;
+
+	xferConfig.tx_data = NULL;
+	xferConfig.tx_cnt  = 0;
+	xferConfig.rx_data = buf;
+	xferConfig.rx_cnt  = 0;
+	xferConfig.length  = Length;
+
+	Chip_SSP_RWFrames_Blocking(LPC_SSP1, &xferConfig);
+}
+
+
+/*-----------------------------------------------------------------------*/
+/* Transmit a byte to MMC via SPI  (Platform dependent)                  */
+/*-----------------------------------------------------------------------*/
+
+//#define xmit_spi(dat) (SSPSend((uint8_t*)&(dat), 1))
+static void xmit_spi(BYTE dat)
+{
+    SSPSend((uint8_t*) &dat, 1);
+}
+
+
+/*-----------------------------------------------------------------------*/
+/* Receive a byte from MMC via SPI  (Platform dependent)                 */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE rcvr_spi (void)
+{
+    BYTE data = 0;
+
+    SSPReceive(&data, 1);
+
+    return data;
+}
+
+/* Alternative macro to receive data fast */
+
+#define rcvr_spi_m(dst) \
+    do { \
+        SSPReceive((uint8_t*)(dst), 1); \
+    } while(0)
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Wait for card ready                                                   */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE wait_ready (void)
+{
+	BYTE res;
+
+
+	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
+	rcvr_spi();
+	do
+		res = rcvr_spi();
+	while ((res != 0xFF) && Timer2);
+
+	return res;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Deselect the card and release SPI bus                                 */
+/*-----------------------------------------------------------------------*/
+
+static
+void deselect (void)
+{
+	CS_HIGH();
+	rcvr_spi();
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Select the card and wait ready                                        */
+/*-----------------------------------------------------------------------*/
+
+static
+BOOL select_ (void)	/* TRUE:Successful, FALSE:Timeout */
+{
+	CS_LOW();
+	if (wait_ready() != 0xFF) {
+		deselect();
+		return FALSE;
+	}
+	return TRUE;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Power Control  (Platform dependent)                                   */
+/*-----------------------------------------------------------------------*/
+/* When the target system does not support socket power control, there   */
+/* is nothing to do in these functions and chk_power always returns 1.   */
+
+static
+void power_on (void)
+{
+}
+
+static
+void power_off (void)
+{
+}
+
+static
+int chk_power(void)		/* Socket power state: 0=off, 1=on */
+{
+	return 1;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Receive a data packet from MMC                                        */
+/*-----------------------------------------------------------------------*/
+
+static
+BOOL rcvr_datablock (
+	BYTE *buff,			/* Data buffer to store received data */
+	UINT btr			/* Byte count (must be multiple of 4) */
+)
+{
+	BYTE token;
+
+
+	Timer1 = 20;
+	do {							/* Wait for data packet in timeout of 200ms */
+		token = rcvr_spi();
+	} while ((token == 0xFF) && Timer1);
+	if(token != 0xFE) return FALSE;	/* If not valid data token, retutn with error */
+
+	do {							/* Receive the data block into buffer */
+		rcvr_spi_m(buff++);
+		rcvr_spi_m(buff++);
+		rcvr_spi_m(buff++);
+		rcvr_spi_m(buff++);
+	} while (btr -= 4);
+	rcvr_spi();						/* Discard CRC */
+	rcvr_spi();
+
+	return TRUE;					/* Return with success */
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Send a data packet to MMC                                             */
+/*-----------------------------------------------------------------------*/
+
+#if _READONLY == 0
+static
+BOOL xmit_datablock (
+	const BYTE *buff,	/* 512 byte data block to be transmitted */
+	BYTE token			/* Data/Stop token */
+)
+{
+	BYTE resp, wc;
+
+
+	if (wait_ready() != 0xFF) return FALSE;
+
+	xmit_spi(token);					/* Xmit data token */
+	if (token != 0xFD) {	/* Is data token */
+		wc = 0;
+		do {							/* Xmit the 512 byte data block to MMC */
+			xmit_spi(*buff++);
+			xmit_spi(*buff++);
+		} while (--wc);
+		xmit_spi(0xFF);					/* CRC (Dummy) */
+		xmit_spi(0xFF);
+		resp = rcvr_spi();				/* Reveive data response */
+		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
+			return FALSE;
+	}
+
+	return TRUE;
+}
+#endif /* _READONLY */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Send a command packet to MMC                                          */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE send_cmd (
+	BYTE cmd,		/* Command byte */
+	DWORD arg		/* Argument */
+)
+{
+	BYTE n, res;
+
+
+	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
+		cmd &= 0x7F;
+		res = send_cmd(CMD55, 0);
+		if (res > 1) return res;
+	}
+
+	/* Select the card and wait for ready */
+	deselect();
+	if (!select_()) return 0xFF;
+
+	/* Send command packet */
+	xmit_spi(cmd);						/* Start + Command index */
+	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
+	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
+	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
+	xmit_spi((BYTE)arg);				/* Argument[7..0] */
+	n = 0x01;							/* Dummy CRC + Stop */
+	if (cmd == CMD0_) n = 0x95;			/* Valid CRC for CMD0_(0) */
+	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
+	xmit_spi(n);
+
+	/* Receive command response */
+	if (cmd == CMD12) rcvr_spi();		/* Skip a stuff byte when stop reading */
+	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
+	do
+		res = rcvr_spi();
+	while ((res & 0x80) && --n);
+
+	return res;			/* Return with the response value */
+}
+
+
+
+/*--------------------------------------------------------------------------
+
+   Public Functions
+
+---------------------------------------------------------------------------*/
+
+
+/*-----------------------------------------------------------------------*/
+/* Initialize Disk Drive                                                 */
+/*-----------------------------------------------------------------------*/
+
+DSTATUS disk_initialize (
+	BYTE drv		/* Physical drive nmuber (0) */
+)
+{
+	BYTE n, cmd, ty, ocr[4];
+
+	if (drv) return STA_NOINIT;			/* Supports only single drive */
+	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
+
+	power_on();							/* Force socket power on */
+	FCLK_SLOW();
+	for (n = 10; n; n--) rcvr_spi();	/* 80 dummy clocks */
+
+	ty = 0;
+	if (send_cmd(CMD0_, 0) == 1) {			/* Enter Idle state */
+		Timer1 = 100;						/* Initialization timeout of 1000 msec */
+		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDHC */
+			for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();		/* Get trailing return value of R7 resp */
+			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
+				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
+				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
+					for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();
+					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
+				}
+			}
+		} else {							/* SDSC or MMC */
+			if (send_cmd(ACMD41, 0) <= 1) 	{
+				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
+			} else {
+				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
+			}
+			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
+			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
+				ty = 0;
+		}
+	}
+	CardType = ty;
+	deselect();
+
+	if (ty) {			/* Initialization succeded */
+		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
+		FCLK_FAST();
+	} else {			/* Initialization failed */
+		power_off();
+	}
+
+	return Stat;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get Disk Status                                                       */
+/*-----------------------------------------------------------------------*/
+
+DSTATUS disk_status (
+	BYTE drv		/* Physical drive nmuber (0) */
+)
+{
+	if (drv) return STA_NOINIT;		/* Supports only single drive */
+	return Stat;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Sector(s)                                                        */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_read (
+	BYTE drv,			/* Physical drive nmuber (0) */
+	BYTE *buff,			/* Pointer to the data buffer to store read data */
+	DWORD sector,		/* Start sector number (LBA) */
+	UINT count			/* Sector count (1..255) */
+)
+{
+	if (drv || !count) return RES_PARERR;
+	if (Stat & STA_NOINIT) return RES_NOTRDY;
+
+	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
+
+	if (count == 1) {	/* Single block read */
+		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
+			&& rcvr_datablock(buff, 512))
+			count = 0;
+	}
+	else {				/* Multiple block read */
+		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
+			do {
+				if (!rcvr_datablock(buff, 512)) break;
+				buff += 512;
+			} while (--count);
+			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
+		}
+	}
+	deselect();
+
+	return count ? RES_ERROR : RES_OK;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Write Sector(s)                                                       */
+/*-----------------------------------------------------------------------*/
+
+#if _READONLY == 0
+DRESULT disk_write (
+	BYTE drv,			/* Physical drive nmuber (0) */
+	const BYTE *buff,	/* Pointer to the data to be written */
+	DWORD sector,		/* Start sector number (LBA) */
+	UINT count			/* Sector count (1..255) */
+)
+{
+	if (drv || !count) return RES_PARERR;
+	if (Stat & STA_NOINIT) return RES_NOTRDY;
+	if (Stat & STA_PROTECT) return RES_WRPRT;
+
+	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
+
+	if (count == 1) {	/* Single block write */
+		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
+			&& xmit_datablock(buff, 0xFE))
+			count = 0;
+	}
+	else {				/* Multiple block write */
+		if (CardType & CT_SDC) send_cmd(ACMD23, count);
+		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
+			do {
+				if (!xmit_datablock(buff, 0xFC)) break;
+				buff += 512;
+			} while (--count);
+			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
+				count = 1;
+		}
+	}
+	deselect();
+
+	return count ? RES_ERROR : RES_OK;
+}
+#endif /* _READONLY == 0 */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Miscellaneous Functions                                               */
+/*-----------------------------------------------------------------------*/
+
+#if _USE_IOCTL != 0
+DRESULT disk_ioctl (
+	BYTE drv,		/* Physical drive nmuber (0) */
+	BYTE ctrl,		/* Control code */
+	void *buff		/* Buffer to send/receive control data */
+)
+{
+	DRESULT res;
+	BYTE n, csd[16], *ptr = buff;
+	WORD csize;
+
+
+	if (drv) return RES_PARERR;
+
+	res = RES_ERROR;
+
+	if (ctrl == CTRL_POWER) {
+		switch (*ptr) {
+		case 0:		/* Sub control code == 0 (POWER_OFF) */
+			if (chk_power())
+				power_off();		/* Power off */
+			res = RES_OK;
+			break;
+		case 1:		/* Sub control code == 1 (POWER_ON) */
+			power_on();				/* Power on */
+			res = RES_OK;
+			break;
+		case 2:		/* Sub control code == 2 (POWER_GET) */
+			*(ptr+1) = (BYTE)chk_power();
+			res = RES_OK;
+			break;
+		default :
+			res = RES_PARERR;
+		}
+	}
+	else {
+		if (Stat & STA_NOINIT) return RES_NOTRDY;
+
+		switch (ctrl) {
+		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
+			if (select_()) {
+				res = RES_OK;
+				deselect();
+			}
+			break;
+
+		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
+			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
+				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
+					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
+					*(DWORD*)buff = (DWORD)csize << 10;
+				} else {					/* SDC ver 1.XX or MMC*/
+					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
+					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
+					*(DWORD*)buff = (DWORD)csize << (n - 9);
+				}
+				res = RES_OK;
+			}
+			break;
+
+		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
+			*(WORD*)buff = 512;
+			res = RES_OK;
+			break;
+
+		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
+			if (CardType & CT_SD2) {	/* SDC ver 2.00 */
+				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
+					rcvr_spi();
+					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
+						for (n = 64 - 16; n; n--) rcvr_spi();	/* Purge trailing data */
+						*(DWORD*)buff = 16UL << (csd[10] >> 4);
+						res = RES_OK;
+					}
+				}
+			} else {					/* SDC ver 1.XX or MMC */
+				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
+					if (CardType & CT_SD1) {	/* SDC ver 1.XX */
+						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
+					} else {					/* MMC */
+						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
+					}
+					res = RES_OK;
+				}
+			}
+			break;
+
+		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
+			*ptr = CardType;
+			res = RES_OK;
+			break;
+
+		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
+			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
+				&& rcvr_datablock(ptr, 16))
+				res = RES_OK;
+			break;
+
+		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
+			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
+				&& rcvr_datablock(ptr, 16))
+				res = RES_OK;
+			break;
+
+		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
+			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
+				for (n = 4; n; n--) *ptr++ = rcvr_spi();
+				res = RES_OK;
+			}
+			break;
+
+		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
+			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
+				rcvr_spi();
+				if (rcvr_datablock(ptr, 64))
+					res = RES_OK;
+			}
+			break;
+
+		default:
+			res = RES_PARERR;
+		}
+
+		deselect();
+	}
+
+	return res;
+}
+#endif /* _USE_IOCTL != 0 */
+
+
+/*-----------------------------------------------------------------------*/
+/* Device Timer Interrupt Procedure  (Platform dependent)                */
+/*-----------------------------------------------------------------------*/
+/* This function must be called in period of 10ms                        */
+
+/* TODO: llamar desde SysTick_Handler cada 10ms */
+void disk_timerproc (void)
+{
+	static BYTE pv;
+	BYTE n, s;
+
+
+	n = Timer1;						/* 100Hz decrement timer */
+	if (n) Timer1 = --n;
+	n = Timer2;
+	if (n) Timer2 = --n;
+
+	n = pv;
+	//pv = SOCKPORT & (SOCKWP | SOCKINS);	/* Sample socket switch */
+
+	/* TODO: Actualizar!!! */
+	//pv = ((GPIO_ReadValue(2) & (1<<11)) != 0);
+	pv = (Chip_GPIO_GetPinState(LPC_GPIO_PORT, 2, 11) != 0);
+
+	if (n == pv) {					/* Have contacts stabled? */
+		s = Stat;
+
+		/* write protect NOT supported */
+
+		/* check card detect */
+		if (pv)			       /* (Socket empty) */
+			s |= (STA_NODISK | STA_NOINIT);
+		else				       /* (Card inserted) */
+			s &= ~STA_NODISK;
+
+		Stat = s;
+	}
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/src/rtc.c ./libs/elm-chan-FatFs/fatfs_ssp/src/rtc.c
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_ssp/src/rtc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_ssp/src/rtc.c	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,101 @@
+/*------------------------------------------------------------------------/
+/RTC control module
+/-------------------------------------------------------------------------/
+/
+/  Copyright (C) 2011, ChaN, all right reserved.
+/
+/ * This software is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
+/ * Redistributions of source code must retain the above copyright notice.
+/
+/-------------------------------------------------------------------------*/
+
+#include "chip.h"
+#include "board.h"
+#include "rtc.h"
+
+
+int rtc_initialize (void)
+{
+	static int init;
+	RTC_TIME_T rtcTime;
+
+	if (init) /* Already initialized */
+		return 1;
+
+	/* RTC Block section ------------------------------------------------------ */
+	Chip_RTC_Init(LPC_RTC);
+
+	/* Set current time for RTC */
+	/* Current time is 8:00:00PM, 2013-01-31 */
+	rtcTime.time[RTC_TIMETYPE_SECOND]     = 0;
+	rtcTime.time[RTC_TIMETYPE_MINUTE]     = 0;
+	rtcTime.time[RTC_TIMETYPE_HOUR]       = 20;
+	rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = 31;
+	rtcTime.time[RTC_TIMETYPE_MONTH]      = 1;
+	rtcTime.time[RTC_TIMETYPE_YEAR]       = 2013;
+	Chip_RTC_SetFullAlarmTime(LPC_RTC, &rtcTime);
+
+	/* Enable rtc (starts increase the tick counter and second counter register) */
+	Chip_RTC_Enable(LPC_RTC, ENABLE);
+	init = 1;
+
+	return 1;
+}
+
+int rtc_gettime (RTC *rtc)
+{
+	RTC_TIME_T rtcTime;
+
+	Chip_RTC_GetFullTime(LPC_RTC, &rtcTime);
+
+	rtc->sec = rtcTime.time[RTC_TIMETYPE_SECOND];
+	rtc->min = rtcTime.time[RTC_TIMETYPE_MINUTE];
+	rtc->hour = rtcTime.time[RTC_TIMETYPE_HOUR];
+	rtc->wday = rtcTime.time[RTC_TIMETYPE_DAYOFWEEK];
+	rtc->mday = rtcTime.time[RTC_TIMETYPE_DAYOFMONTH];
+	rtc->month = rtcTime.time[RTC_TIMETYPE_MONTH];
+	rtc->year = rtcTime.time[RTC_TIMETYPE_YEAR];
+  return 1;
+}
+
+int rtc_settime (const RTC *rtc)
+{
+	RTC_TIME_T rtcTime;
+
+	rtcTime.time[RTC_TIMETYPE_SECOND]     = rtc->sec;
+	rtcTime.time[RTC_TIMETYPE_MINUTE]     = rtc->min;
+	rtcTime.time[RTC_TIMETYPE_HOUR]       = rtc->hour;
+	rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->wday;
+	rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->mday;
+	rtcTime.time[RTC_TIMETYPE_MONTH]      = rtc->month;
+	rtcTime.time[RTC_TIMETYPE_YEAR]	      = rtc->year;
+
+	Chip_RTC_GetFullTime(LPC_RTC, &rtcTime);
+
+  return 1;
+}
+
+/**
+ * @brief	User Provided Timer Function for FatFs module
+ * @return	Nothing
+ * @note	This is a real time clock service to be called from FatFs module.
+ * Any valid time must be returned even if the system does not support a real time clock.
+ * This is not required in read-only configuration.
+ */
+DWORD get_fattime()
+{
+	RTC rtc;
+
+	/* Get local time */
+	rtc_gettime(&rtc);
+
+	/* Pack date and time into a DWORD variable */
+	return ((DWORD) (rtc.year - 1980) << 25)
+		   | ((DWORD) rtc.month << 21)
+		   | ((DWORD) rtc.mday << 16)
+		   | ((DWORD) rtc.hour << 11)
+		   | ((DWORD) rtc.min << 5)
+		   | ((DWORD) rtc.sec >> 1);
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/diskio.h ./libs/elm-chan-FatFs/fatfs_usb/inc/diskio.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/diskio.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/inc/diskio.h	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,88 @@
+/*-----------------------------------------------------------------------
+/  Low level disk interface modlue include file   (C)ChaN, 2012
+/-----------------------------------------------------------------------*/
+
+#ifndef _DISKIO_DEFINED
+#define _DISKIO_DEFINED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _USE_WRITE	1	/* 1: Enable disk_write function */
+#define _USE_IOCTL	1	/* 1: Enable disk_ioctl fucntion */
+
+#include "integer.h"
+
+
+/* Status of Disk Functions */
+typedef BYTE	DSTATUS;
+
+/* Results of Disk Functions */
+typedef enum {
+	RES_OK = 0,		/* 0: Successful */
+	RES_ERROR,		/* 1: R/W Error */
+	RES_WRPRT,		/* 2: Write Protected */
+	RES_NOTRDY,		/* 3: Not Ready */
+	RES_PARERR		/* 4: Invalid Parameter */
+} DRESULT;
+
+
+/*---------------------------------------*/
+/* Prototypes for disk control functions */
+
+
+DSTATUS disk_initialize (BYTE);
+DSTATUS disk_status (BYTE);
+DRESULT disk_read (BYTE, BYTE*, DWORD, BYTE);
+DRESULT disk_write (BYTE, const BYTE*, DWORD, BYTE);
+DRESULT disk_ioctl (BYTE, BYTE, void*);
+
+
+/* Disk Status Bits (DSTATUS) */
+#define STA_NOINIT		0x01	/* Drive not initialized */
+#define STA_NODISK		0x02	/* No medium in the drive */
+#define STA_PROTECT		0x04	/* Write protected */
+
+
+/* Command code for disk_ioctrl fucntion */
+
+/* Generic command (used by FatFs) */
+#define CTRL_SYNC			0	/* Flush disk cache (for write functions) */
+#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
+#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
+#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
+#define CTRL_ERASE_SECTOR	4	/* Force erased a block of sectors (for only _USE_ERASE) */
+
+/* Generic command (not used by FatFs) */
+#define CTRL_POWER			5	/* Get/Set power status */
+#define CTRL_LOCK			6	/* Lock/Unlock media removal */
+#define CTRL_EJECT			7	/* Eject media */
+#define CTRL_FORMAT			8	/* Create physical format on the media */
+
+/* MMC/SDC specific ioctl command */
+#define MMC_GET_TYPE		10	/* Get card type */
+#define MMC_GET_CSD			11	/* Get CSD */
+#define MMC_GET_CID			12	/* Get CID */
+#define MMC_GET_OCR			13	/* Get OCR */
+#define MMC_GET_SDSTAT		14	/* Get SD status */
+
+/* ATA/CF specific ioctl command */
+#define ATA_GET_REV			20	/* Get F/W revision */
+#define ATA_GET_MODEL		21	/* Get model name */
+#define ATA_GET_SN			22	/* Get serial number */
+
+
+/* MMC card type flags (MMC_GET_TYPE) */
+#define CT_MMC		0x01		/* MMC ver 3 */
+#define CT_SD1		0x02		/* SD ver 1 */
+#define CT_SD2		0x04		/* SD ver 2 */
+#define CT_SDC		(CT_SD1|CT_SD2)	/* SD */
+#define CT_BLOCK	0x08		/* Block addressing */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/ffconf.h ./libs/elm-chan-FatFs/fatfs_usb/inc/ffconf.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/ffconf.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/inc/ffconf.h	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,190 @@
+/*---------------------------------------------------------------------------/
+/  FatFs - FAT file system module configuration file  R0.09a (C)ChaN, 2012
+/----------------------------------------------------------------------------/
+/
+/ CAUTION! Do not forget to make clean the project after any changes to
+/ the configuration options.
+/
+/----------------------------------------------------------------------------*/
+#ifndef _FFCONF
+#define _FFCONF 4004	/* Revision ID */
+
+
+/*---------------------------------------------------------------------------/
+/ Functions and Buffer Configurations
+/----------------------------------------------------------------------------*/
+
+#define	_FS_TINY		0	/* 0:Normal or 1:Tiny */
+/* When _FS_TINY is set to 1, FatFs uses the sector buffer in the file system
+/  object instead of the sector buffer in the individual file object for file
+/  data transfer. This reduces memory consumption 512 bytes each file object. */
+
+
+#define _FS_READONLY	0	/* 0:Read/Write or 1:Read only */
+/* Setting _FS_READONLY to 1 defines read only configuration. This removes
+/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
+/  f_truncate and useless f_getfree. */
+
+
+#define _FS_MINIMIZE	0	/* 0 to 3 */
+/* The _FS_MINIMIZE option defines minimization level to remove some functions.
+/
+/   0: Full function.
+/   1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename
+/      are removed.
+/   2: f_opendir and f_readdir are removed in addition to 1.
+/   3: f_lseek is removed in addition to 2. */
+
+
+#define	_USE_STRFUNC	0	/* 0:Disable or 1-2:Enable */
+/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
+
+
+#define	_USE_MKFS		0	/* 0:Disable or 1:Enable */
+/* To enable f_mkfs function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
+
+
+#define	_USE_FORWARD	0	/* 0:Disable or 1:Enable */
+/* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
+
+
+#define	_USE_FASTSEEK	0	/* 0:Disable or 1:Enable */
+/* To enable fast seek feature, set _USE_FASTSEEK to 1. */
+
+
+
+/*---------------------------------------------------------------------------/
+/ Locale and Namespace Configurations
+/----------------------------------------------------------------------------*/
+
+#define _CODE_PAGE	932
+/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
+/  Incorrect setting of the code page can cause a file open failure.
+/
+/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
+/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
+/   949  - Korean (DBCS, OEM, Windows)
+/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
+/   1250 - Central Europe (Windows)
+/   1251 - Cyrillic (Windows)
+/   1252 - Latin 1 (Windows)
+/   1253 - Greek (Windows)
+/   1254 - Turkish (Windows)
+/   1255 - Hebrew (Windows)
+/   1256 - Arabic (Windows)
+/   1257 - Baltic (Windows)
+/   1258 - Vietnam (OEM, Windows)
+/   437  - U.S. (OEM)
+/   720  - Arabic (OEM)
+/   737  - Greek (OEM)
+/   775  - Baltic (OEM)
+/   850  - Multilingual Latin 1 (OEM)
+/   858  - Multilingual Latin 1 + Euro (OEM)
+/   852  - Latin 2 (OEM)
+/   855  - Cyrillic (OEM)
+/   866  - Russian (OEM)
+/   857  - Turkish (OEM)
+/   862  - Hebrew (OEM)
+/   874  - Thai (OEM, Windows)
+/	1    - ASCII only (Valid for non LFN cfg.)
+*/
+
+
+#define	_USE_LFN	0		/* 0 to 3 */
+#define	_MAX_LFN	255		/* Maximum LFN length to handle (12 to 255) */
+/* The _USE_LFN option switches the LFN support.
+/
+/   0: Disable LFN feature. _MAX_LFN and _LFN_UNICODE have no effect.
+/   1: Enable LFN with static working buffer on the BSS. Always NOT reentrant.
+/   2: Enable LFN with dynamic working buffer on the STACK.
+/   3: Enable LFN with dynamic working buffer on the HEAP.
+/
+/  The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes. To enable LFN,
+/  Unicode handling functions ff_convert() and ff_wtoupper() must be added
+/  to the project. When enable to use heap, memory control functions
+/  ff_memalloc() and ff_memfree() must be added to the project. */
+
+
+#define	_LFN_UNICODE	0	/* 0:ANSI/OEM or 1:Unicode */
+/* To switch the character code set on FatFs API to Unicode,
+/  enable LFN feature and set _LFN_UNICODE to 1. */
+
+
+#define _FS_RPATH		0	/* 0 to 2 */
+/* The _FS_RPATH option configures relative path feature.
+/
+/   0: Disable relative path feature and remove related functions.
+/   1: Enable relative path. f_chdrive() and f_chdir() are available.
+/   2: f_getcwd() is available in addition to 1.
+/
+/  Note that output of the f_readdir fnction is affected by this option. */
+
+
+
+/*---------------------------------------------------------------------------/
+/ Physical Drive Configurations
+/----------------------------------------------------------------------------*/
+
+#define _VOLUMES	1
+/* Number of volumes (logical drives) to be used. */
+
+
+#define	_MAX_SS		512		/* 512, 1024, 2048 or 4096 */
+/* Maximum sector size to be handled.
+/  Always set 512 for memory card and hard disk but a larger value may be
+/  required for on-board flash memory, floppy disk and optical disk.
+/  When _MAX_SS is larger than 512, it configures FatFs to variable sector size
+/  and GET_SECTOR_SIZE command must be implememted to the disk_ioctl function. */
+
+
+#define	_MULTI_PARTITION	0	/* 0:Single partition, 1/2:Enable multiple partition */
+/* When set to 0, each volume is bound to the same physical drive number and
+/ it can mount only first primaly partition. When it is set to 1, each volume
+/ is tied to the partitions listed in VolToPart[]. */
+
+
+#define	_USE_ERASE	0	/* 0:Disable or 1:Enable */
+/* To enable sector erase feature, set _USE_ERASE to 1. CTRL_ERASE_SECTOR command
+/  should be added to the disk_ioctl functio. */
+
+
+
+/*---------------------------------------------------------------------------/
+/ System Configurations
+/----------------------------------------------------------------------------*/
+
+#define _WORD_ACCESS	0	/* 0 or 1 */
+/* Set 0 first and it is always compatible with all platforms. The _WORD_ACCESS
+/  option defines which access method is used to the word data on the FAT volume.
+/
+/   0: Byte-by-byte access.
+/   1: Word access. Do not choose this unless following condition is met.
+/
+/  When the byte order on the memory is big-endian or address miss-aligned word
+/  access results incorrect behavior, the _WORD_ACCESS must be set to 0.
+/  If it is not the case, the value can also be set to 1 to improve the
+/  performance and code size.
+*/
+
+
+/* A header file that defines sync object types on the O/S, such as
+/  windows.h, ucos_ii.h and semphr.h, must be included prior to ff.h. */
+
+#define _FS_REENTRANT	0		/* 0:Disable or 1:Enable */
+#define _FS_TIMEOUT		1000	/* Timeout period in unit of time ticks */
+#define	_SYNC_t			HANDLE	/* O/S dependent type of sync object. e.g. HANDLE, OS_EVENT*, ID and etc.. */
+
+/* The _FS_REENTRANT option switches the reentrancy (thread safe) of the FatFs module.
+/
+/   0: Disable reentrancy. _SYNC_t and _FS_TIMEOUT have no effect.
+/   1: Enable reentrancy. Also user provided synchronization handlers,
+/      ff_req_grant, ff_rel_grant, ff_del_syncobj and ff_cre_syncobj
+/      function must be added to the project. */
+
+
+#define	_FS_LOCK	0	/* 0:Disable or >=1:Enable */
+/* To enable file lock control feature, set _FS_LOCK to 1 or greater.
+   The value defines how many files can be opened simultaneously. */
+
+
+#endif /* _FFCONFIG */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/ff.h ./libs/elm-chan-FatFs/fatfs_usb/inc/ff.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/ff.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/inc/ff.h	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,337 @@
+/*---------------------------------------------------------------------------/
+/  FatFs - FAT file system module include file  R0.09a    (C)ChaN, 2012
+/----------------------------------------------------------------------------/
+/ FatFs module is a generic FAT file system module for small embedded systems.
+/ This is a free software that opened for education, research and commercial
+/ developments under license policy of following terms.
+/
+/  Copyright (C) 2012, ChaN, all right reserved.
+/
+/ * The FatFs module is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
+/ * Redistributions of source code must retain the above copyright notice.
+/
+/----------------------------------------------------------------------------*/
+
+#ifndef _FATFS
+#define _FATFS	4004	/* Revision ID */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "integer.h"	/* Basic integer types */
+#include "ffconf.h"		/* FatFs configuration options */
+
+#if _FATFS != _FFCONF
+#error Wrong configuration file (ffconf.h).
+#endif
+
+
+
+/* Definitions of volume management */
+
+#if _MULTI_PARTITION		/* Multiple partition configuration */
+typedef struct {
+	BYTE pd;	/* Physical drive number */
+	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
+} PARTITION;
+extern PARTITION VolToPart[];	/* Volume - Partition resolution table */
+#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
+#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
+
+#else							/* Single partition configuration */
+#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
+#define LD2PT(vol) 0			/* Always mounts the 1st partition or in SFD */
+
+#endif
+
+
+
+/* Type of path name strings on FatFs API */
+
+#if _LFN_UNICODE			/* Unicode string */
+#if !_USE_LFN
+#error _LFN_UNICODE must be 0 in non-LFN cfg.
+#endif
+#ifndef _INC_TCHAR
+typedef WCHAR TCHAR;
+#define _T(x) L ## x
+#define _TEXT(x) L ## x
+#endif
+
+#else						/* ANSI/OEM string */
+#ifndef _INC_TCHAR
+typedef char TCHAR;
+#define _T(x) x
+#define _TEXT(x) x
+#endif
+
+#endif
+
+
+
+/* File system object structure (FATFS) */
+
+typedef struct {
+	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
+	BYTE	drv;			/* Physical drive number */
+	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
+	BYTE	n_fats;			/* Number of FAT copies (1,2) */
+	BYTE	wflag;			/* win[] dirty flag (1:must be written back) */
+	BYTE	fsi_flag;		/* fsinfo dirty flag (1:must be written back) */
+	WORD	id;				/* File system mount ID */
+	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
+#if _MAX_SS != 512
+	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
+#endif
+#if _FS_REENTRANT
+	_SYNC_t	sobj;			/* Identifier of sync object */
+#endif
+#if !_FS_READONLY
+	DWORD	last_clust;		/* Last allocated cluster */
+	DWORD	free_clust;		/* Number of free clusters */
+	DWORD	fsi_sector;		/* fsinfo sector (FAT32) */
+#endif
+#if _FS_RPATH
+	DWORD	cdir;			/* Current directory start cluster (0:root) */
+#endif
+	DWORD	n_fatent;		/* Number of FAT entries (= number of clusters + 2) */
+	DWORD	fsize;			/* Sectors per FAT */
+	DWORD	fatbase;		/* FAT start sector */
+	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
+	DWORD	database;		/* Data start sector */
+	DWORD	winsect;		/* Current sector appearing in the win[] */
+	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and Data on tiny cfg) */
+} FATFS;
+
+
+
+/* File object structure (FIL) */
+
+typedef struct {
+	FATFS*	fs;				/* Pointer to the related file system object */
+	WORD	id;				/* File system mount ID of the related file system object */
+	BYTE	flag;			/* File status flags */
+	BYTE	pad1;
+	DWORD	fptr;			/* File read/write pointer (0ed on file open) */
+	DWORD	fsize;			/* File size */
+	DWORD	sclust;			/* File data start cluster (0:no data cluster, always 0 when fsize is 0) */
+	DWORD	clust;			/* Current cluster of fpter */
+	DWORD	dsect;			/* Current data sector of fpter */
+#if !_FS_READONLY
+	DWORD	dir_sect;		/* Sector containing the directory entry */
+	BYTE*	dir_ptr;		/* Pointer to the directory entry in the window */
+#endif
+#if _USE_FASTSEEK
+	DWORD*	cltbl;			/* Pointer to the cluster link map table (null on file open) */
+#endif
+#if _FS_LOCK
+	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
+#endif
+#if !_FS_TINY
+	BYTE	buf[_MAX_SS];	/* File data read/write buffer */
+#endif
+} FIL;
+
+
+
+/* Directory object structure (DIR) */
+
+typedef struct {
+	FATFS*	fs;				/* Pointer to the owner file system object */
+	WORD	id;				/* Owner file system mount ID */
+	WORD	index;			/* Current read/write index number */
+	DWORD	sclust;			/* Table start cluster (0:Root dir) */
+	DWORD	clust;			/* Current cluster */
+	DWORD	sect;			/* Current sector */
+	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
+	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
+#if _USE_LFN
+	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
+	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
+#endif
+} DIR;
+
+
+
+/* File status structure (FILINFO) */
+
+typedef struct {
+	DWORD	fsize;			/* File size */
+	WORD	fdate;			/* Last modified date */
+	WORD	ftime;			/* Last modified time */
+	BYTE	fattrib;		/* Attribute */
+	TCHAR	fname[13];		/* Short file name (8.3 format) */
+#if _USE_LFN
+	TCHAR*	lfname;			/* Pointer to the LFN buffer */
+	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
+#endif
+} FILINFO;
+
+
+
+/* File function return code (FRESULT) */
+
+typedef enum {
+	FR_OK = 0,				/* (0) Succeeded */
+	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
+	FR_INT_ERR,				/* (2) Assertion failed */
+	FR_NOT_READY,			/* (3) The physical drive cannot work */
+	FR_NO_FILE,				/* (4) Could not find the file */
+	FR_NO_PATH,				/* (5) Could not find the path */
+	FR_INVALID_NAME,		/* (6) The path name format is invalid */
+	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
+	FR_EXIST,				/* (8) Access denied due to prohibited access */
+	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
+	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
+	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
+	FR_NOT_ENABLED,			/* (12) The volume has no work area */
+	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
+	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
+	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
+	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
+	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
+	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
+	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
+} FRESULT;
+
+
+
+/*--------------------------------------------------------------*/
+/* FatFs module application interface                           */
+
+FRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
+FRESULT f_open (FIL*, const TCHAR*, BYTE);			/* Open or create a file */
+FRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
+FRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
+FRESULT f_close (FIL*);								/* Close an open file object */
+FRESULT f_opendir (DIR*, const TCHAR*);				/* Open an existing directory */
+FRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
+FRESULT f_stat (const TCHAR*, FILINFO*);			/* Get file status */
+FRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
+FRESULT f_getfree (const TCHAR*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
+FRESULT f_truncate (FIL*);							/* Truncate file */
+FRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
+FRESULT f_unlink (const TCHAR*);					/* Delete an existing file or directory */
+FRESULT	f_mkdir (const TCHAR*);						/* Create a new directory */
+FRESULT f_chmod (const TCHAR*, BYTE, BYTE);			/* Change attribute of the file/dir */
+FRESULT f_utime (const TCHAR*, const FILINFO*);		/* Change times-tamp of the file/dir */
+FRESULT f_rename (const TCHAR*, const TCHAR*);		/* Rename/Move a file or directory */
+FRESULT f_chdrive (BYTE);							/* Change current drive */
+FRESULT f_chdir (const TCHAR*);						/* Change current directory */
+FRESULT f_getcwd (TCHAR*, UINT);					/* Get current directory */
+FRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);	/* Forward data to the stream */
+FRESULT f_mkfs (BYTE, BYTE, UINT);					/* Create a file system on the drive */
+FRESULT	f_fdisk (BYTE, const DWORD[], void*);		/* Divide a physical drive into some partitions */
+int f_putc (TCHAR, FIL*);							/* Put a character to the file */
+int f_puts (const TCHAR*, FIL*);					/* Put a string to the file */
+int f_printf (FIL*, const TCHAR*, ...);				/* Put a formatted string to the file */
+TCHAR* f_gets (TCHAR*, int, FIL*);					/* Get a string from the file */
+
+#define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
+#define f_error(fp) (((fp)->flag & FA__ERROR) ? 1 : 0)
+#define f_tell(fp) ((fp)->fptr)
+#define f_size(fp) ((fp)->fsize)
+
+#ifndef EOF
+#define EOF (-1)
+#endif
+
+
+
+
+/*--------------------------------------------------------------*/
+/* Additional user defined functions                            */
+
+/* RTC function */
+#if !_FS_READONLY
+DWORD get_fattime (void);
+#endif
+
+/* Unicode support functions */
+#if _USE_LFN						/* Unicode - OEM code conversion */
+WCHAR ff_convert (WCHAR, UINT);		/* OEM-Unicode bidirectional conversion */
+WCHAR ff_wtoupper (WCHAR);			/* Unicode upper-case conversion */
+#if _USE_LFN == 3					/* Memory functions */
+void* ff_memalloc (UINT);			/* Allocate memory block */
+void ff_memfree (void*);			/* Free memory block */
+#endif
+#endif
+
+/* Sync functions */
+#if _FS_REENTRANT
+int ff_cre_syncobj (BYTE, _SYNC_t*);/* Create a sync object */
+int ff_req_grant (_SYNC_t);			/* Lock sync object */
+void ff_rel_grant (_SYNC_t);		/* Unlock sync object */
+int ff_del_syncobj (_SYNC_t);		/* Delete a sync object */
+#endif
+
+
+
+
+/*--------------------------------------------------------------*/
+/* Flags and offset address                                     */
+
+
+/* File access control and file status flags (FIL.flag) */
+
+#define	FA_READ				0x01
+#define	FA_OPEN_EXISTING	0x00
+#define FA__ERROR			0x80
+
+#if !_FS_READONLY
+#define	FA_WRITE			0x02
+#define	FA_CREATE_NEW		0x04
+#define	FA_CREATE_ALWAYS	0x08
+#define	FA_OPEN_ALWAYS		0x10
+#define FA__WRITTEN			0x20
+#define FA__DIRTY			0x40
+#endif
+
+
+/* FAT sub type (FATFS.fs_type) */
+
+#define FS_FAT12	1
+#define FS_FAT16	2
+#define FS_FAT32	3
+
+
+/* File attribute bits for directory entry */
+
+#define	AM_RDO	0x01	/* Read only */
+#define	AM_HID	0x02	/* Hidden */
+#define	AM_SYS	0x04	/* System */
+#define	AM_VOL	0x08	/* Volume label */
+#define AM_LFN	0x0F	/* LFN entry */
+#define AM_DIR	0x10	/* Directory */
+#define AM_ARC	0x20	/* Archive */
+#define AM_MASK	0x3F	/* Mask of defined bits */
+
+
+/* Fast seek feature */
+#define CREATE_LINKMAP	0xFFFFFFFF
+
+
+
+/*--------------------------------*/
+/* Multi-byte word access macros  */
+
+#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
+#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
+#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
+#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
+#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
+#else					/* Use byte-by-byte access to the FAT structure */
+#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
+#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
+#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
+#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FATFS */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/integer.h ./libs/elm-chan-FatFs/fatfs_usb/inc/integer.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/integer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/inc/integer.h	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,37 @@
+/*-------------------------------------------*/
+/* Integer type definitions for FatFs module */
+/*-------------------------------------------*/
+
+#ifndef _INTEGER
+#define _INTEGER
+
+#ifdef _WIN32	/* FatFs development platform */
+
+#include <windows.h>
+#include <tchar.h>
+
+#else			/* Embedded platform */
+
+/* These types must be 16-bit, 32-bit or larger integer */
+typedef int				INT;
+typedef unsigned int	UINT;
+
+/* These types must be 8-bit integer */
+//typedef char			CHAR;
+typedef unsigned char	UCHAR;
+typedef unsigned char	BYTE;
+
+/* These types must be 16-bit integer */
+typedef short			SHORT;
+typedef unsigned short	USHORT;
+typedef unsigned short	WORD;
+typedef unsigned short	WCHAR;
+
+/* These types must be 32-bit integer */
+typedef long			LONG;
+typedef unsigned long	ULONG;
+typedef unsigned long	DWORD;
+
+#endif
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/rtc.h ./libs/elm-chan-FatFs/fatfs_usb/inc/rtc.h
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/inc/rtc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/inc/rtc.h	2018-12-01 17:15:06.589605789 -0300
@@ -0,0 +1,20 @@
+#ifndef _RTC_DEFINED
+#define _RTC_DEFINED
+
+#include "integer.h"
+
+typedef struct {
+	WORD	year;	/* 1..4095 */
+	BYTE	month;	/* 1..12 */
+	BYTE	mday;	/* 1.. 31 */
+	BYTE	wday;	/* 1..7 */
+	BYTE	hour;	/* 0..23 */
+	BYTE	min;	/* 0..59 */
+	BYTE	sec;	/* 0..59 */
+} RTC;
+
+int rtc_initialize (void);		/* Initialize RTC */
+int rtc_gettime (RTC*);			/* Get time */
+int rtc_settime (const RTC*);	/* Set time */
+
+#endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/src/ff.c ./libs/elm-chan-FatFs/fatfs_usb/src/ff.c
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/src/ff.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/src/ff.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,4139 @@
+/*----------------------------------------------------------------------------/
+/  FatFs - FAT file system module  R0.09a                 (C)ChaN, 2012
+/-----------------------------------------------------------------------------/
+/ FatFs module is a generic FAT file system module for small embedded systems.
+/ This is a free software that opened for education, research and commercial
+/ developments under license policy of following terms.
+/
+/  Copyright (C) 2012, ChaN, all right reserved.
+/
+/ * The FatFs module is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
+/ * Redistributions of source code must retain the above copyright notice.
+/
+/-----------------------------------------------------------------------------/
+/ Feb 26,'06 R0.00  Prototype.
+/
+/ Apr 29,'06 R0.01  First stable version.
+/
+/ Jun 01,'06 R0.02  Added FAT12 support.
+/                   Removed unbuffered mode.
+/                   Fixed a problem on small (<32M) partition.
+/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
+/
+/ Sep 22,'06 R0.03  Added f_rename().
+/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
+/ Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
+/                   Fixed f_mkdir() creates incorrect directory on FAT32.
+/
+/ Feb 04,'07 R0.04  Supported multiple drive system.
+/                   Changed some interfaces for multiple drive system.
+/                   Changed f_mountdrv() to f_mount().
+/                   Added f_mkfs().
+/ Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
+/                   Added a capability of extending file size to f_lseek().
+/                   Added minimization level 3.
+/                   Fixed an endian sensitive code in f_mkfs().
+/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
+/                   Added FSInfo support.
+/                   Fixed DBCS name can result FR_INVALID_NAME.
+/                   Fixed short seek (<= csize) collapses the file object.
+/
+/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
+/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
+/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
+/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
+/                   Fixed off by one error at FAT sub-type determination.
+/                   Fixed btr in f_read() can be mistruncated.
+/                   Fixed cached sector is not flushed when create and close without write.
+/
+/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
+/                   Improved performance of f_lseek() on moving to the same or following cluster.
+/
+/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
+/                   Added long file name feature.
+/                   Added multiple code page feature.
+/                   Added re-entrancy for multitask operation.
+/                   Added auto cluster size selection to f_mkfs().
+/                   Added rewind option to f_readdir().
+/                   Changed result code of critical errors.
+/                   Renamed string functions to avoid name collision.
+/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
+/                   Added multiple sector size feature.
+/ Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
+/                   Fixed wrong cache control in f_lseek().
+/                   Added relative path feature.
+/                   Added f_chdir() and f_chdrive().
+/                   Added proper case conversion to extended char.
+/ Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
+/                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
+/                   Fixed name matching error on the 13 char boundary.
+/                   Added a configuration option, _LFN_UNICODE.
+/                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
+/
+/ May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
+/                   Added file lock feature. (_FS_SHARE)
+/                   Added fast seek feature. (_USE_FASTSEEK)
+/                   Changed some types on the API, XCHAR->TCHAR.
+/                   Changed fname member in the FILINFO structure on Unicode cfg.
+/                   String functions support UTF-8 encoding files on Unicode cfg.
+/ Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
+/                   Added sector erase feature. (_USE_ERASE)
+/                   Moved file lock semaphore table from fs object to the bss.
+/                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
+/                   Fixed f_mkfs() creates wrong FAT32 volume.
+/ Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
+/                   f_lseek() reports required table size on creating CLMP.
+/                   Extended format syntax of f_printf function.
+/                   Ignores duplicated directory separators in given path name.
+/
+/ Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
+/                   Added f_fdisk(). (_MULTI_PARTITION = 2)
+/ Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
+/                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
+/                   Changed option name _FS_SHARE to _FS_LOCK.
+/---------------------------------------------------------------------------*/
+
+#include "ff.h"			/* FatFs configurations and declarations */
+#include "diskio.h"		/* Declarations of low level disk I/O functions */
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Definitions
+
+---------------------------------------------------------------------------*/
+
+#if _FATFS != 4004	/* Revision ID */
+#error Wrong include file (ff.h).
+#endif
+
+
+/* Definitions on sector size */
+#if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
+#error Wrong sector size.
+#endif
+#if _MAX_SS != 512
+#define	SS(fs)	((fs)->ssize)	/* Variable sector size */
+#else
+#define	SS(fs)	512U			/* Fixed sector size */
+#endif
+
+
+/* Reentrancy related */
+#if _FS_REENTRANT
+#if _USE_LFN == 1
+#error Static LFN work area must not be used in re-entrant configuration.
+#endif
+#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
+#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
+#else
+#define	ENTER_FF(fs)
+#define LEAVE_FF(fs, res)	return res
+#endif
+
+#define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
+
+
+/* File access control feature */
+#if _FS_LOCK
+#if _FS_READONLY
+#error _FS_LOCK must be 0 on read-only cfg.
+#endif
+typedef struct {
+	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
+	DWORD clu;				/* File ID 2, directory */
+	WORD idx;				/* File ID 3, directory index */
+	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
+} FILESEM;
+#endif
+
+
+
+/* DBCS code ranges and SBCS extend char conversion table */
+
+#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
+#define _DF1S	0x81	/* DBC 1st byte range 1 start */
+#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
+#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
+#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
+#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
+#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
+#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
+#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
+
+#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0x80
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 949	/* Korean */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x41
+#define _DS1E	0x5A
+#define _DS2S	0x61
+#define _DS2E	0x7A
+#define _DS3S	0x81
+#define _DS3E	0xFE
+
+#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0xA1
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 437	/* U.S. (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 720	/* Arabic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 737	/* Greek (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
+				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 775	/* Baltic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
+
+#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
+				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
+				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 857	/* Turkish (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 866	/* Russian (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+
+#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
+				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
+
+#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+
+#elif _CODE_PAGE == 1253 /* Greek (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
+				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
+
+#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+
+#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+
+#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
+
+#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
+#if _USE_LFN
+#error Cannot use LFN feature without valid code page.
+#endif
+#define _DF1S	0
+
+#else
+#error Unknown code page
+
+#endif
+
+
+/* Character code support macros */
+#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
+#define IsLower(c)	(((c)>='a')&&((c)<='z'))
+#define IsDigit(c)	(((c)>='0')&&((c)<='9'))
+
+#if _DF1S		/* Code page is DBCS */
+
+#ifdef _DF2S	/* Two 1st byte areas */
+#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
+#else			/* One 1st byte area */
+#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
+#endif
+
+#ifdef _DS3S	/* Three 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
+#else			/* Two 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
+#endif
+
+#else			/* Code page is SBCS */
+
+#define IsDBCS1(c)	0
+#define IsDBCS2(c)	0
+
+#endif /* _DF1S */
+
+
+/* Name status flags */
+#define NS			11		/* Index of name status byte in fn[] */
+#define NS_LOSS		0x01	/* Out of 8.3 format */
+#define NS_LFN		0x02	/* Force to create LFN entry */
+#define NS_LAST		0x04	/* Last segment */
+#define NS_BODY		0x08	/* Lower case flag (body) */
+#define NS_EXT		0x10	/* Lower case flag (ext) */
+#define NS_DOT		0x20	/* Dot entry */
+
+
+/* FAT sub-type boundaries */
+/* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
+#define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
+#define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
+
+
+/* FatFs refers the members in the FAT structures as byte array instead of
+/ structure member because the structure is not binary compatible between
+/ different platforms */
+
+#define BS_jmpBoot			0	/* Jump instruction (3) */
+#define BS_OEMName			3	/* OEM name (8) */
+#define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
+#define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
+#define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
+#define BPB_NumFATs			16	/* Number of FAT copies (1) */
+#define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
+#define BPB_TotSec16		19	/* Volume size [sector] (2) */
+#define BPB_Media			21	/* Media descriptor (1) */
+#define BPB_FATSz16			22	/* FAT size [sector] (2) */
+#define BPB_SecPerTrk		24	/* Track size [sector] (2) */
+#define BPB_NumHeads		26	/* Number of heads (2) */
+#define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
+#define BPB_TotSec32		32	/* Volume size [sector] (4) */
+#define BS_DrvNum			36	/* Physical drive number (2) */
+#define BS_BootSig			38	/* Extended boot signature (1) */
+#define BS_VolID			39	/* Volume serial number (4) */
+#define BS_VolLab			43	/* Volume label (8) */
+#define BS_FilSysType		54	/* File system type (1) */
+#define BPB_FATSz32			36	/* FAT size [sector] (4) */
+#define BPB_ExtFlags		40	/* Extended flags (2) */
+#define BPB_FSVer			42	/* File system version (2) */
+#define BPB_RootClus		44	/* Root dir first cluster (4) */
+#define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
+#define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
+#define BS_DrvNum32			64	/* Physical drive number (2) */
+#define BS_BootSig32		66	/* Extended boot signature (1) */
+#define BS_VolID32			67	/* Volume serial number (4) */
+#define BS_VolLab32			71	/* Volume label (8) */
+#define BS_FilSysType32		82	/* File system type (1) */
+#define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
+#define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
+#define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
+#define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
+#define MBR_Table			446	/* MBR: Partition table offset (2) */
+#define	SZ_PTE				16	/* MBR: Size of a partition table entry */
+#define BS_55AA				510	/* Boot sector signature (2) */
+
+#define	DIR_Name			0	/* Short file name (11) */
+#define	DIR_Attr			11	/* Attribute (1) */
+#define	DIR_NTres			12	/* NT flag (1) */
+#define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
+#define	DIR_CrtTime			14	/* Created time (2) */
+#define	DIR_CrtDate			16	/* Created date (2) */
+#define DIR_LstAccDate		18	/* Last accessed date (2) */
+#define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
+#define	DIR_WrtTime			22	/* Modified time (2) */
+#define	DIR_WrtDate			24	/* Modified date (2) */
+#define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
+#define	DIR_FileSize		28	/* File size (4) */
+#define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
+#define	LDIR_Attr			11	/* LFN attribute (1) */
+#define	LDIR_T			12	/* LFN type (1) */
+#define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
+#define	LDIR_FstClusLO		26	/* Filled by zero (0) */
+#define	SZ_DIR				32		/* Size of a directory entry */
+#define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
+#define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
+#define	NDDE				0x05	/* Replacement of the character collides with DDE */
+
+
+/*------------------------------------------------------------*/
+/* Module private work area                                   */
+/*------------------------------------------------------------*/
+/* Note that uninitialized variables with static duration are
+/  zeroed/nulled at start-up. If not, the compiler or start-up
+/  routine is out of ANSI-C standard.
+*/
+
+#if _VOLUMES
+static
+FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
+#else
+#error Number of volumes must not be 0.
+#endif
+
+static
+WORD Fsid;				/* File system mount ID */
+
+#if _FS_RPATH
+static
+BYTE CurrVol;			/* Current drive */
+#endif
+
+#if _FS_LOCK
+static
+FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
+#endif
+
+#if _USE_LFN == 0			/* No LFN feature */
+#define	DEF_NAMEBUF			BYTE sfn[12]
+#define INIT_BUF(dobj)		(dobj).fn = sfn
+#define	FREE_BUF()
+
+#elif _USE_LFN == 1			/* LFN feature with static working buffer */
+static WCHAR LfnBuf[_MAX_LFN+1];
+#define	DEF_NAMEBUF			BYTE sfn[12]
+#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
+#define	FREE_BUF()
+
+#elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
+#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
+#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
+#define	FREE_BUF()
+
+#elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
+#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
+#define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
+							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
+							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
+#define	FREE_BUF()			ff_memfree(lfn)
+
+#else
+#error Wrong LFN configuration.
+#endif
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Functions
+
+---------------------------------------------------------------------------*/
+
+
+/*-----------------------------------------------------------------------*/
+/* String functions                                                      */
+/*-----------------------------------------------------------------------*/
+
+/* Copy memory to memory */
+static
+void mem_cpy (void* dst, const void* src, UINT cnt) {
+	BYTE *d = (BYTE*)dst;
+	const BYTE *s = (const BYTE*)src;
+
+#if _WORD_ACCESS == 1
+	while (cnt >= sizeof (int)) {
+		*(int*)d = *(int*)s;
+		d += sizeof (int); s += sizeof (int);
+		cnt -= sizeof (int);
+	}
+#endif
+	while (cnt--)
+		*d++ = *s++;
+}
+
+/* Fill memory */
+static
+void mem_set (void* dst, int val, UINT cnt) {
+	BYTE *d = (BYTE*)dst;
+
+	while (cnt--)
+		*d++ = (BYTE)val;
+}
+
+/* Compare memory to memory */
+static
+int mem_cmp (const void* dst, const void* src, UINT cnt) {
+	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
+	int r = 0;
+
+	while (cnt-- && (r = *d++ - *s++) == 0) ;
+	return r;
+}
+
+/* Check if chr is contained in the string */
+static
+int chk_chr (const char* str, int chr) {
+	while (*str && *str != chr) str++;
+	return *str;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Request/Release grant to access the volume                            */
+/*-----------------------------------------------------------------------*/
+#if _FS_REENTRANT
+
+static
+int lock_fs (
+	FATFS *fs		/* File system object */
+)
+{
+	return ff_req_grant(fs->sobj);
+}
+
+
+static
+void unlock_fs (
+	FATFS *fs,		/* File system object */
+	FRESULT res		/* Result code to be returned */
+)
+{
+	if (fs &&
+		res != FR_NOT_ENABLED &&
+		res != FR_INVALID_DRIVE &&
+		res != FR_INVALID_OBJECT &&
+		res != FR_TIMEOUT) {
+		ff_rel_grant(fs->sobj);
+	}
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* File lock control functions                                           */
+/*-----------------------------------------------------------------------*/
+#if _FS_LOCK
+
+static
+FRESULT chk_lock (	/* Check if the file can be accessed */
+	DIR* dj,		/* Directory object pointing the file to be checked */
+	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
+)
+{
+	UINT i, be;
+
+	/* Search file semaphore table */
+	for (i = be = 0; i < _FS_LOCK; i++) {
+		if (Files[i].fs) {	/* Existing entry */
+			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
+				Files[i].clu == dj->sclust &&
+				Files[i].idx == dj->index) break;
+		} else {			/* Blank entry */
+			be++;
+		}
+	}
+	if (i == _FS_LOCK)	/* The file is not opened */
+		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
+
+	/* The file has been opened. Reject any open against writing file and all write mode open */
+	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
+}
+
+
+static
+int enq_lock (void)	/* Check if an entry is available for a new file */
+{
+	UINT i;
+
+	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
+	return (i == _FS_LOCK) ? 0 : 1;
+}
+
+
+static
+UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
+	DIR* dj,	/* Directory object pointing the file to register or increment */
+	int acc		/* Desired access mode (0:Read, !0:Write) */
+)
+{
+	UINT i;
+
+
+	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
+		if (Files[i].fs == dj->fs &&
+			Files[i].clu == dj->sclust &&
+			Files[i].idx == dj->index) break;
+	}
+
+	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
+		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
+		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
+		Files[i].fs = dj->fs;
+		Files[i].clu = dj->sclust;
+		Files[i].idx = dj->index;
+		Files[i].ctr = 0;
+	}
+
+	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
+
+	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
+
+	return i + 1;
+}
+
+
+static
+FRESULT dec_lock (	/* Decrement file open counter */
+	UINT i			/* Semaphore index */
+)
+{
+	WORD n;
+	FRESULT res;
+
+
+	if (--i < _FS_LOCK) {
+		n = Files[i].ctr;
+		if (n == 0x100) n = 0;
+		if (n) n--;
+		Files[i].ctr = n;
+		if (!n) Files[i].fs = 0;
+		res = FR_OK;
+	} else {
+		res = FR_INT_ERR;
+	}
+	return res;
+}
+
+
+static
+void clear_lock (	/* Clear lock entries of the volume */
+	FATFS *fs
+)
+{
+	UINT i;
+
+	for (i = 0; i < _FS_LOCK; i++) {
+		if (Files[i].fs == fs) Files[i].fs = 0;
+	}
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change window offset                                                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT move_window (
+	FATFS *fs,		/* File system object */
+	DWORD sector	/* Sector number to make appearance in the fs->win[] */
+)					/* Move to zero only writes back dirty window */
+{
+	DWORD wsect;
+
+
+	wsect = fs->winsect;
+	if (wsect != sector) {	/* Changed current window */
+#if !_FS_READONLY
+		if (fs->wflag) {	/* Write back dirty window if needed */
+			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
+				return FR_DISK_ERR;
+			fs->wflag = 0;
+			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
+				BYTE nf;
+				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
+					wsect += fs->fsize;
+					disk_write(fs->drv, fs->win, wsect, 1);
+				}
+			}
+		}
+#endif
+		if (sector) {
+			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
+				return FR_DISK_ERR;
+			fs->winsect = sector;
+		}
+	}
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Clean-up cached data                                                  */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
+	FATFS *fs	/* File system object */
+)
+{
+	FRESULT res;
+
+
+	res = move_window(fs, 0);
+	if (res == FR_OK) {
+		/* Update FSInfo sector if needed */
+		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
+			fs->winsect = 0;
+			/* Create FSInfo structure */
+			mem_set(fs->win, 0, 512);
+			ST_WORD(fs->win+BS_55AA, 0xAA55);
+			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
+			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
+			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
+			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
+			/* Write it into the FSInfo sector */
+			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
+			fs->fsi_flag = 0;
+		}
+		/* Make sure that no pending write process in the physical drive */
+		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
+			res = FR_DISK_ERR;
+	}
+
+	return res;
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get sector# from cluster#                                             */
+/*-----------------------------------------------------------------------*/
+
+
+DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
+	FATFS *fs,		/* File system object */
+	DWORD clst		/* Cluster# to be converted */
+)
+{
+	clst -= 2;
+	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
+	return clst * fs->csize + fs->database;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT access - Read value of a FAT entry                                */
+/*-----------------------------------------------------------------------*/
+
+
+DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
+	FATFS *fs,	/* File system object */
+	DWORD clst	/* Cluster# to get the link information */
+)
+{
+	UINT wc, bc;
+	BYTE *p;
+
+
+	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
+		return 1;
+
+	switch (fs->fs_type) {
+	case FS_FAT12 :
+		bc = (UINT)clst; bc += bc / 2;
+		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
+		wc = fs->win[bc % SS(fs)]; bc++;
+		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
+		wc |= fs->win[bc % SS(fs)] << 8;
+		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
+
+	case FS_FAT16 :
+		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
+		p = &fs->win[clst * 2 % SS(fs)];
+		return LD_WORD(p);
+
+	case FS_FAT32 :
+		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
+		p = &fs->win[clst * 4 % SS(fs)];
+		return LD_DWORD(p) & 0x0FFFFFFF;
+	}
+
+	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT access - Change value of a FAT entry                              */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+
+FRESULT put_fat (
+	FATFS *fs,	/* File system object */
+	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
+	DWORD val	/* New value to mark the cluster */
+)
+{
+	UINT bc;
+	BYTE *p;
+	FRESULT res;
+
+
+	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
+		res = FR_INT_ERR;
+
+	} else {
+		switch (fs->fs_type) {
+		case FS_FAT12 :
+			bc = (UINT)clst; bc += bc / 2;
+			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = &fs->win[bc % SS(fs)];
+			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
+			bc++;
+			fs->wflag = 1;
+			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = &fs->win[bc % SS(fs)];
+			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
+			break;
+
+		case FS_FAT16 :
+			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
+			if (res != FR_OK) break;
+			p = &fs->win[clst * 2 % SS(fs)];
+			ST_WORD(p, (WORD)val);
+			break;
+
+		case FS_FAT32 :
+			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
+			if (res != FR_OK) break;
+			p = &fs->win[clst * 4 % SS(fs)];
+			val |= LD_DWORD(p) & 0xF0000000;
+			ST_DWORD(p, val);
+			break;
+
+		default :
+			res = FR_INT_ERR;
+		}
+		fs->wflag = 1;
+	}
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Remove a cluster chain                                 */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT remove_chain (
+	FATFS *fs,			/* File system object */
+	DWORD clst			/* Cluster# to remove a chain from */
+)
+{
+	FRESULT res;
+	DWORD nxt;
+#if _USE_ERASE
+	DWORD scl = clst, ecl = clst, rt[2];
+#endif
+
+	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
+		res = FR_INT_ERR;
+
+	} else {
+		res = FR_OK;
+		while (clst < fs->n_fatent) {			/* Not a last link? */
+			nxt = get_fat(fs, clst);			/* Get cluster status */
+			if (nxt == 0) break;				/* Empty cluster? */
+			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
+			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
+			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
+			if (res != FR_OK) break;
+			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
+				fs->free_clust++;
+				fs->fsi_flag = 1;
+			}
+#if _USE_ERASE
+			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
+				ecl = nxt;
+			} else {				/* End of contiguous clusters */ 
+				rt[0] = clust2sect(fs, scl);					/* Start sector */
+				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
+				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
+				scl = ecl = nxt;
+			}
+#endif
+			clst = nxt;	/* Next cluster */
+		}
+	}
+
+	return res;
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Stretch or Create a cluster chain                      */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
+	FATFS *fs,			/* File system object */
+	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
+)
+{
+	DWORD cs, ncl, scl;
+	FRESULT res;
+
+
+	if (clst == 0) {		/* Create a new chain */
+		scl = fs->last_clust;			/* Get suggested start point */
+		if (!scl || scl >= fs->n_fatent) scl = 1;
+	}
+	else {					/* Stretch the current chain */
+		cs = get_fat(fs, clst);			/* Check the cluster status */
+		if (cs < 2) return 1;			/* It is an invalid cluster */
+		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
+		scl = clst;
+	}
+
+	ncl = scl;				/* Start cluster */
+	for (;;) {
+		ncl++;							/* Next cluster */
+		if (ncl >= fs->n_fatent) {		/* Wrap around */
+			ncl = 2;
+			if (ncl > scl) return 0;	/* No free cluster */
+		}
+		cs = get_fat(fs, ncl);			/* Get the cluster status */
+		if (cs == 0) break;				/* Found a free cluster */
+		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
+			return cs;
+		if (ncl == scl) return 0;		/* No free cluster */
+	}
+
+	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
+	if (res == FR_OK && clst != 0) {
+		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
+	}
+	if (res == FR_OK) {
+		fs->last_clust = ncl;			/* Update FSINFO */
+		if (fs->free_clust != 0xFFFFFFFF) {
+			fs->free_clust--;
+			fs->fsi_flag = 1;
+		}
+	} else {
+		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
+	}
+
+	return ncl;		/* Return new cluster number or error code */
+}
+#endif /* !_FS_READONLY */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Convert offset into cluster with link map table        */
+/*-----------------------------------------------------------------------*/
+
+#if _USE_FASTSEEK
+static
+DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
+	FIL* fp,		/* Pointer to the file object */
+	DWORD ofs		/* File offset to be converted to cluster# */
+)
+{
+	DWORD cl, ncl, *tbl;
+
+
+	tbl = fp->cltbl + 1;	/* Top of CLMT */
+	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
+	for (;;) {
+		ncl = *tbl++;			/* Number of cluters in the fragment */
+		if (!ncl) return 0;		/* End of table? (error) */
+		if (cl < ncl) break;	/* In this fragment? */
+		cl -= ncl; tbl++;		/* Next fragment */
+	}
+	return cl + *tbl;	/* Return the cluster number */
+}
+#endif	/* _USE_FASTSEEK */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Set directory index                              */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_sdi (
+	DIR *dj,		/* Pointer to directory object */
+	WORD idx		/* Index of directory table */
+)
+{
+	DWORD clst;
+	WORD ic;
+
+
+	dj->index = idx;
+	clst = dj->sclust;
+	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
+		return FR_INT_ERR;
+	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
+		clst = dj->fs->dirbase;
+
+	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
+		dj->clust = clst;
+		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
+			return FR_INT_ERR;
+		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
+	}
+	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
+		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
+		while (idx >= ic) {	/* Follow cluster chain */
+			clst = get_fat(dj->fs, clst);				/* Get next cluster */
+			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
+			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
+				return FR_INT_ERR;
+			idx -= ic;
+		}
+		dj->clust = clst;
+		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
+	}
+
+	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
+
+	return FR_OK;	/* Seek succeeded */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Move directory table index next                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
+	DIR *dj,		/* Pointer to directory object */
+	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
+)
+{
+	DWORD clst;
+	WORD i;
+
+
+	stretch = stretch;		/* To suppress warning on read-only cfg. */
+	i = dj->index + 1;
+	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
+		return FR_NO_FILE;
+
+	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
+		dj->sect++;					/* Next sector */
+
+		if (dj->clust == 0) {	/* Static table */
+			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
+				return FR_NO_FILE;
+		}
+		else {					/* Dynamic table */
+			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
+				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
+				if (clst <= 1) return FR_INT_ERR;
+				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
+				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
+#if !_FS_READONLY
+					BYTE c;
+					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
+					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
+					if (clst == 0) return FR_DENIED;			/* No free cluster */
+					if (clst == 1) return FR_INT_ERR;
+					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
+					/* Clean-up stretched table */
+					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
+					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
+					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
+					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
+						dj->fs->wflag = 1;
+						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
+						dj->fs->winsect++;
+					}
+					dj->fs->winsect -= c;						/* Rewind window address */
+#else
+					return FR_NO_FILE;			/* Report EOT */
+#endif
+				}
+				dj->clust = clst;				/* Initialize data for new cluster */
+				dj->sect = clust2sect(dj->fs, clst);
+			}
+		}
+	}
+
+	dj->index = i;
+	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Load/Store start cluster number                  */
+/*-----------------------------------------------------------------------*/
+
+static
+DWORD ld_clust (
+	FATFS *fs,	/* Pointer to the fs object */
+	BYTE *dir	/* Pointer to the directory entry */
+)
+{
+	DWORD cl;
+
+	cl = LD_WORD(dir+DIR_FstClusLO);
+	if (fs->fs_type == FS_FAT32)
+		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
+
+	return cl;
+}
+
+
+#if !_FS_READONLY
+static
+void st_clust (
+	BYTE *dir,	/* Pointer to the directory entry */
+	DWORD cl	/* Value to be set */
+)
+{
+	ST_WORD(dir+DIR_FstClusLO, cl);
+	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
+static
+const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
+
+
+static
+int cmp_lfn (			/* 1:Matched, 0:Not matched */
+	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
+	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
+)
+{
+	UINT i, s;
+	WCHAR wc, uc;
+
+
+	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
+	s = 0; wc = 1;
+	do {
+		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
+		if (wc) {	/* Last char has not been processed */
+			wc = ff_wtoupper(uc);		/* Convert it to upper case */
+			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
+				return 0;				/* Not matched */
+		} else {
+			if (uc != 0xFFFF) return 0;	/* Check filler */
+		}
+	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
+
+	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
+		return 0;
+
+	return 1;						/* The part of LFN matched */
+}
+
+
+
+static
+int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
+	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
+	BYTE *dir			/* Pointer to the directory entry */
+)
+{
+	UINT i, s;
+	WCHAR wc, uc;
+
+
+	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
+
+	s = 0; wc = 1;
+	do {
+		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
+		if (wc) {	/* Last char has not been processed */
+			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
+			lfnbuf[i++] = wc = uc;			/* Store it */
+		} else {
+			if (uc != 0xFFFF) return 0;		/* Check filler */
+		}
+	} while (++s < 13);						/* Read all character in the entry */
+
+	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
+		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
+		lfnbuf[i] = 0;
+	}
+
+	return 1;
+}
+
+
+#if !_FS_READONLY
+static
+void fit_lfn (
+	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
+	BYTE *dir,				/* Pointer to the directory entry */
+	BYTE ord,				/* LFN order (1-20) */
+	BYTE sum				/* SFN sum */
+)
+{
+	UINT i, s;
+	WCHAR wc;
+
+
+	dir[LDIR_Chksum] = sum;			/* Set check sum */
+	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
+	dir[LDIR_T] = 0;
+	ST_WORD(dir+LDIR_FstClusLO, 0);
+
+	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
+	s = wc = 0;
+	do {
+		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
+		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
+		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
+	} while (++s < 13);
+	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
+	dir[LDIR_Ord] = ord;			/* Set the LFN order */
+}
+
+#endif
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Create numbered name                                                  */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
+void gen_numname (
+	BYTE *dst,			/* Pointer to generated SFN */
+	const BYTE *src,	/* Pointer to source SFN to be modified */
+	const WCHAR *lfn,	/* Pointer to LFN */
+	WORD seq			/* Sequence number */
+)
+{
+	BYTE ns[8], c;
+	UINT i, j;
+
+
+	mem_cpy(dst, src, 11);
+
+	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
+		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
+	}
+
+	/* itoa (hexdecimal) */
+	i = 7;
+	do {
+		c = (seq % 16) + '0';
+		if (c > '9') c += 7;
+		ns[i--] = c;
+		seq /= 16;
+	} while (seq);
+	ns[i] = '~';
+
+	/* Append the number */
+	for (j = 0; j < i && dst[j] != ' '; j++) {
+		if (IsDBCS1(dst[j])) {
+			if (j == i - 1) break;
+			j++;
+		}
+	}
+	do {
+		dst[j++] = (i < 8) ? ns[i++] : ' ';
+	} while (j < 8);
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Calculate sum of an SFN                                               */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
+static
+BYTE sum_sfn (
+	const BYTE *dir		/* Ptr to directory entry */
+)
+{
+	BYTE sum = 0;
+	UINT n = 11;
+
+	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
+	return sum;
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Find an object in the directory                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_find (
+	DIR *dj			/* Pointer to the directory object linked to the file name */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN
+	BYTE a, ord, sum;
+#endif
+
+	res = dir_sdi(dj, 0);			/* Rewind directory object */
+	if (res != FR_OK) return res;
+
+#if _USE_LFN
+	ord = sum = 0xFF;
+#endif
+	do {
+		res = move_window(dj->fs, dj->sect);
+		if (res != FR_OK) break;
+		dir = dj->dir;					/* Ptr to the directory entry of current index */
+		c = dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN	/* LFN configuration */
+		a = dir[DIR_Attr] & AM_MASK;
+		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF;
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (dj->lfn) {
+					if (c & LLE) {		/* Is it start of LFN sequence? */
+						sum = dir[LDIR_Chksum];
+						c &= ~LLE; ord = c;	/* LFN start order */
+						dj->lfn_idx = dj->index;
+					}
+					/* Check validity of the LFN entry and compare it with given name */
+					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
+				}
+			} else {					/* An SFN entry is found */
+				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
+				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
+				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
+			}
+		}
+#else		/* Non LFN configuration */
+		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
+			break;
+#endif
+		res = dir_next(dj, 0);		/* Next entry */
+	} while (res == FR_OK);
+
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read an object from the directory                                     */
+/*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE <= 1
+static
+FRESULT dir_read (
+	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN
+	BYTE a, ord = 0xFF, sum = 0xFF;
+#endif
+
+	res = FR_NO_FILE;
+	while (dj->sect) {
+		res = move_window(dj->fs, dj->sect);
+		if (res != FR_OK) break;
+		dir = dj->dir;					/* Ptr to the directory entry of current index */
+		c = dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN	/* LFN configuration */
+		a = dir[DIR_Attr] & AM_MASK;
+		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF;
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (c & LLE) {			/* Is it start of LFN sequence? */
+					sum = dir[LDIR_Chksum];
+					c &= ~LLE; ord = c;
+					dj->lfn_idx = dj->index;
+				}
+				/* Check LFN validity and capture it */
+				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
+			} else {					/* An SFN entry is found */
+				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
+					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
+				break;
+			}
+		}
+#else		/* Non LFN configuration */
+		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
+			break;
+#endif
+		res = dir_next(dj, 0);				/* Next entry */
+		if (res != FR_OK) break;
+	}
+
+	if (res != FR_OK) dj->sect = 0;
+
+	return res;
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Register an object to the directory                                   */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
+	DIR *dj				/* Target directory with object name to be created */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN	/* LFN configuration */
+	WORD n, ne, is;
+	BYTE sn[12], *fn, sum;
+	WCHAR *lfn;
+
+
+	fn = dj->fn; lfn = dj->lfn;
+	mem_cpy(sn, fn, 12);
+
+	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
+		return FR_INVALID_NAME;
+
+	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
+		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
+		for (n = 1; n < 100; n++) {
+			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
+			res = dir_find(dj);				/* Check if the name collides with existing SFN */
+			if (res != FR_OK) break;
+		}
+		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
+		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
+		fn[NS] = sn[NS]; dj->lfn = lfn;
+	}
+
+	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
+		for (ne = 0; lfn[ne]; ne++) ;
+		ne = (ne + 25) / 13;
+	} else {						/* Otherwise reserve only an SFN entry. */
+		ne = 1;
+	}
+
+	/* Reserve contiguous entries */
+	res = dir_sdi(dj, 0);
+	if (res != FR_OK) return res;
+	n = is = 0;
+	do {
+		res = move_window(dj->fs, dj->sect);
+		if (res != FR_OK) break;
+		c = *dj->dir;				/* Check the entry status */
+		if (c == DDE || c == 0) {	/* Is it a blank entry? */
+			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
+			if (++n == ne) break;	/* A contiguous entry that required count is found */
+		} else {
+			n = 0;					/* Not a blank entry. Restart to search */
+		}
+		res = dir_next(dj, 1);		/* Next entry with table stretch */
+	} while (res == FR_OK);
+
+	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
+		res = dir_sdi(dj, is);
+		if (res == FR_OK) {
+			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
+			ne--;
+			do {					/* Store LFN entries in bottom first */
+				res = move_window(dj->fs, dj->sect);
+				if (res != FR_OK) break;
+				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
+				dj->fs->wflag = 1;
+				res = dir_next(dj, 0);	/* Next entry */
+			} while (res == FR_OK && --ne);
+		}
+	}
+
+#else	/* Non LFN configuration */
+	res = dir_sdi(dj, 0);
+	if (res == FR_OK) {
+		do {	/* Find a blank entry for the SFN */
+			res = move_window(dj->fs, dj->sect);
+			if (res != FR_OK) break;
+			c = *dj->dir;
+			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
+			res = dir_next(dj, 1);			/* Next entry with table stretch */
+		} while (res == FR_OK);
+	}
+#endif
+
+	if (res == FR_OK) {		/* Initialize the SFN entry */
+		res = move_window(dj->fs, dj->sect);
+		if (res == FR_OK) {
+			dir = dj->dir;
+			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
+			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
+#if _USE_LFN
+			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
+#endif
+			dj->fs->wflag = 1;
+		}
+	}
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Remove an object from the directory                                   */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY && !_FS_MINIMIZE
+static
+FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
+	DIR *dj				/* Directory object pointing the entry to be removed */
+)
+{
+	FRESULT res;
+#if _USE_LFN	/* LFN configuration */
+	WORD i;
+
+	i = dj->index;	/* SFN index */
+	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
+	if (res == FR_OK) {
+		do {
+			res = move_window(dj->fs, dj->sect);
+			if (res != FR_OK) break;
+			*dj->dir = DDE;			/* Mark the entry "deleted" */
+			dj->fs->wflag = 1;
+			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
+			res = dir_next(dj, 0);		/* Next entry */
+		} while (res == FR_OK);
+		if (res == FR_NO_FILE) res = FR_INT_ERR;
+	}
+
+#else			/* Non LFN configuration */
+	res = dir_sdi(dj, dj->index);
+	if (res == FR_OK) {
+		res = move_window(dj->fs, dj->sect);
+		if (res == FR_OK) {
+			*dj->dir = DDE;			/* Mark the entry "deleted" */
+			dj->fs->wflag = 1;
+		}
+	}
+#endif
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Pick a segment and create the object name in directory form           */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT create_name (
+	DIR *dj,			/* Pointer to the directory object */
+	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
+)
+{
+#ifdef _EXCVT
+	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
+#endif
+
+#if _USE_LFN	/* LFN configuration */
+	BYTE b, cf;
+	WCHAR w, *lfn;
+	UINT i, ni, si, di;
+	const TCHAR *p;
+
+	/* Create LFN in Unicode */
+	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
+	lfn = dj->lfn;
+	si = di = 0;
+	for (;;) {
+		w = p[si++];					/* Get a character */
+		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
+		if (di >= _MAX_LFN)				/* Reject too long name */
+			return FR_INVALID_NAME;
+#if !_LFN_UNICODE
+		w &= 0xFF;
+		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
+			b = (BYTE)p[si++];			/* Get 2nd byte */
+			if (!IsDBCS2(b))
+				return FR_INVALID_NAME;	/* Reject invalid sequence */
+			w = (w << 8) + b;			/* Create a DBC */
+		}
+		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
+		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
+#endif
+		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
+			return FR_INVALID_NAME;
+		lfn[di++] = w;					/* Store the Unicode char */
+	}
+	*path = &p[si];						/* Return pointer to the next segment */
+	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
+#if _FS_RPATH
+	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
+		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
+		lfn[di] = 0;
+		for (i = 0; i < 11; i++)
+			dj->fn[i] = (i < di) ? '.' : ' ';
+		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
+		return FR_OK;
+	}
+#endif
+	while (di) {						/* Strip trailing spaces and dots */
+		w = lfn[di-1];
+		if (w != ' ' && w != '.') break;
+		di--;
+	}
+	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
+
+	lfn[di] = 0;						/* LFN is created */
+
+	/* Create SFN in directory form */
+	mem_set(dj->fn, ' ', 11);
+	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
+	if (si) cf |= NS_LOSS | NS_LFN;
+	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
+
+	b = i = 0; ni = 8;
+	for (;;) {
+		w = lfn[si++];					/* Get an LFN char */
+		if (!w) break;					/* Break on end of the LFN */
+		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
+			cf |= NS_LOSS | NS_LFN; continue;
+		}
+
+		if (i >= ni || si == di) {		/* Extension or end of SFN */
+			if (ni == 11) {				/* Long extension */
+				cf |= NS_LOSS | NS_LFN; break;
+			}
+			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
+			if (si > di) break;			/* No extension */
+			si = di; i = 8; ni = 11;	/* Enter extension section */
+			b <<= 2; continue;
+		}
+
+		if (w >= 0x80) {				/* Non ASCII char */
+#ifdef _EXCVT
+			w = ff_convert(w, 0);		/* Unicode -> OEM code */
+			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
+#else
+			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
+#endif
+			cf |= NS_LFN;				/* Force create LFN entry */
+		}
+
+		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
+			if (i >= ni - 1) {
+				cf |= NS_LOSS | NS_LFN; i = ni; continue;
+			}
+			dj->fn[i++] = (BYTE)(w >> 8);
+		} else {						/* Single byte char */
+			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
+				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
+			} else {
+				if (IsUpper(w)) {		/* ASCII large capital */
+					b |= 2;
+				} else {
+					if (IsLower(w)) {	/* ASCII small capital */
+						b |= 1; w -= 0x20;
+					}
+				}
+			}
+		}
+		dj->fn[i++] = (BYTE)w;
+	}
+
+	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
+
+	if (ni == 8) b <<= 2;
+	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
+		cf |= NS_LFN;
+	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
+		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
+		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
+	}
+
+	dj->fn[NS] = cf;	/* SFN is created */
+
+	return FR_OK;
+
+
+#else	/* Non-LFN configuration */
+	BYTE b, c, d, *sfn;
+	UINT ni, si, i;
+	const char *p;
+
+	/* Create file name in directory form */
+	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
+	sfn = dj->fn;
+	mem_set(sfn, ' ', 11);
+	si = i = b = 0; ni = 8;
+#if _FS_RPATH
+	if (p[si] == '.') { /* Is this a dot entry? */
+		for (;;) {
+			c = (BYTE)p[si++];
+			if (c != '.' || si >= 3) break;
+			sfn[i++] = c;
+		}
+		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
+		*path = &p[si];									/* Return pointer to the next segment */
+		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
+		return FR_OK;
+	}
+#endif
+	for (;;) {
+		c = (BYTE)p[si++];
+		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
+		if (c == '.' || i >= ni) {
+			if (ni != 8 || c != '.') return FR_INVALID_NAME;
+			i = 8; ni = 11;
+			b <<= 2; continue;
+		}
+		if (c >= 0x80) {				/* Extended char? */
+			b |= 3;						/* Eliminate NT flag */
+#ifdef _EXCVT
+			c = excvt[c - 0x80];		/* Upper conversion (SBCS) */
+#else
+#if !_DF1S	/* ASCII only cfg */
+			return FR_INVALID_NAME;
+#endif
+#endif
+		}
+		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
+			d = (BYTE)p[si++];			/* Get 2nd byte */
+			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
+				return FR_INVALID_NAME;
+			sfn[i++] = c;
+			sfn[i++] = d;
+		} else {						/* Single byte code */
+			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
+				return FR_INVALID_NAME;
+			if (IsUpper(c)) {			/* ASCII large capital? */
+				b |= 2;
+			} else {
+				if (IsLower(c)) {		/* ASCII small capital? */
+					b |= 1; c -= 0x20;
+				}
+			}
+			sfn[i++] = c;
+		}
+	}
+	*path = &p[si];						/* Return pointer to the next segment */
+	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
+
+	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
+	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
+
+	if (ni == 8) b <<= 2;
+	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
+	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
+
+	sfn[NS] = c;		/* Store NT flag, File name is created */
+
+	return FR_OK;
+#endif
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get file information from directory entry                             */
+/*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE <= 1
+static
+void get_fileinfo (		/* No return code */
+	DIR *dj,			/* Pointer to the directory object */
+	FILINFO *fno	 	/* Pointer to the file information to be filled */
+)
+{
+	UINT i;
+	BYTE nt, *dir;
+	TCHAR *p, c;
+
+
+	p = fno->fname;
+	if (dj->sect) {
+		dir = dj->dir;
+		nt = dir[DIR_NTres];		/* NT flag */
+		for (i = 0; i < 8; i++) {	/* Copy name body */
+			c = dir[i];
+			if (c == ' ') break;
+			if (c == NDDE) c = (TCHAR)DDE;
+			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
+#if _LFN_UNICODE
+			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
+				c = (c << 8) | dir[++i];
+			c = ff_convert(c, 1);
+			if (!c) c = '?';
+#endif
+			*p++ = c;
+		}
+		if (dir[8] != ' ') {		/* Copy name extension */
+			*p++ = '.';
+			for (i = 8; i < 11; i++) {
+				c = dir[i];
+				if (c == ' ') break;
+				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
+#if _LFN_UNICODE
+				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
+					c = (c << 8) | dir[++i];
+				c = ff_convert(c, 1);
+				if (!c) c = '?';
+#endif
+				*p++ = c;
+			}
+		}
+		fno->fattrib = dir[DIR_Attr];				/* Attribute */
+		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
+		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
+		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
+	}
+	*p = 0;		/* Terminate SFN str by a \0 */
+
+#if _USE_LFN
+	if (fno->lfname && fno->lfsize) {
+		TCHAR *tp = fno->lfname;
+		WCHAR w, *lfn;
+
+		i = 0;
+		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
+			lfn = dj->lfn;
+			while ((w = *lfn++) != 0) {			/* Get an LFN char */
+#if !_LFN_UNICODE
+				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
+				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
+				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
+					tp[i++] = (TCHAR)(w >> 8);
+#endif
+				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
+				tp[i++] = (TCHAR)w;
+			}
+		}
+		tp[i] = 0;	/* Terminate the LFN str by a \0 */
+	}
+#endif
+}
+#endif /* _FS_MINIMIZE <= 1 */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Follow a file path                                                    */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
+	DIR *dj,			/* Directory object to return last directory and found object */
+	const TCHAR *path	/* Full-path string to find a file or directory */
+)
+{
+	FRESULT res;
+	BYTE *dir, ns;
+
+
+#if _FS_RPATH
+	if (*path == '/' || *path == '\\') { /* There is a heading separator */
+		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
+	} else {							/* No heading separator */
+		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
+	}
+#else
+	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
+		path++;
+	dj->sclust = 0;						/* Start from the root dir */
+#endif
+
+	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
+		res = dir_sdi(dj, 0);
+		dj->dir = 0;
+	} else {							/* Follow path */
+		for (;;) {
+			res = create_name(dj, &path);	/* Get a segment */
+			if (res != FR_OK) break;
+			res = dir_find(dj);				/* Find it */
+			ns = *(dj->fn+NS);
+			if (res != FR_OK) {				/* Failed to find the object */
+				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
+				/* Object not found */
+				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
+					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
+					res = FR_OK;
+					if (!(ns & NS_LAST)) continue;
+				} else {							/* Could not find the object */
+					if (!(ns & NS_LAST)) res = FR_NO_PATH;
+				}
+				break;
+			}
+			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
+			dir = dj->dir;						/* There is next segment. Follow the sub directory */
+			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
+				res = FR_NO_PATH; break;
+			}
+			dj->sclust = ld_clust(dj->fs, dir);
+		}
+	}
+
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Load a sector and check if it is an FAT Volume Boot Record            */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
+	FATFS *fs,	/* File system object */
+	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
+)
+{
+	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
+		return 3;
+	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
+		return 2;
+
+	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
+		return 0;
+	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
+		return 0;
+
+	return 1;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Check if the file system object is valid or not                       */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
+	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
+	FATFS **rfs,		/* Pointer to pointer to the found file system object */
+	BYTE wmode			/* !=0: Check write protection for write access */
+)
+{
+	BYTE fmt, b, pi, *tbl;
+	UINT vol;
+	DSTATUS stat;
+	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
+	WORD nrsv;
+	const TCHAR *p = *path;
+	FATFS *fs;
+
+
+	/* Get logical drive number from the path name */
+	vol = p[0] - '0';					/* Is there a drive number? */
+	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
+		p += 2; *path = p;				/* Return pointer to the path name */
+	} else {							/* No drive number is given */
+#if _FS_RPATH
+		vol = CurrVol;					/* Use current drive */
+#else
+		vol = 0;						/* Use drive 0 */
+#endif
+	}
+
+	/* Check if the file system object is valid or not */
+	*rfs = 0;
+	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
+		return FR_INVALID_DRIVE;
+	fs = FatFs[vol];					/* Get corresponding file system object */
+	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
+
+	ENTER_FF(fs);						/* Lock file system */
+
+	*rfs = fs;							/* Return pointer to the corresponding file system object */
+	if (fs->fs_type) {					/* If the volume has been mounted */
+		stat = disk_status(fs->drv);
+		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
+			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
+				return FR_WRITE_PROTECTED;
+			return FR_OK;				/* The file system object is valid */
+		}
+	}
+
+	/* The file system object is not valid. */
+	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
+
+	fs->fs_type = 0;					/* Clear the file system object */
+	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
+	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
+	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
+		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
+	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
+		return FR_WRITE_PROTECTED;
+#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
+	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
+		return FR_DISK_ERR;
+#endif
+	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
+	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
+	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
+	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
+		/* Check the partition listed in the partition table */
+		pi = LD2PT(vol);
+		if (pi) pi--;
+		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
+		if (tbl[4]) {						/* Is the partition existing? */
+			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
+			fmt = check_fs(fs, bsect);		/* Check the partition */
+		}
+	}
+	if (fmt == 3) return FR_DISK_ERR;
+	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
+
+	/* An FAT volume is found. Following code initializes the file system object */
+
+	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
+		return FR_NO_FILESYSTEM;
+
+	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
+	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
+	fs->fsize = fasize;
+
+	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
+	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
+	fasize *= b;										/* Number of sectors for FAT area */
+
+	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
+	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
+
+	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
+	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
+
+	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
+	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
+
+	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
+	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
+
+	/* Determine the FAT sub type */
+	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
+	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
+	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
+	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
+	fmt = FS_FAT12;
+	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
+	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
+
+	/* Boundaries and Limits */
+	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
+	fs->database = bsect + sysect;						/* Data start sector */
+	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
+	if (fmt == FS_FAT32) {
+		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
+		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
+		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
+	} else {
+		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
+		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
+		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
+			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
+	}
+	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
+		return FR_NO_FILESYSTEM;
+
+#if !_FS_READONLY
+	/* Initialize cluster allocation information */
+	fs->free_clust = 0xFFFFFFFF;
+	fs->last_clust = 0;
+
+	/* Get fsinfo if available */
+	if (fmt == FS_FAT32) {
+	 	fs->fsi_flag = 0;
+		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
+		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
+			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
+			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
+			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
+				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
+				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
+		}
+	}
+#endif
+	fs->fs_type = fmt;		/* FAT sub-type */
+	fs->id = ++Fsid;		/* File system mount ID */
+	fs->winsect = 0;		/* Invalidate sector cache */
+	fs->wflag = 0;
+#if _FS_RPATH
+	fs->cdir = 0;			/* Current directory (root dir) */
+#endif
+#if _FS_LOCK				/* Clear file lock semaphores */
+	clear_lock(fs);
+#endif
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Check if the file/dir object is valid or not                          */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
+	void* obj		/* Pointer to the object FIL/DIR to check validity */
+)
+{
+	FIL *fil;
+
+
+	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
+	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
+		return FR_INVALID_OBJECT;
+
+	ENTER_FF(fil->fs);		/* Lock file system */
+
+	if (disk_status(fil->fs->drv) & STA_NOINIT)
+		return FR_NOT_READY;
+
+	return FR_OK;
+}
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Public Functions
+
+--------------------------------------------------------------------------*/
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Mount/Unmount a Logical Drive                                         */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mount (
+	BYTE vol,		/* Logical drive number to be mounted/unmounted */
+	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
+)
+{
+	FATFS *rfs;
+
+
+	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
+		return FR_INVALID_DRIVE;
+	rfs = FatFs[vol];			/* Get current fs object */
+
+	if (rfs) {
+#if _FS_LOCK
+		clear_lock(rfs);
+#endif
+#if _FS_REENTRANT				/* Discard sync object of the current volume */
+		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
+#endif
+		rfs->fs_type = 0;		/* Clear old fs object */
+	}
+
+	if (fs) {
+		fs->fs_type = 0;		/* Clear new fs object */
+#if _FS_REENTRANT				/* Create sync object for the new volume */
+		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
+#endif
+	}
+	FatFs[vol] = fs;			/* Register new fs object */
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Open or Create a File                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_open (
+	FIL *fp,			/* Pointer to the blank file object */
+	const TCHAR *path,	/* Pointer to the file name */
+	BYTE mode			/* Access mode and file open mode flags */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir;
+	DEF_NAMEBUF;
+
+
+	if (!fp) return FR_INVALID_OBJECT;
+	fp->fs = 0;			/* Clear file object */
+
+#if !_FS_READONLY
+	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
+	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
+#else
+	mode &= FA_READ;
+	res = chk_mounted(&path, &dj.fs, 0);
+#endif
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		dir = dj.dir;
+#if !_FS_READONLY	/* R/W configuration */
+		if (res == FR_OK) {
+			if (!dir)	/* Current dir itself */
+				res = FR_INVALID_NAME;
+#if _FS_LOCK
+			else
+				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+#endif
+		}
+		/* Create or Open a file */
+		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
+			DWORD dw, cl;
+
+			if (res != FR_OK) {					/* No file, create new */
+				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
+#if _FS_LOCK
+					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
+#else
+					res = dir_register(&dj);
+#endif
+				mode |= FA_CREATE_ALWAYS;		/* File is created */
+				dir = dj.dir;					/* New entry */
+			}
+			else {								/* Any object is already existing */
+				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
+					res = FR_DENIED;
+				} else {
+					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
+						res = FR_EXIST;
+				}
+			}
+			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
+				dw = get_fattime();					/* Created time */
+				ST_DWORD(dir+DIR_CrtTime, dw);
+				dir[DIR_Attr] = 0;					/* Reset attribute */
+				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
+				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
+				st_clust(dir, 0);					/* cluster = 0 */
+				dj.fs->wflag = 1;
+				if (cl) {							/* Remove the cluster chain if exist */
+					dw = dj.fs->winsect;
+					res = remove_chain(dj.fs, cl);
+					if (res == FR_OK) {
+						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
+						res = move_window(dj.fs, dw);
+					}
+				}
+			}
+		}
+		else {	/* Open an existing file */
+			if (res == FR_OK) {						/* Follow succeeded */
+				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
+					res = FR_NO_FILE;
+				} else {
+					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
+						res = FR_DENIED;
+				}
+			}
+		}
+		if (res == FR_OK) {
+			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
+				mode |= FA__WRITTEN;
+			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
+			fp->dir_ptr = dir;
+#if _FS_LOCK
+			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+			if (!fp->lockid) res = FR_INT_ERR;
+#endif
+		}
+
+#else				/* R/O configuration */
+		if (res == FR_OK) {					/* Follow succeeded */
+			dir = dj.dir;
+			if (!dir) {						/* Current dir itself */
+				res = FR_INVALID_NAME;
+			} else {
+				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
+					res = FR_NO_FILE;
+			}
+		}
+#endif
+		FREE_BUF();
+
+		if (res == FR_OK) {
+			fp->flag = mode;					/* File access mode */
+			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
+			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
+			fp->fptr = 0;						/* File pointer */
+			fp->dsect = 0;
+#if _USE_FASTSEEK
+			fp->cltbl = 0;						/* Normal seek mode */
+#endif
+			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read File                                                             */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_read (
+	FIL *fp, 		/* Pointer to the file object */
+	void *buff,		/* Pointer to data buffer */
+	UINT btr,		/* Number of bytes to read */
+	UINT *br		/* Pointer to number of bytes read */
+)
+{
+	FRESULT res;
+	DWORD clst, sect, remain;
+	UINT rcnt, cc;
+	BYTE csect, *rbuff = buff;
+
+
+	*br = 0;	/* Clear read byte counter */
+
+	res = validate(fp);							/* Check validity */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)					/* Aborted file? */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+	if (!(fp->flag & FA_READ)) 					/* Check access mode */
+		LEAVE_FF(fp->fs, FR_DENIED);
+	remain = fp->fsize - fp->fptr;
+	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
+
+	for ( ;  btr;								/* Repeat until all data read */
+		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
+		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
+			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
+			if (!csect) {						/* On the cluster boundary? */
+				if (fp->fptr == 0) {			/* On the top of the file? */
+					clst = fp->sclust;			/* Follow from the origin */
+				} else {						/* Middle or end of the file */
+#if _USE_FASTSEEK
+					if (fp->cltbl)
+						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
+					else
+#endif
+						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
+				}
+				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				fp->clust = clst;				/* Update current cluster */
+			}
+			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fp->fs, FR_INT_ERR);
+			sect += csect;
+			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
+			if (cc) {							/* Read maximum contiguous sectors directly */
+				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
+					cc = fp->fs->csize - csect;
+				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
+#if _FS_TINY
+				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
+					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
+#else
+				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
+					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
+#endif
+#endif
+				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
+				continue;
+			}
+#if !_FS_TINY
+			if (fp->dsect != sect) {			/* Load data sector if not in cache */
+#if !_FS_READONLY
+				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
+					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+						ABORT(fp->fs, FR_DISK_ERR);
+					fp->flag &= ~FA__DIRTY;
+				}
+#endif
+				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
+					ABORT(fp->fs, FR_DISK_ERR);
+			}
+#endif
+			fp->dsect = sect;
+		}
+		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
+		if (rcnt > btr) rcnt = btr;
+#if _FS_TINY
+		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
+			ABORT(fp->fs, FR_DISK_ERR);
+		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
+#else
+		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
+#endif
+	}
+
+	LEAVE_FF(fp->fs, FR_OK);
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Write File                                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_write (
+	FIL *fp,			/* Pointer to the file object */
+	const void *buff,	/* Pointer to the data to be written */
+	UINT btw,			/* Number of bytes to write */
+	UINT *bw			/* Pointer to number of bytes written */
+)
+{
+	FRESULT res;
+	DWORD clst, sect;
+	UINT wcnt, cc;
+	const BYTE *wbuff = buff;
+	BYTE csect;
+
+
+	*bw = 0;	/* Clear write byte counter */
+
+	res = validate(fp);						/* Check validity */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)				/* Aborted file? */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+	if (!(fp->flag & FA_WRITE))				/* Check access mode */
+		LEAVE_FF(fp->fs, FR_DENIED);
+	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
+
+	for ( ;  btw;							/* Repeat until all data written */
+		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
+		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
+			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
+			if (!csect) {					/* On the cluster boundary? */
+				if (fp->fptr == 0) {		/* On the top of the file? */
+					clst = fp->sclust;		/* Follow from the origin */
+					if (clst == 0)			/* When no cluster is allocated, */
+						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
+				} else {					/* Middle or end of the file */
+#if _USE_FASTSEEK
+					if (fp->cltbl)
+						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
+					else
+#endif
+						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
+				}
+				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
+				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				fp->clust = clst;			/* Update current cluster */
+			}
+#if _FS_TINY
+			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
+				ABORT(fp->fs, FR_DISK_ERR);
+#else
+			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
+				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+				fp->flag &= ~FA__DIRTY;
+			}
+#endif
+			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fp->fs, FR_INT_ERR);
+			sect += csect;
+			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
+			if (cc) {						/* Write maximum contiguous sectors directly */
+				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
+					cc = fp->fs->csize - csect;
+				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+#if _FS_TINY
+				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
+					fp->fs->wflag = 0;
+				}
+#else
+				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
+					fp->flag &= ~FA__DIRTY;
+				}
+#endif
+				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
+				continue;
+			}
+#if _FS_TINY
+			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
+				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
+				fp->fs->winsect = sect;
+			}
+#else
+			if (fp->dsect != sect) {		/* Fill sector cache with file data */
+				if (fp->fptr < fp->fsize &&
+					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
+						ABORT(fp->fs, FR_DISK_ERR);
+			}
+#endif
+			fp->dsect = sect;
+		}
+		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
+		if (wcnt > btw) wcnt = btw;
+#if _FS_TINY
+		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
+			ABORT(fp->fs, FR_DISK_ERR);
+		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp->fs->wflag = 1;
+#else
+		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp->flag |= FA__DIRTY;
+#endif
+	}
+
+	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
+	fp->flag |= FA__WRITTEN;						/* Set file change flag */
+
+	LEAVE_FF(fp->fs, FR_OK);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Synchronize the File Object                                           */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_sync (
+	FIL *fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	DWORD tim;
+	BYTE *dir;
+
+
+	res = validate(fp);					/* Check validity of the object */
+	if (res == FR_OK) {
+		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
+#if !_FS_TINY	/* Write-back dirty buffer */
+			if (fp->flag & FA__DIRTY) {
+				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+					LEAVE_FF(fp->fs, FR_DISK_ERR);
+				fp->flag &= ~FA__DIRTY;
+			}
+#endif
+			/* Update the directory entry */
+			res = move_window(fp->fs, fp->dir_sect);
+			if (res == FR_OK) {
+				dir = fp->dir_ptr;
+				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
+				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
+				st_clust(dir, fp->sclust);					/* Update start cluster */
+				tim = get_fattime();						/* Update updated time */
+				ST_DWORD(dir+DIR_WrtTime, tim);
+				ST_WORD(dir+DIR_LstAccDate, 0);
+				fp->flag &= ~FA__WRITTEN;
+				fp->fs->wflag = 1;
+				res = sync(fp->fs);
+			}
+		}
+	}
+
+	LEAVE_FF(fp->fs, res);
+}
+
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Close File                                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_close (
+	FIL *fp		/* Pointer to the file object to be closed */
+)
+{
+	FRESULT res;
+
+
+#if _FS_READONLY
+	res = validate(fp);
+	{
+#if _FS_REENTRANT
+		FATFS *fs = fp->fs;
+#endif
+		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
+		LEAVE_FF(fs, res);
+	}
+#else
+	res = f_sync(fp);		/* Flush cached data */
+#if _FS_LOCK
+	if (res == FR_OK) {		/* Decrement open counter */
+#if _FS_REENTRANT
+		FATFS *fs = fp->fs;;
+		res = validate(fp);
+		if (res == FR_OK) {
+			res = dec_lock(fp->lockid);	
+			unlock_fs(fs, FR_OK);
+		}
+#else
+		res = dec_lock(fp->lockid);
+#endif
+	}
+#endif
+	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
+	return res;
+#endif
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Current Drive/Directory Handlings                                     */
+/*-----------------------------------------------------------------------*/
+
+#if _FS_RPATH >= 1
+
+FRESULT f_chdrive (
+	BYTE drv		/* Drive number */
+)
+{
+	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
+
+	CurrVol = drv;
+
+	return FR_OK;
+}
+
+
+
+FRESULT f_chdir (
+	const TCHAR *path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 0);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);		/* Follow the path */
+		FREE_BUF();
+		if (res == FR_OK) {					/* Follow completed */
+			if (!dj.dir) {
+				dj.fs->cdir = dj.sclust;	/* Start directory itself */
+			} else {
+				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
+					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
+				else
+					res = FR_NO_PATH;		/* Reached but a file */
+			}
+		}
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+#if _FS_RPATH >= 2
+FRESULT f_getcwd (
+	TCHAR *path,	/* Pointer to the directory path */
+	UINT sz_path	/* Size of path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	UINT i, n;
+	DWORD ccl;
+	TCHAR *tp;
+	FILINFO fno;
+	DEF_NAMEBUF;
+
+
+	*path = 0;
+	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		i = sz_path;		/* Bottom of buffer (dir stack base) */
+		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
+		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
+			res = dir_sdi(&dj, 1);			/* Get parent dir */
+			if (res != FR_OK) break;
+			res = dir_read(&dj);
+			if (res != FR_OK) break;
+			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
+			res = dir_sdi(&dj, 0);
+			if (res != FR_OK) break;
+			do {							/* Find the entry links to the child dir */
+				res = dir_read(&dj);
+				if (res != FR_OK) break;
+				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
+				res = dir_next(&dj, 0);	
+			} while (res == FR_OK);
+			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
+			if (res != FR_OK) break;
+#if _USE_LFN
+			fno.lfname = path;
+			fno.lfsize = i;
+#endif
+			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
+			tp = fno.fname;
+			if (_USE_LFN && *path) tp = path;
+			for (n = 0; tp[n]; n++) ;
+			if (i < n + 3) {
+				res = FR_NOT_ENOUGH_CORE; break;
+			}
+			while (n) path[--i] = tp[--n];
+			path[--i] = '/';
+		}
+		tp = path;
+		if (res == FR_OK) {
+			*tp++ = '0' + CurrVol;			/* Put drive number */
+			*tp++ = ':';
+			if (i == sz_path) {				/* Root-dir */
+				*tp++ = '/';
+			} else {						/* Sub-dir */
+				do		/* Add stacked path str */
+					*tp++ = path[i++];
+				while (i < sz_path);
+			}
+		}
+		*tp = 0;
+		FREE_BUF();
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+#endif /* _FS_RPATH >= 2 */
+#endif /* _FS_RPATH >= 1 */
+
+
+
+#if _FS_MINIMIZE <= 2
+/*-----------------------------------------------------------------------*/
+/* Seek File R/W Pointer                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_lseek (
+	FIL *fp,		/* Pointer to the file object */
+	DWORD ofs		/* File pointer from top of file */
+)
+{
+	FRESULT res;
+
+
+	res = validate(fp);					/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)			/* Check abort flag */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+
+#if _USE_FASTSEEK
+	if (fp->cltbl) {	/* Fast seek */
+		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
+
+		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
+			tbl = fp->cltbl;
+			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
+			cl = fp->sclust;			/* Top of the chain */
+			if (cl) {
+				do {
+					/* Get a fragment */
+					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
+					do {
+						pcl = cl; ncl++;
+						cl = get_fat(fp->fs, cl);
+						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
+						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					} while (cl == pcl + 1);
+					if (ulen <= tlen) {		/* Store the length and top of the fragment */
+						*tbl++ = ncl; *tbl++ = tcl;
+					}
+				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
+			}
+			*fp->cltbl = ulen;	/* Number of items used */
+			if (ulen <= tlen)
+				*tbl = 0;		/* Terminate table */
+			else
+				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
+
+		} else {						/* Fast seek */
+			if (ofs > fp->fsize)		/* Clip offset at the file size */
+				ofs = fp->fsize;
+			fp->fptr = ofs;				/* Set file pointer */
+			if (ofs) {
+				fp->clust = clmt_clust(fp, ofs - 1);
+				dsc = clust2sect(fp->fs, fp->clust);
+				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
+				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
+				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
+#if !_FS_TINY
+#if !_FS_READONLY
+					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
+						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+							ABORT(fp->fs, FR_DISK_ERR);
+						fp->flag &= ~FA__DIRTY;
+					}
+#endif
+					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
+						ABORT(fp->fs, FR_DISK_ERR);
+#endif
+					fp->dsect = dsc;
+				}
+			}
+		}
+	} else
+#endif
+
+	/* Normal Seek */
+	{
+		DWORD clst, bcs, nsect, ifptr;
+
+		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
+#if !_FS_READONLY
+			 && !(fp->flag & FA_WRITE)
+#endif
+			) ofs = fp->fsize;
+
+		ifptr = fp->fptr;
+		fp->fptr = nsect = 0;
+		if (ofs) {
+			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
+			if (ifptr > 0 &&
+				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
+				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
+				ofs -= fp->fptr;
+				clst = fp->clust;
+			} else {									/* When seek to back cluster, */
+				clst = fp->sclust;						/* start from the first cluster */
+#if !_FS_READONLY
+				if (clst == 0) {						/* If no cluster chain, create a new chain */
+					clst = create_chain(fp->fs, 0);
+					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
+					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					fp->sclust = clst;
+				}
+#endif
+				fp->clust = clst;
+			}
+			if (clst != 0) {
+				while (ofs > bcs) {						/* Cluster following loop */
+#if !_FS_READONLY
+					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
+						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
+						if (clst == 0) {				/* When disk gets full, clip file size */
+							ofs = bcs; break;
+						}
+					} else
+#endif
+						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
+					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
+					fp->clust = clst;
+					fp->fptr += bcs;
+					ofs -= bcs;
+				}
+				fp->fptr += ofs;
+				if (ofs % SS(fp->fs)) {
+					nsect = clust2sect(fp->fs, clst);	/* Current sector */
+					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
+					nsect += ofs / SS(fp->fs);
+				}
+			}
+		}
+		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
+#if !_FS_TINY
+#if !_FS_READONLY
+			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
+				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+				fp->flag &= ~FA__DIRTY;
+			}
+#endif
+			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
+				ABORT(fp->fs, FR_DISK_ERR);
+#endif
+			fp->dsect = nsect;
+		}
+#if !_FS_READONLY
+		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
+			fp->fsize = fp->fptr;
+			fp->flag |= FA__WRITTEN;
+		}
+#endif
+	}
+
+	LEAVE_FF(fp->fs, res);
+}
+
+
+
+#if _FS_MINIMIZE <= 1
+/*-----------------------------------------------------------------------*/
+/* Create a Directory Object                                             */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_opendir (
+	DIR *dj,			/* Pointer to directory object to create */
+	const TCHAR *path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DEF_NAMEBUF;
+
+
+	if (!dj) return FR_INVALID_OBJECT;
+
+	res = chk_mounted(&path, &dj->fs, 0);
+	fs = dj->fs;
+	if (res == FR_OK) {
+		INIT_BUF(*dj);
+		res = follow_path(dj, path);			/* Follow the path to the directory */
+		FREE_BUF();
+		if (res == FR_OK) {						/* Follow completed */
+			if (dj->dir) {						/* It is not the root dir */
+				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
+					dj->sclust = ld_clust(fs, dj->dir);
+				} else {						/* The object is not a directory */
+					res = FR_NO_PATH;
+				}
+			}
+			if (res == FR_OK) {
+				dj->id = fs->id;
+				res = dir_sdi(dj, 0);			/* Rewind dir */
+			}
+		}
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
+	} else {
+		dj->fs = 0;
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Directory Entry in Sequence                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_readdir (
+	DIR *dj,			/* Pointer to the open directory object */
+	FILINFO *fno		/* Pointer to file information to return */
+)
+{
+	FRESULT res;
+	DEF_NAMEBUF;
+
+
+	res = validate(dj);						/* Check validity of the object */
+	if (res == FR_OK) {
+		if (!fno) {
+			res = dir_sdi(dj, 0);			/* Rewind the directory object */
+		} else {
+			INIT_BUF(*dj);
+			res = dir_read(dj);				/* Read an directory item */
+			if (res == FR_NO_FILE) {		/* Reached end of dir */
+				dj->sect = 0;
+				res = FR_OK;
+			}
+			if (res == FR_OK) {				/* A valid entry is found */
+				get_fileinfo(dj, fno);		/* Get the object information */
+				res = dir_next(dj, 0);		/* Increment index for next */
+				if (res == FR_NO_FILE) {
+					dj->sect = 0;
+					res = FR_OK;
+				}
+			}
+			FREE_BUF();
+		}
+	}
+
+	LEAVE_FF(dj->fs, res);
+}
+
+
+
+#if _FS_MINIMIZE == 0
+/*-----------------------------------------------------------------------*/
+/* Get File Status                                                       */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_stat (
+	const TCHAR *path,	/* Pointer to the file path */
+	FILINFO *fno		/* Pointer to file information to return */
+)
+{
+	FRESULT res;
+	DIR dj;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 0);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		if (res == FR_OK) {				/* Follow completed */
+			if (dj.dir)		/* Found an object */
+				get_fileinfo(&dj, fno);
+			else			/* It is root dir */
+				res = FR_INVALID_NAME;
+		}
+		FREE_BUF();
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Get Number of Free Clusters                                           */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_getfree (
+	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
+	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
+	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD n, clst, sect, stat;
+	UINT i;
+	BYTE fat, *p;
+
+
+	/* Get drive number */
+	res = chk_mounted(&path, fatfs, 0);
+	fs = *fatfs;
+	if (res == FR_OK) {
+		/* If free_clust is valid, return it without full cluster scan */
+		if (fs->free_clust <= fs->n_fatent - 2) {
+			*nclst = fs->free_clust;
+		} else {
+			/* Get number of free clusters */
+			fat = fs->fs_type;
+			n = 0;
+			if (fat == FS_FAT12) {
+				clst = 2;
+				do {
+					stat = get_fat(fs, clst);
+					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
+					if (stat == 1) { res = FR_INT_ERR; break; }
+					if (stat == 0) n++;
+				} while (++clst < fs->n_fatent);
+			} else {
+				clst = fs->n_fatent;
+				sect = fs->fatbase;
+				i = 0; p = 0;
+				do {
+					if (!i) {
+						res = move_window(fs, sect++);
+						if (res != FR_OK) break;
+						p = fs->win;
+						i = SS(fs);
+					}
+					if (fat == FS_FAT16) {
+						if (LD_WORD(p) == 0) n++;
+						p += 2; i -= 2;
+					} else {
+						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
+						p += 4; i -= 4;
+					}
+				} while (--clst);
+			}
+			fs->free_clust = n;
+			if (fat == FS_FAT32) fs->fsi_flag = 1;
+			*nclst = n;
+		}
+	}
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Truncate File                                                         */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_truncate (
+	FIL *fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	DWORD ncl;
+
+
+	if (!fp) return FR_INVALID_OBJECT;
+
+	res = validate(fp);						/* Check validity of the object */
+	if (res == FR_OK) {
+		if (fp->flag & FA__ERROR) {			/* Check abort flag */
+			res = FR_INT_ERR;
+		} else {
+			if (!(fp->flag & FA_WRITE))		/* Check access mode */
+				res = FR_DENIED;
+		}
+	}
+	if (res == FR_OK) {
+		if (fp->fsize > fp->fptr) {
+			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
+			fp->flag |= FA__WRITTEN;
+			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
+				res = remove_chain(fp->fs, fp->sclust);
+				fp->sclust = 0;
+			} else {				/* When truncate a part of the file, remove remaining clusters */
+				ncl = get_fat(fp->fs, fp->clust);
+				res = FR_OK;
+				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
+				if (ncl == 1) res = FR_INT_ERR;
+				if (res == FR_OK && ncl < fp->fs->n_fatent) {
+					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
+					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
+				}
+			}
+		}
+		if (res != FR_OK) fp->flag |= FA__ERROR;
+	}
+
+	LEAVE_FF(fp->fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Delete a File or Directory                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_unlink (
+	const TCHAR *path		/* Pointer to the file or directory path */
+)
+{
+	FRESULT res;
+	DIR dj, sdj;
+	BYTE *dir;
+	DWORD dclst;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);		/* Follow the file path */
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
+#if _FS_LOCK
+		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
+#endif
+		if (res == FR_OK) {					/* The object is accessible */
+			dir = dj.dir;
+			if (!dir) {
+				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
+			} else {
+				if (dir[DIR_Attr] & AM_RDO)
+					res = FR_DENIED;		/* Cannot remove R/O object */
+			}
+			dclst = ld_clust(dj.fs, dir);
+			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
+				if (dclst < 2) {
+					res = FR_INT_ERR;
+				} else {
+					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
+					sdj.sclust = dclst;
+					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
+					if (res == FR_OK) {
+						res = dir_read(&sdj);
+						if (res == FR_OK		/* Not empty dir */
+#if _FS_RPATH
+						|| dclst == dj.fs->cdir	/* Current dir */
+#endif
+						) res = FR_DENIED;
+						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
+					}
+				}
+			}
+			if (res == FR_OK) {
+				res = dir_remove(&dj);		/* Remove the directory entry */
+				if (res == FR_OK) {
+					if (dclst)				/* Remove the cluster chain if exist */
+						res = remove_chain(dj.fs, dclst);
+					if (res == FR_OK) res = sync(dj.fs);
+				}
+			}
+		}
+		FREE_BUF();
+	}
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Create a Directory                                                    */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mkdir (
+	const TCHAR *path		/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir, n;
+	DWORD dsc, dcl, pcl, tim = get_fattime();
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);			/* Follow the file path */
+		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
+		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_NO_FILE) {				/* Can create a new directory */
+			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
+			res = FR_OK;
+			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
+			if (dcl == 1) res = FR_INT_ERR;
+			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
+			if (res == FR_OK)					/* Flush FAT */
+				res = move_window(dj.fs, 0);
+			if (res == FR_OK) {					/* Initialize the new directory table */
+				dsc = clust2sect(dj.fs, dcl);
+				dir = dj.fs->win;
+				mem_set(dir, 0, SS(dj.fs));
+				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
+				dir[DIR_Name] = '.';
+				dir[DIR_Attr] = AM_DIR;
+				ST_DWORD(dir+DIR_WrtTime, tim);
+				st_clust(dir, dcl);
+				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
+				dir[33] = '.'; pcl = dj.sclust;
+				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
+					pcl = 0;
+				st_clust(dir+SZ_DIR, pcl);
+				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
+					dj.fs->winsect = dsc++;
+					dj.fs->wflag = 1;
+					res = move_window(dj.fs, 0);
+					if (res != FR_OK) break;
+					mem_set(dir, 0, SS(dj.fs));
+				}
+			}
+			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
+			if (res != FR_OK) {
+				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
+			} else {
+				dir = dj.dir;
+				dir[DIR_Attr] = AM_DIR;				/* Attribute */
+				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
+				st_clust(dir, dcl);					/* Table start cluster */
+				dj.fs->wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+		FREE_BUF();
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change Attribute                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_chmod (
+	const TCHAR *path,	/* Pointer to the file path */
+	BYTE value,			/* Attribute bits */
+	BYTE mask			/* Attribute mask to change */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);		/* Follow the file path */
+		FREE_BUF();
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_OK) {
+			dir = dj.dir;
+			if (!dir) {						/* Is it a root directory? */
+				res = FR_INVALID_NAME;
+			} else {						/* File or sub directory */
+				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
+				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
+				dj.fs->wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change Timestamp                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_utime (
+	const TCHAR *path,	/* Pointer to the file/directory name */
+	const FILINFO *fno	/* Pointer to the time stamp to be set */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		FREE_BUF();
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_OK) {
+			dir = dj.dir;
+			if (!dir) {					/* Root directory */
+				res = FR_INVALID_NAME;
+			} else {					/* File or sub-directory */
+				ST_WORD(dir+DIR_WrtTime, fno->ftime);
+				ST_WORD(dir+DIR_WrtDate, fno->fdate);
+				dj.fs->wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Rename File/Directory                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_rename (
+	const TCHAR *path_old,	/* Pointer to the old name */
+	const TCHAR *path_new	/* Pointer to the new name */
+)
+{
+	FRESULT res;
+	DIR djo, djn;
+	BYTE buf[21], *dir;
+	DWORD dw;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path_old, &djo.fs, 1);
+	if (res == FR_OK) {
+		djn.fs = djo.fs;
+		INIT_BUF(djo);
+		res = follow_path(&djo, path_old);		/* Check old object */
+		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+#if _FS_LOCK
+		if (res == FR_OK) res = chk_lock(&djo, 2);
+#endif
+		if (res == FR_OK) {						/* Old object is found */
+			if (!djo.dir) {						/* Is root dir? */
+				res = FR_NO_FILE;
+			} else {
+				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
+				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
+				res = follow_path(&djn, path_new);
+				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
+				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
+/* Start critical section that an interruption or error can cause cross-link */
+					res = dir_register(&djn);			/* Register the new entry */
+					if (res == FR_OK) {
+						dir = djn.dir;					/* Copy object information except for name */
+						mem_cpy(dir+13, buf+2, 19);
+						dir[DIR_Attr] = buf[0] | AM_ARC;
+						djo.fs->wflag = 1;
+						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
+							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
+							if (!dw) {
+								res = FR_INT_ERR;
+							} else {
+								res = move_window(djo.fs, dw);
+								dir = djo.fs->win+SZ_DIR;	/* .. entry */
+								if (res == FR_OK && dir[1] == '.') {
+									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
+									st_clust(dir, dw);
+									djo.fs->wflag = 1;
+								}
+							}
+						}
+						if (res == FR_OK) {
+							res = dir_remove(&djo);		/* Remove old entry */
+							if (res == FR_OK)
+								res = sync(djo.fs);
+						}
+					}
+/* End critical section */
+				}
+			}
+		}
+		FREE_BUF();
+	}
+	LEAVE_FF(djo.fs, res);
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _FS_MINIMIZE == 0 */
+#endif /* _FS_MINIMIZE <= 1 */
+#endif /* _FS_MINIMIZE <= 2 */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Forward data to the stream directly (available on only tiny cfg)      */
+/*-----------------------------------------------------------------------*/
+#if _USE_FORWARD && _FS_TINY
+
+FRESULT f_forward (
+	FIL *fp, 						/* Pointer to the file object */
+	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
+	UINT btr,						/* Number of bytes to forward */
+	UINT *bf						/* Pointer to number of bytes forwarded */
+)
+{
+	FRESULT res;
+	DWORD remain, clst, sect;
+	UINT rcnt;
+	BYTE csect;
+
+
+	*bf = 0;	/* Clear transfer byte counter */
+
+	if (!fp) return FR_INVALID_OBJECT;
+
+	res = validate(fp);								/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)						/* Check error flag */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+	if (!(fp->flag & FA_READ))						/* Check access mode */
+		LEAVE_FF(fp->fs, FR_DENIED);
+
+	remain = fp->fsize - fp->fptr;
+	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
+
+	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
+		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
+		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
+		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
+			if (!csect) {							/* On the cluster boundary? */
+				clst = (fp->fptr == 0) ?			/* On the top of the file? */
+					fp->sclust : get_fat(fp->fs, fp->clust);
+				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				fp->clust = clst;					/* Update current cluster */
+			}
+		}
+		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
+		if (!sect) ABORT(fp->fs, FR_INT_ERR);
+		sect += csect;
+		if (move_window(fp->fs, sect))				/* Move sector window */
+			ABORT(fp->fs, FR_DISK_ERR);
+		fp->dsect = sect;
+		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
+		if (rcnt > btr) rcnt = btr;
+		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
+		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
+	}
+
+	LEAVE_FF(fp->fs, FR_OK);
+}
+#endif /* _USE_FORWARD */
+
+
+
+#if _USE_MKFS && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Create File System on the Drive                                       */
+/*-----------------------------------------------------------------------*/
+#define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
+#define N_FATS		1		/* Number of FAT copies (1 or 2) */
+
+
+FRESULT f_mkfs (
+	BYTE drv,		/* Logical drive number */
+	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
+	UINT au			/* Allocation unit size [bytes] */
+)
+{
+	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
+	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
+	BYTE fmt, md, sys, *tbl, pdrv, part;
+	DWORD n_clst, vs, n, wsect;
+	UINT i;
+	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
+	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
+	FATFS *fs;
+	DSTATUS stat;
+
+
+	/* Check mounted drive and clear work area */
+	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
+	if (sfd > 1) return FR_INVALID_PARAMETER;
+	if (au & (au - 1)) return FR_INVALID_PARAMETER;
+	fs = FatFs[drv];
+	if (!fs) return FR_NOT_ENABLED;
+	fs->fs_type = 0;
+	pdrv = LD2PD(drv);	/* Physical drive */
+	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
+
+	/* Get disk statics */
+	stat = disk_initialize(pdrv);
+	if (stat & STA_NOINIT) return FR_NOT_READY;
+	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
+#if _MAX_SS != 512					/* Get disk sector size */
+	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
+		return FR_DISK_ERR;
+#endif
+	if (_MULTI_PARTITION && part) {
+		/* Get partition information from partition table in the MBR */
+		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
+		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
+		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
+		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
+		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
+		n_vol = LD_DWORD(tbl+12);	/* Volume size */
+	} else {
+		/* Create a partition in this function */
+		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
+			return FR_DISK_ERR;
+		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
+		n_vol -= b_vol;				/* Volume size */
+	}
+
+	if (!au) {				/* AU auto selection */
+		vs = n_vol / (2000 / (SS(fs) / 512));
+		for (i = 0; vs < vst[i]; i++) ;
+		au = cst[i];
+	}
+	au /= SS(fs);		/* Number of sectors per cluster */
+	if (au == 0) au = 1;
+	if (au > 128) au = 128;
+
+	/* Pre-compute number of clusters and FAT sub-type */
+	n_clst = n_vol / au;
+	fmt = FS_FAT12;
+	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
+	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
+
+	/* Determine offset and size of FAT structure */
+	if (fmt == FS_FAT32) {
+		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
+		n_rsv = 32;
+		n_dir = 0;
+	} else {
+		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
+		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
+		n_rsv = 1;
+		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
+	}
+	b_fat = b_vol + n_rsv;				/* FAT area start sector */
+	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
+	b_data = b_dir + n_dir;				/* Data area start sector */
+	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
+
+	/* Align data start sector to erase block boundary (for flash memory media) */
+	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
+	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
+	n = (n - b_data) / N_FATS;
+	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
+		n_rsv += n;
+		b_fat += n;
+	} else {					/* FAT12/16: Expand FAT size */
+		n_fat += n;
+	}
+
+	/* Determine number of clusters and final check of validity of the FAT sub-type */
+	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
+	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
+		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
+		return FR_MKFS_ABORTED;
+
+	switch (fmt) {	/* Determine system ID for partition table */
+	case FS_FAT12:	sys = 0x01; break;
+	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
+	default: 		sys = 0x0C;
+	}
+
+	if (_MULTI_PARTITION && part) {
+		/* Update system ID in the partition table */
+		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
+		tbl[4] = sys;
+		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
+		md = 0xF8;
+	} else {
+		if (sfd) {	/* No partition table (SFD) */
+			md = 0xF0;
+		} else {	/* Create partition table (FDISK) */
+			mem_set(fs->win, 0, SS(fs));
+			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
+			tbl[1] = 1;						/* Partition start head */
+			tbl[2] = 1;						/* Partition start sector */
+			tbl[3] = 0;						/* Partition start cylinder */
+			tbl[4] = sys;					/* System type */
+			tbl[5] = 254;					/* Partition end head */
+			n = (b_vol + n_vol) / 63 / 255;
+			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
+			tbl[7] = (BYTE)n;				/* End cylinder */
+			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
+			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
+			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
+			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
+				return FR_DISK_ERR;
+			md = 0xF8;
+		}
+	}
+
+	/* Create BPB in the VBR */
+	tbl = fs->win;							/* Clear sector */
+	mem_set(tbl, 0, SS(fs));
+	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
+	i = SS(fs);								/* Sector size */
+	ST_WORD(tbl+BPB_BytsPerSec, i);
+	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
+	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
+	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
+	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
+	ST_WORD(tbl+BPB_RootEntCnt, i);
+	if (n_vol < 0x10000) {					/* Number of total sectors */
+		ST_WORD(tbl+BPB_TotSec16, n_vol);
+	} else {
+		ST_DWORD(tbl+BPB_TotSec32, n_vol);
+	}
+	tbl[BPB_Media] = md;					/* Media descriptor */
+	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
+	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
+	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
+	n = get_fattime();						/* Use current time as VSN */
+	if (fmt == FS_FAT32) {
+		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
+		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
+		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
+		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
+		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
+		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
+		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
+		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
+	} else {
+		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
+		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
+		tbl[BS_DrvNum] = 0x80;				/* Drive number */
+		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
+		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
+	}
+	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
+	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
+		return FR_DISK_ERR;
+	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
+		disk_write(pdrv, tbl, b_vol + 6, 1);
+
+	/* Initialize FAT area */
+	wsect = b_fat;
+	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
+		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
+		n = md;								/* Media descriptor byte */
+		if (fmt != FS_FAT32) {
+			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
+			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
+		} else {
+			n |= 0xFFFFFF00;
+			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
+			ST_DWORD(tbl+4, 0xFFFFFFFF);
+			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
+		}
+		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+			return FR_DISK_ERR;
+		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
+		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
+			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+				return FR_DISK_ERR;
+		}
+	}
+
+	/* Initialize root directory */
+	i = (fmt == FS_FAT32) ? au : n_dir;
+	do {
+		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+			return FR_DISK_ERR;
+	} while (--i);
+
+#if _USE_ERASE	/* Erase data area if needed */
+	{
+		DWORD eb[2];
+
+		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
+		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
+	}
+#endif
+
+	/* Create FSInfo if needed */
+	if (fmt == FS_FAT32) {
+		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
+		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
+		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
+		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
+		ST_WORD(tbl+BS_55AA, 0xAA55);
+		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
+		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
+	}
+
+	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
+}
+
+
+#if _MULTI_PARTITION == 2
+/*-----------------------------------------------------------------------*/
+/* Divide Physical Drive                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_fdisk (
+	BYTE pdrv,			/* Physical drive number */
+	const DWORD szt[],	/* Pointer to the size table for each partitions */
+	void* work			/* Pointer to the working buffer */
+)
+{
+	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
+	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
+	DSTATUS stat;
+	DWORD sz_disk, sz_part, s_part;
+
+
+	stat = disk_initialize(pdrv);
+	if (stat & STA_NOINIT) return FR_NOT_READY;
+	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
+	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
+
+	/* Determine CHS in the table regardless of the drive geometry */
+	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
+	if (n == 256) n--;
+	e_hd = n - 1;
+	sz_cyl = 63 * n;
+	tot_cyl = sz_disk / sz_cyl;
+
+	/* Create partition table */
+	mem_set(buf, 0, _MAX_SS);
+	p = buf + MBR_Table; b_cyl = 0;
+	for (i = 0; i < 4; i++, p += SZ_PTE) {
+		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
+		if (!p_cyl) continue;
+		s_part = (DWORD)sz_cyl * b_cyl;
+		sz_part = (DWORD)sz_cyl * p_cyl;
+		if (i == 0) {	/* Exclude first track of cylinder 0 */
+			s_hd = 1;
+			s_part += 63; sz_part -= 63;
+		} else {
+			s_hd = 0;
+		}
+		e_cyl = b_cyl + p_cyl - 1;
+		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
+
+		/* Set partition table */
+		p[1] = s_hd;						/* Start head */
+		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
+		p[3] = (BYTE)b_cyl;					/* Start cylinder */
+		p[4] = 0x06;						/* System type (temporary setting) */
+		p[5] = e_hd;						/* End head */
+		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
+		p[7] = (BYTE)e_cyl;					/* End cylinder */
+		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
+		ST_DWORD(p + 12, sz_part);			/* Partition size */
+
+		/* Next partition */
+		b_cyl += p_cyl;
+	}
+	ST_WORD(p, 0xAA55);
+
+	/* Write it to the MBR */
+	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
+}
+
+
+#endif /* _MULTI_PARTITION == 2 */
+#endif /* _USE_MKFS && !_FS_READONLY */
+
+
+
+
+#if _USE_STRFUNC
+/*-----------------------------------------------------------------------*/
+/* Get a string from the file                                            */
+/*-----------------------------------------------------------------------*/
+TCHAR* f_gets (
+	TCHAR* buff,	/* Pointer to the string buffer to read */
+	int len,		/* Size of string buffer (characters) */
+	FIL* fil		/* Pointer to the file object */
+)
+{
+	int n = 0;
+	TCHAR c, *p = buff;
+	BYTE s[2];
+	UINT rc;
+
+
+	while (n < len - 1) {			/* Read bytes until buffer gets filled */
+		f_read(fil, s, 1, &rc);
+		if (rc != 1) break;			/* Break on EOF or error */
+		c = s[0];
+#if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
+		if (c >= 0x80) {
+			if (c < 0xC0) continue;	/* Skip stray trailer */
+			if (c < 0xE0) {			/* Two-byte sequence */
+				f_read(fil, s, 1, &rc);
+				if (rc != 1) break;
+				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
+				if (c < 0x80) c = '?';
+			} else {
+				if (c < 0xF0) {		/* Three-byte sequence */
+					f_read(fil, s, 2, &rc);
+					if (rc != 2) break;
+					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
+					if (c < 0x800) c = '?';
+				} else {			/* Reject four-byte sequence */
+					c = '?';
+				}
+			}
+		}
+#endif
+#if _USE_STRFUNC >= 2
+		if (c == '\r') continue;	/* Strip '\r' */
+#endif
+		*p++ = c;
+		n++;
+		if (c == '\n') break;		/* Break on EOL */
+	}
+	*p = 0;
+	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
+}
+
+
+
+#if !_FS_READONLY
+#include <stdarg.h>
+/*-----------------------------------------------------------------------*/
+/* Put a character to the file                                           */
+/*-----------------------------------------------------------------------*/
+int f_putc (
+	TCHAR c,	/* A character to be output */
+	FIL* fil	/* Pointer to the file object */
+)
+{
+	UINT bw, btw;
+	BYTE s[3];
+
+
+#if _USE_STRFUNC >= 2
+	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
+#endif
+
+#if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
+	if (c < 0x80) {			/* 7-bit */
+		s[0] = (BYTE)c;
+		btw = 1;
+	} else {
+		if (c < 0x800) {	/* 11-bit */
+			s[0] = (BYTE)(0xC0 | (c >> 6));
+			s[1] = (BYTE)(0x80 | (c & 0x3F));
+			btw = 2;
+		} else {			/* 16-bit */
+			s[0] = (BYTE)(0xE0 | (c >> 12));
+			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
+			s[2] = (BYTE)(0x80 | (c & 0x3F));
+			btw = 3;
+		}
+	}
+#else				/* Write the character without conversion */
+	s[0] = (BYTE)c;
+	btw = 1;
+#endif
+	f_write(fil, s, btw, &bw);		/* Write the char to the file */
+	return (bw == btw) ? 1 : EOF;	/* Return the result */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a string to the file                                              */
+/*-----------------------------------------------------------------------*/
+int f_puts (
+	const TCHAR* str,	/* Pointer to the string to be output */
+	FIL* fil			/* Pointer to the file object */
+)
+{
+	int n;
+
+
+	for (n = 0; *str; str++, n++) {
+		if (f_putc(*str, fil) == EOF) return EOF;
+	}
+	return n;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a formatted string to the file                                    */
+/*-----------------------------------------------------------------------*/
+int f_printf (
+	FIL* fil,			/* Pointer to the file object */
+	const TCHAR* str,	/* Pointer to the format string */
+	...					/* Optional arguments... */
+)
+{
+	va_list arp;
+	BYTE f, r;
+	UINT i, j, w;
+	ULONG v;
+	TCHAR c, d, s[16], *p;
+	int res, chc, cc;
+
+
+	va_start(arp, str);
+
+	for (cc = res = 0; cc != EOF; res += cc) {
+		c = *str++;
+		if (c == 0) break;			/* End of string */
+		if (c != '%') {				/* Non escape character */
+			cc = f_putc(c, fil);
+			if (cc != EOF) cc = 1;
+			continue;
+		}
+		w = f = 0;
+		c = *str++;
+		if (c == '0') {				/* Flag: '0' padding */
+			f = 1; c = *str++;
+		} else {
+			if (c == '-') {			/* Flag: left justified */
+				f = 2; c = *str++;
+			}
+		}
+		while (IsDigit(c)) {		/* Precision */
+			w = w * 10 + c - '0';
+			c = *str++;
+		}
+		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
+			f |= 4; c = *str++;
+		}
+		if (!c) break;
+		d = c;
+		if (IsLower(d)) d -= 0x20;
+		switch (d) {				/* Type is... */
+		case 'S' :					/* String */
+			p = va_arg(arp, TCHAR*);
+			for (j = 0; p[j]; j++) ;
+			chc = 0;
+			if (!(f & 2)) {
+				while (j++ < w) chc += (cc = f_putc(' ', fil));
+			}
+			chc += (cc = f_puts(p, fil));
+			while (j++ < w) chc += (cc = f_putc(' ', fil));
+			if (cc != EOF) cc = chc;
+			continue;
+		case 'C' :					/* Character */
+			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
+		case 'B' :					/* Binary */
+			r = 2; break;
+		case 'O' :					/* Octal */
+			r = 8; break;
+		case 'D' :					/* Signed decimal */
+		case 'U' :					/* Unsigned decimal */
+			r = 10; break;
+		case 'X' :					/* Hexdecimal */
+			r = 16; break;
+		default:					/* Unknown type (pass-through) */
+			cc = f_putc(c, fil); continue;
+		}
+
+		/* Get an argument and put it in numeral */
+		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
+		if (d == 'D' && (v & 0x80000000)) {
+			v = 0 - v;
+			f |= 8;
+		}
+		i = 0;
+		do {
+			d = (TCHAR)(v % r); v /= r;
+			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
+			s[i++] = d + '0';
+		} while (v && i < sizeof s / sizeof s[0]);
+		if (f & 8) s[i++] = '-';
+		j = i; d = (f & 1) ? '0' : ' ';
+		res = 0;
+		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
+		do res += (cc = f_putc(s[--i], fil)); while(i);
+		while (j++ < w) res += (cc = f_putc(' ', fil));
+		if (cc != EOF) cc = res;
+	}
+
+	va_end(arp);
+	return (cc == EOF) ? cc : res;
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _USE_STRFUNC */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/src/fs_usb.c ./libs/elm-chan-FatFs/fatfs_usb/src/fs_usb.c
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/src/fs_usb.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/src/fs_usb.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,182 @@
+/*
+ * @brief USB Mass Storage Chan FATFS simple abstraction layer
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "fsusb_cfg.h"
+#include "board.h"
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Disk Status */
+static volatile DSTATUS Stat = STA_NOINIT;
+
+/* 100Hz decrement timer stopped at zero (disk_timerproc()) */
+static volatile WORD Timer2;
+
+static DISK_HANDLE_T *hDisk;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize Disk Drive */
+DSTATUS disk_initialize(BYTE drv)
+{
+	if (drv) {
+		return STA_NOINIT;				/* Supports only single drive */
+	}
+	/*	if (Stat & STA_NODISK) return Stat;	*//* No card in the socket */
+
+	if (Stat != STA_NOINIT) {
+		return Stat;					/* card is already enumerated */
+
+	}
+
+	#if !_FS_READONLY
+	FSUSB_InitRealTimeClock();
+	#endif
+
+	/* Initialize the Card Data Strucutre */
+	hDisk = FSUSB_DiskInit();
+
+	/* Reset */
+	Stat = STA_NOINIT;
+
+	FSUSB_DiskInsertWait(hDisk); /* Wait for card to be inserted */
+
+	/* Enumerate the card once detected. Note this function may block for a little while. */
+	if (!FSUSB_DiskAcquire(hDisk)) {
+		DEBUGOUT("Disk Enumeration failed...\r\n");
+		return Stat;
+	}
+
+	Stat &= ~STA_NOINIT;
+	return Stat;
+
+}
+
+/* Disk Drive miscellaneous Functions */
+DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
+{
+	DRESULT res;
+
+	if (drv) {
+		return RES_PARERR;
+	}
+	if (Stat & STA_NOINIT) {
+		return RES_NOTRDY;
+	}
+
+	res = RES_ERROR;
+
+	switch (ctrl) {
+	case CTRL_SYNC:	/* Make sure that no pending write process */
+		if (FSUSB_DiskReadyWait(hDisk, 50)) {
+			res = RES_OK;
+		}
+		break;
+
+	case GET_SECTOR_COUNT:	/* Get number of sectors on the disk (DWORD) */
+		*(DWORD *) buff = FSUSB_DiskGetSectorCnt(hDisk);
+		res = RES_OK;
+		break;
+
+	case GET_SECTOR_SIZE:	/* Get R/W sector size (WORD) */
+		*(WORD *) buff = FSUSB_DiskGetSectorSz(hDisk);
+		res = RES_OK;
+		break;
+
+	case GET_BLOCK_SIZE:/* Get erase block size in unit of sector (DWORD) */
+		*(DWORD *) buff = FSUSB_DiskGetBlockSz(hDisk);
+		res = RES_OK;
+		break;
+
+	default:
+		res = RES_PARERR;
+		break;
+	}
+
+	return res;
+}
+
+/* Read Sector(s) */
+DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
+{
+	if (drv || !count) {
+		return RES_PARERR;
+	}
+	if (Stat & STA_NOINIT) {
+		return RES_NOTRDY;
+	}
+
+	if (FSUSB_DiskReadSectors(hDisk, buff, sector, count)) {
+		return RES_OK;
+	}
+
+	return RES_ERROR;
+}
+
+/* Get Disk Status */
+DSTATUS disk_status(BYTE drv)
+{
+	if (drv) {
+		return STA_NOINIT;	/* Supports only single drive */
+	}
+	return Stat;
+}
+
+/* Write Sector(s) */
+DRESULT disk_write(BYTE drv, const BYTE *buff, DWORD sector, BYTE count)
+{
+
+	if (drv || !count) {
+		return RES_PARERR;
+	}
+	if (Stat & STA_NOINIT) {
+		return RES_NOTRDY;
+	}
+
+	if (FSUSB_DiskWriteSectors(hDisk, (void *) buff, sector, count)) {
+		return RES_OK;
+	}
+
+	return RES_ERROR;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/src/rtc.c ./libs/elm-chan-FatFs/fatfs_usb/src/rtc.c
--- a_bRU7kv/libs/elm-chan-FatFs/fatfs_usb/src/rtc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/fatfs_usb/src/rtc.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,101 @@
+/*------------------------------------------------------------------------/
+/RTC control module
+/-------------------------------------------------------------------------/
+/
+/  Copyright (C) 2011, ChaN, all right reserved.
+/
+/ * This software is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
+/ * Redistributions of source code must retain the above copyright notice.
+/
+/-------------------------------------------------------------------------*/
+
+#include "chip.h"
+#include "board.h"
+#include "rtc.h"
+
+
+int rtc_initialize (void)
+{
+	static int init;
+	RTC_TIME_T rtcTime;
+
+	if (init) /* Already initialized */
+		return 1;
+
+	/* RTC Block section ------------------------------------------------------ */
+	Chip_RTC_Init(LPC_RTC);
+
+	/* Set current time for RTC */
+	/* Current time is 8:00:00PM, 2013-01-31 */
+	rtcTime.time[RTC_TIMETYPE_SECOND]     = 0;
+	rtcTime.time[RTC_TIMETYPE_MINUTE]     = 0;
+	rtcTime.time[RTC_TIMETYPE_HOUR]       = 20;
+	rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = 31;
+	rtcTime.time[RTC_TIMETYPE_MONTH]      = 1;
+	rtcTime.time[RTC_TIMETYPE_YEAR]       = 2013;
+	Chip_RTC_SetFullAlarmTime(LPC_RTC, &rtcTime);
+
+	/* Enable rtc (starts increase the tick counter and second counter register) */
+	Chip_RTC_Enable(LPC_RTC, ENABLE);
+	init = 1;
+
+	return 1;
+}
+
+int rtc_gettime (RTC *rtc)
+{
+	RTC_TIME_T rtcTime;
+
+	Chip_RTC_GetFullTime(LPC_RTC, &rtcTime);
+
+	rtc->sec = rtcTime.time[RTC_TIMETYPE_SECOND];
+	rtc->min = rtcTime.time[RTC_TIMETYPE_MINUTE];
+	rtc->hour = rtcTime.time[RTC_TIMETYPE_HOUR];
+	rtc->wday = rtcTime.time[RTC_TIMETYPE_DAYOFWEEK];
+	rtc->mday = rtcTime.time[RTC_TIMETYPE_DAYOFMONTH];
+	rtc->month = rtcTime.time[RTC_TIMETYPE_MONTH];
+	rtc->year = rtcTime.time[RTC_TIMETYPE_YEAR];
+  return 1;
+}
+
+int rtc_settime (const RTC *rtc)
+{
+	RTC_TIME_T rtcTime;
+
+	rtcTime.time[RTC_TIMETYPE_SECOND]     = rtc->sec;
+	rtcTime.time[RTC_TIMETYPE_MINUTE]     = rtc->min;
+	rtcTime.time[RTC_TIMETYPE_HOUR]       = rtc->hour;
+	rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->wday;
+	rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->mday;
+	rtcTime.time[RTC_TIMETYPE_MONTH]      = rtc->month;
+	rtcTime.time[RTC_TIMETYPE_YEAR]	      = rtc->year;
+
+	Chip_RTC_GetFullTime(LPC_RTC, &rtcTime);
+
+  return 1;
+}
+
+/**
+ * @brief	User Provided Timer Function for FatFs module
+ * @return	Nothing
+ * @note	This is a real time clock service to be called from FatFs module.
+ * Any valid time must be returned even if the system does not support a real time clock.
+ * This is not required in read-only configuration.
+ */
+DWORD get_fattime()
+{
+	RTC rtc;
+
+	/* Get local time */
+	rtc_gettime(&rtc);
+
+	/* Pack date and time into a DWORD variable */
+	return ((DWORD) (rtc.year - 1980) << 25)
+		   | ((DWORD) rtc.month << 21)
+		   | ((DWORD) rtc.mday << 16)
+		   | ((DWORD) rtc.hour << 11)
+		   | ((DWORD) rtc.min << 5)
+		   | ((DWORD) rtc.sec >> 1);
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/elm-chan-FatFs/module.mk ./libs/elm-chan-FatFs/module.mk
--- a_bRU7kv/libs/elm-chan-FatFs/module.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/elm-chan-FatFs/module.mk	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,13 @@
+ifeq ($(USE_FATFS_SSP),y)
+FATFS_BASE=libs/elm-chan-FatFs
+DEFINES+=USE_FATFS_SSP
+INCLUDES += -I$(FATFS_BASE)/fatfs_ssp/inc
+SRC+=$(wildcard $(FATFS_BASE)/fatfs_ssp/src/*.c)
+endif
+
+ifeq ($(USE_FATFS_USB),y)
+FATFS_BASE=libs/elm-chan-FatFs
+DEFINES+=USE_FATFS_USB
+INCLUDES += -I$(FATFS_BASE)/fatfs_usb/inc
+SRC+=$(wildcard $(FATFS_BASE)/fatfs_usb/src/*.c)
+endif
\ No hay ningún carácter de nueva línea al final del archivo
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/event_groups.h ./libs/freertos/include/event_groups.h
--- a_bRU7kv/libs/freertos/include/event_groups.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/event_groups.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,756 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef EVENT_GROUPS_H
+#define EVENT_GROUPS_H
+
+#ifndef INC_FREERTOS_H
+	#error "include FreeRTOS.h" must appear in source files before "include event_groups.h"
+#endif
+
+/* FreeRTOS includes. */
+#include "timers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * An event group is a collection of bits to which an application can assign a
+ * meaning.  For example, an application may create an event group to convey
+ * the status of various CAN bus related events in which bit 0 might mean "A CAN
+ * message has been received and is ready for processing", bit 1 might mean "The
+ * application has queued a message that is ready for sending onto the CAN
+ * network", and bit 2 might mean "It is time to send a SYNC message onto the
+ * CAN network" etc.  A task can then test the bit values to see which events
+ * are active, and optionally enter the Blocked state to wait for a specified
+ * bit or a group of specified bits to be active.  To continue the CAN bus
+ * example, a CAN controlling task can enter the Blocked state (and therefore
+ * not consume any processing time) until either bit 0, bit 1 or bit 2 are
+ * active, at which time the bit that was actually active would inform the task
+ * which action it had to take (process a received message, send a message, or
+ * send a SYNC).
+ *
+ * The event groups implementation contains intelligence to avoid race
+ * conditions that would otherwise occur were an application to use a simple
+ * variable for the same purpose.  This is particularly important with respect
+ * to when a bit within an event group is to be cleared, and when bits have to
+ * be set and then tested atomically - as is the case where event groups are
+ * used to create a synchronisation point between multiple tasks (a
+ * 'rendezvous').
+ *
+ * \defgroup EventGroup
+ */
+
+
+
+/**
+ * event_groups.h
+ *
+ * Type by which event groups are referenced.  For example, a call to
+ * xEventGroupCreate() returns an EventGroupHandle_t variable that can then
+ * be used as a parameter to other event group functions.
+ *
+ * \defgroup EventGroupHandle_t EventGroupHandle_t
+ * \ingroup EventGroup
+ */
+typedef void * EventGroupHandle_t;
+
+/*
+ * The type that holds event bits always matches TickType_t - therefore the
+ * number of bits it holds is set by configUSE_16_BIT_TICKS (16 bits if set to 1,
+ * 32 bits if set to 0.
+ *
+ * \defgroup EventBits_t EventBits_t
+ * \ingroup EventGroup
+ */
+typedef TickType_t EventBits_t;
+
+/**
+ * event_groups.h
+ *<pre>
+ EventGroupHandle_t xEventGroupCreate( void );
+ </pre>
+ *
+ * Create a new event group.
+ *
+ * Internally, within the FreeRTOS implementation, event groups use a [small]
+ * block of memory, in which the event group's structure is stored.  If an event
+ * groups is created using xEventGropuCreate() then the required memory is
+ * automatically dynamically allocated inside the xEventGroupCreate() function.
+ * (see http://www.freertos.org/a00111.html).  If an event group is created
+ * using xEventGropuCreateStatic() then the application writer must instead
+ * provide the memory that will get used by the event group.
+ * xEventGroupCreateStatic() therefore allows an event group to be created
+ * without using any dynamic memory allocation.
+ *
+ * Although event groups are not related to ticks, for internal implementation
+ * reasons the number of bits available for use in an event group is dependent
+ * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
+ * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
+ * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
+ * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
+ * event bits within an event group.
+ *
+ * @return If the event group was created then a handle to the event group is
+ * returned.  If there was insufficient FreeRTOS heap available to create the
+ * event group then NULL is returned.  See http://www.freertos.org/a00111.html
+ *
+ * Example usage:
+   <pre>
+	// Declare a variable to hold the created event group.
+	EventGroupHandle_t xCreatedEventGroup;
+
+	// Attempt to create the event group.
+	xCreatedEventGroup = xEventGroupCreate();
+
+	// Was the event group created successfully?
+	if( xCreatedEventGroup == NULL )
+	{
+		// The event group was not created because there was insufficient
+		// FreeRTOS heap available.
+	}
+	else
+	{
+		// The event group was created.
+	}
+   </pre>
+ * \defgroup xEventGroupCreate xEventGroupCreate
+ * \ingroup EventGroup
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	EventGroupHandle_t xEventGroupCreate( void ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * event_groups.h
+ *<pre>
+ EventGroupHandle_t xEventGroupCreateStatic( EventGroupHandle_t * pxEventGroupBuffer );
+ </pre>
+ *
+ * Create a new event group.
+ *
+ * Internally, within the FreeRTOS implementation, event groups use a [small]
+ * block of memory, in which the event group's structure is stored.  If an event
+ * groups is created using xEventGropuCreate() then the required memory is
+ * automatically dynamically allocated inside the xEventGroupCreate() function.
+ * (see http://www.freertos.org/a00111.html).  If an event group is created
+ * using xEventGropuCreateStatic() then the application writer must instead
+ * provide the memory that will get used by the event group.
+ * xEventGroupCreateStatic() therefore allows an event group to be created
+ * without using any dynamic memory allocation.
+ *
+ * Although event groups are not related to ticks, for internal implementation
+ * reasons the number of bits available for use in an event group is dependent
+ * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
+ * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
+ * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
+ * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
+ * event bits within an event group.
+ *
+ * @param pxEventGroupBuffer pxEventGroupBuffer must point to a variable of type
+ * StaticEventGroup_t, which will be then be used to hold the event group's data
+ * structures, removing the need for the memory to be allocated dynamically.
+ *
+ * @return If the event group was created then a handle to the event group is
+ * returned.  If pxEventGroupBuffer was NULL then NULL is returned.
+ *
+ * Example usage:
+   <pre>
+	// StaticEventGroup_t is a publicly accessible structure that has the same
+	// size and alignment requirements as the real event group structure.  It is
+	// provided as a mechanism for applications to know the size of the event
+	// group (which is dependent on the architecture and configuration file
+	// settings) without breaking the strict data hiding policy by exposing the
+	// real event group internals.  This StaticEventGroup_t variable is passed
+	// into the xSemaphoreCreateEventGroupStatic() function and is used to store
+	// the event group's data structures
+	StaticEventGroup_t xEventGroupBuffer;
+
+	// Create the event group without dynamically allocating any memory.
+	xEventGroup = xEventGroupCreateStatic( &xEventGroupBuffer );
+   </pre>
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * event_groups.h
+ *<pre>
+	EventBits_t xEventGroupWaitBits( 	EventGroupHandle_t xEventGroup,
+										const EventBits_t uxBitsToWaitFor,
+										const BaseType_t xClearOnExit,
+										const BaseType_t xWaitForAllBits,
+										const TickType_t xTicksToWait );
+ </pre>
+ *
+ * [Potentially] block to wait for one or more bits to be set within a
+ * previously created event group.
+ *
+ * This function cannot be called from an interrupt.
+ *
+ * @param xEventGroup The event group in which the bits are being tested.  The
+ * event group must have previously been created using a call to
+ * xEventGroupCreate().
+ *
+ * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
+ * inside the event group.  For example, to wait for bit 0 and/or bit 2 set
+ * uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set
+ * uxBitsToWaitFor to 0x07.  Etc.
+ *
+ * @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within
+ * uxBitsToWaitFor that are set within the event group will be cleared before
+ * xEventGroupWaitBits() returns if the wait condition was met (if the function
+ * returns for a reason other than a timeout).  If xClearOnExit is set to
+ * pdFALSE then the bits set in the event group are not altered when the call to
+ * xEventGroupWaitBits() returns.
+ *
+ * @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then
+ * xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor
+ * are set or the specified block time expires.  If xWaitForAllBits is set to
+ * pdFALSE then xEventGroupWaitBits() will return when any one of the bits set
+ * in uxBitsToWaitFor is set or the specified block time expires.  The block
+ * time is specified by the xTicksToWait parameter.
+ *
+ * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
+ * for one/all (depending on the xWaitForAllBits value) of the bits specified by
+ * uxBitsToWaitFor to become set.
+ *
+ * @return The value of the event group at the time either the bits being waited
+ * for became set, or the block time expired.  Test the return value to know
+ * which bits were set.  If xEventGroupWaitBits() returned because its timeout
+ * expired then not all the bits being waited for will be set.  If
+ * xEventGroupWaitBits() returned because the bits it was waiting for were set
+ * then the returned value is the event group value before any bits were
+ * automatically cleared in the case that xClearOnExit parameter was set to
+ * pdTRUE.
+ *
+ * Example usage:
+   <pre>
+   #define BIT_0	( 1 << 0 )
+   #define BIT_4	( 1 << 4 )
+
+   void aFunction( EventGroupHandle_t xEventGroup )
+   {
+   EventBits_t uxBits;
+   const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
+
+		// Wait a maximum of 100ms for either bit 0 or bit 4 to be set within
+		// the event group.  Clear the bits before exiting.
+		uxBits = xEventGroupWaitBits(
+					xEventGroup,	// The event group being tested.
+					BIT_0 | BIT_4,	// The bits within the event group to wait for.
+					pdTRUE,			// BIT_0 and BIT_4 should be cleared before returning.
+					pdFALSE,		// Don't wait for both bits, either bit will do.
+					xTicksToWait );	// Wait a maximum of 100ms for either bit to be set.
+
+		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
+		{
+			// xEventGroupWaitBits() returned because both bits were set.
+		}
+		else if( ( uxBits & BIT_0 ) != 0 )
+		{
+			// xEventGroupWaitBits() returned because just BIT_0 was set.
+		}
+		else if( ( uxBits & BIT_4 ) != 0 )
+		{
+			// xEventGroupWaitBits() returned because just BIT_4 was set.
+		}
+		else
+		{
+			// xEventGroupWaitBits() returned because xTicksToWait ticks passed
+			// without either BIT_0 or BIT_4 becoming set.
+		}
+   }
+   </pre>
+ * \defgroup xEventGroupWaitBits xEventGroupWaitBits
+ * \ingroup EventGroup
+ */
+EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * event_groups.h
+ *<pre>
+	EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );
+ </pre>
+ *
+ * Clear bits within an event group.  This function cannot be called from an
+ * interrupt.
+ *
+ * @param xEventGroup The event group in which the bits are to be cleared.
+ *
+ * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear
+ * in the event group.  For example, to clear bit 3 only, set uxBitsToClear to
+ * 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.
+ *
+ * @return The value of the event group before the specified bits were cleared.
+ *
+ * Example usage:
+   <pre>
+   #define BIT_0	( 1 << 0 )
+   #define BIT_4	( 1 << 4 )
+
+   void aFunction( EventGroupHandle_t xEventGroup )
+   {
+   EventBits_t uxBits;
+
+		// Clear bit 0 and bit 4 in xEventGroup.
+		uxBits = xEventGroupClearBits(
+								xEventGroup,	// The event group being updated.
+								BIT_0 | BIT_4 );// The bits being cleared.
+
+		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
+		{
+			// Both bit 0 and bit 4 were set before xEventGroupClearBits() was
+			// called.  Both will now be clear (not set).
+		}
+		else if( ( uxBits & BIT_0 ) != 0 )
+		{
+			// Bit 0 was set before xEventGroupClearBits() was called.  It will
+			// now be clear.
+		}
+		else if( ( uxBits & BIT_4 ) != 0 )
+		{
+			// Bit 4 was set before xEventGroupClearBits() was called.  It will
+			// now be clear.
+		}
+		else
+		{
+			// Neither bit 0 nor bit 4 were set in the first place.
+		}
+   }
+   </pre>
+ * \defgroup xEventGroupClearBits xEventGroupClearBits
+ * \ingroup EventGroup
+ */
+EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;
+
+/**
+ * event_groups.h
+ *<pre>
+	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
+ </pre>
+ *
+ * A version of xEventGroupClearBits() that can be called from an interrupt.
+ *
+ * Setting bits in an event group is not a deterministic operation because there
+ * are an unknown number of tasks that may be waiting for the bit or bits being
+ * set.  FreeRTOS does not allow nondeterministic operations to be performed
+ * while interrupts are disabled, so protects event groups that are accessed
+ * from tasks by suspending the scheduler rather than disabling interrupts.  As
+ * a result event groups cannot be accessed directly from an interrupt service
+ * routine.  Therefore xEventGroupClearBitsFromISR() sends a message to the
+ * timer task to have the clear operation performed in the context of the timer
+ * task.
+ *
+ * @param xEventGroup The event group in which the bits are to be cleared.
+ *
+ * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear.
+ * For example, to clear bit 3 only, set uxBitsToClear to 0x08.  To clear bit 3
+ * and bit 0 set uxBitsToClear to 0x09.
+ *
+ * @return If the request to execute the function was posted successfully then
+ * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned
+ * if the timer service queue was full.
+ *
+ * Example usage:
+   <pre>
+   #define BIT_0	( 1 << 0 )
+   #define BIT_4	( 1 << 4 )
+
+   // An event group which it is assumed has already been created by a call to
+   // xEventGroupCreate().
+   EventGroupHandle_t xEventGroup;
+
+   void anInterruptHandler( void )
+   {
+		// Clear bit 0 and bit 4 in xEventGroup.
+		xResult = xEventGroupClearBitsFromISR(
+							xEventGroup,	 // The event group being updated.
+							BIT_0 | BIT_4 ); // The bits being set.
+
+		if( xResult == pdPASS )
+		{
+			// The message was posted successfully.
+		}
+  }
+   </pre>
+ * \defgroup xEventGroupClearBitsFromISR xEventGroupClearBitsFromISR
+ * \ingroup EventGroup
+ */
+#if( configUSE_TRACE_FACILITY == 1 )
+	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
+#else
+	#define xEventGroupClearBitsFromISR( xEventGroup, uxBitsToClear ) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )
+#endif
+
+/**
+ * event_groups.h
+ *<pre>
+	EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
+ </pre>
+ *
+ * Set bits within an event group.
+ * This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()
+ * is a version that can be called from an interrupt.
+ *
+ * Setting bits in an event group will automatically unblock tasks that are
+ * blocked waiting for the bits.
+ *
+ * @param xEventGroup The event group in which the bits are to be set.
+ *
+ * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
+ * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
+ * and bit 0 set uxBitsToSet to 0x09.
+ *
+ * @return The value of the event group at the time the call to
+ * xEventGroupSetBits() returns.  There are two reasons why the returned value
+ * might have the bits specified by the uxBitsToSet parameter cleared.  First,
+ * if setting a bit results in a task that was waiting for the bit leaving the
+ * blocked state then it is possible the bit will be cleared automatically
+ * (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any
+ * unblocked (or otherwise Ready state) task that has a priority above that of
+ * the task that called xEventGroupSetBits() will execute and may change the
+ * event group value before the call to xEventGroupSetBits() returns.
+ *
+ * Example usage:
+   <pre>
+   #define BIT_0	( 1 << 0 )
+   #define BIT_4	( 1 << 4 )
+
+   void aFunction( EventGroupHandle_t xEventGroup )
+   {
+   EventBits_t uxBits;
+
+		// Set bit 0 and bit 4 in xEventGroup.
+		uxBits = xEventGroupSetBits(
+							xEventGroup,	// The event group being updated.
+							BIT_0 | BIT_4 );// The bits being set.
+
+		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
+		{
+			// Both bit 0 and bit 4 remained set when the function returned.
+		}
+		else if( ( uxBits & BIT_0 ) != 0 )
+		{
+			// Bit 0 remained set when the function returned, but bit 4 was
+			// cleared.  It might be that bit 4 was cleared automatically as a
+			// task that was waiting for bit 4 was removed from the Blocked
+			// state.
+		}
+		else if( ( uxBits & BIT_4 ) != 0 )
+		{
+			// Bit 4 remained set when the function returned, but bit 0 was
+			// cleared.  It might be that bit 0 was cleared automatically as a
+			// task that was waiting for bit 0 was removed from the Blocked
+			// state.
+		}
+		else
+		{
+			// Neither bit 0 nor bit 4 remained set.  It might be that a task
+			// was waiting for both of the bits to be set, and the bits were
+			// cleared as the task left the Blocked state.
+		}
+   }
+   </pre>
+ * \defgroup xEventGroupSetBits xEventGroupSetBits
+ * \ingroup EventGroup
+ */
+EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
+
+/**
+ * event_groups.h
+ *<pre>
+	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );
+ </pre>
+ *
+ * A version of xEventGroupSetBits() that can be called from an interrupt.
+ *
+ * Setting bits in an event group is not a deterministic operation because there
+ * are an unknown number of tasks that may be waiting for the bit or bits being
+ * set.  FreeRTOS does not allow nondeterministic operations to be performed in
+ * interrupts or from critical sections.  Therefore xEventGroupSetBitsFromISR()
+ * sends a message to the timer task to have the set operation performed in the
+ * context of the timer task - where a scheduler lock is used in place of a
+ * critical section.
+ *
+ * @param xEventGroup The event group in which the bits are to be set.
+ *
+ * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
+ * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
+ * and bit 0 set uxBitsToSet to 0x09.
+ *
+ * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
+ * will result in a message being sent to the timer daemon task.  If the
+ * priority of the timer daemon task is higher than the priority of the
+ * currently running task (the task the interrupt interrupted) then
+ * *pxHigherPriorityTaskWoken will be set to pdTRUE by
+ * xEventGroupSetBitsFromISR(), indicating that a context switch should be
+ * requested before the interrupt exits.  For that reason
+ * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
+ * example code below.
+ *
+ * @return If the request to execute the function was posted successfully then
+ * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned
+ * if the timer service queue was full.
+ *
+ * Example usage:
+   <pre>
+   #define BIT_0	( 1 << 0 )
+   #define BIT_4	( 1 << 4 )
+
+   // An event group which it is assumed has already been created by a call to
+   // xEventGroupCreate().
+   EventGroupHandle_t xEventGroup;
+
+   void anInterruptHandler( void )
+   {
+   BaseType_t xHigherPriorityTaskWoken, xResult;
+
+		// xHigherPriorityTaskWoken must be initialised to pdFALSE.
+		xHigherPriorityTaskWoken = pdFALSE;
+
+		// Set bit 0 and bit 4 in xEventGroup.
+		xResult = xEventGroupSetBitsFromISR(
+							xEventGroup,	// The event group being updated.
+							BIT_0 | BIT_4   // The bits being set.
+							&xHigherPriorityTaskWoken );
+
+		// Was the message posted successfully?
+		if( xResult == pdPASS )
+		{
+			// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
+			// switch should be requested.  The macro used is port specific and
+			// will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
+			// refer to the documentation page for the port being used.
+			portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+		}
+  }
+   </pre>
+ * \defgroup xEventGroupSetBitsFromISR xEventGroupSetBitsFromISR
+ * \ingroup EventGroup
+ */
+#if( configUSE_TRACE_FACILITY == 1 )
+	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+#else
+	#define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )
+#endif
+
+/**
+ * event_groups.h
+ *<pre>
+	EventBits_t xEventGroupSync(	EventGroupHandle_t xEventGroup,
+									const EventBits_t uxBitsToSet,
+									const EventBits_t uxBitsToWaitFor,
+									TickType_t xTicksToWait );
+ </pre>
+ *
+ * Atomically set bits within an event group, then wait for a combination of
+ * bits to be set within the same event group.  This functionality is typically
+ * used to synchronise multiple tasks, where each task has to wait for the other
+ * tasks to reach a synchronisation point before proceeding.
+ *
+ * This function cannot be used from an interrupt.
+ *
+ * The function will return before its block time expires if the bits specified
+ * by the uxBitsToWait parameter are set, or become set within that time.  In
+ * this case all the bits specified by uxBitsToWait will be automatically
+ * cleared before the function returns.
+ *
+ * @param xEventGroup The event group in which the bits are being tested.  The
+ * event group must have previously been created using a call to
+ * xEventGroupCreate().
+ *
+ * @param uxBitsToSet The bits to set in the event group before determining
+ * if, and possibly waiting for, all the bits specified by the uxBitsToWait
+ * parameter are set.
+ *
+ * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
+ * inside the event group.  For example, to wait for bit 0 and bit 2 set
+ * uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set
+ * uxBitsToWaitFor to 0x07.  Etc.
+ *
+ * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
+ * for all of the bits specified by uxBitsToWaitFor to become set.
+ *
+ * @return The value of the event group at the time either the bits being waited
+ * for became set, or the block time expired.  Test the return value to know
+ * which bits were set.  If xEventGroupSync() returned because its timeout
+ * expired then not all the bits being waited for will be set.  If
+ * xEventGroupSync() returned because all the bits it was waiting for were
+ * set then the returned value is the event group value before any bits were
+ * automatically cleared.
+ *
+ * Example usage:
+ <pre>
+ // Bits used by the three tasks.
+ #define TASK_0_BIT		( 1 << 0 )
+ #define TASK_1_BIT		( 1 << 1 )
+ #define TASK_2_BIT		( 1 << 2 )
+
+ #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )
+
+ // Use an event group to synchronise three tasks.  It is assumed this event
+ // group has already been created elsewhere.
+ EventGroupHandle_t xEventBits;
+
+ void vTask0( void *pvParameters )
+ {
+ EventBits_t uxReturn;
+ TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
+
+	 for( ;; )
+	 {
+		// Perform task functionality here.
+
+		// Set bit 0 in the event flag to note this task has reached the
+		// sync point.  The other two tasks will set the other two bits defined
+		// by ALL_SYNC_BITS.  All three tasks have reached the synchronisation
+		// point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms
+		// for this to happen.
+		uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );
+
+		if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )
+		{
+			// All three tasks reached the synchronisation point before the call
+			// to xEventGroupSync() timed out.
+		}
+	}
+ }
+
+ void vTask1( void *pvParameters )
+ {
+	 for( ;; )
+	 {
+		// Perform task functionality here.
+
+		// Set bit 1 in the event flag to note this task has reached the
+		// synchronisation point.  The other two tasks will set the other two
+		// bits defined by ALL_SYNC_BITS.  All three tasks have reached the
+		// synchronisation point when all the ALL_SYNC_BITS are set.  Wait
+		// indefinitely for this to happen.
+		xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );
+
+		// xEventGroupSync() was called with an indefinite block time, so
+		// this task will only reach here if the syncrhonisation was made by all
+		// three tasks, so there is no need to test the return value.
+	 }
+ }
+
+ void vTask2( void *pvParameters )
+ {
+	 for( ;; )
+	 {
+		// Perform task functionality here.
+
+		// Set bit 2 in the event flag to note this task has reached the
+		// synchronisation point.  The other two tasks will set the other two
+		// bits defined by ALL_SYNC_BITS.  All three tasks have reached the
+		// synchronisation point when all the ALL_SYNC_BITS are set.  Wait
+		// indefinitely for this to happen.
+		xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );
+
+		// xEventGroupSync() was called with an indefinite block time, so
+		// this task will only reach here if the syncrhonisation was made by all
+		// three tasks, so there is no need to test the return value.
+	}
+ }
+
+ </pre>
+ * \defgroup xEventGroupSync xEventGroupSync
+ * \ingroup EventGroup
+ */
+EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+
+/**
+ * event_groups.h
+ *<pre>
+	EventBits_t xEventGroupGetBits( EventGroupHandle_t xEventGroup );
+ </pre>
+ *
+ * Returns the current value of the bits in an event group.  This function
+ * cannot be used from an interrupt.
+ *
+ * @param xEventGroup The event group being queried.
+ *
+ * @return The event group bits at the time xEventGroupGetBits() was called.
+ *
+ * \defgroup xEventGroupGetBits xEventGroupGetBits
+ * \ingroup EventGroup
+ */
+#define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 )
+
+/**
+ * event_groups.h
+ *<pre>
+	EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup );
+ </pre>
+ *
+ * A version of xEventGroupGetBits() that can be called from an ISR.
+ *
+ * @param xEventGroup The event group being queried.
+ *
+ * @return The event group bits at the time xEventGroupGetBitsFromISR() was called.
+ *
+ * \defgroup xEventGroupGetBitsFromISR xEventGroupGetBitsFromISR
+ * \ingroup EventGroup
+ */
+EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
+
+/**
+ * event_groups.h
+ *<pre>
+	void xEventGroupDelete( EventGroupHandle_t xEventGroup );
+ </pre>
+ *
+ * Delete an event group that was previously created by a call to
+ * xEventGroupCreate().  Tasks that are blocked on the event group will be
+ * unblocked and obtain 0 as the event group's value.
+ *
+ * @param xEventGroup The event group being deleted.
+ */
+void vEventGroupDelete( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
+
+/* For internal use only. */
+void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) PRIVILEGED_FUNCTION;
+void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;
+
+
+#if (configUSE_TRACE_FACILITY == 1)
+	UBaseType_t uxEventGroupGetNumber( void* xEventGroup ) PRIVILEGED_FUNCTION;
+	void vEventGroupSetNumber( void* xEventGroup, UBaseType_t uxEventGroupNumber ) PRIVILEGED_FUNCTION;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT_GROUPS_H */
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/FreeRTOS.h ./libs/freertos/include/FreeRTOS.h
--- a_bRU7kv/libs/freertos/include/FreeRTOS.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/FreeRTOS.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,1168 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef INC_FREERTOS_H
+#define INC_FREERTOS_H
+
+/*
+ * Include the generic headers required for the FreeRTOS port being used.
+ */
+#include <stddef.h>
+
+/*
+ * If stdint.h cannot be located then:
+ *   + If using GCC ensure the -nostdint options is *not* being used.
+ *   + Ensure the project's include path includes the directory in which your
+ *     compiler stores stdint.h.
+ *   + Set any compiler options necessary for it to support C99, as technically
+ *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
+ *     other way).
+ *   + The FreeRTOS download includes a simple stdint.h definition that can be
+ *     used in cases where none is provided by the compiler.  The files only
+ *     contains the typedefs required to build FreeRTOS.  Read the instructions
+ *     in FreeRTOS/source/stdint.readme for more information.
+ */
+#include <stdint.h> /* READ COMMENT ABOVE. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Application specific configuration options. */
+#include "FreeRTOSConfig.h"
+
+/* Basic FreeRTOS definitions. */
+#include "projdefs.h"
+
+/* Definitions specific to the port being used. */
+#include "portable.h"
+
+/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
+#ifndef configUSE_NEWLIB_REENTRANT
+	#define configUSE_NEWLIB_REENTRANT 0
+#endif
+
+/* Required if struct _reent is used. */
+#if ( configUSE_NEWLIB_REENTRANT == 1 )
+	#include <reent.h>
+#endif
+/*
+ * Check all the required application specific macros have been defined.
+ * These macros are application specific and (as downloaded) are defined
+ * within FreeRTOSConfig.h.
+ */
+
+#ifndef configMINIMAL_STACK_SIZE
+	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
+#endif
+
+#ifndef configMAX_PRIORITIES
+	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#if configMAX_PRIORITIES < 1
+	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
+#endif
+
+#ifndef configUSE_PREEMPTION
+	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_IDLE_HOOK
+	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_TICK_HOOK
+	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_16_BIT_TICKS
+	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_CO_ROUTINES
+	#define configUSE_CO_ROUTINES 0
+#endif
+
+#ifndef INCLUDE_vTaskPrioritySet
+	#define INCLUDE_vTaskPrioritySet 0
+#endif
+
+#ifndef INCLUDE_uxTaskPriorityGet
+	#define INCLUDE_uxTaskPriorityGet 0
+#endif
+
+#ifndef INCLUDE_vTaskDelete
+	#define INCLUDE_vTaskDelete 0
+#endif
+
+#ifndef INCLUDE_vTaskSuspend
+	#define INCLUDE_vTaskSuspend 0
+#endif
+
+#ifndef INCLUDE_vTaskDelayUntil
+	#define INCLUDE_vTaskDelayUntil 0
+#endif
+
+#ifndef INCLUDE_vTaskDelay
+	#define INCLUDE_vTaskDelay 0
+#endif
+
+#ifndef INCLUDE_xTaskGetIdleTaskHandle
+	#define INCLUDE_xTaskGetIdleTaskHandle 0
+#endif
+
+#ifndef INCLUDE_xTaskAbortDelay
+	#define INCLUDE_xTaskAbortDelay 0
+#endif
+
+#ifndef INCLUDE_xQueueGetMutexHolder
+	#define INCLUDE_xQueueGetMutexHolder 0
+#endif
+
+#ifndef INCLUDE_xSemaphoreGetMutexHolder
+	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
+#endif
+
+#ifndef INCLUDE_xTaskGetHandle
+	#define INCLUDE_xTaskGetHandle 0
+#endif
+
+#ifndef INCLUDE_uxTaskGetStackHighWaterMark
+	#define INCLUDE_uxTaskGetStackHighWaterMark 0
+#endif
+
+#ifndef INCLUDE_eTaskGetState
+	#define INCLUDE_eTaskGetState 0
+#endif
+
+#ifndef INCLUDE_xTaskResumeFromISR
+	#define INCLUDE_xTaskResumeFromISR 1
+#endif
+
+#ifndef INCLUDE_xTimerPendFunctionCall
+	#define INCLUDE_xTimerPendFunctionCall 0
+#endif
+
+#ifndef INCLUDE_xTaskGetSchedulerState
+	#define INCLUDE_xTaskGetSchedulerState 0
+#endif
+
+#ifndef INCLUDE_xTaskGetCurrentTaskHandle
+	#define INCLUDE_xTaskGetCurrentTaskHandle 0
+#endif
+
+#if configUSE_CO_ROUTINES != 0
+	#ifndef configMAX_CO_ROUTINE_PRIORITIES
+		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
+	#endif
+#endif
+
+#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
+	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
+#endif
+
+#ifndef configUSE_APPLICATION_TASK_TAG
+	#define configUSE_APPLICATION_TASK_TAG 0
+#endif
+
+#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
+	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
+#endif
+
+#ifndef configUSE_RECURSIVE_MUTEXES
+	#define configUSE_RECURSIVE_MUTEXES 0
+#endif
+
+#ifndef configUSE_MUTEXES
+	#define configUSE_MUTEXES 0
+#endif
+
+#ifndef configUSE_TIMERS
+	#define configUSE_TIMERS 0
+#endif
+
+#ifndef configUSE_COUNTING_SEMAPHORES
+	#define configUSE_COUNTING_SEMAPHORES 0
+#endif
+
+#ifndef configUSE_ALTERNATIVE_API
+	#define configUSE_ALTERNATIVE_API 0
+#endif
+
+#ifndef portCRITICAL_NESTING_IN_TCB
+	#define portCRITICAL_NESTING_IN_TCB 0
+#endif
+
+#ifndef configMAX_TASK_NAME_LEN
+	#define configMAX_TASK_NAME_LEN 16
+#endif
+
+#ifndef configIDLE_SHOULD_YIELD
+	#define configIDLE_SHOULD_YIELD		1
+#endif
+
+#if configMAX_TASK_NAME_LEN < 1
+	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
+#endif
+
+#ifndef configASSERT
+	#define configASSERT( x )
+	#define configASSERT_DEFINED 0
+#else
+	#define configASSERT_DEFINED 1
+#endif
+
+/* The timers module relies on xTaskGetSchedulerState(). */
+#if configUSE_TIMERS == 1
+
+	#ifndef configTIMER_TASK_PRIORITY
+		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
+	#endif /* configTIMER_TASK_PRIORITY */
+
+	#ifndef configTIMER_QUEUE_LENGTH
+		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
+	#endif /* configTIMER_QUEUE_LENGTH */
+
+	#ifndef configTIMER_TASK_STACK_DEPTH
+		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
+	#endif /* configTIMER_TASK_STACK_DEPTH */
+
+#endif /* configUSE_TIMERS */
+
+#ifndef portSET_INTERRUPT_MASK_FROM_ISR
+	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
+#endif
+
+#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
+	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
+#endif
+
+#ifndef portCLEAN_UP_TCB
+	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
+#endif
+
+#ifndef portPRE_TASK_DELETE_HOOK
+	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
+#endif
+
+#ifndef portSETUP_TCB
+	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
+#endif
+
+#ifndef configQUEUE_REGISTRY_SIZE
+	#define configQUEUE_REGISTRY_SIZE 0U
+#endif
+
+#if ( configQUEUE_REGISTRY_SIZE < 1 )
+	#define vQueueAddToRegistry( xQueue, pcName )
+	#define vQueueUnregisterQueue( xQueue )
+	#define pcQueueGetName( xQueue )
+#endif
+
+#ifndef portPOINTER_SIZE_TYPE
+	#define portPOINTER_SIZE_TYPE uint32_t
+#endif
+
+/* Remove any unused trace macros. */
+#ifndef traceSTART
+	/* Used to perform any necessary initialisation - for example, open a file
+	into which trace is to be written. */
+	#define traceSTART()
+#endif
+
+#ifndef traceEND
+	/* Use to close a trace, for example close a file into which trace has been
+	written. */
+	#define traceEND()
+#endif
+
+#ifndef traceTASK_SWITCHED_IN
+	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
+	to the task control block of the selected task. */
+	#define traceTASK_SWITCHED_IN()
+#endif
+
+#ifndef traceINCREASE_TICK_COUNT
+	/* Called before stepping the tick count after waking from tickless idle
+	sleep. */
+	#define traceINCREASE_TICK_COUNT( x )
+#endif
+
+#ifndef traceLOW_POWER_IDLE_BEGIN
+	/* Called immediately before entering tickless idle. */
+	#define traceLOW_POWER_IDLE_BEGIN()
+#endif
+
+#ifndef	traceLOW_POWER_IDLE_END
+	/* Called when returning to the Idle task after a tickless idle. */
+	#define traceLOW_POWER_IDLE_END()
+#endif
+
+#ifndef traceTASK_SWITCHED_OUT
+	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
+	to the task control block of the task being switched out. */
+	#define traceTASK_SWITCHED_OUT()
+#endif
+
+#ifndef traceTASK_PRIORITY_INHERIT
+	/* Called when a task attempts to take a mutex that is already held by a
+	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
+	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
+	will inherit (the priority of the task that is attempting to obtain the
+	muted. */
+	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
+#endif
+
+#ifndef traceTASK_PRIORITY_DISINHERIT
+	/* Called when a task releases a mutex, the holding of which had resulted in
+	the task inheriting the priority of a higher priority task.
+	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
+	mutex.  uxOriginalPriority is the task's configured (base) priority. */
+	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
+#endif
+
+#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
+	/* Task is about to block because it cannot read from a
+	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
+	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
+	task that attempted the read. */
+	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
+#endif
+
+#ifndef traceBLOCKING_ON_QUEUE_PEEK
+	/* Task is about to block because it cannot read from a
+	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
+	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
+	task that attempted the read. */
+	#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )
+#endif
+
+#ifndef traceBLOCKING_ON_QUEUE_SEND
+	/* Task is about to block because it cannot write to a
+	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
+	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
+	task that attempted the write. */
+	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
+#endif
+
+#ifndef configCHECK_FOR_STACK_OVERFLOW
+	#define configCHECK_FOR_STACK_OVERFLOW 0
+#endif
+
+#ifndef configRECORD_STACK_HIGH_ADDRESS
+	#define configRECORD_STACK_HIGH_ADDRESS 0
+#endif
+
+#ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H
+	#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
+#endif
+
+/* The following event macros are embedded in the kernel API calls. */
+
+#ifndef traceMOVED_TASK_TO_READY_STATE
+	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
+#endif
+
+#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
+	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
+#endif
+
+#ifndef traceQUEUE_CREATE
+	#define traceQUEUE_CREATE( pxNewQueue )
+#endif
+
+#ifndef traceQUEUE_CREATE_FAILED
+	#define traceQUEUE_CREATE_FAILED( ucQueueType )
+#endif
+
+#ifndef traceCREATE_MUTEX
+	#define traceCREATE_MUTEX( pxNewQueue )
+#endif
+
+#ifndef traceCREATE_MUTEX_FAILED
+	#define traceCREATE_MUTEX_FAILED()
+#endif
+
+#ifndef traceGIVE_MUTEX_RECURSIVE
+	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
+#endif
+
+#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
+	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
+#endif
+
+#ifndef traceTAKE_MUTEX_RECURSIVE
+	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
+#endif
+
+#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
+	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
+#endif
+
+#ifndef traceCREATE_COUNTING_SEMAPHORE
+	#define traceCREATE_COUNTING_SEMAPHORE()
+#endif
+
+#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
+	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
+#endif
+
+#ifndef traceQUEUE_SEND
+	#define traceQUEUE_SEND( pxQueue )
+#endif
+
+#ifndef traceQUEUE_SEND_FAILED
+	#define traceQUEUE_SEND_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE
+	#define traceQUEUE_RECEIVE( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK
+	#define traceQUEUE_PEEK( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK_FAILED
+	#define traceQUEUE_PEEK_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK_FROM_ISR
+	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE_FAILED
+	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_SEND_FROM_ISR
+	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
+#endif
+
+#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
+	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE_FROM_ISR
+	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
+	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
+	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_DELETE
+	#define traceQUEUE_DELETE( pxQueue )
+#endif
+
+#ifndef traceTASK_CREATE
+	#define traceTASK_CREATE( pxNewTCB )
+#endif
+
+#ifndef traceTASK_CREATE_FAILED
+	#define traceTASK_CREATE_FAILED()
+#endif
+
+#ifndef traceTASK_DELETE
+	#define traceTASK_DELETE( pxTaskToDelete )
+#endif
+
+#ifndef traceTASK_DELAY_UNTIL
+	#define traceTASK_DELAY_UNTIL( x )
+#endif
+
+#ifndef traceTASK_DELAY
+	#define traceTASK_DELAY()
+#endif
+
+#ifndef traceTASK_PRIORITY_SET
+	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
+#endif
+
+#ifndef traceTASK_SUSPEND
+	#define traceTASK_SUSPEND( pxTaskToSuspend )
+#endif
+
+#ifndef traceTASK_RESUME
+	#define traceTASK_RESUME( pxTaskToResume )
+#endif
+
+#ifndef traceTASK_RESUME_FROM_ISR
+	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
+#endif
+
+#ifndef traceTASK_INCREMENT_TICK
+	#define traceTASK_INCREMENT_TICK( xTickCount )
+#endif
+
+#ifndef traceTIMER_CREATE
+	#define traceTIMER_CREATE( pxNewTimer )
+#endif
+
+#ifndef traceTIMER_CREATE_FAILED
+	#define traceTIMER_CREATE_FAILED()
+#endif
+
+#ifndef traceTIMER_COMMAND_SEND
+	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
+#endif
+
+#ifndef traceTIMER_EXPIRED
+	#define traceTIMER_EXPIRED( pxTimer )
+#endif
+
+#ifndef traceTIMER_COMMAND_RECEIVED
+	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
+#endif
+
+#ifndef traceMALLOC
+    #define traceMALLOC( pvAddress, uiSize )
+#endif
+
+#ifndef traceFREE
+    #define traceFREE( pvAddress, uiSize )
+#endif
+
+#ifndef traceEVENT_GROUP_CREATE
+	#define traceEVENT_GROUP_CREATE( xEventGroup )
+#endif
+
+#ifndef traceEVENT_GROUP_CREATE_FAILED
+	#define traceEVENT_GROUP_CREATE_FAILED()
+#endif
+
+#ifndef traceEVENT_GROUP_SYNC_BLOCK
+	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
+#endif
+
+#ifndef traceEVENT_GROUP_SYNC_END
+	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
+#endif
+
+#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
+	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
+#endif
+
+#ifndef traceEVENT_GROUP_WAIT_BITS_END
+	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
+#endif
+
+#ifndef traceEVENT_GROUP_CLEAR_BITS
+	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
+#endif
+
+#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
+	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
+#endif
+
+#ifndef traceEVENT_GROUP_SET_BITS
+	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
+#endif
+
+#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
+	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
+#endif
+
+#ifndef traceEVENT_GROUP_DELETE
+	#define traceEVENT_GROUP_DELETE( xEventGroup )
+#endif
+
+#ifndef tracePEND_FUNC_CALL
+	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
+#endif
+
+#ifndef tracePEND_FUNC_CALL_FROM_ISR
+	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
+#endif
+
+#ifndef traceQUEUE_REGISTRY_ADD
+	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
+#endif
+
+#ifndef traceTASK_NOTIFY_TAKE_BLOCK
+	#define traceTASK_NOTIFY_TAKE_BLOCK()
+#endif
+
+#ifndef traceTASK_NOTIFY_TAKE
+	#define traceTASK_NOTIFY_TAKE()
+#endif
+
+#ifndef traceTASK_NOTIFY_WAIT_BLOCK
+	#define traceTASK_NOTIFY_WAIT_BLOCK()
+#endif
+
+#ifndef traceTASK_NOTIFY_WAIT
+	#define traceTASK_NOTIFY_WAIT()
+#endif
+
+#ifndef traceTASK_NOTIFY
+	#define traceTASK_NOTIFY()
+#endif
+
+#ifndef traceTASK_NOTIFY_FROM_ISR
+	#define traceTASK_NOTIFY_FROM_ISR()
+#endif
+
+#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
+	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
+#endif
+
+#ifndef traceSTREAM_BUFFER_CREATE_FAILED
+	#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED
+	#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_CREATE
+	#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_DELETE
+	#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RESET
+	#define traceSTREAM_BUFFER_RESET( xStreamBuffer )
+#endif
+
+#ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND
+	#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_SEND
+	#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )
+#endif
+
+#ifndef traceSTREAM_BUFFER_SEND_FAILED
+	#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_SEND_FROM_ISR
+	#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )
+#endif
+
+#ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE
+	#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RECEIVE
+	#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RECEIVE_FAILED
+	#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR
+	#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )
+#endif
+
+#ifndef configGENERATE_RUN_TIME_STATS
+	#define configGENERATE_RUN_TIME_STATS 0
+#endif
+
+#if ( configGENERATE_RUN_TIME_STATS == 1 )
+
+	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
+		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
+	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
+
+	#ifndef portGET_RUN_TIME_COUNTER_VALUE
+		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
+			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
+		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
+	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
+
+#endif /* configGENERATE_RUN_TIME_STATS */
+
+#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
+	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
+#endif
+
+#ifndef configUSE_MALLOC_FAILED_HOOK
+	#define configUSE_MALLOC_FAILED_HOOK 0
+#endif
+
+#ifndef portPRIVILEGE_BIT
+	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
+#endif
+
+#ifndef portYIELD_WITHIN_API
+	#define portYIELD_WITHIN_API portYIELD
+#endif
+
+#ifndef portSUPPRESS_TICKS_AND_SLEEP
+	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
+#endif
+
+#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
+	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
+#endif
+
+#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
+	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
+#endif
+
+#ifndef configUSE_TICKLESS_IDLE
+	#define configUSE_TICKLESS_IDLE 0
+#endif
+
+#ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING
+	#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )
+#endif
+
+#ifndef configPRE_SLEEP_PROCESSING
+	#define configPRE_SLEEP_PROCESSING( x )
+#endif
+
+#ifndef configPOST_SLEEP_PROCESSING
+	#define configPOST_SLEEP_PROCESSING( x )
+#endif
+
+#ifndef configUSE_QUEUE_SETS
+	#define configUSE_QUEUE_SETS 0
+#endif
+
+#ifndef portTASK_USES_FLOATING_POINT
+	#define portTASK_USES_FLOATING_POINT()
+#endif
+
+#ifndef portTASK_CALLS_SECURE_FUNCTIONS
+	#define portTASK_CALLS_SECURE_FUNCTIONS()
+#endif
+
+#ifndef configUSE_TIME_SLICING
+	#define configUSE_TIME_SLICING 1
+#endif
+
+#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
+	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
+#endif
+
+#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
+	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
+#endif
+
+#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
+	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
+#endif
+
+#ifndef configUSE_TRACE_FACILITY
+	#define configUSE_TRACE_FACILITY 0
+#endif
+
+#ifndef mtCOVERAGE_TEST_MARKER
+	#define mtCOVERAGE_TEST_MARKER()
+#endif
+
+#ifndef mtCOVERAGE_TEST_DELAY
+	#define mtCOVERAGE_TEST_DELAY()
+#endif
+
+#ifndef portASSERT_IF_IN_ISR
+	#define portASSERT_IF_IN_ISR()
+#endif
+
+#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
+	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
+#endif
+
+#ifndef configAPPLICATION_ALLOCATED_HEAP
+	#define configAPPLICATION_ALLOCATED_HEAP 0
+#endif
+
+#ifndef configUSE_TASK_NOTIFICATIONS
+	#define configUSE_TASK_NOTIFICATIONS 1
+#endif
+
+#ifndef portTICK_TYPE_IS_ATOMIC
+	#define portTICK_TYPE_IS_ATOMIC 0
+#endif
+
+#ifndef configSUPPORT_STATIC_ALLOCATION
+	/* Defaults to 0 for backward compatibility. */
+	#define configSUPPORT_STATIC_ALLOCATION 0
+#endif
+
+#ifndef configSUPPORT_DYNAMIC_ALLOCATION
+	/* Defaults to 1 for backward compatibility. */
+	#define configSUPPORT_DYNAMIC_ALLOCATION 1
+#endif
+
+#ifndef configSTACK_DEPTH_TYPE
+	/* Defaults to uint16_t for backward compatibility, but can be overridden
+	in FreeRTOSConfig.h if uint16_t is too restrictive. */
+	#define configSTACK_DEPTH_TYPE uint16_t
+#endif
+
+/* Sanity check the configuration. */
+#if( configUSE_TICKLESS_IDLE != 0 )
+	#if( INCLUDE_vTaskSuspend != 1 )
+		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
+	#endif /* INCLUDE_vTaskSuspend */
+#endif /* configUSE_TICKLESS_IDLE */
+
+#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
+	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
+#endif
+
+#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
+	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
+#endif
+
+#ifndef configINITIAL_TICK_COUNT
+	#define configINITIAL_TICK_COUNT 0
+#endif
+
+#if( portTICK_TYPE_IS_ATOMIC == 0 )
+	/* Either variables of tick type cannot be read atomically, or
+	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
+	the tick count is returned to the standard critical section macros. */
+	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
+	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
+	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
+	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
+#else
+	/* The tick type can be read atomically, so critical sections used when the
+	tick count is returned can be defined away. */
+	#define portTICK_TYPE_ENTER_CRITICAL()
+	#define portTICK_TYPE_EXIT_CRITICAL()
+	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
+	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
+#endif
+
+/* Definitions to allow backward compatibility with FreeRTOS versions prior to
+V8 if desired. */
+#ifndef configENABLE_BACKWARD_COMPATIBILITY
+	#define configENABLE_BACKWARD_COMPATIBILITY 1
+#endif
+
+#ifndef configPRINTF
+	/* configPRINTF() was not defined, so define it away to nothing.  To use
+	configPRINTF() then define it as follows (where MyPrintFunction() is
+	provided by the application writer):
+
+	void MyPrintFunction(const char *pcFormat, ... );
+	#define configPRINTF( X )   MyPrintFunction X
+
+	Then call like a standard printf() function, but placing brackets around
+	all parameters so they are passed as a single parameter.  For example:
+	configPRINTF( ("Value = %d", MyVariable) ); */
+	#define configPRINTF( X )
+#endif
+
+#ifndef configMAX
+	/* The application writer has not provided their own MAX macro, so define
+	the following generic implementation. */
+	#define configMAX( a, b ) ( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )
+#endif
+
+#ifndef configMIN
+	/* The application writer has not provided their own MAX macro, so define
+	the following generic implementation. */
+	#define configMIN( a, b ) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )
+#endif
+
+#if configENABLE_BACKWARD_COMPATIBILITY == 1
+	#define eTaskStateGet eTaskGetState
+	#define portTickType TickType_t
+	#define xTaskHandle TaskHandle_t
+	#define xQueueHandle QueueHandle_t
+	#define xSemaphoreHandle SemaphoreHandle_t
+	#define xQueueSetHandle QueueSetHandle_t
+	#define xQueueSetMemberHandle QueueSetMemberHandle_t
+	#define xTimeOutType TimeOut_t
+	#define xMemoryRegion MemoryRegion_t
+	#define xTaskParameters TaskParameters_t
+	#define xTaskStatusType	TaskStatus_t
+	#define xTimerHandle TimerHandle_t
+	#define xCoRoutineHandle CoRoutineHandle_t
+	#define pdTASK_HOOK_CODE TaskHookFunction_t
+	#define portTICK_RATE_MS portTICK_PERIOD_MS
+	#define pcTaskGetTaskName pcTaskGetName
+	#define pcTimerGetTimerName pcTimerGetName
+	#define pcQueueGetQueueName pcQueueGetName
+	#define vTaskGetTaskInfo vTaskGetInfo
+
+	/* Backward compatibility within the scheduler code only - these definitions
+	are not really required but are included for completeness. */
+	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
+	#define pdTASK_CODE TaskFunction_t
+	#define xListItem ListItem_t
+	#define xList List_t
+#endif /* configENABLE_BACKWARD_COMPATIBILITY */
+
+#if( configUSE_ALTERNATIVE_API != 0 )
+	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
+#endif
+
+/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
+if floating point hardware is otherwise supported by the FreeRTOS port in use.
+This constant is not supported by all FreeRTOS ports that include floating
+point support. */
+#ifndef configUSE_TASK_FPU_SUPPORT
+	#define configUSE_TASK_FPU_SUPPORT 1
+#endif
+
+/*
+ * In line with software engineering best practice, FreeRTOS implements a strict
+ * data hiding policy, so the real structures used by FreeRTOS to maintain the
+ * state of tasks, queues, semaphores, etc. are not accessible to the application
+ * code.  However, if the application writer wants to statically allocate such
+ * an object then the size of the object needs to be know.  Dummy structures
+ * that are guaranteed to have the same size and alignment requirements of the
+ * real objects are used for this purpose.  The dummy list and list item
+ * structures below are used for inclusion in such a dummy structure.
+ */
+struct xSTATIC_LIST_ITEM
+{
+	TickType_t xDummy1;
+	void *pvDummy2[ 4 ];
+};
+typedef struct xSTATIC_LIST_ITEM StaticListItem_t;
+
+/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
+struct xSTATIC_MINI_LIST_ITEM
+{
+	TickType_t xDummy1;
+	void *pvDummy2[ 2 ];
+};
+typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
+
+/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
+typedef struct xSTATIC_LIST
+{
+	UBaseType_t uxDummy1;
+	void *pvDummy2;
+	StaticMiniListItem_t xDummy3;
+} StaticList_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the Task structure used internally by
+ * FreeRTOS is not accessible to application code.  However, if the application
+ * writer wants to statically allocate the memory required to create a task then
+ * the size of the task object needs to be know.  The StaticTask_t structure
+ * below is provided for this purpose.  Its sizes and alignment requirements are
+ * guaranteed to match those of the genuine structure, no matter which
+ * architecture is being used, and no matter how the values in FreeRTOSConfig.h
+ * are set.  Its contents are somewhat obfuscated in the hope users will
+ * recognise that it would be unwise to make direct use of the structure members.
+ */
+typedef struct xSTATIC_TCB
+{
+	void				*pxDummy1;
+	#if ( portUSING_MPU_WRAPPERS == 1 )
+		xMPU_SETTINGS	xDummy2;
+	#endif
+	StaticListItem_t	xDummy3[ 2 ];
+	UBaseType_t			uxDummy5;
+	void				*pxDummy6;
+	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
+	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
+		void			*pxDummy8;
+	#endif
+	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
+		UBaseType_t		uxDummy9;
+	#endif
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t		uxDummy10[ 2 ];
+	#endif
+	#if ( configUSE_MUTEXES == 1 )
+		UBaseType_t		uxDummy12[ 2 ];
+	#endif
+	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+		void			*pxDummy14;
+	#endif
+	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
+		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
+	#endif
+	#if ( configGENERATE_RUN_TIME_STATS == 1 )
+		uint32_t		ulDummy16;
+	#endif
+	#if ( configUSE_NEWLIB_REENTRANT == 1 )
+		struct	_reent	xDummy17;
+	#endif
+	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
+		uint32_t 		ulDummy18;
+		uint8_t 		ucDummy19;
+	#endif
+	#if( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
+		uint8_t			uxDummy20;
+	#endif
+
+	#if( INCLUDE_xTaskAbortDelay == 1 )
+		uint8_t ucDummy21;
+	#endif
+
+} StaticTask_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the Queue structure used internally by
+ * FreeRTOS is not accessible to application code.  However, if the application
+ * writer wants to statically allocate the memory required to create a queue
+ * then the size of the queue object needs to be know.  The StaticQueue_t
+ * structure below is provided for this purpose.  Its sizes and alignment
+ * requirements are guaranteed to match those of the genuine structure, no
+ * matter which architecture is being used, and no matter how the values in
+ * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
+ * users will recognise that it would be unwise to make direct use of the
+ * structure members.
+ */
+typedef struct xSTATIC_QUEUE
+{
+	void *pvDummy1[ 3 ];
+
+	union
+	{
+		void *pvDummy2;
+		UBaseType_t uxDummy2;
+	} u;
+
+	StaticList_t xDummy3[ 2 ];
+	UBaseType_t uxDummy4[ 3 ];
+	uint8_t ucDummy5[ 2 ];
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t ucDummy6;
+	#endif
+
+	#if ( configUSE_QUEUE_SETS == 1 )
+		void *pvDummy7;
+	#endif
+
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxDummy8;
+		uint8_t ucDummy9;
+	#endif
+
+} StaticQueue_t;
+typedef StaticQueue_t StaticSemaphore_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the event group structure used
+ * internally by FreeRTOS is not accessible to application code.  However, if
+ * the application writer wants to statically allocate the memory required to
+ * create an event group then the size of the event group object needs to be
+ * know.  The StaticEventGroup_t structure below is provided for this purpose.
+ * Its sizes and alignment requirements are guaranteed to match those of the
+ * genuine structure, no matter which architecture is being used, and no matter
+ * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
+ * obfuscated in the hope users will recognise that it would be unwise to make
+ * direct use of the structure members.
+ */
+typedef struct xSTATIC_EVENT_GROUP
+{
+	TickType_t xDummy1;
+	StaticList_t xDummy2;
+
+	#if( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxDummy3;
+	#endif
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+			uint8_t ucDummy4;
+	#endif
+
+} StaticEventGroup_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the software timer structure used
+ * internally by FreeRTOS is not accessible to application code.  However, if
+ * the application writer wants to statically allocate the memory required to
+ * create a software timer then the size of the queue object needs to be know.
+ * The StaticTimer_t structure below is provided for this purpose.  Its sizes
+ * and alignment requirements are guaranteed to match those of the genuine
+ * structure, no matter which architecture is being used, and no matter how the
+ * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
+ * the hope users will recognise that it would be unwise to make direct use of
+ * the structure members.
+ */
+typedef struct xSTATIC_TIMER
+{
+	void				*pvDummy1;
+	StaticListItem_t	xDummy2;
+	TickType_t			xDummy3;
+	UBaseType_t			uxDummy4;
+	void 				*pvDummy5[ 2 ];
+	#if( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t		uxDummy6;
+	#endif
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t 		ucDummy7;
+	#endif
+
+} StaticTimer_t;
+
+/*
+* In line with software engineering best practice, especially when supplying a
+* library that is likely to change in future versions, FreeRTOS implements a
+* strict data hiding policy.  This means the stream buffer structure used
+* internally by FreeRTOS is not accessible to application code.  However, if
+* the application writer wants to statically allocate the memory required to
+* create a stream buffer then the size of the stream buffer object needs to be
+* know.  The StaticStreamBuffer_t structure below is provided for this purpose.
+* Its size and alignment requirements are guaranteed to match those of the
+* genuine structure, no matter which architecture is being used, and no matter
+* how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
+* obfuscated in the hope users will recognise that it would be unwise to make
+* direct use of the structure members.
+*/
+typedef struct xSTATIC_STREAM_BUFFER
+{
+	size_t uxDummy1[ 4 ];
+	void * pvDummy2[ 3 ];
+	uint8_t ucDummy3;
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxDummy4;
+	#endif
+} StaticStreamBuffer_t;
+
+/* Message buffers are built on stream buffers. */
+typedef StaticStreamBuffer_t StaticMessageBuffer_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INC_FREERTOS_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/message_buffer.h ./libs/freertos/include/message_buffer.h
--- a_bRU7kv/libs/freertos/include/message_buffer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/message_buffer.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,779 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+/*
+ * Message buffers build functionality on top of FreeRTOS stream buffers.
+ * Whereas stream buffers are used to send a continuous stream of data from one
+ * task or interrupt to another, message buffers are used to send variable
+ * length discrete messages from one task or interrupt to another.  Their
+ * implementation is light weight, making them particularly suited for interrupt
+ * to task and core to core communication scenarios.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xMessageBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xMessageBufferRead()) inside a critical section and set the receive
+ * timeout to 0.
+ *
+ * Message buffers hold variable length messages.  To enable that, when a
+ * message is written to the message buffer an additional sizeof( size_t ) bytes
+ * are also written to store the message's length (that happens internally, with
+ * the API function).  sizeof( size_t ) is typically 4 bytes on a 32-bit
+ * architecture, so writing a 10 byte message to a message buffer on a 32-bit
+ * architecture will actually reduce the available space in the message buffer
+ * by 14 bytes (10 byte are used by the message, and 4 bytes to hold the length
+ * of the message).
+ */
+
+#ifndef FREERTOS_MESSAGE_BUFFER_H
+#define FREERTOS_MESSAGE_BUFFER_H
+
+/* Message buffers are built onto of stream buffers. */
+#include "stream_buffer.h"
+
+#if defined( __cplusplus )
+extern "C" {
+#endif
+
+/**
+ * Type by which message buffers are referenced.  For example, a call to
+ * xMessageBufferCreate() returns an MessageBufferHandle_t variable that can
+ * then be used as a parameter to xMessageBufferSend(), xMessageBufferReceive(),
+ * etc.
+ */
+typedef void * MessageBufferHandle_t;
+
+/*-----------------------------------------------------------*/
+
+/**
+ * message_buffer.h
+ *
+<pre>
+MessageBufferHandle_t xMessageBufferCreate( size_t xBufferSizeBytes );
+</pre>
+ *
+ * Creates a new message buffer using dynamically allocated memory.  See
+ * xMessageBufferCreateStatic() for a version that uses statically allocated
+ * memory (memory that is allocated at compile time).
+ *
+ * configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in
+ * FreeRTOSConfig.h for xMessageBufferCreate() to be available.
+ *
+ * @param xBufferSizeBytes The total number of bytes (not messages) the message
+ * buffer will be able to hold at any one time.  When a message is written to
+ * the message buffer an additional sizeof( size_t ) bytes are also written to
+ * store the message's length.  sizeof( size_t ) is typically 4 bytes on a
+ * 32-bit architecture, so on most 32-bit architectures a 10 byte message will
+ * take up 14 bytes of message buffer space.
+ *
+ * @return If NULL is returned, then the message buffer cannot be created
+ * because there is insufficient heap memory available for FreeRTOS to allocate
+ * the message buffer data structures and storage area.  A non-NULL value being
+ * returned indicates that the message buffer has been created successfully -
+ * the returned value should be stored as the handle to the created message
+ * buffer.
+ *
+ * Example use:
+<pre>
+
+void vAFunction( void )
+{
+MessageBufferHandle_t xMessageBuffer;
+const size_t xMessageBufferSizeBytes = 100;
+
+    // Create a message buffer that can hold 100 bytes.  The memory used to hold
+    // both the message buffer structure and the messages themselves is allocated
+    // dynamically.  Each message added to the buffer consumes an additional 4
+    // bytes which are used to hold the lengh of the message.
+    xMessageBuffer = xMessageBufferCreate( xMessageBufferSizeBytes );
+
+    if( xMessageBuffer == NULL )
+    {
+        // There was not enough heap memory space available to create the
+        // message buffer.
+    }
+    else
+    {
+        // The message buffer was created successfully and can now be used.
+    }
+
+</pre>
+ * \defgroup xMessageBufferCreate xMessageBufferCreate
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferCreate( xBufferSizeBytes ) ( MessageBufferHandle_t ) xStreamBufferGenericCreate( xBufferSizeBytes, ( size_t ) 0, pdTRUE )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+MessageBufferHandle_t xMessageBufferCreateStatic( size_t xBufferSizeBytes,
+                                                  uint8_t *pucMessageBufferStorageArea,
+                                                  StaticMessageBuffer_t *pxStaticMessageBuffer );
+</pre>
+ * Creates a new message buffer using statically allocated memory.  See
+ * xMessageBufferCreate() for a version that uses dynamically allocated memory.
+ *
+ * @param xBufferSizeBytes The size, in bytes, of the buffer pointed to by the
+ * pucMessageBufferStorageArea parameter.  When a message is written to the
+ * message buffer an additional sizeof( size_t ) bytes are also written to store
+ * the message's length.  sizeof( size_t ) is typically 4 bytes on a 32-bit
+ * architecture, so on most 32-bit architecture a 10 byte message will take up
+ * 14 bytes of message buffer space.  The maximum number of bytes that can be
+ * stored in the message buffer is actually (xBufferSizeBytes - 1).
+ *
+ * @param pucMessageBufferStorageArea Must point to a uint8_t array that is at
+ * least xBufferSizeBytes + 1 big.  This is the array to which messages are
+ * copied when they are written to the message buffer.
+ *
+ * @param pxStaticMessageBuffer Must point to a variable of type
+ * StaticMessageBuffer_t, which will be used to hold the message buffer's data
+ * structure.
+ *
+ * @return If the message buffer is created successfully then a handle to the
+ * created message buffer is returned. If either pucMessageBufferStorageArea or
+ * pxStaticmessageBuffer are NULL then NULL is returned.
+ *
+ * Example use:
+<pre>
+
+// Used to dimension the array used to hold the messages.  The available space
+// will actually be one less than this, so 999.
+#define STORAGE_SIZE_BYTES 1000
+
+// Defines the memory that will actually hold the messages within the message
+// buffer.
+static uint8_t ucStorageBuffer[ STORAGE_SIZE_BYTES ];
+
+// The variable used to hold the message buffer structure.
+StaticMessageBuffer_t xMessageBufferStruct;
+
+void MyFunction( void )
+{
+MessageBufferHandle_t xMessageBuffer;
+
+    xMessageBuffer = xMessageBufferCreateStatic( sizeof( ucBufferStorage ),
+                                                 ucBufferStorage,
+                                                 &xMessageBufferStruct );
+
+    // As neither the pucMessageBufferStorageArea or pxStaticMessageBuffer
+    // parameters were NULL, xMessageBuffer will not be NULL, and can be used to
+    // reference the created message buffer in other message buffer API calls.
+
+    // Other code that uses the message buffer can go here.
+}
+
+</pre>
+ * \defgroup xMessageBufferCreateStatic xMessageBufferCreateStatic
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferCreateStatic( xBufferSizeBytes, pucMessageBufferStorageArea, pxStaticMessageBuffer ) ( MessageBufferHandle_t ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, 0, pdTRUE, pucMessageBufferStorageArea, pxStaticMessageBuffer )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,
+                           const void *pvTxData,
+                           size_t xDataLengthBytes,
+                           TickType_t xTicksToWait );
+<pre>
+ *
+ * Sends a discrete message to the message buffer.  The message can be any
+ * length that fits within the buffer's free space, and is copied into the
+ * buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xMessageBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xMessageBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xMessageBufferSend() to write to a message buffer from a task.  Use
+ * xMessageBufferSendFromISR() to write to a message buffer from an interrupt
+ * service routine (ISR).
+ *
+ * @param xMessageBuffer The handle of the message buffer to which a message is
+ * being sent.
+ *
+ * @param pvTxData A pointer to the message that is to be copied into the
+ * message buffer.
+ *
+ * @param xDataLengthBytes The length of the message.  That is, the number of
+ * bytes to copy from pvTxData into the message buffer.  When a message is
+ * written to the message buffer an additional sizeof( size_t ) bytes are also
+ * written to store the message's length.  sizeof( size_t ) is typically 4 bytes
+ * on a 32-bit architecture, so on most 32-bit architecture setting
+ * xDataLengthBytes to 20 will reduce the free space in the message buffer by 24
+ * bytes (20 bytes of message data and 4 bytes to hold the message length).
+ *
+ * @param xTicksToWait The maximum amount of time the calling task should remain
+ * in the Blocked state to wait for enough space to become available in the
+ * message buffer, should the message buffer have insufficient space when
+ * xMessageBufferSend() is called.  The calling task will never block if
+ * xTicksToWait is zero.  The block time is specified in tick periods, so the
+ * absolute time it represents is dependent on the tick frequency.  The macro
+ * pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into
+ * a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will cause
+ * the task to wait indefinitely (without timing out), provided
+ * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  Tasks do not use any
+ * CPU time when they are in the Blocked state.
+ *
+ * @return The number of bytes written to the message buffer.  If the call to
+ * xMessageBufferSend() times out before there was enough space to write the
+ * message into the message buffer then zero is returned.  If the call did not
+ * time out then xDataLengthBytes is returned.
+ *
+ * Example use:
+<pre>
+void vAFunction( MessageBufferHandle_t xMessageBuffer )
+{
+size_t xBytesSent;
+uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };
+char *pcStringToSend = "String to send";
+const TickType_t x100ms = pdMS_TO_TICKS( 100 );
+
+    // Send an array to the message buffer, blocking for a maximum of 100ms to
+    // wait for enough space to be available in the message buffer.
+    xBytesSent = xMessageBufferSend( xMessageBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );
+
+    if( xBytesSent != sizeof( ucArrayToSend ) )
+    {
+        // The call to xMessageBufferSend() times out before there was enough
+        // space in the buffer for the data to be written.
+    }
+
+    // Send the string to the message buffer.  Return immediately if there is
+    // not enough space in the buffer.
+    xBytesSent = xMessageBufferSend( xMessageBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );
+
+    if( xBytesSent != strlen( pcStringToSend ) )
+    {
+        // The string could not be added to the message buffer because there was
+        // not enough free space in the buffer.
+    }
+}
+</pre>
+ * \defgroup xMessageBufferSend xMessageBufferSend
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferSend( xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait ) xStreamBufferSend( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,
+                                  const void *pvTxData,
+                                  size_t xDataLengthBytes,
+                                  BaseType_t *pxHigherPriorityTaskWoken );
+<pre>
+ *
+ * Interrupt safe version of the API function that sends a discrete message to
+ * the message buffer.  The message can be any length that fits within the
+ * buffer's free space, and is copied into the buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xMessageBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xMessageBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xMessageBufferSend() to write to a message buffer from a task.  Use
+ * xMessageBufferSendFromISR() to write to a message buffer from an interrupt
+ * service routine (ISR).
+ *
+ * @param xMessageBuffer The handle of the message buffer to which a message is
+ * being sent.
+ *
+ * @param pvTxData A pointer to the message that is to be copied into the
+ * message buffer.
+ *
+ * @param xDataLengthBytes The length of the message.  That is, the number of
+ * bytes to copy from pvTxData into the message buffer.  When a message is
+ * written to the message buffer an additional sizeof( size_t ) bytes are also
+ * written to store the message's length.  sizeof( size_t ) is typically 4 bytes
+ * on a 32-bit architecture, so on most 32-bit architecture setting
+ * xDataLengthBytes to 20 will reduce the free space in the message buffer by 24
+ * bytes (20 bytes of message data and 4 bytes to hold the message length).
+ *
+ * @param pxHigherPriorityTaskWoken  It is possible that a message buffer will
+ * have a task blocked on it waiting for data.  Calling
+ * xMessageBufferSendFromISR() can make data available, and so cause a task that
+ * was waiting for data to leave the Blocked state.  If calling
+ * xMessageBufferSendFromISR() causes a task to leave the Blocked state, and the
+ * unblocked task has a priority higher than the currently executing task (the
+ * task that was interrupted), then, internally, xMessageBufferSendFromISR()
+ * will set *pxHigherPriorityTaskWoken to pdTRUE.  If
+ * xMessageBufferSendFromISR() sets this value to pdTRUE, then normally a
+ * context switch should be performed before the interrupt is exited.  This will
+ * ensure that the interrupt returns directly to the highest priority Ready
+ * state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
+ * is passed into the function.  See the code example below for an example.
+ *
+ * @return The number of bytes actually written to the message buffer.  If the
+ * message buffer didn't have enough free space for the message to be stored
+ * then 0 is returned, otherwise xDataLengthBytes is returned.
+ *
+ * Example use:
+<pre>
+// A message buffer that has already been created.
+MessageBufferHandle_t xMessageBuffer;
+
+void vAnInterruptServiceRoutine( void )
+{
+size_t xBytesSent;
+char *pcStringToSend = "String to send";
+BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.
+
+    // Attempt to send the string to the message buffer.
+    xBytesSent = xMessageBufferSendFromISR( xMessageBuffer,
+                                            ( void * ) pcStringToSend,
+                                            strlen( pcStringToSend ),
+                                            &xHigherPriorityTaskWoken );
+
+    if( xBytesSent != strlen( pcStringToSend ) )
+    {
+        // The string could not be added to the message buffer because there was
+        // not enough free space in the buffer.
+    }
+
+    // If xHigherPriorityTaskWoken was set to pdTRUE inside
+    // xMessageBufferSendFromISR() then a task that has a priority above the
+    // priority of the currently executing task was unblocked and a context
+    // switch should be performed to ensure the ISR returns to the unblocked
+    // task.  In most FreeRTOS ports this is done by simply passing
+    // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
+    // variables value, and perform the context switch if necessary.  Check the
+    // documentation for the port in use for port specific instructions.
+    taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+}
+</pre>
+ * \defgroup xMessageBufferSendFromISR xMessageBufferSendFromISR
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferSendFromISR( xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken ) xStreamBufferSendFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer,
+                              void *pvRxData,
+                              size_t xBufferLengthBytes,
+                              TickType_t xTicksToWait );
+</pre>
+ *
+ * Receives a discrete message from a message buffer.  Messages can be of
+ * variable length and are copied out of the buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xMessageBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xMessageBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xMessageBufferReceive() to read from a message buffer from a task.  Use
+ * xMessageBufferReceiveFromISR() to read from a message buffer from an
+ * interrupt service routine (ISR).
+ *
+ * @param xMessageBuffer The handle of the message buffer from which a message
+ * is being received.
+ *
+ * @param pvRxData A pointer to the buffer into which the received message is
+ * to be copied.
+ *
+ * @param xBufferLengthBytes The length of the buffer pointed to by the pvRxData
+ * parameter.  This sets the maximum length of the message that can be received.
+ * If xBufferLengthBytes is too small to hold the next message then the message
+ * will be left in the message buffer and 0 will be returned.
+ *
+ * @param xTicksToWait The maximum amount of time the task should remain in the
+ * Blocked state to wait for a message, should the message buffer be empty.
+ * xMessageBufferReceive() will return immediately if xTicksToWait is zero and
+ * the message buffer is empty.  The block time is specified in tick periods, so
+ * the absolute time it represents is dependent on the tick frequency.  The
+ * macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds
+ * into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will
+ * cause the task to wait indefinitely (without timing out), provided
+ * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  Tasks do not use any
+ * CPU time when they are in the Blocked state.
+ *
+ * @return The length, in bytes, of the message read from the message buffer, if
+ * any.  If xMessageBufferReceive() times out before a message became available
+ * then zero is returned.  If the length of the message is greater than
+ * xBufferLengthBytes then the message will be left in the message buffer and
+ * zero is returned.
+ *
+ * Example use:
+<pre>
+void vAFunction( MessageBuffer_t xMessageBuffer )
+{
+uint8_t ucRxData[ 20 ];
+size_t xReceivedBytes;
+const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );
+
+    // Receive the next message from the message buffer.  Wait in the Blocked
+    // state (so not using any CPU processing time) for a maximum of 100ms for
+    // a message to become available.
+    xReceivedBytes = xMessageBufferReceive( xMessageBuffer,
+                                            ( void * ) ucRxData,
+                                            sizeof( ucRxData ),
+                                            xBlockTime );
+
+    if( xReceivedBytes > 0 )
+    {
+        // A ucRxData contains a message that is xReceivedBytes long.  Process
+        // the message here....
+    }
+}
+</pre>
+ * \defgroup xMessageBufferReceive xMessageBufferReceive
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferReceive( xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait ) xStreamBufferReceive( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait )
+
+
+/**
+ * message_buffer.h
+ *
+<pre>
+size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer,
+                                     void *pvRxData,
+                                     size_t xBufferLengthBytes,
+                                     BaseType_t *pxHigherPriorityTaskWoken );
+</pre>
+ *
+ * An interrupt safe version of the API function that receives a discrete
+ * message from a message buffer.  Messages can be of variable length and are
+ * copied out of the buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xMessageBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xMessageBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xMessageBufferReceive() to read from a message buffer from a task.  Use
+ * xMessageBufferReceiveFromISR() to read from a message buffer from an
+ * interrupt service routine (ISR).
+ *
+ * @param xMessageBuffer The handle of the message buffer from which a message
+ * is being received.
+ *
+ * @param pvRxData A pointer to the buffer into which the received message is
+ * to be copied.
+ *
+ * @param xBufferLengthBytes The length of the buffer pointed to by the pvRxData
+ * parameter.  This sets the maximum length of the message that can be received.
+ * If xBufferLengthBytes is too small to hold the next message then the message
+ * will be left in the message buffer and 0 will be returned.
+ *
+ * @param pxHigherPriorityTaskWoken  It is possible that a message buffer will
+ * have a task blocked on it waiting for space to become available.  Calling
+ * xMessageBufferReceiveFromISR() can make space available, and so cause a task
+ * that is waiting for space to leave the Blocked state.  If calling
+ * xMessageBufferReceiveFromISR() causes a task to leave the Blocked state, and
+ * the unblocked task has a priority higher than the currently executing task
+ * (the task that was interrupted), then, internally,
+ * xMessageBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
+ * If xMessageBufferReceiveFromISR() sets this value to pdTRUE, then normally a
+ * context switch should be performed before the interrupt is exited.  That will
+ * ensure the interrupt returns directly to the highest priority Ready state
+ * task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
+ * passed into the function.  See the code example below for an example.
+ *
+ * @return The length, in bytes, of the message read from the message buffer, if
+ * any.
+ *
+ * Example use:
+<pre>
+// A message buffer that has already been created.
+MessageBuffer_t xMessageBuffer;
+
+void vAnInterruptServiceRoutine( void )
+{
+uint8_t ucRxData[ 20 ];
+size_t xReceivedBytes;
+BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.
+
+    // Receive the next message from the message buffer.
+    xReceivedBytes = xMessageBufferReceiveFromISR( xMessageBuffer,
+                                                  ( void * ) ucRxData,
+                                                  sizeof( ucRxData ),
+                                                  &xHigherPriorityTaskWoken );
+
+    if( xReceivedBytes > 0 )
+    {
+        // A ucRxData contains a message that is xReceivedBytes long.  Process
+        // the message here....
+    }
+
+    // If xHigherPriorityTaskWoken was set to pdTRUE inside
+    // xMessageBufferReceiveFromISR() then a task that has a priority above the
+    // priority of the currently executing task was unblocked and a context
+    // switch should be performed to ensure the ISR returns to the unblocked
+    // task.  In most FreeRTOS ports this is done by simply passing
+    // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
+    // variables value, and perform the context switch if necessary.  Check the
+    // documentation for the port in use for port specific instructions.
+    taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+}
+</pre>
+ * \defgroup xMessageBufferReceiveFromISR xMessageBufferReceiveFromISR
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferReceiveFromISR( xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken ) xStreamBufferReceiveFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+void vMessageBufferDelete( MessageBufferHandle_t xMessageBuffer );
+</pre>
+ *
+ * Deletes a message buffer that was previously created using a call to
+ * xMessageBufferCreate() or xMessageBufferCreateStatic().  If the message
+ * buffer was created using dynamic memory (that is, by xMessageBufferCreate()),
+ * then the allocated memory is freed.
+ *
+ * A message buffer handle must not be used after the message buffer has been
+ * deleted.
+ *
+ * @param xMessageBuffer The handle of the message buffer to be deleted.
+ *
+ */
+#define vMessageBufferDelete( xMessageBuffer ) vStreamBufferDelete( ( StreamBufferHandle_t ) xMessageBuffer )
+
+/**
+ * message_buffer.h
+<pre>
+BaseType_t xMessageBufferIsFull( MessageBufferHandle_t xMessageBuffer ) );
+</pre>
+ *
+ * Tests to see if a message buffer is full.  A message buffer is full if it
+ * cannot accept any more messages, of any size, until space is made available
+ * by a message being removed from the message buffer.
+ *
+ * @param xMessageBuffer The handle of the message buffer being queried.
+ *
+ * @return If the message buffer referenced by xMessageBuffer is full then
+ * pdTRUE is returned.  Otherwise pdFALSE is returned.
+ */
+#define xMessageBufferIsFull( xMessageBuffer ) xStreamBufferIsFull( ( StreamBufferHandle_t ) xMessageBuffer )
+
+/**
+ * message_buffer.h
+<pre>
+BaseType_t xMessageBufferIsEmpty( MessageBufferHandle_t xMessageBuffer ) );
+</pre>
+ *
+ * Tests to see if a message buffer is empty (does not contain any messages).
+ *
+ * @param xMessageBuffer The handle of the message buffer being queried.
+ *
+ * @return If the message buffer referenced by xMessageBuffer is empty then
+ * pdTRUE is returned.  Otherwise pdFALSE is returned.
+ *
+ */
+#define xMessageBufferIsEmpty( xMessageBuffer ) xStreamBufferIsEmpty( ( StreamBufferHandle_t ) xMessageBuffer )
+
+/**
+ * message_buffer.h
+<pre>
+BaseType_t xMessageBufferReset( MessageBufferHandle_t xMessageBuffer );
+</pre>
+ *
+ * Resets a message buffer to its initial empty state, discarding any message it
+ * contained.
+ *
+ * A message buffer can only be reset if there are no tasks blocked on it.
+ *
+ * @param xMessageBuffer The handle of the message buffer being reset.
+ *
+ * @return If the message buffer was reset then pdPASS is returned.  If the
+ * message buffer could not be reset because either there was a task blocked on
+ * the message queue to wait for space to become available, or to wait for a
+ * a message to be available, then pdFAIL is returned.
+ *
+ * \defgroup xMessageBufferReset xMessageBufferReset
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferReset( xMessageBuffer ) xStreamBufferReset( ( StreamBufferHandle_t ) xMessageBuffer )
+
+
+/**
+ * message_buffer.h
+<pre>
+size_t xMessageBufferSpaceAvailable( MessageBufferHandle_t xMessageBuffer ) );
+</pre>
+ * Returns the number of bytes of free space in the message buffer.
+ *
+ * @param xMessageBuffer The handle of the message buffer being queried.
+ *
+ * @return The number of bytes that can be written to the message buffer before
+ * the message buffer would be full.  When a message is written to the message
+ * buffer an additional sizeof( size_t ) bytes are also written to store the
+ * message's length.  sizeof( size_t ) is typically 4 bytes on a 32-bit
+ * architecture, so if xMessageBufferSpacesAvailable() returns 10, then the size
+ * of the largest message that can be written to the message buffer is 6 bytes.
+ *
+ * \defgroup xMessageBufferSpaceAvailable xMessageBufferSpaceAvailable
+ * \ingroup MessageBufferManagement
+ */
+#define xMessageBufferSpaceAvailable( xMessageBuffer ) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+BaseType_t xMessageBufferSendCompletedFromISR( MessageBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
+</pre>
+ *
+ * For advanced users only.
+ *
+ * The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when
+ * data is sent to a message buffer or stream buffer.  If there was a task that
+ * was blocked on the message or stream buffer waiting for data to arrive then
+ * the sbSEND_COMPLETED() macro sends a notification to the task to remove it
+ * from the Blocked state.  xMessageBufferSendCompletedFromISR() does the same
+ * thing.  It is provided to enable application writers to implement their own
+ * version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.
+ *
+ * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
+ * additional information.
+ *
+ * @param xStreamBuffer The handle of the stream buffer to which data was
+ * written.
+ *
+ * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
+ * initialised to pdFALSE before it is passed into
+ * xMessageBufferSendCompletedFromISR().  If calling
+ * xMessageBufferSendCompletedFromISR() removes a task from the Blocked state,
+ * and the task has a priority above the priority of the currently running task,
+ * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
+ * context switch should be performed before exiting the ISR.
+ *
+ * @return If a task was removed from the Blocked state then pdTRUE is returned.
+ * Otherwise pdFALSE is returned.
+ *
+ * \defgroup xMessageBufferSendCompletedFromISR xMessageBufferSendCompletedFromISR
+ * \ingroup StreamBufferManagement
+ */
+#define xMessageBufferSendCompletedFromISR( xMessageBuffer, pxHigherPriorityTaskWoken ) xStreamBufferSendCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )
+
+/**
+ * message_buffer.h
+ *
+<pre>
+BaseType_t xMessageBufferReceiveCompletedFromISR( MessageBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
+</pre>
+ *
+ * For advanced users only.
+ *
+ * The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when
+ * data is read out of a message buffer or stream buffer.  If there was a task
+ * that was blocked on the message or stream buffer waiting for data to arrive
+ * then the sbRECEIVE_COMPLETED() macro sends a notification to the task to
+ * remove it from the Blocked state.  xMessageBufferReceiveCompletedFromISR()
+ * does the same thing.  It is provided to enable application writers to
+ * implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT
+ * ANY OTHER TIME.
+ *
+ * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
+ * additional information.
+ *
+ * @param xStreamBuffer The handle of the stream buffer from which data was
+ * read.
+ *
+ * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
+ * initialised to pdFALSE before it is passed into
+ * xMessageBufferReceiveCompletedFromISR().  If calling
+ * xMessageBufferReceiveCompletedFromISR() removes a task from the Blocked state,
+ * and the task has a priority above the priority of the currently running task,
+ * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
+ * context switch should be performed before exiting the ISR.
+ *
+ * @return If a task was removed from the Blocked state then pdTRUE is returned.
+ * Otherwise pdFALSE is returned.
+ *
+ * \defgroup xMessageBufferReceiveCompletedFromISR xMessageBufferReceiveCompletedFromISR
+ * \ingroup StreamBufferManagement
+ */
+#define xMessageBufferReceiveCompletedFromISR( xMessageBuffer, pxHigherPriorityTaskWoken ) xStreamBufferReceiveCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )
+
+#if defined( __cplusplus )
+} /* extern "C" */
+#endif
+
+#endif	/* !defined( FREERTOS_MESSAGE_BUFFER_H ) */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/private/deprecated_definitions.h ./libs/freertos/include/private/deprecated_definitions.h
--- a_bRU7kv/libs/freertos/include/private/deprecated_definitions.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/private/deprecated_definitions.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,279 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef DEPRECATED_DEFINITIONS_H
+#define DEPRECATED_DEFINITIONS_H
+
+
+/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
+pre-processor definition was used to ensure the pre-processor found the correct
+portmacro.h file for the port being used.  That scheme was deprecated in favour
+of setting the compiler's include path such that it found the correct
+portmacro.h file - removing the need for the constant and allowing the
+portmacro.h file to be located anywhere in relation to the port being used.  The
+definitions below remain in the code for backward compatibility only.  New
+projects should not use them. */
+
+#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
+	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
+	typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
+	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
+	typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef GCC_MEGA_AVR
+	#include "../portable/GCC/ATMega323/portmacro.h"
+#endif
+
+#ifdef IAR_MEGA_AVR
+	#include "../portable/IAR/ATMega323/portmacro.h"
+#endif
+
+#ifdef MPLAB_PIC24_PORT
+	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
+#endif
+
+#ifdef MPLAB_DSPIC_PORT
+	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
+#endif
+
+#ifdef MPLAB_PIC18F_PORT
+	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
+#endif
+
+#ifdef MPLAB_PIC32MX_PORT
+	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
+#endif
+
+#ifdef _FEDPICC
+	#include "libFreeRTOS/Include/portmacro.h"
+#endif
+
+#ifdef SDCC_CYGNAL
+	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
+#endif
+
+#ifdef GCC_ARM7
+	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
+#endif
+
+#ifdef GCC_ARM7_ECLIPSE
+	#include "portmacro.h"
+#endif
+
+#ifdef ROWLEY_LPC23xx
+	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
+#endif
+
+#ifdef IAR_MSP430
+	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
+#endif
+
+#ifdef GCC_MSP430
+	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
+#endif
+
+#ifdef ROWLEY_MSP430
+	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
+#endif
+
+#ifdef ARM7_LPC21xx_KEIL_RVDS
+	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
+#endif
+
+#ifdef SAM7_GCC
+	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
+#endif
+
+#ifdef SAM7_IAR
+	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
+#endif
+
+#ifdef SAM9XE_IAR
+	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
+#endif
+
+#ifdef LPC2000_IAR
+	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
+#endif
+
+#ifdef STR71X_IAR
+	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
+#endif
+
+#ifdef STR75X_IAR
+	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
+#endif
+
+#ifdef STR75X_GCC
+	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
+#endif
+
+#ifdef STR91X_IAR
+	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
+#endif
+
+#ifdef GCC_H8S
+	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
+#endif
+
+#ifdef GCC_AT91FR40008
+	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
+#endif
+
+#ifdef RVDS_ARMCM3_LM3S102
+	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef GCC_ARMCM3_LM3S102
+	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef GCC_ARMCM3
+	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef IAR_ARM_CM3
+	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef IAR_ARMCM3_LM
+	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef HCS12_CODE_WARRIOR
+	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
+#endif
+
+#ifdef MICROBLAZE_GCC
+	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
+#endif
+
+#ifdef TERN_EE
+	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
+#endif
+
+#ifdef GCC_HCS12
+	#include "../../Source/portable/GCC/HCS12/portmacro.h"
+#endif
+
+#ifdef GCC_MCF5235
+    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
+#endif
+
+#ifdef COLDFIRE_V2_GCC
+	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
+#endif
+
+#ifdef COLDFIRE_V2_CODEWARRIOR
+	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
+#endif
+
+#ifdef GCC_PPC405
+	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
+#endif
+
+#ifdef GCC_PPC440
+	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
+#endif
+
+#ifdef _16FX_SOFTUNE
+	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
+#endif
+
+#ifdef BCC_INDUSTRIAL_PC_PORT
+	/* A short file name has to be used in place of the normal
+	FreeRTOSConfig.h when using the Borland compiler. */
+	#include "frconfig.h"
+	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
+    typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef BCC_FLASH_LITE_186_PORT
+	/* A short file name has to be used in place of the normal
+	FreeRTOSConfig.h when using the Borland compiler. */
+	#include "frconfig.h"
+	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
+    typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef __GNUC__
+   #ifdef __AVR32_AVR32A__
+	   #include "portmacro.h"
+   #endif
+#endif
+
+#ifdef __ICCAVR32__
+   #ifdef __CORE__
+      #if __CORE__ == __AVR32A__
+	      #include "portmacro.h"
+      #endif
+   #endif
+#endif
+
+#ifdef __91467D
+	#include "portmacro.h"
+#endif
+
+#ifdef __96340
+	#include "portmacro.h"
+#endif
+
+
+#ifdef __IAR_V850ES_Fx3__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Jx3__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Jx3_L__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Jx2__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Hx2__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_78K0R_Kx3__
+	#include "../../Source/portable/IAR/78K0R/portmacro.h"
+#endif
+
+#ifdef __IAR_78K0R_Kx3L__
+	#include "../../Source/portable/IAR/78K0R/portmacro.h"
+#endif
+
+#endif /* DEPRECATED_DEFINITIONS_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/private/list.h ./libs/freertos/include/private/list.h
--- a_bRU7kv/libs/freertos/include/private/list.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/private/list.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,411 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*
+ * This is the list implementation used by the scheduler.  While it is tailored
+ * heavily for the schedulers needs, it is also available for use by
+ * application code.
+ *
+ * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
+ * numeric value (xItemValue).  Most of the time the lists are sorted in
+ * descending item value order.
+ *
+ * Lists are created already containing one list item.  The value of this
+ * item is the maximum possible that can be stored, it is therefore always at
+ * the end of the list and acts as a marker.  The list member pxHead always
+ * points to this marker - even though it is at the tail of the list.  This
+ * is because the tail contains a wrap back pointer to the true head of
+ * the list.
+ *
+ * In addition to it's value, each list item contains a pointer to the next
+ * item in the list (pxNext), a pointer to the list it is in (pxContainer)
+ * and a pointer to back to the object that contains it.  These later two
+ * pointers are included for efficiency of list manipulation.  There is
+ * effectively a two way link between the object containing the list item and
+ * the list item itself.
+ *
+ *
+ * \page ListIntroduction List Implementation
+ * \ingroup FreeRTOSIntro
+ */
+
+#ifndef INC_FREERTOS_H
+	#error FreeRTOS.h must be included before list.h
+#endif
+
+#ifndef LIST_H
+#define LIST_H
+
+/*
+ * The list structure members are modified from within interrupts, and therefore
+ * by rights should be declared volatile.  However, they are only modified in a
+ * functionally atomic way (within critical sections of with the scheduler
+ * suspended) and are either passed by reference into a function or indexed via
+ * a volatile variable.  Therefore, in all use cases tested so far, the volatile
+ * qualifier can be omitted in order to provide a moderate performance
+ * improvement without adversely affecting functional behaviour.  The assembly
+ * instructions generated by the IAR, ARM and GCC compilers when the respective
+ * compiler's options were set for maximum optimisation has been inspected and
+ * deemed to be as intended.  That said, as compiler technology advances, and
+ * especially if aggressive cross module optimisation is used (a use case that
+ * has not been exercised to any great extend) then it is feasible that the
+ * volatile qualifier will be needed for correct optimisation.  It is expected
+ * that a compiler removing essential code because, without the volatile
+ * qualifier on the list structure members and with aggressive cross module
+ * optimisation, the compiler deemed the code unnecessary will result in
+ * complete and obvious failure of the scheduler.  If this is ever experienced
+ * then the volatile qualifier can be inserted in the relevant places within the
+ * list structures by simply defining configLIST_VOLATILE to volatile in
+ * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
+ * If configLIST_VOLATILE is not defined then the preprocessor directives below
+ * will simply #define configLIST_VOLATILE away completely.
+ *
+ * To use volatile list structure members then add the following line to
+ * FreeRTOSConfig.h (without the quotes):
+ * "#define configLIST_VOLATILE volatile"
+ */
+#ifndef configLIST_VOLATILE
+	#define configLIST_VOLATILE
+#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Macros that can be used to place known values within the list structures,
+then check that the known values do not get corrupted during the execution of
+the application.   These may catch the list data structures being overwritten in
+memory.  They will not catch data errors caused by incorrect configuration or
+use of FreeRTOS.*/
+#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
+	/* Define the macros to do nothing. */
+	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
+	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
+	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
+	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
+	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
+	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
+	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
+	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
+	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
+	#define listTEST_LIST_INTEGRITY( pxList )
+#else
+	/* Define macros that add new members into the list structures. */
+	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
+	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
+	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
+	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
+
+	/* Define macros that set the new structure members to known values. */
+	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
+	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
+	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
+	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
+
+	/* Define macros that will assert if one of the structure members does not
+	contain its expected value. */
+	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
+	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
+#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
+
+
+/*
+ * Definition of the only type of object that a list can contain.
+ */
+struct xLIST_ITEM
+{
+	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
+	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
+	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
+	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
+	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
+	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+};
+typedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
+
+struct xMINI_LIST_ITEM
+{
+	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	configLIST_VOLATILE TickType_t xItemValue;
+	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
+	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
+};
+typedef struct xMINI_LIST_ITEM MiniListItem_t;
+
+/*
+ * Definition of the type of queue used by the scheduler.
+ */
+typedef struct xLIST
+{
+	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	volatile UBaseType_t uxNumberOfItems;
+	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
+	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
+	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+} List_t;
+
+/*
+ * Access macro to set the owner of a list item.  The owner of a list item
+ * is the object (usually a TCB) that contains the list item.
+ *
+ * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
+ * \ingroup LinkedList
+ */
+#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
+
+/*
+ * Access macro to get the owner of a list item.  The owner of a list item
+ * is the object (usually a TCB) that contains the list item.
+ *
+ * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
+ * \ingroup LinkedList
+ */
+#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
+
+/*
+ * Access macro to set the value of the list item.  In most cases the value is
+ * used to sort the list in descending order.
+ *
+ * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
+ * \ingroup LinkedList
+ */
+#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
+
+/*
+ * Access macro to retrieve the value of the list item.  The value can
+ * represent anything - for example the priority of a task, or the time at
+ * which a task should be unblocked.
+ *
+ * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
+ * \ingroup LinkedList
+ */
+#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
+
+/*
+ * Access macro to retrieve the value of the list item at the head of a given
+ * list.
+ *
+ * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
+ * \ingroup LinkedList
+ */
+#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
+
+/*
+ * Return the list item at the head of the list.
+ *
+ * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
+ * \ingroup LinkedList
+ */
+#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
+
+/*
+ * Return the list item at the head of the list.
+ *
+ * \page listGET_NEXT listGET_NEXT
+ * \ingroup LinkedList
+ */
+#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
+
+/*
+ * Return the list item that marks the end of the list
+ *
+ * \page listGET_END_MARKER listGET_END_MARKER
+ * \ingroup LinkedList
+ */
+#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
+
+/*
+ * Access macro to determine if a list contains any items.  The macro will
+ * only have the value true if the list is empty.
+ *
+ * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
+ * \ingroup LinkedList
+ */
+#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
+
+/*
+ * Access macro to return the number of items in the list.
+ */
+#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
+
+/*
+ * Access function to obtain the owner of the next entry in a list.
+ *
+ * The list member pxIndex is used to walk through a list.  Calling
+ * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
+ * and returns that entry's pxOwner parameter.  Using multiple calls to this
+ * function it is therefore possible to move through every item contained in
+ * a list.
+ *
+ * The pxOwner parameter of a list item is a pointer to the object that owns
+ * the list item.  In the scheduler this is normally a task control block.
+ * The pxOwner parameter effectively creates a two way link between the list
+ * item and its owner.
+ *
+ * @param pxTCB pxTCB is set to the address of the owner of the next list item.
+ * @param pxList The list from which the next item owner is to be returned.
+ *
+ * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
+ * \ingroup LinkedList
+ */
+#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
+{																							\
+List_t * const pxConstList = ( pxList );													\
+	/* Increment the index to the next item and return the item, ensuring */				\
+	/* we don't return the marker used at the end of the list.  */							\
+	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
+	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
+	{																						\
+		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
+	}																						\
+	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
+}
+
+
+/*
+ * Access function to obtain the owner of the first entry in a list.  Lists
+ * are normally sorted in ascending item value order.
+ *
+ * This function returns the pxOwner member of the first item in the list.
+ * The pxOwner parameter of a list item is a pointer to the object that owns
+ * the list item.  In the scheduler this is normally a task control block.
+ * The pxOwner parameter effectively creates a two way link between the list
+ * item and its owner.
+ *
+ * @param pxList The list from which the owner of the head item is to be
+ * returned.
+ *
+ * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
+ * \ingroup LinkedList
+ */
+#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
+
+/*
+ * Check to see if a list item is within a list.  The list item maintains a
+ * "container" pointer that points to the list it is in.  All this macro does
+ * is check to see if the container and the list match.
+ *
+ * @param pxList The list we want to know if the list item is within.
+ * @param pxListItem The list item we want to know if is in the list.
+ * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
+ */
+#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
+
+/*
+ * Return the list a list item is contained within (referenced from).
+ *
+ * @param pxListItem The list item being queried.
+ * @return A pointer to the List_t object that references the pxListItem
+ */
+#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
+
+/*
+ * This provides a crude means of knowing if a list has been initialised, as
+ * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
+ * function.
+ */
+#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
+
+/*
+ * Must be called before a list is used!  This initialises all the members
+ * of the list structure and inserts the xListEnd item into the list as a
+ * marker to the back of the list.
+ *
+ * @param pxList Pointer to the list being initialised.
+ *
+ * \page vListInitialise vListInitialise
+ * \ingroup LinkedList
+ */
+void vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
+
+/*
+ * Must be called before a list item is used.  This sets the list container to
+ * null so the item does not think that it is already contained in a list.
+ *
+ * @param pxItem Pointer to the list item being initialised.
+ *
+ * \page vListInitialiseItem vListInitialiseItem
+ * \ingroup LinkedList
+ */
+void vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
+
+/*
+ * Insert a list item into a list.  The item will be inserted into the list in
+ * a position determined by its item value (descending item value order).
+ *
+ * @param pxList The list into which the item is to be inserted.
+ *
+ * @param pxNewListItem The item that is to be placed in the list.
+ *
+ * \page vListInsert vListInsert
+ * \ingroup LinkedList
+ */
+void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
+
+/*
+ * Insert a list item into a list.  The item will be inserted in a position
+ * such that it will be the last item within the list returned by multiple
+ * calls to listGET_OWNER_OF_NEXT_ENTRY.
+ *
+ * The list member pxIndex is used to walk through a list.  Calling
+ * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
+ * Placing an item in a list using vListInsertEnd effectively places the item
+ * in the list position pointed to by pxIndex.  This means that every other
+ * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
+ * the pxIndex parameter again points to the item being inserted.
+ *
+ * @param pxList The list into which the item is to be inserted.
+ *
+ * @param pxNewListItem The list item to be inserted into the list.
+ *
+ * \page vListInsertEnd vListInsertEnd
+ * \ingroup LinkedList
+ */
+void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
+
+/*
+ * Remove an item from a list.  The list item has a pointer to the list that
+ * it is in, so only the list item need be passed into the function.
+ *
+ * @param uxListRemove The item to be removed.  The item will remove itself from
+ * the list pointed to by it's pxContainer parameter.
+ *
+ * @return The number of items that remain in the list after the list item has
+ * been removed.
+ *
+ * \page uxListRemove uxListRemove
+ * \ingroup LinkedList
+ */
+UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/private/mpu_wrappers.h ./libs/freertos/include/private/mpu_wrappers.h
--- a_bRU7kv/libs/freertos/include/private/mpu_wrappers.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/private/mpu_wrappers.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,181 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef MPU_WRAPPERS_H
+#define MPU_WRAPPERS_H
+
+/* This file redefines API functions to be called through a wrapper macro, but
+only for ports that are using the MPU. */
+#ifdef portUSING_MPU_WRAPPERS
+
+	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
+	included from queue.c or task.c to prevent it from having an effect within
+	those files. */
+	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+		/*
+		 * Map standard (non MPU) API functions to equivalents that start
+		 * "MPU_".  This will cause the application code to call the MPU_
+		 * version, which wraps the non-MPU version with privilege promoting
+		 * then demoting code, so the kernel code always runs will full
+		 * privileges.
+		 */
+
+		/* Map standard tasks.h API functions to the MPU equivalents. */
+		#define xTaskCreate								MPU_xTaskCreate
+		#define xTaskCreateStatic						MPU_xTaskCreateStatic
+		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
+		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
+		#define vTaskDelete								MPU_vTaskDelete
+		#define vTaskDelay								MPU_vTaskDelay
+		#define vTaskDelayUntil							MPU_vTaskDelayUntil
+		#define xTaskAbortDelay							MPU_xTaskAbortDelay
+		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
+		#define eTaskGetState							MPU_eTaskGetState
+		#define vTaskGetInfo							MPU_vTaskGetInfo
+		#define vTaskPrioritySet						MPU_vTaskPrioritySet
+		#define vTaskSuspend							MPU_vTaskSuspend
+		#define vTaskResume								MPU_vTaskResume
+		#define vTaskSuspendAll							MPU_vTaskSuspendAll
+		#define xTaskResumeAll							MPU_xTaskResumeAll
+		#define xTaskGetTickCount						MPU_xTaskGetTickCount
+		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
+		#define pcTaskGetName							MPU_pcTaskGetName
+		#define xTaskGetHandle							MPU_xTaskGetHandle
+		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
+		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
+		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
+		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
+		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
+		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
+		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
+		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
+		#define vTaskList								MPU_vTaskList
+		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
+		#define xTaskGenericNotify						MPU_xTaskGenericNotify
+		#define xTaskNotifyWait							MPU_xTaskNotifyWait
+		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
+		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
+
+		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
+		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
+		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
+		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
+
+		/* Map standard queue.h API functions to the MPU equivalents. */
+		#define xQueueGenericSend						MPU_xQueueGenericSend
+		#define xQueueReceive							MPU_xQueueReceive
+		#define xQueuePeek								MPU_xQueuePeek
+		#define xQueueSemaphoreTake						MPU_xQueueSemaphoreTake
+		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
+		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
+		#define vQueueDelete							MPU_vQueueDelete
+		#define xQueueCreateMutex						MPU_xQueueCreateMutex
+		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
+		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
+		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
+		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
+		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
+		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
+		#define xQueueGenericCreate						MPU_xQueueGenericCreate
+		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
+		#define xQueueCreateSet							MPU_xQueueCreateSet
+		#define xQueueAddToSet							MPU_xQueueAddToSet
+		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
+		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
+		#define xQueueGenericReset						MPU_xQueueGenericReset
+
+		#if( configQUEUE_REGISTRY_SIZE > 0 )
+			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
+			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
+			#define pcQueueGetName							MPU_pcQueueGetName
+		#endif
+
+		/* Map standard timer.h API functions to the MPU equivalents. */
+		#define xTimerCreate							MPU_xTimerCreate
+		#define xTimerCreateStatic						MPU_xTimerCreateStatic
+		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
+		#define vTimerSetTimerID						MPU_vTimerSetTimerID
+		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
+		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
+		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
+		#define pcTimerGetName							MPU_pcTimerGetName
+		#define xTimerGetPeriod							MPU_xTimerGetPeriod
+		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
+		#define xTimerGenericCommand					MPU_xTimerGenericCommand
+
+		/* Map standard event_group.h API functions to the MPU equivalents. */
+		#define xEventGroupCreate						MPU_xEventGroupCreate
+		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
+		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
+		#define xEventGroupClearBits					MPU_xEventGroupClearBits
+		#define xEventGroupSetBits						MPU_xEventGroupSetBits
+		#define xEventGroupSync							MPU_xEventGroupSync
+		#define vEventGroupDelete						MPU_vEventGroupDelete
+
+		/* Map standard message/stream_buffer.h API functions to the MPU
+		equivalents. */
+		#define xStreamBufferSend						MPU_xStreamBufferSend
+		#define xStreamBufferSendFromISR				MPU_xStreamBufferSendFromISR
+		#define xStreamBufferReceive					MPU_xStreamBufferReceive
+		#define xStreamBufferReceiveFromISR				MPU_xStreamBufferReceiveFromISR
+		#define vStreamBufferDelete						MPU_vStreamBufferDelete
+		#define xStreamBufferIsFull						MPU_xStreamBufferIsFull
+		#define xStreamBufferIsEmpty					MPU_xStreamBufferIsEmpty
+		#define xStreamBufferReset						MPU_xStreamBufferReset
+		#define xStreamBufferSpacesAvailable			MPU_xStreamBufferSpacesAvailable
+		#define xStreamBufferBytesAvailable				MPU_xStreamBufferBytesAvailable
+		#define xStreamBufferSetTriggerLevel			MPU_xStreamBufferSetTriggerLevel
+		#define xStreamBufferGenericCreate				MPU_xStreamBufferGenericCreate
+		#define xStreamBufferGenericCreateStatic		MPU_xStreamBufferGenericCreateStatic
+
+
+		/* Remove the privileged function macro, but keep the PRIVILEGED_DATA
+		macro so applications can place data in privileged access sections
+		(useful when using statically allocated objects). */
+		#define PRIVILEGED_FUNCTION
+		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
+
+	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
+
+		/* Ensure API functions go in the privileged execution section. */
+		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
+		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
+
+	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
+
+#else /* portUSING_MPU_WRAPPERS */
+
+	#define PRIVILEGED_FUNCTION
+	#define PRIVILEGED_DATA
+	#define portUSING_MPU_WRAPPERS 0
+
+#endif /* portUSING_MPU_WRAPPERS */
+
+
+#endif /* MPU_WRAPPERS_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/private/portable.h ./libs/freertos/include/private/portable.h
--- a_bRU7kv/libs/freertos/include/private/portable.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/private/portable.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,165 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*-----------------------------------------------------------
+ * Portable layer API.  Each function must be defined for each port.
+ *----------------------------------------------------------*/
+
+#ifndef PORTABLE_H
+#define PORTABLE_H
+
+/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
+pre-processor definition was used to ensure the pre-processor found the correct
+portmacro.h file for the port being used.  That scheme was deprecated in favour
+of setting the compiler's include path such that it found the correct
+portmacro.h file - removing the need for the constant and allowing the
+portmacro.h file to be located anywhere in relation to the port being used.
+Purely for reasons of backward compatibility the old method is still valid, but
+to make it clear that new projects should not use it, support for the port
+specific constants has been moved into the deprecated_definitions.h header
+file. */
+#include "deprecated_definitions.h"
+
+/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
+did not result in a portmacro.h header file being included - and it should be
+included here.  In this case the path to the correct portmacro.h header file
+must be set in the compiler's include path. */
+#ifndef portENTER_CRITICAL
+	#include "portmacro.h"
+#endif
+
+#if portBYTE_ALIGNMENT == 32
+	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
+#endif
+
+#if portBYTE_ALIGNMENT == 16
+	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
+#endif
+
+#if portBYTE_ALIGNMENT == 8
+	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
+#endif
+
+#if portBYTE_ALIGNMENT == 4
+	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
+#endif
+
+#if portBYTE_ALIGNMENT == 2
+	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
+#endif
+
+#if portBYTE_ALIGNMENT == 1
+	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
+#endif
+
+#ifndef portBYTE_ALIGNMENT_MASK
+	#error "Invalid portBYTE_ALIGNMENT definition"
+#endif
+
+#ifndef portNUM_CONFIGURABLE_REGIONS
+	#define portNUM_CONFIGURABLE_REGIONS 1
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mpu_wrappers.h"
+
+/*
+ * Setup the stack of a new task so it is ready to be placed under the
+ * scheduler control.  The registers have to be placed on the stack in
+ * the order that the port expects to find them.
+ *
+ */
+#if( portUSING_MPU_WRAPPERS == 1 )
+	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
+#else
+	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
+#endif
+
+/* Used by heap_5.c. */
+typedef struct HeapRegion
+{
+	uint8_t *pucStartAddress;
+	size_t xSizeInBytes;
+} HeapRegion_t;
+
+/*
+ * Used to define multiple heap regions for use by heap_5.c.  This function
+ * must be called before any calls to pvPortMalloc() - not creating a task,
+ * queue, semaphore, mutex, software timer, event group, etc. will result in
+ * pvPortMalloc being called.
+ *
+ * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
+ * defines a region of memory that can be used as the heap.  The array is
+ * terminated by a HeapRegions_t structure that has a size of 0.  The region
+ * with the lowest start address must appear first in the array.
+ */
+void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
+
+
+/*
+ * Map to the memory management routines required for the port.
+ */
+void *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
+void vPortFree( void *pv ) PRIVILEGED_FUNCTION;
+void vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
+size_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
+size_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Setup the hardware ready for the scheduler to take control.  This generally
+ * sets up a tick interrupt and sets timers for the correct tick frequency.
+ */
+BaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
+ * the hardware is left in its original condition after the scheduler stops
+ * executing.
+ */
+void vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * The structures and methods of manipulating the MPU are contained within the
+ * port layer.
+ *
+ * Fills the xMPUSettings structure with the memory region information
+ * contained in xRegions.
+ */
+#if( portUSING_MPU_WRAPPERS == 1 )
+	struct xMEMORY_REGION;
+	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PORTABLE_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/private/projdefs.h ./libs/freertos/include/private/projdefs.h
--- a_bRU7kv/libs/freertos/include/private/projdefs.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/private/projdefs.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,124 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef PROJDEFS_H
+#define PROJDEFS_H
+
+/*
+ * Defines the prototype to which task functions must conform.  Defined in this
+ * file to ensure the type is known before portable.h is included.
+ */
+typedef void (*TaskFunction_t)( void * );
+
+/* Converts a time in milliseconds to a time in ticks.  This macro can be
+overridden by a macro of the same name defined in FreeRTOSConfig.h in case the
+definition here is not suitable for your application. */
+#ifndef pdMS_TO_TICKS
+	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
+#endif
+
+#define pdFALSE			( ( BaseType_t ) 0 )
+#define pdTRUE			( ( BaseType_t ) 1 )
+
+#define pdPASS			( pdTRUE )
+#define pdFAIL			( pdFALSE )
+#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
+#define errQUEUE_FULL	( ( BaseType_t ) 0 )
+
+/* FreeRTOS error definitions. */
+#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
+#define errQUEUE_BLOCKED						( -4 )
+#define errQUEUE_YIELD							( -5 )
+
+/* Macros used for basic data corruption checks. */
+#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
+	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
+#endif
+
+#if( configUSE_16_BIT_TICKS == 1 )
+	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
+#else
+	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
+#endif
+
+/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
+itself. */
+#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
+#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
+#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
+#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
+#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
+#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
+#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
+#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
+#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
+#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
+#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
+#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
+#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
+#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
+#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
+#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
+#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
+#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
+#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
+#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
+#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
+#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
+#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
+#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
+#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
+#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
+#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
+#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
+#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
+#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
+#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
+#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
+#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
+#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
+#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
+#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
+#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
+#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
+#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
+#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
+
+/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
+itself. */
+#define pdFREERTOS_LITTLE_ENDIAN		0
+#define pdFREERTOS_BIG_ENDIAN			1
+
+/* Re-defining endian values for generic naming. */
+#define pdLITTLE_ENDIAN					pdFREERTOS_LITTLE_ENDIAN
+#define pdBIG_ENDIAN					pdFREERTOS_BIG_ENDIAN
+
+
+#endif /* PROJDEFS_H */
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/private/stack_macros.h ./libs/freertos/include/private/stack_macros.h
--- a_bRU7kv/libs/freertos/include/private/stack_macros.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/private/stack_macros.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,129 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef STACK_MACROS_H
+#define STACK_MACROS_H
+
+/*
+ * Call the stack overflow hook function if the stack of the task being swapped
+ * out is currently overflowed, or looks like it might have overflowed in the
+ * past.
+ *
+ * Setting configCHECK_FOR_STACK_OVERFLOW to 1 will cause the macro to check
+ * the current stack state only - comparing the current top of stack value to
+ * the stack limit.  Setting configCHECK_FOR_STACK_OVERFLOW to greater than 1
+ * will also cause the last few stack bytes to be checked to ensure the value
+ * to which the bytes were set when the task was created have not been
+ * overwritten.  Note this second test does not guarantee that an overflowed
+ * stack will always be recognised.
+ */
+
+/*-----------------------------------------------------------*/
+
+#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH < 0 ) )
+
+	/* Only the current stack state is to be checked. */
+	#define taskCHECK_FOR_STACK_OVERFLOW()																\
+	{																									\
+		/* Is the currently saved stack pointer within the stack limit? */								\
+		if( pxCurrentTCB->pxTopOfStack <= pxCurrentTCB->pxStack )										\
+		{																								\
+			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
+		}																								\
+	}
+
+#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
+/*-----------------------------------------------------------*/
+
+#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH > 0 ) )
+
+	/* Only the current stack state is to be checked. */
+	#define taskCHECK_FOR_STACK_OVERFLOW()																\
+	{																									\
+																										\
+		/* Is the currently saved stack pointer within the stack limit? */								\
+		if( pxCurrentTCB->pxTopOfStack >= pxCurrentTCB->pxEndOfStack )									\
+		{																								\
+			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
+		}																								\
+	}
+
+#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
+/*-----------------------------------------------------------*/
+
+#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) )
+
+	#define taskCHECK_FOR_STACK_OVERFLOW()																\
+	{																									\
+		const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB->pxStack;							\
+		const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5;											\
+																										\
+		if( ( pulStack[ 0 ] != ulCheckValue ) ||												\
+			( pulStack[ 1 ] != ulCheckValue ) ||												\
+			( pulStack[ 2 ] != ulCheckValue ) ||												\
+			( pulStack[ 3 ] != ulCheckValue ) )												\
+		{																								\
+			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
+		}																								\
+	}
+
+#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
+/*-----------------------------------------------------------*/
+
+#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH > 0 ) )
+
+	#define taskCHECK_FOR_STACK_OVERFLOW()																								\
+	{																																	\
+	int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB->pxEndOfStack;																		\
+	static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
+													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
+													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
+													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
+													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };	\
+																																		\
+																																		\
+		pcEndOfStack -= sizeof( ucExpectedStackBytes );																					\
+																																		\
+		/* Has the extremity of the task stack ever been written over? */																\
+		if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )					\
+		{																																\
+			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );									\
+		}																																\
+	}
+
+#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
+/*-----------------------------------------------------------*/
+
+/* Remove stack overflow macro if not being used. */
+#ifndef taskCHECK_FOR_STACK_OVERFLOW
+	#define taskCHECK_FOR_STACK_OVERFLOW()
+#endif
+
+
+
+#endif /* STACK_MACROS_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/queue.h ./libs/freertos/include/queue.h
--- a_bRU7kv/libs/freertos/include/queue.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/queue.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,1653 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#ifndef QUEUE_H
+#define QUEUE_H
+
+#ifndef INC_FREERTOS_H
+	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Type by which queues are referenced.  For example, a call to xQueueCreate()
+ * returns an QueueHandle_t variable that can then be used as a parameter to
+ * xQueueSend(), xQueueReceive(), etc.
+ */
+typedef void * QueueHandle_t;
+
+/**
+ * Type by which queue sets are referenced.  For example, a call to
+ * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
+ * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
+ */
+typedef void * QueueSetHandle_t;
+
+/**
+ * Queue sets can contain both queues and semaphores, so the
+ * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
+ * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
+ */
+typedef void * QueueSetMemberHandle_t;
+
+/* For internal use only. */
+#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
+#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
+#define queueOVERWRITE			( ( BaseType_t ) 2 )
+
+/* For internal use only.  These definitions *must* match those in queue.c. */
+#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
+#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
+#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
+#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
+#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
+#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
+
+/**
+ * queue. h
+ * <pre>
+ QueueHandle_t xQueueCreate(
+							  UBaseType_t uxQueueLength,
+							  UBaseType_t uxItemSize
+						  );
+ * </pre>
+ *
+ * Creates a new queue instance, and returns a handle by which the new queue
+ * can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, queues use two blocks of
+ * memory.  The first block is used to hold the queue's data structures.  The
+ * second block is used to hold items placed into the queue.  If a queue is
+ * created using xQueueCreate() then both blocks of memory are automatically
+ * dynamically allocated inside the xQueueCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a queue is created using
+ * xQueueCreateStatic() then the application writer must provide the memory that
+ * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
+ * be created without using any dynamic memory allocation.
+ *
+ * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
+ *
+ * @param uxQueueLength The maximum number of items that the queue can contain.
+ *
+ * @param uxItemSize The number of bytes each item in the queue will require.
+ * Items are queued by copy, not by reference, so this is the number of bytes
+ * that will be copied for each posted item.  Each item on the queue must be
+ * the same size.
+ *
+ * @return If the queue is successfully create then a handle to the newly
+ * created queue is returned.  If the queue cannot be created then 0 is
+ * returned.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ };
+
+ void vATask( void *pvParameters )
+ {
+ QueueHandle_t xQueue1, xQueue2;
+
+	// Create a queue capable of containing 10 uint32_t values.
+	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
+	if( xQueue1 == 0 )
+	{
+		// Queue was not created and must not be used.
+	}
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
+	if( xQueue2 == 0 )
+	{
+		// Queue was not created and must not be used.
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueCreate xQueueCreate
+ * \ingroup QueueManagement
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
+#endif
+
+/**
+ * queue. h
+ * <pre>
+ QueueHandle_t xQueueCreateStatic(
+							  UBaseType_t uxQueueLength,
+							  UBaseType_t uxItemSize,
+							  uint8_t *pucQueueStorageBuffer,
+							  StaticQueue_t *pxQueueBuffer
+						  );
+ * </pre>
+ *
+ * Creates a new queue instance, and returns a handle by which the new queue
+ * can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, queues use two blocks of
+ * memory.  The first block is used to hold the queue's data structures.  The
+ * second block is used to hold items placed into the queue.  If a queue is
+ * created using xQueueCreate() then both blocks of memory are automatically
+ * dynamically allocated inside the xQueueCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a queue is created using
+ * xQueueCreateStatic() then the application writer must provide the memory that
+ * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
+ * be created without using any dynamic memory allocation.
+ *
+ * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
+ *
+ * @param uxQueueLength The maximum number of items that the queue can contain.
+ *
+ * @param uxItemSize The number of bytes each item in the queue will require.
+ * Items are queued by copy, not by reference, so this is the number of bytes
+ * that will be copied for each posted item.  Each item on the queue must be
+ * the same size.
+ *
+ * @param pucQueueStorageBuffer If uxItemSize is not zero then
+ * pucQueueStorageBuffer must point to a uint8_t array that is at least large
+ * enough to hold the maximum number of items that can be in the queue at any
+ * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
+ * zero then pucQueueStorageBuffer can be NULL.
+ *
+ * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
+ * will be used to hold the queue's data structure.
+ *
+ * @return If the queue is created then a handle to the created queue is
+ * returned.  If pxQueueBuffer is NULL then NULL is returned.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ };
+
+ #define QUEUE_LENGTH 10
+ #define ITEM_SIZE sizeof( uint32_t )
+
+ // xQueueBuffer will hold the queue structure.
+ StaticQueue_t xQueueBuffer;
+
+ // ucQueueStorage will hold the items posted to the queue.  Must be at least
+ // [(queue length) * ( queue item size)] bytes long.
+ uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
+
+ void vATask( void *pvParameters )
+ {
+ QueueHandle_t xQueue1;
+
+	// Create a queue capable of containing 10 uint32_t values.
+	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
+							ITEM_SIZE	  // The size of each item in the queue
+							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
+							&xQueueBuffer ); // The buffer that will hold the queue structure.
+
+	// The queue is guaranteed to be created successfully as no dynamic memory
+	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueCreateStatic xQueueCreateStatic
+ * \ingroup QueueManagement
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueSendToToFront(
+								   QueueHandle_t	xQueue,
+								   const void		*pvItemToQueue,
+								   TickType_t		xTicksToWait
+							   );
+ * </pre>
+ *
+ * Post an item to the front of a queue.  The item is queued by copy, not by
+ * reference.  This function must not be called from an interrupt service
+ * routine.  See xQueueSendFromISR () for an alternative which may be used
+ * in an ISR.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param xTicksToWait The maximum amount of time the task should block
+ * waiting for space to become available on the queue, should it already
+ * be full.  The call will return immediately if this is set to 0 and the
+ * queue is full.  The time is defined in tick periods so the constant
+ * portTICK_PERIOD_MS should be used to convert to real time if this is required.
+ *
+ * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ } xMessage;
+
+ uint32_t ulVar = 10UL;
+
+ void vATask( void *pvParameters )
+ {
+ QueueHandle_t xQueue1, xQueue2;
+ struct AMessage *pxMessage;
+
+	// Create a queue capable of containing 10 uint32_t values.
+	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
+
+	// ...
+
+	if( xQueue1 != 0 )
+	{
+		// Send an uint32_t.  Wait for 10 ticks for space to become
+		// available if necessary.
+		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
+		{
+			// Failed to post the message, even after 10 ticks.
+		}
+	}
+
+	if( xQueue2 != 0 )
+	{
+		// Send a pointer to a struct AMessage object.  Don't block if the
+		// queue is already full.
+		pxMessage = & xMessage;
+		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueSend xQueueSend
+ * \ingroup QueueManagement
+ */
+#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueSendToBack(
+								   QueueHandle_t	xQueue,
+								   const void		*pvItemToQueue,
+								   TickType_t		xTicksToWait
+							   );
+ * </pre>
+ *
+ * This is a macro that calls xQueueGenericSend().
+ *
+ * Post an item to the back of a queue.  The item is queued by copy, not by
+ * reference.  This function must not be called from an interrupt service
+ * routine.  See xQueueSendFromISR () for an alternative which may be used
+ * in an ISR.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param xTicksToWait The maximum amount of time the task should block
+ * waiting for space to become available on the queue, should it already
+ * be full.  The call will return immediately if this is set to 0 and the queue
+ * is full.  The  time is defined in tick periods so the constant
+ * portTICK_PERIOD_MS should be used to convert to real time if this is required.
+ *
+ * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ } xMessage;
+
+ uint32_t ulVar = 10UL;
+
+ void vATask( void *pvParameters )
+ {
+ QueueHandle_t xQueue1, xQueue2;
+ struct AMessage *pxMessage;
+
+	// Create a queue capable of containing 10 uint32_t values.
+	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
+
+	// ...
+
+	if( xQueue1 != 0 )
+	{
+		// Send an uint32_t.  Wait for 10 ticks for space to become
+		// available if necessary.
+		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
+		{
+			// Failed to post the message, even after 10 ticks.
+		}
+	}
+
+	if( xQueue2 != 0 )
+	{
+		// Send a pointer to a struct AMessage object.  Don't block if the
+		// queue is already full.
+		pxMessage = & xMessage;
+		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueSend xQueueSend
+ * \ingroup QueueManagement
+ */
+#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueSend(
+							  QueueHandle_t xQueue,
+							  const void * pvItemToQueue,
+							  TickType_t xTicksToWait
+						 );
+ * </pre>
+ *
+ * This is a macro that calls xQueueGenericSend().  It is included for
+ * backward compatibility with versions of FreeRTOS.org that did not
+ * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
+ * equivalent to xQueueSendToBack().
+ *
+ * Post an item on a queue.  The item is queued by copy, not by reference.
+ * This function must not be called from an interrupt service routine.
+ * See xQueueSendFromISR () for an alternative which may be used in an ISR.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param xTicksToWait The maximum amount of time the task should block
+ * waiting for space to become available on the queue, should it already
+ * be full.  The call will return immediately if this is set to 0 and the
+ * queue is full.  The time is defined in tick periods so the constant
+ * portTICK_PERIOD_MS should be used to convert to real time if this is required.
+ *
+ * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ } xMessage;
+
+ uint32_t ulVar = 10UL;
+
+ void vATask( void *pvParameters )
+ {
+ QueueHandle_t xQueue1, xQueue2;
+ struct AMessage *pxMessage;
+
+	// Create a queue capable of containing 10 uint32_t values.
+	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
+
+	// ...
+
+	if( xQueue1 != 0 )
+	{
+		// Send an uint32_t.  Wait for 10 ticks for space to become
+		// available if necessary.
+		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
+		{
+			// Failed to post the message, even after 10 ticks.
+		}
+	}
+
+	if( xQueue2 != 0 )
+	{
+		// Send a pointer to a struct AMessage object.  Don't block if the
+		// queue is already full.
+		pxMessage = & xMessage;
+		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueSend xQueueSend
+ * \ingroup QueueManagement
+ */
+#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueOverwrite(
+							  QueueHandle_t xQueue,
+							  const void * pvItemToQueue
+						 );
+ * </pre>
+ *
+ * Only for use with queues that have a length of one - so the queue is either
+ * empty or full.
+ *
+ * Post an item on a queue.  If the queue is already full then overwrite the
+ * value held in the queue.  The item is queued by copy, not by reference.
+ *
+ * This function must not be called from an interrupt service routine.
+ * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
+ *
+ * @param xQueue The handle of the queue to which the data is being sent.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
+ * therefore has the same return values as xQueueSendToFront().  However, pdPASS
+ * is the only value that can be returned because xQueueOverwrite() will write
+ * to the queue even when the queue is already full.
+ *
+ * Example usage:
+   <pre>
+
+ void vFunction( void *pvParameters )
+ {
+ QueueHandle_t xQueue;
+ uint32_t ulVarToSend, ulValReceived;
+
+	// Create a queue to hold one uint32_t value.  It is strongly
+	// recommended *not* to use xQueueOverwrite() on queues that can
+	// contain more than one value, and doing so will trigger an assertion
+	// if configASSERT() is defined.
+	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
+
+	// Write the value 10 to the queue using xQueueOverwrite().
+	ulVarToSend = 10;
+	xQueueOverwrite( xQueue, &ulVarToSend );
+
+	// Peeking the queue should now return 10, but leave the value 10 in
+	// the queue.  A block time of zero is used as it is known that the
+	// queue holds a value.
+	ulValReceived = 0;
+	xQueuePeek( xQueue, &ulValReceived, 0 );
+
+	if( ulValReceived != 10 )
+	{
+		// Error unless the item was removed by a different task.
+	}
+
+	// The queue is still full.  Use xQueueOverwrite() to overwrite the
+	// value held in the queue with 100.
+	ulVarToSend = 100;
+	xQueueOverwrite( xQueue, &ulVarToSend );
+
+	// This time read from the queue, leaving the queue empty once more.
+	// A block time of 0 is used again.
+	xQueueReceive( xQueue, &ulValReceived, 0 );
+
+	// The value read should be the last value written, even though the
+	// queue was already full when the value was written.
+	if( ulValReceived != 100 )
+	{
+		// Error!
+	}
+
+	// ...
+}
+ </pre>
+ * \defgroup xQueueOverwrite xQueueOverwrite
+ * \ingroup QueueManagement
+ */
+#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
+
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueGenericSend(
+									QueueHandle_t xQueue,
+									const void * pvItemToQueue,
+									TickType_t xTicksToWait
+									BaseType_t xCopyPosition
+								);
+ * </pre>
+ *
+ * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
+ * xQueueSendToBack() are used in place of calling this function directly.
+ *
+ * Post an item on a queue.  The item is queued by copy, not by reference.
+ * This function must not be called from an interrupt service routine.
+ * See xQueueSendFromISR () for an alternative which may be used in an ISR.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param xTicksToWait The maximum amount of time the task should block
+ * waiting for space to become available on the queue, should it already
+ * be full.  The call will return immediately if this is set to 0 and the
+ * queue is full.  The time is defined in tick periods so the constant
+ * portTICK_PERIOD_MS should be used to convert to real time if this is required.
+ *
+ * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
+ * item at the back of the queue, or queueSEND_TO_FRONT to place the item
+ * at the front of the queue (for high priority messages).
+ *
+ * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ } xMessage;
+
+ uint32_t ulVar = 10UL;
+
+ void vATask( void *pvParameters )
+ {
+ QueueHandle_t xQueue1, xQueue2;
+ struct AMessage *pxMessage;
+
+	// Create a queue capable of containing 10 uint32_t values.
+	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
+
+	// ...
+
+	if( xQueue1 != 0 )
+	{
+		// Send an uint32_t.  Wait for 10 ticks for space to become
+		// available if necessary.
+		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
+		{
+			// Failed to post the message, even after 10 ticks.
+		}
+	}
+
+	if( xQueue2 != 0 )
+	{
+		// Send a pointer to a struct AMessage object.  Don't block if the
+		// queue is already full.
+		pxMessage = & xMessage;
+		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueSend xQueueSend
+ * \ingroup QueueManagement
+ */
+BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueuePeek(
+							 QueueHandle_t xQueue,
+							 void * const pvBuffer,
+							 TickType_t xTicksToWait
+						 );</pre>
+ *
+ * Receive an item from a queue without removing the item from the queue.
+ * The item is received by copy so a buffer of adequate size must be
+ * provided.  The number of bytes copied into the buffer was defined when
+ * the queue was created.
+ *
+ * Successfully received items remain on the queue so will be returned again
+ * by the next call, or a call to xQueueReceive().
+ *
+ * This macro must not be used in an interrupt service routine.  See
+ * xQueuePeekFromISR() for an alternative that can be called from an interrupt
+ * service routine.
+ *
+ * @param xQueue The handle to the queue from which the item is to be
+ * received.
+ *
+ * @param pvBuffer Pointer to the buffer into which the received item will
+ * be copied.
+ *
+ * @param xTicksToWait The maximum amount of time the task should block
+ * waiting for an item to receive should the queue be empty at the time
+ * of the call.	 The time is defined in tick periods so the constant
+ * portTICK_PERIOD_MS should be used to convert to real time if this is required.
+ * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
+ * is empty.
+ *
+ * @return pdTRUE if an item was successfully received from the queue,
+ * otherwise pdFALSE.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ } xMessage;
+
+ QueueHandle_t xQueue;
+
+ // Task to create a queue and post a value.
+ void vATask( void *pvParameters )
+ {
+ struct AMessage *pxMessage;
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
+	if( xQueue == 0 )
+	{
+		// Failed to create the queue.
+	}
+
+	// ...
+
+	// Send a pointer to a struct AMessage object.  Don't block if the
+	// queue is already full.
+	pxMessage = & xMessage;
+	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
+
+	// ... Rest of task code.
+ }
+
+ // Task to peek the data from the queue.
+ void vADifferentTask( void *pvParameters )
+ {
+ struct AMessage *pxRxedMessage;
+
+	if( xQueue != 0 )
+	{
+		// Peek a message on the created queue.  Block for 10 ticks if a
+		// message is not immediately available.
+		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
+		{
+			// pcRxedMessage now points to the struct AMessage variable posted
+			// by vATask, but the item still remains on the queue.
+		}
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueuePeek xQueuePeek
+ * \ingroup QueueManagement
+ */
+BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueuePeekFromISR(
+									QueueHandle_t xQueue,
+									void *pvBuffer,
+								);</pre>
+ *
+ * A version of xQueuePeek() that can be called from an interrupt service
+ * routine (ISR).
+ *
+ * Receive an item from a queue without removing the item from the queue.
+ * The item is received by copy so a buffer of adequate size must be
+ * provided.  The number of bytes copied into the buffer was defined when
+ * the queue was created.
+ *
+ * Successfully received items remain on the queue so will be returned again
+ * by the next call, or a call to xQueueReceive().
+ *
+ * @param xQueue The handle to the queue from which the item is to be
+ * received.
+ *
+ * @param pvBuffer Pointer to the buffer into which the received item will
+ * be copied.
+ *
+ * @return pdTRUE if an item was successfully received from the queue,
+ * otherwise pdFALSE.
+ *
+ * \defgroup xQueuePeekFromISR xQueuePeekFromISR
+ * \ingroup QueueManagement
+ */
+BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueReceive(
+								 QueueHandle_t xQueue,
+								 void *pvBuffer,
+								 TickType_t xTicksToWait
+							);</pre>
+ *
+ * Receive an item from a queue.  The item is received by copy so a buffer of
+ * adequate size must be provided.  The number of bytes copied into the buffer
+ * was defined when the queue was created.
+ *
+ * Successfully received items are removed from the queue.
+ *
+ * This function must not be used in an interrupt service routine.  See
+ * xQueueReceiveFromISR for an alternative that can.
+ *
+ * @param xQueue The handle to the queue from which the item is to be
+ * received.
+ *
+ * @param pvBuffer Pointer to the buffer into which the received item will
+ * be copied.
+ *
+ * @param xTicksToWait The maximum amount of time the task should block
+ * waiting for an item to receive should the queue be empty at the time
+ * of the call.	 xQueueReceive() will return immediately if xTicksToWait
+ * is zero and the queue is empty.  The time is defined in tick periods so the
+ * constant portTICK_PERIOD_MS should be used to convert to real time if this is
+ * required.
+ *
+ * @return pdTRUE if an item was successfully received from the queue,
+ * otherwise pdFALSE.
+ *
+ * Example usage:
+   <pre>
+ struct AMessage
+ {
+	char ucMessageID;
+	char ucData[ 20 ];
+ } xMessage;
+
+ QueueHandle_t xQueue;
+
+ // Task to create a queue and post a value.
+ void vATask( void *pvParameters )
+ {
+ struct AMessage *pxMessage;
+
+	// Create a queue capable of containing 10 pointers to AMessage structures.
+	// These should be passed by pointer as they contain a lot of data.
+	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
+	if( xQueue == 0 )
+	{
+		// Failed to create the queue.
+	}
+
+	// ...
+
+	// Send a pointer to a struct AMessage object.  Don't block if the
+	// queue is already full.
+	pxMessage = & xMessage;
+	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
+
+	// ... Rest of task code.
+ }
+
+ // Task to receive from the queue.
+ void vADifferentTask( void *pvParameters )
+ {
+ struct AMessage *pxRxedMessage;
+
+	if( xQueue != 0 )
+	{
+		// Receive a message on the created queue.  Block for 10 ticks if a
+		// message is not immediately available.
+		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
+		{
+			// pcRxedMessage now points to the struct AMessage variable posted
+			// by vATask.
+		}
+	}
+
+	// ... Rest of task code.
+ }
+ </pre>
+ * \defgroup xQueueReceive xQueueReceive
+ * \ingroup QueueManagement
+ */
+BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
+ *
+ * Return the number of messages stored in a queue.
+ *
+ * @param xQueue A handle to the queue being queried.
+ *
+ * @return The number of messages available in the queue.
+ *
+ * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
+ * \ingroup QueueManagement
+ */
+UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
+ *
+ * Return the number of free spaces available in a queue.  This is equal to the
+ * number of items that can be sent to the queue before the queue becomes full
+ * if no items are removed.
+ *
+ * @param xQueue A handle to the queue being queried.
+ *
+ * @return The number of spaces available in the queue.
+ *
+ * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
+ * \ingroup QueueManagement
+ */
+UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
+ *
+ * Delete a queue - freeing all the memory allocated for storing of items
+ * placed on the queue.
+ *
+ * @param xQueue A handle to the queue to be deleted.
+ *
+ * \defgroup vQueueDelete vQueueDelete
+ * \ingroup QueueManagement
+ */
+void vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueSendToFrontFromISR(
+										 QueueHandle_t xQueue,
+										 const void *pvItemToQueue,
+										 BaseType_t *pxHigherPriorityTaskWoken
+									  );
+ </pre>
+ *
+ * This is a macro that calls xQueueGenericSendFromISR().
+ *
+ * Post an item to the front of a queue.  It is safe to use this macro from
+ * within an interrupt service routine.
+ *
+ * Items are queued by copy not reference so it is preferable to only
+ * queue small items, especially when called from an ISR.  In most cases
+ * it would be preferable to store a pointer to the item being queued.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @return pdTRUE if the data was successfully sent to the queue, otherwise
+ * errQUEUE_FULL.
+ *
+ * Example usage for buffered IO (where the ISR can obtain more than one value
+ * per call):
+   <pre>
+ void vBufferISR( void )
+ {
+ char cIn;
+ BaseType_t xHigherPrioritTaskWoken;
+
+	// We have not woken a task at the start of the ISR.
+	xHigherPriorityTaskWoken = pdFALSE;
+
+	// Loop until the buffer is empty.
+	do
+	{
+		// Obtain a byte from the buffer.
+		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
+
+		// Post the byte.
+		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
+
+	} while( portINPUT_BYTE( BUFFER_COUNT ) );
+
+	// Now the buffer is empty we can switch context if necessary.
+	if( xHigherPriorityTaskWoken )
+	{
+		taskYIELD ();
+	}
+ }
+ </pre>
+ *
+ * \defgroup xQueueSendFromISR xQueueSendFromISR
+ * \ingroup QueueManagement
+ */
+#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
+
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueSendToBackFromISR(
+										 QueueHandle_t xQueue,
+										 const void *pvItemToQueue,
+										 BaseType_t *pxHigherPriorityTaskWoken
+									  );
+ </pre>
+ *
+ * This is a macro that calls xQueueGenericSendFromISR().
+ *
+ * Post an item to the back of a queue.  It is safe to use this macro from
+ * within an interrupt service routine.
+ *
+ * Items are queued by copy not reference so it is preferable to only
+ * queue small items, especially when called from an ISR.  In most cases
+ * it would be preferable to store a pointer to the item being queued.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @return pdTRUE if the data was successfully sent to the queue, otherwise
+ * errQUEUE_FULL.
+ *
+ * Example usage for buffered IO (where the ISR can obtain more than one value
+ * per call):
+   <pre>
+ void vBufferISR( void )
+ {
+ char cIn;
+ BaseType_t xHigherPriorityTaskWoken;
+
+	// We have not woken a task at the start of the ISR.
+	xHigherPriorityTaskWoken = pdFALSE;
+
+	// Loop until the buffer is empty.
+	do
+	{
+		// Obtain a byte from the buffer.
+		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
+
+		// Post the byte.
+		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
+
+	} while( portINPUT_BYTE( BUFFER_COUNT ) );
+
+	// Now the buffer is empty we can switch context if necessary.
+	if( xHigherPriorityTaskWoken )
+	{
+		taskYIELD ();
+	}
+ }
+ </pre>
+ *
+ * \defgroup xQueueSendFromISR xQueueSendFromISR
+ * \ingroup QueueManagement
+ */
+#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueOverwriteFromISR(
+							  QueueHandle_t xQueue,
+							  const void * pvItemToQueue,
+							  BaseType_t *pxHigherPriorityTaskWoken
+						 );
+ * </pre>
+ *
+ * A version of xQueueOverwrite() that can be used in an interrupt service
+ * routine (ISR).
+ *
+ * Only for use with queues that can hold a single item - so the queue is either
+ * empty or full.
+ *
+ * Post an item on a queue.  If the queue is already full then overwrite the
+ * value held in the queue.  The item is queued by copy, not by reference.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @return xQueueOverwriteFromISR() is a macro that calls
+ * xQueueGenericSendFromISR(), and therefore has the same return values as
+ * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
+ * returned because xQueueOverwriteFromISR() will write to the queue even when
+ * the queue is already full.
+ *
+ * Example usage:
+   <pre>
+
+ QueueHandle_t xQueue;
+
+ void vFunction( void *pvParameters )
+ {
+ 	// Create a queue to hold one uint32_t value.  It is strongly
+	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
+	// contain more than one value, and doing so will trigger an assertion
+	// if configASSERT() is defined.
+	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
+}
+
+void vAnInterruptHandler( void )
+{
+// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
+BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+uint32_t ulVarToSend, ulValReceived;
+
+	// Write the value 10 to the queue using xQueueOverwriteFromISR().
+	ulVarToSend = 10;
+	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
+
+	// The queue is full, but calling xQueueOverwriteFromISR() again will still
+	// pass because the value held in the queue will be overwritten with the
+	// new value.
+	ulVarToSend = 100;
+	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
+
+	// Reading from the queue will now return 100.
+
+	// ...
+
+	if( xHigherPrioritytaskWoken == pdTRUE )
+	{
+		// Writing to the queue caused a task to unblock and the unblocked task
+		// has a priority higher than or equal to the priority of the currently
+		// executing task (the task this interrupt interrupted).  Perform a context
+		// switch so this interrupt returns directly to the unblocked task.
+		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
+	}
+}
+ </pre>
+ * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
+ * \ingroup QueueManagement
+ */
+#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueSendFromISR(
+									 QueueHandle_t xQueue,
+									 const void *pvItemToQueue,
+									 BaseType_t *pxHigherPriorityTaskWoken
+								);
+ </pre>
+ *
+ * This is a macro that calls xQueueGenericSendFromISR().  It is included
+ * for backward compatibility with versions of FreeRTOS.org that did not
+ * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
+ * macros.
+ *
+ * Post an item to the back of a queue.  It is safe to use this function from
+ * within an interrupt service routine.
+ *
+ * Items are queued by copy not reference so it is preferable to only
+ * queue small items, especially when called from an ISR.  In most cases
+ * it would be preferable to store a pointer to the item being queued.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @return pdTRUE if the data was successfully sent to the queue, otherwise
+ * errQUEUE_FULL.
+ *
+ * Example usage for buffered IO (where the ISR can obtain more than one value
+ * per call):
+   <pre>
+ void vBufferISR( void )
+ {
+ char cIn;
+ BaseType_t xHigherPriorityTaskWoken;
+
+	// We have not woken a task at the start of the ISR.
+	xHigherPriorityTaskWoken = pdFALSE;
+
+	// Loop until the buffer is empty.
+	do
+	{
+		// Obtain a byte from the buffer.
+		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
+
+		// Post the byte.
+		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
+
+	} while( portINPUT_BYTE( BUFFER_COUNT ) );
+
+	// Now the buffer is empty we can switch context if necessary.
+	if( xHigherPriorityTaskWoken )
+	{
+		// Actual macro used here is port specific.
+		portYIELD_FROM_ISR ();
+	}
+ }
+ </pre>
+ *
+ * \defgroup xQueueSendFromISR xQueueSendFromISR
+ * \ingroup QueueManagement
+ */
+#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueGenericSendFromISR(
+										   QueueHandle_t		xQueue,
+										   const	void	*pvItemToQueue,
+										   BaseType_t	*pxHigherPriorityTaskWoken,
+										   BaseType_t	xCopyPosition
+									   );
+ </pre>
+ *
+ * It is preferred that the macros xQueueSendFromISR(),
+ * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
+ * of calling this function directly.  xQueueGiveFromISR() is an
+ * equivalent for use by semaphores that don't actually copy any data.
+ *
+ * Post an item on a queue.  It is safe to use this function from within an
+ * interrupt service routine.
+ *
+ * Items are queued by copy not reference so it is preferable to only
+ * queue small items, especially when called from an ISR.  In most cases
+ * it would be preferable to store a pointer to the item being queued.
+ *
+ * @param xQueue The handle to the queue on which the item is to be posted.
+ *
+ * @param pvItemToQueue A pointer to the item that is to be placed on the
+ * queue.  The size of the items the queue will hold was defined when the
+ * queue was created, so this many bytes will be copied from pvItemToQueue
+ * into the queue storage area.
+ *
+ * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
+ * item at the back of the queue, or queueSEND_TO_FRONT to place the item
+ * at the front of the queue (for high priority messages).
+ *
+ * @return pdTRUE if the data was successfully sent to the queue, otherwise
+ * errQUEUE_FULL.
+ *
+ * Example usage for buffered IO (where the ISR can obtain more than one value
+ * per call):
+   <pre>
+ void vBufferISR( void )
+ {
+ char cIn;
+ BaseType_t xHigherPriorityTaskWokenByPost;
+
+	// We have not woken a task at the start of the ISR.
+	xHigherPriorityTaskWokenByPost = pdFALSE;
+
+	// Loop until the buffer is empty.
+	do
+	{
+		// Obtain a byte from the buffer.
+		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
+
+		// Post each byte.
+		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
+
+	} while( portINPUT_BYTE( BUFFER_COUNT ) );
+
+	// Now the buffer is empty we can switch context if necessary.  Note that the
+	// name of the yield function required is port specific.
+	if( xHigherPriorityTaskWokenByPost )
+	{
+		taskYIELD_YIELD_FROM_ISR();
+	}
+ }
+ </pre>
+ *
+ * \defgroup xQueueSendFromISR xQueueSendFromISR
+ * \ingroup QueueManagement
+ */
+BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
+BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/**
+ * queue. h
+ * <pre>
+ BaseType_t xQueueReceiveFromISR(
+									   QueueHandle_t	xQueue,
+									   void	*pvBuffer,
+									   BaseType_t *pxTaskWoken
+								   );
+ * </pre>
+ *
+ * Receive an item from a queue.  It is safe to use this function from within an
+ * interrupt service routine.
+ *
+ * @param xQueue The handle to the queue from which the item is to be
+ * received.
+ *
+ * @param pvBuffer Pointer to the buffer into which the received item will
+ * be copied.
+ *
+ * @param pxTaskWoken A task may be blocked waiting for space to become
+ * available on the queue.  If xQueueReceiveFromISR causes such a task to
+ * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
+ * remain unchanged.
+ *
+ * @return pdTRUE if an item was successfully received from the queue,
+ * otherwise pdFALSE.
+ *
+ * Example usage:
+   <pre>
+
+ QueueHandle_t xQueue;
+
+ // Function to create a queue and post some values.
+ void vAFunction( void *pvParameters )
+ {
+ char cValueToPost;
+ const TickType_t xTicksToWait = ( TickType_t )0xff;
+
+	// Create a queue capable of containing 10 characters.
+	xQueue = xQueueCreate( 10, sizeof( char ) );
+	if( xQueue == 0 )
+	{
+		// Failed to create the queue.
+	}
+
+	// ...
+
+	// Post some characters that will be used within an ISR.  If the queue
+	// is full then this task will block for xTicksToWait ticks.
+	cValueToPost = 'a';
+	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
+	cValueToPost = 'b';
+	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
+
+	// ... keep posting characters ... this task may block when the queue
+	// becomes full.
+
+	cValueToPost = 'c';
+	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
+ }
+
+ // ISR that outputs all the characters received on the queue.
+ void vISR_Routine( void )
+ {
+ BaseType_t xTaskWokenByReceive = pdFALSE;
+ char cRxedChar;
+
+	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
+	{
+		// A character was received.  Output the character now.
+		vOutputCharacter( cRxedChar );
+
+		// If removing the character from the queue woke the task that was
+		// posting onto the queue cTaskWokenByReceive will have been set to
+		// pdTRUE.  No matter how many times this loop iterates only one
+		// task will be woken.
+	}
+
+	if( cTaskWokenByPost != ( char ) pdFALSE;
+	{
+		taskYIELD ();
+	}
+ }
+ </pre>
+ * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
+ * \ingroup QueueManagement
+ */
+BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/*
+ * Utilities to query queues that are safe to use from an ISR.  These utilities
+ * should be used only from witin an ISR, or within a critical section.
+ */
+BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+
+/*
+ * The functions defined above are for passing data to and from tasks.  The
+ * functions below are the equivalents for passing data to and from
+ * co-routines.
+ *
+ * These functions are called from the co-routine macro implementation and
+ * should not be called directly from application code.  Instead use the macro
+ * wrappers defined within croutine.h.
+ */
+BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
+BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
+BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
+BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
+
+/*
+ * For internal use only.  Use xSemaphoreCreateMutex(),
+ * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
+ * these functions directly.
+ */
+QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
+QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
+QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
+QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
+BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+void* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
+void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
+
+/*
+ * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
+ * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
+ */
+BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+BaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
+
+/*
+ * Reset a queue back to its original empty state.  The return value is now
+ * obsolete and is always set to pdPASS.
+ */
+#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
+
+/*
+ * The registry is provided as a means for kernel aware debuggers to
+ * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
+ * a queue, semaphore or mutex handle to the registry if you want the handle
+ * to be available to a kernel aware debugger.  If you are not using a kernel
+ * aware debugger then this function can be ignored.
+ *
+ * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
+ * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
+ * within FreeRTOSConfig.h for the registry to be available.  Its value
+ * does not effect the number of queues, semaphores and mutexes that can be
+ * created - just the number that the registry can hold.
+ *
+ * @param xQueue The handle of the queue being added to the registry.  This
+ * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
+ * handles can also be passed in here.
+ *
+ * @param pcName The name to be associated with the handle.  This is the
+ * name that the kernel aware debugger will display.  The queue registry only
+ * stores a pointer to the string - so the string must be persistent (global or
+ * preferably in ROM/Flash), not on the stack.
+ */
+#if( configQUEUE_REGISTRY_SIZE > 0 )
+	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+#endif
+
+/*
+ * The registry is provided as a means for kernel aware debuggers to
+ * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
+ * a queue, semaphore or mutex handle to the registry if you want the handle
+ * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
+ * remove the queue, semaphore or mutex from the register.  If you are not using
+ * a kernel aware debugger then this function can be ignored.
+ *
+ * @param xQueue The handle of the queue being removed from the registry.
+ */
+#if( configQUEUE_REGISTRY_SIZE > 0 )
+	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+#endif
+
+/*
+ * The queue registry is provided as a means for kernel aware debuggers to
+ * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
+ * up and return the name of a queue in the queue registry from the queue's
+ * handle.
+ *
+ * @param xQueue The handle of the queue the name of which will be returned.
+ * @return If the queue is in the registry then a pointer to the name of the
+ * queue is returned.  If the queue is not in the registry then NULL is
+ * returned.
+ */
+#if( configQUEUE_REGISTRY_SIZE > 0 )
+	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+#endif
+
+/*
+ * Generic version of the function used to creaet a queue using dynamic memory
+ * allocation.  This is called by other functions and macros that create other
+ * RTOS objects that use the queue structure as their base.
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
+#endif
+
+/*
+ * Generic version of the function used to creaet a queue using dynamic memory
+ * allocation.  This is called by other functions and macros that create other
+ * RTOS objects that use the queue structure as their base.
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
+#endif
+
+/*
+ * Queue sets provide a mechanism to allow a task to block (pend) on a read
+ * operation from multiple queues or semaphores simultaneously.
+ *
+ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
+ * function.
+ *
+ * A queue set must be explicitly created using a call to xQueueCreateSet()
+ * before it can be used.  Once created, standard FreeRTOS queues and semaphores
+ * can be added to the set using calls to xQueueAddToSet().
+ * xQueueSelectFromSet() is then used to determine which, if any, of the queues
+ * or semaphores contained in the set is in a state where a queue read or
+ * semaphore take operation would be successful.
+ *
+ * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
+ * for reasons why queue sets are very rarely needed in practice as there are
+ * simpler methods of blocking on multiple objects.
+ *
+ * Note 2:  Blocking on a queue set that contains a mutex will not cause the
+ * mutex holder to inherit the priority of the blocked task.
+ *
+ * Note 3:  An additional 4 bytes of RAM is required for each space in a every
+ * queue added to a queue set.  Therefore counting semaphores that have a high
+ * maximum count value should not be added to a queue set.
+ *
+ * Note 4:  A receive (in the case of a queue) or take (in the case of a
+ * semaphore) operation must not be performed on a member of a queue set unless
+ * a call to xQueueSelectFromSet() has first returned a handle to that set member.
+ *
+ * @param uxEventQueueLength Queue sets store events that occur on
+ * the queues and semaphores contained in the set.  uxEventQueueLength specifies
+ * the maximum number of events that can be queued at once.  To be absolutely
+ * certain that events are not lost uxEventQueueLength should be set to the
+ * total sum of the length of the queues added to the set, where binary
+ * semaphores and mutexes have a length of 1, and counting semaphores have a
+ * length set by their maximum count value.  Examples:
+ *  + If a queue set is to hold a queue of length 5, another queue of length 12,
+ *    and a binary semaphore, then uxEventQueueLength should be set to
+ *    (5 + 12 + 1), or 18.
+ *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
+ *    should be set to (1 + 1 + 1 ), or 3.
+ *  + If a queue set is to hold a counting semaphore that has a maximum count of
+ *    5, and a counting semaphore that has a maximum count of 3, then
+ *    uxEventQueueLength should be set to (5 + 3), or 8.
+ *
+ * @return If the queue set is created successfully then a handle to the created
+ * queue set is returned.  Otherwise NULL is returned.
+ */
+QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
+
+/*
+ * Adds a queue or semaphore to a queue set that was previously created by a
+ * call to xQueueCreateSet().
+ *
+ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
+ * function.
+ *
+ * Note 1:  A receive (in the case of a queue) or take (in the case of a
+ * semaphore) operation must not be performed on a member of a queue set unless
+ * a call to xQueueSelectFromSet() has first returned a handle to that set member.
+ *
+ * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
+ * the queue set (cast to an QueueSetMemberHandle_t type).
+ *
+ * @param xQueueSet The handle of the queue set to which the queue or semaphore
+ * is being added.
+ *
+ * @return If the queue or semaphore was successfully added to the queue set
+ * then pdPASS is returned.  If the queue could not be successfully added to the
+ * queue set because it is already a member of a different queue set then pdFAIL
+ * is returned.
+ */
+BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
+
+/*
+ * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
+ * be removed from a set if the queue or semaphore is empty.
+ *
+ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
+ * function.
+ *
+ * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
+ * from the queue set (cast to an QueueSetMemberHandle_t type).
+ *
+ * @param xQueueSet The handle of the queue set in which the queue or semaphore
+ * is included.
+ *
+ * @return If the queue or semaphore was successfully removed from the queue set
+ * then pdPASS is returned.  If the queue was not in the queue set, or the
+ * queue (or semaphore) was not empty, then pdFAIL is returned.
+ */
+BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
+
+/*
+ * xQueueSelectFromSet() selects from the members of a queue set a queue or
+ * semaphore that either contains data (in the case of a queue) or is available
+ * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
+ * allows a task to block (pend) on a read operation on all the queues and
+ * semaphores in a queue set simultaneously.
+ *
+ * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
+ * function.
+ *
+ * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
+ * for reasons why queue sets are very rarely needed in practice as there are
+ * simpler methods of blocking on multiple objects.
+ *
+ * Note 2:  Blocking on a queue set that contains a mutex will not cause the
+ * mutex holder to inherit the priority of the blocked task.
+ *
+ * Note 3:  A receive (in the case of a queue) or take (in the case of a
+ * semaphore) operation must not be performed on a member of a queue set unless
+ * a call to xQueueSelectFromSet() has first returned a handle to that set member.
+ *
+ * @param xQueueSet The queue set on which the task will (potentially) block.
+ *
+ * @param xTicksToWait The maximum time, in ticks, that the calling task will
+ * remain in the Blocked state (with other tasks executing) to wait for a member
+ * of the queue set to be ready for a successful queue read or semaphore take
+ * operation.
+ *
+ * @return xQueueSelectFromSet() will return the handle of a queue (cast to
+ * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
+ * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
+ * in the queue set that is available, or NULL if no such queue or semaphore
+ * exists before before the specified block time expires.
+ */
+QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/*
+ * A version of xQueueSelectFromSet() that can be used from an ISR.
+ */
+QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
+
+/* Not public API functions. */
+void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
+BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
+void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
+UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* QUEUE_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/semphr.h ./libs/freertos/include/semphr.h
--- a_bRU7kv/libs/freertos/include/semphr.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/semphr.h	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,1140 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef SEMAPHORE_H
+#define SEMAPHORE_H
+
+#ifndef INC_FREERTOS_H
+	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
+#endif
+
+#include "queue.h"
+
+typedef QueueHandle_t SemaphoreHandle_t;
+
+#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
+#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
+#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
+
+
+/**
+ * semphr. h
+ * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
+ *
+ * In many usage scenarios it is faster and more memory efficient to use a
+ * direct to task notification in place of a binary semaphore!
+ * http://www.freertos.org/RTOS-task-notifications.html
+ *
+ * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
+ * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
+ * the vSemaphoreCreateBinary() macro are created in a state such that the
+ * first call to 'take' the semaphore would pass, whereas binary semaphores
+ * created using xSemaphoreCreateBinary() are created in a state such that the
+ * the semaphore must first be 'given' before it can be 'taken'.
+ *
+ * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
+ * The queue length is 1 as this is a binary semaphore.  The data size is 0
+ * as we don't want to actually store any data - we just want to know if the
+ * queue is empty or full.
+ *
+ * This type of semaphore can be used for pure synchronisation between tasks or
+ * between an interrupt and a task.  The semaphore need not be given back once
+ * obtained, so one task/interrupt can continuously 'give' the semaphore while
+ * another continuously 'takes' the semaphore.  For this reason this type of
+ * semaphore does not use a priority inheritance mechanism.  For an alternative
+ * that does use priority inheritance see xSemaphoreCreateMutex().
+ *
+ * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore = NULL;
+
+ void vATask( void * pvParameters )
+ {
+    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
+    // This is a macro so pass the variable in directly.
+    vSemaphoreCreateBinary( xSemaphore );
+
+    if( xSemaphore != NULL )
+    {
+        // The semaphore was created successfully.
+        // The semaphore can now be used.
+    }
+ }
+ </pre>
+ * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
+ * \ingroup Semaphores
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	#define vSemaphoreCreateBinary( xSemaphore )																							\
+		{																																	\
+			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
+			if( ( xSemaphore ) != NULL )																									\
+			{																																\
+				( void ) xSemaphoreGive( ( xSemaphore ) );																					\
+			}																																\
+		}
+#endif
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
+ *
+ * Creates a new binary semaphore instance, and returns a handle by which the
+ * new semaphore can be referenced.
+ *
+ * In many usage scenarios it is faster and more memory efficient to use a
+ * direct to task notification in place of a binary semaphore!
+ * http://www.freertos.org/RTOS-task-notifications.html
+ *
+ * Internally, within the FreeRTOS implementation, binary semaphores use a block
+ * of memory, in which the semaphore structure is stored.  If a binary semaphore
+ * is created using xSemaphoreCreateBinary() then the required memory is
+ * automatically dynamically allocated inside the xSemaphoreCreateBinary()
+ * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
+ * is created using xSemaphoreCreateBinaryStatic() then the application writer
+ * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
+ * binary semaphore to be created without using any dynamic memory allocation.
+ *
+ * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
+ * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
+ * the vSemaphoreCreateBinary() macro are created in a state such that the
+ * first call to 'take' the semaphore would pass, whereas binary semaphores
+ * created using xSemaphoreCreateBinary() are created in a state such that the
+ * the semaphore must first be 'given' before it can be 'taken'.
+ *
+ * This type of semaphore can be used for pure synchronisation between tasks or
+ * between an interrupt and a task.  The semaphore need not be given back once
+ * obtained, so one task/interrupt can continuously 'give' the semaphore while
+ * another continuously 'takes' the semaphore.  For this reason this type of
+ * semaphore does not use a priority inheritance mechanism.  For an alternative
+ * that does use priority inheritance see xSemaphoreCreateMutex().
+ *
+ * @return Handle to the created semaphore, or NULL if the memory required to
+ * hold the semaphore's data structures could not be allocated.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore = NULL;
+
+ void vATask( void * pvParameters )
+ {
+    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
+    // This is a macro so pass the variable in directly.
+    xSemaphore = xSemaphoreCreateBinary();
+
+    if( xSemaphore != NULL )
+    {
+        // The semaphore was created successfully.
+        // The semaphore can now be used.
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateBinary xSemaphoreCreateBinary
+ * \ingroup Semaphores
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
+#endif
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer )</pre>
+ *
+ * Creates a new binary semaphore instance, and returns a handle by which the
+ * new semaphore can be referenced.
+ *
+ * NOTE: In many usage scenarios it is faster and more memory efficient to use a
+ * direct to task notification in place of a binary semaphore!
+ * http://www.freertos.org/RTOS-task-notifications.html
+ *
+ * Internally, within the FreeRTOS implementation, binary semaphores use a block
+ * of memory, in which the semaphore structure is stored.  If a binary semaphore
+ * is created using xSemaphoreCreateBinary() then the required memory is
+ * automatically dynamically allocated inside the xSemaphoreCreateBinary()
+ * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
+ * is created using xSemaphoreCreateBinaryStatic() then the application writer
+ * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
+ * binary semaphore to be created without using any dynamic memory allocation.
+ *
+ * This type of semaphore can be used for pure synchronisation between tasks or
+ * between an interrupt and a task.  The semaphore need not be given back once
+ * obtained, so one task/interrupt can continuously 'give' the semaphore while
+ * another continuously 'takes' the semaphore.  For this reason this type of
+ * semaphore does not use a priority inheritance mechanism.  For an alternative
+ * that does use priority inheritance see xSemaphoreCreateMutex().
+ *
+ * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
+ * which will then be used to hold the semaphore's data structure, removing the
+ * need for the memory to be allocated dynamically.
+ *
+ * @return If the semaphore is created then a handle to the created semaphore is
+ * returned.  If pxSemaphoreBuffer is NULL then NULL is returned.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore = NULL;
+ StaticSemaphore_t xSemaphoreBuffer;
+
+ void vATask( void * pvParameters )
+ {
+    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
+    // The semaphore's data structures will be placed in the xSemaphoreBuffer
+    // variable, the address of which is passed into the function.  The
+    // function's parameter is not NULL, so the function will not attempt any
+    // dynamic memory allocation, and therefore the function will not return
+    // return NULL.
+    xSemaphore = xSemaphoreCreateBinary( &xSemaphoreBuffer );
+
+    // Rest of task code goes here.
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateBinaryStatic xSemaphoreCreateBinaryStatic
+ * \ingroup Semaphores
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * semphr. h
+ * <pre>xSemaphoreTake(
+ *                   SemaphoreHandle_t xSemaphore,
+ *                   TickType_t xBlockTime
+ *               )</pre>
+ *
+ * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
+ * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
+ * xSemaphoreCreateCounting().
+ *
+ * @param xSemaphore A handle to the semaphore being taken - obtained when
+ * the semaphore was created.
+ *
+ * @param xBlockTime The time in ticks to wait for the semaphore to become
+ * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
+ * real time.  A block time of zero can be used to poll the semaphore.  A block
+ * time of portMAX_DELAY can be used to block indefinitely (provided
+ * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
+ *
+ * @return pdTRUE if the semaphore was obtained.  pdFALSE
+ * if xBlockTime expired without the semaphore becoming available.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore = NULL;
+
+ // A task that creates a semaphore.
+ void vATask( void * pvParameters )
+ {
+    // Create the semaphore to guard a shared resource.
+    xSemaphore = xSemaphoreCreateBinary();
+ }
+
+ // A task that uses the semaphore.
+ void vAnotherTask( void * pvParameters )
+ {
+    // ... Do other things.
+
+    if( xSemaphore != NULL )
+    {
+        // See if we can obtain the semaphore.  If the semaphore is not available
+        // wait 10 ticks to see if it becomes free.
+        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
+        {
+            // We were able to obtain the semaphore and can now access the
+            // shared resource.
+
+            // ...
+
+            // We have finished accessing the shared resource.  Release the
+            // semaphore.
+            xSemaphoreGive( xSemaphore );
+        }
+        else
+        {
+            // We could not obtain the semaphore and can therefore not access
+            // the shared resource safely.
+        }
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreTake xSemaphoreTake
+ * \ingroup Semaphores
+ */
+#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) )
+
+/**
+ * semphr. h
+ * xSemaphoreTakeRecursive(
+ *                          SemaphoreHandle_t xMutex,
+ *                          TickType_t xBlockTime
+ *                        )
+ *
+ * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
+ * The mutex must have previously been created using a call to
+ * xSemaphoreCreateRecursiveMutex();
+ *
+ * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
+ * macro to be available.
+ *
+ * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
+ *
+ * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
+ * doesn't become available again until the owner has called
+ * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
+ * if a task successfully 'takes' the same mutex 5 times then the mutex will
+ * not be available to any other task until it has also  'given' the mutex back
+ * exactly five times.
+ *
+ * @param xMutex A handle to the mutex being obtained.  This is the
+ * handle returned by xSemaphoreCreateRecursiveMutex();
+ *
+ * @param xBlockTime The time in ticks to wait for the semaphore to become
+ * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
+ * real time.  A block time of zero can be used to poll the semaphore.  If
+ * the task already owns the semaphore then xSemaphoreTakeRecursive() will
+ * return immediately no matter what the value of xBlockTime.
+ *
+ * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
+ * expired without the semaphore becoming available.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xMutex = NULL;
+
+ // A task that creates a mutex.
+ void vATask( void * pvParameters )
+ {
+    // Create the mutex to guard a shared resource.
+    xMutex = xSemaphoreCreateRecursiveMutex();
+ }
+
+ // A task that uses the mutex.
+ void vAnotherTask( void * pvParameters )
+ {
+    // ... Do other things.
+
+    if( xMutex != NULL )
+    {
+        // See if we can obtain the mutex.  If the mutex is not available
+        // wait 10 ticks to see if it becomes free.
+        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
+        {
+            // We were able to obtain the mutex and can now access the
+            // shared resource.
+
+            // ...
+            // For some reason due to the nature of the code further calls to
+            // xSemaphoreTakeRecursive() are made on the same mutex.  In real
+            // code these would not be just sequential calls as this would make
+            // no sense.  Instead the calls are likely to be buried inside
+            // a more complex call structure.
+            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
+            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
+
+            // The mutex has now been 'taken' three times, so will not be
+            // available to another task until it has also been given back
+            // three times.  Again it is unlikely that real code would have
+            // these calls sequentially, but instead buried in a more complex
+            // call structure.  This is just for illustrative purposes.
+            xSemaphoreGiveRecursive( xMutex );
+            xSemaphoreGiveRecursive( xMutex );
+            xSemaphoreGiveRecursive( xMutex );
+
+            // Now the mutex can be taken by other tasks.
+        }
+        else
+        {
+            // We could not obtain the mutex and can therefore not access
+            // the shared resource safely.
+        }
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
+ * \ingroup Semaphores
+ */
+#if( configUSE_RECURSIVE_MUTEXES == 1 )
+	#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
+#endif
+
+/**
+ * semphr. h
+ * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
+ *
+ * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
+ * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
+ * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
+ *
+ * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
+ * an alternative which can be used from an ISR.
+ *
+ * This macro must also not be used on semaphores created using
+ * xSemaphoreCreateRecursiveMutex().
+ *
+ * @param xSemaphore A handle to the semaphore being released.  This is the
+ * handle returned when the semaphore was created.
+ *
+ * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
+ * Semaphores are implemented using queues.  An error can occur if there is
+ * no space on the queue to post a message - indicating that the
+ * semaphore was not first obtained correctly.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore = NULL;
+
+ void vATask( void * pvParameters )
+ {
+    // Create the semaphore to guard a shared resource.
+    xSemaphore = vSemaphoreCreateBinary();
+
+    if( xSemaphore != NULL )
+    {
+        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
+        {
+            // We would expect this call to fail because we cannot give
+            // a semaphore without first "taking" it!
+        }
+
+        // Obtain the semaphore - don't block if the semaphore is not
+        // immediately available.
+        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
+        {
+            // We now have the semaphore and can access the shared resource.
+
+            // ...
+
+            // We have finished accessing the shared resource so can free the
+            // semaphore.
+            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
+            {
+                // We would not expect this call to fail because we must have
+                // obtained the semaphore to get here.
+            }
+        }
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreGive xSemaphoreGive
+ * \ingroup Semaphores
+ */
+#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
+
+/**
+ * semphr. h
+ * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
+ *
+ * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
+ * The mutex must have previously been created using a call to
+ * xSemaphoreCreateRecursiveMutex();
+ *
+ * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
+ * macro to be available.
+ *
+ * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
+ *
+ * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
+ * doesn't become available again until the owner has called
+ * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
+ * if a task successfully 'takes' the same mutex 5 times then the mutex will
+ * not be available to any other task until it has also  'given' the mutex back
+ * exactly five times.
+ *
+ * @param xMutex A handle to the mutex being released, or 'given'.  This is the
+ * handle returned by xSemaphoreCreateMutex();
+ *
+ * @return pdTRUE if the semaphore was given.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xMutex = NULL;
+
+ // A task that creates a mutex.
+ void vATask( void * pvParameters )
+ {
+    // Create the mutex to guard a shared resource.
+    xMutex = xSemaphoreCreateRecursiveMutex();
+ }
+
+ // A task that uses the mutex.
+ void vAnotherTask( void * pvParameters )
+ {
+    // ... Do other things.
+
+    if( xMutex != NULL )
+    {
+        // See if we can obtain the mutex.  If the mutex is not available
+        // wait 10 ticks to see if it becomes free.
+        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
+        {
+            // We were able to obtain the mutex and can now access the
+            // shared resource.
+
+            // ...
+            // For some reason due to the nature of the code further calls to
+			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
+			// code these would not be just sequential calls as this would make
+			// no sense.  Instead the calls are likely to be buried inside
+			// a more complex call structure.
+            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
+            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
+
+            // The mutex has now been 'taken' three times, so will not be
+			// available to another task until it has also been given back
+			// three times.  Again it is unlikely that real code would have
+			// these calls sequentially, it would be more likely that the calls
+			// to xSemaphoreGiveRecursive() would be called as a call stack
+			// unwound.  This is just for demonstrative purposes.
+            xSemaphoreGiveRecursive( xMutex );
+			xSemaphoreGiveRecursive( xMutex );
+			xSemaphoreGiveRecursive( xMutex );
+
+			// Now the mutex can be taken by other tasks.
+        }
+        else
+        {
+            // We could not obtain the mutex and can therefore not access
+            // the shared resource safely.
+        }
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
+ * \ingroup Semaphores
+ */
+#if( configUSE_RECURSIVE_MUTEXES == 1 )
+	#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
+#endif
+
+/**
+ * semphr. h
+ * <pre>
+ xSemaphoreGiveFromISR(
+                          SemaphoreHandle_t xSemaphore,
+                          BaseType_t *pxHigherPriorityTaskWoken
+                      )</pre>
+ *
+ * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
+ * created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().
+ *
+ * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
+ * must not be used with this macro.
+ *
+ * This macro can be used from an ISR.
+ *
+ * @param xSemaphore A handle to the semaphore being released.  This is the
+ * handle returned when the semaphore was created.
+ *
+ * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
+ *
+ * Example usage:
+ <pre>
+ \#define LONG_TIME 0xffff
+ \#define TICKS_TO_WAIT	10
+ SemaphoreHandle_t xSemaphore = NULL;
+
+ // Repetitive task.
+ void vATask( void * pvParameters )
+ {
+    for( ;; )
+    {
+        // We want this task to run every 10 ticks of a timer.  The semaphore
+        // was created before this task was started.
+
+        // Block waiting for the semaphore to become available.
+        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
+        {
+            // It is time to execute.
+
+            // ...
+
+            // We have finished our task.  Return to the top of the loop where
+            // we will block on the semaphore until it is time to execute
+            // again.  Note when using the semaphore for synchronisation with an
+			// ISR in this manner there is no need to 'give' the semaphore back.
+        }
+    }
+ }
+
+ // Timer ISR
+ void vTimerISR( void * pvParameters )
+ {
+ static uint8_t ucLocalTickCount = 0;
+ static BaseType_t xHigherPriorityTaskWoken;
+
+    // A timer tick has occurred.
+
+    // ... Do other time functions.
+
+    // Is it time for vATask () to run?
+	xHigherPriorityTaskWoken = pdFALSE;
+    ucLocalTickCount++;
+    if( ucLocalTickCount >= TICKS_TO_WAIT )
+    {
+        // Unblock the task by releasing the semaphore.
+        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
+
+        // Reset the count so we release the semaphore again in 10 ticks time.
+        ucLocalTickCount = 0;
+    }
+
+    if( xHigherPriorityTaskWoken != pdFALSE )
+    {
+        // We can force a context switch here.  Context switching from an
+        // ISR uses port specific syntax.  Check the demo task for your port
+        // to find the syntax required.
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
+ * \ingroup Semaphores
+ */
+#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
+
+/**
+ * semphr. h
+ * <pre>
+ xSemaphoreTakeFromISR(
+                          SemaphoreHandle_t xSemaphore,
+                          BaseType_t *pxHigherPriorityTaskWoken
+                      )</pre>
+ *
+ * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
+ * previously been created with a call to xSemaphoreCreateBinary() or
+ * xSemaphoreCreateCounting().
+ *
+ * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
+ * must not be used with this macro.
+ *
+ * This macro can be used from an ISR, however taking a semaphore from an ISR
+ * is not a common operation.  It is likely to only be useful when taking a
+ * counting semaphore when an interrupt is obtaining an object from a resource
+ * pool (when the semaphore count indicates the number of resources available).
+ *
+ * @param xSemaphore A handle to the semaphore being taken.  This is the
+ * handle returned when the semaphore was created.
+ *
+ * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
+ * to unblock, and the unblocked task has a priority higher than the currently
+ * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
+ * a context switch should be requested before the interrupt is exited.
+ *
+ * @return pdTRUE if the semaphore was successfully taken, otherwise
+ * pdFALSE
+ */
+#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
+ *
+ * Creates a new mutex type semaphore instance, and returns a handle by which
+ * the new mutex can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, mutex semaphores use a block
+ * of memory, in which the mutex structure is stored.  If a mutex is created
+ * using xSemaphoreCreateMutex() then the required memory is automatically
+ * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
+ * http://www.freertos.org/a00111.html).  If a mutex is created using
+ * xSemaphoreCreateMutexStatic() then the application writer must provided the
+ * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
+ * without using any dynamic memory allocation.
+ *
+ * Mutexes created using this function can be accessed using the xSemaphoreTake()
+ * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
+ * xSemaphoreGiveRecursive() macros must not be used.
+ *
+ * This type of semaphore uses a priority inheritance mechanism so a task
+ * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
+ * semaphore it is no longer required.
+ *
+ * Mutex type semaphores cannot be used from within interrupt service routines.
+ *
+ * See xSemaphoreCreateBinary() for an alternative implementation that can be
+ * used for pure synchronisation (where one task or interrupt always 'gives' the
+ * semaphore and another always 'takes' the semaphore) and from within interrupt
+ * service routines.
+ *
+ * @return If the mutex was successfully created then a handle to the created
+ * semaphore is returned.  If there was not enough heap to allocate the mutex
+ * data structures then NULL is returned.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore;
+
+ void vATask( void * pvParameters )
+ {
+    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
+    // This is a macro so pass the variable in directly.
+    xSemaphore = xSemaphoreCreateMutex();
+
+    if( xSemaphore != NULL )
+    {
+        // The semaphore was created successfully.
+        // The semaphore can now be used.
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateMutex xSemaphoreCreateMutex
+ * \ingroup Semaphores
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
+#endif
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
+ *
+ * Creates a new mutex type semaphore instance, and returns a handle by which
+ * the new mutex can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, mutex semaphores use a block
+ * of memory, in which the mutex structure is stored.  If a mutex is created
+ * using xSemaphoreCreateMutex() then the required memory is automatically
+ * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
+ * http://www.freertos.org/a00111.html).  If a mutex is created using
+ * xSemaphoreCreateMutexStatic() then the application writer must provided the
+ * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
+ * without using any dynamic memory allocation.
+ *
+ * Mutexes created using this function can be accessed using the xSemaphoreTake()
+ * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
+ * xSemaphoreGiveRecursive() macros must not be used.
+ *
+ * This type of semaphore uses a priority inheritance mechanism so a task
+ * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
+ * semaphore it is no longer required.
+ *
+ * Mutex type semaphores cannot be used from within interrupt service routines.
+ *
+ * See xSemaphoreCreateBinary() for an alternative implementation that can be
+ * used for pure synchronisation (where one task or interrupt always 'gives' the
+ * semaphore and another always 'takes' the semaphore) and from within interrupt
+ * service routines.
+ *
+ * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
+ * which will be used to hold the mutex's data structure, removing the need for
+ * the memory to be allocated dynamically.
+ *
+ * @return If the mutex was successfully created then a handle to the created
+ * mutex is returned.  If pxMutexBuffer was NULL then NULL is returned.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore;
+ StaticSemaphore_t xMutexBuffer;
+
+ void vATask( void * pvParameters )
+ {
+    // A mutex cannot be used before it has been created.  xMutexBuffer is
+    // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
+    // attempted.
+    xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );
+
+    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
+    // so there is no need to check it.
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateMutexStatic xSemaphoreCreateMutexStatic
+ * \ingroup Semaphores
+ */
+ #if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
+ *
+ * Creates a new recursive mutex type semaphore instance, and returns a handle
+ * by which the new recursive mutex can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, recursive mutexs use a block
+ * of memory, in which the mutex structure is stored.  If a recursive mutex is
+ * created using xSemaphoreCreateRecursiveMutex() then the required memory is
+ * automatically dynamically allocated inside the
+ * xSemaphoreCreateRecursiveMutex() function.  (see
+ * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
+ * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
+ * provide the memory that will get used by the mutex.
+ * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
+ * be created without using any dynamic memory allocation.
+ *
+ * Mutexes created using this macro can be accessed using the
+ * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
+ * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
+ *
+ * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
+ * doesn't become available again until the owner has called
+ * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
+ * if a task successfully 'takes' the same mutex 5 times then the mutex will
+ * not be available to any other task until it has also  'given' the mutex back
+ * exactly five times.
+ *
+ * This type of semaphore uses a priority inheritance mechanism so a task
+ * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
+ * semaphore it is no longer required.
+ *
+ * Mutex type semaphores cannot be used from within interrupt service routines.
+ *
+ * See xSemaphoreCreateBinary() for an alternative implementation that can be
+ * used for pure synchronisation (where one task or interrupt always 'gives' the
+ * semaphore and another always 'takes' the semaphore) and from within interrupt
+ * service routines.
+ *
+ * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
+ * SemaphoreHandle_t.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore;
+
+ void vATask( void * pvParameters )
+ {
+    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
+    // This is a macro so pass the variable in directly.
+    xSemaphore = xSemaphoreCreateRecursiveMutex();
+
+    if( xSemaphore != NULL )
+    {
+        // The semaphore was created successfully.
+        // The semaphore can now be used.
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateRecursiveMutex xSemaphoreCreateRecursiveMutex
+ * \ingroup Semaphores
+ */
+#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
+	#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
+#endif
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
+ *
+ * Creates a new recursive mutex type semaphore instance, and returns a handle
+ * by which the new recursive mutex can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, recursive mutexs use a block
+ * of memory, in which the mutex structure is stored.  If a recursive mutex is
+ * created using xSemaphoreCreateRecursiveMutex() then the required memory is
+ * automatically dynamically allocated inside the
+ * xSemaphoreCreateRecursiveMutex() function.  (see
+ * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
+ * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
+ * provide the memory that will get used by the mutex.
+ * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
+ * be created without using any dynamic memory allocation.
+ *
+ * Mutexes created using this macro can be accessed using the
+ * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
+ * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
+ *
+ * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
+ * doesn't become available again until the owner has called
+ * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
+ * if a task successfully 'takes' the same mutex 5 times then the mutex will
+ * not be available to any other task until it has also  'given' the mutex back
+ * exactly five times.
+ *
+ * This type of semaphore uses a priority inheritance mechanism so a task
+ * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
+ * semaphore it is no longer required.
+ *
+ * Mutex type semaphores cannot be used from within interrupt service routines.
+ *
+ * See xSemaphoreCreateBinary() for an alternative implementation that can be
+ * used for pure synchronisation (where one task or interrupt always 'gives' the
+ * semaphore and another always 'takes' the semaphore) and from within interrupt
+ * service routines.
+ *
+ * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
+ * which will then be used to hold the recursive mutex's data structure,
+ * removing the need for the memory to be allocated dynamically.
+ *
+ * @return If the recursive mutex was successfully created then a handle to the
+ * created recursive mutex is returned.  If pxMutexBuffer was NULL then NULL is
+ * returned.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore;
+ StaticSemaphore_t xMutexBuffer;
+
+ void vATask( void * pvParameters )
+ {
+    // A recursive semaphore cannot be used before it is created.  Here a
+    // recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().
+    // The address of xMutexBuffer is passed into the function, and will hold
+    // the mutexes data structures - so no dynamic memory allocation will be
+    // attempted.
+    xSemaphore = xSemaphoreCreateRecursiveMutexStatic( &xMutexBuffer );
+
+    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
+    // so there is no need to check it.
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateRecursiveMutexStatic xSemaphoreCreateRecursiveMutexStatic
+ * \ingroup Semaphores
+ */
+#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
+	#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
+ *
+ * Creates a new counting semaphore instance, and returns a handle by which the
+ * new counting semaphore can be referenced.
+ *
+ * In many usage scenarios it is faster and more memory efficient to use a
+ * direct to task notification in place of a counting semaphore!
+ * http://www.freertos.org/RTOS-task-notifications.html
+ *
+ * Internally, within the FreeRTOS implementation, counting semaphores use a
+ * block of memory, in which the counting semaphore structure is stored.  If a
+ * counting semaphore is created using xSemaphoreCreateCounting() then the
+ * required memory is automatically dynamically allocated inside the
+ * xSemaphoreCreateCounting() function.  (see
+ * http://www.freertos.org/a00111.html).  If a counting semaphore is created
+ * using xSemaphoreCreateCountingStatic() then the application writer can
+ * instead optionally provide the memory that will get used by the counting
+ * semaphore.  xSemaphoreCreateCountingStatic() therefore allows a counting
+ * semaphore to be created without using any dynamic memory allocation.
+ *
+ * Counting semaphores are typically used for two things:
+ *
+ * 1) Counting events.
+ *
+ *    In this usage scenario an event handler will 'give' a semaphore each time
+ *    an event occurs (incrementing the semaphore count value), and a handler
+ *    task will 'take' a semaphore each time it processes an event
+ *    (decrementing the semaphore count value).  The count value is therefore
+ *    the difference between the number of events that have occurred and the
+ *    number that have been processed.  In this case it is desirable for the
+ *    initial count value to be zero.
+ *
+ * 2) Resource management.
+ *
+ *    In this usage scenario the count value indicates the number of resources
+ *    available.  To obtain control of a resource a task must first obtain a
+ *    semaphore - decrementing the semaphore count value.  When the count value
+ *    reaches zero there are no free resources.  When a task finishes with the
+ *    resource it 'gives' the semaphore back - incrementing the semaphore count
+ *    value.  In this case it is desirable for the initial count value to be
+ *    equal to the maximum count value, indicating that all resources are free.
+ *
+ * @param uxMaxCount The maximum count value that can be reached.  When the
+ *        semaphore reaches this value it can no longer be 'given'.
+ *
+ * @param uxInitialCount The count value assigned to the semaphore when it is
+ *        created.
+ *
+ * @return Handle to the created semaphore.  Null if the semaphore could not be
+ *         created.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore;
+
+ void vATask( void * pvParameters )
+ {
+ SemaphoreHandle_t xSemaphore = NULL;
+
+    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
+    // The max value to which the semaphore can count should be 10, and the
+    // initial value assigned to the count should be 0.
+    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
+
+    if( xSemaphore != NULL )
+    {
+        // The semaphore was created successfully.
+        // The semaphore can now be used.
+    }
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
+ * \ingroup Semaphores
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
+#endif
+
+/**
+ * semphr. h
+ * <pre>SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )</pre>
+ *
+ * Creates a new counting semaphore instance, and returns a handle by which the
+ * new counting semaphore can be referenced.
+ *
+ * In many usage scenarios it is faster and more memory efficient to use a
+ * direct to task notification in place of a counting semaphore!
+ * http://www.freertos.org/RTOS-task-notifications.html
+ *
+ * Internally, within the FreeRTOS implementation, counting semaphores use a
+ * block of memory, in which the counting semaphore structure is stored.  If a
+ * counting semaphore is created using xSemaphoreCreateCounting() then the
+ * required memory is automatically dynamically allocated inside the
+ * xSemaphoreCreateCounting() function.  (see
+ * http://www.freertos.org/a00111.html).  If a counting semaphore is created
+ * using xSemaphoreCreateCountingStatic() then the application writer must
+ * provide the memory.  xSemaphoreCreateCountingStatic() therefore allows a
+ * counting semaphore to be created without using any dynamic memory allocation.
+ *
+ * Counting semaphores are typically used for two things:
+ *
+ * 1) Counting events.
+ *
+ *    In this usage scenario an event handler will 'give' a semaphore each time
+ *    an event occurs (incrementing the semaphore count value), and a handler
+ *    task will 'take' a semaphore each time it processes an event
+ *    (decrementing the semaphore count value).  The count value is therefore
+ *    the difference between the number of events that have occurred and the
+ *    number that have been processed.  In this case it is desirable for the
+ *    initial count value to be zero.
+ *
+ * 2) Resource management.
+ *
+ *    In this usage scenario the count value indicates the number of resources
+ *    available.  To obtain control of a resource a task must first obtain a
+ *    semaphore - decrementing the semaphore count value.  When the count value
+ *    reaches zero there are no free resources.  When a task finishes with the
+ *    resource it 'gives' the semaphore back - incrementing the semaphore count
+ *    value.  In this case it is desirable for the initial count value to be
+ *    equal to the maximum count value, indicating that all resources are free.
+ *
+ * @param uxMaxCount The maximum count value that can be reached.  When the
+ *        semaphore reaches this value it can no longer be 'given'.
+ *
+ * @param uxInitialCount The count value assigned to the semaphore when it is
+ *        created.
+ *
+ * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
+ * which will then be used to hold the semaphore's data structure, removing the
+ * need for the memory to be allocated dynamically.
+ *
+ * @return If the counting semaphore was successfully created then a handle to
+ * the created counting semaphore is returned.  If pxSemaphoreBuffer was NULL
+ * then NULL is returned.
+ *
+ * Example usage:
+ <pre>
+ SemaphoreHandle_t xSemaphore;
+ StaticSemaphore_t xSemaphoreBuffer;
+
+ void vATask( void * pvParameters )
+ {
+ SemaphoreHandle_t xSemaphore = NULL;
+
+    // Counting semaphore cannot be used before they have been created.  Create
+    // a counting semaphore using xSemaphoreCreateCountingStatic().  The max
+    // value to which the semaphore can count is 10, and the initial value
+    // assigned to the count will be 0.  The address of xSemaphoreBuffer is
+    // passed in and will be used to hold the semaphore structure, so no dynamic
+    // memory allocation will be used.
+    xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );
+
+    // No memory allocation was attempted so xSemaphore cannot be NULL, so there
+    // is no need to check its value.
+ }
+ </pre>
+ * \defgroup xSemaphoreCreateCountingStatic xSemaphoreCreateCountingStatic
+ * \ingroup Semaphores
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * semphr. h
+ * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
+ *
+ * Delete a semaphore.  This function must be used with care.  For example,
+ * do not delete a mutex type semaphore if the mutex is held by a task.
+ *
+ * @param xSemaphore A handle to the semaphore to be deleted.
+ *
+ * \defgroup vSemaphoreDelete vSemaphoreDelete
+ * \ingroup Semaphores
+ */
+#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
+
+/**
+ * semphr.h
+ * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
+ *
+ * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
+ * If xMutex is not a mutex type semaphore, or the mutex is available (not held
+ * by a task), return NULL.
+ *
+ * Note: This is a good way of determining if the calling task is the mutex
+ * holder, but not a good way of determining the identity of the mutex holder as
+ * the holder may change between the function exiting and the returned value
+ * being tested.
+ */
+#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
+
+/**
+ * semphr.h
+ * <pre>TaskHandle_t xSemaphoreGetMutexHolderFromISR( SemaphoreHandle_t xMutex );</pre>
+ *
+ * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
+ * If xMutex is not a mutex type semaphore, or the mutex is available (not held
+ * by a task), return NULL.
+ *
+ */
+#define xSemaphoreGetMutexHolderFromISR( xSemaphore ) xQueueGetMutexHolderFromISR( ( xSemaphore ) )
+
+/**
+ * semphr.h
+ * <pre>UBaseType_t uxSemaphoreGetCount( SemaphoreHandle_t xSemaphore );</pre>
+ *
+ * If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns
+ * its current count value.  If the semaphore is a binary semaphore then
+ * uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the
+ * semaphore is not available.
+ *
+ */
+#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
+
+#endif /* SEMAPHORE_H */
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/stream_buffer.h ./libs/freertos/include/stream_buffer.h
--- a_bRU7kv/libs/freertos/include/stream_buffer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/stream_buffer.h	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,852 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*
+ * Stream buffers are used to send a continuous stream of data from one task or
+ * interrupt to another.  Their implementation is light weight, making them
+ * particularly suited for interrupt to task and core to core communication
+ * scenarios.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xStreamBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xStreamBufferRead()) inside a critical section section and set the
+ * receive block time to 0.
+ *
+ */
+
+#ifndef STREAM_BUFFER_H
+#define STREAM_BUFFER_H
+
+#if defined( __cplusplus )
+extern "C" {
+#endif
+
+/**
+ * Type by which stream buffers are referenced.  For example, a call to
+ * xStreamBufferCreate() returns an StreamBufferHandle_t variable that can
+ * then be used as a parameter to xStreamBufferSend(), xStreamBufferReceive(),
+ * etc.
+ */
+typedef void * StreamBufferHandle_t;
+
+
+/**
+ * message_buffer.h
+ *
+<pre>
+StreamBufferHandle_t xStreamBufferCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes );
+</pre>
+ *
+ * Creates a new stream buffer using dynamically allocated memory.  See
+ * xStreamBufferCreateStatic() for a version that uses statically allocated
+ * memory (memory that is allocated at compile time).
+ *
+ * configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in
+ * FreeRTOSConfig.h for xStreamBufferCreate() to be available.
+ *
+ * @param xBufferSizeBytes The total number of bytes the stream buffer will be
+ * able to hold at any one time.
+ *
+ * @param xTriggerLevelBytes The number of bytes that must be in the stream
+ * buffer before a task that is blocked on the stream buffer to wait for data is
+ * moved out of the blocked state.  For example, if a task is blocked on a read
+ * of an empty stream buffer that has a trigger level of 1 then the task will be
+ * unblocked when a single byte is written to the buffer or the task's block
+ * time expires.  As another example, if a task is blocked on a read of an empty
+ * stream buffer that has a trigger level of 10 then the task will not be
+ * unblocked until the stream buffer contains at least 10 bytes or the task's
+ * block time expires.  If a reading task's block time expires before the
+ * trigger level is reached then the task will still receive however many bytes
+ * are actually available.  Setting a trigger level of 0 will result in a
+ * trigger level of 1 being used.  It is not valid to specify a trigger level
+ * that is greater than the buffer size.
+ *
+ * @return If NULL is returned, then the stream buffer cannot be created
+ * because there is insufficient heap memory available for FreeRTOS to allocate
+ * the stream buffer data structures and storage area.  A non-NULL value being
+ * returned indicates that the stream buffer has been created successfully -
+ * the returned value should be stored as the handle to the created stream
+ * buffer.
+ *
+ * Example use:
+<pre>
+
+void vAFunction( void )
+{
+StreamBufferHandle_t xStreamBuffer;
+const size_t xStreamBufferSizeBytes = 100, xTriggerLevel = 10;
+
+    // Create a stream buffer that can hold 100 bytes.  The memory used to hold
+    // both the stream buffer structure and the data in the stream buffer is
+    // allocated dynamically.
+    xStreamBuffer = xStreamBufferCreate( xStreamBufferSizeBytes, xTriggerLevel );
+
+    if( xStreamBuffer == NULL )
+    {
+        // There was not enough heap memory space available to create the
+        // stream buffer.
+    }
+    else
+    {
+        // The stream buffer was created successfully and can now be used.
+    }
+}
+</pre>
+ * \defgroup xStreamBufferCreate xStreamBufferCreate
+ * \ingroup StreamBufferManagement
+ */
+#define xStreamBufferCreate( xBufferSizeBytes, xTriggerLevelBytes ) xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE )
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+StreamBufferHandle_t xStreamBufferCreateStatic( size_t xBufferSizeBytes,
+                                                size_t xTriggerLevelBytes,
+                                                uint8_t *pucStreamBufferStorageArea,
+                                                StaticStreamBuffer_t *pxStaticStreamBuffer );
+</pre>
+ * Creates a new stream buffer using statically allocated memory.  See
+ * xStreamBufferCreate() for a version that uses dynamically allocated memory.
+ *
+ * configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h for
+ * xStreamBufferCreateStatic() to be available.
+ *
+ * @param xBufferSizeBytes The size, in bytes, of the buffer pointed to by the
+ * pucStreamBufferStorageArea parameter.
+ *
+ * @param xTriggerLevelBytes The number of bytes that must be in the stream
+ * buffer before a task that is blocked on the stream buffer to wait for data is
+ * moved out of the blocked state.  For example, if a task is blocked on a read
+ * of an empty stream buffer that has a trigger level of 1 then the task will be
+ * unblocked when a single byte is written to the buffer or the task's block
+ * time expires.  As another example, if a task is blocked on a read of an empty
+ * stream buffer that has a trigger level of 10 then the task will not be
+ * unblocked until the stream buffer contains at least 10 bytes or the task's
+ * block time expires.  If a reading task's block time expires before the
+ * trigger level is reached then the task will still receive however many bytes
+ * are actually available.  Setting a trigger level of 0 will result in a
+ * trigger level of 1 being used.  It is not valid to specify a trigger level
+ * that is greater than the buffer size.
+ *
+ * @param pucStreamBufferStorageArea Must point to a uint8_t array that is at
+ * least xBufferSizeBytes + 1 big.  This is the array to which streams are
+ * copied when they are written to the stream buffer.
+ *
+ * @param pxStaticStreamBuffer Must point to a variable of type
+ * StaticStreamBuffer_t, which will be used to hold the stream buffer's data
+ * structure.
+ *
+ * @return If the stream buffer is created successfully then a handle to the
+ * created stream buffer is returned. If either pucStreamBufferStorageArea or
+ * pxStaticstreamBuffer are NULL then NULL is returned.
+ *
+ * Example use:
+<pre>
+
+// Used to dimension the array used to hold the streams.  The available space
+// will actually be one less than this, so 999.
+#define STORAGE_SIZE_BYTES 1000
+
+// Defines the memory that will actually hold the streams within the stream
+// buffer.
+static uint8_t ucStorageBuffer[ STORAGE_SIZE_BYTES ];
+
+// The variable used to hold the stream buffer structure.
+StaticStreamBuffer_t xStreamBufferStruct;
+
+void MyFunction( void )
+{
+StreamBufferHandle_t xStreamBuffer;
+const size_t xTriggerLevel = 1;
+
+    xStreamBuffer = xStreamBufferCreateStatic( sizeof( ucBufferStorage ),
+                                               xTriggerLevel,
+                                               ucBufferStorage,
+                                               &xStreamBufferStruct );
+
+    // As neither the pucStreamBufferStorageArea or pxStaticStreamBuffer
+    // parameters were NULL, xStreamBuffer will not be NULL, and can be used to
+    // reference the created stream buffer in other stream buffer API calls.
+
+    // Other code that uses the stream buffer can go here.
+}
+
+</pre>
+ * \defgroup xStreamBufferCreateStatic xStreamBufferCreateStatic
+ * \ingroup StreamBufferManagement
+ */
+#define xStreamBufferCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pucStreamBufferStorageArea, pxStaticStreamBuffer ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE, pucStreamBufferStorageArea, pxStaticStreamBuffer )
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
+                          const void *pvTxData,
+                          size_t xDataLengthBytes,
+                          TickType_t xTicksToWait );
+<pre>
+ *
+ * Sends bytes to a stream buffer.  The bytes are copied into the stream buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xStreamBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xStreamBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xStreamBufferSend() to write to a stream buffer from a task.  Use
+ * xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
+ * service routine (ISR).
+ *
+ * @param xStreamBuffer The handle of the stream buffer to which a stream is
+ * being sent.
+ *
+ * @param pvTxData A pointer to the buffer that holds the bytes to be copied
+ * into the stream buffer.
+ *
+ * @param xDataLengthBytes   The maximum number of bytes to copy from pvTxData
+ * into the stream buffer.
+ *
+ * @param xTicksToWait The maximum amount of time the task should remain in the
+ * Blocked state to wait for enough space to become available in the stream
+ * buffer, should the stream buffer contain too little space to hold the
+ * another xDataLengthBytes bytes.  The block time is specified in tick periods,
+ * so the absolute time it represents is dependent on the tick frequency.  The
+ * macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds
+ * into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will
+ * cause the task to wait indefinitely (without timing out), provided
+ * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  If a task times out
+ * before it can write all xDataLengthBytes into the buffer it will still write
+ * as many bytes as possible.  A task does not use any CPU time when it is in
+ * the blocked state.
+ *
+ * @return The number of bytes written to the stream buffer.  If a task times
+ * out before it can write all xDataLengthBytes into the buffer it will still
+ * write as many bytes as possible.
+ *
+ * Example use:
+<pre>
+void vAFunction( StreamBufferHandle_t xStreamBuffer )
+{
+size_t xBytesSent;
+uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };
+char *pcStringToSend = "String to send";
+const TickType_t x100ms = pdMS_TO_TICKS( 100 );
+
+    // Send an array to the stream buffer, blocking for a maximum of 100ms to
+    // wait for enough space to be available in the stream buffer.
+    xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );
+
+    if( xBytesSent != sizeof( ucArrayToSend ) )
+    {
+        // The call to xStreamBufferSend() times out before there was enough
+        // space in the buffer for the data to be written, but it did
+        // successfully write xBytesSent bytes.
+    }
+
+    // Send the string to the stream buffer.  Return immediately if there is not
+    // enough space in the buffer.
+    xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );
+
+    if( xBytesSent != strlen( pcStringToSend ) )
+    {
+        // The entire string could not be added to the stream buffer because
+        // there was not enough free space in the buffer, but xBytesSent bytes
+        // were sent.  Could try again to send the remaining bytes.
+    }
+}
+</pre>
+ * \defgroup xStreamBufferSend xStreamBufferSend
+ * \ingroup StreamBufferManagement
+ */
+size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
+						  const void *pvTxData,
+						  size_t xDataLengthBytes,
+						  TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
+                                 const void *pvTxData,
+                                 size_t xDataLengthBytes,
+                                 BaseType_t *pxHigherPriorityTaskWoken );
+<pre>
+ *
+ * Interrupt safe version of the API function that sends a stream of bytes to
+ * the stream buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xStreamBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xStreamBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xStreamBufferSend() to write to a stream buffer from a task.  Use
+ * xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
+ * service routine (ISR).
+ *
+ * @param xStreamBuffer The handle of the stream buffer to which a stream is
+ * being sent.
+ *
+ * @param pvTxData A pointer to the data that is to be copied into the stream
+ * buffer.
+ *
+ * @param xDataLengthBytes The maximum number of bytes to copy from pvTxData
+ * into the stream buffer.
+ *
+ * @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
+ * have a task blocked on it waiting for data.  Calling
+ * xStreamBufferSendFromISR() can make data available, and so cause a task that
+ * was waiting for data to leave the Blocked state.  If calling
+ * xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the
+ * unblocked task has a priority higher than the currently executing task (the
+ * task that was interrupted), then, internally, xStreamBufferSendFromISR()
+ * will set *pxHigherPriorityTaskWoken to pdTRUE.  If
+ * xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a
+ * context switch should be performed before the interrupt is exited.  This will
+ * ensure that the interrupt returns directly to the highest priority Ready
+ * state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
+ * is passed into the function.  See the example code below for an example.
+ *
+ * @return The number of bytes actually written to the stream buffer, which will
+ * be less than xDataLengthBytes if the stream buffer didn't have enough free
+ * space for all the bytes to be written.
+ *
+ * Example use:
+<pre>
+// A stream buffer that has already been created.
+StreamBufferHandle_t xStreamBuffer;
+
+void vAnInterruptServiceRoutine( void )
+{
+size_t xBytesSent;
+char *pcStringToSend = "String to send";
+BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.
+
+    // Attempt to send the string to the stream buffer.
+    xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,
+                                           ( void * ) pcStringToSend,
+                                           strlen( pcStringToSend ),
+                                           &xHigherPriorityTaskWoken );
+
+    if( xBytesSent != strlen( pcStringToSend ) )
+    {
+        // There was not enough free space in the stream buffer for the entire
+        // string to be written, ut xBytesSent bytes were written.
+    }
+
+    // If xHigherPriorityTaskWoken was set to pdTRUE inside
+    // xStreamBufferSendFromISR() then a task that has a priority above the
+    // priority of the currently executing task was unblocked and a context
+    // switch should be performed to ensure the ISR returns to the unblocked
+    // task.  In most FreeRTOS ports this is done by simply passing
+    // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
+    // variables value, and perform the context switch if necessary.  Check the
+    // documentation for the port in use for port specific instructions.
+    taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+}
+</pre>
+ * \defgroup xStreamBufferSendFromISR xStreamBufferSendFromISR
+ * \ingroup StreamBufferManagement
+ */
+size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
+								 const void *pvTxData,
+								 size_t xDataLengthBytes,
+								 BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
+                             void *pvRxData,
+                             size_t xBufferLengthBytes,
+                             TickType_t xTicksToWait );
+</pre>
+ *
+ * Receives bytes from a stream buffer.
+ *
+ * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
+ * implementation (so also the message buffer implementation, as message buffers
+ * are built on top of stream buffers) assumes there is only one task or
+ * interrupt that will write to the buffer (the writer), and only one task or
+ * interrupt that will read from the buffer (the reader).  It is safe for the
+ * writer and reader to be different tasks or interrupts, but, unlike other
+ * FreeRTOS objects, it is not safe to have multiple different writers or
+ * multiple different readers.  If there are to be multiple different writers
+ * then the application writer must place each call to a writing API function
+ * (such as xStreamBufferSend()) inside a critical section and set the send
+ * block time to 0.  Likewise, if there are to be multiple different readers
+ * then the application writer must place each call to a reading API function
+ * (such as xStreamBufferRead()) inside a critical section and set the receive
+ * block time to 0.
+ *
+ * Use xStreamBufferReceive() to read from a stream buffer from a task.  Use
+ * xStreamBufferReceiveFromISR() to read from a stream buffer from an
+ * interrupt service routine (ISR).
+ *
+ * @param xStreamBuffer The handle of the stream buffer from which bytes are to
+ * be received.
+ *
+ * @param pvRxData A pointer to the buffer into which the received bytes will be
+ * copied.
+ *
+ * @param xBufferLengthBytes The length of the buffer pointed to by the
+ * pvRxData parameter.  This sets the maximum number of bytes to receive in one
+ * call.  xStreamBufferReceive will return as many bytes as possible up to a
+ * maximum set by xBufferLengthBytes.
+ *
+ * @param xTicksToWait The maximum amount of time the task should remain in the
+ * Blocked state to wait for data to become available if the stream buffer is
+ * empty.  xStreamBufferReceive() will return immediately if xTicksToWait is
+ * zero.  The block time is specified in tick periods, so the absolute time it
+ * represents is dependent on the tick frequency.  The macro pdMS_TO_TICKS() can
+ * be used to convert a time specified in milliseconds into a time specified in
+ * ticks.  Setting xTicksToWait to portMAX_DELAY will cause the task to wait
+ * indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1
+ * in FreeRTOSConfig.h.  A task does not use any CPU time when it is in the
+ * Blocked state.
+ *
+ * @return The number of bytes actually read from the stream buffer, which will
+ * be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed
+ * out before xBufferLengthBytes were available.
+ *
+ * Example use:
+<pre>
+void vAFunction( StreamBuffer_t xStreamBuffer )
+{
+uint8_t ucRxData[ 20 ];
+size_t xReceivedBytes;
+const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );
+
+    // Receive up to another sizeof( ucRxData ) bytes from the stream buffer.
+    // Wait in the Blocked state (so not using any CPU processing time) for a
+    // maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be
+    // available.
+    xReceivedBytes = xStreamBufferReceive( xStreamBuffer,
+                                           ( void * ) ucRxData,
+                                           sizeof( ucRxData ),
+                                           xBlockTime );
+
+    if( xReceivedBytes > 0 )
+    {
+        // A ucRxData contains another xRecievedBytes bytes of data, which can
+        // be processed here....
+    }
+}
+</pre>
+ * \defgroup xStreamBufferReceive xStreamBufferReceive
+ * \ingroup StreamBufferManagement
+ */
+size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
+							 void *pvRxData,
+							 size_t xBufferLengthBytes,
+							 TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
+                                    void *pvRxData,
+                                    size_t xBufferLengthBytes,
+                                    BaseType_t *pxHigherPriorityTaskWoken );
+</pre>
+ *
+ * An interrupt safe version of the API function that receives bytes from a
+ * stream buffer.
+ *
+ * Use xStreamBufferReceive() to read bytes from a stream buffer from a task.
+ * Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an
+ * interrupt service routine (ISR).
+ *
+ * @param xStreamBuffer The handle of the stream buffer from which a stream
+ * is being received.
+ *
+ * @param pvRxData A pointer to the buffer into which the received bytes are
+ * copied.
+ *
+ * @param xBufferLengthBytes The length of the buffer pointed to by the
+ * pvRxData parameter.  This sets the maximum number of bytes to receive in one
+ * call.  xStreamBufferReceive will return as many bytes as possible up to a
+ * maximum set by xBufferLengthBytes.
+ *
+ * @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
+ * have a task blocked on it waiting for space to become available.  Calling
+ * xStreamBufferReceiveFromISR() can make space available, and so cause a task
+ * that is waiting for space to leave the Blocked state.  If calling
+ * xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and
+ * the unblocked task has a priority higher than the currently executing task
+ * (the task that was interrupted), then, internally,
+ * xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
+ * If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a
+ * context switch should be performed before the interrupt is exited.  That will
+ * ensure the interrupt returns directly to the highest priority Ready state
+ * task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
+ * passed into the function.  See the code example below for an example.
+ *
+ * @return The number of bytes read from the stream buffer, if any.
+ *
+ * Example use:
+<pre>
+// A stream buffer that has already been created.
+StreamBuffer_t xStreamBuffer;
+
+void vAnInterruptServiceRoutine( void )
+{
+uint8_t ucRxData[ 20 ];
+size_t xReceivedBytes;
+BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.
+
+    // Receive the next stream from the stream buffer.
+    xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,
+                                                  ( void * ) ucRxData,
+                                                  sizeof( ucRxData ),
+                                                  &xHigherPriorityTaskWoken );
+
+    if( xReceivedBytes > 0 )
+    {
+        // ucRxData contains xReceivedBytes read from the stream buffer.
+        // Process the stream here....
+    }
+
+    // If xHigherPriorityTaskWoken was set to pdTRUE inside
+    // xStreamBufferReceiveFromISR() then a task that has a priority above the
+    // priority of the currently executing task was unblocked and a context
+    // switch should be performed to ensure the ISR returns to the unblocked
+    // task.  In most FreeRTOS ports this is done by simply passing
+    // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
+    // variables value, and perform the context switch if necessary.  Check the
+    // documentation for the port in use for port specific instructions.
+    taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+}
+</pre>
+ * \defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR
+ * \ingroup StreamBufferManagement
+ */
+size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
+									void *pvRxData,
+									size_t xBufferLengthBytes,
+									BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer );
+</pre>
+ *
+ * Deletes a stream buffer that was previously created using a call to
+ * xStreamBufferCreate() or xStreamBufferCreateStatic().  If the stream
+ * buffer was created using dynamic memory (that is, by xStreamBufferCreate()),
+ * then the allocated memory is freed.
+ *
+ * A stream buffer handle must not be used after the stream buffer has been
+ * deleted.
+ *
+ * @param xStreamBuffer The handle of the stream buffer to be deleted.
+ *
+ * \defgroup vStreamBufferDelete vStreamBufferDelete
+ * \ingroup StreamBufferManagement
+ */
+void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer );
+</pre>
+ *
+ * Queries a stream buffer to see if it is full.  A stream buffer is full if it
+ * does not have any free space, and therefore cannot accept any more data.
+ *
+ * @param xStreamBuffer The handle of the stream buffer being queried.
+ *
+ * @return If the stream buffer is full then pdTRUE is returned.  Otherwise
+ * pdFALSE is returned.
+ *
+ * \defgroup xStreamBufferIsFull xStreamBufferIsFull
+ * \ingroup StreamBufferManagement
+ */
+BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer );
+</pre>
+ *
+ * Queries a stream buffer to see if it is empty.  A stream buffer is empty if
+ * it does not contain any data.
+ *
+ * @param xStreamBuffer The handle of the stream buffer being queried.
+ *
+ * @return If the stream buffer is empty then pdTRUE is returned.  Otherwise
+ * pdFALSE is returned.
+ *
+ * \defgroup xStreamBufferIsEmpty xStreamBufferIsEmpty
+ * \ingroup StreamBufferManagement
+ */
+BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer );
+</pre>
+ *
+ * Resets a stream buffer to its initial, empty, state.  Any data that was in
+ * the stream buffer is discarded.  A stream buffer can only be reset if there
+ * are no tasks blocked waiting to either send to or receive from the stream
+ * buffer.
+ *
+ * @param xStreamBuffer The handle of the stream buffer being reset.
+ *
+ * @return If the stream buffer is reset then pdPASS is returned.  If there was
+ * a task blocked waiting to send to or read from the stream buffer then the
+ * stream buffer is not reset and pdFAIL is returned.
+ *
+ * \defgroup xStreamBufferReset xStreamBufferReset
+ * \ingroup StreamBufferManagement
+ */
+BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer );
+</pre>
+ *
+ * Queries a stream buffer to see how much free space it contains, which is
+ * equal to the amount of data that can be sent to the stream buffer before it
+ * is full.
+ *
+ * @param xStreamBuffer The handle of the stream buffer being queried.
+ *
+ * @return The number of bytes that can be written to the stream buffer before
+ * the stream buffer would be full.
+ *
+ * \defgroup xStreamBufferSpacesAvailable xStreamBufferSpacesAvailable
+ * \ingroup StreamBufferManagement
+ */
+size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer );
+</pre>
+ *
+ * Queries a stream buffer to see how much data it contains, which is equal to
+ * the number of bytes that can be read from the stream buffer before the stream
+ * buffer would be empty.
+ *
+ * @param xStreamBuffer The handle of the stream buffer being queried.
+ *
+ * @return The number of bytes that can be read from the stream buffer before
+ * the stream buffer would be empty.
+ *
+ * \defgroup xStreamBufferBytesAvailable xStreamBufferBytesAvailable
+ * \ingroup StreamBufferManagement
+ */
+size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel );
+</pre>
+ *
+ * A stream buffer's trigger level is the number of bytes that must be in the
+ * stream buffer before a task that is blocked on the stream buffer to
+ * wait for data is moved out of the blocked state.  For example, if a task is
+ * blocked on a read of an empty stream buffer that has a trigger level of 1
+ * then the task will be unblocked when a single byte is written to the buffer
+ * or the task's block time expires.  As another example, if a task is blocked
+ * on a read of an empty stream buffer that has a trigger level of 10 then the
+ * task will not be unblocked until the stream buffer contains at least 10 bytes
+ * or the task's block time expires.  If a reading task's block time expires
+ * before the trigger level is reached then the task will still receive however
+ * many bytes are actually available.  Setting a trigger level of 0 will result
+ * in a trigger level of 1 being used.  It is not valid to specify a trigger
+ * level that is greater than the buffer size.
+ *
+ * A trigger level is set when the stream buffer is created, and can be modified
+ * using xStreamBufferSetTriggerLevel().
+ *
+ * @param xStreamBuffer The handle of the stream buffer being updated.
+ *
+ * @param xTriggerLevel The new trigger level for the stream buffer.
+ *
+ * @return If xTriggerLevel was less than or equal to the stream buffer's length
+ * then the trigger level will be updated and pdTRUE is returned.  Otherwise
+ * pdFALSE is returned.
+ *
+ * \defgroup xStreamBufferSetTriggerLevel xStreamBufferSetTriggerLevel
+ * \ingroup StreamBufferManagement
+ */
+BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
+</pre>
+ *
+ * For advanced users only.
+ *
+ * The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when
+ * data is sent to a message buffer or stream buffer.  If there was a task that
+ * was blocked on the message or stream buffer waiting for data to arrive then
+ * the sbSEND_COMPLETED() macro sends a notification to the task to remove it
+ * from the Blocked state.  xStreamBufferSendCompletedFromISR() does the same
+ * thing.  It is provided to enable application writers to implement their own
+ * version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.
+ *
+ * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
+ * additional information.
+ *
+ * @param xStreamBuffer The handle of the stream buffer to which data was
+ * written.
+ *
+ * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
+ * initialised to pdFALSE before it is passed into
+ * xStreamBufferSendCompletedFromISR().  If calling
+ * xStreamBufferSendCompletedFromISR() removes a task from the Blocked state,
+ * and the task has a priority above the priority of the currently running task,
+ * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
+ * context switch should be performed before exiting the ISR.
+ *
+ * @return If a task was removed from the Blocked state then pdTRUE is returned.
+ * Otherwise pdFALSE is returned.
+ *
+ * \defgroup xStreamBufferSendCompletedFromISR xStreamBufferSendCompletedFromISR
+ * \ingroup StreamBufferManagement
+ */
+BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/**
+ * stream_buffer.h
+ *
+<pre>
+BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
+</pre>
+ *
+ * For advanced users only.
+ *
+ * The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when
+ * data is read out of a message buffer or stream buffer.  If there was a task
+ * that was blocked on the message or stream buffer waiting for data to arrive
+ * then the sbRECEIVE_COMPLETED() macro sends a notification to the task to
+ * remove it from the Blocked state.  xStreamBufferReceiveCompletedFromISR()
+ * does the same thing.  It is provided to enable application writers to
+ * implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT
+ * ANY OTHER TIME.
+ *
+ * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
+ * additional information.
+ *
+ * @param xStreamBuffer The handle of the stream buffer from which data was
+ * read.
+ *
+ * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
+ * initialised to pdFALSE before it is passed into
+ * xStreamBufferReceiveCompletedFromISR().  If calling
+ * xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state,
+ * and the task has a priority above the priority of the currently running task,
+ * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
+ * context switch should be performed before exiting the ISR.
+ *
+ * @return If a task was removed from the Blocked state then pdTRUE is returned.
+ * Otherwise pdFALSE is returned.
+ *
+ * \defgroup xStreamBufferReceiveCompletedFromISR xStreamBufferReceiveCompletedFromISR
+ * \ingroup StreamBufferManagement
+ */
+BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/* Functions below here are not part of the public API. */
+StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
+												 size_t xTriggerLevelBytes,
+												 BaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;
+
+StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
+													   size_t xTriggerLevelBytes,
+													   BaseType_t xIsMessageBuffer,
+													   uint8_t * const pucStreamBufferStorageArea,
+													   StaticStreamBuffer_t * const pxStaticStreamBuffer ) PRIVILEGED_FUNCTION;
+
+#if( configUSE_TRACE_FACILITY == 1 )
+	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber ) PRIVILEGED_FUNCTION;
+	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
+#endif
+
+#if defined( __cplusplus )
+}
+#endif
+
+#endif	/* !defined( STREAM_BUFFER_H ) */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/task.h ./libs/freertos/include/task.h
--- a_bRU7kv/libs/freertos/include/task.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/task.h	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,2338 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#ifndef INC_TASK_H
+#define INC_TASK_H
+
+#ifndef INC_FREERTOS_H
+	#error "include FreeRTOS.h must appear in source files before include task.h"
+#endif
+
+#include "list.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-----------------------------------------------------------
+ * MACROS AND DEFINITIONS
+ *----------------------------------------------------------*/
+
+#define tskKERNEL_VERSION_NUMBER "V10.0.1"
+#define tskKERNEL_VERSION_MAJOR 10
+#define tskKERNEL_VERSION_MINOR 0
+#define tskKERNEL_VERSION_BUILD 1
+
+/**
+ * task. h
+ *
+ * Type by which tasks are referenced.  For example, a call to xTaskCreate
+ * returns (via a pointer parameter) an TaskHandle_t variable that can then
+ * be used as a parameter to vTaskDelete to delete the task.
+ *
+ * \defgroup TaskHandle_t TaskHandle_t
+ * \ingroup Tasks
+ */
+typedef void * TaskHandle_t;
+
+/*
+ * Defines the prototype to which the application task hook function must
+ * conform.
+ */
+typedef BaseType_t (*TaskHookFunction_t)( void * );
+
+/* Task states returned by eTaskGetState. */
+typedef enum
+{
+	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
+	eReady,			/* The task being queried is in a read or pending ready list. */
+	eBlocked,		/* The task being queried is in the Blocked state. */
+	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
+	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
+	eInvalid			/* Used as an 'invalid state' value. */
+} eTaskState;
+
+/* Actions that can be performed when vTaskNotify() is called. */
+typedef enum
+{
+	eNoAction = 0,				/* Notify the task without updating its notify value. */
+	eSetBits,					/* Set bits in the task's notification value. */
+	eIncrement,					/* Increment the task's notification value. */
+	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
+	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
+} eNotifyAction;
+
+/*
+ * Used internally only.
+ */
+typedef struct xTIME_OUT
+{
+	BaseType_t xOverflowCount;
+	TickType_t xTimeOnEntering;
+} TimeOut_t;
+
+/*
+ * Defines the memory ranges allocated to the task when an MPU is used.
+ */
+typedef struct xMEMORY_REGION
+{
+	void *pvBaseAddress;
+	uint32_t ulLengthInBytes;
+	uint32_t ulParameters;
+} MemoryRegion_t;
+
+/*
+ * Parameters required to create an MPU protected task.
+ */
+typedef struct xTASK_PARAMETERS
+{
+	TaskFunction_t pvTaskCode;
+	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	uint16_t usStackDepth;
+	void *pvParameters;
+	UBaseType_t uxPriority;
+	StackType_t *puxStackBuffer;
+	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
+	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+		StaticTask_t * const pxTaskBuffer;
+	#endif
+} TaskParameters_t;
+
+/* Used with the uxTaskGetSystemState() function to return the state of each task
+in the system. */
+typedef struct xTASK_STATUS
+{
+	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
+	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	UBaseType_t xTaskNumber;		/* A number unique to the task. */
+	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
+	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
+	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
+	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
+	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
+	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
+} TaskStatus_t;
+
+/* Possible return values for eTaskConfirmSleepModeStatus(). */
+typedef enum
+{
+	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
+	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
+	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
+} eSleepModeStatus;
+
+/**
+ * Defines the priority used by the idle task.  This must not be modified.
+ *
+ * \ingroup TaskUtils
+ */
+#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
+
+/**
+ * task. h
+ *
+ * Macro for forcing a context switch.
+ *
+ * \defgroup taskYIELD taskYIELD
+ * \ingroup SchedulerControl
+ */
+#define taskYIELD()					portYIELD()
+
+/**
+ * task. h
+ *
+ * Macro to mark the start of a critical code region.  Preemptive context
+ * switches cannot occur when in a critical region.
+ *
+ * NOTE: This may alter the stack (depending on the portable implementation)
+ * so must be used with care!
+ *
+ * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
+ * \ingroup SchedulerControl
+ */
+#define taskENTER_CRITICAL()		portENTER_CRITICAL()
+#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
+
+/**
+ * task. h
+ *
+ * Macro to mark the end of a critical code region.  Preemptive context
+ * switches cannot occur when in a critical region.
+ *
+ * NOTE: This may alter the stack (depending on the portable implementation)
+ * so must be used with care!
+ *
+ * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
+ * \ingroup SchedulerControl
+ */
+#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
+#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
+/**
+ * task. h
+ *
+ * Macro to disable all maskable interrupts.
+ *
+ * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
+ * \ingroup SchedulerControl
+ */
+#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
+
+/**
+ * task. h
+ *
+ * Macro to enable microcontroller interrupts.
+ *
+ * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
+ * \ingroup SchedulerControl
+ */
+#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
+
+/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
+0 to generate more optimal code when configASSERT() is defined as the constant
+is used in assert() statements. */
+#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
+#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
+#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
+
+
+/*-----------------------------------------------------------
+ * TASK CREATION API
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ *<pre>
+ BaseType_t xTaskCreate(
+							  TaskFunction_t pvTaskCode,
+							  const char * const pcName,
+							  configSTACK_DEPTH_TYPE usStackDepth,
+							  void *pvParameters,
+							  UBaseType_t uxPriority,
+							  TaskHandle_t *pvCreatedTask
+						  );</pre>
+ *
+ * Create a new task and add it to the list of tasks that are ready to run.
+ *
+ * Internally, within the FreeRTOS implementation, tasks use two blocks of
+ * memory.  The first block is used to hold the task's data structures.  The
+ * second block is used by the task as its stack.  If a task is created using
+ * xTaskCreate() then both blocks of memory are automatically dynamically
+ * allocated inside the xTaskCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a task is created using
+ * xTaskCreateStatic() then the application writer must provide the required
+ * memory.  xTaskCreateStatic() therefore allows a task to be created without
+ * using any dynamic memory allocation.
+ *
+ * See xTaskCreateStatic() for a version that does not use any dynamic memory
+ * allocation.
+ *
+ * xTaskCreate() can only be used to create a task that has unrestricted
+ * access to the entire microcontroller memory map.  Systems that include MPU
+ * support can alternatively create an MPU constrained task using
+ * xTaskCreateRestricted().
+ *
+ * @param pvTaskCode Pointer to the task entry function.  Tasks
+ * must be implemented to never return (i.e. continuous loop).
+ *
+ * @param pcName A descriptive name for the task.  This is mainly used to
+ * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
+ * is 16.
+ *
+ * @param usStackDepth The size of the task stack specified as the number of
+ * variables the stack can hold - not the number of bytes.  For example, if
+ * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
+ * will be allocated for stack storage.
+ *
+ * @param pvParameters Pointer that will be used as the parameter for the task
+ * being created.
+ *
+ * @param uxPriority The priority at which the task should run.  Systems that
+ * include MPU support can optionally create tasks in a privileged (system)
+ * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
+ * example, to create a privileged task at priority 2 the uxPriority parameter
+ * should be set to ( 2 | portPRIVILEGE_BIT ).
+ *
+ * @param pvCreatedTask Used to pass back a handle by which the created task
+ * can be referenced.
+ *
+ * @return pdPASS if the task was successfully created and added to a ready
+ * list, otherwise an error code defined in the file projdefs.h
+ *
+ * Example usage:
+   <pre>
+ // Task to be created.
+ void vTaskCode( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+	 }
+ }
+
+ // Function that creates a task.
+ void vOtherFunction( void )
+ {
+ static uint8_t ucParameterToPass;
+ TaskHandle_t xHandle = NULL;
+
+	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
+	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
+	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
+	 // the new task attempts to access it.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
+     configASSERT( xHandle );
+
+	 // Use the handle to delete the task.
+     if( xHandle != NULL )
+     {
+	     vTaskDelete( xHandle );
+     }
+ }
+   </pre>
+ * \defgroup xTaskCreate xTaskCreate
+ * \ingroup Tasks
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
+							const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+							const configSTACK_DEPTH_TYPE usStackDepth,
+							void * const pvParameters,
+							UBaseType_t uxPriority,
+							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * task. h
+ *<pre>
+ TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
+								 const char * const pcName,
+								 uint32_t ulStackDepth,
+								 void *pvParameters,
+								 UBaseType_t uxPriority,
+								 StackType_t *pxStackBuffer,
+								 StaticTask_t *pxTaskBuffer );</pre>
+ *
+ * Create a new task and add it to the list of tasks that are ready to run.
+ *
+ * Internally, within the FreeRTOS implementation, tasks use two blocks of
+ * memory.  The first block is used to hold the task's data structures.  The
+ * second block is used by the task as its stack.  If a task is created using
+ * xTaskCreate() then both blocks of memory are automatically dynamically
+ * allocated inside the xTaskCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a task is created using
+ * xTaskCreateStatic() then the application writer must provide the required
+ * memory.  xTaskCreateStatic() therefore allows a task to be created without
+ * using any dynamic memory allocation.
+ *
+ * @param pvTaskCode Pointer to the task entry function.  Tasks
+ * must be implemented to never return (i.e. continuous loop).
+ *
+ * @param pcName A descriptive name for the task.  This is mainly used to
+ * facilitate debugging.  The maximum length of the string is defined by
+ * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
+ *
+ * @param ulStackDepth The size of the task stack specified as the number of
+ * variables the stack can hold - not the number of bytes.  For example, if
+ * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
+ * will be allocated for stack storage.
+ *
+ * @param pvParameters Pointer that will be used as the parameter for the task
+ * being created.
+ *
+ * @param uxPriority The priority at which the task will run.
+ *
+ * @param pxStackBuffer Must point to a StackType_t array that has at least
+ * ulStackDepth indexes - the array will then be used as the task's stack,
+ * removing the need for the stack to be allocated dynamically.
+ *
+ * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
+ * then be used to hold the task's data structures, removing the need for the
+ * memory to be allocated dynamically.
+ *
+ * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
+ * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
+ * are NULL then the task will not be created and
+ * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
+ *
+ * Example usage:
+   <pre>
+
+    // Dimensions the buffer that the task being created will use as its stack.
+    // NOTE:  This is the number of words the stack will hold, not the number of
+    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
+    // then 400 bytes (100 * 32-bits) will be allocated.
+    #define STACK_SIZE 200
+
+    // Structure that will hold the TCB of the task being created.
+    StaticTask_t xTaskBuffer;
+
+    // Buffer that the task being created will use as its stack.  Note this is
+    // an array of StackType_t variables.  The size of StackType_t is dependent on
+    // the RTOS port.
+    StackType_t xStack[ STACK_SIZE ];
+
+    // Function that implements the task being created.
+    void vTaskCode( void * pvParameters )
+    {
+        // The parameter value is expected to be 1 as 1 is passed in the
+        // pvParameters value in the call to xTaskCreateStatic().
+        configASSERT( ( uint32_t ) pvParameters == 1UL );
+
+        for( ;; )
+        {
+            // Task code goes here.
+        }
+    }
+
+    // Function that creates a task.
+    void vOtherFunction( void )
+    {
+        TaskHandle_t xHandle = NULL;
+
+        // Create the task without using any dynamic memory allocation.
+        xHandle = xTaskCreateStatic(
+                      vTaskCode,       // Function that implements the task.
+                      "NAME",          // Text name for the task.
+                      STACK_SIZE,      // Stack size in words, not bytes.
+                      ( void * ) 1,    // Parameter passed into the task.
+                      tskIDLE_PRIORITY,// Priority at which the task is created.
+                      xStack,          // Array to use as the task's stack.
+                      &xTaskBuffer );  // Variable to hold the task's data structure.
+
+        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
+        // been created, and xHandle will be the task's handle.  Use the handle
+        // to suspend the task.
+        vTaskSuspend( xHandle );
+    }
+   </pre>
+ * \defgroup xTaskCreateStatic xTaskCreateStatic
+ * \ingroup Tasks
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
+									const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const uint32_t ulStackDepth,
+									void * const pvParameters,
+									UBaseType_t uxPriority,
+									StackType_t * const puxStackBuffer,
+									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * task. h
+ *<pre>
+ BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
+ *
+ * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.
+ *
+ * xTaskCreateRestricted() should only be used in systems that include an MPU
+ * implementation.
+ *
+ * Create a new task and add it to the list of tasks that are ready to run.
+ * The function parameters define the memory regions and associated access
+ * permissions allocated to the task.
+ *
+ * See xTaskCreateRestrictedStatic() for a version that does not use any
+ * dynamic memory allocation.
+ *
+ * @param pxTaskDefinition Pointer to a structure that contains a member
+ * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
+ * documentation) plus an optional stack buffer and the memory region
+ * definitions.
+ *
+ * @param pxCreatedTask Used to pass back a handle by which the created task
+ * can be referenced.
+ *
+ * @return pdPASS if the task was successfully created and added to a ready
+ * list, otherwise an error code defined in the file projdefs.h
+ *
+ * Example usage:
+   <pre>
+// Create an TaskParameters_t structure that defines the task to be created.
+static const TaskParameters_t xCheckTaskParameters =
+{
+	vATask,		// pvTaskCode - the function that implements the task.
+	"ATask",	// pcName - just a text name for the task to assist debugging.
+	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
+	NULL,		// pvParameters - passed into the task function as the function parameters.
+	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
+	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
+
+	// xRegions - Allocate up to three separate memory regions for access by
+	// the task, with appropriate access permissions.  Different processors have
+	// different memory alignment requirements - refer to the FreeRTOS documentation
+	// for full information.
+	{
+		// Base address					Length	Parameters
+        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
+        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
+        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
+	}
+};
+
+int main( void )
+{
+TaskHandle_t xHandle;
+
+	// Create a task from the const structure defined above.  The task handle
+	// is requested (the second parameter is not NULL) but in this case just for
+	// demonstration purposes as its not actually used.
+	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
+
+	// Start the scheduler.
+	vTaskStartScheduler();
+
+	// Will only get here if there was insufficient memory to create the idle
+	// and/or timer task.
+	for( ;; );
+}
+   </pre>
+ * \defgroup xTaskCreateRestricted xTaskCreateRestricted
+ * \ingroup Tasks
+ */
+#if( portUSING_MPU_WRAPPERS == 1 )
+	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * task. h
+ *<pre>
+ BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
+ *
+ * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.
+ *
+ * xTaskCreateRestrictedStatic() should only be used in systems that include an
+ * MPU implementation.
+ *
+ * Internally, within the FreeRTOS implementation, tasks use two blocks of
+ * memory.  The first block is used to hold the task's data structures.  The
+ * second block is used by the task as its stack.  If a task is created using
+ * xTaskCreateRestricted() then the stack is provided by the application writer,
+ * and the memory used to hold the task's data structure is automatically
+ * dynamically allocated inside the xTaskCreateRestricted() function.  If a task
+ * is created using xTaskCreateRestrictedStatic() then the application writer
+ * must provide the memory used to hold the task's data structures too.
+ * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be
+ * created without using any dynamic memory allocation.
+ *
+ * @param pxTaskDefinition Pointer to a structure that contains a member
+ * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
+ * documentation) plus an optional stack buffer and the memory region
+ * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure
+ * contains an additional member, which is used to point to a variable of type
+ * StaticTask_t - which is then used to hold the task's data structure.
+ *
+ * @param pxCreatedTask Used to pass back a handle by which the created task
+ * can be referenced.
+ *
+ * @return pdPASS if the task was successfully created and added to a ready
+ * list, otherwise an error code defined in the file projdefs.h
+ *
+ * Example usage:
+   <pre>
+// Create an TaskParameters_t structure that defines the task to be created.
+// The StaticTask_t variable is only included in the structure when
+// configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can
+// be used to force the variable into the RTOS kernel's privileged data area.
+static PRIVILEGED_DATA StaticTask_t xTaskBuffer;
+static const TaskParameters_t xCheckTaskParameters =
+{
+	vATask,		// pvTaskCode - the function that implements the task.
+	"ATask",	// pcName - just a text name for the task to assist debugging.
+	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
+	NULL,		// pvParameters - passed into the task function as the function parameters.
+	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
+	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
+
+	// xRegions - Allocate up to three separate memory regions for access by
+	// the task, with appropriate access permissions.  Different processors have
+	// different memory alignment requirements - refer to the FreeRTOS documentation
+	// for full information.
+	{
+		// Base address					Length	Parameters
+        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
+        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
+        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
+	}
+
+	&xTaskBuffer; // Holds the task's data structure.
+};
+
+int main( void )
+{
+TaskHandle_t xHandle;
+
+	// Create a task from the const structure defined above.  The task handle
+	// is requested (the second parameter is not NULL) but in this case just for
+	// demonstration purposes as its not actually used.
+	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
+
+	// Start the scheduler.
+	vTaskStartScheduler();
+
+	// Will only get here if there was insufficient memory to create the idle
+	// and/or timer task.
+	for( ;; );
+}
+   </pre>
+ * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic
+ * \ingroup Tasks
+ */
+#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * task. h
+ *<pre>
+ void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
+ *
+ * Memory regions are assigned to a restricted task when the task is created by
+ * a call to xTaskCreateRestricted().  These regions can be redefined using
+ * vTaskAllocateMPURegions().
+ *
+ * @param xTask The handle of the task being updated.
+ *
+ * @param xRegions A pointer to an MemoryRegion_t structure that contains the
+ * new memory region definitions.
+ *
+ * Example usage:
+   <pre>
+// Define an array of MemoryRegion_t structures that configures an MPU region
+// allowing read/write access for 1024 bytes starting at the beginning of the
+// ucOneKByte array.  The other two of the maximum 3 definable regions are
+// unused so set to zero.
+static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
+{
+	// Base address		Length		Parameters
+	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
+	{ 0,				0,			0 },
+	{ 0,				0,			0 }
+};
+
+void vATask( void *pvParameters )
+{
+	// This task was created such that it has access to certain regions of
+	// memory as defined by the MPU configuration.  At some point it is
+	// desired that these MPU regions are replaced with that defined in the
+	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
+	// for this purpose.  NULL is used as the task handle to indicate that this
+	// function should modify the MPU regions of the calling task.
+	vTaskAllocateMPURegions( NULL, xAltRegions );
+
+	// Now the task can continue its function, but from this point on can only
+	// access its stack and the ucOneKByte array (unless any other statically
+	// defined or shared regions have been declared elsewhere).
+}
+   </pre>
+ * \defgroup xTaskCreateRestricted xTaskCreateRestricted
+ * \ingroup Tasks
+ */
+void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Remove a task from the RTOS real time kernel's management.  The task being
+ * deleted will be removed from all ready, blocked, suspended and event lists.
+ *
+ * NOTE:  The idle task is responsible for freeing the kernel allocated
+ * memory from tasks that have been deleted.  It is therefore important that
+ * the idle task is not starved of microcontroller processing time if your
+ * application makes any calls to vTaskDelete ().  Memory allocated by the
+ * task code is not automatically freed, and should be freed before the task
+ * is deleted.
+ *
+ * See the demo application file death.c for sample code that utilises
+ * vTaskDelete ().
+ *
+ * @param xTask The handle of the task to be deleted.  Passing NULL will
+ * cause the calling task to be deleted.
+ *
+ * Example usage:
+   <pre>
+ void vOtherFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create the task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // Use the handle to delete the task.
+	 vTaskDelete( xHandle );
+ }
+   </pre>
+ * \defgroup vTaskDelete vTaskDelete
+ * \ingroup Tasks
+ */
+void vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------
+ * TASK CONTROL API
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
+ *
+ * Delay a task for a given number of ticks.  The actual time that the
+ * task remains blocked depends on the tick rate.  The constant
+ * portTICK_PERIOD_MS can be used to calculate real time from the tick
+ * rate - with the resolution of one tick period.
+ *
+ * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ *
+ * vTaskDelay() specifies a time at which the task wishes to unblock relative to
+ * the time at which vTaskDelay() is called.  For example, specifying a block
+ * period of 100 ticks will cause the task to unblock 100 ticks after
+ * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
+ * of controlling the frequency of a periodic task as the path taken through the
+ * code, as well as other task and interrupt activity, will effect the frequency
+ * at which vTaskDelay() gets called and therefore the time at which the task
+ * next executes.  See vTaskDelayUntil() for an alternative API function designed
+ * to facilitate fixed frequency execution.  It does this by specifying an
+ * absolute time (rather than a relative time) at which the calling task should
+ * unblock.
+ *
+ * @param xTicksToDelay The amount of time, in tick periods, that
+ * the calling task should block.
+ *
+ * Example usage:
+
+ void vTaskFunction( void * pvParameters )
+ {
+ // Block for 500ms.
+ const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
+
+	 for( ;; )
+	 {
+		 // Simply toggle the LED every 500ms, blocking between each toggle.
+		 vToggleLED();
+		 vTaskDelay( xDelay );
+	 }
+ }
+
+ * \defgroup vTaskDelay vTaskDelay
+ * \ingroup TaskCtrl
+ */
+void vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
+ *
+ * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Delay a task until a specified time.  This function can be used by periodic
+ * tasks to ensure a constant execution frequency.
+ *
+ * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
+ * cause a task to block for the specified number of ticks from the time vTaskDelay () is
+ * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
+ * execution frequency as the time between a task starting to execute and that task
+ * calling vTaskDelay () may not be fixed [the task may take a different path though the
+ * code between calls, or may get interrupted or preempted a different number of times
+ * each time it executes].
+ *
+ * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
+ * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
+ * unblock.
+ *
+ * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
+ * rate - with the resolution of one tick period.
+ *
+ * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
+ * task was last unblocked.  The variable must be initialised with the current time
+ * prior to its first use (see the example below).  Following this the variable is
+ * automatically updated within vTaskDelayUntil ().
+ *
+ * @param xTimeIncrement The cycle time period.  The task will be unblocked at
+ * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
+ * same xTimeIncrement parameter value will cause the task to execute with
+ * a fixed interface period.
+ *
+ * Example usage:
+   <pre>
+ // Perform an action every 10 ticks.
+ void vTaskFunction( void * pvParameters )
+ {
+ TickType_t xLastWakeTime;
+ const TickType_t xFrequency = 10;
+
+	 // Initialise the xLastWakeTime variable with the current time.
+	 xLastWakeTime = xTaskGetTickCount ();
+	 for( ;; )
+	 {
+		 // Wait for the next cycle.
+		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
+
+		 // Perform action here.
+	 }
+ }
+   </pre>
+ * \defgroup vTaskDelayUntil vTaskDelayUntil
+ * \ingroup TaskCtrl
+ */
+void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
+ * function to be available.
+ *
+ * A task will enter the Blocked state when it is waiting for an event.  The
+ * event it is waiting for can be a temporal event (waiting for a time), such
+ * as when vTaskDelay() is called, or an event on an object, such as when
+ * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
+ * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
+ * task will leave the Blocked state, and return from whichever function call
+ * placed the task into the Blocked state.
+ *
+ * @param xTask The handle of the task to remove from the Blocked state.
+ *
+ * @return If the task referenced by xTask was not in the Blocked state then
+ * pdFAIL is returned.  Otherwise pdPASS is returned.
+ *
+ * \defgroup xTaskAbortDelay xTaskAbortDelay
+ * \ingroup TaskCtrl
+ */
+BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Obtain the priority of any task.
+ *
+ * @param xTask Handle of the task to be queried.  Passing a NULL
+ * handle results in the priority of the calling task being returned.
+ *
+ * @return The priority of xTask.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to obtain the priority of the created task.
+	 // It was created with tskIDLE_PRIORITY, but may have changed
+	 // it itself.
+	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
+	 {
+		 // The task has changed it's priority.
+	 }
+
+	 // ...
+
+	 // Is our priority higher than the created task?
+	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
+	 {
+		 // Our priority (obtained using NULL handle) is higher.
+	 }
+ }
+   </pre>
+ * \defgroup uxTaskPriorityGet uxTaskPriorityGet
+ * \ingroup TaskCtrl
+ */
+UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
+ *
+ * A version of uxTaskPriorityGet() that can be used from an ISR.
+ */
+UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Obtain the state of any task.  States are encoded by the eTaskState
+ * enumerated type.
+ *
+ * @param xTask Handle of the task to be queried.
+ *
+ * @return The state of xTask at the time the function was called.  Note the
+ * state of the task might change between the function being called, and the
+ * functions return value being tested by the calling task.
+ */
+eTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
+ *
+ * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
+ * available.  See the configuration section for more information.
+ *
+ * Populates a TaskStatus_t structure with information about a task.
+ *
+ * @param xTask Handle of the task being queried.  If xTask is NULL then
+ * information will be returned about the calling task.
+ *
+ * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
+ * filled with information about the task referenced by the handle passed using
+ * the xTask parameter.
+ *
+ * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
+ * the stack high water mark of the task being queried.  Calculating the stack
+ * high water mark takes a relatively long time, and can make the system
+ * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
+ * allow the high water mark checking to be skipped.  The high watermark value
+ * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
+ * not set to pdFALSE;
+ *
+ * @param eState The TaskStatus_t structure contains a member to report the
+ * state of the task being queried.  Obtaining the task state is not as fast as
+ * a simple assignment - so the eState parameter is provided to allow the state
+ * information to be omitted from the TaskStatus_t structure.  To obtain state
+ * information then set eState to eInvalid - otherwise the value passed in
+ * eState will be reported as the task state in the TaskStatus_t structure.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+ TaskStatus_t xTaskDetails;
+
+    // Obtain the handle of a task from its name.
+    xHandle = xTaskGetHandle( "Task_Name" );
+
+    // Check the handle is not NULL.
+    configASSERT( xHandle );
+
+    // Use the handle to obtain further information about the task.
+    vTaskGetInfo( xHandle,
+                  &xTaskDetails,
+                  pdTRUE, // Include the high water mark in xTaskDetails.
+                  eInvalid ); // Include the task state in xTaskDetails.
+ }
+   </pre>
+ * \defgroup vTaskGetInfo vTaskGetInfo
+ * \ingroup TaskCtrl
+ */
+void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
+ *
+ * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Set the priority of any task.
+ *
+ * A context switch will occur before the function returns if the priority
+ * being set is higher than the currently executing task.
+ *
+ * @param xTask Handle to the task for which the priority is being set.
+ * Passing a NULL handle results in the priority of the calling task being set.
+ *
+ * @param uxNewPriority The priority to which the task will be set.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to raise the priority of the created task.
+	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
+
+	 // ...
+
+	 // Use a NULL handle to raise our priority to the same value.
+	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
+ }
+   </pre>
+ * \defgroup vTaskPrioritySet vTaskPrioritySet
+ * \ingroup TaskCtrl
+ */
+void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
+ *
+ * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Suspend any task.  When suspended a task will never get any microcontroller
+ * processing time, no matter what its priority.
+ *
+ * Calls to vTaskSuspend are not accumulative -
+ * i.e. calling vTaskSuspend () twice on the same task still only requires one
+ * call to vTaskResume () to ready the suspended task.
+ *
+ * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
+ * handle will cause the calling task to be suspended.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to suspend the created task.
+	 vTaskSuspend( xHandle );
+
+	 // ...
+
+	 // The created task will not run during this period, unless
+	 // another task calls vTaskResume( xHandle ).
+
+	 //...
+
+
+	 // Suspend ourselves.
+	 vTaskSuspend( NULL );
+
+	 // We cannot get here unless another task calls vTaskResume
+	 // with our handle as the parameter.
+ }
+   </pre>
+ * \defgroup vTaskSuspend vTaskSuspend
+ * \ingroup TaskCtrl
+ */
+void vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
+ *
+ * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Resumes a suspended task.
+ *
+ * A task that has been suspended by one or more calls to vTaskSuspend ()
+ * will be made available for running again by a single call to
+ * vTaskResume ().
+ *
+ * @param xTaskToResume Handle to the task being readied.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to suspend the created task.
+	 vTaskSuspend( xHandle );
+
+	 // ...
+
+	 // The created task will not run during this period, unless
+	 // another task calls vTaskResume( xHandle ).
+
+	 //...
+
+
+	 // Resume the suspended task ourselves.
+	 vTaskResume( xHandle );
+
+	 // The created task will once again get microcontroller processing
+	 // time in accordance with its priority within the system.
+ }
+   </pre>
+ * \defgroup vTaskResume vTaskResume
+ * \ingroup TaskCtrl
+ */
+void vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
+ *
+ * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
+ * available.  See the configuration section for more information.
+ *
+ * An implementation of vTaskResume() that can be called from within an ISR.
+ *
+ * A task that has been suspended by one or more calls to vTaskSuspend ()
+ * will be made available for running again by a single call to
+ * xTaskResumeFromISR ().
+ *
+ * xTaskResumeFromISR() should not be used to synchronise a task with an
+ * interrupt if there is a chance that the interrupt could arrive prior to the
+ * task being suspended - as this can lead to interrupts being missed. Use of a
+ * semaphore as a synchronisation mechanism would avoid this eventuality.
+ *
+ * @param xTaskToResume Handle to the task being readied.
+ *
+ * @return pdTRUE if resuming the task should result in a context switch,
+ * otherwise pdFALSE. This is used by the ISR to determine if a context switch
+ * may be required following the ISR.
+ *
+ * \defgroup vTaskResumeFromISR vTaskResumeFromISR
+ * \ingroup TaskCtrl
+ */
+BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------
+ * SCHEDULER CONTROL
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ * <pre>void vTaskStartScheduler( void );</pre>
+ *
+ * Starts the real time kernel tick processing.  After calling the kernel
+ * has control over which tasks are executed and when.
+ *
+ * See the demo application file main.c for an example of creating
+ * tasks and starting the kernel.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+	 // Create at least one task before starting the kernel.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
+
+	 // Start the real time kernel with preemption.
+	 vTaskStartScheduler ();
+
+	 // Will not get here unless a task calls vTaskEndScheduler ()
+ }
+   </pre>
+ *
+ * \defgroup vTaskStartScheduler vTaskStartScheduler
+ * \ingroup SchedulerControl
+ */
+void vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskEndScheduler( void );</pre>
+ *
+ * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
+ * in place of DOS, implements this function.
+ *
+ * Stops the real time kernel tick.  All created tasks will be automatically
+ * deleted and multitasking (either preemptive or cooperative) will
+ * stop.  Execution then resumes from the point where vTaskStartScheduler ()
+ * was called, as if vTaskStartScheduler () had just returned.
+ *
+ * See the demo application file main. c in the demo/PC directory for an
+ * example that uses vTaskEndScheduler ().
+ *
+ * vTaskEndScheduler () requires an exit function to be defined within the
+ * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
+ * performs hardware specific operations such as stopping the kernel tick.
+ *
+ * vTaskEndScheduler () will cause all of the resources allocated by the
+ * kernel to be freed - but will not free resources allocated by application
+ * tasks.
+ *
+ * Example usage:
+   <pre>
+ void vTaskCode( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+
+		 // At some point we want to end the real time kernel processing
+		 // so call ...
+		 vTaskEndScheduler ();
+	 }
+ }
+
+ void vAFunction( void )
+ {
+	 // Create at least one task before starting the kernel.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
+
+	 // Start the real time kernel with preemption.
+	 vTaskStartScheduler ();
+
+	 // Will only get here when the vTaskCode () task has called
+	 // vTaskEndScheduler ().  When we get here we are back to single task
+	 // execution.
+ }
+   </pre>
+ *
+ * \defgroup vTaskEndScheduler vTaskEndScheduler
+ * \ingroup SchedulerControl
+ */
+void vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskSuspendAll( void );</pre>
+ *
+ * Suspends the scheduler without disabling interrupts.  Context switches will
+ * not occur while the scheduler is suspended.
+ *
+ * After calling vTaskSuspendAll () the calling task will continue to execute
+ * without risk of being swapped out until a call to xTaskResumeAll () has been
+ * made.
+ *
+ * API functions that have the potential to cause a context switch (for example,
+ * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
+ * is suspended.
+ *
+ * Example usage:
+   <pre>
+ void vTask1( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+
+		 // ...
+
+		 // At some point the task wants to perform a long operation during
+		 // which it does not want to get swapped out.  It cannot use
+		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
+		 // operation may cause interrupts to be missed - including the
+		 // ticks.
+
+		 // Prevent the real time kernel swapping out the task.
+		 vTaskSuspendAll ();
+
+		 // Perform the operation here.  There is no need to use critical
+		 // sections as we have all the microcontroller processing time.
+		 // During this time interrupts will still operate and the kernel
+		 // tick count will be maintained.
+
+		 // ...
+
+		 // The operation is complete.  Restart the kernel.
+		 xTaskResumeAll ();
+	 }
+ }
+   </pre>
+ * \defgroup vTaskSuspendAll vTaskSuspendAll
+ * \ingroup SchedulerControl
+ */
+void vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>BaseType_t xTaskResumeAll( void );</pre>
+ *
+ * Resumes scheduler activity after it was suspended by a call to
+ * vTaskSuspendAll().
+ *
+ * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
+ * that were previously suspended by a call to vTaskSuspend().
+ *
+ * @return If resuming the scheduler caused a context switch then pdTRUE is
+ *		  returned, otherwise pdFALSE is returned.
+ *
+ * Example usage:
+   <pre>
+ void vTask1( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+
+		 // ...
+
+		 // At some point the task wants to perform a long operation during
+		 // which it does not want to get swapped out.  It cannot use
+		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
+		 // operation may cause interrupts to be missed - including the
+		 // ticks.
+
+		 // Prevent the real time kernel swapping out the task.
+		 vTaskSuspendAll ();
+
+		 // Perform the operation here.  There is no need to use critical
+		 // sections as we have all the microcontroller processing time.
+		 // During this time interrupts will still operate and the real
+		 // time kernel tick count will be maintained.
+
+		 // ...
+
+		 // The operation is complete.  Restart the kernel.  We want to force
+		 // a context switch - but there is no point if resuming the scheduler
+		 // caused a context switch already.
+		 if( !xTaskResumeAll () )
+		 {
+			  taskYIELD ();
+		 }
+	 }
+ }
+   </pre>
+ * \defgroup xTaskResumeAll xTaskResumeAll
+ * \ingroup SchedulerControl
+ */
+BaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------
+ * TASK UTILITIES
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
+ *
+ * @return The count of ticks since vTaskStartScheduler was called.
+ *
+ * \defgroup xTaskGetTickCount xTaskGetTickCount
+ * \ingroup TaskUtils
+ */
+TickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
+ *
+ * @return The count of ticks since vTaskStartScheduler was called.
+ *
+ * This is a version of xTaskGetTickCount() that is safe to be called from an
+ * ISR - provided that TickType_t is the natural word size of the
+ * microcontroller being used or interrupt nesting is either not supported or
+ * not being used.
+ *
+ * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
+ * \ingroup TaskUtils
+ */
+TickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
+ *
+ * @return The number of tasks that the real time kernel is currently managing.
+ * This includes all ready, blocked and suspended tasks.  A task that
+ * has been deleted but not yet freed by the idle task will also be
+ * included in the count.
+ *
+ * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
+ * \ingroup TaskUtils
+ */
+UBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
+ *
+ * @return The text (human readable) name of the task referenced by the handle
+ * xTaskToQuery.  A task can query its own name by either passing in its own
+ * handle, or by setting xTaskToQuery to NULL.
+ *
+ * \defgroup pcTaskGetName pcTaskGetName
+ * \ingroup TaskUtils
+ */
+char *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task. h
+ * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
+ *
+ * NOTE:  This function takes a relatively long time to complete and should be
+ * used sparingly.
+ *
+ * @return The handle of the task that has the human readable name pcNameToQuery.
+ * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
+ * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
+ *
+ * \defgroup pcTaskGetHandle pcTaskGetHandle
+ * \ingroup TaskUtils
+ */
+TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task.h
+ * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
+ *
+ * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
+ * this function to be available.
+ *
+ * Returns the high water mark of the stack associated with xTask.  That is,
+ * the minimum free stack space there has been (in words, so on a 32 bit machine
+ * a value of 1 means 4 bytes) since the task started.  The smaller the returned
+ * number the closer the task has come to overflowing its stack.
+ *
+ * @param xTask Handle of the task associated with the stack to be checked.
+ * Set xTask to NULL to check the stack of the calling task.
+ *
+ * @return The smallest amount of free stack space there has been (in words, so
+ * actual spaces on the stack rather than bytes) since the task referenced by
+ * xTask was created.
+ */
+UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/* When using trace macros it is sometimes necessary to include task.h before
+FreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
+so the following two prototypes will cause a compilation error.  This can be
+fixed by simply guarding against the inclusion of these two prototypes unless
+they are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
+constant. */
+#ifdef configUSE_APPLICATION_TASK_TAG
+	#if configUSE_APPLICATION_TASK_TAG == 1
+		/**
+		 * task.h
+		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
+		 *
+		 * Sets pxHookFunction to be the task hook function used by the task xTask.
+		 * Passing xTask as NULL has the effect of setting the calling tasks hook
+		 * function.
+		 */
+		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
+
+		/**
+		 * task.h
+		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
+		 *
+		 * Returns the pxHookFunction value assigned to the task xTask.
+		 */
+		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
+#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
+
+#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
+
+	/* Each task contains an array of pointers that is dimensioned by the
+	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
+	kernel does not use the pointers itself, so the application writer can use
+	the pointers for any purpose they wish.  The following two functions are
+	used to set and query a pointer respectively. */
+	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
+	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/**
+ * task.h
+ * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
+ *
+ * Calls the hook function associated with xTask.  Passing xTask as NULL has
+ * the effect of calling the Running tasks (the calling task) hook function.
+ *
+ * pvParameter is passed to the hook function for the task to interpret as it
+ * wants.  The return value is the value returned by the task hook function
+ * registered by the user.
+ */
+BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
+
+/**
+ * xTaskGetIdleTaskHandle() is only available if
+ * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
+ *
+ * Simply returns the handle of the idle task.  It is not valid to call
+ * xTaskGetIdleTaskHandle() before the scheduler has been started.
+ */
+TaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
+ * uxTaskGetSystemState() to be available.
+ *
+ * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
+ * the system.  TaskStatus_t structures contain, among other things, members
+ * for the task handle, task name, task priority, task state, and total amount
+ * of run time consumed by the task.  See the TaskStatus_t structure
+ * definition in this file for the full member list.
+ *
+ * NOTE:  This function is intended for debugging use only as its use results in
+ * the scheduler remaining suspended for an extended period.
+ *
+ * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
+ * The array must contain at least one TaskStatus_t structure for each task
+ * that is under the control of the RTOS.  The number of tasks under the control
+ * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
+ *
+ * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
+ * parameter.  The size is specified as the number of indexes in the array, or
+ * the number of TaskStatus_t structures contained in the array, not by the
+ * number of bytes in the array.
+ *
+ * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
+ * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
+ * total run time (as defined by the run time stats clock, see
+ * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
+ * pulTotalRunTime can be set to NULL to omit the total run time information.
+ *
+ * @return The number of TaskStatus_t structures that were populated by
+ * uxTaskGetSystemState().  This should equal the number returned by the
+ * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
+ * in the uxArraySize parameter was too small.
+ *
+ * Example usage:
+   <pre>
+    // This example demonstrates how a human readable table of run time stats
+	// information is generated from raw data provided by uxTaskGetSystemState().
+	// The human readable table is written to pcWriteBuffer
+	void vTaskGetRunTimeStats( char *pcWriteBuffer )
+	{
+	TaskStatus_t *pxTaskStatusArray;
+	volatile UBaseType_t uxArraySize, x;
+	uint32_t ulTotalRunTime, ulStatsAsPercentage;
+
+		// Make sure the write buffer does not contain a string.
+		*pcWriteBuffer = 0x00;
+
+		// Take a snapshot of the number of tasks in case it changes while this
+		// function is executing.
+		uxArraySize = uxTaskGetNumberOfTasks();
+
+		// Allocate a TaskStatus_t structure for each task.  An array could be
+		// allocated statically at compile time.
+		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
+
+		if( pxTaskStatusArray != NULL )
+		{
+			// Generate raw status information about each task.
+			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
+
+			// For percentage calculations.
+			ulTotalRunTime /= 100UL;
+
+			// Avoid divide by zero errors.
+			if( ulTotalRunTime > 0 )
+			{
+				// For each populated position in the pxTaskStatusArray array,
+				// format the raw data as human readable ASCII data
+				for( x = 0; x < uxArraySize; x++ )
+				{
+					// What percentage of the total run time has the task used?
+					// This will always be rounded down to the nearest integer.
+					// ulTotalRunTimeDiv100 has already been divided by 100.
+					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
+
+					if( ulStatsAsPercentage > 0UL )
+					{
+						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
+					}
+					else
+					{
+						// If the percentage is zero here then the task has
+						// consumed less than 1% of the total run time.
+						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
+					}
+
+					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
+				}
+			}
+
+			// The array is no longer needed, free the memory it consumes.
+			vPortFree( pxTaskStatusArray );
+		}
+	}
+	</pre>
+ */
+UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
+ *
+ * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
+ * both be defined as 1 for this function to be available.  See the
+ * configuration section of the FreeRTOS.org website for more information.
+ *
+ * NOTE 1: This function will disable interrupts for its duration.  It is
+ * not intended for normal application runtime use but as a debug aid.
+ *
+ * Lists all the current tasks, along with their current state and stack
+ * usage high water mark.
+ *
+ * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
+ * suspended ('S').
+ *
+ * PLEASE NOTE:
+ *
+ * This function is provided for convenience only, and is used by many of the
+ * demo applications.  Do not consider it to be part of the scheduler.
+ *
+ * vTaskList() calls uxTaskGetSystemState(), then formats part of the
+ * uxTaskGetSystemState() output into a human readable table that displays task
+ * names, states and stack usage.
+ *
+ * vTaskList() has a dependency on the sprintf() C library function that might
+ * bloat the code size, use a lot of stack, and provide different results on
+ * different platforms.  An alternative, tiny, third party, and limited
+ * functionality implementation of sprintf() is provided in many of the
+ * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
+ * printf-stdarg.c does not provide a full snprintf() implementation!).
+ *
+ * It is recommended that production systems call uxTaskGetSystemState()
+ * directly to get access to raw stats data, rather than indirectly through a
+ * call to vTaskList().
+ *
+ * @param pcWriteBuffer A buffer into which the above mentioned details
+ * will be written, in ASCII form.  This buffer is assumed to be large
+ * enough to contain the generated report.  Approximately 40 bytes per
+ * task should be sufficient.
+ *
+ * \defgroup vTaskList vTaskList
+ * \ingroup TaskUtils
+ */
+void vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task. h
+ * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
+ *
+ * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
+ * must both be defined as 1 for this function to be available.  The application
+ * must also then provide definitions for
+ * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
+ * to configure a peripheral timer/counter and return the timers current count
+ * value respectively.  The counter should be at least 10 times the frequency of
+ * the tick count.
+ *
+ * NOTE 1: This function will disable interrupts for its duration.  It is
+ * not intended for normal application runtime use but as a debug aid.
+ *
+ * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
+ * accumulated execution time being stored for each task.  The resolution
+ * of the accumulated time value depends on the frequency of the timer
+ * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
+ * Calling vTaskGetRunTimeStats() writes the total execution time of each
+ * task into a buffer, both as an absolute count value and as a percentage
+ * of the total system execution time.
+ *
+ * NOTE 2:
+ *
+ * This function is provided for convenience only, and is used by many of the
+ * demo applications.  Do not consider it to be part of the scheduler.
+ *
+ * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
+ * uxTaskGetSystemState() output into a human readable table that displays the
+ * amount of time each task has spent in the Running state in both absolute and
+ * percentage terms.
+ *
+ * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
+ * that might bloat the code size, use a lot of stack, and provide different
+ * results on different platforms.  An alternative, tiny, third party, and
+ * limited functionality implementation of sprintf() is provided in many of the
+ * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
+ * printf-stdarg.c does not provide a full snprintf() implementation!).
+ *
+ * It is recommended that production systems call uxTaskGetSystemState() directly
+ * to get access to raw stats data, rather than indirectly through a call to
+ * vTaskGetRunTimeStats().
+ *
+ * @param pcWriteBuffer A buffer into which the execution times will be
+ * written, in ASCII form.  This buffer is assumed to be large enough to
+ * contain the generated report.  Approximately 40 bytes per task should
+ * be sufficient.
+ *
+ * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
+ * \ingroup TaskUtils
+ */
+void vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * A notification sent to a task will remain pending until it is cleared by the
+ * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
+ * already in the Blocked state to wait for a notification when the notification
+ * arrives then the task will automatically be removed from the Blocked state
+ * (unblocked) and the notification cleared.
+ *
+ * A task can use xTaskNotifyWait() to [optionally] block to wait for a
+ * notification to be pending, or ulTaskNotifyTake() to [optionally] block
+ * to wait for its notification value to have a non-zero value.  The task does
+ * not consume any CPU time while it is in the Blocked state.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @param ulValue Data that can be sent with the notification.  How the data is
+ * used depends on the value of the eAction parameter.
+ *
+ * @param eAction Specifies how the notification updates the task's notification
+ * value, if at all.  Valid values for eAction are as follows:
+ *
+ * eSetBits -
+ * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
+ * always returns pdPASS in this case.
+ *
+ * eIncrement -
+ * The task's notification value is incremented.  ulValue is not used and
+ * xTaskNotify() always returns pdPASS in this case.
+ *
+ * eSetValueWithOverwrite -
+ * The task's notification value is set to the value of ulValue, even if the
+ * task being notified had not yet processed the previous notification (the
+ * task already had a notification pending).  xTaskNotify() always returns
+ * pdPASS in this case.
+ *
+ * eSetValueWithoutOverwrite -
+ * If the task being notified did not already have a notification pending then
+ * the task's notification value is set to ulValue and xTaskNotify() will
+ * return pdPASS.  If the task being notified already had a notification
+ * pending then no action is performed and pdFAIL is returned.
+ *
+ * eNoAction -
+ * The task receives a notification without its notification value being
+ * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
+ * this case.
+ *
+ *  pulPreviousNotificationValue -
+ *  Can be used to pass out the subject task's notification value before any
+ *  bits are modified by the notify function.
+ *
+ * @return Dependent on the value of eAction.  See the description of the
+ * eAction parameter.
+ *
+ * \defgroup xTaskNotify xTaskNotify
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
+#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
+#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * A version of xTaskNotify() that can be used from an interrupt service routine
+ * (ISR).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * A notification sent to a task will remain pending until it is cleared by the
+ * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
+ * already in the Blocked state to wait for a notification when the notification
+ * arrives then the task will automatically be removed from the Blocked state
+ * (unblocked) and the notification cleared.
+ *
+ * A task can use xTaskNotifyWait() to [optionally] block to wait for a
+ * notification to be pending, or ulTaskNotifyTake() to [optionally] block
+ * to wait for its notification value to have a non-zero value.  The task does
+ * not consume any CPU time while it is in the Blocked state.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @param ulValue Data that can be sent with the notification.  How the data is
+ * used depends on the value of the eAction parameter.
+ *
+ * @param eAction Specifies how the notification updates the task's notification
+ * value, if at all.  Valid values for eAction are as follows:
+ *
+ * eSetBits -
+ * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
+ * always returns pdPASS in this case.
+ *
+ * eIncrement -
+ * The task's notification value is incremented.  ulValue is not used and
+ * xTaskNotify() always returns pdPASS in this case.
+ *
+ * eSetValueWithOverwrite -
+ * The task's notification value is set to the value of ulValue, even if the
+ * task being notified had not yet processed the previous notification (the
+ * task already had a notification pending).  xTaskNotify() always returns
+ * pdPASS in this case.
+ *
+ * eSetValueWithoutOverwrite -
+ * If the task being notified did not already have a notification pending then
+ * the task's notification value is set to ulValue and xTaskNotify() will
+ * return pdPASS.  If the task being notified already had a notification
+ * pending then no action is performed and pdFAIL is returned.
+ *
+ * eNoAction -
+ * The task receives a notification without its notification value being
+ * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
+ * this case.
+ *
+ * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
+ * task to which the notification was sent to leave the Blocked state, and the
+ * unblocked task has a priority higher than the currently running task.  If
+ * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
+ * be requested before the interrupt is exited.  How a context switch is
+ * requested from an ISR is dependent on the port - see the documentation page
+ * for the port in use.
+ *
+ * @return Dependent on the value of eAction.  See the description of the
+ * eAction parameter.
+ *
+ * \defgroup xTaskNotify xTaskNotify
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
+#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * A notification sent to a task will remain pending until it is cleared by the
+ * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
+ * already in the Blocked state to wait for a notification when the notification
+ * arrives then the task will automatically be removed from the Blocked state
+ * (unblocked) and the notification cleared.
+ *
+ * A task can use xTaskNotifyWait() to [optionally] block to wait for a
+ * notification to be pending, or ulTaskNotifyTake() to [optionally] block
+ * to wait for its notification value to have a non-zero value.  The task does
+ * not consume any CPU time while it is in the Blocked state.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
+ * will be cleared in the calling task's notification value before the task
+ * checks to see if any notifications are pending, and optionally blocks if no
+ * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
+ * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
+ * the effect of resetting the task's notification value to 0.  Setting
+ * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
+ *
+ * @param ulBitsToClearOnExit If a notification is pending or received before
+ * the calling task exits the xTaskNotifyWait() function then the task's
+ * notification value (see the xTaskNotify() API function) is passed out using
+ * the pulNotificationValue parameter.  Then any bits that are set in
+ * ulBitsToClearOnExit will be cleared in the task's notification value (note
+ * *pulNotificationValue is set before any bits are cleared).  Setting
+ * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
+ * (if limits.h is not included) will have the effect of resetting the task's
+ * notification value to 0 before the function exits.  Setting
+ * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
+ * when the function exits (in which case the value passed out in
+ * pulNotificationValue will match the task's notification value).
+ *
+ * @param pulNotificationValue Used to pass the task's notification value out
+ * of the function.  Note the value passed out will not be effected by the
+ * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
+ *
+ * @param xTicksToWait The maximum amount of time that the task should wait in
+ * the Blocked state for a notification to be received, should a notification
+ * not already be pending when xTaskNotifyWait() was called.  The task
+ * will not consume any processing time while it is in the Blocked state.  This
+ * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
+ * used to convert a time specified in milliseconds to a time specified in
+ * ticks.
+ *
+ * @return If a notification was received (including notifications that were
+ * already pending when xTaskNotifyWait was called) then pdPASS is
+ * returned.  Otherwise pdFAIL is returned.
+ *
+ * \defgroup xTaskNotifyWait xTaskNotifyWait
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
+ * to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * xTaskNotifyGive() is a helper macro intended for use when task notifications
+ * are used as light weight and faster binary or counting semaphore equivalents.
+ * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
+ * the equivalent action that instead uses a task notification is
+ * xTaskNotifyGive().
+ *
+ * When task notifications are being used as a binary or counting semaphore
+ * equivalent then the task being notified should wait for the notification
+ * using the ulTaskNotificationTake() API function rather than the
+ * xTaskNotifyWait() API function.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
+ * eAction parameter set to eIncrement - so pdPASS is always returned.
+ *
+ * \defgroup xTaskNotifyGive xTaskNotifyGive
+ * \ingroup TaskNotifications
+ */
+#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
+
+/**
+ * task. h
+ * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
+ * to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * A version of xTaskNotifyGive() that can be called from an interrupt service
+ * routine (ISR).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * vTaskNotifyGiveFromISR() is intended for use when task notifications are
+ * used as light weight and faster binary or counting semaphore equivalents.
+ * Actual FreeRTOS semaphores are given from an ISR using the
+ * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
+ * a task notification is vTaskNotifyGiveFromISR().
+ *
+ * When task notifications are being used as a binary or counting semaphore
+ * equivalent then the task being notified should wait for the notification
+ * using the ulTaskNotificationTake() API function rather than the
+ * xTaskNotifyWait() API function.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
+ * task to which the notification was sent to leave the Blocked state, and the
+ * unblocked task has a priority higher than the currently running task.  If
+ * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
+ * should be requested before the interrupt is exited.  How a context switch is
+ * requested from an ISR is dependent on the port - see the documentation page
+ * for the port in use.
+ *
+ * \defgroup xTaskNotifyWait xTaskNotifyWait
+ * \ingroup TaskNotifications
+ */
+void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * ulTaskNotifyTake() is intended for use when a task notification is used as a
+ * faster and lighter weight binary or counting semaphore alternative.  Actual
+ * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
+ * equivalent action that instead uses a task notification is
+ * ulTaskNotifyTake().
+ *
+ * When a task is using its notification value as a binary or counting semaphore
+ * other tasks should send notifications to it using the xTaskNotifyGive()
+ * macro, or xTaskNotify() function with the eAction parameter set to
+ * eIncrement.
+ *
+ * ulTaskNotifyTake() can either clear the task's notification value to
+ * zero on exit, in which case the notification value acts like a binary
+ * semaphore, or decrement the task's notification value on exit, in which case
+ * the notification value acts like a counting semaphore.
+ *
+ * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
+ * the task's notification value to be non-zero.  The task does not consume any
+ * CPU time while it is in the Blocked state.
+ *
+ * Where as xTaskNotifyWait() will return when a notification is pending,
+ * ulTaskNotifyTake() will return when the task's notification value is
+ * not zero.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
+ * notification value is decremented when the function exits.  In this way the
+ * notification value acts like a counting semaphore.  If xClearCountOnExit is
+ * not pdFALSE then the task's notification value is cleared to zero when the
+ * function exits.  In this way the notification value acts like a binary
+ * semaphore.
+ *
+ * @param xTicksToWait The maximum amount of time that the task should wait in
+ * the Blocked state for the task's notification value to be greater than zero,
+ * should the count not already be greater than zero when
+ * ulTaskNotifyTake() was called.  The task will not consume any processing
+ * time while it is in the Blocked state.  This is specified in kernel ticks,
+ * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
+ * specified in milliseconds to a time specified in ticks.
+ *
+ * @return The task's notification count before it is either cleared to zero or
+ * decremented (see the xClearCountOnExit parameter).
+ *
+ * \defgroup ulTaskNotifyTake ulTaskNotifyTake
+ * \ingroup TaskNotifications
+ */
+uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
+ *
+ * If the notification state of the task referenced by the handle xTask is
+ * eNotified, then set the task's notification state to eNotWaitingNotification.
+ * The task's notification value is not altered.  Set xTask to NULL to clear the
+ * notification state of the calling task.
+ *
+ * @return pdTRUE if the task's notification state was set to
+ * eNotWaitingNotification, otherwise pdFALSE.
+ * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
+
+/*-----------------------------------------------------------
+ * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
+ *----------------------------------------------------------*/
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
+ * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
+ * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * Called from the real time kernel tick (either preemptive or cooperative),
+ * this increments the tick count and checks if any tasks that are blocked
+ * for a finite period required removing from a blocked list and placing on
+ * a ready list.  If a non-zero value is returned then a context switch is
+ * required because either:
+ *   + A task was removed from a blocked list because its timeout had expired,
+ *     or
+ *   + Time slicing is in use and there is a task of equal priority to the
+ *     currently running task.
+ */
+BaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
+ * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
+ *
+ * Removes the calling task from the ready list and places it both
+ * on the list of tasks waiting for a particular event, and the
+ * list of delayed tasks.  The task will be removed from both lists
+ * and replaced on the ready list should either the event occur (and
+ * there be no higher priority tasks waiting on the same event) or
+ * the delay period expires.
+ *
+ * The 'unordered' version replaces the event list item value with the
+ * xItemValue value, and inserts the list item at the end of the list.
+ *
+ * The 'ordered' version uses the existing event list item value (which is the
+ * owning tasks priority) to insert the list item into the event list is task
+ * priority order.
+ *
+ * @param pxEventList The list containing tasks that are blocked waiting
+ * for the event to occur.
+ *
+ * @param xItemValue The item value to use for the event list item when the
+ * event list is not ordered by task priority.
+ *
+ * @param xTicksToWait The maximum amount of time that the task should wait
+ * for the event to occur.  This is specified in kernel ticks,the constant
+ * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
+ * period.
+ */
+void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
+ * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
+ *
+ * This function performs nearly the same function as vTaskPlaceOnEventList().
+ * The difference being that this function does not permit tasks to block
+ * indefinitely, whereas vTaskPlaceOnEventList() does.
+ *
+ */
+void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
+ * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
+ *
+ * Removes a task from both the specified event list and the list of blocked
+ * tasks, and places it on a ready queue.
+ *
+ * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
+ * if either an event occurs to unblock a task, or the block timeout period
+ * expires.
+ *
+ * xTaskRemoveFromEventList() is used when the event list is in task priority
+ * order.  It removes the list item from the head of the event list as that will
+ * have the highest priority owning task of all the tasks on the event list.
+ * vTaskRemoveFromUnorderedEventList() is used when the event list is not
+ * ordered and the event list items hold something other than the owning tasks
+ * priority.  In this case the event list item value is updated to the value
+ * passed in the xItemValue parameter.
+ *
+ * @return pdTRUE if the task being removed has a higher priority than the task
+ * making the call, otherwise pdFALSE.
+ */
+BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
+void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
+ * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
+ * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * Sets the pointer to the current TCB to the TCB of the highest priority task
+ * that is ready to run.
+ */
+void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
+ * THE EVENT BITS MODULE.
+ */
+TickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Return the handle of the calling task.
+ */
+TaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Capture the current time status for future reference.
+ */
+void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
+
+/*
+ * Compare the time status now with that previously captured to see if the
+ * timeout has expired.
+ */
+BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
+
+/*
+ * Shortcut used by the queue implementation to prevent unnecessary call to
+ * taskYIELD();
+ */
+void vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Returns the scheduler state as taskSCHEDULER_RUNNING,
+ * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
+ */
+BaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Raises the priority of the mutex holder to that of the calling task should
+ * the mutex holder have a priority less than the calling task.
+ */
+BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
+
+/*
+ * Set the priority of a task back to its proper priority in the case that it
+ * inherited a higher priority while it was holding a semaphore.
+ */
+BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
+
+/*
+ * If a higher priority task attempting to obtain a mutex caused a lower
+ * priority task to inherit the higher priority task's priority - but the higher
+ * priority task then timed out without obtaining the mutex, then the lower
+ * priority task will disinherit the priority again - but only down as far as
+ * the highest priority task that is still waiting for the mutex (if there were
+ * more than one task waiting for the mutex).
+ */
+void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;
+
+/*
+ * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
+ */
+UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/*
+ * Set the uxTaskNumber of the task referenced by the xTask parameter to
+ * uxHandle.
+ */
+void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
+
+/*
+ * Only available when configUSE_TICKLESS_IDLE is set to 1.
+ * If tickless mode is being used, or a low power mode is implemented, then
+ * the tick interrupt will not execute during idle periods.  When this is the
+ * case, the tick count value maintained by the scheduler needs to be kept up
+ * to date with the actual execution time by being skipped forward by a time
+ * equal to the idle period.
+ */
+void vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
+
+/*
+ * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
+ * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
+ * specific sleep function to determine if it is ok to proceed with the sleep,
+ * and if it is ok to proceed, if it is ok to sleep indefinitely.
+ *
+ * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
+ * called with the scheduler suspended, not from within a critical section.  It
+ * is therefore possible for an interrupt to request a context switch between
+ * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
+ * entered.  eTaskConfirmSleepModeStatus() should be called from a short
+ * critical section between the timer being stopped and the sleep mode being
+ * entered to ensure it is ok to proceed into the sleep mode.
+ */
+eSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * For internal use only.  Increment the mutex held count when a mutex is
+ * taken and return the handle of the task that has taken the mutex.
+ */
+void *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * For internal use only.  Same as vTaskSetTimeOutState(), but without a critial
+ * section.
+ */
+void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* INC_TASK_H */
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/include/timers.h ./libs/freertos/include/timers.h
--- a_bRU7kv/libs/freertos/include/timers.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/include/timers.h	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,1277 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#ifndef TIMERS_H
+#define TIMERS_H
+
+#ifndef INC_FREERTOS_H
+	#error "include FreeRTOS.h must appear in source files before include timers.h"
+#endif
+
+/*lint -save -e537 This headers are only multiply included if the application code
+happens to also be including task.h. */
+#include "task.h"
+/*lint -restore */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-----------------------------------------------------------
+ * MACROS AND DEFINITIONS
+ *----------------------------------------------------------*/
+
+/* IDs for commands that can be sent/received on the timer queue.  These are to
+be used solely through the macros that make up the public software timer API,
+as defined below.  The commands that are sent from interrupts must use the
+highest numbers as tmrFIRST_FROM_ISR_COMMAND is used to determine if the task
+or interrupt version of the queue send function should be used. */
+#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR 	( ( BaseType_t ) -2 )
+#define tmrCOMMAND_EXECUTE_CALLBACK				( ( BaseType_t ) -1 )
+#define tmrCOMMAND_START_DONT_TRACE				( ( BaseType_t ) 0 )
+#define tmrCOMMAND_START					    ( ( BaseType_t ) 1 )
+#define tmrCOMMAND_RESET						( ( BaseType_t ) 2 )
+#define tmrCOMMAND_STOP							( ( BaseType_t ) 3 )
+#define tmrCOMMAND_CHANGE_PERIOD				( ( BaseType_t ) 4 )
+#define tmrCOMMAND_DELETE						( ( BaseType_t ) 5 )
+
+#define tmrFIRST_FROM_ISR_COMMAND				( ( BaseType_t ) 6 )
+#define tmrCOMMAND_START_FROM_ISR				( ( BaseType_t ) 6 )
+#define tmrCOMMAND_RESET_FROM_ISR				( ( BaseType_t ) 7 )
+#define tmrCOMMAND_STOP_FROM_ISR				( ( BaseType_t ) 8 )
+#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR		( ( BaseType_t ) 9 )
+
+
+/**
+ * Type by which software timers are referenced.  For example, a call to
+ * xTimerCreate() returns an TimerHandle_t variable that can then be used to
+ * reference the subject timer in calls to other software timer API functions
+ * (for example, xTimerStart(), xTimerReset(), etc.).
+ */
+typedef void * TimerHandle_t;
+
+/*
+ * Defines the prototype to which timer callback functions must conform.
+ */
+typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );
+
+/*
+ * Defines the prototype to which functions used with the
+ * xTimerPendFunctionCallFromISR() function must conform.
+ */
+typedef void (*PendedFunction_t)( void *, uint32_t );
+
+/**
+ * TimerHandle_t xTimerCreate( 	const char * const pcTimerName,
+ * 								TickType_t xTimerPeriodInTicks,
+ * 								UBaseType_t uxAutoReload,
+ * 								void * pvTimerID,
+ * 								TimerCallbackFunction_t pxCallbackFunction );
+ *
+ * Creates a new software timer instance, and returns a handle by which the
+ * created software timer can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, software timers use a block
+ * of memory, in which the timer data structure is stored.  If a software timer
+ * is created using xTimerCreate() then the required memory is automatically
+ * dynamically allocated inside the xTimerCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a software timer is created using
+ * xTimerCreateStatic() then the application writer must provide the memory that
+ * will get used by the software timer.  xTimerCreateStatic() therefore allows a
+ * software timer to be created without using any dynamic memory allocation.
+ *
+ * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
+ * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
+ * xTimerChangePeriodFromISR() API functions can all be used to transition a
+ * timer into the active state.
+ *
+ * @param pcTimerName A text name that is assigned to the timer.  This is done
+ * purely to assist debugging.  The kernel itself only ever references a timer
+ * by its handle, and never by its name.
+ *
+ * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
+ * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
+ * has been specified in milliseconds.  For example, if the timer must expire
+ * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
+ * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
+ * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
+ * equal to 1000.
+ *
+ * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
+ * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
+ * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
+ * enter the dormant state after it expires.
+ *
+ * @param pvTimerID An identifier that is assigned to the timer being created.
+ * Typically this would be used in the timer callback function to identify which
+ * timer expired when the same callback function is assigned to more than one
+ * timer.
+ *
+ * @param pxCallbackFunction The function to call when the timer expires.
+ * Callback functions must have the prototype defined by TimerCallbackFunction_t,
+ * which is	"void vCallbackFunction( TimerHandle_t xTimer );".
+ *
+ * @return If the timer is successfully created then a handle to the newly
+ * created timer is returned.  If the timer cannot be created (because either
+ * there is insufficient FreeRTOS heap remaining to allocate the timer
+ * structures, or the timer period was set to 0) then NULL is returned.
+ *
+ * Example usage:
+ * @verbatim
+ * #define NUM_TIMERS 5
+ *
+ * // An array to hold handles to the created timers.
+ * TimerHandle_t xTimers[ NUM_TIMERS ];
+ *
+ * // An array to hold a count of the number of times each timer expires.
+ * int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
+ *
+ * // Define a callback function that will be used by multiple timer instances.
+ * // The callback function does nothing but count the number of times the
+ * // associated timer expires, and stop the timer once the timer has expired
+ * // 10 times.
+ * void vTimerCallback( TimerHandle_t pxTimer )
+ * {
+ * int32_t lArrayIndex;
+ * const int32_t xMaxExpiryCountBeforeStopping = 10;
+ *
+ * 	   // Optionally do something if the pxTimer parameter is NULL.
+ * 	   configASSERT( pxTimer );
+ *
+ *     // Which timer expired?
+ *     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
+ *
+ *     // Increment the number of times that pxTimer has expired.
+ *     lExpireCounters[ lArrayIndex ] += 1;
+ *
+ *     // If the timer has expired 10 times then stop it from running.
+ *     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
+ *     {
+ *         // Do not use a block time if calling a timer API function from a
+ *         // timer callback function, as doing so could cause a deadlock!
+ *         xTimerStop( pxTimer, 0 );
+ *     }
+ * }
+ *
+ * void main( void )
+ * {
+ * int32_t x;
+ *
+ *     // Create then start some timers.  Starting the timers before the scheduler
+ *     // has been started means the timers will start running immediately that
+ *     // the scheduler starts.
+ *     for( x = 0; x < NUM_TIMERS; x++ )
+ *     {
+ *         xTimers[ x ] = xTimerCreate(    "Timer",       // Just a text name, not used by the kernel.
+ *                                         ( 100 * x ),   // The timer period in ticks.
+ *                                         pdTRUE,        // The timers will auto-reload themselves when they expire.
+ *                                         ( void * ) x,  // Assign each timer a unique id equal to its array index.
+ *                                         vTimerCallback // Each timer calls the same callback when it expires.
+ *                                     );
+ *
+ *         if( xTimers[ x ] == NULL )
+ *         {
+ *             // The timer was not created.
+ *         }
+ *         else
+ *         {
+ *             // Start the timer.  No block time is specified, and even if one was
+ *             // it would be ignored because the scheduler has not yet been
+ *             // started.
+ *             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
+ *             {
+ *                 // The timer could not be set into the Active state.
+ *             }
+ *         }
+ *     }
+ *
+ *     // ...
+ *     // Create tasks here.
+ *     // ...
+ *
+ *     // Starting the scheduler will start the timers running as they have already
+ *     // been set into the active state.
+ *     vTaskStartScheduler();
+ *
+ *     // Should not reach here.
+ *     for( ;; );
+ * }
+ * @endverbatim
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+								const TickType_t xTimerPeriodInTicks,
+								const UBaseType_t uxAutoReload,
+								void * const pvTimerID,
+								TimerCallbackFunction_t pxCallbackFunction ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * TimerHandle_t xTimerCreateStatic(const char * const pcTimerName,
+ * 									TickType_t xTimerPeriodInTicks,
+ * 									UBaseType_t uxAutoReload,
+ * 									void * pvTimerID,
+ * 									TimerCallbackFunction_t pxCallbackFunction,
+ *									StaticTimer_t *pxTimerBuffer );
+ *
+ * Creates a new software timer instance, and returns a handle by which the
+ * created software timer can be referenced.
+ *
+ * Internally, within the FreeRTOS implementation, software timers use a block
+ * of memory, in which the timer data structure is stored.  If a software timer
+ * is created using xTimerCreate() then the required memory is automatically
+ * dynamically allocated inside the xTimerCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a software timer is created using
+ * xTimerCreateStatic() then the application writer must provide the memory that
+ * will get used by the software timer.  xTimerCreateStatic() therefore allows a
+ * software timer to be created without using any dynamic memory allocation.
+ *
+ * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
+ * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
+ * xTimerChangePeriodFromISR() API functions can all be used to transition a
+ * timer into the active state.
+ *
+ * @param pcTimerName A text name that is assigned to the timer.  This is done
+ * purely to assist debugging.  The kernel itself only ever references a timer
+ * by its handle, and never by its name.
+ *
+ * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
+ * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
+ * has been specified in milliseconds.  For example, if the timer must expire
+ * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
+ * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
+ * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
+ * equal to 1000.
+ *
+ * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
+ * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
+ * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
+ * enter the dormant state after it expires.
+ *
+ * @param pvTimerID An identifier that is assigned to the timer being created.
+ * Typically this would be used in the timer callback function to identify which
+ * timer expired when the same callback function is assigned to more than one
+ * timer.
+ *
+ * @param pxCallbackFunction The function to call when the timer expires.
+ * Callback functions must have the prototype defined by TimerCallbackFunction_t,
+ * which is "void vCallbackFunction( TimerHandle_t xTimer );".
+ *
+ * @param pxTimerBuffer Must point to a variable of type StaticTimer_t, which
+ * will be then be used to hold the software timer's data structures, removing
+ * the need for the memory to be allocated dynamically.
+ *
+ * @return If the timer is created then a handle to the created timer is
+ * returned.  If pxTimerBuffer was NULL then NULL is returned.
+ *
+ * Example usage:
+ * @verbatim
+ *
+ * // The buffer used to hold the software timer's data structure.
+ * static StaticTimer_t xTimerBuffer;
+ *
+ * // A variable that will be incremented by the software timer's callback
+ * // function.
+ * UBaseType_t uxVariableToIncrement = 0;
+ *
+ * // A software timer callback function that increments a variable passed to
+ * // it when the software timer was created.  After the 5th increment the
+ * // callback function stops the software timer.
+ * static void prvTimerCallback( TimerHandle_t xExpiredTimer )
+ * {
+ * UBaseType_t *puxVariableToIncrement;
+ * BaseType_t xReturned;
+ *
+ *     // Obtain the address of the variable to increment from the timer ID.
+ *     puxVariableToIncrement = ( UBaseType_t * ) pvTimerGetTimerID( xExpiredTimer );
+ *
+ *     // Increment the variable to show the timer callback has executed.
+ *     ( *puxVariableToIncrement )++;
+ *
+ *     // If this callback has executed the required number of times, stop the
+ *     // timer.
+ *     if( *puxVariableToIncrement == 5 )
+ *     {
+ *         // This is called from a timer callback so must not block.
+ *         xTimerStop( xExpiredTimer, staticDONT_BLOCK );
+ *     }
+ * }
+ *
+ *
+ * void main( void )
+ * {
+ *     // Create the software time.  xTimerCreateStatic() has an extra parameter
+ *     // than the normal xTimerCreate() API function.  The parameter is a pointer
+ *     // to the StaticTimer_t structure that will hold the software timer
+ *     // structure.  If the parameter is passed as NULL then the structure will be
+ *     // allocated dynamically, just as if xTimerCreate() had been called.
+ *     xTimer = xTimerCreateStatic( "T1",             // Text name for the task.  Helps debugging only.  Not used by FreeRTOS.
+ *                                  xTimerPeriod,     // The period of the timer in ticks.
+ *                                  pdTRUE,           // This is an auto-reload timer.
+ *                                  ( void * ) &uxVariableToIncrement,    // A variable incremented by the software timer's callback function
+ *                                  prvTimerCallback, // The function to execute when the timer expires.
+ *                                  &xTimerBuffer );  // The buffer that will hold the software timer structure.
+ *
+ *     // The scheduler has not started yet so a block time is not used.
+ *     xReturned = xTimerStart( xTimer, 0 );
+ *
+ *     // ...
+ *     // Create tasks here.
+ *     // ...
+ *
+ *     // Starting the scheduler will start the timers running as they have already
+ *     // been set into the active state.
+ *     vTaskStartScheduler();
+ *
+ *     // Should not reach here.
+ *     for( ;; );
+ * }
+ * @endverbatim
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+										const TickType_t xTimerPeriodInTicks,
+										const UBaseType_t uxAutoReload,
+										void * const pvTimerID,
+										TimerCallbackFunction_t pxCallbackFunction,
+										StaticTimer_t *pxTimerBuffer ) PRIVILEGED_FUNCTION;
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * void *pvTimerGetTimerID( TimerHandle_t xTimer );
+ *
+ * Returns the ID assigned to the timer.
+ *
+ * IDs are assigned to timers using the pvTimerID parameter of the call to
+ * xTimerCreated() that was used to create the timer, and by calling the
+ * vTimerSetTimerID() API function.
+ *
+ * If the same callback function is assigned to multiple timers then the timer
+ * ID can be used as time specific (timer local) storage.
+ *
+ * @param xTimer The timer being queried.
+ *
+ * @return The ID assigned to the timer being queried.
+ *
+ * Example usage:
+ *
+ * See the xTimerCreate() API function example usage scenario.
+ */
+void *pvTimerGetTimerID( const TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
+
+/**
+ * void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );
+ *
+ * Sets the ID assigned to the timer.
+ *
+ * IDs are assigned to timers using the pvTimerID parameter of the call to
+ * xTimerCreated() that was used to create the timer.
+ *
+ * If the same callback function is assigned to multiple timers then the timer
+ * ID can be used as time specific (timer local) storage.
+ *
+ * @param xTimer The timer being updated.
+ *
+ * @param pvNewID The ID to assign to the timer.
+ *
+ * Example usage:
+ *
+ * See the xTimerCreate() API function example usage scenario.
+ */
+void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) PRIVILEGED_FUNCTION;
+
+/**
+ * BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );
+ *
+ * Queries a timer to see if it is active or dormant.
+ *
+ * A timer will be dormant if:
+ *     1) It has been created but not started, or
+ *     2) It is an expired one-shot timer that has not been restarted.
+ *
+ * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
+ * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
+ * xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the
+ * active state.
+ *
+ * @param xTimer The timer being queried.
+ *
+ * @return pdFALSE will be returned if the timer is dormant.  A value other than
+ * pdFALSE will be returned if the timer is active.
+ *
+ * Example usage:
+ * @verbatim
+ * // This function assumes xTimer has already been created.
+ * void vAFunction( TimerHandle_t xTimer )
+ * {
+ *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
+ *     {
+ *         // xTimer is active, do something.
+ *     }
+ *     else
+ *     {
+ *         // xTimer is not active, do something else.
+ *     }
+ * }
+ * @endverbatim
+ */
+BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
+
+/**
+ * TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );
+ *
+ * Simply returns the handle of the timer service/daemon task.  It it not valid
+ * to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started.
+ */
+TaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
+ *
+ * Timer functionality is provided by a timer service/daemon task.  Many of the
+ * public FreeRTOS timer API functions send commands to the timer service task
+ * through a queue called the timer command queue.  The timer command queue is
+ * private to the kernel itself and is not directly accessible to application
+ * code.  The length of the timer command queue is set by the
+ * configTIMER_QUEUE_LENGTH configuration constant.
+ *
+ * xTimerStart() starts a timer that was previously created using the
+ * xTimerCreate() API function.  If the timer had already been started and was
+ * already in the active state, then xTimerStart() has equivalent functionality
+ * to the xTimerReset() API function.
+ *
+ * Starting a timer ensures the timer is in the active state.  If the timer
+ * is not stopped, deleted, or reset in the mean time, the callback function
+ * associated with the timer will get called 'n' ticks after xTimerStart() was
+ * called, where 'n' is the timers defined period.
+ *
+ * It is valid to call xTimerStart() before the scheduler has been started, but
+ * when this is done the timer will not actually start until the scheduler is
+ * started, and the timers expiry time will be relative to when the scheduler is
+ * started, not relative to when xTimerStart() was called.
+ *
+ * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart()
+ * to be available.
+ *
+ * @param xTimer The handle of the timer being started/restarted.
+ *
+ * @param xTicksToWait Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the start command to be successfully
+ * sent to the timer command queue, should the queue already be full when
+ * xTimerStart() was called.  xTicksToWait is ignored if xTimerStart() is called
+ * before the scheduler is started.
+ *
+ * @return pdFAIL will be returned if the start command could not be sent to
+ * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
+ * be returned if the command was successfully sent to the timer command queue.
+ * When the command is actually processed will depend on the priority of the
+ * timer service/daemon task relative to other tasks in the system, although the
+ * timers expiry time is relative to when xTimerStart() is actually called.  The
+ * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
+ * configuration constant.
+ *
+ * Example usage:
+ *
+ * See the xTimerCreate() API function example usage scenario.
+ *
+ */
+#define xTimerStart( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
+
+/**
+ * BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );
+ *
+ * Timer functionality is provided by a timer service/daemon task.  Many of the
+ * public FreeRTOS timer API functions send commands to the timer service task
+ * through a queue called the timer command queue.  The timer command queue is
+ * private to the kernel itself and is not directly accessible to application
+ * code.  The length of the timer command queue is set by the
+ * configTIMER_QUEUE_LENGTH configuration constant.
+ *
+ * xTimerStop() stops a timer that was previously started using either of the
+ * The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(),
+ * xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.
+ *
+ * Stopping a timer ensures the timer is not in the active state.
+ *
+ * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop()
+ * to be available.
+ *
+ * @param xTimer The handle of the timer being stopped.
+ *
+ * @param xTicksToWait Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the stop command to be successfully
+ * sent to the timer command queue, should the queue already be full when
+ * xTimerStop() was called.  xTicksToWait is ignored if xTimerStop() is called
+ * before the scheduler is started.
+ *
+ * @return pdFAIL will be returned if the stop command could not be sent to
+ * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
+ * be returned if the command was successfully sent to the timer command queue.
+ * When the command is actually processed will depend on the priority of the
+ * timer service/daemon task relative to other tasks in the system.  The timer
+ * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
+ * configuration constant.
+ *
+ * Example usage:
+ *
+ * See the xTimerCreate() API function example usage scenario.
+ *
+ */
+#define xTimerStop( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )
+
+/**
+ * BaseType_t xTimerChangePeriod( 	TimerHandle_t xTimer,
+ *										TickType_t xNewPeriod,
+ *										TickType_t xTicksToWait );
+ *
+ * Timer functionality is provided by a timer service/daemon task.  Many of the
+ * public FreeRTOS timer API functions send commands to the timer service task
+ * through a queue called the timer command queue.  The timer command queue is
+ * private to the kernel itself and is not directly accessible to application
+ * code.  The length of the timer command queue is set by the
+ * configTIMER_QUEUE_LENGTH configuration constant.
+ *
+ * xTimerChangePeriod() changes the period of a timer that was previously
+ * created using the xTimerCreate() API function.
+ *
+ * xTimerChangePeriod() can be called to change the period of an active or
+ * dormant state timer.
+ *
+ * The configUSE_TIMERS configuration constant must be set to 1 for
+ * xTimerChangePeriod() to be available.
+ *
+ * @param xTimer The handle of the timer that is having its period changed.
+ *
+ * @param xNewPeriod The new period for xTimer. Timer periods are specified in
+ * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
+ * that has been specified in milliseconds.  For example, if the timer must
+ * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
+ * if the timer must expire after 500ms, then xNewPeriod can be set to
+ * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
+ * or equal to 1000.
+ *
+ * @param xTicksToWait Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the change period command to be
+ * successfully sent to the timer command queue, should the queue already be
+ * full when xTimerChangePeriod() was called.  xTicksToWait is ignored if
+ * xTimerChangePeriod() is called before the scheduler is started.
+ *
+ * @return pdFAIL will be returned if the change period command could not be
+ * sent to the timer command queue even after xTicksToWait ticks had passed.
+ * pdPASS will be returned if the command was successfully sent to the timer
+ * command queue.  When the command is actually processed will depend on the
+ * priority of the timer service/daemon task relative to other tasks in the
+ * system.  The timer service/daemon task priority is set by the
+ * configTIMER_TASK_PRIORITY configuration constant.
+ *
+ * Example usage:
+ * @verbatim
+ * // This function assumes xTimer has already been created.  If the timer
+ * // referenced by xTimer is already active when it is called, then the timer
+ * // is deleted.  If the timer referenced by xTimer is not active when it is
+ * // called, then the period of the timer is set to 500ms and the timer is
+ * // started.
+ * void vAFunction( TimerHandle_t xTimer )
+ * {
+ *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
+ *     {
+ *         // xTimer is already active - delete it.
+ *         xTimerDelete( xTimer );
+ *     }
+ *     else
+ *     {
+ *         // xTimer is not active, change its period to 500ms.  This will also
+ *         // cause the timer to start.  Block for a maximum of 100 ticks if the
+ *         // change period command cannot immediately be sent to the timer
+ *         // command queue.
+ *         if( xTimerChangePeriod( xTimer, 500 / portTICK_PERIOD_MS, 100 ) == pdPASS )
+ *         {
+ *             // The command was successfully sent.
+ *         }
+ *         else
+ *         {
+ *             // The command could not be sent, even after waiting for 100 ticks
+ *             // to pass.  Take appropriate action here.
+ *         }
+ *     }
+ * }
+ * @endverbatim
+ */
+ #define xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )
+
+/**
+ * BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
+ *
+ * Timer functionality is provided by a timer service/daemon task.  Many of the
+ * public FreeRTOS timer API functions send commands to the timer service task
+ * through a queue called the timer command queue.  The timer command queue is
+ * private to the kernel itself and is not directly accessible to application
+ * code.  The length of the timer command queue is set by the
+ * configTIMER_QUEUE_LENGTH configuration constant.
+ *
+ * xTimerDelete() deletes a timer that was previously created using the
+ * xTimerCreate() API function.
+ *
+ * The configUSE_TIMERS configuration constant must be set to 1 for
+ * xTimerDelete() to be available.
+ *
+ * @param xTimer The handle of the timer being deleted.
+ *
+ * @param xTicksToWait Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the delete command to be
+ * successfully sent to the timer command queue, should the queue already be
+ * full when xTimerDelete() was called.  xTicksToWait is ignored if xTimerDelete()
+ * is called before the scheduler is started.
+ *
+ * @return pdFAIL will be returned if the delete command could not be sent to
+ * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
+ * be returned if the command was successfully sent to the timer command queue.
+ * When the command is actually processed will depend on the priority of the
+ * timer service/daemon task relative to other tasks in the system.  The timer
+ * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
+ * configuration constant.
+ *
+ * Example usage:
+ *
+ * See the xTimerChangePeriod() API function example usage scenario.
+ */
+#define xTimerDelete( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )
+
+/**
+ * BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
+ *
+ * Timer functionality is provided by a timer service/daemon task.  Many of the
+ * public FreeRTOS timer API functions send commands to the timer service task
+ * through a queue called the timer command queue.  The timer command queue is
+ * private to the kernel itself and is not directly accessible to application
+ * code.  The length of the timer command queue is set by the
+ * configTIMER_QUEUE_LENGTH configuration constant.
+ *
+ * xTimerReset() re-starts a timer that was previously created using the
+ * xTimerCreate() API function.  If the timer had already been started and was
+ * already in the active state, then xTimerReset() will cause the timer to
+ * re-evaluate its expiry time so that it is relative to when xTimerReset() was
+ * called.  If the timer was in the dormant state then xTimerReset() has
+ * equivalent functionality to the xTimerStart() API function.
+ *
+ * Resetting a timer ensures the timer is in the active state.  If the timer
+ * is not stopped, deleted, or reset in the mean time, the callback function
+ * associated with the timer will get called 'n' ticks after xTimerReset() was
+ * called, where 'n' is the timers defined period.
+ *
+ * It is valid to call xTimerReset() before the scheduler has been started, but
+ * when this is done the timer will not actually start until the scheduler is
+ * started, and the timers expiry time will be relative to when the scheduler is
+ * started, not relative to when xTimerReset() was called.
+ *
+ * The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset()
+ * to be available.
+ *
+ * @param xTimer The handle of the timer being reset/started/restarted.
+ *
+ * @param xTicksToWait Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the reset command to be successfully
+ * sent to the timer command queue, should the queue already be full when
+ * xTimerReset() was called.  xTicksToWait is ignored if xTimerReset() is called
+ * before the scheduler is started.
+ *
+ * @return pdFAIL will be returned if the reset command could not be sent to
+ * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
+ * be returned if the command was successfully sent to the timer command queue.
+ * When the command is actually processed will depend on the priority of the
+ * timer service/daemon task relative to other tasks in the system, although the
+ * timers expiry time is relative to when xTimerStart() is actually called.  The
+ * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
+ * configuration constant.
+ *
+ * Example usage:
+ * @verbatim
+ * // When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass
+ * // without a key being pressed, then the LCD back-light is switched off.  In
+ * // this case, the timer is a one-shot timer.
+ *
+ * TimerHandle_t xBacklightTimer = NULL;
+ *
+ * // The callback function assigned to the one-shot timer.  In this case the
+ * // parameter is not used.
+ * void vBacklightTimerCallback( TimerHandle_t pxTimer )
+ * {
+ *     // The timer expired, therefore 5 seconds must have passed since a key
+ *     // was pressed.  Switch off the LCD back-light.
+ *     vSetBacklightState( BACKLIGHT_OFF );
+ * }
+ *
+ * // The key press event handler.
+ * void vKeyPressEventHandler( char cKey )
+ * {
+ *     // Ensure the LCD back-light is on, then reset the timer that is
+ *     // responsible for turning the back-light off after 5 seconds of
+ *     // key inactivity.  Wait 10 ticks for the command to be successfully sent
+ *     // if it cannot be sent immediately.
+ *     vSetBacklightState( BACKLIGHT_ON );
+ *     if( xTimerReset( xBacklightTimer, 100 ) != pdPASS )
+ *     {
+ *         // The reset command was not executed successfully.  Take appropriate
+ *         // action here.
+ *     }
+ *
+ *     // Perform the rest of the key processing here.
+ * }
+ *
+ * void main( void )
+ * {
+ * int32_t x;
+ *
+ *     // Create then start the one-shot timer that is responsible for turning
+ *     // the back-light off if no keys are pressed within a 5 second period.
+ *     xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.
+ *                                     ( 5000 / portTICK_PERIOD_MS), // The timer period in ticks.
+ *                                     pdFALSE,                    // The timer is a one-shot timer.
+ *                                     0,                          // The id is not used by the callback so can take any value.
+ *                                     vBacklightTimerCallback     // The callback function that switches the LCD back-light off.
+ *                                   );
+ *
+ *     if( xBacklightTimer == NULL )
+ *     {
+ *         // The timer was not created.
+ *     }
+ *     else
+ *     {
+ *         // Start the timer.  No block time is specified, and even if one was
+ *         // it would be ignored because the scheduler has not yet been
+ *         // started.
+ *         if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )
+ *         {
+ *             // The timer could not be set into the Active state.
+ *         }
+ *     }
+ *
+ *     // ...
+ *     // Create tasks here.
+ *     // ...
+ *
+ *     // Starting the scheduler will start the timer running as it has already
+ *     // been set into the active state.
+ *     vTaskStartScheduler();
+ *
+ *     // Should not reach here.
+ *     for( ;; );
+ * }
+ * @endverbatim
+ */
+#define xTimerReset( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
+
+/**
+ * BaseType_t xTimerStartFromISR( 	TimerHandle_t xTimer,
+ *									BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ * A version of xTimerStart() that can be called from an interrupt service
+ * routine.
+ *
+ * @param xTimer The handle of the timer being started/restarted.
+ *
+ * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
+ * of its time in the Blocked state, waiting for messages to arrive on the timer
+ * command queue.  Calling xTimerStartFromISR() writes a message to the timer
+ * command queue, so has the potential to transition the timer service/daemon
+ * task out of the Blocked state.  If calling xTimerStartFromISR() causes the
+ * timer service/daemon task to leave the Blocked state, and the timer service/
+ * daemon task has a priority equal to or greater than the currently executing
+ * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
+ * get set to pdTRUE internally within the xTimerStartFromISR() function.  If
+ * xTimerStartFromISR() sets this value to pdTRUE then a context switch should
+ * be performed before the interrupt exits.
+ *
+ * @return pdFAIL will be returned if the start command could not be sent to
+ * the timer command queue.  pdPASS will be returned if the command was
+ * successfully sent to the timer command queue.  When the command is actually
+ * processed will depend on the priority of the timer service/daemon task
+ * relative to other tasks in the system, although the timers expiry time is
+ * relative to when xTimerStartFromISR() is actually called.  The timer
+ * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
+ * configuration constant.
+ *
+ * Example usage:
+ * @verbatim
+ * // This scenario assumes xBacklightTimer has already been created.  When a
+ * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
+ * // without a key being pressed, then the LCD back-light is switched off.  In
+ * // this case, the timer is a one-shot timer, and unlike the example given for
+ * // the xTimerReset() function, the key press event handler is an interrupt
+ * // service routine.
+ *
+ * // The callback function assigned to the one-shot timer.  In this case the
+ * // parameter is not used.
+ * void vBacklightTimerCallback( TimerHandle_t pxTimer )
+ * {
+ *     // The timer expired, therefore 5 seconds must have passed since a key
+ *     // was pressed.  Switch off the LCD back-light.
+ *     vSetBacklightState( BACKLIGHT_OFF );
+ * }
+ *
+ * // The key press interrupt service routine.
+ * void vKeyPressEventInterruptHandler( void )
+ * {
+ * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+ *
+ *     // Ensure the LCD back-light is on, then restart the timer that is
+ *     // responsible for turning the back-light off after 5 seconds of
+ *     // key inactivity.  This is an interrupt service routine so can only
+ *     // call FreeRTOS API functions that end in "FromISR".
+ *     vSetBacklightState( BACKLIGHT_ON );
+ *
+ *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
+ *     // as both cause the timer to re-calculate its expiry time.
+ *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
+ *     // declared (in this function).
+ *     if( xTimerStartFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
+ *     {
+ *         // The start command was not executed successfully.  Take appropriate
+ *         // action here.
+ *     }
+ *
+ *     // Perform the rest of the key processing here.
+ *
+ *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
+ *     // should be performed.  The syntax required to perform a context switch
+ *     // from inside an ISR varies from port to port, and from compiler to
+ *     // compiler.  Inspect the demos for the port you are using to find the
+ *     // actual syntax required.
+ *     if( xHigherPriorityTaskWoken != pdFALSE )
+ *     {
+ *         // Call the interrupt safe yield function here (actual function
+ *         // depends on the FreeRTOS port being used).
+ *     }
+ * }
+ * @endverbatim
+ */
+#define xTimerStartFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
+
+/**
+ * BaseType_t xTimerStopFromISR( 	TimerHandle_t xTimer,
+ *									BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ * A version of xTimerStop() that can be called from an interrupt service
+ * routine.
+ *
+ * @param xTimer The handle of the timer being stopped.
+ *
+ * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
+ * of its time in the Blocked state, waiting for messages to arrive on the timer
+ * command queue.  Calling xTimerStopFromISR() writes a message to the timer
+ * command queue, so has the potential to transition the timer service/daemon
+ * task out of the Blocked state.  If calling xTimerStopFromISR() causes the
+ * timer service/daemon task to leave the Blocked state, and the timer service/
+ * daemon task has a priority equal to or greater than the currently executing
+ * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
+ * get set to pdTRUE internally within the xTimerStopFromISR() function.  If
+ * xTimerStopFromISR() sets this value to pdTRUE then a context switch should
+ * be performed before the interrupt exits.
+ *
+ * @return pdFAIL will be returned if the stop command could not be sent to
+ * the timer command queue.  pdPASS will be returned if the command was
+ * successfully sent to the timer command queue.  When the command is actually
+ * processed will depend on the priority of the timer service/daemon task
+ * relative to other tasks in the system.  The timer service/daemon task
+ * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
+ *
+ * Example usage:
+ * @verbatim
+ * // This scenario assumes xTimer has already been created and started.  When
+ * // an interrupt occurs, the timer should be simply stopped.
+ *
+ * // The interrupt service routine that stops the timer.
+ * void vAnExampleInterruptServiceRoutine( void )
+ * {
+ * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+ *
+ *     // The interrupt has occurred - simply stop the timer.
+ *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
+ *     // (within this function).  As this is an interrupt service routine, only
+ *     // FreeRTOS API functions that end in "FromISR" can be used.
+ *     if( xTimerStopFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
+ *     {
+ *         // The stop command was not executed successfully.  Take appropriate
+ *         // action here.
+ *     }
+ *
+ *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
+ *     // should be performed.  The syntax required to perform a context switch
+ *     // from inside an ISR varies from port to port, and from compiler to
+ *     // compiler.  Inspect the demos for the port you are using to find the
+ *     // actual syntax required.
+ *     if( xHigherPriorityTaskWoken != pdFALSE )
+ *     {
+ *         // Call the interrupt safe yield function here (actual function
+ *         // depends on the FreeRTOS port being used).
+ *     }
+ * }
+ * @endverbatim
+ */
+#define xTimerStopFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )
+
+/**
+ * BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer,
+ *										 TickType_t xNewPeriod,
+ *										 BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ * A version of xTimerChangePeriod() that can be called from an interrupt
+ * service routine.
+ *
+ * @param xTimer The handle of the timer that is having its period changed.
+ *
+ * @param xNewPeriod The new period for xTimer. Timer periods are specified in
+ * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
+ * that has been specified in milliseconds.  For example, if the timer must
+ * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
+ * if the timer must expire after 500ms, then xNewPeriod can be set to
+ * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
+ * or equal to 1000.
+ *
+ * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
+ * of its time in the Blocked state, waiting for messages to arrive on the timer
+ * command queue.  Calling xTimerChangePeriodFromISR() writes a message to the
+ * timer command queue, so has the potential to transition the timer service/
+ * daemon task out of the Blocked state.  If calling xTimerChangePeriodFromISR()
+ * causes the timer service/daemon task to leave the Blocked state, and the
+ * timer service/daemon task has a priority equal to or greater than the
+ * currently executing task (the task that was interrupted), then
+ * *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the
+ * xTimerChangePeriodFromISR() function.  If xTimerChangePeriodFromISR() sets
+ * this value to pdTRUE then a context switch should be performed before the
+ * interrupt exits.
+ *
+ * @return pdFAIL will be returned if the command to change the timers period
+ * could not be sent to the timer command queue.  pdPASS will be returned if the
+ * command was successfully sent to the timer command queue.  When the command
+ * is actually processed will depend on the priority of the timer service/daemon
+ * task relative to other tasks in the system.  The timer service/daemon task
+ * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
+ *
+ * Example usage:
+ * @verbatim
+ * // This scenario assumes xTimer has already been created and started.  When
+ * // an interrupt occurs, the period of xTimer should be changed to 500ms.
+ *
+ * // The interrupt service routine that changes the period of xTimer.
+ * void vAnExampleInterruptServiceRoutine( void )
+ * {
+ * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+ *
+ *     // The interrupt has occurred - change the period of xTimer to 500ms.
+ *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
+ *     // (within this function).  As this is an interrupt service routine, only
+ *     // FreeRTOS API functions that end in "FromISR" can be used.
+ *     if( xTimerChangePeriodFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
+ *     {
+ *         // The command to change the timers period was not executed
+ *         // successfully.  Take appropriate action here.
+ *     }
+ *
+ *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
+ *     // should be performed.  The syntax required to perform a context switch
+ *     // from inside an ISR varies from port to port, and from compiler to
+ *     // compiler.  Inspect the demos for the port you are using to find the
+ *     // actual syntax required.
+ *     if( xHigherPriorityTaskWoken != pdFALSE )
+ *     {
+ *         // Call the interrupt safe yield function here (actual function
+ *         // depends on the FreeRTOS port being used).
+ *     }
+ * }
+ * @endverbatim
+ */
+#define xTimerChangePeriodFromISR( xTimer, xNewPeriod, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )
+
+/**
+ * BaseType_t xTimerResetFromISR( 	TimerHandle_t xTimer,
+ *									BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ * A version of xTimerReset() that can be called from an interrupt service
+ * routine.
+ *
+ * @param xTimer The handle of the timer that is to be started, reset, or
+ * restarted.
+ *
+ * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
+ * of its time in the Blocked state, waiting for messages to arrive on the timer
+ * command queue.  Calling xTimerResetFromISR() writes a message to the timer
+ * command queue, so has the potential to transition the timer service/daemon
+ * task out of the Blocked state.  If calling xTimerResetFromISR() causes the
+ * timer service/daemon task to leave the Blocked state, and the timer service/
+ * daemon task has a priority equal to or greater than the currently executing
+ * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
+ * get set to pdTRUE internally within the xTimerResetFromISR() function.  If
+ * xTimerResetFromISR() sets this value to pdTRUE then a context switch should
+ * be performed before the interrupt exits.
+ *
+ * @return pdFAIL will be returned if the reset command could not be sent to
+ * the timer command queue.  pdPASS will be returned if the command was
+ * successfully sent to the timer command queue.  When the command is actually
+ * processed will depend on the priority of the timer service/daemon task
+ * relative to other tasks in the system, although the timers expiry time is
+ * relative to when xTimerResetFromISR() is actually called.  The timer service/daemon
+ * task priority is set by the configTIMER_TASK_PRIORITY configuration constant.
+ *
+ * Example usage:
+ * @verbatim
+ * // This scenario assumes xBacklightTimer has already been created.  When a
+ * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
+ * // without a key being pressed, then the LCD back-light is switched off.  In
+ * // this case, the timer is a one-shot timer, and unlike the example given for
+ * // the xTimerReset() function, the key press event handler is an interrupt
+ * // service routine.
+ *
+ * // The callback function assigned to the one-shot timer.  In this case the
+ * // parameter is not used.
+ * void vBacklightTimerCallback( TimerHandle_t pxTimer )
+ * {
+ *     // The timer expired, therefore 5 seconds must have passed since a key
+ *     // was pressed.  Switch off the LCD back-light.
+ *     vSetBacklightState( BACKLIGHT_OFF );
+ * }
+ *
+ * // The key press interrupt service routine.
+ * void vKeyPressEventInterruptHandler( void )
+ * {
+ * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+ *
+ *     // Ensure the LCD back-light is on, then reset the timer that is
+ *     // responsible for turning the back-light off after 5 seconds of
+ *     // key inactivity.  This is an interrupt service routine so can only
+ *     // call FreeRTOS API functions that end in "FromISR".
+ *     vSetBacklightState( BACKLIGHT_ON );
+ *
+ *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
+ *     // as both cause the timer to re-calculate its expiry time.
+ *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
+ *     // declared (in this function).
+ *     if( xTimerResetFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
+ *     {
+ *         // The reset command was not executed successfully.  Take appropriate
+ *         // action here.
+ *     }
+ *
+ *     // Perform the rest of the key processing here.
+ *
+ *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
+ *     // should be performed.  The syntax required to perform a context switch
+ *     // from inside an ISR varies from port to port, and from compiler to
+ *     // compiler.  Inspect the demos for the port you are using to find the
+ *     // actual syntax required.
+ *     if( xHigherPriorityTaskWoken != pdFALSE )
+ *     {
+ *         // Call the interrupt safe yield function here (actual function
+ *         // depends on the FreeRTOS port being used).
+ *     }
+ * }
+ * @endverbatim
+ */
+#define xTimerResetFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
+
+
+/**
+ * BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
+ *                                          void *pvParameter1,
+ *                                          uint32_t ulParameter2,
+ *                                          BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ *
+ * Used from application interrupt service routines to defer the execution of a
+ * function to the RTOS daemon task (the timer service task, hence this function
+ * is implemented in timers.c and is prefixed with 'Timer').
+ *
+ * Ideally an interrupt service routine (ISR) is kept as short as possible, but
+ * sometimes an ISR either has a lot of processing to do, or needs to perform
+ * processing that is not deterministic.  In these cases
+ * xTimerPendFunctionCallFromISR() can be used to defer processing of a function
+ * to the RTOS daemon task.
+ *
+ * A mechanism is provided that allows the interrupt to return directly to the
+ * task that will subsequently execute the pended callback function.  This
+ * allows the callback function to execute contiguously in time with the
+ * interrupt - just as if the callback had executed in the interrupt itself.
+ *
+ * @param xFunctionToPend The function to execute from the timer service/
+ * daemon task.  The function must conform to the PendedFunction_t
+ * prototype.
+ *
+ * @param pvParameter1 The value of the callback function's first parameter.
+ * The parameter has a void * type to allow it to be used to pass any type.
+ * For example, unsigned longs can be cast to a void *, or the void * can be
+ * used to point to a structure.
+ *
+ * @param ulParameter2 The value of the callback function's second parameter.
+ *
+ * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
+ * will result in a message being sent to the timer daemon task.  If the
+ * priority of the timer daemon task (which is set using
+ * configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of
+ * the currently running task (the task the interrupt interrupted) then
+ * *pxHigherPriorityTaskWoken will be set to pdTRUE within
+ * xTimerPendFunctionCallFromISR(), indicating that a context switch should be
+ * requested before the interrupt exits.  For that reason
+ * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
+ * example code below.
+ *
+ * @return pdPASS is returned if the message was successfully sent to the
+ * timer daemon task, otherwise pdFALSE is returned.
+ *
+ * Example usage:
+ * @verbatim
+ *
+ *	// The callback function that will execute in the context of the daemon task.
+ *  // Note callback functions must all use this same prototype.
+ *  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
+ *	{
+ *		BaseType_t xInterfaceToService;
+ *
+ *		// The interface that requires servicing is passed in the second
+ *      // parameter.  The first parameter is not used in this case.
+ *		xInterfaceToService = ( BaseType_t ) ulParameter2;
+ *
+ *		// ...Perform the processing here...
+ *	}
+ *
+ *	// An ISR that receives data packets from multiple interfaces
+ *  void vAnISR( void )
+ *	{
+ *		BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
+ *
+ *		// Query the hardware to determine which interface needs processing.
+ *		xInterfaceToService = prvCheckInterfaces();
+ *
+ *      // The actual processing is to be deferred to a task.  Request the
+ *      // vProcessInterface() callback function is executed, passing in the
+ *		// number of the interface that needs processing.  The interface to
+ *		// service is passed in the second parameter.  The first parameter is
+ *		// not used in this case.
+ *		xHigherPriorityTaskWoken = pdFALSE;
+ *		xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );
+ *
+ *		// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
+ *		// switch should be requested.  The macro used is port specific and will
+ *		// be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
+ *		// the documentation page for the port being used.
+ *		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+ *
+ *	}
+ * @endverbatim
+ */
+BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+ /**
+  * BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
+  *                                    void *pvParameter1,
+  *                                    uint32_t ulParameter2,
+  *                                    TickType_t xTicksToWait );
+  *
+  *
+  * Used to defer the execution of a function to the RTOS daemon task (the timer
+  * service task, hence this function is implemented in timers.c and is prefixed
+  * with 'Timer').
+  *
+  * @param xFunctionToPend The function to execute from the timer service/
+  * daemon task.  The function must conform to the PendedFunction_t
+  * prototype.
+  *
+  * @param pvParameter1 The value of the callback function's first parameter.
+  * The parameter has a void * type to allow it to be used to pass any type.
+  * For example, unsigned longs can be cast to a void *, or the void * can be
+  * used to point to a structure.
+  *
+  * @param ulParameter2 The value of the callback function's second parameter.
+  *
+  * @param xTicksToWait Calling this function will result in a message being
+  * sent to the timer daemon task on a queue.  xTicksToWait is the amount of
+  * time the calling task should remain in the Blocked state (so not using any
+  * processing time) for space to become available on the timer queue if the
+  * queue is found to be full.
+  *
+  * @return pdPASS is returned if the message was successfully sent to the
+  * timer daemon task, otherwise pdFALSE is returned.
+  *
+  */
+BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * const char * const pcTimerGetName( TimerHandle_t xTimer );
+ *
+ * Returns the name that was assigned to a timer when the timer was created.
+ *
+ * @param xTimer The handle of the timer being queried.
+ *
+ * @return The name assigned to the timer specified by the xTimer parameter.
+ */
+const char * pcTimerGetName( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * TickType_t xTimerGetPeriod( TimerHandle_t xTimer );
+ *
+ * Returns the period of a timer.
+ *
+ * @param xTimer The handle of the timer being queried.
+ *
+ * @return The period of the timer in ticks.
+ */
+TickType_t xTimerGetPeriod( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
+
+/**
+* TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );
+*
+* Returns the time in ticks at which the timer will expire.  If this is less
+* than the current tick count then the expiry time has overflowed from the
+* current time.
+*
+* @param xTimer The handle of the timer being queried.
+*
+* @return If the timer is running then the time in ticks at which the timer
+* will next expire is returned.  If the timer is not running then the return
+* value is undefined.
+*/
+TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
+
+/*
+ * Functions beyond this part are not part of the public API and are intended
+ * for use by the kernel only.
+ */
+BaseType_t xTimerCreateTimerTask( void ) PRIVILEGED_FUNCTION;
+BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+#if( configUSE_TRACE_FACILITY == 1 )
+	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber ) PRIVILEGED_FUNCTION;
+	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* TIMERS_H */
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/MemMang/heap_1.c ./libs/freertos/MemMang/heap_1.c
--- a_bRU7kv/libs/freertos/MemMang/heap_1.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/MemMang/heap_1.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,147 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+/*
+ * The simplest possible implementation of pvPortMalloc().  Note that this
+ * implementation does NOT allow allocated memory to be freed again.
+ *
+ * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
+ * memory management pages of http://www.FreeRTOS.org for more information.
+ */
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
+	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
+#endif
+
+/* A few bytes might be lost to byte aligning the heap start address. */
+#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
+
+/* Allocate the memory for the heap. */
+/* Allocate the memory for the heap. */
+#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
+	/* The application writer has already defined the array used for the RTOS
+	heap - probably so it can be placed in a special segment or address. */
+	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
+#else
+	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
+#endif /* configAPPLICATION_ALLOCATED_HEAP */
+
+/* Index into the ucHeap array. */
+static size_t xNextFreeByte = ( size_t ) 0;
+
+/*-----------------------------------------------------------*/
+
+void *pvPortMalloc( size_t xWantedSize )
+{
+void *pvReturn = NULL;
+static uint8_t *pucAlignedHeap = NULL;
+
+	/* Ensure that blocks are always aligned to the required number of bytes. */
+	#if( portBYTE_ALIGNMENT != 1 )
+	{
+		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
+		{
+			/* Byte alignment required. */
+			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+		}
+	}
+	#endif
+
+	vTaskSuspendAll();
+	{
+		if( pucAlignedHeap == NULL )
+		{
+			/* Ensure the heap starts on a correctly aligned boundary. */
+			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
+		}
+
+		/* Check there is enough room left for the allocation. */
+		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
+			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
+		{
+			/* Return the next free byte then increment the index past this
+			block. */
+			pvReturn = pucAlignedHeap + xNextFreeByte;
+			xNextFreeByte += xWantedSize;
+		}
+
+		traceMALLOC( pvReturn, xWantedSize );
+	}
+	( void ) xTaskResumeAll();
+
+	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
+	{
+		if( pvReturn == NULL )
+		{
+			extern void vApplicationMallocFailedHook( void );
+			vApplicationMallocFailedHook();
+		}
+	}
+	#endif
+
+	return pvReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vPortFree( void *pv )
+{
+	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
+	heap_4.c for alternative implementations, and the memory management pages of
+	http://www.FreeRTOS.org for more information. */
+	( void ) pv;
+
+	/* Force an assert as it is invalid to call this function. */
+	configASSERT( pv == NULL );
+}
+/*-----------------------------------------------------------*/
+
+void vPortInitialiseBlocks( void )
+{
+	/* Only required when static memory is not cleared. */
+	xNextFreeByte = ( size_t ) 0;
+}
+/*-----------------------------------------------------------*/
+
+size_t xPortGetFreeHeapSize( void )
+{
+	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
+}
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/MemMang/heap_2.c ./libs/freertos/MemMang/heap_2.c
--- a_bRU7kv/libs/freertos/MemMang/heap_2.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/MemMang/heap_2.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,272 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*
+ * A sample implementation of pvPortMalloc() and vPortFree() that permits
+ * allocated blocks to be freed, but does not combine adjacent free blocks
+ * into a single larger block (and so will fragment memory).  See heap_4.c for
+ * an equivalent that does combine adjacent blocks into single larger blocks.
+ *
+ * See heap_1.c, heap_3.c and heap_4.c for alternative implementations, and the
+ * memory management pages of http://www.FreeRTOS.org for more information.
+ */
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
+	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
+#endif
+
+/* A few bytes might be lost to byte aligning the heap start address. */
+#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
+
+/*
+ * Initialises the heap structures before their first use.
+ */
+static void prvHeapInit( void );
+
+/* Allocate the memory for the heap. */
+#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
+	/* The application writer has already defined the array used for the RTOS
+	heap - probably so it can be placed in a special segment or address. */
+	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
+#else
+	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
+#endif /* configAPPLICATION_ALLOCATED_HEAP */
+
+
+/* Define the linked list structure.  This is used to link free blocks in order
+of their size. */
+typedef struct A_BLOCK_LINK
+{
+	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
+	size_t xBlockSize;						/*<< The size of the free block. */
+} BlockLink_t;
+
+
+static const uint16_t heapSTRUCT_SIZE	= ( ( sizeof ( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );
+#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
+
+/* Create a couple of list links to mark the start and end of the list. */
+static BlockLink_t xStart, xEnd;
+
+/* Keeps track of the number of free bytes remaining, but says nothing about
+fragmentation. */
+static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;
+
+/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */
+
+/*
+ * Insert a block into the list of free blocks - which is ordered by size of
+ * the block.  Small blocks at the start of the list and large blocks at the end
+ * of the list.
+ */
+#define prvInsertBlockIntoFreeList( pxBlockToInsert )								\
+{																					\
+BlockLink_t *pxIterator;															\
+size_t xBlockSize;																	\
+																					\
+	xBlockSize = pxBlockToInsert->xBlockSize;										\
+																					\
+	/* Iterate through the list until a block is found that has a larger size */	\
+	/* than the block we are inserting. */											\
+	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock )	\
+	{																				\
+		/* There is nothing to do here - just iterate to the correct position. */	\
+	}																				\
+																					\
+	/* Update the list to include the block being inserted in the correct */		\
+	/* position. */																	\
+	pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;					\
+	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
+}
+/*-----------------------------------------------------------*/
+
+void *pvPortMalloc( size_t xWantedSize )
+{
+BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
+static BaseType_t xHeapHasBeenInitialised = pdFALSE;
+void *pvReturn = NULL;
+
+	vTaskSuspendAll();
+	{
+		/* If this is the first call to malloc then the heap will require
+		initialisation to setup the list of free blocks. */
+		if( xHeapHasBeenInitialised == pdFALSE )
+		{
+			prvHeapInit();
+			xHeapHasBeenInitialised = pdTRUE;
+		}
+
+		/* The wanted size is increased so it can contain a BlockLink_t
+		structure in addition to the requested amount of bytes. */
+		if( xWantedSize > 0 )
+		{
+			xWantedSize += heapSTRUCT_SIZE;
+
+			/* Ensure that blocks are always aligned to the required number of bytes. */
+			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
+			{
+				/* Byte alignment required. */
+				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+			}
+		}
+
+		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
+		{
+			/* Blocks are stored in byte order - traverse the list from the start
+			(smallest) block until one of adequate size is found. */
+			pxPreviousBlock = &xStart;
+			pxBlock = xStart.pxNextFreeBlock;
+			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
+			{
+				pxPreviousBlock = pxBlock;
+				pxBlock = pxBlock->pxNextFreeBlock;
+			}
+
+			/* If we found the end marker then a block of adequate size was not found. */
+			if( pxBlock != &xEnd )
+			{
+				/* Return the memory space - jumping over the BlockLink_t structure
+				at its start. */
+				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
+
+				/* This block is being returned for use so must be taken out of the
+				list of free blocks. */
+				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
+
+				/* If the block is larger than required it can be split into two. */
+				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
+				{
+					/* This block is to be split into two.  Create a new block
+					following the number of bytes requested. The void cast is
+					used to prevent byte alignment warnings from the compiler. */
+					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
+
+					/* Calculate the sizes of two blocks split from the single
+					block. */
+					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
+					pxBlock->xBlockSize = xWantedSize;
+
+					/* Insert the new block into the list of free blocks. */
+					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
+				}
+
+				xFreeBytesRemaining -= pxBlock->xBlockSize;
+			}
+		}
+
+		traceMALLOC( pvReturn, xWantedSize );
+	}
+	( void ) xTaskResumeAll();
+
+	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
+	{
+		if( pvReturn == NULL )
+		{
+			extern void vApplicationMallocFailedHook( void );
+			vApplicationMallocFailedHook();
+		}
+	}
+	#endif
+
+	return pvReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vPortFree( void *pv )
+{
+uint8_t *puc = ( uint8_t * ) pv;
+BlockLink_t *pxLink;
+
+	if( pv != NULL )
+	{
+		/* The memory being freed will have an BlockLink_t structure immediately
+		before it. */
+		puc -= heapSTRUCT_SIZE;
+
+		/* This unexpected casting is to keep some compilers from issuing
+		byte alignment warnings. */
+		pxLink = ( void * ) puc;
+
+		vTaskSuspendAll();
+		{
+			/* Add this block to the list of free blocks. */
+			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
+			xFreeBytesRemaining += pxLink->xBlockSize;
+			traceFREE( pv, pxLink->xBlockSize );
+		}
+		( void ) xTaskResumeAll();
+	}
+}
+/*-----------------------------------------------------------*/
+
+size_t xPortGetFreeHeapSize( void )
+{
+	return xFreeBytesRemaining;
+}
+/*-----------------------------------------------------------*/
+
+void vPortInitialiseBlocks( void )
+{
+	/* This just exists to keep the linker quiet. */
+}
+/*-----------------------------------------------------------*/
+
+static void prvHeapInit( void )
+{
+BlockLink_t *pxFirstFreeBlock;
+uint8_t *pucAlignedHeap;
+
+	/* Ensure the heap starts on a correctly aligned boundary. */
+	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
+
+	/* xStart is used to hold a pointer to the first item in the list of free
+	blocks.  The void cast is used to prevent compiler warnings. */
+	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
+	xStart.xBlockSize = ( size_t ) 0;
+
+	/* xEnd is used to mark the end of the list of free blocks. */
+	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
+	xEnd.pxNextFreeBlock = NULL;
+
+	/* To start with there is a single free block that is sized to take up the
+	entire heap space. */
+	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
+	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
+	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
+}
+/*-----------------------------------------------------------*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/MemMang/heap_3.c ./libs/freertos/MemMang/heap_3.c
--- a_bRU7kv/libs/freertos/MemMang/heap_3.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/MemMang/heap_3.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,97 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+/*
+ * Implementation of pvPortMalloc() and vPortFree() that relies on the
+ * compilers own malloc() and free() implementations.
+ *
+ * This file can only be used if the linker is configured to to generate
+ * a heap memory area.
+ *
+ * See heap_1.c, heap_2.c and heap_4.c for alternative implementations, and the
+ * memory management pages of http://www.FreeRTOS.org for more information.
+ */
+
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
+	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
+#endif
+
+/*-----------------------------------------------------------*/
+
+void *pvPortMalloc( size_t xWantedSize )
+{
+void *pvReturn;
+
+	vTaskSuspendAll();
+	{
+		pvReturn = malloc( xWantedSize );
+		traceMALLOC( pvReturn, xWantedSize );
+	}
+	( void ) xTaskResumeAll();
+
+	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
+	{
+		if( pvReturn == NULL )
+		{
+			extern void vApplicationMallocFailedHook( void );
+			vApplicationMallocFailedHook();
+		}
+	}
+	#endif
+
+	return pvReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vPortFree( void *pv )
+{
+	if( pv )
+	{
+		vTaskSuspendAll();
+		{
+			free( pv );
+			traceFREE( pv, 0 );
+		}
+		( void ) xTaskResumeAll();
+	}
+}
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/MemMang/heap_4.c ./libs/freertos/MemMang/heap_4.c
--- a_bRU7kv/libs/freertos/MemMang/heap_4.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/MemMang/heap_4.c	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,436 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*
+ * A sample implementation of pvPortMalloc() and vPortFree() that combines
+ * (coalescences) adjacent memory blocks as they are freed, and in so doing
+ * limits memory fragmentation.
+ *
+ * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
+ * memory management pages of http://www.FreeRTOS.org for more information.
+ */
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
+	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
+#endif
+
+/* Block sizes must not get too small. */
+#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
+
+/* Assumes 8bit bytes! */
+#define heapBITS_PER_BYTE		( ( size_t ) 8 )
+
+/* Allocate the memory for the heap. */
+#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
+	/* The application writer has already defined the array used for the RTOS
+	heap - probably so it can be placed in a special segment or address. */
+	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
+#else
+	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
+#endif /* configAPPLICATION_ALLOCATED_HEAP */
+
+/* Define the linked list structure.  This is used to link free blocks in order
+of their memory address. */
+typedef struct A_BLOCK_LINK
+{
+	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
+	size_t xBlockSize;						/*<< The size of the free block. */
+} BlockLink_t;
+
+/*-----------------------------------------------------------*/
+
+/*
+ * Inserts a block of memory that is being freed into the correct position in
+ * the list of free memory blocks.  The block being freed will be merged with
+ * the block in front it and/or the block behind it if the memory blocks are
+ * adjacent to each other.
+ */
+static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
+
+/*
+ * Called automatically to setup the required heap structures the first time
+ * pvPortMalloc() is called.
+ */
+static void prvHeapInit( void );
+
+/*-----------------------------------------------------------*/
+
+/* The size of the structure placed at the beginning of each allocated memory
+block must by correctly byte aligned. */
+static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
+
+/* Create a couple of list links to mark the start and end of the list. */
+static BlockLink_t xStart, *pxEnd = NULL;
+
+/* Keeps track of the number of free bytes remaining, but says nothing about
+fragmentation. */
+static size_t xFreeBytesRemaining = 0U;
+static size_t xMinimumEverFreeBytesRemaining = 0U;
+
+/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
+member of an BlockLink_t structure is set then the block belongs to the
+application.  When the bit is free the block is still part of the free heap
+space. */
+static size_t xBlockAllocatedBit = 0;
+
+/*-----------------------------------------------------------*/
+
+void *pvPortMalloc( size_t xWantedSize )
+{
+BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
+void *pvReturn = NULL;
+
+	vTaskSuspendAll();
+	{
+		/* If this is the first call to malloc then the heap will require
+		initialisation to setup the list of free blocks. */
+		if( pxEnd == NULL )
+		{
+			prvHeapInit();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		/* Check the requested block size is not so large that the top bit is
+		set.  The top bit of the block size member of the BlockLink_t structure
+		is used to determine who owns the block - the application or the
+		kernel, so it must be free. */
+		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
+		{
+			/* The wanted size is increased so it can contain a BlockLink_t
+			structure in addition to the requested amount of bytes. */
+			if( xWantedSize > 0 )
+			{
+				xWantedSize += xHeapStructSize;
+
+				/* Ensure that blocks are always aligned to the required number
+				of bytes. */
+				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
+				{
+					/* Byte alignment required. */
+					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
+			{
+				/* Traverse the list from the start	(lowest address) block until
+				one	of adequate size is found. */
+				pxPreviousBlock = &xStart;
+				pxBlock = xStart.pxNextFreeBlock;
+				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
+				{
+					pxPreviousBlock = pxBlock;
+					pxBlock = pxBlock->pxNextFreeBlock;
+				}
+
+				/* If the end marker was reached then a block of adequate size
+				was	not found. */
+				if( pxBlock != pxEnd )
+				{
+					/* Return the memory space pointed to - jumping over the
+					BlockLink_t structure at its start. */
+					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
+
+					/* This block is being returned for use so must be taken out
+					of the list of free blocks. */
+					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
+
+					/* If the block is larger than required it can be split into
+					two. */
+					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
+					{
+						/* This block is to be split into two.  Create a new
+						block following the number of bytes requested. The void
+						cast is used to prevent byte alignment warnings from the
+						compiler. */
+						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
+						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
+
+						/* Calculate the sizes of two blocks split from the
+						single block. */
+						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
+						pxBlock->xBlockSize = xWantedSize;
+
+						/* Insert the new block into the list of free blocks. */
+						prvInsertBlockIntoFreeList( pxNewBlockLink );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					xFreeBytesRemaining -= pxBlock->xBlockSize;
+
+					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
+					{
+						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* The block is being returned - it is allocated and owned
+					by the application and has no "next" block. */
+					pxBlock->xBlockSize |= xBlockAllocatedBit;
+					pxBlock->pxNextFreeBlock = NULL;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		traceMALLOC( pvReturn, xWantedSize );
+	}
+	( void ) xTaskResumeAll();
+
+	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
+	{
+		if( pvReturn == NULL )
+		{
+			extern void vApplicationMallocFailedHook( void );
+			vApplicationMallocFailedHook();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	#endif
+
+	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
+	return pvReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vPortFree( void *pv )
+{
+uint8_t *puc = ( uint8_t * ) pv;
+BlockLink_t *pxLink;
+
+	if( pv != NULL )
+	{
+		/* The memory being freed will have an BlockLink_t structure immediately
+		before it. */
+		puc -= xHeapStructSize;
+
+		/* This casting is to keep the compiler from issuing warnings. */
+		pxLink = ( void * ) puc;
+
+		/* Check the block is actually allocated. */
+		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
+		configASSERT( pxLink->pxNextFreeBlock == NULL );
+
+		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
+		{
+			if( pxLink->pxNextFreeBlock == NULL )
+			{
+				/* The block is being returned to the heap - it is no longer
+				allocated. */
+				pxLink->xBlockSize &= ~xBlockAllocatedBit;
+
+				vTaskSuspendAll();
+				{
+					/* Add this block to the list of free blocks. */
+					xFreeBytesRemaining += pxLink->xBlockSize;
+					traceFREE( pv, pxLink->xBlockSize );
+					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
+				}
+				( void ) xTaskResumeAll();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+size_t xPortGetFreeHeapSize( void )
+{
+	return xFreeBytesRemaining;
+}
+/*-----------------------------------------------------------*/
+
+size_t xPortGetMinimumEverFreeHeapSize( void )
+{
+	return xMinimumEverFreeBytesRemaining;
+}
+/*-----------------------------------------------------------*/
+
+void vPortInitialiseBlocks( void )
+{
+	/* This just exists to keep the linker quiet. */
+}
+/*-----------------------------------------------------------*/
+
+static void prvHeapInit( void )
+{
+BlockLink_t *pxFirstFreeBlock;
+uint8_t *pucAlignedHeap;
+size_t uxAddress;
+size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
+
+	/* Ensure the heap starts on a correctly aligned boundary. */
+	uxAddress = ( size_t ) ucHeap;
+
+	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
+	{
+		uxAddress += ( portBYTE_ALIGNMENT - 1 );
+		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
+		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
+	}
+
+	pucAlignedHeap = ( uint8_t * ) uxAddress;
+
+	/* xStart is used to hold a pointer to the first item in the list of free
+	blocks.  The void cast is used to prevent compiler warnings. */
+	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
+	xStart.xBlockSize = ( size_t ) 0;
+
+	/* pxEnd is used to mark the end of the list of free blocks and is inserted
+	at the end of the heap space. */
+	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
+	uxAddress -= xHeapStructSize;
+	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
+	pxEnd = ( void * ) uxAddress;
+	pxEnd->xBlockSize = 0;
+	pxEnd->pxNextFreeBlock = NULL;
+
+	/* To start with there is a single free block that is sized to take up the
+	entire heap space, minus the space taken by pxEnd. */
+	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
+	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
+	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
+
+	/* Only one block exists - and it covers the entire usable heap space. */
+	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
+	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
+
+	/* Work out the position of the top bit in a size_t variable. */
+	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
+}
+/*-----------------------------------------------------------*/
+
+static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
+{
+BlockLink_t *pxIterator;
+uint8_t *puc;
+
+	/* Iterate through the list until a block is found that has a higher address
+	than the block being inserted. */
+	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
+	{
+		/* Nothing to do here, just iterate to the right position. */
+	}
+
+	/* Do the block being inserted, and the block it is being inserted after
+	make a contiguous block of memory? */
+	puc = ( uint8_t * ) pxIterator;
+	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
+	{
+		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
+		pxBlockToInsert = pxIterator;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	/* Do the block being inserted, and the block it is being inserted before
+	make a contiguous block of memory? */
+	puc = ( uint8_t * ) pxBlockToInsert;
+	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
+	{
+		if( pxIterator->pxNextFreeBlock != pxEnd )
+		{
+			/* Form one big block from the two blocks. */
+			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
+			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
+		}
+		else
+		{
+			pxBlockToInsert->pxNextFreeBlock = pxEnd;
+		}
+	}
+	else
+	{
+		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
+	}
+
+	/* If the block being inserted plugged a gab, so was merged with the block
+	before and the block after, then it's pxNextFreeBlock pointer will have
+	already been set, and should not be set here as that would make it point
+	to itself. */
+	if( pxIterator != pxBlockToInsert )
+	{
+		pxIterator->pxNextFreeBlock = pxBlockToInsert;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/MemMang/heap_5.c ./libs/freertos/MemMang/heap_5.c
--- a_bRU7kv/libs/freertos/MemMang/heap_5.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/MemMang/heap_5.c	2018-12-01 17:15:06.597605890 -0300
@@ -0,0 +1,485 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*
+ * A sample implementation of pvPortMalloc() that allows the heap to be defined
+ * across multiple non-contigous blocks and combines (coalescences) adjacent
+ * memory blocks as they are freed.
+ *
+ * See heap_1.c, heap_2.c, heap_3.c and heap_4.c for alternative
+ * implementations, and the memory management pages of http://www.FreeRTOS.org
+ * for more information.
+ *
+ * Usage notes:
+ *
+ * vPortDefineHeapRegions() ***must*** be called before pvPortMalloc().
+ * pvPortMalloc() will be called if any task objects (tasks, queues, event
+ * groups, etc.) are created, therefore vPortDefineHeapRegions() ***must*** be
+ * called before any other objects are defined.
+ *
+ * vPortDefineHeapRegions() takes a single parameter.  The parameter is an array
+ * of HeapRegion_t structures.  HeapRegion_t is defined in portable.h as
+ *
+ * typedef struct HeapRegion
+ * {
+ *	uint8_t *pucStartAddress; << Start address of a block of memory that will be part of the heap.
+ *	size_t xSizeInBytes;	  << Size of the block of memory.
+ * } HeapRegion_t;
+ *
+ * The array is terminated using a NULL zero sized region definition, and the
+ * memory regions defined in the array ***must*** appear in address order from
+ * low address to high address.  So the following is a valid example of how
+ * to use the function.
+ *
+ * HeapRegion_t xHeapRegions[] =
+ * {
+ * 	{ ( uint8_t * ) 0x80000000UL, 0x10000 }, << Defines a block of 0x10000 bytes starting at address 0x80000000
+ * 	{ ( uint8_t * ) 0x90000000UL, 0xa0000 }, << Defines a block of 0xa0000 bytes starting at address of 0x90000000
+ * 	{ NULL, 0 }                << Terminates the array.
+ * };
+ *
+ * vPortDefineHeapRegions( xHeapRegions ); << Pass the array into vPortDefineHeapRegions().
+ *
+ * Note 0x80000000 is the lower address so appears in the array first.
+ *
+ */
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
+	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
+#endif
+
+/* Block sizes must not get too small. */
+#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
+
+/* Assumes 8bit bytes! */
+#define heapBITS_PER_BYTE		( ( size_t ) 8 )
+
+/* Define the linked list structure.  This is used to link free blocks in order
+of their memory address. */
+typedef struct A_BLOCK_LINK
+{
+	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
+	size_t xBlockSize;						/*<< The size of the free block. */
+} BlockLink_t;
+
+/*-----------------------------------------------------------*/
+
+/*
+ * Inserts a block of memory that is being freed into the correct position in
+ * the list of free memory blocks.  The block being freed will be merged with
+ * the block in front it and/or the block behind it if the memory blocks are
+ * adjacent to each other.
+ */
+static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
+
+/*-----------------------------------------------------------*/
+
+/* The size of the structure placed at the beginning of each allocated memory
+block must by correctly byte aligned. */
+static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
+
+/* Create a couple of list links to mark the start and end of the list. */
+static BlockLink_t xStart, *pxEnd = NULL;
+
+/* Keeps track of the number of free bytes remaining, but says nothing about
+fragmentation. */
+static size_t xFreeBytesRemaining = 0U;
+static size_t xMinimumEverFreeBytesRemaining = 0U;
+
+/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
+member of an BlockLink_t structure is set then the block belongs to the
+application.  When the bit is free the block is still part of the free heap
+space. */
+static size_t xBlockAllocatedBit = 0;
+
+/*-----------------------------------------------------------*/
+
+void *pvPortMalloc( size_t xWantedSize )
+{
+BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
+void *pvReturn = NULL;
+
+	/* The heap must be initialised before the first call to
+	prvPortMalloc(). */
+	configASSERT( pxEnd );
+
+	vTaskSuspendAll();
+	{
+		/* Check the requested block size is not so large that the top bit is
+		set.  The top bit of the block size member of the BlockLink_t structure
+		is used to determine who owns the block - the application or the
+		kernel, so it must be free. */
+		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
+		{
+			/* The wanted size is increased so it can contain a BlockLink_t
+			structure in addition to the requested amount of bytes. */
+			if( xWantedSize > 0 )
+			{
+				xWantedSize += xHeapStructSize;
+
+				/* Ensure that blocks are always aligned to the required number
+				of bytes. */
+				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
+				{
+					/* Byte alignment required. */
+					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
+			{
+				/* Traverse the list from the start	(lowest address) block until
+				one	of adequate size is found. */
+				pxPreviousBlock = &xStart;
+				pxBlock = xStart.pxNextFreeBlock;
+				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
+				{
+					pxPreviousBlock = pxBlock;
+					pxBlock = pxBlock->pxNextFreeBlock;
+				}
+
+				/* If the end marker was reached then a block of adequate size
+				was	not found. */
+				if( pxBlock != pxEnd )
+				{
+					/* Return the memory space pointed to - jumping over the
+					BlockLink_t structure at its start. */
+					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
+
+					/* This block is being returned for use so must be taken out
+					of the list of free blocks. */
+					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
+
+					/* If the block is larger than required it can be split into
+					two. */
+					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
+					{
+						/* This block is to be split into two.  Create a new
+						block following the number of bytes requested. The void
+						cast is used to prevent byte alignment warnings from the
+						compiler. */
+						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
+
+						/* Calculate the sizes of two blocks split from the
+						single block. */
+						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
+						pxBlock->xBlockSize = xWantedSize;
+
+						/* Insert the new block into the list of free blocks. */
+						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					xFreeBytesRemaining -= pxBlock->xBlockSize;
+
+					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
+					{
+						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* The block is being returned - it is allocated and owned
+					by the application and has no "next" block. */
+					pxBlock->xBlockSize |= xBlockAllocatedBit;
+					pxBlock->pxNextFreeBlock = NULL;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		traceMALLOC( pvReturn, xWantedSize );
+	}
+	( void ) xTaskResumeAll();
+
+	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
+	{
+		if( pvReturn == NULL )
+		{
+			extern void vApplicationMallocFailedHook( void );
+			vApplicationMallocFailedHook();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	#endif
+
+	return pvReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vPortFree( void *pv )
+{
+uint8_t *puc = ( uint8_t * ) pv;
+BlockLink_t *pxLink;
+
+	if( pv != NULL )
+	{
+		/* The memory being freed will have an BlockLink_t structure immediately
+		before it. */
+		puc -= xHeapStructSize;
+
+		/* This casting is to keep the compiler from issuing warnings. */
+		pxLink = ( void * ) puc;
+
+		/* Check the block is actually allocated. */
+		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
+		configASSERT( pxLink->pxNextFreeBlock == NULL );
+
+		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
+		{
+			if( pxLink->pxNextFreeBlock == NULL )
+			{
+				/* The block is being returned to the heap - it is no longer
+				allocated. */
+				pxLink->xBlockSize &= ~xBlockAllocatedBit;
+
+				vTaskSuspendAll();
+				{
+					/* Add this block to the list of free blocks. */
+					xFreeBytesRemaining += pxLink->xBlockSize;
+					traceFREE( pv, pxLink->xBlockSize );
+					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
+				}
+				( void ) xTaskResumeAll();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+size_t xPortGetFreeHeapSize( void )
+{
+	return xFreeBytesRemaining;
+}
+/*-----------------------------------------------------------*/
+
+size_t xPortGetMinimumEverFreeHeapSize( void )
+{
+	return xMinimumEverFreeBytesRemaining;
+}
+/*-----------------------------------------------------------*/
+
+static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
+{
+BlockLink_t *pxIterator;
+uint8_t *puc;
+
+	/* Iterate through the list until a block is found that has a higher address
+	than the block being inserted. */
+	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
+	{
+		/* Nothing to do here, just iterate to the right position. */
+	}
+
+	/* Do the block being inserted, and the block it is being inserted after
+	make a contiguous block of memory? */
+	puc = ( uint8_t * ) pxIterator;
+	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
+	{
+		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
+		pxBlockToInsert = pxIterator;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	/* Do the block being inserted, and the block it is being inserted before
+	make a contiguous block of memory? */
+	puc = ( uint8_t * ) pxBlockToInsert;
+	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
+	{
+		if( pxIterator->pxNextFreeBlock != pxEnd )
+		{
+			/* Form one big block from the two blocks. */
+			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
+			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
+		}
+		else
+		{
+			pxBlockToInsert->pxNextFreeBlock = pxEnd;
+		}
+	}
+	else
+	{
+		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
+	}
+
+	/* If the block being inserted plugged a gab, so was merged with the block
+	before and the block after, then it's pxNextFreeBlock pointer will have
+	already been set, and should not be set here as that would make it point
+	to itself. */
+	if( pxIterator != pxBlockToInsert )
+	{
+		pxIterator->pxNextFreeBlock = pxBlockToInsert;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )
+{
+BlockLink_t *pxFirstFreeBlockInRegion = NULL, *pxPreviousFreeBlock;
+size_t xAlignedHeap;
+size_t xTotalRegionSize, xTotalHeapSize = 0;
+BaseType_t xDefinedRegions = 0;
+size_t xAddress;
+const HeapRegion_t *pxHeapRegion;
+
+	/* Can only call once! */
+	configASSERT( pxEnd == NULL );
+
+	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
+
+	while( pxHeapRegion->xSizeInBytes > 0 )
+	{
+		xTotalRegionSize = pxHeapRegion->xSizeInBytes;
+
+		/* Ensure the heap region starts on a correctly aligned boundary. */
+		xAddress = ( size_t ) pxHeapRegion->pucStartAddress;
+		if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
+		{
+			xAddress += ( portBYTE_ALIGNMENT - 1 );
+			xAddress &= ~portBYTE_ALIGNMENT_MASK;
+
+			/* Adjust the size for the bytes lost to alignment. */
+			xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;
+		}
+
+		xAlignedHeap = xAddress;
+
+		/* Set xStart if it has not already been set. */
+		if( xDefinedRegions == 0 )
+		{
+			/* xStart is used to hold a pointer to the first item in the list of
+			free blocks.  The void cast is used to prevent compiler warnings. */
+			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
+			xStart.xBlockSize = ( size_t ) 0;
+		}
+		else
+		{
+			/* Should only get here if one region has already been added to the
+			heap. */
+			configASSERT( pxEnd != NULL );
+
+			/* Check blocks are passed in with increasing start addresses. */
+			configASSERT( xAddress > ( size_t ) pxEnd );
+		}
+
+		/* Remember the location of the end marker in the previous region, if
+		any. */
+		pxPreviousFreeBlock = pxEnd;
+
+		/* pxEnd is used to mark the end of the list of free blocks and is
+		inserted at the end of the region space. */
+		xAddress = xAlignedHeap + xTotalRegionSize;
+		xAddress -= xHeapStructSize;
+		xAddress &= ~portBYTE_ALIGNMENT_MASK;
+		pxEnd = ( BlockLink_t * ) xAddress;
+		pxEnd->xBlockSize = 0;
+		pxEnd->pxNextFreeBlock = NULL;
+
+		/* To start with there is a single free block in this region that is
+		sized to take up the entire heap region minus the space taken by the
+		free block structure. */
+		pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;
+		pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;
+		pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;
+
+		/* If this is not the first region that makes up the entire heap space
+		then link the previous region to this region. */
+		if( pxPreviousFreeBlock != NULL )
+		{
+			pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;
+		}
+
+		xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;
+
+		/* Move onto the next HeapRegion_t structure. */
+		xDefinedRegions++;
+		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
+	}
+
+	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
+	xFreeBytesRemaining = xTotalHeapSize;
+
+	/* Check something was actually defined before it is accessed. */
+	configASSERT( xTotalHeapSize );
+
+	/* Work out the position of the top bit in a size_t variable. */
+	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
+}
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/MemMang/ReadMe.url ./libs/freertos/MemMang/ReadMe.url
--- a_bRU7kv/libs/freertos/MemMang/ReadMe.url	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/MemMang/ReadMe.url	2018-12-01 17:15:06.593605839 -0300
@@ -0,0 +1,5 @@
+[{000214A0-0000-0000-C000-000000000046}]
+Prop3=19,2
+[InternetShortcut]
+URL=http://www.freertos.org/a00111.html
+IDList=
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/module.mk ./libs/freertos/module.mk
--- a_bRU7kv/libs/freertos/module.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/module.mk	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,23 @@
+ifeq ($(USE_FREERTOS),y)
+
+FREERTOS_BASE=libs/freertos
+SRC+=$(FREERTOS_BASE)/MemMang/heap_$(FREERTOS_HEAP_TYPE).c
+
+INCLUDES += -I$(FREERTOS_BASE)/include
+INCLUDES += -I$(FREERTOS_BASE)/include/private
+
+DEFINES+=USE_FREERTOS
+DEFINES+=TICK_OVER_RTOS
+
+SRC+=$(wildcard $(FREERTOS_BASE)/source/*.c)
+SRC+=$(wildcard $(FREERTOS_BASE)/source/portable/*.c)
+
+ifeq ($(USE_FPU),y)
+INCLUDES += -I$(FREERTOS_BASE)/source/portable/ARM_CM4F
+SRC+=$(FREERTOS_BASE)/source/portable/ARM_CM4F/port.c
+else
+INCLUDES += -I$(FREERTOS_BASE)/source/portable/ARM_CM3
+SRC+=$(FREERTOS_BASE)/source/portable/ARM_CM3/port.c
+endif
+
+endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/event_groups.c ./libs/freertos/source/event_groups.c
--- a_bRU7kv/libs/freertos/source/event_groups.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/event_groups.c	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,738 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/* Standard includes. */
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+/* FreeRTOS includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+#include "timers.h"
+#include "event_groups.h"
+
+/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
+MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
+header files above, but not in this file, in order to generate the correct
+privileged Vs unprivileged linkage and placement. */
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
+
+/* The following bit fields convey control information in a task's event list
+item value.  It is important they don't clash with the
+taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
+#if configUSE_16_BIT_TICKS == 1
+	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
+	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
+	#define eventWAIT_FOR_ALL_BITS			0x0400U
+	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
+#else
+	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
+	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
+	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
+	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
+#endif
+
+typedef struct xEventGroupDefinition
+{
+	EventBits_t uxEventBits;
+	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
+
+	#if( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxEventGroupNumber;
+	#endif
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
+	#endif
+} EventGroup_t;
+
+/*-----------------------------------------------------------*/
+
+/*
+ * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
+ * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
+ * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
+ * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
+ * wait condition is met if any of the bits set in uxBitsToWait for are also set
+ * in uxCurrentEventBits.
+ */
+static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
+	{
+	EventGroup_t *pxEventBits;
+
+		/* A StaticEventGroup_t object must be provided. */
+		configASSERT( pxEventGroupBuffer );
+
+		#if( configASSERT_DEFINED == 1 )
+		{
+			/* Sanity check that the size of the structure used to declare a
+			variable of type StaticEventGroup_t equals the size of the real
+			event group structure. */
+			volatile size_t xSize = sizeof( StaticEventGroup_t );
+			configASSERT( xSize == sizeof( EventGroup_t ) );
+		}
+		#endif /* configASSERT_DEFINED */
+
+		/* The user has provided a statically allocated event group - use it. */
+		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 EventGroup_t and StaticEventGroup_t are guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
+
+		if( pxEventBits != NULL )
+		{
+			pxEventBits->uxEventBits = 0;
+			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
+
+			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+			{
+				/* Both static and dynamic allocation can be used, so note that
+				this event group was created statically in case the event group
+				is later deleted. */
+				pxEventBits->ucStaticallyAllocated = pdTRUE;
+			}
+			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+
+			traceEVENT_GROUP_CREATE( pxEventBits );
+		}
+		else
+		{
+			traceEVENT_GROUP_CREATE_FAILED();
+		}
+
+		return ( EventGroupHandle_t ) pxEventBits;
+	}
+
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+
+	EventGroupHandle_t xEventGroupCreate( void )
+	{
+	EventGroup_t *pxEventBits;
+
+		/* Allocate the event group. */
+		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
+
+		if( pxEventBits != NULL )
+		{
+			pxEventBits->uxEventBits = 0;
+			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
+
+			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+			{
+				/* Both static and dynamic allocation can be used, so note this
+				event group was allocated statically in case the event group is
+				later deleted. */
+				pxEventBits->ucStaticallyAllocated = pdFALSE;
+			}
+			#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+			traceEVENT_GROUP_CREATE( pxEventBits );
+		}
+		else
+		{
+			traceEVENT_GROUP_CREATE_FAILED();
+		}
+
+		return ( EventGroupHandle_t ) pxEventBits;
+	}
+
+#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
+{
+EventBits_t uxOriginalBitValue, uxReturn;
+EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+BaseType_t xAlreadyYielded;
+BaseType_t xTimeoutOccurred = pdFALSE;
+
+	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
+	configASSERT( uxBitsToWaitFor != 0 );
+	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+	{
+		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
+	}
+	#endif
+
+	vTaskSuspendAll();
+	{
+		uxOriginalBitValue = pxEventBits->uxEventBits;
+
+		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
+
+		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
+		{
+			/* All the rendezvous bits are now set - no need to block. */
+			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
+
+			/* Rendezvous always clear the bits.  They will have been cleared
+			already unless this is the only task in the rendezvous. */
+			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
+
+			xTicksToWait = 0;
+		}
+		else
+		{
+			if( xTicksToWait != ( TickType_t ) 0 )
+			{
+				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
+
+				/* Store the bits that the calling task is waiting for in the
+				task's event list item so the kernel knows when a match is
+				found.  Then enter the blocked state. */
+				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
+
+				/* This assignment is obsolete as uxReturn will get set after
+				the task unblocks, but some compilers mistakenly generate a
+				warning about uxReturn being returned without being set if the
+				assignment is omitted. */
+				uxReturn = 0;
+			}
+			else
+			{
+				/* The rendezvous bits were not set, but no block time was
+				specified - just return the current event bit value. */
+				uxReturn = pxEventBits->uxEventBits;
+				xTimeoutOccurred = pdTRUE;
+			}
+		}
+	}
+	xAlreadyYielded = xTaskResumeAll();
+
+	if( xTicksToWait != ( TickType_t ) 0 )
+	{
+		if( xAlreadyYielded == pdFALSE )
+		{
+			portYIELD_WITHIN_API();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		/* The task blocked to wait for its required bits to be set - at this
+		point either the required bits were set or the block time expired.  If
+		the required bits were set they will have been stored in the task's
+		event list item, and they should now be retrieved then cleared. */
+		uxReturn = uxTaskResetEventItemValue();
+
+		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
+		{
+			/* The task timed out, just return the current event bit value. */
+			taskENTER_CRITICAL();
+			{
+				uxReturn = pxEventBits->uxEventBits;
+
+				/* Although the task got here because it timed out before the
+				bits it was waiting for were set, it is possible that since it
+				unblocked another task has set the bits.  If this is the case
+				then it needs to clear the bits before exiting. */
+				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
+				{
+					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			taskEXIT_CRITICAL();
+
+			xTimeoutOccurred = pdTRUE;
+		}
+		else
+		{
+			/* The task unblocked because the bits were set. */
+		}
+
+		/* Control bits might be set as the task had blocked should not be
+		returned. */
+		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
+	}
+
+	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
+
+	/* Prevent compiler warnings when trace macros are not used. */
+	( void ) xTimeoutOccurred;
+
+	return uxReturn;
+}
+/*-----------------------------------------------------------*/
+
+EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
+{
+EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+EventBits_t uxReturn, uxControlBits = 0;
+BaseType_t xWaitConditionMet, xAlreadyYielded;
+BaseType_t xTimeoutOccurred = pdFALSE;
+
+	/* Check the user is not attempting to wait on the bits used by the kernel
+	itself, and that at least one bit is being requested. */
+	configASSERT( xEventGroup );
+	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
+	configASSERT( uxBitsToWaitFor != 0 );
+	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+	{
+		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
+	}
+	#endif
+
+	vTaskSuspendAll();
+	{
+		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
+
+		/* Check to see if the wait condition is already met or not. */
+		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
+
+		if( xWaitConditionMet != pdFALSE )
+		{
+			/* The wait condition has already been met so there is no need to
+			block. */
+			uxReturn = uxCurrentEventBits;
+			xTicksToWait = ( TickType_t ) 0;
+
+			/* Clear the wait bits if requested to do so. */
+			if( xClearOnExit != pdFALSE )
+			{
+				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else if( xTicksToWait == ( TickType_t ) 0 )
+		{
+			/* The wait condition has not been met, but no block time was
+			specified, so just return the current value. */
+			uxReturn = uxCurrentEventBits;
+			xTimeoutOccurred = pdTRUE;
+		}
+		else
+		{
+			/* The task is going to block to wait for its required bits to be
+			set.  uxControlBits are used to remember the specified behaviour of
+			this call to xEventGroupWaitBits() - for use when the event bits
+			unblock the task. */
+			if( xClearOnExit != pdFALSE )
+			{
+				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			if( xWaitForAllBits != pdFALSE )
+			{
+				uxControlBits |= eventWAIT_FOR_ALL_BITS;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			/* Store the bits that the calling task is waiting for in the
+			task's event list item so the kernel knows when a match is
+			found.  Then enter the blocked state. */
+			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
+
+			/* This is obsolete as it will get set after the task unblocks, but
+			some compilers mistakenly generate a warning about the variable
+			being returned without being set if it is not done. */
+			uxReturn = 0;
+
+			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
+		}
+	}
+	xAlreadyYielded = xTaskResumeAll();
+
+	if( xTicksToWait != ( TickType_t ) 0 )
+	{
+		if( xAlreadyYielded == pdFALSE )
+		{
+			portYIELD_WITHIN_API();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		/* The task blocked to wait for its required bits to be set - at this
+		point either the required bits were set or the block time expired.  If
+		the required bits were set they will have been stored in the task's
+		event list item, and they should now be retrieved then cleared. */
+		uxReturn = uxTaskResetEventItemValue();
+
+		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
+		{
+			taskENTER_CRITICAL();
+			{
+				/* The task timed out, just return the current event bit value. */
+				uxReturn = pxEventBits->uxEventBits;
+
+				/* It is possible that the event bits were updated between this
+				task leaving the Blocked state and running again. */
+				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
+				{
+					if( xClearOnExit != pdFALSE )
+					{
+						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+				xTimeoutOccurred = pdTRUE;
+			}
+			taskEXIT_CRITICAL();
+		}
+		else
+		{
+			/* The task unblocked because the bits were set. */
+		}
+
+		/* The task blocked so control bits may have been set. */
+		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
+	}
+	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
+
+	/* Prevent compiler warnings when trace macros are not used. */
+	( void ) xTimeoutOccurred;
+
+	return uxReturn;
+}
+/*-----------------------------------------------------------*/
+
+EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
+{
+EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+EventBits_t uxReturn;
+
+	/* Check the user is not attempting to clear the bits used by the kernel
+	itself. */
+	configASSERT( xEventGroup );
+	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
+
+	taskENTER_CRITICAL();
+	{
+		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
+
+		/* The value returned is the event group value prior to the bits being
+		cleared. */
+		uxReturn = pxEventBits->uxEventBits;
+
+		/* Clear the bits. */
+		pxEventBits->uxEventBits &= ~uxBitsToClear;
+	}
+	taskEXIT_CRITICAL();
+
+	return uxReturn;
+}
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
+
+	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
+	{
+		BaseType_t xReturn;
+
+		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
+		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
+
+		return xReturn;
+	}
+
+#endif
+/*-----------------------------------------------------------*/
+
+EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
+{
+UBaseType_t uxSavedInterruptStatus;
+EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+EventBits_t uxReturn;
+
+	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		uxReturn = pxEventBits->uxEventBits;
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return uxReturn;
+}
+/*-----------------------------------------------------------*/
+
+EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
+{
+ListItem_t *pxListItem, *pxNext;
+ListItem_t const *pxListEnd;
+List_t *pxList;
+EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
+EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+BaseType_t xMatchFound = pdFALSE;
+
+	/* Check the user is not attempting to set the bits used by the kernel
+	itself. */
+	configASSERT( xEventGroup );
+	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
+
+	pxList = &( pxEventBits->xTasksWaitingForBits );
+	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
+	vTaskSuspendAll();
+	{
+		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
+
+		pxListItem = listGET_HEAD_ENTRY( pxList );
+
+		/* Set the bits. */
+		pxEventBits->uxEventBits |= uxBitsToSet;
+
+		/* See if the new bit value should unblock any tasks. */
+		while( pxListItem != pxListEnd )
+		{
+			pxNext = listGET_NEXT( pxListItem );
+			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
+			xMatchFound = pdFALSE;
+
+			/* Split the bits waited for from the control bits. */
+			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
+			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
+
+			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
+			{
+				/* Just looking for single bit being set. */
+				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
+				{
+					xMatchFound = pdTRUE;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
+			{
+				/* All bits are set. */
+				xMatchFound = pdTRUE;
+			}
+			else
+			{
+				/* Need all bits to be set, but not all the bits were set. */
+			}
+
+			if( xMatchFound != pdFALSE )
+			{
+				/* The bits match.  Should the bits be cleared on exit? */
+				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
+				{
+					uxBitsToClear |= uxBitsWaitedFor;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				/* Store the actual event flag value in the task's event list
+				item before removing the task from the event list.  The
+				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
+				that is was unblocked due to its required bits matching, rather
+				than because it timed out. */
+				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
+			}
+
+			/* Move onto the next list item.  Note pxListItem->pxNext is not
+			used here as the list item may have been removed from the event list
+			and inserted into the ready/pending reading list. */
+			pxListItem = pxNext;
+		}
+
+		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
+		bit was set in the control word. */
+		pxEventBits->uxEventBits &= ~uxBitsToClear;
+	}
+	( void ) xTaskResumeAll();
+
+	return pxEventBits->uxEventBits;
+}
+/*-----------------------------------------------------------*/
+
+void vEventGroupDelete( EventGroupHandle_t xEventGroup )
+{
+EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
+
+	vTaskSuspendAll();
+	{
+		traceEVENT_GROUP_DELETE( xEventGroup );
+
+		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
+		{
+			/* Unblock the task, returning 0 as the event list is being deleted
+			and cannot therefore have any bits set. */
+			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
+			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
+		}
+
+		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
+		{
+			/* The event group can only have been allocated dynamically - free
+			it again. */
+			vPortFree( pxEventBits );
+		}
+		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+		{
+			/* The event group could have been allocated statically or
+			dynamically, so check before attempting to free the memory. */
+			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
+			{
+				vPortFree( pxEventBits );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+	}
+	( void ) xTaskResumeAll();
+}
+/*-----------------------------------------------------------*/
+
+/* For internal use only - execute a 'set bits' command that was pended from
+an interrupt. */
+void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
+{
+	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
+}
+/*-----------------------------------------------------------*/
+
+/* For internal use only - execute a 'clear bits' command that was pended from
+an interrupt. */
+void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
+{
+	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
+}
+/*-----------------------------------------------------------*/
+
+static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
+{
+BaseType_t xWaitConditionMet = pdFALSE;
+
+	if( xWaitForAllBits == pdFALSE )
+	{
+		/* Task only has to wait for one bit within uxBitsToWaitFor to be
+		set.  Is one already set? */
+		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
+		{
+			xWaitConditionMet = pdTRUE;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
+		Are they set already? */
+		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
+		{
+			xWaitConditionMet = pdTRUE;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+	return xWaitConditionMet;
+}
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
+
+	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
+	{
+	BaseType_t xReturn;
+
+		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
+		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
+
+		return xReturn;
+	}
+
+#endif
+/*-----------------------------------------------------------*/
+
+#if (configUSE_TRACE_FACILITY == 1)
+
+	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
+	{
+	UBaseType_t xReturn;
+	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
+
+		if( xEventGroup == NULL )
+		{
+			xReturn = 0;
+		}
+		else
+		{
+			xReturn = pxEventBits->uxEventGroupNumber;
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
+	{
+		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/hooks.c ./libs/freertos/source/hooks.c
--- a_bRU7kv/libs/freertos/source/hooks.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/hooks.c	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,15 @@
+#include <FreeRTOS.h>
+#include <task.h>
+
+void vApplicationStackOverflowHook(TaskHandle_t xTask,
+                                   signed char *pcTaskName)
+{
+    while(1)
+        ;
+}
+
+void vApplicationMallocFailedHook( void )
+{
+    while(1)
+        ;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/list.c ./libs/freertos/source/list.c
--- a_bRU7kv/libs/freertos/source/list.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/list.c	2018-12-01 17:15:06.601605940 -0300
@@ -0,0 +1,198 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#include <stdlib.h>
+#include "FreeRTOS.h"
+#include "list.h"
+
+/*-----------------------------------------------------------
+ * PUBLIC LIST API documented in list.h
+ *----------------------------------------------------------*/
+
+void vListInitialise( List_t * const pxList )
+{
+	/* The list structure contains a list item which is used to mark the
+	end of the list.  To initialise the list the list end is inserted
+	as the only list entry. */
+	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
+
+	/* The list end value is the highest possible value in the list to
+	ensure it remains at the end of the list. */
+	pxList->xListEnd.xItemValue = portMAX_DELAY;
+
+	/* The list end next and previous pointers point to itself so we know
+	when the list is empty. */
+	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
+	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
+
+	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
+
+	/* Write known values into the list if
+	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
+	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
+}
+/*-----------------------------------------------------------*/
+
+void vListInitialiseItem( ListItem_t * const pxItem )
+{
+	/* Make sure the list item is not recorded as being on a list. */
+	pxItem->pvContainer = NULL;
+
+	/* Write known values into the list item if
+	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
+	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
+}
+/*-----------------------------------------------------------*/
+
+void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
+{
+ListItem_t * const pxIndex = pxList->pxIndex;
+
+	/* Only effective when configASSERT() is also defined, these tests may catch
+	the list data structures being overwritten in memory.  They will not catch
+	data errors caused by incorrect configuration or use of FreeRTOS. */
+	listTEST_LIST_INTEGRITY( pxList );
+	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
+
+	/* Insert a new list item into pxList, but rather than sort the list,
+	makes the new list item the last item to be removed by a call to
+	listGET_OWNER_OF_NEXT_ENTRY(). */
+	pxNewListItem->pxNext = pxIndex;
+	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
+
+	/* Only used during decision coverage testing. */
+	mtCOVERAGE_TEST_DELAY();
+
+	pxIndex->pxPrevious->pxNext = pxNewListItem;
+	pxIndex->pxPrevious = pxNewListItem;
+
+	/* Remember which list the item is in. */
+	pxNewListItem->pvContainer = ( void * ) pxList;
+
+	( pxList->uxNumberOfItems )++;
+}
+/*-----------------------------------------------------------*/
+
+void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
+{
+ListItem_t *pxIterator;
+const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
+
+	/* Only effective when configASSERT() is also defined, these tests may catch
+	the list data structures being overwritten in memory.  They will not catch
+	data errors caused by incorrect configuration or use of FreeRTOS. */
+	listTEST_LIST_INTEGRITY( pxList );
+	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
+
+	/* Insert the new list item into the list, sorted in xItemValue order.
+
+	If the list already contains a list item with the same item value then the
+	new list item should be placed after it.  This ensures that TCB's which are
+	stored in ready lists (all of which have the same xItemValue value) get a
+	share of the CPU.  However, if the xItemValue is the same as the back marker
+	the iteration loop below will not end.  Therefore the value is checked
+	first, and the algorithm slightly modified if necessary. */
+	if( xValueOfInsertion == portMAX_DELAY )
+	{
+		pxIterator = pxList->xListEnd.pxPrevious;
+	}
+	else
+	{
+		/* *** NOTE ***********************************************************
+		If you find your application is crashing here then likely causes are
+		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
+		more tips, and ensure configASSERT() is defined!
+		http://www.freertos.org/a00110.html#configASSERT
+
+			1) Stack overflow -
+			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
+			2) Incorrect interrupt priority assignment, especially on Cortex-M
+			   parts where numerically high priority values denote low actual
+			   interrupt priorities, which can seem counter intuitive.  See
+			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
+			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
+			   http://www.freertos.org/a00110.html
+			3) Calling an API function from within a critical section or when
+			   the scheduler is suspended, or calling an API function that does
+			   not end in "FromISR" from an interrupt.
+			4) Using a queue or semaphore before it has been initialised or
+			   before the scheduler has been started (are interrupts firing
+			   before vTaskStartScheduler() has been called?).
+		**********************************************************************/
+
+		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
+		{
+			/* There is nothing to do here, just iterating to the wanted
+			insertion position. */
+		}
+	}
+
+	pxNewListItem->pxNext = pxIterator->pxNext;
+	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
+	pxNewListItem->pxPrevious = pxIterator;
+	pxIterator->pxNext = pxNewListItem;
+
+	/* Remember which list the item is in.  This allows fast removal of the
+	item later. */
+	pxNewListItem->pvContainer = ( void * ) pxList;
+
+	( pxList->uxNumberOfItems )++;
+}
+/*-----------------------------------------------------------*/
+
+UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
+{
+/* The list item knows which list it is in.  Obtain the list from the list
+item. */
+List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
+
+	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
+	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
+
+	/* Only used during decision coverage testing. */
+	mtCOVERAGE_TEST_DELAY();
+
+	/* Make sure the index is left pointing to a valid item. */
+	if( pxList->pxIndex == pxItemToRemove )
+	{
+		pxList->pxIndex = pxItemToRemove->pxPrevious;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	pxItemToRemove->pvContainer = NULL;
+	( pxList->uxNumberOfItems )--;
+
+	return pxList->uxNumberOfItems;
+}
+/*-----------------------------------------------------------*/
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/portable/ARM_CM3/port.c ./libs/freertos/source/portable/ARM_CM3/port.c
--- a_bRU7kv/libs/freertos/source/portable/ARM_CM3/port.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/portable/ARM_CM3/port.c	2018-12-01 17:15:06.605605990 -0300
@@ -0,0 +1,717 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*-----------------------------------------------------------
+ * Implementation of functions defined in portable.h for the ARM CM3 port.
+ *----------------------------------------------------------*/
+
+/* Scheduler includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+
+/* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is
+defined.  The value should also ensure backward compatibility.
+FreeRTOS.org versions prior to V4.4.0 did not include this definition. */
+#ifndef configKERNEL_INTERRUPT_PRIORITY
+	#define configKERNEL_INTERRUPT_PRIORITY 255
+#endif
+
+#ifndef configSYSTICK_CLOCK_HZ
+	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
+	/* Ensure the SysTick is clocked at the same frequency as the core. */
+	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
+#else
+	/* The way the SysTick is clocked is not modified in case it is not the same
+	as the core. */
+	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
+#endif
+
+/* Constants required to manipulate the core.  Registers first... */
+#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
+#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
+#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
+#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
+/* ...then bits in the registers. */
+#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
+#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
+#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
+#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
+#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
+
+#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
+#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
+
+/* Constants required to check the validity of an interrupt priority. */
+#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
+#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
+#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
+#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
+#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
+#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
+#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
+#define portPRIGROUP_SHIFT					( 8UL )
+
+/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
+#define portVECTACTIVE_MASK					( 0xFFUL )
+
+/* Constants required to set up the initial stack. */
+#define portINITIAL_XPSR					( 0x01000000UL )
+
+/* The systick is a 24-bit counter. */
+#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
+
+/* A fiddle factor to estimate the number of SysTick counts that would have
+occurred while the SysTick counter is stopped during tickless idle
+calculations. */
+#define portMISSED_COUNTS_FACTOR			( 45UL )
+
+/* For strict compliance with the Cortex-M spec the task start address should
+have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
+#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
+
+/* Let the user override the pre-loading of the initial LR with the address of
+prvTaskExitError() in case it messes up unwinding of the stack in the
+debugger. */
+#ifdef configTASK_RETURN_ADDRESS
+	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
+#else
+	#define portTASK_RETURN_ADDRESS	prvTaskExitError
+#endif
+
+/*
+ * Setup the timer to generate the tick interrupts.  The implementation in this
+ * file is weak to allow application writers to change the timer used to
+ * generate the tick interrupt.
+ */
+void vPortSetupTimerInterrupt( void );
+
+/*
+ * Exception handlers.
+ */
+void xPortPendSVHandler( void ) __attribute__ (( naked ));
+void xPortSysTickHandler( void );
+void vPortSVCHandler( void ) __attribute__ (( naked ));
+
+/*
+ * Start first task is a separate function so it can be tested in isolation.
+ */
+static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
+
+/*
+ * Used to catch tasks that attempt to return from their implementing function.
+ */
+static void prvTaskExitError( void );
+
+/*-----------------------------------------------------------*/
+
+/* Each task maintains its own interrupt status in the critical nesting
+variable. */
+static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
+
+/*
+ * The number of SysTick increments that make up one tick period.
+ */
+#if( configUSE_TICKLESS_IDLE == 1 )
+	static uint32_t ulTimerCountsForOneTick = 0;
+#endif /* configUSE_TICKLESS_IDLE */
+
+/*
+ * The maximum number of tick periods that can be suppressed is limited by the
+ * 24 bit resolution of the SysTick timer.
+ */
+#if( configUSE_TICKLESS_IDLE == 1 )
+	static uint32_t xMaximumPossibleSuppressedTicks = 0;
+#endif /* configUSE_TICKLESS_IDLE */
+
+/*
+ * Compensate for the CPU cycles that pass while the SysTick is stopped (low
+ * power functionality only.
+ */
+#if( configUSE_TICKLESS_IDLE == 1 )
+	static uint32_t ulStoppedTimerCompensation = 0;
+#endif /* configUSE_TICKLESS_IDLE */
+
+/*
+ * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
+ * FreeRTOS API functions are not called from interrupts that have been assigned
+ * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
+ */
+#if( configASSERT_DEFINED == 1 )
+	 static uint8_t ucMaxSysCallPriority = 0;
+	 static uint32_t ulMaxPRIGROUPValue = 0;
+	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
+#endif /* configASSERT_DEFINED */
+
+/*-----------------------------------------------------------*/
+
+/*
+ * See header file for description.
+ */
+StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
+{
+	/* Simulate the stack frame as it would be created by a context switch
+	interrupt. */
+	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
+	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
+	pxTopOfStack--;
+	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
+	pxTopOfStack--;
+	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
+	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
+	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
+	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
+
+	return pxTopOfStack;
+}
+/*-----------------------------------------------------------*/
+
+static void prvTaskExitError( void )
+{
+volatile uint32_t ulDummy = 0UL;
+
+	/* A function that implements a task must not exit or attempt to return to
+	its caller as there is nothing to return to.  If a task wants to exit it
+	should instead call vTaskDelete( NULL ).
+
+	Artificially force an assert() to be triggered if configASSERT() is
+	defined, then stop here so application writers can catch the error. */
+	configASSERT( uxCriticalNesting == ~0UL );
+	portDISABLE_INTERRUPTS();
+	while( ulDummy == 0 )
+	{
+		/* This file calls prvTaskExitError() after the scheduler has been
+		started to remove a compiler warning about the function being defined
+		but never called.  ulDummy is used purely to quieten other warnings
+		about code appearing after this function is called - making ulDummy
+		volatile makes the compiler think the function could return and
+		therefore not output an 'unreachable code' warning for code that appears
+		after it. */
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vPortSVCHandler( void )
+{
+	__asm volatile (
+					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
+					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
+					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
+					"	ldmia r0!, {r4-r11}				\n" /* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
+					"	msr psp, r0						\n" /* Restore the task stack pointer. */
+					"	isb								\n"
+					"	mov r0, #0 						\n"
+					"	msr	basepri, r0					\n"
+					"	orr r14, #0xd					\n"
+					"	bx r14							\n"
+					"									\n"
+					"	.align 4						\n"
+					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
+				);
+}
+/*-----------------------------------------------------------*/
+
+static void prvPortStartFirstTask( void )
+{
+	__asm volatile(
+					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
+					" ldr r0, [r0] 			\n"
+					" ldr r0, [r0] 			\n"
+					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
+					" cpsie i				\n" /* Globally enable interrupts. */
+					" cpsie f				\n"
+					" dsb					\n"
+					" isb					\n"
+					" svc 0					\n" /* System call to start first task. */
+					" nop					\n"
+				);
+}
+/*-----------------------------------------------------------*/
+
+/*
+ * See header file for description.
+ */
+BaseType_t xPortStartScheduler( void )
+{
+	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
+	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
+	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
+
+	#if( configASSERT_DEFINED == 1 )
+	{
+		volatile uint32_t ulOriginalPriority;
+		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
+		volatile uint8_t ucMaxPriorityValue;
+
+		/* Determine the maximum priority from which ISR safe FreeRTOS API
+		functions can be called.  ISR safe functions are those that end in
+		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
+		ensure interrupt entry is as fast and simple as possible.
+
+		Save the interrupt priority value that is about to be clobbered. */
+		ulOriginalPriority = *pucFirstUserPriorityRegister;
+
+		/* Determine the number of priority bits available.  First write to all
+		possible bits. */
+		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
+
+		/* Read the value back to see how many bits stuck. */
+		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
+
+		/* Use the same mask on the maximum system call priority. */
+		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
+
+		/* Calculate the maximum acceptable priority group value for the number
+		of bits read back. */
+		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
+		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
+		{
+			ulMaxPRIGROUPValue--;
+			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
+		}
+
+		#ifdef __NVIC_PRIO_BITS
+		{
+			/* Check the CMSIS configuration that defines the number of
+			priority bits matches the number of priority bits actually queried
+			from the hardware. */
+			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
+		}
+		#endif
+
+		#ifdef configPRIO_BITS
+		{
+			/* Check the FreeRTOS configuration that defines the number of
+			priority bits matches the number of priority bits actually queried
+			from the hardware. */
+			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
+		}
+		#endif
+
+		/* Shift the priority group value back to its position within the AIRCR
+		register. */
+		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
+		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
+
+		/* Restore the clobbered interrupt priority register to its original
+		value. */
+		*pucFirstUserPriorityRegister = ulOriginalPriority;
+	}
+	#endif /* conifgASSERT_DEFINED */
+
+	/* Make PendSV and SysTick the lowest priority interrupts. */
+	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
+	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
+
+	/* Start the timer that generates the tick ISR.  Interrupts are disabled
+	here already. */
+	vPortSetupTimerInterrupt();
+
+	/* Initialise the critical nesting count ready for the first task. */
+	uxCriticalNesting = 0;
+
+	/* Start the first task. */
+	prvPortStartFirstTask();
+
+	/* Should never get here as the tasks will now be executing!  Call the task
+	exit error function to prevent compiler warnings about a static function
+	not being called in the case that the application writer overrides this
+	functionality by defining configTASK_RETURN_ADDRESS.  Call
+	vTaskSwitchContext() so link time optimisation does not remove the
+	symbol. */
+	vTaskSwitchContext();
+	prvTaskExitError();
+
+	/* Should not get here! */
+	return 0;
+}
+/*-----------------------------------------------------------*/
+
+void vPortEndScheduler( void )
+{
+	/* Not implemented in ports where there is nothing to return to.
+	Artificially force an assert. */
+	configASSERT( uxCriticalNesting == 1000UL );
+}
+/*-----------------------------------------------------------*/
+
+void vPortEnterCritical( void )
+{
+	portDISABLE_INTERRUPTS();
+	uxCriticalNesting++;
+
+	/* This is not the interrupt safe version of the enter critical function so
+	assert() if it is being called from an interrupt context.  Only API
+	functions that end in "FromISR" can be used in an interrupt.  Only assert if
+	the critical nesting count is 1 to protect against recursive calls if the
+	assert function also uses a critical section. */
+	if( uxCriticalNesting == 1 )
+	{
+		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vPortExitCritical( void )
+{
+	configASSERT( uxCriticalNesting );
+	uxCriticalNesting--;
+	if( uxCriticalNesting == 0 )
+	{
+		portENABLE_INTERRUPTS();
+	}
+}
+/*-----------------------------------------------------------*/
+
+void xPortPendSVHandler( void )
+{
+	/* This is a naked function. */
+
+	__asm volatile
+	(
+	"	mrs r0, psp							\n"
+	"	isb									\n"
+	"										\n"
+	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
+	"	ldr	r2, [r3]						\n"
+	"										\n"
+	"	stmdb r0!, {r4-r11}					\n" /* Save the remaining registers. */
+	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
+	"										\n"
+	"	stmdb sp!, {r3, r14}				\n"
+	"	mov r0, %0							\n"
+	"	msr basepri, r0						\n"
+	"	bl vTaskSwitchContext				\n"
+	"	mov r0, #0							\n"
+	"	msr basepri, r0						\n"
+	"	ldmia sp!, {r3, r14}				\n"
+	"										\n" /* Restore the context, including the critical nesting count. */
+	"	ldr r1, [r3]						\n"
+	"	ldr r0, [r1]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
+	"	ldmia r0!, {r4-r11}					\n" /* Pop the registers. */
+	"	msr psp, r0							\n"
+	"	isb									\n"
+	"	bx r14								\n"
+	"										\n"
+	"	.align 4							\n"
+	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
+	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
+	);
+}
+/*-----------------------------------------------------------*/
+
+void xPortSysTickHandler( void )
+{
+	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
+	executes all interrupts must be unmasked.  There is therefore no need to
+	save and then restore the interrupt mask value as its value is already
+	known. */
+	portDISABLE_INTERRUPTS();
+	{
+		/* Increment the RTOS tick. */
+		if( xTaskIncrementTick() != pdFALSE )
+		{
+			/* A context switch is required.  Context switching is performed in
+			the PendSV interrupt.  Pend the PendSV interrupt. */
+			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
+		}
+	}
+	portENABLE_INTERRUPTS();
+}
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TICKLESS_IDLE == 1 )
+
+	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
+	{
+	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
+	TickType_t xModifiableIdleTime;
+
+		/* Make sure the SysTick reload value does not overflow the counter. */
+		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
+		{
+			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
+		}
+
+		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
+		is accounted for as best it can be, but using the tickless mode will
+		inevitably result in some tiny drift of the time maintained by the
+		kernel with respect to calendar time. */
+		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
+
+		/* Calculate the reload value required to wait xExpectedIdleTime
+		tick periods.  -1 is used because this code will execute part way
+		through one of the tick periods. */
+		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
+		if( ulReloadValue > ulStoppedTimerCompensation )
+		{
+			ulReloadValue -= ulStoppedTimerCompensation;
+		}
+
+		/* Enter a critical section but don't use the taskENTER_CRITICAL()
+		method as that will mask interrupts that should exit sleep mode. */
+		__asm volatile( "cpsid i" ::: "memory" );
+		__asm volatile( "dsb" );
+		__asm volatile( "isb" );
+
+		/* If a context switch is pending or a task is waiting for the scheduler
+		to be unsuspended then abandon the low power entry. */
+		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
+		{
+			/* Restart from whatever is left in the count register to complete
+			this tick period. */
+			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
+
+			/* Restart SysTick. */
+			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
+
+			/* Reset the reload register to the value required for normal tick
+			periods. */
+			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
+
+			/* Re-enable interrupts - see comments above the cpsid instruction()
+			above. */
+			__asm volatile( "cpsie i" ::: "memory" );
+		}
+		else
+		{
+			/* Set the new reload value. */
+			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
+
+			/* Clear the SysTick count flag and set the count value back to
+			zero. */
+			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
+
+			/* Restart SysTick. */
+			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
+
+			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
+			set its parameter to 0 to indicate that its implementation contains
+			its own wait for interrupt or wait for event instruction, and so wfi
+			should not be executed again.  However, the original expected idle
+			time variable must remain unmodified, so a copy is taken. */
+			xModifiableIdleTime = xExpectedIdleTime;
+			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
+			if( xModifiableIdleTime > 0 )
+			{
+				__asm volatile( "dsb" ::: "memory" );
+				__asm volatile( "wfi" );
+				__asm volatile( "isb" );
+			}
+			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
+
+			/* Re-enable interrupts to allow the interrupt that brought the MCU
+			out of sleep mode to execute immediately.  see comments above
+			__disable_interrupt() call above. */
+			__asm volatile( "cpsie i" ::: "memory" );
+			__asm volatile( "dsb" );
+			__asm volatile( "isb" );
+
+			/* Disable interrupts again because the clock is about to be stopped
+			and interrupts that execute while the clock is stopped will increase
+			any slippage between the time maintained by the RTOS and calendar
+			time. */
+			__asm volatile( "cpsid i" ::: "memory" );
+			__asm volatile( "dsb" );
+			__asm volatile( "isb" );
+
+			/* Disable the SysTick clock without reading the
+			portNVIC_SYSTICK_CTRL_REG register to ensure the
+			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
+			the time the SysTick is stopped for is accounted for as best it can
+			be, but using the tickless mode will inevitably result in some tiny
+			drift of the time maintained by the kernel with respect to calendar
+			time*/
+			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
+
+			/* Determine if the SysTick clock has already counted to zero and
+			been set back to the current reload value (the reload back being
+			correct for the entire expected idle time) or if the SysTick is yet
+			to count to zero (in which case an interrupt other than the SysTick
+			must have brought the system out of sleep mode). */
+			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
+			{
+				uint32_t ulCalculatedLoadValue;
+
+				/* The tick interrupt is already pending, and the SysTick count
+				reloaded with ulReloadValue.  Reset the
+				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
+				period. */
+				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
+
+				/* Don't allow a tiny value, or values that have somehow
+				underflowed because the post sleep hook did something
+				that took too long. */
+				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
+				{
+					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
+				}
+
+				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
+
+				/* As the pending tick will be processed as soon as this
+				function exits, the tick value maintained by the tick is stepped
+				forward by one less than the time spent waiting. */
+				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
+			}
+			else
+			{
+				/* Something other than the tick interrupt ended the sleep.
+				Work out how long the sleep lasted rounded to complete tick
+				periods (not the ulReload value which accounted for part
+				ticks). */
+				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
+
+				/* How many complete tick periods passed while the processor
+				was waiting? */
+				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
+
+				/* The reload value is set to whatever fraction of a single tick
+				period remains. */
+				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
+			}
+
+			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
+			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
+			value. */
+			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
+			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
+			vTaskStepTick( ulCompleteTickPeriods );
+			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
+
+			/* Exit with interrpts enabled. */
+			__asm volatile( "cpsie i" ::: "memory" );
+		}
+	}
+
+#endif /* configUSE_TICKLESS_IDLE */
+/*-----------------------------------------------------------*/
+
+/*
+ * Setup the systick timer to generate the tick interrupts at the required
+ * frequency.
+ */
+__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
+{
+	/* Calculate the constants required to configure the tick interrupt. */
+	#if( configUSE_TICKLESS_IDLE == 1 )
+	{
+		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
+		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
+		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
+	}
+	#endif /* configUSE_TICKLESS_IDLE */
+
+	/* Stop and clear the SysTick. */
+	portNVIC_SYSTICK_CTRL_REG = 0UL;
+	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
+
+	/* Configure SysTick to interrupt at the requested rate. */
+	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
+	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
+}
+/*-----------------------------------------------------------*/
+
+#if( configASSERT_DEFINED == 1 )
+
+	void vPortValidateInterruptPriority( void )
+	{
+	uint32_t ulCurrentInterrupt;
+	uint8_t ucCurrentPriority;
+
+		/* Obtain the number of the currently executing interrupt. */
+		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
+
+		/* Is the interrupt number a user defined interrupt? */
+		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
+		{
+			/* Look up the interrupt's priority. */
+			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
+
+			/* The following assertion will fail if a service routine (ISR) for
+			an interrupt that has been assigned a priority above
+			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
+			function.  ISR safe FreeRTOS API functions must *only* be called
+			from interrupts that have been assigned a priority at or below
+			configMAX_SYSCALL_INTERRUPT_PRIORITY.
+
+			Numerically low interrupt priority numbers represent logically high
+			interrupt priorities, therefore the priority of the interrupt must
+			be set to a value equal to or numerically *higher* than
+			configMAX_SYSCALL_INTERRUPT_PRIORITY.
+
+			Interrupts that	use the FreeRTOS API must not be left at their
+			default priority of	zero as that is the highest possible priority,
+			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
+			and	therefore also guaranteed to be invalid.
+
+			FreeRTOS maintains separate thread and ISR API functions to ensure
+			interrupt entry is as fast and simple as possible.
+
+			The following links provide detailed information:
+			http://www.freertos.org/RTOS-Cortex-M3-M4.html
+			http://www.freertos.org/FAQHelp.html */
+			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
+		}
+
+		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
+		that define each interrupt's priority to be split between bits that
+		define the interrupt's pre-emption priority bits and bits that define
+		the interrupt's sub-priority.  For simplicity all bits must be defined
+		to be pre-emption priority bits.  The following assertion will fail if
+		this is not the case (if some bits represent a sub-priority).
+
+		If the application only uses CMSIS libraries for interrupt
+		configuration then the correct setting can be achieved on all Cortex-M
+		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
+		scheduler.  Note however that some vendor specific peripheral libraries
+		assume a non-zero priority group setting, in which cases using a value
+		of zero will result in unpredictable behaviour. */
+		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
+	}
+
+#endif /* configASSERT_DEFINED */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/portable/ARM_CM3/portmacro.h ./libs/freertos/source/portable/ARM_CM3/portmacro.h
--- a_bRU7kv/libs/freertos/source/portable/ARM_CM3/portmacro.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/portable/ARM_CM3/portmacro.h	2018-12-01 17:15:06.605605990 -0300
@@ -0,0 +1,242 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#ifndef PORTMACRO_H
+#define PORTMACRO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-----------------------------------------------------------
+ * Port specific definitions.
+ *
+ * The settings in this file configure FreeRTOS correctly for the
+ * given hardware and compiler.
+ *
+ * These settings should not be altered.
+ *-----------------------------------------------------------
+ */
+
+/* Type definitions. */
+#define portCHAR		char
+#define portFLOAT		float
+#define portDOUBLE		double
+#define portLONG		long
+#define portSHORT		short
+#define portSTACK_TYPE	uint32_t
+#define portBASE_TYPE	long
+
+typedef portSTACK_TYPE StackType_t;
+typedef long BaseType_t;
+typedef unsigned long UBaseType_t;
+
+#if( configUSE_16_BIT_TICKS == 1 )
+	typedef uint16_t TickType_t;
+	#define portMAX_DELAY ( TickType_t ) 0xffff
+#else
+	typedef uint32_t TickType_t;
+	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
+
+	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
+	not need to be guarded with a critical section. */
+	#define portTICK_TYPE_IS_ATOMIC 1
+#endif
+/*-----------------------------------------------------------*/
+
+/* Architecture specifics. */
+#define portSTACK_GROWTH			( -1 )
+#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
+#define portBYTE_ALIGNMENT			8
+/*-----------------------------------------------------------*/
+
+/* Scheduler utilities. */
+#define portYIELD() 															\
+{																				\
+	/* Set a PendSV to request a context switch. */								\
+	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
+																				\
+	/* Barriers are normally not required but do ensure the code is completely	\
+	within the specified behaviour for the architecture. */						\
+	__asm volatile( "dsb" ::: "memory" );										\
+	__asm volatile( "isb" );													\
+}
+
+#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
+#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
+#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
+#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
+/*-----------------------------------------------------------*/
+
+/* Critical section management. */
+extern void vPortEnterCritical( void );
+extern void vPortExitCritical( void );
+#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
+#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
+#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
+#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
+#define portENTER_CRITICAL()					vPortEnterCritical()
+#define portEXIT_CRITICAL()						vPortExitCritical()
+
+/*-----------------------------------------------------------*/
+
+/* Task function macros as described on the FreeRTOS.org WEB site.  These are
+not necessary for to use this port.  They are defined so the common demo files
+(which build with all the ports) will build. */
+#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
+#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
+/*-----------------------------------------------------------*/
+
+/* Tickless idle/low power functionality. */
+#ifndef portSUPPRESS_TICKS_AND_SLEEP
+	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
+	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
+#endif
+/*-----------------------------------------------------------*/
+
+/* Architecture specific optimisations. */
+#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
+	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
+#endif
+
+#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
+
+	/* Generic helper function. */
+	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
+	{
+	uint8_t ucReturn;
+
+		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
+		return ucReturn;
+	}
+
+	/* Check the configuration. */
+	#if( configMAX_PRIORITIES > 32 )
+		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
+	#endif
+
+	/* Store/clear the ready priorities in a bit map. */
+	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
+	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
+
+	/*-----------------------------------------------------------*/
+
+	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
+
+#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
+
+/*-----------------------------------------------------------*/
+
+#ifdef configASSERT
+	void vPortValidateInterruptPriority( void );
+	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
+#endif
+
+/* portNOP() is not required by this port. */
+#define portNOP()
+
+#define portINLINE	__inline
+
+#ifndef portFORCE_INLINE
+	#define portFORCE_INLINE inline __attribute__(( always_inline))
+#endif
+
+portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
+{
+uint32_t ulCurrentInterrupt;
+BaseType_t xReturn;
+
+	/* Obtain the number of the currently executing interrupt. */
+	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
+
+	if( ulCurrentInterrupt == 0 )
+	{
+		xReturn = pdFALSE;
+	}
+	else
+	{
+		xReturn = pdTRUE;
+	}
+
+	return xReturn;
+}
+
+/*-----------------------------------------------------------*/
+
+portFORCE_INLINE static void vPortRaiseBASEPRI( void )
+{
+uint32_t ulNewBASEPRI;
+
+	__asm volatile
+	(
+		"	mov %0, %1												\n" \
+		"	msr basepri, %0											\n" \
+		"	isb														\n" \
+		"	dsb														\n" \
+		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
+	);
+}
+
+/*-----------------------------------------------------------*/
+
+portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
+{
+uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
+
+	__asm volatile
+	(
+		"	mrs %0, basepri											\n" \
+		"	mov %1, %2												\n" \
+		"	msr basepri, %1											\n" \
+		"	isb														\n" \
+		"	dsb														\n" \
+		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
+	);
+
+	/* This return will not be reached but is necessary to prevent compiler
+	warnings. */
+	return ulOriginalBASEPRI;
+}
+/*-----------------------------------------------------------*/
+
+portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
+{
+	__asm volatile
+	(
+		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
+	);
+}
+/*-----------------------------------------------------------*/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PORTMACRO_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/portable/ARM_CM4F/port.c ./libs/freertos/source/portable/ARM_CM4F/port.c
--- a_bRU7kv/libs/freertos/source/portable/ARM_CM4F/port.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/portable/ARM_CM4F/port.c	2018-12-01 17:15:06.605605990 -0300
@@ -0,0 +1,775 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*-----------------------------------------------------------
+ * Implementation of functions defined in portable.h for the ARM CM4F port.
+ *----------------------------------------------------------*/
+
+/* Scheduler includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+
+#ifndef __VFP_FP__
+	#error This port can only be used when the project options are configured to enable hardware floating point support.
+#endif
+
+#ifndef configSYSTICK_CLOCK_HZ
+	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
+	/* Ensure the SysTick is clocked at the same frequency as the core. */
+	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
+#else
+	/* The way the SysTick is clocked is not modified in case it is not the same
+	as the core. */
+	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
+#endif
+
+/* Constants required to manipulate the core.  Registers first... */
+#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
+#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
+#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
+#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
+/* ...then bits in the registers. */
+#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
+#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
+#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
+#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
+#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
+
+/* Constants used to detect a Cortex-M7 r0p1 core, which should use the ARM_CM7
+r0p1 port. */
+#define portCPUID							( * ( ( volatile uint32_t * ) 0xE000ed00 ) )
+#define portCORTEX_M7_r0p1_ID				( 0x410FC271UL )
+#define portCORTEX_M7_r0p0_ID				( 0x410FC270UL )
+
+#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
+#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
+
+/* Constants required to check the validity of an interrupt priority. */
+#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
+#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
+#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
+#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
+#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
+#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
+#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
+#define portPRIGROUP_SHIFT					( 8UL )
+
+/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
+#define portVECTACTIVE_MASK					( 0xFFUL )
+
+/* Constants required to manipulate the VFP. */
+#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
+#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
+
+/* Constants required to set up the initial stack. */
+#define portINITIAL_XPSR					( 0x01000000 )
+#define portINITIAL_EXC_RETURN				( 0xfffffffd )
+
+/* The systick is a 24-bit counter. */
+#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
+
+/* For strict compliance with the Cortex-M spec the task start address should
+have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
+#define portSTART_ADDRESS_MASK		( ( StackType_t ) 0xfffffffeUL )
+
+/* A fiddle factor to estimate the number of SysTick counts that would have
+occurred while the SysTick counter is stopped during tickless idle
+calculations. */
+#define portMISSED_COUNTS_FACTOR			( 45UL )
+
+/* Let the user override the pre-loading of the initial LR with the address of
+prvTaskExitError() in case it messes up unwinding of the stack in the
+debugger. */
+#ifdef configTASK_RETURN_ADDRESS
+	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
+#else
+	#define portTASK_RETURN_ADDRESS	prvTaskExitError
+#endif
+
+/*
+ * Setup the timer to generate the tick interrupts.  The implementation in this
+ * file is weak to allow application writers to change the timer used to
+ * generate the tick interrupt.
+ */
+void vPortSetupTimerInterrupt( void );
+
+/*
+ * Exception handlers.
+ */
+void xPortPendSVHandler( void ) __attribute__ (( naked ));
+void xPortSysTickHandler( void );
+void vPortSVCHandler( void ) __attribute__ (( naked ));
+
+/*
+ * Start first task is a separate function so it can be tested in isolation.
+ */
+static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
+
+/*
+ * Function to enable the VFP.
+ */
+static void vPortEnableVFP( void ) __attribute__ (( naked ));
+
+/*
+ * Used to catch tasks that attempt to return from their implementing function.
+ */
+static void prvTaskExitError( void );
+
+/*-----------------------------------------------------------*/
+
+/* Each task maintains its own interrupt status in the critical nesting
+variable. */
+static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
+
+/*
+ * The number of SysTick increments that make up one tick period.
+ */
+#if( configUSE_TICKLESS_IDLE == 1 )
+	static uint32_t ulTimerCountsForOneTick = 0;
+#endif /* configUSE_TICKLESS_IDLE */
+
+/*
+ * The maximum number of tick periods that can be suppressed is limited by the
+ * 24 bit resolution of the SysTick timer.
+ */
+#if( configUSE_TICKLESS_IDLE == 1 )
+	static uint32_t xMaximumPossibleSuppressedTicks = 0;
+#endif /* configUSE_TICKLESS_IDLE */
+
+/*
+ * Compensate for the CPU cycles that pass while the SysTick is stopped (low
+ * power functionality only.
+ */
+#if( configUSE_TICKLESS_IDLE == 1 )
+	static uint32_t ulStoppedTimerCompensation = 0;
+#endif /* configUSE_TICKLESS_IDLE */
+
+/*
+ * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
+ * FreeRTOS API functions are not called from interrupts that have been assigned
+ * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
+ */
+#if( configASSERT_DEFINED == 1 )
+	 static uint8_t ucMaxSysCallPriority = 0;
+	 static uint32_t ulMaxPRIGROUPValue = 0;
+	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
+#endif /* configASSERT_DEFINED */
+
+/*-----------------------------------------------------------*/
+
+/*
+ * See header file for description.
+ */
+StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
+{
+	/* Simulate the stack frame as it would be created by a context switch
+	interrupt. */
+
+	/* Offset added to account for the way the MCU uses the stack on entry/exit
+	of interrupts, and to ensure alignment. */
+	pxTopOfStack--;
+
+	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
+	pxTopOfStack--;
+	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
+	pxTopOfStack--;
+	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
+
+	/* Save code space by skipping register initialisation. */
+	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
+	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
+
+	/* A save method is being used that requires each task to maintain its
+	own exec return value. */
+	pxTopOfStack--;
+	*pxTopOfStack = portINITIAL_EXC_RETURN;
+
+	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
+
+	return pxTopOfStack;
+}
+/*-----------------------------------------------------------*/
+
+static void prvTaskExitError( void )
+{
+volatile uint32_t ulDummy = 0;
+
+	/* A function that implements a task must not exit or attempt to return to
+	its caller as there is nothing to return to.  If a task wants to exit it
+	should instead call vTaskDelete( NULL ).
+
+	Artificially force an assert() to be triggered if configASSERT() is
+	defined, then stop here so application writers can catch the error. */
+	configASSERT( uxCriticalNesting == ~0UL );
+	portDISABLE_INTERRUPTS();
+	while( ulDummy == 0 )
+	{
+		/* This file calls prvTaskExitError() after the scheduler has been
+		started to remove a compiler warning about the function being defined
+		but never called.  ulDummy is used purely to quieten other warnings
+		about code appearing after this function is called - making ulDummy
+		volatile makes the compiler think the function could return and
+		therefore not output an 'unreachable code' warning for code that appears
+		after it. */
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vPortSVCHandler( void )
+{
+	__asm volatile (
+					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
+					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
+					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
+					"	ldmia r0!, {r4-r11, r14}		\n" /* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
+					"	msr psp, r0						\n" /* Restore the task stack pointer. */
+					"	isb								\n"
+					"	mov r0, #0 						\n"
+					"	msr	basepri, r0					\n"
+					"	bx r14							\n"
+					"									\n"
+					"	.align 4						\n"
+					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
+				);
+}
+/*-----------------------------------------------------------*/
+
+static void prvPortStartFirstTask( void )
+{
+	/* Start the first task.  This also clears the bit that indicates the FPU is
+	in use in case the FPU was used before the scheduler was started - which
+	would otherwise result in the unnecessary leaving of space in the SVC stack
+	for lazy saving of FPU registers. */
+	__asm volatile(
+					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
+					" ldr r0, [r0] 			\n"
+					" ldr r0, [r0] 			\n"
+					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
+					" mov r0, #0			\n" /* Clear the bit that indicates the FPU is in use, see comment above. */
+					" msr control, r0		\n"
+					" cpsie i				\n" /* Globally enable interrupts. */
+					" cpsie f				\n"
+					" dsb					\n"
+					" isb					\n"
+					" svc 0					\n" /* System call to start first task. */
+					" nop					\n"
+				);
+}
+/*-----------------------------------------------------------*/
+
+/*
+ * See header file for description.
+ */
+BaseType_t xPortStartScheduler( void )
+{
+	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
+	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
+	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
+
+	/* This port can be used on all revisions of the Cortex-M7 core other than
+	the r0p1 parts.  r0p1 parts should use the port from the
+	/source/portable/GCC/ARM_CM7/r0p1 directory. */
+	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
+	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
+
+	#if( configASSERT_DEFINED == 1 )
+	{
+		volatile uint32_t ulOriginalPriority;
+		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
+		volatile uint8_t ucMaxPriorityValue;
+
+		/* Determine the maximum priority from which ISR safe FreeRTOS API
+		functions can be called.  ISR safe functions are those that end in
+		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
+		ensure interrupt entry is as fast and simple as possible.
+
+		Save the interrupt priority value that is about to be clobbered. */
+		ulOriginalPriority = *pucFirstUserPriorityRegister;
+
+		/* Determine the number of priority bits available.  First write to all
+		possible bits. */
+		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
+
+		/* Read the value back to see how many bits stuck. */
+		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
+
+		/* Use the same mask on the maximum system call priority. */
+		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
+
+		/* Calculate the maximum acceptable priority group value for the number
+		of bits read back. */
+		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
+		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
+		{
+			ulMaxPRIGROUPValue--;
+			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
+		}
+
+		#ifdef __NVIC_PRIO_BITS
+		{
+			/* Check the CMSIS configuration that defines the number of
+			priority bits matches the number of priority bits actually queried
+			from the hardware. */
+			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
+		}
+		#endif
+
+		#ifdef configPRIO_BITS
+		{
+			/* Check the FreeRTOS configuration that defines the number of
+			priority bits matches the number of priority bits actually queried
+			from the hardware. */
+			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
+		}
+		#endif
+
+		/* Shift the priority group value back to its position within the AIRCR
+		register. */
+		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
+		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
+
+		/* Restore the clobbered interrupt priority register to its original
+		value. */
+		*pucFirstUserPriorityRegister = ulOriginalPriority;
+	}
+	#endif /* conifgASSERT_DEFINED */
+
+	/* Make PendSV and SysTick the lowest priority interrupts. */
+	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
+	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
+
+	/* Start the timer that generates the tick ISR.  Interrupts are disabled
+	here already. */
+	vPortSetupTimerInterrupt();
+
+	/* Initialise the critical nesting count ready for the first task. */
+	uxCriticalNesting = 0;
+
+	/* Ensure the VFP is enabled - it should be anyway. */
+	vPortEnableVFP();
+
+	/* Lazy save always. */
+	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
+
+	/* Start the first task. */
+	prvPortStartFirstTask();
+
+	/* Should never get here as the tasks will now be executing!  Call the task
+	exit error function to prevent compiler warnings about a static function
+	not being called in the case that the application writer overrides this
+	functionality by defining configTASK_RETURN_ADDRESS.  Call
+	vTaskSwitchContext() so link time optimisation does not remove the
+	symbol. */
+	vTaskSwitchContext();
+	prvTaskExitError();
+
+	/* Should not get here! */
+	return 0;
+}
+/*-----------------------------------------------------------*/
+
+void vPortEndScheduler( void )
+{
+	/* Not implemented in ports where there is nothing to return to.
+	Artificially force an assert. */
+	configASSERT( uxCriticalNesting == 1000UL );
+}
+/*-----------------------------------------------------------*/
+
+void vPortEnterCritical( void )
+{
+	portDISABLE_INTERRUPTS();
+	uxCriticalNesting++;
+
+	/* This is not the interrupt safe version of the enter critical function so
+	assert() if it is being called from an interrupt context.  Only API
+	functions that end in "FromISR" can be used in an interrupt.  Only assert if
+	the critical nesting count is 1 to protect against recursive calls if the
+	assert function also uses a critical section. */
+	if( uxCriticalNesting == 1 )
+	{
+		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vPortExitCritical( void )
+{
+	configASSERT( uxCriticalNesting );
+	uxCriticalNesting--;
+	if( uxCriticalNesting == 0 )
+	{
+		portENABLE_INTERRUPTS();
+	}
+}
+/*-----------------------------------------------------------*/
+
+void xPortPendSVHandler( void )
+{
+	/* This is a naked function. */
+
+	__asm volatile
+	(
+	"	mrs r0, psp							\n"
+	"	isb									\n"
+	"										\n"
+	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
+	"	ldr	r2, [r3]						\n"
+	"										\n"
+	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. */
+	"	it eq								\n"
+	"	vstmdbeq r0!, {s16-s31}				\n"
+	"										\n"
+	"	stmdb r0!, {r4-r11, r14}			\n" /* Save the core registers. */
+	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
+	"										\n"
+	"	stmdb sp!, {r0, r3}					\n"
+	"	mov r0, %0 							\n"
+	"	msr basepri, r0						\n"
+	"	dsb									\n"
+	"	isb									\n"
+	"	bl vTaskSwitchContext				\n"
+	"	mov r0, #0							\n"
+	"	msr basepri, r0						\n"
+	"	ldmia sp!, {r0, r3}					\n"
+	"										\n"
+	"	ldr r1, [r3]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
+	"	ldr r0, [r1]						\n"
+	"										\n"
+	"	ldmia r0!, {r4-r11, r14}			\n" /* Pop the core registers. */
+	"										\n"
+	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
+	"	it eq								\n"
+	"	vldmiaeq r0!, {s16-s31}				\n"
+	"										\n"
+	"	msr psp, r0							\n"
+	"	isb									\n"
+	"										\n"
+	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
+		#if WORKAROUND_PMU_CM001 == 1
+	"			push { r14 }				\n"
+	"			pop { pc }					\n"
+		#endif
+	#endif
+	"										\n"
+	"	bx r14								\n"
+	"										\n"
+	"	.align 4							\n"
+	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
+	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
+	);
+}
+/*-----------------------------------------------------------*/
+
+void xPortSysTickHandler( void )
+{
+	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
+	executes all interrupts must be unmasked.  There is therefore no need to
+	save and then restore the interrupt mask value as its value is already
+	known. */
+	portDISABLE_INTERRUPTS();
+	{
+		/* Increment the RTOS tick. */
+		if( xTaskIncrementTick() != pdFALSE )
+		{
+			/* A context switch is required.  Context switching is performed in
+			the PendSV interrupt.  Pend the PendSV interrupt. */
+			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
+		}
+	}
+	portENABLE_INTERRUPTS();
+}
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TICKLESS_IDLE == 1 )
+
+	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
+	{
+	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
+	TickType_t xModifiableIdleTime;
+
+		/* Make sure the SysTick reload value does not overflow the counter. */
+		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
+		{
+			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
+		}
+
+		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
+		is accounted for as best it can be, but using the tickless mode will
+		inevitably result in some tiny drift of the time maintained by the
+		kernel with respect to calendar time. */
+		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
+
+		/* Calculate the reload value required to wait xExpectedIdleTime
+		tick periods.  -1 is used because this code will execute part way
+		through one of the tick periods. */
+		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
+		if( ulReloadValue > ulStoppedTimerCompensation )
+		{
+			ulReloadValue -= ulStoppedTimerCompensation;
+		}
+
+		/* Enter a critical section but don't use the taskENTER_CRITICAL()
+		method as that will mask interrupts that should exit sleep mode. */
+		__asm volatile( "cpsid i" ::: "memory" );
+		__asm volatile( "dsb" );
+		__asm volatile( "isb" );
+
+		/* If a context switch is pending or a task is waiting for the scheduler
+		to be unsuspended then abandon the low power entry. */
+		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
+		{
+			/* Restart from whatever is left in the count register to complete
+			this tick period. */
+			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
+
+			/* Restart SysTick. */
+			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
+
+			/* Reset the reload register to the value required for normal tick
+			periods. */
+			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
+
+			/* Re-enable interrupts - see comments above the cpsid instruction()
+			above. */
+			__asm volatile( "cpsie i" ::: "memory" );
+		}
+		else
+		{
+			/* Set the new reload value. */
+			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
+
+			/* Clear the SysTick count flag and set the count value back to
+			zero. */
+			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
+
+			/* Restart SysTick. */
+			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
+
+			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
+			set its parameter to 0 to indicate that its implementation contains
+			its own wait for interrupt or wait for event instruction, and so wfi
+			should not be executed again.  However, the original expected idle
+			time variable must remain unmodified, so a copy is taken. */
+			xModifiableIdleTime = xExpectedIdleTime;
+			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
+			if( xModifiableIdleTime > 0 )
+			{
+				__asm volatile( "dsb" ::: "memory" );
+				__asm volatile( "wfi" );
+				__asm volatile( "isb" );
+			}
+			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
+
+			/* Re-enable interrupts to allow the interrupt that brought the MCU
+			out of sleep mode to execute immediately.  see comments above
+			__disable_interrupt() call above. */
+			__asm volatile( "cpsie i" ::: "memory" );
+			__asm volatile( "dsb" );
+			__asm volatile( "isb" );
+
+			/* Disable interrupts again because the clock is about to be stopped
+			and interrupts that execute while the clock is stopped will increase
+			any slippage between the time maintained by the RTOS and calendar
+			time. */
+			__asm volatile( "cpsid i" ::: "memory" );
+			__asm volatile( "dsb" );
+			__asm volatile( "isb" );
+
+			/* Disable the SysTick clock without reading the
+			portNVIC_SYSTICK_CTRL_REG register to ensure the
+			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
+			the time the SysTick is stopped for is accounted for as best it can
+			be, but using the tickless mode will inevitably result in some tiny
+			drift of the time maintained by the kernel with respect to calendar
+			time*/
+			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
+
+			/* Determine if the SysTick clock has already counted to zero and
+			been set back to the current reload value (the reload back being
+			correct for the entire expected idle time) or if the SysTick is yet
+			to count to zero (in which case an interrupt other than the SysTick
+			must have brought the system out of sleep mode). */
+			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
+			{
+				uint32_t ulCalculatedLoadValue;
+
+				/* The tick interrupt is already pending, and the SysTick count
+				reloaded with ulReloadValue.  Reset the
+				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
+				period. */
+				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
+
+				/* Don't allow a tiny value, or values that have somehow
+				underflowed because the post sleep hook did something
+				that took too long. */
+				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
+				{
+					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
+				}
+
+				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
+
+				/* As the pending tick will be processed as soon as this
+				function exits, the tick value maintained by the tick is stepped
+				forward by one less than the time spent waiting. */
+				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
+			}
+			else
+			{
+				/* Something other than the tick interrupt ended the sleep.
+				Work out how long the sleep lasted rounded to complete tick
+				periods (not the ulReload value which accounted for part
+				ticks). */
+				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
+
+				/* How many complete tick periods passed while the processor
+				was waiting? */
+				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
+
+				/* The reload value is set to whatever fraction of a single tick
+				period remains. */
+				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
+			}
+
+			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
+			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
+			value. */
+			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
+			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
+			vTaskStepTick( ulCompleteTickPeriods );
+			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
+
+			/* Exit with interrpts enabled. */
+			__asm volatile( "cpsie i" ::: "memory" );
+		}
+	}
+
+#endif /* #if configUSE_TICKLESS_IDLE */
+/*-----------------------------------------------------------*/
+
+/*
+ * Setup the systick timer to generate the tick interrupts at the required
+ * frequency.
+ */
+__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
+{
+	/* Calculate the constants required to configure the tick interrupt. */
+	#if( configUSE_TICKLESS_IDLE == 1 )
+	{
+		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
+		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
+		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
+	}
+	#endif /* configUSE_TICKLESS_IDLE */
+
+	/* Stop and clear the SysTick. */
+	portNVIC_SYSTICK_CTRL_REG = 0UL;
+	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
+
+	/* Configure SysTick to interrupt at the requested rate. */
+	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
+	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
+}
+/*-----------------------------------------------------------*/
+
+/* This is a naked function. */
+static void vPortEnableVFP( void )
+{
+	__asm volatile
+	(
+		"	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
+		"	ldr r1, [r0]				\n"
+		"								\n"
+		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
+		"	str r1, [r0]				\n"
+		"	bx r14						"
+	);
+}
+/*-----------------------------------------------------------*/
+
+#if( configASSERT_DEFINED == 1 )
+
+	void vPortValidateInterruptPriority( void )
+	{
+	uint32_t ulCurrentInterrupt;
+	uint8_t ucCurrentPriority;
+
+		/* Obtain the number of the currently executing interrupt. */
+		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
+
+		/* Is the interrupt number a user defined interrupt? */
+		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
+		{
+			/* Look up the interrupt's priority. */
+			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
+
+			/* The following assertion will fail if a service routine (ISR) for
+			an interrupt that has been assigned a priority above
+			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
+			function.  ISR safe FreeRTOS API functions must *only* be called
+			from interrupts that have been assigned a priority at or below
+			configMAX_SYSCALL_INTERRUPT_PRIORITY.
+
+			Numerically low interrupt priority numbers represent logically high
+			interrupt priorities, therefore the priority of the interrupt must
+			be set to a value equal to or numerically *higher* than
+			configMAX_SYSCALL_INTERRUPT_PRIORITY.
+
+			Interrupts that	use the FreeRTOS API must not be left at their
+			default priority of	zero as that is the highest possible priority,
+			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
+			and	therefore also guaranteed to be invalid.
+
+			FreeRTOS maintains separate thread and ISR API functions to ensure
+			interrupt entry is as fast and simple as possible.
+
+			The following links provide detailed information:
+			http://www.freertos.org/RTOS-Cortex-M3-M4.html
+			http://www.freertos.org/FAQHelp.html */
+			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
+		}
+
+		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
+		that define each interrupt's priority to be split between bits that
+		define the interrupt's pre-emption priority bits and bits that define
+		the interrupt's sub-priority.  For simplicity all bits must be defined
+		to be pre-emption priority bits.  The following assertion will fail if
+		this is not the case (if some bits represent a sub-priority).
+
+		If the application only uses CMSIS libraries for interrupt
+		configuration then the correct setting can be achieved on all Cortex-M
+		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
+		scheduler.  Note however that some vendor specific peripheral libraries
+		assume a non-zero priority group setting, in which cases using a value
+		of zero will result in unpredictable behaviour. */
+		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
+	}
+
+#endif /* configASSERT_DEFINED */
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/portable/ARM_CM4F/portmacro.h ./libs/freertos/source/portable/ARM_CM4F/portmacro.h
--- a_bRU7kv/libs/freertos/source/portable/ARM_CM4F/portmacro.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/portable/ARM_CM4F/portmacro.h	2018-12-01 17:15:06.605605990 -0300
@@ -0,0 +1,242 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#ifndef PORTMACRO_H
+#define PORTMACRO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-----------------------------------------------------------
+ * Port specific definitions.
+ *
+ * The settings in this file configure FreeRTOS correctly for the
+ * given hardware and compiler.
+ *
+ * These settings should not be altered.
+ *-----------------------------------------------------------
+ */
+
+/* Type definitions. */
+#define portCHAR		char
+#define portFLOAT		float
+#define portDOUBLE		double
+#define portLONG		long
+#define portSHORT		short
+#define portSTACK_TYPE	uint32_t
+#define portBASE_TYPE	long
+
+typedef portSTACK_TYPE StackType_t;
+typedef long BaseType_t;
+typedef unsigned long UBaseType_t;
+
+#if( configUSE_16_BIT_TICKS == 1 )
+	typedef uint16_t TickType_t;
+	#define portMAX_DELAY ( TickType_t ) 0xffff
+#else
+	typedef uint32_t TickType_t;
+	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
+
+	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
+	not need to be guarded with a critical section. */
+	#define portTICK_TYPE_IS_ATOMIC 1
+#endif
+/*-----------------------------------------------------------*/
+
+/* Architecture specifics. */
+#define portSTACK_GROWTH			( -1 )
+#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
+#define portBYTE_ALIGNMENT			8
+/*-----------------------------------------------------------*/
+
+/* Scheduler utilities. */
+#define portYIELD() 															\
+{																				\
+	/* Set a PendSV to request a context switch. */								\
+	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
+																				\
+	/* Barriers are normally not required but do ensure the code is completely	\
+	within the specified behaviour for the architecture. */						\
+	__asm volatile( "dsb" ::: "memory" );										\
+	__asm volatile( "isb" );													\
+}
+
+#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
+#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
+#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
+#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
+/*-----------------------------------------------------------*/
+
+/* Critical section management. */
+extern void vPortEnterCritical( void );
+extern void vPortExitCritical( void );
+#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
+#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
+#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
+#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
+#define portENTER_CRITICAL()					vPortEnterCritical()
+#define portEXIT_CRITICAL()						vPortExitCritical()
+
+/*-----------------------------------------------------------*/
+
+/* Task function macros as described on the FreeRTOS.org WEB site.  These are
+not necessary for to use this port.  They are defined so the common demo files
+(which build with all the ports) will build. */
+#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
+#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
+/*-----------------------------------------------------------*/
+
+/* Tickless idle/low power functionality. */
+#ifndef portSUPPRESS_TICKS_AND_SLEEP
+	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
+	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
+#endif
+/*-----------------------------------------------------------*/
+
+/* Architecture specific optimisations. */
+#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
+	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
+#endif
+
+#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
+
+	/* Generic helper function. */
+	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
+	{
+	uint8_t ucReturn;
+
+		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
+		return ucReturn;
+	}
+
+	/* Check the configuration. */
+	#if( configMAX_PRIORITIES > 32 )
+		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
+	#endif
+
+	/* Store/clear the ready priorities in a bit map. */
+	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
+	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
+
+	/*-----------------------------------------------------------*/
+
+	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
+
+#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
+
+/*-----------------------------------------------------------*/
+
+#ifdef configASSERT
+	void vPortValidateInterruptPriority( void );
+	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
+#endif
+
+/* portNOP() is not required by this port. */
+#define portNOP()
+
+#define portINLINE	__inline
+
+#ifndef portFORCE_INLINE
+	#define portFORCE_INLINE inline __attribute__(( always_inline))
+#endif
+
+portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
+{
+uint32_t ulCurrentInterrupt;
+BaseType_t xReturn;
+
+	/* Obtain the number of the currently executing interrupt. */
+	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
+
+	if( ulCurrentInterrupt == 0 )
+	{
+		xReturn = pdFALSE;
+	}
+	else
+	{
+		xReturn = pdTRUE;
+	}
+
+	return xReturn;
+}
+
+/*-----------------------------------------------------------*/
+
+portFORCE_INLINE static void vPortRaiseBASEPRI( void )
+{
+uint32_t ulNewBASEPRI;
+
+	__asm volatile
+	(
+		"	mov %0, %1												\n"	\
+		"	msr basepri, %0											\n" \
+		"	isb														\n" \
+		"	dsb														\n" \
+		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
+	);
+}
+
+/*-----------------------------------------------------------*/
+
+portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
+{
+uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
+
+	__asm volatile
+	(
+		"	mrs %0, basepri											\n" \
+		"	mov %1, %2												\n"	\
+		"	msr basepri, %1											\n" \
+		"	isb														\n" \
+		"	dsb														\n" \
+		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
+	);
+
+	/* This return will not be reached but is necessary to prevent compiler
+	warnings. */
+	return ulOriginalBASEPRI;
+}
+/*-----------------------------------------------------------*/
+
+portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
+{
+	__asm volatile
+	(
+		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
+	);
+}
+/*-----------------------------------------------------------*/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PORTMACRO_H */
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/queue.c ./libs/freertos/source/queue.c
--- a_bRU7kv/libs/freertos/source/queue.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/queue.c	2018-12-01 17:15:06.605605990 -0300
@@ -0,0 +1,2909 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include "queue.h"
+
+#if ( configUSE_CO_ROUTINES == 1 )
+	#include "croutine.h"
+#endif
+
+/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
+MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
+header files above, but not in this file, in order to generate the correct
+privileged Vs unprivileged linkage and placement. */
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
+
+
+/* Constants used with the cRxLock and cTxLock structure members. */
+#define queueUNLOCKED					( ( int8_t ) -1 )
+#define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
+
+/* When the Queue_t structure is used to represent a base queue its pcHead and
+pcTail members are used as pointers into the queue storage area.  When the
+Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
+not necessary, and the pcHead pointer is set to NULL to indicate that the
+pcTail pointer actually points to the mutex holder (if any).  Map alternative
+names to the pcHead and pcTail structure members to ensure the readability of
+the code is maintained despite this dual use of two structure members.  An
+alternative implementation would be to use a union, but use of a union is
+against the coding standard (although an exception to the standard has been
+permitted where the dual use also significantly changes the type of the
+structure member). */
+#define pxMutexHolder					pcTail
+#define uxQueueType						pcHead
+#define queueQUEUE_IS_MUTEX				NULL
+
+/* Semaphores do not actually store or copy data, so have an item size of
+zero. */
+#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
+#define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
+
+#if( configUSE_PREEMPTION == 0 )
+	/* If the cooperative scheduler is being used then a yield should not be
+	performed just because a higher priority task has been woken. */
+	#define queueYIELD_IF_USING_PREEMPTION()
+#else
+	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
+#endif
+
+/*
+ * Definition of the queue used by the scheduler.
+ * Items are queued by copy, not reference.  See the following link for the
+ * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
+ */
+typedef struct QueueDefinition
+{
+	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
+	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
+	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
+
+	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
+	{
+		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
+		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
+	} u;
+
+	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
+	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
+
+	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
+	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
+	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
+
+	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
+	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
+	#endif
+
+	#if ( configUSE_QUEUE_SETS == 1 )
+		struct QueueDefinition *pxQueueSetContainer;
+	#endif
+
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxQueueNumber;
+		uint8_t ucQueueType;
+	#endif
+
+} xQUEUE;
+
+/* The old xQUEUE name is maintained above then typedefed to the new Queue_t
+name below to enable the use of older kernel aware debuggers. */
+typedef xQUEUE Queue_t;
+
+/*-----------------------------------------------------------*/
+
+/*
+ * The queue registry is just a means for kernel aware debuggers to locate
+ * queue structures.  It has no other purpose so is an optional component.
+ */
+#if ( configQUEUE_REGISTRY_SIZE > 0 )
+
+	/* The type stored within the queue registry array.  This allows a name
+	to be assigned to each queue making kernel aware debugging a little
+	more user friendly. */
+	typedef struct QUEUE_REGISTRY_ITEM
+	{
+		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+		QueueHandle_t xHandle;
+	} xQueueRegistryItem;
+
+	/* The old xQueueRegistryItem name is maintained above then typedefed to the
+	new xQueueRegistryItem name below to enable the use of older kernel aware
+	debuggers. */
+	typedef xQueueRegistryItem QueueRegistryItem_t;
+
+	/* The queue registry is simply an array of QueueRegistryItem_t structures.
+	The pcQueueName member of a structure being NULL is indicative of the
+	array position being vacant. */
+	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
+
+#endif /* configQUEUE_REGISTRY_SIZE */
+
+/*
+ * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
+ * prevent an ISR from adding or removing items to the queue, but does prevent
+ * an ISR from removing tasks from the queue event lists.  If an ISR finds a
+ * queue is locked it will instead increment the appropriate queue lock count
+ * to indicate that a task may require unblocking.  When the queue in unlocked
+ * these lock counts are inspected, and the appropriate action taken.
+ */
+static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
+
+/*
+ * Uses a critical section to determine if there is any data in a queue.
+ *
+ * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
+ */
+static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
+
+/*
+ * Uses a critical section to determine if there is any space in a queue.
+ *
+ * @return pdTRUE if there is no space, otherwise pdFALSE;
+ */
+static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
+
+/*
+ * Copies an item into the queue, either at the front of the queue or the
+ * back of the queue.
+ */
+static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
+
+/*
+ * Copies an item out of a queue.
+ */
+static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
+
+#if ( configUSE_QUEUE_SETS == 1 )
+	/*
+	 * Checks to see if a queue is a member of a queue set, and if so, notifies
+	 * the queue set that the queue contains data.
+	 */
+	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
+#endif
+
+/*
+ * Called after a Queue_t structure has been allocated either statically or
+ * dynamically to fill in the structure's members.
+ */
+static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
+
+/*
+ * Mutexes are a special type of queue.  When a mutex is created, first the
+ * queue is created, then prvInitialiseMutex() is called to configure the queue
+ * as a mutex.
+ */
+#if( configUSE_MUTEXES == 1 )
+	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
+#endif
+
+#if( configUSE_MUTEXES == 1 )
+	/*
+	 * If a task waiting for a mutex causes the mutex holder to inherit a
+	 * priority, but the waiting task times out, then the holder should
+	 * disinherit the priority - but only down to the highest priority of any
+	 * other tasks that are waiting for the same mutex.  This function returns
+	 * that priority.
+	 */
+	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
+#endif
+/*-----------------------------------------------------------*/
+
+/*
+ * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
+ * accessing the queue event lists.
+ */
+#define prvLockQueue( pxQueue )								\
+	taskENTER_CRITICAL();									\
+	{														\
+		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
+		{													\
+			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
+		}													\
+		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
+		{													\
+			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
+		}													\
+	}														\
+	taskEXIT_CRITICAL()
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
+{
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	configASSERT( pxQueue );
+
+	taskENTER_CRITICAL();
+	{
+		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
+		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
+		pxQueue->pcWriteTo = pxQueue->pcHead;
+		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
+		pxQueue->cRxLock = queueUNLOCKED;
+		pxQueue->cTxLock = queueUNLOCKED;
+
+		if( xNewQueue == pdFALSE )
+		{
+			/* If there are tasks blocked waiting to read from the queue, then
+			the tasks will remain blocked as after this function exits the queue
+			will still be empty.  If there are tasks blocked waiting to write to
+			the queue, then one should be unblocked as after this function exits
+			it will be possible to write to it. */
+			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+			{
+				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+				{
+					queueYIELD_IF_USING_PREEMPTION();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			/* Ensure the event queues start in the correct state. */
+			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
+			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
+		}
+	}
+	taskEXIT_CRITICAL();
+
+	/* A value is returned for calling semantic consistency with previous
+	versions. */
+	return pdPASS;
+}
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
+	{
+	Queue_t *pxNewQueue;
+
+		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
+
+		/* The StaticQueue_t structure and the queue storage area must be
+		supplied. */
+		configASSERT( pxStaticQueue != NULL );
+
+		/* A queue storage area should be provided if the item size is not 0, and
+		should not be provided if the item size is 0. */
+		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
+		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
+
+		#if( configASSERT_DEFINED == 1 )
+		{
+			/* Sanity check that the size of the structure used to declare a
+			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
+			the real queue and semaphore structures. */
+			volatile size_t xSize = sizeof( StaticQueue_t );
+			configASSERT( xSize == sizeof( Queue_t ) );
+		}
+		#endif /* configASSERT_DEFINED */
+
+		/* The address of a statically allocated queue was passed in, use it.
+		The address of a statically allocated storage area was also passed in
+		but is already set. */
+		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
+
+		if( pxNewQueue != NULL )
+		{
+			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+			{
+				/* Queues can be allocated wither statically or dynamically, so
+				note this queue was allocated statically in case the queue is
+				later deleted. */
+				pxNewQueue->ucStaticallyAllocated = pdTRUE;
+			}
+			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+
+			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
+		}
+		else
+		{
+			traceQUEUE_CREATE_FAILED( ucQueueType );
+		}
+
+		return pxNewQueue;
+	}
+
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+
+	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
+	{
+	Queue_t *pxNewQueue;
+	size_t xQueueSizeInBytes;
+	uint8_t *pucQueueStorage;
+
+		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
+
+		if( uxItemSize == ( UBaseType_t ) 0 )
+		{
+			/* There is not going to be a queue storage area. */
+			xQueueSizeInBytes = ( size_t ) 0;
+		}
+		else
+		{
+			/* Allocate enough space to hold the maximum number of items that
+			can be in the queue at any time. */
+			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+		}
+
+		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
+
+		if( pxNewQueue != NULL )
+		{
+			/* Jump past the queue structure to find the location of the queue
+			storage area. */
+			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
+
+			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+			{
+				/* Queues can be created either statically or dynamically, so
+				note this task was created dynamically in case it is later
+				deleted. */
+				pxNewQueue->ucStaticallyAllocated = pdFALSE;
+			}
+			#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
+		}
+		else
+		{
+			traceQUEUE_CREATE_FAILED( ucQueueType );
+		}
+
+		return pxNewQueue;
+	}
+
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
+{
+	/* Remove compiler warnings about unused parameters should
+	configUSE_TRACE_FACILITY not be set to 1. */
+	( void ) ucQueueType;
+
+	if( uxItemSize == ( UBaseType_t ) 0 )
+	{
+		/* No RAM was allocated for the queue storage area, but PC head cannot
+		be set to NULL because NULL is used as a key to say the queue is used as
+		a mutex.  Therefore just set pcHead to point to the queue as a benign
+		value that is known to be within the memory map. */
+		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
+	}
+	else
+	{
+		/* Set the head to the start of the queue storage area. */
+		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
+	}
+
+	/* Initialise the queue members as described where the queue type is
+	defined. */
+	pxNewQueue->uxLength = uxQueueLength;
+	pxNewQueue->uxItemSize = uxItemSize;
+	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
+
+	#if ( configUSE_TRACE_FACILITY == 1 )
+	{
+		pxNewQueue->ucQueueType = ucQueueType;
+	}
+	#endif /* configUSE_TRACE_FACILITY */
+
+	#if( configUSE_QUEUE_SETS == 1 )
+	{
+		pxNewQueue->pxQueueSetContainer = NULL;
+	}
+	#endif /* configUSE_QUEUE_SETS */
+
+	traceQUEUE_CREATE( pxNewQueue );
+}
+/*-----------------------------------------------------------*/
+
+#if( configUSE_MUTEXES == 1 )
+
+	static void prvInitialiseMutex( Queue_t *pxNewQueue )
+	{
+		if( pxNewQueue != NULL )
+		{
+			/* The queue create function will set all the queue structure members
+			correctly for a generic queue, but this function is creating a
+			mutex.  Overwrite those members that need to be set differently -
+			in particular the information required for priority inheritance. */
+			pxNewQueue->pxMutexHolder = NULL;
+			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
+
+			/* In case this is a recursive mutex. */
+			pxNewQueue->u.uxRecursiveCallCount = 0;
+
+			traceCREATE_MUTEX( pxNewQueue );
+
+			/* Start with the semaphore in the expected state. */
+			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
+		}
+		else
+		{
+			traceCREATE_MUTEX_FAILED();
+		}
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+
+	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
+	{
+	Queue_t *pxNewQueue;
+	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
+
+		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
+		prvInitialiseMutex( pxNewQueue );
+
+		return pxNewQueue;
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+
+	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
+	{
+	Queue_t *pxNewQueue;
+	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
+
+		/* Prevent compiler warnings about unused parameters if
+		configUSE_TRACE_FACILITY does not equal 1. */
+		( void ) ucQueueType;
+
+		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
+		prvInitialiseMutex( pxNewQueue );
+
+		return pxNewQueue;
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
+
+	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
+	{
+	void *pxReturn;
+
+		/* This function is called by xSemaphoreGetMutexHolder(), and should not
+		be called directly.  Note:  This is a good way of determining if the
+		calling task is the mutex holder, but not a good way of determining the
+		identity of the mutex holder, as the holder may change between the
+		following critical section exiting and the function returning. */
+		taskENTER_CRITICAL();
+		{
+			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
+			{
+				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
+			}
+			else
+			{
+				pxReturn = NULL;
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		return pxReturn;
+	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
+
+#endif
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
+
+	void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
+	{
+	void *pxReturn;
+
+		configASSERT( xSemaphore );
+
+		/* Mutexes cannot be used in interrupt service routines, so the mutex
+		holder should not change in an ISR, and therefore a critical section is
+		not required here. */
+		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
+		{
+			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
+		}
+		else
+		{
+			pxReturn = NULL;
+		}
+
+		return pxReturn;
+	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
+
+#endif
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_RECURSIVE_MUTEXES == 1 )
+
+	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
+	{
+	BaseType_t xReturn;
+	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
+
+		configASSERT( pxMutex );
+
+		/* If this is the task that holds the mutex then pxMutexHolder will not
+		change outside of this task.  If this task does not hold the mutex then
+		pxMutexHolder can never coincidentally equal the tasks handle, and as
+		this is the only condition we are interested in it does not matter if
+		pxMutexHolder is accessed simultaneously by another task.  Therefore no
+		mutual exclusion is required to test the pxMutexHolder variable. */
+		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
+		{
+			traceGIVE_MUTEX_RECURSIVE( pxMutex );
+
+			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
+			the task handle, therefore no underflow check is required.  Also,
+			uxRecursiveCallCount is only modified by the mutex holder, and as
+			there can only be one, no mutual exclusion is required to modify the
+			uxRecursiveCallCount member. */
+			( pxMutex->u.uxRecursiveCallCount )--;
+
+			/* Has the recursive call count unwound to 0? */
+			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
+			{
+				/* Return the mutex.  This will automatically unblock any other
+				task that might be waiting to access the mutex. */
+				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			xReturn = pdPASS;
+		}
+		else
+		{
+			/* The mutex cannot be given because the calling task is not the
+			holder. */
+			xReturn = pdFAIL;
+
+			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_RECURSIVE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_RECURSIVE_MUTEXES == 1 )
+
+	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
+	{
+	BaseType_t xReturn;
+	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
+
+		configASSERT( pxMutex );
+
+		/* Comments regarding mutual exclusion as per those within
+		xQueueGiveMutexRecursive(). */
+
+		traceTAKE_MUTEX_RECURSIVE( pxMutex );
+
+		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
+		{
+			( pxMutex->u.uxRecursiveCallCount )++;
+			xReturn = pdPASS;
+		}
+		else
+		{
+			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
+
+			/* pdPASS will only be returned if the mutex was successfully
+			obtained.  The calling task may have entered the Blocked state
+			before reaching here. */
+			if( xReturn != pdFAIL )
+			{
+				( pxMutex->u.uxRecursiveCallCount )++;
+			}
+			else
+			{
+				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
+			}
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_RECURSIVE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+
+	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
+	{
+	QueueHandle_t xHandle;
+
+		configASSERT( uxMaxCount != 0 );
+		configASSERT( uxInitialCount <= uxMaxCount );
+
+		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
+
+		if( xHandle != NULL )
+		{
+			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
+
+			traceCREATE_COUNTING_SEMAPHORE();
+		}
+		else
+		{
+			traceCREATE_COUNTING_SEMAPHORE_FAILED();
+		}
+
+		return xHandle;
+	}
+
+#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+
+	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
+	{
+	QueueHandle_t xHandle;
+
+		configASSERT( uxMaxCount != 0 );
+		configASSERT( uxInitialCount <= uxMaxCount );
+
+		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
+
+		if( xHandle != NULL )
+		{
+			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
+
+			traceCREATE_COUNTING_SEMAPHORE();
+		}
+		else
+		{
+			traceCREATE_COUNTING_SEMAPHORE_FAILED();
+		}
+
+		return xHandle;
+	}
+
+#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
+{
+BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
+TimeOut_t xTimeOut;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	configASSERT( pxQueue );
+	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
+	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
+	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+	{
+		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
+	}
+	#endif
+
+
+	/* This function relaxes the coding standard somewhat to allow return
+	statements within the function itself.  This is done in the interest
+	of execution time efficiency. */
+	for( ;; )
+	{
+		taskENTER_CRITICAL();
+		{
+			/* Is there room on the queue now?  The running task must be the
+			highest priority task wanting to access the queue.  If the head item
+			in the queue is to be overwritten then it does not matter if the
+			queue is full. */
+			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
+			{
+				traceQUEUE_SEND( pxQueue );
+				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
+
+				#if ( configUSE_QUEUE_SETS == 1 )
+				{
+					if( pxQueue->pxQueueSetContainer != NULL )
+					{
+						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
+						{
+							/* The queue is a member of a queue set, and posting
+							to the queue set caused a higher priority task to
+							unblock. A context switch is required. */
+							queueYIELD_IF_USING_PREEMPTION();
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						/* If there was a task waiting for data to arrive on the
+						queue then unblock it now. */
+						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+						{
+							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+							{
+								/* The unblocked task has a priority higher than
+								our own so yield immediately.  Yes it is ok to
+								do this from within the critical section - the
+								kernel takes care of that. */
+								queueYIELD_IF_USING_PREEMPTION();
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else if( xYieldRequired != pdFALSE )
+						{
+							/* This path is a special case that will only get
+							executed if the task was holding multiple mutexes
+							and the mutexes were given back in an order that is
+							different to that in which they were taken. */
+							queueYIELD_IF_USING_PREEMPTION();
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+				}
+				#else /* configUSE_QUEUE_SETS */
+				{
+					/* If there was a task waiting for data to arrive on the
+					queue then unblock it now. */
+					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+					{
+						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+						{
+							/* The unblocked task has a priority higher than
+							our own so yield immediately.  Yes it is ok to do
+							this from within the critical section - the kernel
+							takes care of that. */
+							queueYIELD_IF_USING_PREEMPTION();
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else if( xYieldRequired != pdFALSE )
+					{
+						/* This path is a special case that will only get
+						executed if the task was holding multiple mutexes and
+						the mutexes were given back in an order that is
+						different to that in which they were taken. */
+						queueYIELD_IF_USING_PREEMPTION();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				#endif /* configUSE_QUEUE_SETS */
+
+				taskEXIT_CRITICAL();
+				return pdPASS;
+			}
+			else
+			{
+				if( xTicksToWait == ( TickType_t ) 0 )
+				{
+					/* The queue was full and no block time is specified (or
+					the block time has expired) so leave now. */
+					taskEXIT_CRITICAL();
+
+					/* Return to the original privilege level before exiting
+					the function. */
+					traceQUEUE_SEND_FAILED( pxQueue );
+					return errQUEUE_FULL;
+				}
+				else if( xEntryTimeSet == pdFALSE )
+				{
+					/* The queue was full and a block time was specified so
+					configure the timeout structure. */
+					vTaskInternalSetTimeOutState( &xTimeOut );
+					xEntryTimeSet = pdTRUE;
+				}
+				else
+				{
+					/* Entry time was already set. */
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		/* Interrupts and other tasks can send to and receive from the queue
+		now the critical section has been exited. */
+
+		vTaskSuspendAll();
+		prvLockQueue( pxQueue );
+
+		/* Update the timeout state to see if it has expired yet. */
+		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
+		{
+			if( prvIsQueueFull( pxQueue ) != pdFALSE )
+			{
+				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
+				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
+
+				/* Unlocking the queue means queue events can effect the
+				event list.  It is possible that interrupts occurring now
+				remove this task from the event list again - but as the
+				scheduler is suspended the task will go onto the pending
+				ready last instead of the actual ready list. */
+				prvUnlockQueue( pxQueue );
+
+				/* Resuming the scheduler will move tasks from the pending
+				ready list into the ready list - so it is feasible that this
+				task is already in a ready list before it yields - in which
+				case the yield will not cause a context switch unless there
+				is also a higher priority task in the pending ready list. */
+				if( xTaskResumeAll() == pdFALSE )
+				{
+					portYIELD_WITHIN_API();
+				}
+			}
+			else
+			{
+				/* Try again. */
+				prvUnlockQueue( pxQueue );
+				( void ) xTaskResumeAll();
+			}
+		}
+		else
+		{
+			/* The timeout has expired. */
+			prvUnlockQueue( pxQueue );
+			( void ) xTaskResumeAll();
+
+			traceQUEUE_SEND_FAILED( pxQueue );
+			return errQUEUE_FULL;
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
+{
+BaseType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	configASSERT( pxQueue );
+	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
+	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
+
+	/* RTOS ports that support interrupt nesting have the concept of a maximum
+	system call (or maximum API call) interrupt priority.  Interrupts that are
+	above the maximum system call priority are kept permanently enabled, even
+	when the RTOS kernel is in a critical section, but cannot make any calls to
+	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
+	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+	failure if a FreeRTOS API function is called from an interrupt that has been
+	assigned a priority above the configured maximum system call priority.
+	Only FreeRTOS functions that end in FromISR can be called from interrupts
+	that have been assigned a priority at or (logically) below the maximum
+	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
+	safe API to ensure interrupt entry is as fast and as simple as possible.
+	More information (albeit Cortex-M specific) is provided on the following
+	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+	/* Similar to xQueueGenericSend, except without blocking if there is no room
+	in the queue.  Also don't directly wake a task that was blocked on a queue
+	read, instead return a flag to say whether a context switch is required or
+	not (i.e. has a task with a higher priority than us been woken by this
+	post). */
+	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
+		{
+			const int8_t cTxLock = pxQueue->cTxLock;
+
+			traceQUEUE_SEND_FROM_ISR( pxQueue );
+
+			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
+			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
+			in a task disinheriting a priority and prvCopyDataToQueue() can be
+			called here even though the disinherit function does not check if
+			the scheduler is suspended before accessing the ready lists. */
+			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
+
+			/* The event list is not altered if the queue is locked.  This will
+			be done when the queue is unlocked later. */
+			if( cTxLock == queueUNLOCKED )
+			{
+				#if ( configUSE_QUEUE_SETS == 1 )
+				{
+					if( pxQueue->pxQueueSetContainer != NULL )
+					{
+						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
+						{
+							/* The queue is a member of a queue set, and posting
+							to the queue set caused a higher priority task to
+							unblock.  A context switch is required. */
+							if( pxHigherPriorityTaskWoken != NULL )
+							{
+								*pxHigherPriorityTaskWoken = pdTRUE;
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+						{
+							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+							{
+								/* The task waiting has a higher priority so
+								record that a context switch is required. */
+								if( pxHigherPriorityTaskWoken != NULL )
+								{
+									*pxHigherPriorityTaskWoken = pdTRUE;
+								}
+								else
+								{
+									mtCOVERAGE_TEST_MARKER();
+								}
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+				}
+				#else /* configUSE_QUEUE_SETS */
+				{
+					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+					{
+						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+						{
+							/* The task waiting has a higher priority so record that a
+							context	switch is required. */
+							if( pxHigherPriorityTaskWoken != NULL )
+							{
+								*pxHigherPriorityTaskWoken = pdTRUE;
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				#endif /* configUSE_QUEUE_SETS */
+			}
+			else
+			{
+				/* Increment the lock count so the task that unlocks the queue
+				knows that data was posted while it was locked. */
+				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
+			}
+
+			xReturn = pdPASS;
+		}
+		else
+		{
+			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
+			xReturn = errQUEUE_FULL;
+		}
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
+{
+BaseType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
+	item size is 0.  Don't directly wake a task that was blocked on a queue
+	read, instead return a flag to say whether a context switch is required or
+	not (i.e. has a task with a higher priority than us been woken by this
+	post). */
+
+	configASSERT( pxQueue );
+
+	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
+	if the item size is not 0. */
+	configASSERT( pxQueue->uxItemSize == 0 );
+
+	/* Normally a mutex would not be given from an interrupt, especially if
+	there is a mutex holder, as priority inheritance makes no sense for an
+	interrupts, only tasks. */
+	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
+
+	/* RTOS ports that support interrupt nesting have the concept of a maximum
+	system call (or maximum API call) interrupt priority.  Interrupts that are
+	above the maximum system call priority are kept permanently enabled, even
+	when the RTOS kernel is in a critical section, but cannot make any calls to
+	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
+	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+	failure if a FreeRTOS API function is called from an interrupt that has been
+	assigned a priority above the configured maximum system call priority.
+	Only FreeRTOS functions that end in FromISR can be called from interrupts
+	that have been assigned a priority at or (logically) below the maximum
+	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
+	safe API to ensure interrupt entry is as fast and as simple as possible.
+	More information (albeit Cortex-M specific) is provided on the following
+	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
+
+		/* When the queue is used to implement a semaphore no data is ever
+		moved through the queue but it is still valid to see if the queue 'has
+		space'. */
+		if( uxMessagesWaiting < pxQueue->uxLength )
+		{
+			const int8_t cTxLock = pxQueue->cTxLock;
+
+			traceQUEUE_SEND_FROM_ISR( pxQueue );
+
+			/* A task can only have an inherited priority if it is a mutex
+			holder - and if there is a mutex holder then the mutex cannot be
+			given from an ISR.  As this is the ISR version of the function it
+			can be assumed there is no mutex holder and no need to determine if
+			priority disinheritance is needed.  Simply increase the count of
+			messages (semaphores) available. */
+			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
+
+			/* The event list is not altered if the queue is locked.  This will
+			be done when the queue is unlocked later. */
+			if( cTxLock == queueUNLOCKED )
+			{
+				#if ( configUSE_QUEUE_SETS == 1 )
+				{
+					if( pxQueue->pxQueueSetContainer != NULL )
+					{
+						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
+						{
+							/* The semaphore is a member of a queue set, and
+							posting	to the queue set caused a higher priority
+							task to	unblock.  A context switch is required. */
+							if( pxHigherPriorityTaskWoken != NULL )
+							{
+								*pxHigherPriorityTaskWoken = pdTRUE;
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+						{
+							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+							{
+								/* The task waiting has a higher priority so
+								record that a context switch is required. */
+								if( pxHigherPriorityTaskWoken != NULL )
+								{
+									*pxHigherPriorityTaskWoken = pdTRUE;
+								}
+								else
+								{
+									mtCOVERAGE_TEST_MARKER();
+								}
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+				}
+				#else /* configUSE_QUEUE_SETS */
+				{
+					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+					{
+						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+						{
+							/* The task waiting has a higher priority so record that a
+							context	switch is required. */
+							if( pxHigherPriorityTaskWoken != NULL )
+							{
+								*pxHigherPriorityTaskWoken = pdTRUE;
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				#endif /* configUSE_QUEUE_SETS */
+			}
+			else
+			{
+				/* Increment the lock count so the task that unlocks the queue
+				knows that data was posted while it was locked. */
+				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
+			}
+
+			xReturn = pdPASS;
+		}
+		else
+		{
+			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
+			xReturn = errQUEUE_FULL;
+		}
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
+{
+BaseType_t xEntryTimeSet = pdFALSE;
+TimeOut_t xTimeOut;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	/* Check the pointer is not NULL. */
+	configASSERT( ( pxQueue ) );
+
+	/* The buffer into which data is received can only be NULL if the data size
+	is zero (so no data is copied into the buffer. */
+	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
+
+	/* Cannot block if the scheduler is suspended. */
+	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+	{
+		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
+	}
+	#endif
+
+
+	/* This function relaxes the coding standard somewhat to allow return
+	statements within the function itself.  This is done in the interest
+	of execution time efficiency. */
+
+	for( ;; )
+	{
+		taskENTER_CRITICAL();
+		{
+			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
+
+			/* Is there data in the queue now?  To be running the calling task
+			must be the highest priority task wanting to access the queue. */
+			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
+			{
+				/* Data available, remove one item. */
+				prvCopyDataFromQueue( pxQueue, pvBuffer );
+				traceQUEUE_RECEIVE( pxQueue );
+				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
+
+				/* There is now space in the queue, were any tasks waiting to
+				post to the queue?  If so, unblock the highest priority waiting
+				task. */
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+				{
+					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+					{
+						queueYIELD_IF_USING_PREEMPTION();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				taskEXIT_CRITICAL();
+				return pdPASS;
+			}
+			else
+			{
+				if( xTicksToWait == ( TickType_t ) 0 )
+				{
+					/* The queue was empty and no block time is specified (or
+					the block time has expired) so leave now. */
+					taskEXIT_CRITICAL();
+					traceQUEUE_RECEIVE_FAILED( pxQueue );
+					return errQUEUE_EMPTY;
+				}
+				else if( xEntryTimeSet == pdFALSE )
+				{
+					/* The queue was empty and a block time was specified so
+					configure the timeout structure. */
+					vTaskInternalSetTimeOutState( &xTimeOut );
+					xEntryTimeSet = pdTRUE;
+				}
+				else
+				{
+					/* Entry time was already set. */
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		/* Interrupts and other tasks can send to and receive from the queue
+		now the critical section has been exited. */
+
+		vTaskSuspendAll();
+		prvLockQueue( pxQueue );
+
+		/* Update the timeout state to see if it has expired yet. */
+		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
+		{
+			/* The timeout has not expired.  If the queue is still empty place
+			the task on the list of tasks waiting to receive from the queue. */
+			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
+			{
+				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
+				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
+				prvUnlockQueue( pxQueue );
+				if( xTaskResumeAll() == pdFALSE )
+				{
+					portYIELD_WITHIN_API();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				/* The queue contains data again.  Loop back to try and read the
+				data. */
+				prvUnlockQueue( pxQueue );
+				( void ) xTaskResumeAll();
+			}
+		}
+		else
+		{
+			/* Timed out.  If there is no data in the queue exit, otherwise loop
+			back and attempt to read the data. */
+			prvUnlockQueue( pxQueue );
+			( void ) xTaskResumeAll();
+
+			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
+			{
+				traceQUEUE_RECEIVE_FAILED( pxQueue );
+				return errQUEUE_EMPTY;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
+{
+BaseType_t xEntryTimeSet = pdFALSE;
+TimeOut_t xTimeOut;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+#if( configUSE_MUTEXES == 1 )
+	BaseType_t xInheritanceOccurred = pdFALSE;
+#endif
+
+	/* Check the queue pointer is not NULL. */
+	configASSERT( ( pxQueue ) );
+
+	/* Check this really is a semaphore, in which case the item size will be
+	0. */
+	configASSERT( pxQueue->uxItemSize == 0 );
+
+	/* Cannot block if the scheduler is suspended. */
+	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+	{
+		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
+	}
+	#endif
+
+
+	/* This function relaxes the coding standard somewhat to allow return
+	statements within the function itself.  This is done in the interest
+	of execution time efficiency. */
+
+	for( ;; )
+	{
+		taskENTER_CRITICAL();
+		{
+			/* Semaphores are queues with an item size of 0, and where the
+			number of messages in the queue is the semaphore's count value. */
+			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
+
+			/* Is there data in the queue now?  To be running the calling task
+			must be the highest priority task wanting to access the queue. */
+			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
+			{
+				traceQUEUE_RECEIVE( pxQueue );
+
+				/* Semaphores are queues with a data size of zero and where the
+				messages waiting is the semaphore's count.  Reduce the count. */
+				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
+
+				#if ( configUSE_MUTEXES == 1 )
+				{
+					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
+					{
+						/* Record the information required to implement
+						priority inheritance should it become necessary. */
+						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				#endif /* configUSE_MUTEXES */
+
+				/* Check to see if other tasks are blocked waiting to give the
+				semaphore, and if so, unblock the highest priority such task. */
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+				{
+					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+					{
+						queueYIELD_IF_USING_PREEMPTION();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				taskEXIT_CRITICAL();
+				return pdPASS;
+			}
+			else
+			{
+				if( xTicksToWait == ( TickType_t ) 0 )
+				{
+					/* For inheritance to have occurred there must have been an
+					initial timeout, and an adjusted timeout cannot become 0, as
+					if it were 0 the function would have exited. */
+					#if( configUSE_MUTEXES == 1 )
+					{
+						configASSERT( xInheritanceOccurred == pdFALSE );
+					}
+					#endif /* configUSE_MUTEXES */
+
+					/* The semaphore count was 0 and no block time is specified
+					(or the block time has expired) so exit now. */
+					taskEXIT_CRITICAL();
+					traceQUEUE_RECEIVE_FAILED( pxQueue );
+					return errQUEUE_EMPTY;
+				}
+				else if( xEntryTimeSet == pdFALSE )
+				{
+					/* The semaphore count was 0 and a block time was specified
+					so configure the timeout structure ready to block. */
+					vTaskInternalSetTimeOutState( &xTimeOut );
+					xEntryTimeSet = pdTRUE;
+				}
+				else
+				{
+					/* Entry time was already set. */
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		/* Interrupts and other tasks can give to and take from the semaphore
+		now the critical section has been exited. */
+
+		vTaskSuspendAll();
+		prvLockQueue( pxQueue );
+
+		/* Update the timeout state to see if it has expired yet. */
+		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
+		{
+			/* A block time is specified and not expired.  If the semaphore
+			count is 0 then enter the Blocked state to wait for a semaphore to
+			become available.  As semaphores are implemented with queues the
+			queue being empty is equivalent to the semaphore count being 0. */
+			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
+			{
+				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
+
+				#if ( configUSE_MUTEXES == 1 )
+				{
+					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
+					{
+						taskENTER_CRITICAL();
+						{
+							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
+						}
+						taskEXIT_CRITICAL();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				#endif
+
+				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
+				prvUnlockQueue( pxQueue );
+				if( xTaskResumeAll() == pdFALSE )
+				{
+					portYIELD_WITHIN_API();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				/* There was no timeout and the semaphore count was not 0, so
+				attempt to take the semaphore again. */
+				prvUnlockQueue( pxQueue );
+				( void ) xTaskResumeAll();
+			}
+		}
+		else
+		{
+			/* Timed out. */
+			prvUnlockQueue( pxQueue );
+			( void ) xTaskResumeAll();
+
+			/* If the semaphore count is 0 exit now as the timeout has
+			expired.  Otherwise return to attempt to take the semaphore that is
+			known to be available.  As semaphores are implemented by queues the
+			queue being empty is equivalent to the semaphore count being 0. */
+			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
+			{
+				#if ( configUSE_MUTEXES == 1 )
+				{
+					/* xInheritanceOccurred could only have be set if
+					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
+					test the mutex type again to check it is actually a mutex. */
+					if( xInheritanceOccurred != pdFALSE )
+					{
+						taskENTER_CRITICAL();
+						{
+							UBaseType_t uxHighestWaitingPriority;
+
+							/* This task blocking on the mutex caused another
+							task to inherit this task's priority.  Now this task
+							has timed out the priority should be disinherited
+							again, but only as low as the next highest priority
+							task that is waiting for the same mutex. */
+							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
+							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
+						}
+						taskEXIT_CRITICAL();
+					}
+				}
+				#endif /* configUSE_MUTEXES */
+
+				traceQUEUE_RECEIVE_FAILED( pxQueue );
+				return errQUEUE_EMPTY;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
+{
+BaseType_t xEntryTimeSet = pdFALSE;
+TimeOut_t xTimeOut;
+int8_t *pcOriginalReadPosition;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	/* Check the pointer is not NULL. */
+	configASSERT( ( pxQueue ) );
+
+	/* The buffer into which data is received can only be NULL if the data size
+	is zero (so no data is copied into the buffer. */
+	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
+
+	/* Cannot block if the scheduler is suspended. */
+	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+	{
+		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
+	}
+	#endif
+
+
+	/* This function relaxes the coding standard somewhat to allow return
+	statements within the function itself.  This is done in the interest
+	of execution time efficiency. */
+
+	for( ;; )
+	{
+		taskENTER_CRITICAL();
+		{
+			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
+
+			/* Is there data in the queue now?  To be running the calling task
+			must be the highest priority task wanting to access the queue. */
+			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
+			{
+				/* Remember the read position so it can be reset after the data
+				is read from the queue as this function is only peeking the
+				data, not removing it. */
+				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
+
+				prvCopyDataFromQueue( pxQueue, pvBuffer );
+				traceQUEUE_PEEK( pxQueue );
+
+				/* The data is not being removed, so reset the read pointer. */
+				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
+
+				/* The data is being left in the queue, so see if there are
+				any other tasks waiting for the data. */
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+				{
+					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+					{
+						/* The task waiting has a higher priority than this task. */
+						queueYIELD_IF_USING_PREEMPTION();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				taskEXIT_CRITICAL();
+				return pdPASS;
+			}
+			else
+			{
+				if( xTicksToWait == ( TickType_t ) 0 )
+				{
+					/* The queue was empty and no block time is specified (or
+					the block time has expired) so leave now. */
+					taskEXIT_CRITICAL();
+					traceQUEUE_PEEK_FAILED( pxQueue );
+					return errQUEUE_EMPTY;
+				}
+				else if( xEntryTimeSet == pdFALSE )
+				{
+					/* The queue was empty and a block time was specified so
+					configure the timeout structure ready to enter the blocked
+					state. */
+					vTaskInternalSetTimeOutState( &xTimeOut );
+					xEntryTimeSet = pdTRUE;
+				}
+				else
+				{
+					/* Entry time was already set. */
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		/* Interrupts and other tasks can send to and receive from the queue
+		now the critical section has been exited. */
+
+		vTaskSuspendAll();
+		prvLockQueue( pxQueue );
+
+		/* Update the timeout state to see if it has expired yet. */
+		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
+		{
+			/* Timeout has not expired yet, check to see if there is data in the
+			queue now, and if not enter the Blocked state to wait for data. */
+			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
+			{
+				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
+				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
+				prvUnlockQueue( pxQueue );
+				if( xTaskResumeAll() == pdFALSE )
+				{
+					portYIELD_WITHIN_API();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				/* There is data in the queue now, so don't enter the blocked
+				state, instead return to try and obtain the data. */
+				prvUnlockQueue( pxQueue );
+				( void ) xTaskResumeAll();
+			}
+		}
+		else
+		{
+			/* The timeout has expired.  If there is still no data in the queue
+			exit, otherwise go back and try to read the data again. */
+			prvUnlockQueue( pxQueue );
+			( void ) xTaskResumeAll();
+
+			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
+			{
+				traceQUEUE_PEEK_FAILED( pxQueue );
+				return errQUEUE_EMPTY;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
+{
+BaseType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	configASSERT( pxQueue );
+	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
+
+	/* RTOS ports that support interrupt nesting have the concept of a maximum
+	system call (or maximum API call) interrupt priority.  Interrupts that are
+	above the maximum system call priority are kept permanently enabled, even
+	when the RTOS kernel is in a critical section, but cannot make any calls to
+	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
+	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+	failure if a FreeRTOS API function is called from an interrupt that has been
+	assigned a priority above the configured maximum system call priority.
+	Only FreeRTOS functions that end in FromISR can be called from interrupts
+	that have been assigned a priority at or (logically) below the maximum
+	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
+	safe API to ensure interrupt entry is as fast and as simple as possible.
+	More information (albeit Cortex-M specific) is provided on the following
+	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
+
+		/* Cannot block in an ISR, so check there is data available. */
+		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
+		{
+			const int8_t cRxLock = pxQueue->cRxLock;
+
+			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
+
+			prvCopyDataFromQueue( pxQueue, pvBuffer );
+			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
+
+			/* If the queue is locked the event list will not be modified.
+			Instead update the lock count so the task that unlocks the queue
+			will know that an ISR has removed data while the queue was
+			locked. */
+			if( cRxLock == queueUNLOCKED )
+			{
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+				{
+					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+					{
+						/* The task waiting has a higher priority than us so
+						force a context switch. */
+						if( pxHigherPriorityTaskWoken != NULL )
+						{
+							*pxHigherPriorityTaskWoken = pdTRUE;
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				/* Increment the lock count so the task that unlocks the queue
+				knows that data was removed while it was locked. */
+				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
+			}
+
+			xReturn = pdPASS;
+		}
+		else
+		{
+			xReturn = pdFAIL;
+			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
+		}
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
+{
+BaseType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+int8_t *pcOriginalReadPosition;
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	configASSERT( pxQueue );
+	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
+	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
+
+	/* RTOS ports that support interrupt nesting have the concept of a maximum
+	system call (or maximum API call) interrupt priority.  Interrupts that are
+	above the maximum system call priority are kept permanently enabled, even
+	when the RTOS kernel is in a critical section, but cannot make any calls to
+	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
+	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+	failure if a FreeRTOS API function is called from an interrupt that has been
+	assigned a priority above the configured maximum system call priority.
+	Only FreeRTOS functions that end in FromISR can be called from interrupts
+	that have been assigned a priority at or (logically) below the maximum
+	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
+	safe API to ensure interrupt entry is as fast and as simple as possible.
+	More information (albeit Cortex-M specific) is provided on the following
+	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		/* Cannot block in an ISR, so check there is data available. */
+		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
+		{
+			traceQUEUE_PEEK_FROM_ISR( pxQueue );
+
+			/* Remember the read position so it can be reset as nothing is
+			actually being removed from the queue. */
+			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
+			prvCopyDataFromQueue( pxQueue, pvBuffer );
+			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
+
+			xReturn = pdPASS;
+		}
+		else
+		{
+			xReturn = pdFAIL;
+			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
+		}
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
+{
+UBaseType_t uxReturn;
+
+	configASSERT( xQueue );
+
+	taskENTER_CRITICAL();
+	{
+		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
+	}
+	taskEXIT_CRITICAL();
+
+	return uxReturn;
+} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
+/*-----------------------------------------------------------*/
+
+UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
+{
+UBaseType_t uxReturn;
+Queue_t *pxQueue;
+
+	pxQueue = ( Queue_t * ) xQueue;
+	configASSERT( pxQueue );
+
+	taskENTER_CRITICAL();
+	{
+		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
+	}
+	taskEXIT_CRITICAL();
+
+	return uxReturn;
+} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
+/*-----------------------------------------------------------*/
+
+UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
+{
+UBaseType_t uxReturn;
+
+	configASSERT( xQueue );
+
+	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
+
+	return uxReturn;
+} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
+/*-----------------------------------------------------------*/
+
+void vQueueDelete( QueueHandle_t xQueue )
+{
+Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+	configASSERT( pxQueue );
+	traceQUEUE_DELETE( pxQueue );
+
+	#if ( configQUEUE_REGISTRY_SIZE > 0 )
+	{
+		vQueueUnregisterQueue( pxQueue );
+	}
+	#endif
+
+	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
+	{
+		/* The queue can only have been allocated dynamically - free it
+		again. */
+		vPortFree( pxQueue );
+	}
+	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+	{
+		/* The queue could have been allocated statically or dynamically, so
+		check before attempting to free the memory. */
+		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
+		{
+			vPortFree( pxQueue );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	#else
+	{
+		/* The queue must have been statically allocated, so is not going to be
+		deleted.  Avoid compiler warnings about the unused parameter. */
+		( void ) pxQueue;
+	}
+	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+}
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
+	{
+		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
+	{
+		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
+	{
+		return ( ( Queue_t * ) xQueue )->ucQueueType;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if( configUSE_MUTEXES == 1 )
+
+	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
+	{
+	UBaseType_t uxHighestPriorityOfWaitingTasks;
+
+		/* If a task waiting for a mutex causes the mutex holder to inherit a
+		priority, but the waiting task times out, then the holder should
+		disinherit the priority - but only down to the highest priority of any
+		other tasks that are waiting for the same mutex.  For this purpose,
+		return the priority of the highest priority task that is waiting for the
+		mutex. */
+		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
+		{
+			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
+		}
+		else
+		{
+			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
+		}
+
+		return uxHighestPriorityOfWaitingTasks;
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
+{
+BaseType_t xReturn = pdFALSE;
+UBaseType_t uxMessagesWaiting;
+
+	/* This function is called from a critical section. */
+
+	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
+
+	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
+	{
+		#if ( configUSE_MUTEXES == 1 )
+		{
+			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
+			{
+				/* The mutex is no longer being held. */
+				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
+				pxQueue->pxMutexHolder = NULL;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* configUSE_MUTEXES */
+	}
+	else if( xPosition == queueSEND_TO_BACK )
+	{
+		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
+		pxQueue->pcWriteTo += pxQueue->uxItemSize;
+		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
+		{
+			pxQueue->pcWriteTo = pxQueue->pcHead;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
+		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
+		{
+			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		if( xPosition == queueOVERWRITE )
+		{
+			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
+			{
+				/* An item is not being added but overwritten, so subtract
+				one from the recorded number of items in the queue so when
+				one is added again below the number of recorded items remains
+				correct. */
+				--uxMessagesWaiting;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
+{
+	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
+	{
+		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
+		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
+		{
+			pxQueue->u.pcReadFrom = pxQueue->pcHead;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
+	}
+}
+/*-----------------------------------------------------------*/
+
+static void prvUnlockQueue( Queue_t * const pxQueue )
+{
+	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
+
+	/* The lock counts contains the number of extra data items placed or
+	removed from the queue while the queue was locked.  When a queue is
+	locked items can be added or removed, but the event lists cannot be
+	updated. */
+	taskENTER_CRITICAL();
+	{
+		int8_t cTxLock = pxQueue->cTxLock;
+
+		/* See if data was added to the queue while it was locked. */
+		while( cTxLock > queueLOCKED_UNMODIFIED )
+		{
+			/* Data was posted while the queue was locked.  Are any tasks
+			blocked waiting for data to become available? */
+			#if ( configUSE_QUEUE_SETS == 1 )
+			{
+				if( pxQueue->pxQueueSetContainer != NULL )
+				{
+					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
+					{
+						/* The queue is a member of a queue set, and posting to
+						the queue set caused a higher priority task to unblock.
+						A context switch is required. */
+						vTaskMissedYield();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					/* Tasks that are removed from the event list will get
+					added to the pending ready list as the scheduler is still
+					suspended. */
+					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+					{
+						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+						{
+							/* The task waiting has a higher priority so record that a
+							context	switch is required. */
+							vTaskMissedYield();
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						break;
+					}
+				}
+			}
+			#else /* configUSE_QUEUE_SETS */
+			{
+				/* Tasks that are removed from the event list will get added to
+				the pending ready list as the scheduler is still suspended. */
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+				{
+					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+					{
+						/* The task waiting has a higher priority so record that
+						a context switch is required. */
+						vTaskMissedYield();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					break;
+				}
+			}
+			#endif /* configUSE_QUEUE_SETS */
+
+			--cTxLock;
+		}
+
+		pxQueue->cTxLock = queueUNLOCKED;
+	}
+	taskEXIT_CRITICAL();
+
+	/* Do the same for the Rx lock. */
+	taskENTER_CRITICAL();
+	{
+		int8_t cRxLock = pxQueue->cRxLock;
+
+		while( cRxLock > queueLOCKED_UNMODIFIED )
+		{
+			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+			{
+				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+				{
+					vTaskMissedYield();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				--cRxLock;
+			}
+			else
+			{
+				break;
+			}
+		}
+
+		pxQueue->cRxLock = queueUNLOCKED;
+	}
+	taskEXIT_CRITICAL();
+}
+/*-----------------------------------------------------------*/
+
+static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
+{
+BaseType_t xReturn;
+
+	taskENTER_CRITICAL();
+	{
+		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
+		{
+			xReturn = pdTRUE;
+		}
+		else
+		{
+			xReturn = pdFALSE;
+		}
+	}
+	taskEXIT_CRITICAL();
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
+{
+BaseType_t xReturn;
+
+	configASSERT( xQueue );
+	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
+	{
+		xReturn = pdTRUE;
+	}
+	else
+	{
+		xReturn = pdFALSE;
+	}
+
+	return xReturn;
+} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
+/*-----------------------------------------------------------*/
+
+static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
+{
+BaseType_t xReturn;
+
+	taskENTER_CRITICAL();
+	{
+		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
+		{
+			xReturn = pdTRUE;
+		}
+		else
+		{
+			xReturn = pdFALSE;
+		}
+	}
+	taskEXIT_CRITICAL();
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
+{
+BaseType_t xReturn;
+
+	configASSERT( xQueue );
+	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
+	{
+		xReturn = pdTRUE;
+	}
+	else
+	{
+		xReturn = pdFALSE;
+	}
+
+	return xReturn;
+} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_CO_ROUTINES == 1 )
+
+	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
+	{
+	BaseType_t xReturn;
+	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+		/* If the queue is already full we may have to block.  A critical section
+		is required to prevent an interrupt removing something from the queue
+		between the check to see if the queue is full and blocking on the queue. */
+		portDISABLE_INTERRUPTS();
+		{
+			if( prvIsQueueFull( pxQueue ) != pdFALSE )
+			{
+				/* The queue is full - do we want to block or just leave without
+				posting? */
+				if( xTicksToWait > ( TickType_t ) 0 )
+				{
+					/* As this is called from a coroutine we cannot block directly, but
+					return indicating that we need to block. */
+					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
+					portENABLE_INTERRUPTS();
+					return errQUEUE_BLOCKED;
+				}
+				else
+				{
+					portENABLE_INTERRUPTS();
+					return errQUEUE_FULL;
+				}
+			}
+		}
+		portENABLE_INTERRUPTS();
+
+		portDISABLE_INTERRUPTS();
+		{
+			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
+			{
+				/* There is room in the queue, copy the data into the queue. */
+				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
+				xReturn = pdPASS;
+
+				/* Were any co-routines waiting for data to become available? */
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+				{
+					/* In this instance the co-routine could be placed directly
+					into the ready list as we are within a critical section.
+					Instead the same pending ready list mechanism is used as if
+					the event were caused from within an interrupt. */
+					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+					{
+						/* The co-routine waiting has a higher priority so record
+						that a yield might be appropriate. */
+						xReturn = errQUEUE_YIELD;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				xReturn = errQUEUE_FULL;
+			}
+		}
+		portENABLE_INTERRUPTS();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_CO_ROUTINES */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_CO_ROUTINES == 1 )
+
+	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
+	{
+	BaseType_t xReturn;
+	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+		/* If the queue is already empty we may have to block.  A critical section
+		is required to prevent an interrupt adding something to the queue
+		between the check to see if the queue is empty and blocking on the queue. */
+		portDISABLE_INTERRUPTS();
+		{
+			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
+			{
+				/* There are no messages in the queue, do we want to block or just
+				leave with nothing? */
+				if( xTicksToWait > ( TickType_t ) 0 )
+				{
+					/* As this is a co-routine we cannot block directly, but return
+					indicating that we need to block. */
+					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
+					portENABLE_INTERRUPTS();
+					return errQUEUE_BLOCKED;
+				}
+				else
+				{
+					portENABLE_INTERRUPTS();
+					return errQUEUE_FULL;
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		portENABLE_INTERRUPTS();
+
+		portDISABLE_INTERRUPTS();
+		{
+			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
+			{
+				/* Data is available from the queue. */
+				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
+				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
+				{
+					pxQueue->u.pcReadFrom = pxQueue->pcHead;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+				--( pxQueue->uxMessagesWaiting );
+				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
+
+				xReturn = pdPASS;
+
+				/* Were any co-routines waiting for space to become available? */
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+				{
+					/* In this instance the co-routine could be placed directly
+					into the ready list as we are within a critical section.
+					Instead the same pending ready list mechanism is used as if
+					the event were caused from within an interrupt. */
+					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+					{
+						xReturn = errQUEUE_YIELD;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				xReturn = pdFAIL;
+			}
+		}
+		portENABLE_INTERRUPTS();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_CO_ROUTINES */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_CO_ROUTINES == 1 )
+
+	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
+	{
+	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+		/* Cannot block within an ISR so if there is no space on the queue then
+		exit without doing anything. */
+		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
+		{
+			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
+
+			/* We only want to wake one co-routine per ISR, so check that a
+			co-routine has not already been woken. */
+			if( xCoRoutinePreviouslyWoken == pdFALSE )
+			{
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
+				{
+					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
+					{
+						return pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return xCoRoutinePreviouslyWoken;
+	}
+
+#endif /* configUSE_CO_ROUTINES */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_CO_ROUTINES == 1 )
+
+	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
+	{
+	BaseType_t xReturn;
+	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+		/* We cannot block from an ISR, so check there is data available. If
+		not then just leave without doing anything. */
+		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
+		{
+			/* Copy the data from the queue. */
+			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
+			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
+			{
+				pxQueue->u.pcReadFrom = pxQueue->pcHead;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+			--( pxQueue->uxMessagesWaiting );
+			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
+
+			if( ( *pxCoRoutineWoken ) == pdFALSE )
+			{
+				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
+				{
+					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
+					{
+						*pxCoRoutineWoken = pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			xReturn = pdPASS;
+		}
+		else
+		{
+			xReturn = pdFAIL;
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_CO_ROUTINES */
+/*-----------------------------------------------------------*/
+
+#if ( configQUEUE_REGISTRY_SIZE > 0 )
+
+	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	{
+	UBaseType_t ux;
+
+		/* See if there is an empty space in the registry.  A NULL name denotes
+		a free slot. */
+		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
+		{
+			if( xQueueRegistry[ ux ].pcQueueName == NULL )
+			{
+				/* Store the information on this queue. */
+				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
+				xQueueRegistry[ ux ].xHandle = xQueue;
+
+				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
+				break;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+	}
+
+#endif /* configQUEUE_REGISTRY_SIZE */
+/*-----------------------------------------------------------*/
+
+#if ( configQUEUE_REGISTRY_SIZE > 0 )
+
+	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	{
+	UBaseType_t ux;
+	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+		/* Note there is nothing here to protect against another task adding or
+		removing entries from the registry while it is being searched. */
+		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
+		{
+			if( xQueueRegistry[ ux ].xHandle == xQueue )
+			{
+				pcReturn = xQueueRegistry[ ux ].pcQueueName;
+				break;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+
+		return pcReturn;
+	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
+
+#endif /* configQUEUE_REGISTRY_SIZE */
+/*-----------------------------------------------------------*/
+
+#if ( configQUEUE_REGISTRY_SIZE > 0 )
+
+	void vQueueUnregisterQueue( QueueHandle_t xQueue )
+	{
+	UBaseType_t ux;
+
+		/* See if the handle of the queue being unregistered in actually in the
+		registry. */
+		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
+		{
+			if( xQueueRegistry[ ux ].xHandle == xQueue )
+			{
+				/* Set the name to NULL to show that this slot if free again. */
+				xQueueRegistry[ ux ].pcQueueName = NULL;
+
+				/* Set the handle to NULL to ensure the same queue handle cannot
+				appear in the registry twice if it is added, removed, then
+				added again. */
+				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
+				break;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+
+	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
+
+#endif /* configQUEUE_REGISTRY_SIZE */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TIMERS == 1 )
+
+	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
+	{
+	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
+
+		/* This function should not be called by application code hence the
+		'Restricted' in its name.  It is not part of the public API.  It is
+		designed for use by kernel code, and has special calling requirements.
+		It can result in vListInsert() being called on a list that can only
+		possibly ever have one item in it, so the list will be fast, but even
+		so it should be called with the scheduler locked and not from a critical
+		section. */
+
+		/* Only do anything if there are no messages in the queue.  This function
+		will not actually cause the task to block, just place it on a blocked
+		list.  It will not block until the scheduler is unlocked - at which
+		time a yield will be performed.  If an item is added to the queue while
+		the queue is locked, and the calling task blocks on the queue, then the
+		calling task will be immediately unblocked when the queue is unlocked. */
+		prvLockQueue( pxQueue );
+		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
+		{
+			/* There is nothing in the queue, block for the specified period. */
+			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+		prvUnlockQueue( pxQueue );
+	}
+
+#endif /* configUSE_TIMERS */
+/*-----------------------------------------------------------*/
+
+#if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+
+	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
+	{
+	QueueSetHandle_t pxQueue;
+
+		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
+
+		return pxQueue;
+	}
+
+#endif /* configUSE_QUEUE_SETS */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_QUEUE_SETS == 1 )
+
+	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
+	{
+	BaseType_t xReturn;
+
+		taskENTER_CRITICAL();
+		{
+			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
+			{
+				/* Cannot add a queue/semaphore to more than one queue set. */
+				xReturn = pdFAIL;
+			}
+			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
+			{
+				/* Cannot add a queue/semaphore to a queue set if there are already
+				items in the queue/semaphore. */
+				xReturn = pdFAIL;
+			}
+			else
+			{
+				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
+				xReturn = pdPASS;
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_QUEUE_SETS */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_QUEUE_SETS == 1 )
+
+	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
+	{
+	BaseType_t xReturn;
+	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
+
+		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
+		{
+			/* The queue was not a member of the set. */
+			xReturn = pdFAIL;
+		}
+		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
+		{
+			/* It is dangerous to remove a queue from a set when the queue is
+			not empty because the queue set will still hold pending events for
+			the queue. */
+			xReturn = pdFAIL;
+		}
+		else
+		{
+			taskENTER_CRITICAL();
+			{
+				/* The queue is no longer contained in the set. */
+				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
+			}
+			taskEXIT_CRITICAL();
+			xReturn = pdPASS;
+		}
+
+		return xReturn;
+	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
+
+#endif /* configUSE_QUEUE_SETS */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_QUEUE_SETS == 1 )
+
+	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
+	{
+	QueueSetMemberHandle_t xReturn = NULL;
+
+		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
+		return xReturn;
+	}
+
+#endif /* configUSE_QUEUE_SETS */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_QUEUE_SETS == 1 )
+
+	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
+	{
+	QueueSetMemberHandle_t xReturn = NULL;
+
+		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
+		return xReturn;
+	}
+
+#endif /* configUSE_QUEUE_SETS */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_QUEUE_SETS == 1 )
+
+	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
+	{
+	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
+	BaseType_t xReturn = pdFALSE;
+
+		/* This function must be called form a critical section. */
+
+		configASSERT( pxQueueSetContainer );
+		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
+
+		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
+		{
+			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
+
+			traceQUEUE_SEND( pxQueueSetContainer );
+
+			/* The data copied is the handle of the queue that contains data. */
+			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
+
+			if( cTxLock == queueUNLOCKED )
+			{
+				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
+				{
+					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
+					{
+						/* The task waiting has a higher priority. */
+						xReturn = pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_QUEUE_SETS */
+
+
+
+
+
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/static_provider.c ./libs/freertos/source/static_provider.c
--- a_bRU7kv/libs/freertos/source/static_provider.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/static_provider.c	2018-12-01 17:15:06.605605990 -0300
@@ -0,0 +1,54 @@
+#include <FreeRTOS.h>
+
+/* configSUPPORT_STATIC_ALLOCATION is set to 1, so the application must provide an
+implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
+used by the Idle task. */
+void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
+                                    StackType_t **ppxIdleTaskStackBuffer,
+                                    uint32_t *pulIdleTaskStackSize )
+{
+/* If the buffers to be provided to the Idle task are declared inside this
+function then they must be declared static - otherwise they will be allocated on
+the stack and so not exists after this function exits. */
+static StaticTask_t xIdleTaskTCB;
+static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];
+
+    /* Pass out a pointer to the StaticTask_t structure in which the Idle task's
+    state will be stored. */
+    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
+
+    /* Pass out the array that will be used as the Idle task's stack. */
+    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
+
+    /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
+    Note that, as the array is necessarily of type StackType_t,
+    configMINIMAL_STACK_SIZE is specified in words, not bytes. */
+    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
+}
+/*-----------------------------------------------------------*/
+
+/* configSUPPORT_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the
+application must provide an implementation of vApplicationGetTimerTaskMemory()
+to provide the memory that is used by the Timer service task. */
+void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
+                                     StackType_t **ppxTimerTaskStackBuffer,
+                                     uint32_t *pulTimerTaskStackSize )
+{
+/* If the buffers to be provided to the Timer task are declared inside this
+function then they must be declared static - otherwise they will be allocated on
+the stack and so not exists after this function exits. */
+static StaticTask_t xTimerTaskTCB;
+static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];
+
+    /* Pass out a pointer to the StaticTask_t structure in which the Timer
+    task's state will be stored. */
+    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
+
+    /* Pass out the array that will be used as the Timer task's stack. */
+    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
+
+    /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
+    Note that, as the array is necessarily of type StackType_t,
+    configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */
+    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
+}
\ No hay ningún carácter de nueva línea al final del archivo
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/stream_buffer.c ./libs/freertos/source/stream_buffer.c
--- a_bRU7kv/libs/freertos/source/stream_buffer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/stream_buffer.c	2018-12-01 17:15:06.609606040 -0300
@@ -0,0 +1,1199 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/* Standard includes. */
+#include <stdint.h>
+#include <string.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+/* FreeRTOS includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+#include "stream_buffer.h"
+
+#if( configUSE_TASK_NOTIFICATIONS != 1 )
+	#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
+#endif
+
+/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
+MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
+header files above, but not in this file, in order to generate the correct
+privileged Vs unprivileged linkage and placement. */
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
+
+/* If the user has not provided application specific Rx notification macros,
+or #defined the notification macros away, them provide default implementations
+that uses task notifications. */
+/*lint -save -e9026 Function like macros allowed and needed here so they can be overidden. */
+#ifndef sbRECEIVE_COMPLETED
+	#define sbRECEIVE_COMPLETED( pxStreamBuffer )										\
+		vTaskSuspendAll();																\
+		{																				\
+			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
+			{																			\
+				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend,			\
+									  ( uint32_t ) 0,									\
+									  eNoAction );										\
+				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
+			}																			\
+		}																				\
+		( void ) xTaskResumeAll();
+#endif /* sbRECEIVE_COMPLETED */
+
+#ifndef sbRECEIVE_COMPLETED_FROM_ISR
+	#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,								\
+										  pxHigherPriorityTaskWoken )					\
+	{																					\
+	UBaseType_t uxSavedInterruptStatus;													\
+																						\
+		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
+		{																				\
+			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
+			{																			\
+				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,	\
+											 ( uint32_t ) 0,							\
+											 eNoAction,									\
+											 pxHigherPriorityTaskWoken );				\
+				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
+			}																			\
+		}																				\
+		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
+	}
+#endif /* sbRECEIVE_COMPLETED_FROM_ISR */
+
+/* If the user has not provided an application specific Tx notification macro,
+or #defined the notification macro away, them provide a default implementation
+that uses task notifications. */
+#ifndef sbSEND_COMPLETED
+	#define sbSEND_COMPLETED( pxStreamBuffer )											\
+		vTaskSuspendAll();																\
+		{																				\
+			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
+			{																			\
+				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive,		\
+									  ( uint32_t ) 0,									\
+									  eNoAction );										\
+				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
+			}																			\
+		}																				\
+		( void ) xTaskResumeAll();
+#endif /* sbSEND_COMPLETED */
+
+#ifndef sbSEND_COMPLETE_FROM_ISR
+	#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )		\
+	{																					\
+	UBaseType_t uxSavedInterruptStatus;													\
+																						\
+		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
+		{																				\
+			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
+			{																			\
+				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,	\
+											 ( uint32_t ) 0,							\
+											 eNoAction,									\
+											 pxHigherPriorityTaskWoken );				\
+				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
+			}																			\
+		}																				\
+		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
+	}
+#endif /* sbSEND_COMPLETE_FROM_ISR */
+/*lint -restore (9026) */
+
+/* The number of bytes used to hold the length of a message in the buffer. */
+#define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( size_t ) )
+
+/* Bits stored in the ucFlags field of the stream buffer. */
+#define sbFLAGS_IS_MESSAGE_BUFFER		( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
+#define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */
+
+/*-----------------------------------------------------------*/
+
+/* Structure that hold state information on the buffer. */
+typedef struct xSTREAM_BUFFER /*lint !e9058 Style convention uses tag. */
+{
+	volatile size_t xTail;				/* Index to the next item to read within the buffer. */
+	volatile size_t xHead;				/* Index to the next item to write within the buffer. */
+	size_t xLength;						/* The length of the buffer pointed to by pucBuffer. */
+	size_t xTriggerLevelBytes;			/* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
+	volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
+	volatile TaskHandle_t xTaskWaitingToSend;	/* Holds the handle of a task waiting to send data to a message buffer that is full. */
+	uint8_t *pucBuffer;					/* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
+	uint8_t ucFlags;
+
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxStreamBufferNumber;		/* Used for tracing purposes. */
+	#endif
+} StreamBuffer_t;
+
+/*
+ * The number of bytes available to be read from the buffer.
+ */
+static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
+
+/*
+ * Add xCount bytes from pucData into the pxStreamBuffer message buffer.
+ * Returns the number of bytes written, which will either equal xCount in the
+ * success case, or 0 if there was not enough space in the buffer (in which case
+ * no data is written into the buffer).
+ */
+static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;
+
+/*
+ * If the stream buffer is being used as a message buffer, then reads an entire
+ * message out of the buffer.  If the stream buffer is being used as a stream
+ * buffer then read as many bytes as possible from the buffer.
+ * prvReadBytesFromBuffer() is called to actually extract the bytes from the
+ * buffer's data storage area.
+ */
+static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
+										void *pvRxData,
+										size_t xBufferLengthBytes,
+										size_t xBytesAvailable,
+										size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
+
+/*
+ * If the stream buffer is being used as a message buffer, then writes an entire
+ * message to the buffer.  If the stream buffer is being used as a stream
+ * buffer then write as many bytes as possible to the buffer.
+ * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's
+ * data storage area.
+ */
+static size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,
+										const void * pvTxData,
+										size_t xDataLengthBytes,
+										size_t xSpace,
+										size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
+
+/*
+ * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them
+ * to pucData.
+ */
+static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,
+									  uint8_t *pucData,
+									  size_t xMaxCount,
+									  size_t xBytesAvailable ); PRIVILEGED_FUNCTION
+
+/*
+ * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to
+ * initialise the members of the newly created stream buffer structure.
+ */
+static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
+										  uint8_t * const pucBuffer,
+										  size_t xBufferSizeBytes,
+										  size_t xTriggerLevelBytes,
+										  BaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+
+	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
+	{
+	uint8_t *pucAllocatedMemory;
+
+		/* In case the stream buffer is going to be used as a message buffer
+		(that is, it will hold discrete messages with a little meta data that
+		says how big the next message is) check the buffer will be large enough
+		to hold at least one message. */
+		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
+		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
+
+		/* A trigger level of 0 would cause a waiting task to unblock even when
+		the buffer was empty. */
+		if( xTriggerLevelBytes == ( size_t ) 0 )
+		{
+			xTriggerLevelBytes = ( size_t ) 1; /*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
+		}
+
+		/* A stream buffer requires a StreamBuffer_t structure and a buffer.
+		Both are allocated in a single call to pvPortMalloc().  The
+		StreamBuffer_t structure is placed at the start of the allocated memory
+		and the buffer follows immediately after.  The requested size is
+		incremented so the free space is returned as the user would expect -
+		this is a quirk of the implementation that means otherwise the free
+		space would be reported as one byte smaller than would be logically
+		expected. */
+		xBufferSizeBytes++;
+		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
+
+		if( pucAllocatedMemory != NULL )
+		{
+			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
+										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
+										   xBufferSizeBytes,
+										   xTriggerLevelBytes,
+										   xIsMessageBuffer );
+
+			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
+		}
+		else
+		{
+			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
+		}
+
+		return ( StreamBufferHandle_t * ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
+	}
+
+#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
+														   size_t xTriggerLevelBytes,
+														   BaseType_t xIsMessageBuffer,
+														   uint8_t * const pucStreamBufferStorageArea,
+														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
+	{
+	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
+	StreamBufferHandle_t xReturn;
+
+		configASSERT( pucStreamBufferStorageArea );
+		configASSERT( pxStaticStreamBuffer );
+		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
+
+		/* A trigger level of 0 would cause a waiting task to unblock even when
+		the buffer was empty. */
+		if( xTriggerLevelBytes == ( size_t ) 0 )
+		{
+			xTriggerLevelBytes = ( size_t ) 1; /*lint !e9044 Function parameter deliberately modified to ensure it is in range. */
+		}
+
+		/* In case the stream buffer is going to be used as a message buffer
+		(that is, it will hold discrete messages with a little meta data that
+		says how big the next message is) check the buffer will be large enough
+		to hold at least one message. */
+		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
+
+		#if( configASSERT_DEFINED == 1 )
+		{
+			/* Sanity check that the size of the structure used to declare a
+			variable of type StaticStreamBuffer_t equals the size of the real
+			message buffer structure. */
+			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
+			configASSERT( xSize == sizeof( StreamBuffer_t ) );
+		}
+		#endif /* configASSERT_DEFINED */
+
+		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
+		{
+			prvInitialiseNewStreamBuffer( pxStreamBuffer,
+										  pucStreamBufferStorageArea,
+										  xBufferSizeBytes,
+										  xTriggerLevelBytes,
+										  xIsMessageBuffer );
+
+			/* Remember this was statically allocated in case it is ever deleted
+			again. */
+			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
+
+			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
+
+			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */
+		}
+		else
+		{
+			xReturn = NULL;
+			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
+		}
+
+		return xReturn;
+	}
+
+#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
+/*-----------------------------------------------------------*/
+
+void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
+{
+StreamBuffer_t * pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+
+	configASSERT( pxStreamBuffer );
+
+	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
+
+	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
+	{
+		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+		{
+			/* Both the structure and the buffer were allocated using a single call
+			to pvPortMalloc(), hence only one call to vPortFree() is required. */
+			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
+		}
+		#else
+		{
+			/* Should not be possible to get here, ucFlags must be corrupt.
+			Force an assert. */
+			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
+		}
+		#endif
+	}
+	else
+	{
+		/* The structure and buffer were not allocated dynamically and cannot be
+		freed - just scrub the structure so future use will assert. */
+		memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
+	}
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+BaseType_t xReturn = pdFAIL, xIsMessageBuffer;
+
+#if( configUSE_TRACE_FACILITY == 1 )
+	UBaseType_t uxStreamBufferNumber;
+#endif
+
+	configASSERT( pxStreamBuffer );
+
+	#if( configUSE_TRACE_FACILITY == 1 )
+	{
+		/* Store the stream buffer number so it can be restored after the
+		reset. */
+		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
+	}
+	#endif
+
+	/* Can only reset a message buffer if there are no tasks blocked on it. */
+	if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
+	{
+		if( pxStreamBuffer->xTaskWaitingToSend == NULL )
+		{
+			if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
+			{
+				xIsMessageBuffer = pdTRUE;
+			}
+			else
+			{
+				xIsMessageBuffer = pdFALSE;
+			}
+
+			prvInitialiseNewStreamBuffer( pxStreamBuffer,
+										  pxStreamBuffer->pucBuffer,
+										  pxStreamBuffer->xLength,
+										  pxStreamBuffer->xTriggerLevelBytes,
+										  xIsMessageBuffer );
+			xReturn = pdPASS;
+
+			#if( configUSE_TRACE_FACILITY == 1 )
+			{
+				pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
+			}
+			#endif
+
+			traceSTREAM_BUFFER_RESET( xStreamBuffer );
+		}
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+BaseType_t xReturn;
+
+	configASSERT( pxStreamBuffer );
+
+	/* It is not valid for the trigger level to be 0. */
+	if( xTriggerLevel == ( size_t ) 0 )
+	{
+		xTriggerLevel = ( size_t ) 1; /*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
+	}
+
+	/* The trigger level is the number of bytes that must be in the stream
+	buffer before a task that is waiting for data is unblocked. */
+	if( xTriggerLevel <= pxStreamBuffer->xLength )
+	{
+		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
+		xReturn = pdPASS;
+	}
+	else
+	{
+		xReturn = pdFALSE;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
+{
+const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+size_t xSpace;
+
+	configASSERT( pxStreamBuffer );
+
+	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
+	xSpace -= pxStreamBuffer->xHead;
+	xSpace -= ( size_t ) 1;
+
+	if( xSpace >= pxStreamBuffer->xLength )
+	{
+		xSpace -= pxStreamBuffer->xLength;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	return xSpace;
+}
+/*-----------------------------------------------------------*/
+
+size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
+{
+const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+size_t xReturn;
+
+	configASSERT( pxStreamBuffer );
+
+	xReturn = prvBytesInBuffer( pxStreamBuffer );
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
+						  const void *pvTxData,
+						  size_t xDataLengthBytes,
+						  TickType_t xTicksToWait )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+size_t xReturn, xSpace = 0;
+size_t xRequiredSpace = xDataLengthBytes;
+TimeOut_t xTimeOut;
+
+	configASSERT( pvTxData );
+	configASSERT( pxStreamBuffer );
+
+	/* This send function is used to write to both message buffers and stream
+	buffers.  If this is a message buffer then the space needed must be
+	increased by the amount of bytes needed to store the length of the
+	message. */
+	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
+	{
+		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	if( xTicksToWait != ( TickType_t ) 0 )
+	{
+		vTaskSetTimeOutState( &xTimeOut );
+
+		do
+		{
+			/* Wait until the required number of bytes are free in the message
+			buffer. */
+			taskENTER_CRITICAL();
+			{
+				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
+
+				if( xSpace < xRequiredSpace )
+				{
+					/* Clear notification state as going to wait for space. */
+					( void ) xTaskNotifyStateClear( NULL );
+
+					/* Should only be one writer. */
+					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
+					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
+				}
+				else
+				{
+					taskEXIT_CRITICAL();
+					break;
+				}
+			}
+			taskEXIT_CRITICAL();
+
+			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
+			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
+			pxStreamBuffer->xTaskWaitingToSend = NULL;
+
+		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	if( xSpace == ( size_t ) 0 )
+	{
+		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
+
+	if( xReturn > ( size_t ) 0 )
+	{
+		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
+
+		/* Was a task waiting for the data? */
+		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
+		{
+			sbSEND_COMPLETED( pxStreamBuffer );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
+								 const void *pvTxData,
+								 size_t xDataLengthBytes,
+								 BaseType_t * const pxHigherPriorityTaskWoken )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+size_t xReturn, xSpace;
+size_t xRequiredSpace = xDataLengthBytes;
+
+	configASSERT( pvTxData );
+	configASSERT( pxStreamBuffer );
+
+	/* This send function is used to write to both message buffers and stream
+	buffers.  If this is a message buffer then the space needed must be
+	increased by the amount of bytes needed to store the length of the
+	message. */
+	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
+	{
+		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
+	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
+
+	if( xReturn > ( size_t ) 0 )
+	{
+		/* Was a task waiting for the data? */
+		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
+		{
+			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
+									   const void * pvTxData,
+									   size_t xDataLengthBytes,
+									   size_t xSpace,
+									   size_t xRequiredSpace )
+{
+	BaseType_t xShouldWrite;
+	size_t xReturn;
+
+	if( xSpace == ( size_t ) 0 )
+	{
+		/* Doesn't matter if this is a stream buffer or a message buffer, there
+		is no space to write. */
+		xShouldWrite = pdFALSE;
+	}
+	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
+	{
+		/* This is a stream buffer, as opposed to a message buffer, so writing a
+		stream of bytes rather than discrete messages.  Write as many bytes as
+		possible. */
+		xShouldWrite = pdTRUE;
+		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace ); /*lint !e9044 Function parameter modified to ensure it is capped to available space. */
+	}
+	else if( xSpace >= xRequiredSpace )
+	{
+		/* This is a message buffer, as opposed to a stream buffer, and there
+		is enough space to write both the message length and the message itself
+		into the buffer.  Start by writing the length of the data, the data
+		itself will be written later in this function. */
+		xShouldWrite = pdTRUE;
+		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
+	}
+	else
+	{
+		/* There is space available, but not enough space. */
+		xShouldWrite = pdFALSE;
+	}
+
+	if( xShouldWrite != pdFALSE )
+	{
+		/* Writes the data itself. */
+		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
+	}
+	else
+	{
+		xReturn = 0;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
+							 void *pvRxData,
+							 size_t xBufferLengthBytes,
+							 TickType_t xTicksToWait )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
+
+	configASSERT( pvRxData );
+	configASSERT( pxStreamBuffer );
+
+	/* This receive function is used by both message buffers, which store
+	discrete messages, and stream buffers, which store a continuous stream of
+	bytes.  Discrete messages include an additional
+	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
+	message. */
+	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
+	{
+		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
+	}
+	else
+	{
+		xBytesToStoreMessageLength = 0;
+	}
+
+	if( xTicksToWait != ( TickType_t ) 0 )
+	{
+		/* Checking if there is data and clearing the notification state must be
+		performed atomically. */
+		taskENTER_CRITICAL();
+		{
+			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
+
+			/* If this function was invoked by a message buffer read then
+			xBytesToStoreMessageLength holds the number of bytes used to hold
+			the length of the next discrete message.  If this function was
+			invoked by a stream buffer read then xBytesToStoreMessageLength will
+			be 0. */
+			if( xBytesAvailable <= xBytesToStoreMessageLength )
+			{
+				/* Clear notification state as going to wait for data. */
+				( void ) xTaskNotifyStateClear( NULL );
+
+				/* Should only be one reader. */
+				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
+				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		if( xBytesAvailable <= xBytesToStoreMessageLength )
+		{
+			/* Wait for data to be available. */
+			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
+			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
+			pxStreamBuffer->xTaskWaitingToReceive = NULL;
+
+			/* Recheck the data available after blocking. */
+			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
+	}
+
+	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
+	holds the number of bytes used to store the message length) or a stream of
+	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
+	available must be greater than xBytesToStoreMessageLength to be able to
+	read bytes from the buffer. */
+	if( xBytesAvailable > xBytesToStoreMessageLength )
+	{
+		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
+
+		/* Was a task waiting for space in the buffer? */
+		if( xReceivedLength != ( size_t ) 0 )
+		{
+			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
+			sbRECEIVE_COMPLETED( pxStreamBuffer );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	return xReceivedLength;
+}
+/*-----------------------------------------------------------*/
+
+size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
+									void *pvRxData,
+									size_t xBufferLengthBytes,
+									BaseType_t * const pxHigherPriorityTaskWoken )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
+
+	configASSERT( pvRxData );
+	configASSERT( pxStreamBuffer );
+
+	/* This receive function is used by both message buffers, which store
+	discrete messages, and stream buffers, which store a continuous stream of
+	bytes.  Discrete messages include an additional
+	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
+	message. */
+	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
+	{
+		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
+	}
+	else
+	{
+		xBytesToStoreMessageLength = 0;
+	}
+
+	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
+
+	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
+	holds the number of bytes used to store the message length) or a stream of
+	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
+	available must be greater than xBytesToStoreMessageLength to be able to
+	read bytes from the buffer. */
+	if( xBytesAvailable > xBytesToStoreMessageLength )
+	{
+		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
+
+		/* Was a task waiting for space in the buffer? */
+		if( xReceivedLength != ( size_t ) 0 )
+		{
+			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
+
+	return xReceivedLength;
+}
+/*-----------------------------------------------------------*/
+
+static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
+										void *pvRxData,
+										size_t xBufferLengthBytes,
+										size_t xBytesAvailable,
+										size_t xBytesToStoreMessageLength )
+{
+size_t xOriginalTail, xReceivedLength, xNextMessageLength;
+
+	if( xBytesToStoreMessageLength != ( size_t ) 0 )
+	{
+		/* A discrete message is being received.  First receive the length
+		of the message.  A copy of the tail is stored so the buffer can be
+		returned to its prior state if the length of the message is too
+		large for the provided buffer. */
+		xOriginalTail = pxStreamBuffer->xTail;
+		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
+
+		/* Reduce the number of bytes available by the number of bytes just
+		read out. */
+		xBytesAvailable -= xBytesToStoreMessageLength;
+
+		/* Check there is enough space in the buffer provided by the
+		user. */
+		if( xNextMessageLength > xBufferLengthBytes )
+		{
+			/* The user has provided insufficient space to read the message
+			so return the buffer to its previous state (so the length of
+			the message is in the buffer again). */
+			pxStreamBuffer->xTail = xOriginalTail;
+			xNextMessageLength = 0;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		/* A stream of bytes is being received (as opposed to a discrete
+		message), so read as many bytes as possible. */
+		xNextMessageLength = xBufferLengthBytes;
+	}
+
+	/* Read the actual data. */
+	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
+
+	return xReceivedLength;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
+{
+const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+BaseType_t xReturn;
+size_t xTail;
+
+	configASSERT( pxStreamBuffer );
+
+	/* True if no bytes are available. */
+	xTail = pxStreamBuffer->xTail;
+	if( pxStreamBuffer->xHead == xTail )
+	{
+		xReturn = pdTRUE;
+	}
+	else
+	{
+		xReturn = pdFALSE;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
+{
+BaseType_t xReturn;
+size_t xBytesToStoreMessageLength;
+const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+
+	configASSERT( pxStreamBuffer );
+
+	/* This generic version of the receive function is used by both message
+	buffers, which store discrete messages, and stream buffers, which store a
+	continuous stream of bytes.  Discrete messages include an additional
+	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
+	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
+	{
+		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
+	}
+	else
+	{
+		xBytesToStoreMessageLength = 0;
+	}
+
+	/* True if the available space equals zero. */
+	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
+	{
+		xReturn = pdTRUE;
+	}
+	else
+	{
+		xReturn = pdFALSE;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+BaseType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+
+	configASSERT( pxStreamBuffer );
+
+	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
+		{
+			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
+										 ( uint32_t ) 0,
+										 eNoAction,
+										 pxHigherPriorityTaskWoken );
+			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
+			xReturn = pdTRUE;
+		}
+		else
+		{
+			xReturn = pdFALSE;
+		}
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
+{
+StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; /*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
+BaseType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+
+	configASSERT( pxStreamBuffer );
+
+	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
+	{
+		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
+		{
+			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
+										 ( uint32_t ) 0,
+										 eNoAction,
+										 pxHigherPriorityTaskWoken );
+			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
+			xReturn = pdTRUE;
+		}
+		else
+		{
+			xReturn = pdFALSE;
+		}
+	}
+	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
+{
+size_t xNextHead, xFirstLength;
+
+	configASSERT( xCount > ( size_t ) 0 );
+
+	xNextHead = pxStreamBuffer->xHead;
+
+	/* Calculate the number of bytes that can be added in the first write -
+	which may be less than the total number of bytes that need to be added if
+	the buffer will wrap back to the beginning. */
+	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
+
+	/* Write as many bytes as can be written in the first write. */
+	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
+	memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
+
+	/* If the number of bytes written was less than the number that could be
+	written in the first write... */
+	if( xCount > xFirstLength )
+	{
+		/* ...then write the remaining bytes to the start of the buffer. */
+		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
+		memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	xNextHead += xCount;
+	if( xNextHead >= pxStreamBuffer->xLength )
+	{
+		xNextHead -= pxStreamBuffer->xLength;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	pxStreamBuffer->xHead = xNextHead;
+
+	return xCount;
+}
+/*-----------------------------------------------------------*/
+
+static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
+{
+size_t xCount, xFirstLength, xNextTail;
+
+	/* Use the minimum of the wanted bytes and the available bytes. */
+	xCount = configMIN( xBytesAvailable, xMaxCount );
+
+	if( xCount > ( size_t ) 0 )
+	{
+		xNextTail = pxStreamBuffer->xTail;
+
+		/* Calculate the number of bytes that can be read - which may be
+		less than the number wanted if the data wraps around to the start of
+		the buffer. */
+		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
+
+		/* Obtain the number of bytes it is possible to obtain in the first
+		read.  Asserts check bounds of read and write. */
+		configASSERT( xFirstLength <= xMaxCount );
+		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
+		memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
+
+		/* If the total number of wanted bytes is greater than the number
+		that could be read in the first read... */
+		if( xCount > xFirstLength )
+		{
+			/*...then read the remaining bytes from the start of the buffer. */
+			configASSERT( xCount <= xMaxCount );
+			memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		/* Move the tail pointer to effectively remove the data read from
+		the buffer. */
+		xNextTail += xCount;
+
+		if( xNextTail >= pxStreamBuffer->xLength )
+		{
+			xNextTail -= pxStreamBuffer->xLength;
+		}
+
+		pxStreamBuffer->xTail = xNextTail;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	return xCount;
+}
+/*-----------------------------------------------------------*/
+
+static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
+{
+/* Returns the distance between xTail and xHead. */
+size_t xCount;
+
+	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
+	xCount -= pxStreamBuffer->xTail;
+	if ( xCount >= pxStreamBuffer->xLength )
+	{
+		xCount -= pxStreamBuffer->xLength;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	return xCount;
+}
+/*-----------------------------------------------------------*/
+
+static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
+										  uint8_t * const pucBuffer,
+										  size_t xBufferSizeBytes,
+										  size_t xTriggerLevelBytes,
+										  BaseType_t xIsMessageBuffer )
+{
+	/* Assert here is deliberately writing to the entire buffer to ensure it can
+	be written to without generating exceptions, and is setting the buffer to a
+	known value to assist in development/debugging. */
+	#if( configASSERT_DEFINED == 1 )
+	{
+		/* The value written just has to be identifiable when looking at the
+		memory.  Don't use 0xA5 as that is the stack fill value and could
+		result in confusion as to what is actually being observed. */
+		const BaseType_t xWriteValue = 0x55;
+		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
+	}
+	#endif
+
+	memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
+	pxStreamBuffer->pucBuffer = pucBuffer;
+	pxStreamBuffer->xLength = xBufferSizeBytes;
+	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
+
+	if( xIsMessageBuffer != pdFALSE )
+	{
+		pxStreamBuffer->ucFlags |= sbFLAGS_IS_MESSAGE_BUFFER;
+	}
+}
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
+	{
+		return ( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
+	{
+		( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber = uxStreamBufferNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
+	{
+		return ( ( StreamBuffer_t * )xStreamBuffer )->ucFlags | sbFLAGS_IS_MESSAGE_BUFFER;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/tasks.c ./libs/freertos/source/tasks.c
--- a_bRU7kv/libs/freertos/source/tasks.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/tasks.c	2018-12-01 17:15:06.609606040 -0300
@@ -0,0 +1,5045 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/* Standard includes. */
+#include <stdlib.h>
+#include <string.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+/* FreeRTOS includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+#include "timers.h"
+#include "stack_macros.h"
+
+/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
+MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
+header files above, but not in this file, in order to generate the correct
+privileged Vs unprivileged linkage and placement. */
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
+
+/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
+functions but without including stdio.h here. */
+#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
+	/* At the bottom of this file are two optional functions that can be used
+	to generate human readable text from the raw data generated by the
+	uxTaskGetSystemState() function.  Note the formatting functions are provided
+	for convenience only, and are NOT considered part of the kernel. */
+	#include <stdio.h>
+#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
+
+#if( configUSE_PREEMPTION == 0 )
+	/* If the cooperative scheduler is being used then a yield should not be
+	performed just because a higher priority task has been woken. */
+	#define taskYIELD_IF_USING_PREEMPTION()
+#else
+	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
+#endif
+
+/* Values that can be assigned to the ucNotifyState member of the TCB. */
+#define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
+#define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
+#define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
+
+/*
+ * The value used to fill the stack of a task when the task is created.  This
+ * is used purely for checking the high water mark for tasks.
+ */
+#define tskSTACK_FILL_BYTE	( 0xa5U )
+
+/* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
+dynamically allocated RAM, in which case when any task is deleted it is known
+that both the task's stack and TCB need to be freed.  Sometimes the
+FreeRTOSConfig.h settings only allow a task to be created using statically
+allocated RAM, in which case when any task is deleted it is known that neither
+the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
+settings allow a task to be created using either statically or dynamically
+allocated RAM, in which case a member of the TCB is used to record whether the
+stack and/or TCB were allocated statically or dynamically, so when a task is
+deleted the RAM that was allocated dynamically is freed again and no attempt is
+made to free the RAM that was allocated statically.
+tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
+task to be created using either statically or dynamically allocated RAM.  Note
+that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
+a statically allocated stack and a dynamically allocated TCB.
+!!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
+changed then the definition of StaticTask_t must also be updated. */
+#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
+#define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
+#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
+
+/* If any of the following are set then task stacks are filled with a known
+value so the high water mark can be determined.  If none of the following are
+set then don't fill the stack so there is no unnecessary dependency on memset. */
+#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
+	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
+#else
+	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
+#endif
+
+/*
+ * Macros used by vListTask to indicate which state a task is in.
+ */
+#define tskRUNNING_CHAR		( 'X' )
+#define tskBLOCKED_CHAR		( 'B' )
+#define tskREADY_CHAR		( 'R' )
+#define tskDELETED_CHAR		( 'D' )
+#define tskSUSPENDED_CHAR	( 'S' )
+
+/*
+ * Some kernel aware debuggers require the data the debugger needs access to be
+ * global, rather than file scope.
+ */
+#ifdef portREMOVE_STATIC_QUALIFIER
+	#define static
+#endif
+
+/* The name allocated to the Idle task.  This can be overridden by defining
+configIDLE_TASK_NAME in FreeRTOSConfig.h. */
+#ifndef configIDLE_TASK_NAME
+	#define configIDLE_TASK_NAME "IDLE"
+#endif
+
+#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
+
+	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
+	performed in a generic way that is not optimised to any particular
+	microcontroller architecture. */
+
+	/* uxTopReadyPriority holds the priority of the highest priority ready
+	state task. */
+	#define taskRECORD_READY_PRIORITY( uxPriority )														\
+	{																									\
+		if( ( uxPriority ) > uxTopReadyPriority )														\
+		{																								\
+			uxTopReadyPriority = ( uxPriority );														\
+		}																								\
+	} /* taskRECORD_READY_PRIORITY */
+
+	/*-----------------------------------------------------------*/
+
+	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
+	{																									\
+	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
+																										\
+		/* Find the highest priority queue that contains ready tasks. */								\
+		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
+		{																								\
+			configASSERT( uxTopPriority );																\
+			--uxTopPriority;																			\
+		}																								\
+																										\
+		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
+		the	same priority get an equal share of the processor time. */									\
+		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
+		uxTopReadyPriority = uxTopPriority;																\
+	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
+
+	/*-----------------------------------------------------------*/
+
+	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
+	they are only required when a port optimised method of task selection is
+	being used. */
+	#define taskRESET_READY_PRIORITY( uxPriority )
+	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
+
+#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
+
+	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
+	performed in a way that is tailored to the particular microcontroller
+	architecture being used. */
+
+	/* A port optimised version is provided.  Call the port defined macros. */
+	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
+
+	/*-----------------------------------------------------------*/
+
+	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
+	{																								\
+	UBaseType_t uxTopPriority;																		\
+																									\
+		/* Find the highest priority list that contains ready tasks. */								\
+		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
+		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
+		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
+	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
+
+	/*-----------------------------------------------------------*/
+
+	/* A port optimised version is provided, call it only if the TCB being reset
+	is being referenced from a ready list.  If it is referenced from a delayed
+	or suspended list then it won't be in a ready list. */
+	#define taskRESET_READY_PRIORITY( uxPriority )														\
+	{																									\
+		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
+		{																								\
+			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
+		}																								\
+	}
+
+#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
+
+/*-----------------------------------------------------------*/
+
+/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
+count overflows. */
+#define taskSWITCH_DELAYED_LISTS()																	\
+{																									\
+	List_t *pxTemp;																					\
+																									\
+	/* The delayed tasks list should be empty when the lists are switched. */						\
+	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
+																									\
+	pxTemp = pxDelayedTaskList;																		\
+	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
+	pxOverflowDelayedTaskList = pxTemp;																\
+	xNumOfOverflows++;																				\
+	prvResetNextTaskUnblockTime();																	\
+}
+
+/*-----------------------------------------------------------*/
+
+/*
+ * Place the task represented by pxTCB into the appropriate ready list for
+ * the task.  It is inserted at the end of the list.
+ */
+#define prvAddTaskToReadyList( pxTCB )																\
+	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
+	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
+	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
+	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
+/*-----------------------------------------------------------*/
+
+/*
+ * Several functions take an TaskHandle_t parameter that can optionally be NULL,
+ * where NULL is used to indicate that the handle of the currently executing
+ * task should be used in place of the parameter.  This macro simply checks to
+ * see if the parameter is NULL and returns a pointer to the appropriate TCB.
+ */
+#define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
+
+/* The item value of the event list item is normally used to hold the priority
+of the task to which it belongs (coded to allow it to be held in reverse
+priority order).  However, it is occasionally borrowed for other purposes.  It
+is important its value is not updated due to a task priority change while it is
+being used for another purpose.  The following bit definition is used to inform
+the scheduler that the value should not be changed - in which case it is the
+responsibility of whichever module is using the value to ensure it gets set back
+to its original value when it is released. */
+#if( configUSE_16_BIT_TICKS == 1 )
+	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
+#else
+	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
+#endif
+
+/*
+ * Task control block.  A task control block (TCB) is allocated for each task,
+ * and stores task state information, including a pointer to the task's context
+ * (the task's run time environment, including register values)
+ */
+typedef struct tskTaskControlBlock
+{
+	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
+
+	#if ( portUSING_MPU_WRAPPERS == 1 )
+		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
+	#endif
+
+	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
+	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
+	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
+	StackType_t			*pxStack;			/*< Points to the start of the stack. */
+	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
+		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
+	#endif
+
+	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
+		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
+	#endif
+
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
+		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
+	#endif
+
+	#if ( configUSE_MUTEXES == 1 )
+		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
+		UBaseType_t		uxMutexesHeld;
+	#endif
+
+	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+		TaskHookFunction_t pxTaskTag;
+	#endif
+
+	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
+		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
+	#endif
+
+	#if( configGENERATE_RUN_TIME_STATS == 1 )
+		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
+	#endif
+
+	#if ( configUSE_NEWLIB_REENTRANT == 1 )
+		/* Allocate a Newlib reent structure that is specific to this task.
+		Note Newlib support has been included by popular demand, but is not
+		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
+		responsible for resulting newlib operation.  User must be familiar with
+		newlib and must provide system-wide implementations of the necessary
+		stubs. Be warned that (at the time of writing) the current newlib design
+		implements a system-wide malloc() that must be provided with locks. */
+		struct	_reent xNewLib_reent;
+	#endif
+
+	#if( configUSE_TASK_NOTIFICATIONS == 1 )
+		volatile uint32_t ulNotifiedValue;
+		volatile uint8_t ucNotifyState;
+	#endif
+
+	/* See the comments above the definition of
+	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
+	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
+		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
+	#endif
+
+	#if( INCLUDE_xTaskAbortDelay == 1 )
+		uint8_t ucDelayAborted;
+	#endif
+
+} tskTCB;
+
+/* The old tskTCB name is maintained above then typedefed to the new TCB_t name
+below to enable the use of older kernel aware debuggers. */
+typedef tskTCB TCB_t;
+
+/*lint -save -e956 A manual analysis and inspection has been used to determine
+which static variables must be declared volatile. */
+
+PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
+
+/* Lists for ready and blocked tasks. --------------------*/
+PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
+PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
+PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
+PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
+PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
+PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
+
+#if( INCLUDE_vTaskDelete == 1 )
+
+	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
+	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
+
+#endif
+
+#if ( INCLUDE_vTaskSuspend == 1 )
+
+	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
+
+#endif
+
+/* Other file private variables. --------------------------------*/
+PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
+PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
+PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
+PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
+PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
+PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
+PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
+PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
+PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
+PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
+
+/* Context switches are held pending while the scheduler is suspended.  Also,
+interrupts must not manipulate the xStateListItem of a TCB, or any of the
+lists the xStateListItem can be referenced from, if the scheduler is suspended.
+If an interrupt needs to unblock a task while the scheduler is suspended then it
+moves the task's event list item into the xPendingReadyList, ready for the
+kernel to move the task from the pending ready list into the real ready list
+when the scheduler is unsuspended.  The pending ready list itself can only be
+accessed from a critical section. */
+PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
+
+#if ( configGENERATE_RUN_TIME_STATS == 1 )
+
+	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
+	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
+
+#endif
+
+/*lint -restore */
+
+/*-----------------------------------------------------------*/
+
+/* Callback function prototypes. --------------------------*/
+#if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
+
+	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
+
+#endif
+
+#if( configUSE_TICK_HOOK > 0 )
+
+	extern void vApplicationTickHook( void );
+
+#endif
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
+
+#endif
+
+/* File private functions. --------------------------------*/
+
+/**
+ * Utility task that simply returns pdTRUE if the task referenced by xTask is
+ * currently in the Suspended state, or pdFALSE if the task referenced by xTask
+ * is in any other state.
+ */
+#if ( INCLUDE_vTaskSuspend == 1 )
+
+	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+#endif /* INCLUDE_vTaskSuspend */
+
+/*
+ * Utility to ready all the lists used by the scheduler.  This is called
+ * automatically upon the creation of the first task.
+ */
+static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * The idle task, which as all tasks is implemented as a never ending loop.
+ * The idle task is automatically created and added to the ready lists upon
+ * creation of the first user task.
+ *
+ * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
+ * language extensions.  The equivalent prototype for this function is:
+ *
+ * void prvIdleTask( void *pvParameters );
+ *
+ */
+static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
+
+/*
+ * Utility to free all memory allocated by the scheduler to hold a TCB,
+ * including the stack pointed to by the TCB.
+ *
+ * This does not free memory allocated by the task itself (i.e. memory
+ * allocated by calls to pvPortMalloc from within the tasks application code).
+ */
+#if ( INCLUDE_vTaskDelete == 1 )
+
+	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*
+ * Used only by the idle task.  This checks to see if anything has been placed
+ * in the list of tasks waiting to be deleted.  If so the task is cleaned up
+ * and its TCB deleted.
+ */
+static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * The currently executing task is entering the Blocked state.  Add the task to
+ * either the current or the overflow delayed task list.
+ */
+static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
+
+/*
+ * Fills an TaskStatus_t structure with information on each task that is
+ * referenced from the pxList list (which may be a ready list, a delayed list,
+ * a suspended list, etc.).
+ *
+ * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
+ * NORMAL APPLICATION CODE.
+ */
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*
+ * Searches pxList for a task with name pcNameToQuery - returning a handle to
+ * the task if it is found, or NULL if the task is not found.
+ */
+#if ( INCLUDE_xTaskGetHandle == 1 )
+
+	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*
+ * When a task is created, the stack of the task is filled with a known value.
+ * This function determines the 'high water mark' of the task stack by
+ * determining how much of the stack remains at the original preset value.
+ */
+#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
+
+	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*
+ * Return the amount of time, in ticks, that will pass before the kernel will
+ * next move a task from the Blocked state to the Running state.
+ *
+ * This conditional compilation should use inequality to 0, not equality to 1.
+ * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
+ * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
+ * set to a value other than 1.
+ */
+#if ( configUSE_TICKLESS_IDLE != 0 )
+
+	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*
+ * Set xNextTaskUnblockTime to the time at which the next Blocked state task
+ * will exit the Blocked state.
+ */
+static void prvResetNextTaskUnblockTime( void );
+
+#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
+
+	/*
+	 * Helper function used to pad task names with spaces when printing out
+	 * human readable tables of task information.
+	 */
+	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*
+ * Called after a Task_t structure has been allocated either statically or
+ * dynamically to fill in the structure's members.
+ */
+static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
+									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const uint32_t ulStackDepth,
+									void * const pvParameters,
+									UBaseType_t uxPriority,
+									TaskHandle_t * const pxCreatedTask,
+									TCB_t *pxNewTCB,
+									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
+
+/*
+ * Called after a new task has been created and initialised to place the task
+ * under the control of the scheduler.
+ */
+static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
+
+/*
+ * freertos_tasks_c_additions_init() should only be called if the user definable
+ * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
+ * called by the function.
+ */
+#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
+
+	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
+									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const uint32_t ulStackDepth,
+									void * const pvParameters,
+									UBaseType_t uxPriority,
+									StackType_t * const puxStackBuffer,
+									StaticTask_t * const pxTaskBuffer )
+	{
+	TCB_t *pxNewTCB;
+	TaskHandle_t xReturn;
+
+		configASSERT( puxStackBuffer != NULL );
+		configASSERT( pxTaskBuffer != NULL );
+
+		#if( configASSERT_DEFINED == 1 )
+		{
+			/* Sanity check that the size of the structure used to declare a
+			variable of type StaticTask_t equals the size of the real task
+			structure. */
+			volatile size_t xSize = sizeof( StaticTask_t );
+			configASSERT( xSize == sizeof( TCB_t ) );
+		}
+		#endif /* configASSERT_DEFINED */
+
+
+		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
+		{
+			/* The memory used for the task's TCB and stack are passed into this
+			function - use them. */
+			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
+			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
+
+			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
+			{
+				/* Tasks can be created statically or dynamically, so note this
+				task was created statically in case the task is later deleted. */
+				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
+			}
+			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+
+			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
+			prvAddNewTaskToReadyList( pxNewTCB );
+		}
+		else
+		{
+			xReturn = NULL;
+		}
+
+		return xReturn;
+	}
+
+#endif /* SUPPORT_STATIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+
+	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
+	{
+	TCB_t *pxNewTCB;
+	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
+
+		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
+		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
+
+		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
+		{
+			/* Allocate space for the TCB.  Where the memory comes from depends
+			on the implementation of the port malloc function and whether or
+			not static allocation is being used. */
+			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
+
+			/* Store the stack location in the TCB. */
+			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
+
+			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
+			{
+				/* Tasks can be created statically or dynamically, so note this
+				task was created statically in case the task is later deleted. */
+				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
+			}
+			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+
+			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
+									pxTaskDefinition->pcName,
+									( uint32_t ) pxTaskDefinition->usStackDepth,
+									pxTaskDefinition->pvParameters,
+									pxTaskDefinition->uxPriority,
+									pxCreatedTask, pxNewTCB,
+									pxTaskDefinition->xRegions );
+
+			prvAddNewTaskToReadyList( pxNewTCB );
+			xReturn = pdPASS;
+		}
+
+		return xReturn;
+	}
+
+#endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
+/*-----------------------------------------------------------*/
+
+#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+
+	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
+	{
+	TCB_t *pxNewTCB;
+	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
+
+		configASSERT( pxTaskDefinition->puxStackBuffer );
+
+		if( pxTaskDefinition->puxStackBuffer != NULL )
+		{
+			/* Allocate space for the TCB.  Where the memory comes from depends
+			on the implementation of the port malloc function and whether or
+			not static allocation is being used. */
+			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
+
+			if( pxNewTCB != NULL )
+			{
+				/* Store the stack location in the TCB. */
+				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
+
+				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+				{
+					/* Tasks can be created statically or dynamically, so note
+					this task had a statically allocated stack in case it is
+					later deleted.  The TCB was allocated dynamically. */
+					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
+				}
+				#endif
+
+				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
+										pxTaskDefinition->pcName,
+										( uint32_t ) pxTaskDefinition->usStackDepth,
+										pxTaskDefinition->pvParameters,
+										pxTaskDefinition->uxPriority,
+										pxCreatedTask, pxNewTCB,
+										pxTaskDefinition->xRegions );
+
+				prvAddNewTaskToReadyList( pxNewTCB );
+				xReturn = pdPASS;
+			}
+		}
+
+		return xReturn;
+	}
+
+#endif /* portUSING_MPU_WRAPPERS */
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+
+	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
+							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+							const configSTACK_DEPTH_TYPE usStackDepth,
+							void * const pvParameters,
+							UBaseType_t uxPriority,
+							TaskHandle_t * const pxCreatedTask )
+	{
+	TCB_t *pxNewTCB;
+	BaseType_t xReturn;
+
+		/* If the stack grows down then allocate the stack then the TCB so the stack
+		does not grow into the TCB.  Likewise if the stack grows up then allocate
+		the TCB then the stack. */
+		#if( portSTACK_GROWTH > 0 )
+		{
+			/* Allocate space for the TCB.  Where the memory comes from depends on
+			the implementation of the port malloc function and whether or not static
+			allocation is being used. */
+			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
+
+			if( pxNewTCB != NULL )
+			{
+				/* Allocate space for the stack used by the task being created.
+				The base of the stack memory stored in the TCB so the task can
+				be deleted later if required. */
+				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+
+				if( pxNewTCB->pxStack == NULL )
+				{
+					/* Could not allocate the stack.  Delete the allocated TCB. */
+					vPortFree( pxNewTCB );
+					pxNewTCB = NULL;
+				}
+			}
+		}
+		#else /* portSTACK_GROWTH */
+		{
+		StackType_t *pxStack;
+
+			/* Allocate space for the stack used by the task being created. */
+			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+
+			if( pxStack != NULL )
+			{
+				/* Allocate space for the TCB. */
+				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
+
+				if( pxNewTCB != NULL )
+				{
+					/* Store the stack location in the TCB. */
+					pxNewTCB->pxStack = pxStack;
+				}
+				else
+				{
+					/* The stack cannot be used as the TCB was not created.  Free
+					it again. */
+					vPortFree( pxStack );
+				}
+			}
+			else
+			{
+				pxNewTCB = NULL;
+			}
+		}
+		#endif /* portSTACK_GROWTH */
+
+		if( pxNewTCB != NULL )
+		{
+			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
+			{
+				/* Tasks can be created statically or dynamically, so note this
+				task was created dynamically in case it is later deleted. */
+				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
+			}
+			#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
+			prvAddNewTaskToReadyList( pxNewTCB );
+			xReturn = pdPASS;
+		}
+		else
+		{
+			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
+		}
+
+		return xReturn;
+	}
+
+#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
+									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const uint32_t ulStackDepth,
+									void * const pvParameters,
+									UBaseType_t uxPriority,
+									TaskHandle_t * const pxCreatedTask,
+									TCB_t *pxNewTCB,
+									const MemoryRegion_t * const xRegions )
+{
+StackType_t *pxTopOfStack;
+UBaseType_t x;
+
+	#if( portUSING_MPU_WRAPPERS == 1 )
+		/* Should the task be created in privileged mode? */
+		BaseType_t xRunPrivileged;
+		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
+		{
+			xRunPrivileged = pdTRUE;
+		}
+		else
+		{
+			xRunPrivileged = pdFALSE;
+		}
+		uxPriority &= ~portPRIVILEGE_BIT;
+	#endif /* portUSING_MPU_WRAPPERS == 1 */
+
+	/* Avoid dependency on memset() if it is not required. */
+	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
+	{
+		/* Fill the stack with a known value to assist debugging. */
+		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
+	}
+	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
+
+	/* Calculate the top of stack address.  This depends on whether the stack
+	grows from high memory to low (as per the 80x86) or vice versa.
+	portSTACK_GROWTH is used to make the result positive or negative as required
+	by the port. */
+	#if( portSTACK_GROWTH < 0 )
+	{
+		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
+		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
+
+		/* Check the alignment of the calculated top of stack is correct. */
+		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
+
+		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
+		{
+			/* Also record the stack's high address, which may assist
+			debugging. */
+			pxNewTCB->pxEndOfStack = pxTopOfStack;
+		}
+		#endif /* configRECORD_STACK_HIGH_ADDRESS */
+	}
+	#else /* portSTACK_GROWTH */
+	{
+		pxTopOfStack = pxNewTCB->pxStack;
+
+		/* Check the alignment of the stack buffer is correct. */
+		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
+
+		/* The other extreme of the stack space is required if stack checking is
+		performed. */
+		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
+	}
+	#endif /* portSTACK_GROWTH */
+
+	/* Store the task name in the TCB. */
+	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
+	{
+		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
+
+		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
+		configMAX_TASK_NAME_LEN characters just in case the memory after the
+		string is not accessible (extremely unlikely). */
+		if( pcName[ x ] == 0x00 )
+		{
+			break;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+	/* Ensure the name string is terminated in the case that the string length
+	was greater or equal to configMAX_TASK_NAME_LEN. */
+	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
+
+	/* This is used as an array index so must ensure it's not too large.  First
+	remove the privilege bit if one is present. */
+	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
+	{
+		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	pxNewTCB->uxPriority = uxPriority;
+	#if ( configUSE_MUTEXES == 1 )
+	{
+		pxNewTCB->uxBasePriority = uxPriority;
+		pxNewTCB->uxMutexesHeld = 0;
+	}
+	#endif /* configUSE_MUTEXES */
+
+	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
+	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
+
+	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
+	back to	the containing TCB from a generic item in a list. */
+	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
+
+	/* Event lists are always in priority order. */
+	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
+
+	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
+	{
+		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
+	}
+	#endif /* portCRITICAL_NESTING_IN_TCB */
+
+	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+	{
+		pxNewTCB->pxTaskTag = NULL;
+	}
+	#endif /* configUSE_APPLICATION_TASK_TAG */
+
+	#if ( configGENERATE_RUN_TIME_STATS == 1 )
+	{
+		pxNewTCB->ulRunTimeCounter = 0UL;
+	}
+	#endif /* configGENERATE_RUN_TIME_STATS */
+
+	#if ( portUSING_MPU_WRAPPERS == 1 )
+	{
+		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
+	}
+	#else
+	{
+		/* Avoid compiler warning about unreferenced parameter. */
+		( void ) xRegions;
+	}
+	#endif
+
+	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
+	{
+		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
+		{
+			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
+		}
+	}
+	#endif
+
+	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
+	{
+		pxNewTCB->ulNotifiedValue = 0;
+		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
+	}
+	#endif
+
+	#if ( configUSE_NEWLIB_REENTRANT == 1 )
+	{
+		/* Initialise this task's Newlib reent structure. */
+		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
+	}
+	#endif
+
+	#if( INCLUDE_xTaskAbortDelay == 1 )
+	{
+		pxNewTCB->ucDelayAborted = pdFALSE;
+	}
+	#endif
+
+	/* Initialize the TCB stack to look as if the task was already running,
+	but had been interrupted by the scheduler.  The return address is set
+	to the start of the task function. Once the stack has been initialised
+	the top of stack variable is updated. */
+	#if( portUSING_MPU_WRAPPERS == 1 )
+	{
+		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
+	}
+	#else /* portUSING_MPU_WRAPPERS */
+	{
+		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
+	}
+	#endif /* portUSING_MPU_WRAPPERS */
+
+	if( ( void * ) pxCreatedTask != NULL )
+	{
+		/* Pass the handle out in an anonymous way.  The handle can be used to
+		change the created task's priority, delete the created task, etc.*/
+		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+}
+/*-----------------------------------------------------------*/
+
+static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
+{
+	/* Ensure interrupts don't access the task lists while the lists are being
+	updated. */
+	taskENTER_CRITICAL();
+	{
+		uxCurrentNumberOfTasks++;
+		if( pxCurrentTCB == NULL )
+		{
+			/* There are no other tasks, or all the other tasks are in
+			the suspended state - make this the current task. */
+			pxCurrentTCB = pxNewTCB;
+
+			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
+			{
+				/* This is the first task to be created so do the preliminary
+				initialisation required.  We will not recover if this call
+				fails, but we will report the failure. */
+				prvInitialiseTaskLists();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			/* If the scheduler is not already running, make this task the
+			current task if it is the highest priority task to be created
+			so far. */
+			if( xSchedulerRunning == pdFALSE )
+			{
+				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
+				{
+					pxCurrentTCB = pxNewTCB;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+
+		uxTaskNumber++;
+
+		#if ( configUSE_TRACE_FACILITY == 1 )
+		{
+			/* Add a counter into the TCB for tracing only. */
+			pxNewTCB->uxTCBNumber = uxTaskNumber;
+		}
+		#endif /* configUSE_TRACE_FACILITY */
+		traceTASK_CREATE( pxNewTCB );
+
+		prvAddTaskToReadyList( pxNewTCB );
+
+		portSETUP_TCB( pxNewTCB );
+	}
+	taskEXIT_CRITICAL();
+
+	if( xSchedulerRunning != pdFALSE )
+	{
+		/* If the created task is of a higher priority than the current task
+		then it should run now. */
+		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
+		{
+			taskYIELD_IF_USING_PREEMPTION();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+}
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskDelete == 1 )
+
+	void vTaskDelete( TaskHandle_t xTaskToDelete )
+	{
+	TCB_t *pxTCB;
+
+		taskENTER_CRITICAL();
+		{
+			/* If null is passed in here then it is the calling task that is
+			being deleted. */
+			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
+
+			/* Remove task from the ready list. */
+			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+			{
+				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			/* Is the task waiting on an event also? */
+			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
+			{
+				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			/* Increment the uxTaskNumber also so kernel aware debuggers can
+			detect that the task lists need re-generating.  This is done before
+			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
+			not return. */
+			uxTaskNumber++;
+
+			if( pxTCB == pxCurrentTCB )
+			{
+				/* A task is deleting itself.  This cannot complete within the
+				task itself, as a context switch to another task is required.
+				Place the task in the termination list.  The idle task will
+				check the termination list and free up any memory allocated by
+				the scheduler for the TCB and stack of the deleted task. */
+				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
+
+				/* Increment the ucTasksDeleted variable so the idle task knows
+				there is a task that has been deleted and that it should therefore
+				check the xTasksWaitingTermination list. */
+				++uxDeletedTasksWaitingCleanUp;
+
+				/* The pre-delete hook is primarily for the Windows simulator,
+				in which Windows specific clean up operations are performed,
+				after which it is not possible to yield away from this task -
+				hence xYieldPending is used to latch that a context switch is
+				required. */
+				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
+			}
+			else
+			{
+				--uxCurrentNumberOfTasks;
+				prvDeleteTCB( pxTCB );
+
+				/* Reset the next expected unblock time in case it referred to
+				the task that has just been deleted. */
+				prvResetNextTaskUnblockTime();
+			}
+
+			traceTASK_DELETE( pxTCB );
+		}
+		taskEXIT_CRITICAL();
+
+		/* Force a reschedule if it is the currently running task that has just
+		been deleted. */
+		if( xSchedulerRunning != pdFALSE )
+		{
+			if( pxTCB == pxCurrentTCB )
+			{
+				configASSERT( uxSchedulerSuspended == 0 );
+				portYIELD_WITHIN_API();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+	}
+
+#endif /* INCLUDE_vTaskDelete */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskDelayUntil == 1 )
+
+	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
+	{
+	TickType_t xTimeToWake;
+	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
+
+		configASSERT( pxPreviousWakeTime );
+		configASSERT( ( xTimeIncrement > 0U ) );
+		configASSERT( uxSchedulerSuspended == 0 );
+
+		vTaskSuspendAll();
+		{
+			/* Minor optimisation.  The tick count cannot change in this
+			block. */
+			const TickType_t xConstTickCount = xTickCount;
+
+			/* Generate the tick time at which the task wants to wake. */
+			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
+
+			if( xConstTickCount < *pxPreviousWakeTime )
+			{
+				/* The tick count has overflowed since this function was
+				lasted called.  In this case the only time we should ever
+				actually delay is if the wake time has also	overflowed,
+				and the wake time is greater than the tick time.  When this
+				is the case it is as if neither time had overflowed. */
+				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
+				{
+					xShouldDelay = pdTRUE;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				/* The tick time has not overflowed.  In this case we will
+				delay if either the wake time has overflowed, and/or the
+				tick time is less than the wake time. */
+				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
+				{
+					xShouldDelay = pdTRUE;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+
+			/* Update the wake time ready for the next call. */
+			*pxPreviousWakeTime = xTimeToWake;
+
+			if( xShouldDelay != pdFALSE )
+			{
+				traceTASK_DELAY_UNTIL( xTimeToWake );
+
+				/* prvAddCurrentTaskToDelayedList() needs the block time, not
+				the time to wake, so subtract the current tick count. */
+				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		xAlreadyYielded = xTaskResumeAll();
+
+		/* Force a reschedule if xTaskResumeAll has not already done so, we may
+		have put ourselves to sleep. */
+		if( xAlreadyYielded == pdFALSE )
+		{
+			portYIELD_WITHIN_API();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* INCLUDE_vTaskDelayUntil */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskDelay == 1 )
+
+	void vTaskDelay( const TickType_t xTicksToDelay )
+	{
+	BaseType_t xAlreadyYielded = pdFALSE;
+
+		/* A delay time of zero just forces a reschedule. */
+		if( xTicksToDelay > ( TickType_t ) 0U )
+		{
+			configASSERT( uxSchedulerSuspended == 0 );
+			vTaskSuspendAll();
+			{
+				traceTASK_DELAY();
+
+				/* A task that is removed from the event list while the
+				scheduler is suspended will not get placed in the ready
+				list or removed from the blocked list until the scheduler
+				is resumed.
+
+				This task cannot be in an event list as it is the currently
+				executing task. */
+				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
+			}
+			xAlreadyYielded = xTaskResumeAll();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		/* Force a reschedule if xTaskResumeAll has not already done so, we may
+		have put ourselves to sleep. */
+		if( xAlreadyYielded == pdFALSE )
+		{
+			portYIELD_WITHIN_API();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* INCLUDE_vTaskDelay */
+/*-----------------------------------------------------------*/
+
+#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
+
+	eTaskState eTaskGetState( TaskHandle_t xTask )
+	{
+	eTaskState eReturn;
+	List_t *pxStateList;
+	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
+
+		configASSERT( pxTCB );
+
+		if( pxTCB == pxCurrentTCB )
+		{
+			/* The task calling this function is querying its own state. */
+			eReturn = eRunning;
+		}
+		else
+		{
+			taskENTER_CRITICAL();
+			{
+				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
+			}
+			taskEXIT_CRITICAL();
+
+			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
+			{
+				/* The task being queried is referenced from one of the Blocked
+				lists. */
+				eReturn = eBlocked;
+			}
+
+			#if ( INCLUDE_vTaskSuspend == 1 )
+				else if( pxStateList == &xSuspendedTaskList )
+				{
+					/* The task being queried is referenced from the suspended
+					list.  Is it genuinely suspended or is it block
+					indefinitely? */
+					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
+					{
+						eReturn = eSuspended;
+					}
+					else
+					{
+						eReturn = eBlocked;
+					}
+				}
+			#endif
+
+			#if ( INCLUDE_vTaskDelete == 1 )
+				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
+				{
+					/* The task being queried is referenced from the deleted
+					tasks list, or it is not referenced from any lists at
+					all. */
+					eReturn = eDeleted;
+				}
+			#endif
+
+			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
+			{
+				/* If the task is not in any other state, it must be in the
+				Ready (including pending ready) state. */
+				eReturn = eReady;
+			}
+		}
+
+		return eReturn;
+	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
+
+#endif /* INCLUDE_eTaskGetState */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_uxTaskPriorityGet == 1 )
+
+	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
+	{
+	TCB_t *pxTCB;
+	UBaseType_t uxReturn;
+
+		taskENTER_CRITICAL();
+		{
+			/* If null is passed in here then it is the priority of the that
+			called uxTaskPriorityGet() that is being queried. */
+			pxTCB = prvGetTCBFromHandle( xTask );
+			uxReturn = pxTCB->uxPriority;
+		}
+		taskEXIT_CRITICAL();
+
+		return uxReturn;
+	}
+
+#endif /* INCLUDE_uxTaskPriorityGet */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_uxTaskPriorityGet == 1 )
+
+	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
+	{
+	TCB_t *pxTCB;
+	UBaseType_t uxReturn, uxSavedInterruptState;
+
+		/* RTOS ports that support interrupt nesting have the concept of a
+		maximum	system call (or maximum API call) interrupt priority.
+		Interrupts that are	above the maximum system call priority are keep
+		permanently enabled, even when the RTOS kernel is in a critical section,
+		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
+		is defined in FreeRTOSConfig.h then
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+		failure if a FreeRTOS API function is called from an interrupt that has
+		been assigned a priority above the configured maximum system call
+		priority.  Only FreeRTOS functions that end in FromISR can be called
+		from interrupts	that have been assigned a priority at or (logically)
+		below the maximum system call interrupt priority.  FreeRTOS maintains a
+		separate interrupt safe API to ensure interrupt entry is as fast and as
+		simple as possible.  More information (albeit Cortex-M specific) is
+		provided on the following link:
+		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
+		{
+			/* If null is passed in here then it is the priority of the calling
+			task that is being queried. */
+			pxTCB = prvGetTCBFromHandle( xTask );
+			uxReturn = pxTCB->uxPriority;
+		}
+		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
+
+		return uxReturn;
+	}
+
+#endif /* INCLUDE_uxTaskPriorityGet */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskPrioritySet == 1 )
+
+	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
+	{
+	TCB_t *pxTCB;
+	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
+	BaseType_t xYieldRequired = pdFALSE;
+
+		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
+
+		/* Ensure the new priority is valid. */
+		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
+		{
+			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		taskENTER_CRITICAL();
+		{
+			/* If null is passed in here then it is the priority of the calling
+			task that is being changed. */
+			pxTCB = prvGetTCBFromHandle( xTask );
+
+			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
+
+			#if ( configUSE_MUTEXES == 1 )
+			{
+				uxCurrentBasePriority = pxTCB->uxBasePriority;
+			}
+			#else
+			{
+				uxCurrentBasePriority = pxTCB->uxPriority;
+			}
+			#endif
+
+			if( uxCurrentBasePriority != uxNewPriority )
+			{
+				/* The priority change may have readied a task of higher
+				priority than the calling task. */
+				if( uxNewPriority > uxCurrentBasePriority )
+				{
+					if( pxTCB != pxCurrentTCB )
+					{
+						/* The priority of a task other than the currently
+						running task is being raised.  Is the priority being
+						raised above that of the running task? */
+						if( uxNewPriority >= pxCurrentTCB->uxPriority )
+						{
+							xYieldRequired = pdTRUE;
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						/* The priority of the running task is being raised,
+						but the running task must already be the highest
+						priority task able to run so no yield is required. */
+					}
+				}
+				else if( pxTCB == pxCurrentTCB )
+				{
+					/* Setting the priority of the running task down means
+					there may now be another task of higher priority that
+					is ready to execute. */
+					xYieldRequired = pdTRUE;
+				}
+				else
+				{
+					/* Setting the priority of any other task down does not
+					require a yield as the running task must be above the
+					new priority of the task being modified. */
+				}
+
+				/* Remember the ready list the task might be referenced from
+				before its uxPriority member is changed so the
+				taskRESET_READY_PRIORITY() macro can function correctly. */
+				uxPriorityUsedOnEntry = pxTCB->uxPriority;
+
+				#if ( configUSE_MUTEXES == 1 )
+				{
+					/* Only change the priority being used if the task is not
+					currently using an inherited priority. */
+					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
+					{
+						pxTCB->uxPriority = uxNewPriority;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* The base priority gets set whatever. */
+					pxTCB->uxBasePriority = uxNewPriority;
+				}
+				#else
+				{
+					pxTCB->uxPriority = uxNewPriority;
+				}
+				#endif
+
+				/* Only reset the event list item value if the value is not
+				being used for anything else. */
+				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
+				{
+					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				/* If the task is in the blocked or suspended list we need do
+				nothing more than change its priority variable. However, if
+				the task is in a ready list it needs to be removed and placed
+				in the list appropriate to its new priority. */
+				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
+				{
+					/* The task is currently in its ready list - remove before
+					adding it to it's new ready list.  As we are in a critical
+					section we can do this even if the scheduler is suspended. */
+					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+					{
+						/* It is known that the task is in its ready list so
+						there is no need to check again and the port level
+						reset macro can be called directly. */
+						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+					prvAddTaskToReadyList( pxTCB );
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				if( xYieldRequired != pdFALSE )
+				{
+					taskYIELD_IF_USING_PREEMPTION();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				/* Remove compiler warning about unused variables when the port
+				optimised task selection is not being used. */
+				( void ) uxPriorityUsedOnEntry;
+			}
+		}
+		taskEXIT_CRITICAL();
+	}
+
+#endif /* INCLUDE_vTaskPrioritySet */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskSuspend == 1 )
+
+	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
+	{
+	TCB_t *pxTCB;
+
+		taskENTER_CRITICAL();
+		{
+			/* If null is passed in here then it is the running task that is
+			being suspended. */
+			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
+
+			traceTASK_SUSPEND( pxTCB );
+
+			/* Remove task from the ready/delayed list and place in the
+			suspended list. */
+			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+			{
+				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			/* Is the task waiting on an event also? */
+			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
+			{
+				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
+
+			#if( configUSE_TASK_NOTIFICATIONS == 1 )
+			{
+				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
+				{
+					/* The task was blocked to wait for a notification, but is
+					now suspended, so no notification was received. */
+					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
+				}
+			}
+			#endif
+		}
+		taskEXIT_CRITICAL();
+
+		if( xSchedulerRunning != pdFALSE )
+		{
+			/* Reset the next expected unblock time in case it referred to the
+			task that is now in the Suspended state. */
+			taskENTER_CRITICAL();
+			{
+				prvResetNextTaskUnblockTime();
+			}
+			taskEXIT_CRITICAL();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		if( pxTCB == pxCurrentTCB )
+		{
+			if( xSchedulerRunning != pdFALSE )
+			{
+				/* The current task has just been suspended. */
+				configASSERT( uxSchedulerSuspended == 0 );
+				portYIELD_WITHIN_API();
+			}
+			else
+			{
+				/* The scheduler is not running, but the task that was pointed
+				to by pxCurrentTCB has just been suspended and pxCurrentTCB
+				must be adjusted to point to a different task. */
+				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
+				{
+					/* No other tasks are ready, so set pxCurrentTCB back to
+					NULL so when the next task is created pxCurrentTCB will
+					be set to point to it no matter what its relative priority
+					is. */
+					pxCurrentTCB = NULL;
+				}
+				else
+				{
+					vTaskSwitchContext();
+				}
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* INCLUDE_vTaskSuspend */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskSuspend == 1 )
+
+	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
+	{
+	BaseType_t xReturn = pdFALSE;
+	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
+
+		/* Accesses xPendingReadyList so must be called from a critical
+		section. */
+
+		/* It does not make sense to check if the calling task is suspended. */
+		configASSERT( xTask );
+
+		/* Is the task being resumed actually in the suspended list? */
+		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
+		{
+			/* Has the task already been resumed from within an ISR? */
+			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
+			{
+				/* Is it in the suspended list because it is in the	Suspended
+				state, or because is is blocked with no timeout? */
+				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
+				{
+					xReturn = pdTRUE;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return xReturn;
+	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
+
+#endif /* INCLUDE_vTaskSuspend */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskSuspend == 1 )
+
+	void vTaskResume( TaskHandle_t xTaskToResume )
+	{
+	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
+
+		/* It does not make sense to resume the calling task. */
+		configASSERT( xTaskToResume );
+
+		/* The parameter cannot be NULL as it is impossible to resume the
+		currently executing task. */
+		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
+		{
+			taskENTER_CRITICAL();
+			{
+				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
+				{
+					traceTASK_RESUME( pxTCB );
+
+					/* The ready list can be accessed even if the scheduler is
+					suspended because this is inside a critical section. */
+					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
+					prvAddTaskToReadyList( pxTCB );
+
+					/* A higher priority task may have just been resumed. */
+					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
+					{
+						/* This yield may not cause the task just resumed to run,
+						but will leave the lists in the correct state for the
+						next yield. */
+						taskYIELD_IF_USING_PREEMPTION();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			taskEXIT_CRITICAL();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* INCLUDE_vTaskSuspend */
+
+/*-----------------------------------------------------------*/
+
+#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
+
+	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
+	{
+	BaseType_t xYieldRequired = pdFALSE;
+	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
+	UBaseType_t uxSavedInterruptStatus;
+
+		configASSERT( xTaskToResume );
+
+		/* RTOS ports that support interrupt nesting have the concept of a
+		maximum	system call (or maximum API call) interrupt priority.
+		Interrupts that are	above the maximum system call priority are keep
+		permanently enabled, even when the RTOS kernel is in a critical section,
+		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
+		is defined in FreeRTOSConfig.h then
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+		failure if a FreeRTOS API function is called from an interrupt that has
+		been assigned a priority above the configured maximum system call
+		priority.  Only FreeRTOS functions that end in FromISR can be called
+		from interrupts	that have been assigned a priority at or (logically)
+		below the maximum system call interrupt priority.  FreeRTOS maintains a
+		separate interrupt safe API to ensure interrupt entry is as fast and as
+		simple as possible.  More information (albeit Cortex-M specific) is
+		provided on the following link:
+		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+		{
+			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
+			{
+				traceTASK_RESUME_FROM_ISR( pxTCB );
+
+				/* Check the ready lists can be accessed. */
+				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+				{
+					/* Ready lists can be accessed so move the task from the
+					suspended list to the ready list directly. */
+					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
+					{
+						xYieldRequired = pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+					prvAddTaskToReadyList( pxTCB );
+				}
+				else
+				{
+					/* The delayed or ready lists cannot be accessed so the task
+					is held in the pending ready list until the scheduler is
+					unsuspended. */
+					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+		return xYieldRequired;
+	}
+
+#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+void vTaskStartScheduler( void )
+{
+BaseType_t xReturn;
+
+	/* Add the idle task at the lowest priority. */
+	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	{
+		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
+		StackType_t *pxIdleTaskStackBuffer = NULL;
+		uint32_t ulIdleTaskStackSize;
+
+		/* The Idle task is created using user provided RAM - obtain the
+		address of the RAM then create the idle task. */
+		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
+		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
+												configIDLE_TASK_NAME,
+												ulIdleTaskStackSize,
+												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
+												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
+												pxIdleTaskStackBuffer,
+												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
+
+		if( xIdleTaskHandle != NULL )
+		{
+			xReturn = pdPASS;
+		}
+		else
+		{
+			xReturn = pdFAIL;
+		}
+	}
+	#else
+	{
+		/* The Idle task is being created using dynamically allocated RAM. */
+		xReturn = xTaskCreate(	prvIdleTask,
+								configIDLE_TASK_NAME,
+								configMINIMAL_STACK_SIZE,
+								( void * ) NULL,
+								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
+								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
+	}
+	#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+	#if ( configUSE_TIMERS == 1 )
+	{
+		if( xReturn == pdPASS )
+		{
+			xReturn = xTimerCreateTimerTask();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	#endif /* configUSE_TIMERS */
+
+	if( xReturn == pdPASS )
+	{
+		/* freertos_tasks_c_additions_init() should only be called if the user
+		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
+		the only macro called by the function. */
+		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
+		{
+			freertos_tasks_c_additions_init();
+		}
+		#endif
+
+		/* Interrupts are turned off here, to ensure a tick does not occur
+		before or during the call to xPortStartScheduler().  The stacks of
+		the created tasks contain a status word with interrupts switched on
+		so interrupts will automatically get re-enabled when the first task
+		starts to run. */
+		portDISABLE_INTERRUPTS();
+
+		#if ( configUSE_NEWLIB_REENTRANT == 1 )
+		{
+			/* Switch Newlib's _impure_ptr variable to point to the _reent
+			structure specific to the task that will run first. */
+			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
+		}
+		#endif /* configUSE_NEWLIB_REENTRANT */
+
+		xNextTaskUnblockTime = portMAX_DELAY;
+		xSchedulerRunning = pdTRUE;
+		xTickCount = ( TickType_t ) 0U;
+
+		/* If configGENERATE_RUN_TIME_STATS is defined then the following
+		macro must be defined to configure the timer/counter used to generate
+		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
+		is set to 0 and the following line fails to build then ensure you do not
+		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
+		FreeRTOSConfig.h file. */
+		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
+
+		/* Setting up the timer tick is hardware specific and thus in the
+		portable interface. */
+		if( xPortStartScheduler() != pdFALSE )
+		{
+			/* Should not reach here as if the scheduler is running the
+			function will not return. */
+		}
+		else
+		{
+			/* Should only reach here if a task calls xTaskEndScheduler(). */
+		}
+	}
+	else
+	{
+		/* This line will only be reached if the kernel could not be started,
+		because there was not enough FreeRTOS heap to create the idle task
+		or the timer task. */
+		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
+	}
+
+	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
+	meaning xIdleTaskHandle is not used anywhere else. */
+	( void ) xIdleTaskHandle;
+}
+/*-----------------------------------------------------------*/
+
+void vTaskEndScheduler( void )
+{
+	/* Stop the scheduler interrupts and call the portable scheduler end
+	routine so the original ISRs can be restored if necessary.  The port
+	layer must ensure interrupts enable	bit is left in the correct state. */
+	portDISABLE_INTERRUPTS();
+	xSchedulerRunning = pdFALSE;
+	vPortEndScheduler();
+}
+/*----------------------------------------------------------*/
+
+void vTaskSuspendAll( void )
+{
+	/* A critical section is not required as the variable is of type
+	BaseType_t.  Please read Richard Barry's reply in the following link to a
+	post in the FreeRTOS support forum before reporting this as a bug! -
+	http://goo.gl/wu4acr */
+	++uxSchedulerSuspended;
+}
+/*----------------------------------------------------------*/
+
+#if ( configUSE_TICKLESS_IDLE != 0 )
+
+	static TickType_t prvGetExpectedIdleTime( void )
+	{
+	TickType_t xReturn;
+	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
+
+		/* uxHigherPriorityReadyTasks takes care of the case where
+		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
+		task that are in the Ready state, even though the idle task is
+		running. */
+		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
+		{
+			if( uxTopReadyPriority > tskIDLE_PRIORITY )
+			{
+				uxHigherPriorityReadyTasks = pdTRUE;
+			}
+		}
+		#else
+		{
+			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
+
+			/* When port optimised task selection is used the uxTopReadyPriority
+			variable is used as a bit map.  If bits other than the least
+			significant bit are set then there are tasks that have a priority
+			above the idle priority that are in the Ready state.  This takes
+			care of the case where the co-operative scheduler is in use. */
+			if( uxTopReadyPriority > uxLeastSignificantBit )
+			{
+				uxHigherPriorityReadyTasks = pdTRUE;
+			}
+		}
+		#endif
+
+		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
+		{
+			xReturn = 0;
+		}
+		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
+		{
+			/* There are other idle priority tasks in the ready state.  If
+			time slicing is used then the very next tick interrupt must be
+			processed. */
+			xReturn = 0;
+		}
+		else if( uxHigherPriorityReadyTasks != pdFALSE )
+		{
+			/* There are tasks in the Ready state that have a priority above the
+			idle priority.  This path can only be reached if
+			configUSE_PREEMPTION is 0. */
+			xReturn = 0;
+		}
+		else
+		{
+			xReturn = xNextTaskUnblockTime - xTickCount;
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_TICKLESS_IDLE */
+/*----------------------------------------------------------*/
+
+BaseType_t xTaskResumeAll( void )
+{
+TCB_t *pxTCB = NULL;
+BaseType_t xAlreadyYielded = pdFALSE;
+
+	/* If uxSchedulerSuspended is zero then this function does not match a
+	previous call to vTaskSuspendAll(). */
+	configASSERT( uxSchedulerSuspended );
+
+	/* It is possible that an ISR caused a task to be removed from an event
+	list while the scheduler was suspended.  If this was the case then the
+	removed task will have been added to the xPendingReadyList.  Once the
+	scheduler has been resumed it is safe to move all the pending ready
+	tasks from this list into their appropriate ready list. */
+	taskENTER_CRITICAL();
+	{
+		--uxSchedulerSuspended;
+
+		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+		{
+			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
+			{
+				/* Move any readied tasks from the pending list into the
+				appropriate ready list. */
+				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
+				{
+					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
+					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
+					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+					prvAddTaskToReadyList( pxTCB );
+
+					/* If the moved task has a priority higher than the current
+					task then a yield must be performed. */
+					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
+					{
+						xYieldPending = pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+
+				if( pxTCB != NULL )
+				{
+					/* A task was unblocked while the scheduler was suspended,
+					which may have prevented the next unblock time from being
+					re-calculated, in which case re-calculate it now.  Mainly
+					important for low power tickless implementations, where
+					this can prevent an unnecessary exit from low power
+					state. */
+					prvResetNextTaskUnblockTime();
+				}
+
+				/* If any ticks occurred while the scheduler was suspended then
+				they should be processed now.  This ensures the tick count does
+				not	slip, and that any delayed tasks are resumed at the correct
+				time. */
+				{
+					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
+
+					if( uxPendedCounts > ( UBaseType_t ) 0U )
+					{
+						do
+						{
+							if( xTaskIncrementTick() != pdFALSE )
+							{
+								xYieldPending = pdTRUE;
+							}
+							else
+							{
+								mtCOVERAGE_TEST_MARKER();
+							}
+							--uxPendedCounts;
+						} while( uxPendedCounts > ( UBaseType_t ) 0U );
+
+						uxPendedTicks = 0;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+
+				if( xYieldPending != pdFALSE )
+				{
+					#if( configUSE_PREEMPTION != 0 )
+					{
+						xAlreadyYielded = pdTRUE;
+					}
+					#endif
+					taskYIELD_IF_USING_PREEMPTION();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	taskEXIT_CRITICAL();
+
+	return xAlreadyYielded;
+}
+/*-----------------------------------------------------------*/
+
+TickType_t xTaskGetTickCount( void )
+{
+TickType_t xTicks;
+
+	/* Critical section required if running on a 16 bit processor. */
+	portTICK_TYPE_ENTER_CRITICAL();
+	{
+		xTicks = xTickCount;
+	}
+	portTICK_TYPE_EXIT_CRITICAL();
+
+	return xTicks;
+}
+/*-----------------------------------------------------------*/
+
+TickType_t xTaskGetTickCountFromISR( void )
+{
+TickType_t xReturn;
+UBaseType_t uxSavedInterruptStatus;
+
+	/* RTOS ports that support interrupt nesting have the concept of a maximum
+	system call (or maximum API call) interrupt priority.  Interrupts that are
+	above the maximum system call priority are kept permanently enabled, even
+	when the RTOS kernel is in a critical section, but cannot make any calls to
+	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
+	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+	failure if a FreeRTOS API function is called from an interrupt that has been
+	assigned a priority above the configured maximum system call priority.
+	Only FreeRTOS functions that end in FromISR can be called from interrupts
+	that have been assigned a priority at or (logically) below the maximum
+	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
+	safe API to ensure interrupt entry is as fast and as simple as possible.
+	More information (albeit Cortex-M specific) is provided on the following
+	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
+	{
+		xReturn = xTickCount;
+	}
+	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+UBaseType_t uxTaskGetNumberOfTasks( void )
+{
+	/* A critical section is not required because the variables are of type
+	BaseType_t. */
+	return uxCurrentNumberOfTasks;
+}
+/*-----------------------------------------------------------*/
+
+char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+{
+TCB_t *pxTCB;
+
+	/* If null is passed in here then the name of the calling task is being
+	queried. */
+	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
+	configASSERT( pxTCB );
+	return &( pxTCB->pcTaskName[ 0 ] );
+}
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_xTaskGetHandle == 1 )
+
+	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
+	{
+	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
+	UBaseType_t x;
+	char cNextChar;
+
+		/* This function is called with the scheduler suspended. */
+
+		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
+		{
+			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
+
+			do
+			{
+				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
+
+				/* Check each character in the name looking for a match or
+				mismatch. */
+				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
+				{
+					cNextChar = pxNextTCB->pcTaskName[ x ];
+
+					if( cNextChar != pcNameToQuery[ x ] )
+					{
+						/* Characters didn't match. */
+						break;
+					}
+					else if( cNextChar == 0x00 )
+					{
+						/* Both strings terminated, a match must have been
+						found. */
+						pxReturn = pxNextTCB;
+						break;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+
+				if( pxReturn != NULL )
+				{
+					/* The handle has been found. */
+					break;
+				}
+
+			} while( pxNextTCB != pxFirstTCB );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return pxReturn;
+	}
+
+#endif /* INCLUDE_xTaskGetHandle */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_xTaskGetHandle == 1 )
+
+	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	{
+	UBaseType_t uxQueue = configMAX_PRIORITIES;
+	TCB_t* pxTCB;
+
+		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
+		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
+
+		vTaskSuspendAll();
+		{
+			/* Search the ready lists. */
+			do
+			{
+				uxQueue--;
+				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
+
+				if( pxTCB != NULL )
+				{
+					/* Found the handle. */
+					break;
+				}
+
+			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+
+			/* Search the delayed lists. */
+			if( pxTCB == NULL )
+			{
+				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
+			}
+
+			if( pxTCB == NULL )
+			{
+				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
+			}
+
+			#if ( INCLUDE_vTaskSuspend == 1 )
+			{
+				if( pxTCB == NULL )
+				{
+					/* Search the suspended list. */
+					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
+				}
+			}
+			#endif
+
+			#if( INCLUDE_vTaskDelete == 1 )
+			{
+				if( pxTCB == NULL )
+				{
+					/* Search the deleted list. */
+					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
+				}
+			}
+			#endif
+		}
+		( void ) xTaskResumeAll();
+
+		return ( TaskHandle_t ) pxTCB;
+	}
+
+#endif /* INCLUDE_xTaskGetHandle */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
+	{
+	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
+
+		vTaskSuspendAll();
+		{
+			/* Is there a space in the array for each task in the system? */
+			if( uxArraySize >= uxCurrentNumberOfTasks )
+			{
+				/* Fill in an TaskStatus_t structure with information on each
+				task in the Ready state. */
+				do
+				{
+					uxQueue--;
+					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
+
+				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+
+				/* Fill in an TaskStatus_t structure with information on each
+				task in the Blocked state. */
+				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
+				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
+
+				#if( INCLUDE_vTaskDelete == 1 )
+				{
+					/* Fill in an TaskStatus_t structure with information on
+					each task that has been deleted but not yet cleaned up. */
+					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
+				}
+				#endif
+
+				#if ( INCLUDE_vTaskSuspend == 1 )
+				{
+					/* Fill in an TaskStatus_t structure with information on
+					each task in the Suspended state. */
+					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
+				}
+				#endif
+
+				#if ( configGENERATE_RUN_TIME_STATS == 1)
+				{
+					if( pulTotalRunTime != NULL )
+					{
+						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
+							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
+						#else
+							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
+						#endif
+					}
+				}
+				#else
+				{
+					if( pulTotalRunTime != NULL )
+					{
+						*pulTotalRunTime = 0;
+					}
+				}
+				#endif
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		( void ) xTaskResumeAll();
+
+		return uxTask;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*----------------------------------------------------------*/
+
+#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
+
+	TaskHandle_t xTaskGetIdleTaskHandle( void )
+	{
+		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
+		started, then xIdleTaskHandle will be NULL. */
+		configASSERT( ( xIdleTaskHandle != NULL ) );
+		return xIdleTaskHandle;
+	}
+
+#endif /* INCLUDE_xTaskGetIdleTaskHandle */
+/*----------------------------------------------------------*/
+
+/* This conditional compilation should use inequality to 0, not equality to 1.
+This is to ensure vTaskStepTick() is available when user defined low power mode
+implementations require configUSE_TICKLESS_IDLE to be set to a value other than
+1. */
+#if ( configUSE_TICKLESS_IDLE != 0 )
+
+	void vTaskStepTick( const TickType_t xTicksToJump )
+	{
+		/* Correct the tick count value after a period during which the tick
+		was suppressed.  Note this does *not* call the tick hook function for
+		each stepped tick. */
+		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
+		xTickCount += xTicksToJump;
+		traceINCREASE_TICK_COUNT( xTicksToJump );
+	}
+
+#endif /* configUSE_TICKLESS_IDLE */
+/*----------------------------------------------------------*/
+
+#if ( INCLUDE_xTaskAbortDelay == 1 )
+
+	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
+	{
+	TCB_t *pxTCB = ( TCB_t * ) xTask;
+	BaseType_t xReturn;
+
+		configASSERT( pxTCB );
+
+		vTaskSuspendAll();
+		{
+			/* A task can only be prematurely removed from the Blocked state if
+			it is actually in the Blocked state. */
+			if( eTaskGetState( xTask ) == eBlocked )
+			{
+				xReturn = pdPASS;
+
+				/* Remove the reference to the task from the blocked list.  An
+				interrupt won't touch the xStateListItem because the
+				scheduler is suspended. */
+				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+
+				/* Is the task waiting on an event also?  If so remove it from
+				the event list too.  Interrupts can touch the event list item,
+				even though the scheduler is suspended, so a critical section
+				is used. */
+				taskENTER_CRITICAL();
+				{
+					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
+					{
+						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
+						pxTCB->ucDelayAborted = pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				taskEXIT_CRITICAL();
+
+				/* Place the unblocked task into the appropriate ready list. */
+				prvAddTaskToReadyList( pxTCB );
+
+				/* A task being unblocked cannot cause an immediate context
+				switch if preemption is turned off. */
+				#if (  configUSE_PREEMPTION == 1 )
+				{
+					/* Preemption is on, but a context switch should only be
+					performed if the unblocked task has a priority that is
+					equal to or higher than the currently executing task. */
+					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
+					{
+						/* Pend the yield to be performed when the scheduler
+						is unsuspended. */
+						xYieldPending = pdTRUE;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				#endif /* configUSE_PREEMPTION */
+			}
+			else
+			{
+				xReturn = pdFAIL;
+			}
+		}
+		( void ) xTaskResumeAll();
+
+		return xReturn;
+	}
+
+#endif /* INCLUDE_xTaskAbortDelay */
+/*----------------------------------------------------------*/
+
+BaseType_t xTaskIncrementTick( void )
+{
+TCB_t * pxTCB;
+TickType_t xItemValue;
+BaseType_t xSwitchRequired = pdFALSE;
+
+	/* Called by the portable layer each time a tick interrupt occurs.
+	Increments the tick then checks to see if the new tick value will cause any
+	tasks to be unblocked. */
+	traceTASK_INCREMENT_TICK( xTickCount );
+	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+	{
+		/* Minor optimisation.  The tick count cannot change in this
+		block. */
+		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
+
+		/* Increment the RTOS tick, switching the delayed and overflowed
+		delayed lists if it wraps to 0. */
+		xTickCount = xConstTickCount;
+
+		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
+		{
+			taskSWITCH_DELAYED_LISTS();
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		/* See if this tick has made a timeout expire.  Tasks are stored in
+		the	queue in the order of their wake time - meaning once one task
+		has been found whose block time has not expired there is no need to
+		look any further down the list. */
+		if( xConstTickCount >= xNextTaskUnblockTime )
+		{
+			for( ;; )
+			{
+				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
+				{
+					/* The delayed list is empty.  Set xNextTaskUnblockTime
+					to the maximum possible value so it is extremely
+					unlikely that the
+					if( xTickCount >= xNextTaskUnblockTime ) test will pass
+					next time through. */
+					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+					break;
+				}
+				else
+				{
+					/* The delayed list is not empty, get the value of the
+					item at the head of the delayed list.  This is the time
+					at which the task at the head of the delayed list must
+					be removed from the Blocked state. */
+					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
+					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
+
+					if( xConstTickCount < xItemValue )
+					{
+						/* It is not time to unblock this item yet, but the
+						item value is the time at which the task at the head
+						of the blocked list must be removed from the Blocked
+						state -	so record the item value in
+						xNextTaskUnblockTime. */
+						xNextTaskUnblockTime = xItemValue;
+						break;
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* It is time to remove the item from the Blocked state. */
+					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+
+					/* Is the task waiting on an event also?  If so remove
+					it from the event list. */
+					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
+					{
+						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* Place the unblocked task into the appropriate ready
+					list. */
+					prvAddTaskToReadyList( pxTCB );
+
+					/* A task being unblocked cannot cause an immediate
+					context switch if preemption is turned off. */
+					#if (  configUSE_PREEMPTION == 1 )
+					{
+						/* Preemption is on, but a context switch should
+						only be performed if the unblocked task has a
+						priority that is equal to or higher than the
+						currently executing task. */
+						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
+						{
+							xSwitchRequired = pdTRUE;
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					#endif /* configUSE_PREEMPTION */
+				}
+			}
+		}
+
+		/* Tasks of equal priority to the currently running task will share
+		processing time (time slice) if preemption is on, and the application
+		writer has not explicitly turned time slicing off. */
+		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
+		{
+			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
+			{
+				xSwitchRequired = pdTRUE;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
+
+		#if ( configUSE_TICK_HOOK == 1 )
+		{
+			/* Guard against the tick hook being called when the pended tick
+			count is being unwound (when the scheduler is being unlocked). */
+			if( uxPendedTicks == ( UBaseType_t ) 0U )
+			{
+				vApplicationTickHook();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* configUSE_TICK_HOOK */
+	}
+	else
+	{
+		++uxPendedTicks;
+
+		/* The tick hook gets called at regular intervals, even if the
+		scheduler is locked. */
+		#if ( configUSE_TICK_HOOK == 1 )
+		{
+			vApplicationTickHook();
+		}
+		#endif
+	}
+
+	#if ( configUSE_PREEMPTION == 1 )
+	{
+		if( xYieldPending != pdFALSE )
+		{
+			xSwitchRequired = pdTRUE;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	#endif /* configUSE_PREEMPTION */
+
+	return xSwitchRequired;
+}
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+
+	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
+	{
+	TCB_t *xTCB;
+
+		/* If xTask is NULL then it is the task hook of the calling task that is
+		getting set. */
+		if( xTask == NULL )
+		{
+			xTCB = ( TCB_t * ) pxCurrentTCB;
+		}
+		else
+		{
+			xTCB = ( TCB_t * ) xTask;
+		}
+
+		/* Save the hook function in the TCB.  A critical section is required as
+		the value can be accessed from an interrupt. */
+		taskENTER_CRITICAL();
+			xTCB->pxTaskTag = pxHookFunction;
+		taskEXIT_CRITICAL();
+	}
+
+#endif /* configUSE_APPLICATION_TASK_TAG */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+
+	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
+	{
+	TCB_t *xTCB;
+	TaskHookFunction_t xReturn;
+
+		/* If xTask is NULL then we are setting our own task hook. */
+		if( xTask == NULL )
+		{
+			xTCB = ( TCB_t * ) pxCurrentTCB;
+		}
+		else
+		{
+			xTCB = ( TCB_t * ) xTask;
+		}
+
+		/* Save the hook function in the TCB.  A critical section is required as
+		the value can be accessed from an interrupt. */
+		taskENTER_CRITICAL();
+		{
+			xReturn = xTCB->pxTaskTag;
+		}
+		taskEXIT_CRITICAL();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_APPLICATION_TASK_TAG */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+
+	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
+	{
+	TCB_t *xTCB;
+	BaseType_t xReturn;
+
+		/* If xTask is NULL then we are calling our own task hook. */
+		if( xTask == NULL )
+		{
+			xTCB = ( TCB_t * ) pxCurrentTCB;
+		}
+		else
+		{
+			xTCB = ( TCB_t * ) xTask;
+		}
+
+		if( xTCB->pxTaskTag != NULL )
+		{
+			xReturn = xTCB->pxTaskTag( pvParameter );
+		}
+		else
+		{
+			xReturn = pdFAIL;
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_APPLICATION_TASK_TAG */
+/*-----------------------------------------------------------*/
+
+void vTaskSwitchContext( void )
+{
+	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
+	{
+		/* The scheduler is currently suspended - do not allow a context
+		switch. */
+		xYieldPending = pdTRUE;
+	}
+	else
+	{
+		xYieldPending = pdFALSE;
+		traceTASK_SWITCHED_OUT();
+
+		#if ( configGENERATE_RUN_TIME_STATS == 1 )
+		{
+				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
+					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
+				#else
+					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
+				#endif
+
+				/* Add the amount of time the task has been running to the
+				accumulated time so far.  The time the task started running was
+				stored in ulTaskSwitchedInTime.  Note that there is no overflow
+				protection here so count values are only valid until the timer
+				overflows.  The guard against negative values is to protect
+				against suspect run time stat counter implementations - which
+				are provided by the application, not the kernel. */
+				if( ulTotalRunTime > ulTaskSwitchedInTime )
+				{
+					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+				ulTaskSwitchedInTime = ulTotalRunTime;
+		}
+		#endif /* configGENERATE_RUN_TIME_STATS */
+
+		/* Check for stack overflow, if configured. */
+		taskCHECK_FOR_STACK_OVERFLOW();
+
+		/* Select a new task to run using either the generic C or port
+		optimised asm code. */
+		taskSELECT_HIGHEST_PRIORITY_TASK();
+		traceTASK_SWITCHED_IN();
+
+		#if ( configUSE_NEWLIB_REENTRANT == 1 )
+		{
+			/* Switch Newlib's _impure_ptr variable to point to the _reent
+			structure specific to this task. */
+			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
+		}
+		#endif /* configUSE_NEWLIB_REENTRANT */
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
+{
+	configASSERT( pxEventList );
+
+	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
+	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
+
+	/* Place the event list item of the TCB in the appropriate event list.
+	This is placed in the list in priority order so the highest priority task
+	is the first to be woken by the event.  The queue that contains the event
+	list is locked, preventing simultaneous access from interrupts. */
+	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
+
+	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
+}
+/*-----------------------------------------------------------*/
+
+void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
+{
+	configASSERT( pxEventList );
+
+	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
+	the event groups implementation. */
+	configASSERT( uxSchedulerSuspended != 0 );
+
+	/* Store the item value in the event list item.  It is safe to access the
+	event list item here as interrupts won't access the event list item of a
+	task that is not in the Blocked state. */
+	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
+
+	/* Place the event list item of the TCB at the end of the appropriate event
+	list.  It is safe to access the event list here because it is part of an
+	event group implementation - and interrupts don't access event groups
+	directly (instead they access them indirectly by pending function calls to
+	the task level). */
+	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
+
+	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
+}
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TIMERS == 1 )
+
+	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
+	{
+		configASSERT( pxEventList );
+
+		/* This function should not be called by application code hence the
+		'Restricted' in its name.  It is not part of the public API.  It is
+		designed for use by kernel code, and has special calling requirements -
+		it should be called with the scheduler suspended. */
+
+
+		/* Place the event list item of the TCB in the appropriate event list.
+		In this case it is assume that this is the only task that is going to
+		be waiting on this event list, so the faster vListInsertEnd() function
+		can be used in place of vListInsert. */
+		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
+
+		/* If the task should block indefinitely then set the block time to a
+		value that will be recognised as an indefinite delay inside the
+		prvAddCurrentTaskToDelayedList() function. */
+		if( xWaitIndefinitely != pdFALSE )
+		{
+			xTicksToWait = portMAX_DELAY;
+		}
+
+		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
+		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
+	}
+
+#endif /* configUSE_TIMERS */
+/*-----------------------------------------------------------*/
+
+BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
+{
+TCB_t *pxUnblockedTCB;
+BaseType_t xReturn;
+
+	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
+	called from a critical section within an ISR. */
+
+	/* The event list is sorted in priority order, so the first in the list can
+	be removed as it is known to be the highest priority.  Remove the TCB from
+	the delayed list, and add it to the ready list.
+
+	If an event is for a queue that is locked then this function will never
+	get called - the lock count on the queue will get modified instead.  This
+	means exclusive access to the event list is guaranteed here.
+
+	This function assumes that a check has already been made to ensure that
+	pxEventList is not empty. */
+	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
+	configASSERT( pxUnblockedTCB );
+	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
+
+	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+	{
+		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
+		prvAddTaskToReadyList( pxUnblockedTCB );
+	}
+	else
+	{
+		/* The delayed and ready lists cannot be accessed, so hold this task
+		pending until the scheduler is resumed. */
+		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
+	}
+
+	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
+	{
+		/* Return true if the task removed from the event list has a higher
+		priority than the calling task.  This allows the calling task to know if
+		it should force a context switch now. */
+		xReturn = pdTRUE;
+
+		/* Mark that a yield is pending in case the user is not using the
+		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
+		xYieldPending = pdTRUE;
+	}
+	else
+	{
+		xReturn = pdFALSE;
+	}
+
+	#if( configUSE_TICKLESS_IDLE != 0 )
+	{
+		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
+		might be set to the blocked task's time out time.  If the task is
+		unblocked for a reason other than a timeout xNextTaskUnblockTime is
+		normally left unchanged, because it is automatically reset to a new
+		value when the tick count equals xNextTaskUnblockTime.  However if
+		tickless idling is used it might be more important to enter sleep mode
+		at the earliest possible time - so reset xNextTaskUnblockTime here to
+		ensure it is updated at the earliest possible time. */
+		prvResetNextTaskUnblockTime();
+	}
+	#endif
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
+{
+TCB_t *pxUnblockedTCB;
+
+	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
+	the event flags implementation. */
+	configASSERT( uxSchedulerSuspended != pdFALSE );
+
+	/* Store the new item value in the event list. */
+	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
+
+	/* Remove the event list form the event flag.  Interrupts do not access
+	event flags. */
+	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
+	configASSERT( pxUnblockedTCB );
+	( void ) uxListRemove( pxEventListItem );
+
+	/* Remove the task from the delayed list and add it to the ready list.  The
+	scheduler is suspended so interrupts will not be accessing the ready
+	lists. */
+	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
+	prvAddTaskToReadyList( pxUnblockedTCB );
+
+	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
+	{
+		/* The unblocked task has a priority above that of the calling task, so
+		a context switch is required.  This function is called with the
+		scheduler suspended so xYieldPending is set so the context switch
+		occurs immediately that the scheduler is resumed (unsuspended). */
+		xYieldPending = pdTRUE;
+	}
+}
+/*-----------------------------------------------------------*/
+
+void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
+{
+	configASSERT( pxTimeOut );
+	taskENTER_CRITICAL();
+	{
+		pxTimeOut->xOverflowCount = xNumOfOverflows;
+		pxTimeOut->xTimeOnEntering = xTickCount;
+	}
+	taskEXIT_CRITICAL();
+}
+/*-----------------------------------------------------------*/
+
+void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
+{
+	/* For internal use only as it does not use a critical section. */
+	pxTimeOut->xOverflowCount = xNumOfOverflows;
+	pxTimeOut->xTimeOnEntering = xTickCount;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
+{
+BaseType_t xReturn;
+
+	configASSERT( pxTimeOut );
+	configASSERT( pxTicksToWait );
+
+	taskENTER_CRITICAL();
+	{
+		/* Minor optimisation.  The tick count cannot change in this block. */
+		const TickType_t xConstTickCount = xTickCount;
+		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
+
+		#if( INCLUDE_xTaskAbortDelay == 1 )
+			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
+			{
+				/* The delay was aborted, which is not the same as a time out,
+				but has the same result. */
+				pxCurrentTCB->ucDelayAborted = pdFALSE;
+				xReturn = pdTRUE;
+			}
+			else
+		#endif
+
+		#if ( INCLUDE_vTaskSuspend == 1 )
+			if( *pxTicksToWait == portMAX_DELAY )
+			{
+				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
+				specified is the maximum block time then the task should block
+				indefinitely, and therefore never time out. */
+				xReturn = pdFALSE;
+			}
+			else
+		#endif
+
+		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
+		{
+			/* The tick count is greater than the time at which
+			vTaskSetTimeout() was called, but has also overflowed since
+			vTaskSetTimeOut() was called.  It must have wrapped all the way
+			around and gone past again. This passed since vTaskSetTimeout()
+			was called. */
+			xReturn = pdTRUE;
+		}
+		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
+		{
+			/* Not a genuine timeout. Adjust parameters for time remaining. */
+			*pxTicksToWait -= xElapsedTime;
+			vTaskInternalSetTimeOutState( pxTimeOut );
+			xReturn = pdFALSE;
+		}
+		else
+		{
+			*pxTicksToWait = 0;
+			xReturn = pdTRUE;
+		}
+	}
+	taskEXIT_CRITICAL();
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vTaskMissedYield( void )
+{
+	xYieldPending = pdTRUE;
+}
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
+	{
+	UBaseType_t uxReturn;
+	TCB_t *pxTCB;
+
+		if( xTask != NULL )
+		{
+			pxTCB = ( TCB_t * ) xTask;
+			uxReturn = pxTCB->uxTaskNumber;
+		}
+		else
+		{
+			uxReturn = 0U;
+		}
+
+		return uxReturn;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
+	{
+	TCB_t *pxTCB;
+
+		if( xTask != NULL )
+		{
+			pxTCB = ( TCB_t * ) xTask;
+			pxTCB->uxTaskNumber = uxHandle;
+		}
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+
+/*
+ * -----------------------------------------------------------
+ * The Idle task.
+ * ----------------------------------------------------------
+ *
+ * The portTASK_FUNCTION() macro is used to allow port/compiler specific
+ * language extensions.  The equivalent prototype for this function is:
+ *
+ * void prvIdleTask( void *pvParameters );
+ *
+ */
+static portTASK_FUNCTION( prvIdleTask, pvParameters )
+{
+	/* Stop warnings. */
+	( void ) pvParameters;
+
+	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
+	SCHEDULER IS STARTED. **/
+
+	/* In case a task that has a secure context deletes itself, in which case
+	the idle task is responsible for deleting the task's secure context, if
+	any. */
+	portTASK_CALLS_SECURE_FUNCTIONS();
+
+	for( ;; )
+	{
+		/* See if any tasks have deleted themselves - if so then the idle task
+		is responsible for freeing the deleted task's TCB and stack. */
+		prvCheckTasksWaitingTermination();
+
+		#if ( configUSE_PREEMPTION == 0 )
+		{
+			/* If we are not using preemption we keep forcing a task switch to
+			see if any other task has become available.  If we are using
+			preemption we don't need to do this as any task becoming available
+			will automatically get the processor anyway. */
+			taskYIELD();
+		}
+		#endif /* configUSE_PREEMPTION */
+
+		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
+		{
+			/* When using preemption tasks of equal priority will be
+			timesliced.  If a task that is sharing the idle priority is ready
+			to run then the idle task should yield before the end of the
+			timeslice.
+
+			A critical region is not required here as we are just reading from
+			the list, and an occasional incorrect value will not matter.  If
+			the ready list at the idle priority contains more than one task
+			then a task other than the idle task is ready to execute. */
+			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
+			{
+				taskYIELD();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
+
+		#if ( configUSE_IDLE_HOOK == 1 )
+		{
+			extern void vApplicationIdleHook( void );
+
+			/* Call the user defined function from within the idle task.  This
+			allows the application designer to add background functionality
+			without the overhead of a separate task.
+			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
+			CALL A FUNCTION THAT MIGHT BLOCK. */
+			vApplicationIdleHook();
+		}
+		#endif /* configUSE_IDLE_HOOK */
+
+		/* This conditional compilation should use inequality to 0, not equality
+		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
+		user defined low power mode	implementations require
+		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
+		#if ( configUSE_TICKLESS_IDLE != 0 )
+		{
+		TickType_t xExpectedIdleTime;
+
+			/* It is not desirable to suspend then resume the scheduler on
+			each iteration of the idle task.  Therefore, a preliminary
+			test of the expected idle time is performed without the
+			scheduler suspended.  The result here is not necessarily
+			valid. */
+			xExpectedIdleTime = prvGetExpectedIdleTime();
+
+			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
+			{
+				vTaskSuspendAll();
+				{
+					/* Now the scheduler is suspended, the expected idle
+					time can be sampled again, and this time its value can
+					be used. */
+					configASSERT( xNextTaskUnblockTime >= xTickCount );
+					xExpectedIdleTime = prvGetExpectedIdleTime();
+
+					/* Define the following macro to set xExpectedIdleTime to 0
+					if the application does not want
+					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
+					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
+
+					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
+					{
+						traceLOW_POWER_IDLE_BEGIN();
+						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
+						traceLOW_POWER_IDLE_END();
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				( void ) xTaskResumeAll();
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* configUSE_TICKLESS_IDLE */
+	}
+}
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TICKLESS_IDLE != 0 )
+
+	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
+	{
+	/* The idle task exists in addition to the application tasks. */
+	const UBaseType_t uxNonApplicationTasks = 1;
+	eSleepModeStatus eReturn = eStandardSleep;
+
+		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
+		{
+			/* A task was made ready while the scheduler was suspended. */
+			eReturn = eAbortSleep;
+		}
+		else if( xYieldPending != pdFALSE )
+		{
+			/* A yield was pended while the scheduler was suspended. */
+			eReturn = eAbortSleep;
+		}
+		else
+		{
+			/* If all the tasks are in the suspended list (which might mean they
+			have an infinite block time rather than actually being suspended)
+			then it is safe to turn all clocks off and just wait for external
+			interrupts. */
+			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
+			{
+				eReturn = eNoTasksWaitingTimeout;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+
+		return eReturn;
+	}
+
+#endif /* configUSE_TICKLESS_IDLE */
+/*-----------------------------------------------------------*/
+
+#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
+
+	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
+	{
+	TCB_t *pxTCB;
+
+		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
+		{
+			pxTCB = prvGetTCBFromHandle( xTaskToSet );
+			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
+		}
+	}
+
+#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
+/*-----------------------------------------------------------*/
+
+#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
+
+	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
+	{
+	void *pvReturn = NULL;
+	TCB_t *pxTCB;
+
+		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
+		{
+			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
+			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
+		}
+		else
+		{
+			pvReturn = NULL;
+		}
+
+		return pvReturn;
+	}
+
+#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
+/*-----------------------------------------------------------*/
+
+#if ( portUSING_MPU_WRAPPERS == 1 )
+
+	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
+	{
+	TCB_t *pxTCB;
+
+		/* If null is passed in here then we are modifying the MPU settings of
+		the calling task. */
+		pxTCB = prvGetTCBFromHandle( xTaskToModify );
+
+		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
+	}
+
+#endif /* portUSING_MPU_WRAPPERS */
+/*-----------------------------------------------------------*/
+
+static void prvInitialiseTaskLists( void )
+{
+UBaseType_t uxPriority;
+
+	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
+	{
+		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
+	}
+
+	vListInitialise( &xDelayedTaskList1 );
+	vListInitialise( &xDelayedTaskList2 );
+	vListInitialise( &xPendingReadyList );
+
+	#if ( INCLUDE_vTaskDelete == 1 )
+	{
+		vListInitialise( &xTasksWaitingTermination );
+	}
+	#endif /* INCLUDE_vTaskDelete */
+
+	#if ( INCLUDE_vTaskSuspend == 1 )
+	{
+		vListInitialise( &xSuspendedTaskList );
+	}
+	#endif /* INCLUDE_vTaskSuspend */
+
+	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
+	using list2. */
+	pxDelayedTaskList = &xDelayedTaskList1;
+	pxOverflowDelayedTaskList = &xDelayedTaskList2;
+}
+/*-----------------------------------------------------------*/
+
+static void prvCheckTasksWaitingTermination( void )
+{
+
+	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
+
+	#if ( INCLUDE_vTaskDelete == 1 )
+	{
+		TCB_t *pxTCB;
+
+		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
+		being called too often in the idle task. */
+		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
+		{
+			taskENTER_CRITICAL();
+			{
+				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
+				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+				--uxCurrentNumberOfTasks;
+				--uxDeletedTasksWaitingCleanUp;
+			}
+			taskEXIT_CRITICAL();
+
+			prvDeleteTCB( pxTCB );
+		}
+	}
+	#endif /* INCLUDE_vTaskDelete */
+}
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TRACE_FACILITY == 1 )
+
+	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
+	{
+	TCB_t *pxTCB;
+
+		/* xTask is NULL then get the state of the calling task. */
+		pxTCB = prvGetTCBFromHandle( xTask );
+
+		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
+		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
+		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
+		pxTaskStatus->pxStackBase = pxTCB->pxStack;
+		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
+
+		#if ( configUSE_MUTEXES == 1 )
+		{
+			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
+		}
+		#else
+		{
+			pxTaskStatus->uxBasePriority = 0;
+		}
+		#endif
+
+		#if ( configGENERATE_RUN_TIME_STATS == 1 )
+		{
+			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
+		}
+		#else
+		{
+			pxTaskStatus->ulRunTimeCounter = 0;
+		}
+		#endif
+
+		/* Obtaining the task state is a little fiddly, so is only done if the
+		value of eState passed into this function is eInvalid - otherwise the
+		state is just set to whatever is passed in. */
+		if( eState != eInvalid )
+		{
+			if( pxTCB == pxCurrentTCB )
+			{
+				pxTaskStatus->eCurrentState = eRunning;
+			}
+			else
+			{
+				pxTaskStatus->eCurrentState = eState;
+
+				#if ( INCLUDE_vTaskSuspend == 1 )
+				{
+					/* If the task is in the suspended list then there is a
+					chance it is actually just blocked indefinitely - so really
+					it should be reported as being in the Blocked state. */
+					if( eState == eSuspended )
+					{
+						vTaskSuspendAll();
+						{
+							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
+							{
+								pxTaskStatus->eCurrentState = eBlocked;
+							}
+						}
+						( void ) xTaskResumeAll();
+					}
+				}
+				#endif /* INCLUDE_vTaskSuspend */
+			}
+		}
+		else
+		{
+			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
+		}
+
+		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
+		parameter is provided to allow it to be skipped. */
+		if( xGetFreeStackSpace != pdFALSE )
+		{
+			#if ( portSTACK_GROWTH > 0 )
+			{
+				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
+			}
+			#else
+			{
+				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
+			}
+			#endif
+		}
+		else
+		{
+			pxTaskStatus->usStackHighWaterMark = 0;
+		}
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
+	{
+	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
+	UBaseType_t uxTask = 0;
+
+		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
+		{
+			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
+
+			/* Populate an TaskStatus_t structure within the
+			pxTaskStatusArray array for each task that is referenced from
+			pxList.  See the definition of TaskStatus_t in task.h for the
+			meaning of each TaskStatus_t structure member. */
+			do
+			{
+				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
+				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
+				uxTask++;
+			} while( pxNextTCB != pxFirstTCB );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return uxTask;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
+
+	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
+	{
+	uint32_t ulCount = 0U;
+
+		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
+		{
+			pucStackByte -= portSTACK_GROWTH;
+			ulCount++;
+		}
+
+		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
+
+		return ( uint16_t ) ulCount;
+	}
+
+#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
+
+	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
+	{
+	TCB_t *pxTCB;
+	uint8_t *pucEndOfStack;
+	UBaseType_t uxReturn;
+
+		pxTCB = prvGetTCBFromHandle( xTask );
+
+		#if portSTACK_GROWTH < 0
+		{
+			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
+		}
+		#else
+		{
+			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
+		}
+		#endif
+
+		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
+
+		return uxReturn;
+	}
+
+#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
+/*-----------------------------------------------------------*/
+
+#if ( INCLUDE_vTaskDelete == 1 )
+
+	static void prvDeleteTCB( TCB_t *pxTCB )
+	{
+		/* This call is required specifically for the TriCore port.  It must be
+		above the vPortFree() calls.  The call is also used by ports/demos that
+		want to allocate and clean RAM statically. */
+		portCLEAN_UP_TCB( pxTCB );
+
+		/* Free up the memory allocated by the scheduler for the task.  It is up
+		to the task to free any memory allocated at the application level. */
+		#if ( configUSE_NEWLIB_REENTRANT == 1 )
+		{
+			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
+		}
+		#endif /* configUSE_NEWLIB_REENTRANT */
+
+		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
+		{
+			/* The task can only have been allocated dynamically - free both
+			the stack and TCB. */
+			vPortFree( pxTCB->pxStack );
+			vPortFree( pxTCB );
+		}
+		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
+		{
+			/* The task could have been allocated statically or dynamically, so
+			check what was statically allocated before trying to free the
+			memory. */
+			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
+			{
+				/* Both the stack and TCB were allocated dynamically, so both
+				must be freed. */
+				vPortFree( pxTCB->pxStack );
+				vPortFree( pxTCB );
+			}
+			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
+			{
+				/* Only the stack was statically allocated, so the TCB is the
+				only memory that must be freed. */
+				vPortFree( pxTCB );
+			}
+			else
+			{
+				/* Neither the stack nor the TCB were allocated dynamically, so
+				nothing needs to be freed. */
+				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+	}
+
+#endif /* INCLUDE_vTaskDelete */
+/*-----------------------------------------------------------*/
+
+static void prvResetNextTaskUnblockTime( void )
+{
+TCB_t *pxTCB;
+
+	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
+	{
+		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
+		the maximum possible value so it is	extremely unlikely that the
+		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
+		there is an item in the delayed list. */
+		xNextTaskUnblockTime = portMAX_DELAY;
+	}
+	else
+	{
+		/* The new current delayed list is not empty, get the value of
+		the item at the head of the delayed list.  This is the time at
+		which the task at the head of the delayed list should be removed
+		from the Blocked state. */
+		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
+		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
+	}
+}
+/*-----------------------------------------------------------*/
+
+#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
+
+	TaskHandle_t xTaskGetCurrentTaskHandle( void )
+	{
+	TaskHandle_t xReturn;
+
+		/* A critical section is not required as this is not called from
+		an interrupt and the current TCB will always be the same for any
+		individual execution thread. */
+		xReturn = pxCurrentTCB;
+
+		return xReturn;
+	}
+
+#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
+
+	BaseType_t xTaskGetSchedulerState( void )
+	{
+	BaseType_t xReturn;
+
+		if( xSchedulerRunning == pdFALSE )
+		{
+			xReturn = taskSCHEDULER_NOT_STARTED;
+		}
+		else
+		{
+			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+			{
+				xReturn = taskSCHEDULER_RUNNING;
+			}
+			else
+			{
+				xReturn = taskSCHEDULER_SUSPENDED;
+			}
+		}
+
+		return xReturn;
+	}
+
+#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_MUTEXES == 1 )
+
+	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
+	{
+	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
+	BaseType_t xReturn = pdFALSE;
+
+		/* If the mutex was given back by an interrupt while the queue was
+		locked then the mutex holder might now be NULL.  _RB_ Is this still
+		needed as interrupts can no longer use mutexes? */
+		if( pxMutexHolder != NULL )
+		{
+			/* If the holder of the mutex has a priority below the priority of
+			the task attempting to obtain the mutex then it will temporarily
+			inherit the priority of the task attempting to obtain the mutex. */
+			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
+			{
+				/* Adjust the mutex holder state to account for its new
+				priority.  Only reset the event list item value if the value is
+				not being used for anything else. */
+				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
+				{
+					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+
+				/* If the task being modified is in the ready state it will need
+				to be moved into a new list. */
+				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
+				{
+					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+					{
+						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* Inherit the priority before being moved into the new list. */
+					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
+					prvAddTaskToReadyList( pxMutexHolderTCB );
+				}
+				else
+				{
+					/* Just inherit the priority. */
+					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
+				}
+
+				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
+
+				/* Inheritance occurred. */
+				xReturn = pdTRUE;
+			}
+			else
+			{
+				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
+				{
+					/* The base priority of the mutex holder is lower than the
+					priority of the task attempting to take the mutex, but the
+					current priority of the mutex holder is not lower than the
+					priority of the task attempting to take the mutex.
+					Therefore the mutex holder must have already inherited a
+					priority, but inheritance would have occurred if that had
+					not been the case. */
+					xReturn = pdTRUE;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_MUTEXES == 1 )
+
+	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
+	{
+	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
+	BaseType_t xReturn = pdFALSE;
+
+		if( pxMutexHolder != NULL )
+		{
+			/* A task can only have an inherited priority if it holds the mutex.
+			If the mutex is held by a task then it cannot be given from an
+			interrupt, and if a mutex is given by the holding task then it must
+			be the running state task. */
+			configASSERT( pxTCB == pxCurrentTCB );
+			configASSERT( pxTCB->uxMutexesHeld );
+			( pxTCB->uxMutexesHeld )--;
+
+			/* Has the holder of the mutex inherited the priority of another
+			task? */
+			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
+			{
+				/* Only disinherit if no other mutexes are held. */
+				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
+				{
+					/* A task can only have an inherited priority if it holds
+					the mutex.  If the mutex is held by a task then it cannot be
+					given from an interrupt, and if a mutex is given by the
+					holding task then it must be the running state task.  Remove
+					the holding task from the ready list. */
+					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+					{
+						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* Disinherit the priority before adding the task into the
+					new	ready list. */
+					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
+					pxTCB->uxPriority = pxTCB->uxBasePriority;
+
+					/* Reset the event list item value.  It cannot be in use for
+					any other purpose if this task is running, and it must be
+					running to give back the mutex. */
+					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+					prvAddTaskToReadyList( pxTCB );
+
+					/* Return true to indicate that a context switch is required.
+					This is only actually required in the corner case whereby
+					multiple mutexes were held and the mutexes were given back
+					in an order different to that in which they were taken.
+					If a context switch did not occur when the first mutex was
+					returned, even if a task was waiting on it, then a context
+					switch should occur when the last mutex is returned whether
+					a task is waiting on it or not. */
+					xReturn = pdTRUE;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+
+		return xReturn;
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_MUTEXES == 1 )
+
+	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
+	{
+	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
+	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
+	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
+
+		if( pxMutexHolder != NULL )
+		{
+			/* If pxMutexHolder is not NULL then the holder must hold at least
+			one mutex. */
+			configASSERT( pxTCB->uxMutexesHeld );
+
+			/* Determine the priority to which the priority of the task that
+			holds the mutex should be set.  This will be the greater of the
+			holding task's base priority and the priority of the highest
+			priority task that is waiting to obtain the mutex. */
+			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
+			{
+				uxPriorityToUse = uxHighestPriorityWaitingTask;
+			}
+			else
+			{
+				uxPriorityToUse = pxTCB->uxBasePriority;
+			}
+
+			/* Does the priority need to change? */
+			if( pxTCB->uxPriority != uxPriorityToUse )
+			{
+				/* Only disinherit if no other mutexes are held.  This is a
+				simplification in the priority inheritance implementation.  If
+				the task that holds the mutex is also holding other mutexes then
+				the other mutexes may have caused the priority inheritance. */
+				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
+				{
+					/* If a task has timed out because it already holds the
+					mutex it was trying to obtain then it cannot of inherited
+					its own priority. */
+					configASSERT( pxTCB != pxCurrentTCB );
+
+					/* Disinherit the priority, remembering the previous
+					priority to facilitate determining the subject task's
+					state. */
+					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
+					uxPriorityUsedOnEntry = pxTCB->uxPriority;
+					pxTCB->uxPriority = uxPriorityToUse;
+
+					/* Only reset the event list item value if the value is not
+					being used for anything else. */
+					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
+					{
+						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+
+					/* If the running task is not the task that holds the mutex
+					then the task that holds the mutex could be in either the
+					Ready, Blocked or Suspended states.  Only remove the task
+					from its current state list if it is in the Ready state as
+					the task's priority is going to change and there is one
+					Ready list per priority. */
+					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
+					{
+						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+						{
+							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+
+						prvAddTaskToReadyList( pxTCB );
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if ( portCRITICAL_NESTING_IN_TCB == 1 )
+
+	void vTaskEnterCritical( void )
+	{
+		portDISABLE_INTERRUPTS();
+
+		if( xSchedulerRunning != pdFALSE )
+		{
+			( pxCurrentTCB->uxCriticalNesting )++;
+
+			/* This is not the interrupt safe version of the enter critical
+			function so	assert() if it is being called from an interrupt
+			context.  Only API functions that end in "FromISR" can be used in an
+			interrupt.  Only assert if the critical nesting count is 1 to
+			protect against recursive calls if the assert function also uses a
+			critical section. */
+			if( pxCurrentTCB->uxCriticalNesting == 1 )
+			{
+				portASSERT_IF_IN_ISR();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* portCRITICAL_NESTING_IN_TCB */
+/*-----------------------------------------------------------*/
+
+#if ( portCRITICAL_NESTING_IN_TCB == 1 )
+
+	void vTaskExitCritical( void )
+	{
+		if( xSchedulerRunning != pdFALSE )
+		{
+			if( pxCurrentTCB->uxCriticalNesting > 0U )
+			{
+				( pxCurrentTCB->uxCriticalNesting )--;
+
+				if( pxCurrentTCB->uxCriticalNesting == 0U )
+				{
+					portENABLE_INTERRUPTS();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* portCRITICAL_NESTING_IN_TCB */
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
+
+	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
+	{
+	size_t x;
+
+		/* Start by copying the entire string. */
+		strcpy( pcBuffer, pcTaskName );
+
+		/* Pad the end of the string with spaces to ensure columns line up when
+		printed out. */
+		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
+		{
+			pcBuffer[ x ] = ' ';
+		}
+
+		/* Terminate. */
+		pcBuffer[ x ] = 0x00;
+
+		/* Return the new end of string. */
+		return &( pcBuffer[ x ] );
+	}
+
+#endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
+/*-----------------------------------------------------------*/
+
+#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+
+	void vTaskList( char * pcWriteBuffer )
+	{
+	TaskStatus_t *pxTaskStatusArray;
+	volatile UBaseType_t uxArraySize, x;
+	char cStatus;
+
+		/*
+		 * PLEASE NOTE:
+		 *
+		 * This function is provided for convenience only, and is used by many
+		 * of the demo applications.  Do not consider it to be part of the
+		 * scheduler.
+		 *
+		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
+		 * uxTaskGetSystemState() output into a human readable table that
+		 * displays task names, states and stack usage.
+		 *
+		 * vTaskList() has a dependency on the sprintf() C library function that
+		 * might bloat the code size, use a lot of stack, and provide different
+		 * results on different platforms.  An alternative, tiny, third party,
+		 * and limited functionality implementation of sprintf() is provided in
+		 * many of the FreeRTOS/Demo sub-directories in a file called
+		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
+		 * snprintf() implementation!).
+		 *
+		 * It is recommended that production systems call uxTaskGetSystemState()
+		 * directly to get access to raw stats data, rather than indirectly
+		 * through a call to vTaskList().
+		 */
+
+
+		/* Make sure the write buffer does not contain a string. */
+		*pcWriteBuffer = 0x00;
+
+		/* Take a snapshot of the number of tasks in case it changes while this
+		function is executing. */
+		uxArraySize = uxCurrentNumberOfTasks;
+
+		/* Allocate an array index for each task.  NOTE!  if
+		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
+		equate to NULL. */
+		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
+
+		if( pxTaskStatusArray != NULL )
+		{
+			/* Generate the (binary) data. */
+			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
+
+			/* Create a human readable table from the binary data. */
+			for( x = 0; x < uxArraySize; x++ )
+			{
+				switch( pxTaskStatusArray[ x ].eCurrentState )
+				{
+					case eRunning:		cStatus = tskRUNNING_CHAR;
+										break;
+
+					case eReady:		cStatus = tskREADY_CHAR;
+										break;
+
+					case eBlocked:		cStatus = tskBLOCKED_CHAR;
+										break;
+
+					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
+										break;
+
+					case eDeleted:		cStatus = tskDELETED_CHAR;
+										break;
+
+					default:			/* Should not get here, but it is included
+										to prevent static checking errors. */
+										cStatus = 0x00;
+										break;
+				}
+
+				/* Write the task name to the string, padding with spaces so it
+				can be printed in tabular form more easily. */
+				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
+
+				/* Write the rest of the string. */
+				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
+				pcWriteBuffer += strlen( pcWriteBuffer );
+			}
+
+			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
+			is 0 then vPortFree() will be #defined to nothing. */
+			vPortFree( pxTaskStatusArray );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
+/*----------------------------------------------------------*/
+
+#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+
+	void vTaskGetRunTimeStats( char *pcWriteBuffer )
+	{
+	TaskStatus_t *pxTaskStatusArray;
+	volatile UBaseType_t uxArraySize, x;
+	uint32_t ulTotalTime, ulStatsAsPercentage;
+
+		#if( configUSE_TRACE_FACILITY != 1 )
+		{
+			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
+		}
+		#endif
+
+		/*
+		 * PLEASE NOTE:
+		 *
+		 * This function is provided for convenience only, and is used by many
+		 * of the demo applications.  Do not consider it to be part of the
+		 * scheduler.
+		 *
+		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
+		 * of the uxTaskGetSystemState() output into a human readable table that
+		 * displays the amount of time each task has spent in the Running state
+		 * in both absolute and percentage terms.
+		 *
+		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
+		 * function that might bloat the code size, use a lot of stack, and
+		 * provide different results on different platforms.  An alternative,
+		 * tiny, third party, and limited functionality implementation of
+		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
+		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
+		 * a full snprintf() implementation!).
+		 *
+		 * It is recommended that production systems call uxTaskGetSystemState()
+		 * directly to get access to raw stats data, rather than indirectly
+		 * through a call to vTaskGetRunTimeStats().
+		 */
+
+		/* Make sure the write buffer does not contain a string. */
+		*pcWriteBuffer = 0x00;
+
+		/* Take a snapshot of the number of tasks in case it changes while this
+		function is executing. */
+		uxArraySize = uxCurrentNumberOfTasks;
+
+		/* Allocate an array index for each task.  NOTE!  If
+		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
+		equate to NULL. */
+		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
+
+		if( pxTaskStatusArray != NULL )
+		{
+			/* Generate the (binary) data. */
+			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
+
+			/* For percentage calculations. */
+			ulTotalTime /= 100UL;
+
+			/* Avoid divide by zero errors. */
+			if( ulTotalTime > 0 )
+			{
+				/* Create a human readable table from the binary data. */
+				for( x = 0; x < uxArraySize; x++ )
+				{
+					/* What percentage of the total run time has the task used?
+					This will always be rounded down to the nearest integer.
+					ulTotalRunTimeDiv100 has already been divided by 100. */
+					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
+
+					/* Write the task name to the string, padding with
+					spaces so it can be printed in tabular form more
+					easily. */
+					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
+
+					if( ulStatsAsPercentage > 0UL )
+					{
+						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
+						{
+							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
+						}
+						#else
+						{
+							/* sizeof( int ) == sizeof( long ) so a smaller
+							printf() library can be used. */
+							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
+						}
+						#endif
+					}
+					else
+					{
+						/* If the percentage is zero here then the task has
+						consumed less than 1% of the total run time. */
+						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
+						{
+							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
+						}
+						#else
+						{
+							/* sizeof( int ) == sizeof( long ) so a smaller
+							printf() library can be used. */
+							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
+						}
+						#endif
+					}
+
+					pcWriteBuffer += strlen( pcWriteBuffer );
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
+			is 0 then vPortFree() will be #defined to nothing. */
+			vPortFree( pxTaskStatusArray );
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
+/*-----------------------------------------------------------*/
+
+TickType_t uxTaskResetEventItemValue( void )
+{
+TickType_t uxReturn;
+
+	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
+
+	/* Reset the event list item to its normal value - so it can be used with
+	queues and semaphores. */
+	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+
+	return uxReturn;
+}
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_MUTEXES == 1 )
+
+	void *pvTaskIncrementMutexHeldCount( void )
+	{
+		/* If xSemaphoreCreateMutex() is called before any tasks have been created
+		then pxCurrentTCB will be NULL. */
+		if( pxCurrentTCB != NULL )
+		{
+			( pxCurrentTCB->uxMutexesHeld )++;
+		}
+
+		return pxCurrentTCB;
+	}
+
+#endif /* configUSE_MUTEXES */
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TASK_NOTIFICATIONS == 1 )
+
+	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
+	{
+	uint32_t ulReturn;
+
+		taskENTER_CRITICAL();
+		{
+			/* Only block if the notification count is not already non-zero. */
+			if( pxCurrentTCB->ulNotifiedValue == 0UL )
+			{
+				/* Mark this task as waiting for a notification. */
+				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
+
+				if( xTicksToWait > ( TickType_t ) 0 )
+				{
+					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
+					traceTASK_NOTIFY_TAKE_BLOCK();
+
+					/* All ports are written to allow a yield in a critical
+					section (some will yield immediately, others wait until the
+					critical section exits) - but it is not something that
+					application code should ever do. */
+					portYIELD_WITHIN_API();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		taskENTER_CRITICAL();
+		{
+			traceTASK_NOTIFY_TAKE();
+			ulReturn = pxCurrentTCB->ulNotifiedValue;
+
+			if( ulReturn != 0UL )
+			{
+				if( xClearCountOnExit != pdFALSE )
+				{
+					pxCurrentTCB->ulNotifiedValue = 0UL;
+				}
+				else
+				{
+					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
+		}
+		taskEXIT_CRITICAL();
+
+		return ulReturn;
+	}
+
+#endif /* configUSE_TASK_NOTIFICATIONS */
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TASK_NOTIFICATIONS == 1 )
+
+	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
+	{
+	BaseType_t xReturn;
+
+		taskENTER_CRITICAL();
+		{
+			/* Only block if a notification is not already pending. */
+			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
+			{
+				/* Clear bits in the task's notification value as bits may get
+				set	by the notifying task or interrupt.  This can be used to
+				clear the value to zero. */
+				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
+
+				/* Mark this task as waiting for a notification. */
+				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
+
+				if( xTicksToWait > ( TickType_t ) 0 )
+				{
+					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
+					traceTASK_NOTIFY_WAIT_BLOCK();
+
+					/* All ports are written to allow a yield in a critical
+					section (some will yield immediately, others wait until the
+					critical section exits) - but it is not something that
+					application code should ever do. */
+					portYIELD_WITHIN_API();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		taskENTER_CRITICAL();
+		{
+			traceTASK_NOTIFY_WAIT();
+
+			if( pulNotificationValue != NULL )
+			{
+				/* Output the current notification value, which may or may not
+				have changed. */
+				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
+			}
+
+			/* If ucNotifyValue is set then either the task never entered the
+			blocked state (because a notification was already pending) or the
+			task unblocked because of a notification.  Otherwise the task
+			unblocked because of a timeout. */
+			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
+			{
+				/* A notification was not received. */
+				xReturn = pdFALSE;
+			}
+			else
+			{
+				/* A notification was already pending or a notification was
+				received while the task was waiting. */
+				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
+				xReturn = pdTRUE;
+			}
+
+			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
+		}
+		taskEXIT_CRITICAL();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_TASK_NOTIFICATIONS */
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TASK_NOTIFICATIONS == 1 )
+
+	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
+	{
+	TCB_t * pxTCB;
+	BaseType_t xReturn = pdPASS;
+	uint8_t ucOriginalNotifyState;
+
+		configASSERT( xTaskToNotify );
+		pxTCB = ( TCB_t * ) xTaskToNotify;
+
+		taskENTER_CRITICAL();
+		{
+			if( pulPreviousNotificationValue != NULL )
+			{
+				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
+			}
+
+			ucOriginalNotifyState = pxTCB->ucNotifyState;
+
+			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
+
+			switch( eAction )
+			{
+				case eSetBits	:
+					pxTCB->ulNotifiedValue |= ulValue;
+					break;
+
+				case eIncrement	:
+					( pxTCB->ulNotifiedValue )++;
+					break;
+
+				case eSetValueWithOverwrite	:
+					pxTCB->ulNotifiedValue = ulValue;
+					break;
+
+				case eSetValueWithoutOverwrite :
+					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
+					{
+						pxTCB->ulNotifiedValue = ulValue;
+					}
+					else
+					{
+						/* The value could not be written to the task. */
+						xReturn = pdFAIL;
+					}
+					break;
+
+				case eNoAction:
+					/* The task is being notified without its notify value being
+					updated. */
+					break;
+			}
+
+			traceTASK_NOTIFY();
+
+			/* If the task is in the blocked state specifically to wait for a
+			notification then unblock it now. */
+			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
+			{
+				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+				prvAddTaskToReadyList( pxTCB );
+
+				/* The task should not have been on an event list. */
+				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
+
+				#if( configUSE_TICKLESS_IDLE != 0 )
+				{
+					/* If a task is blocked waiting for a notification then
+					xNextTaskUnblockTime might be set to the blocked task's time
+					out time.  If the task is unblocked for a reason other than
+					a timeout xNextTaskUnblockTime is normally left unchanged,
+					because it will automatically get reset to a new value when
+					the tick count equals xNextTaskUnblockTime.  However if
+					tickless idling is used it might be more important to enter
+					sleep mode at the earliest possible time - so reset
+					xNextTaskUnblockTime here to ensure it is updated at the
+					earliest possible time. */
+					prvResetNextTaskUnblockTime();
+				}
+				#endif
+
+				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
+				{
+					/* The notified task has a priority above the currently
+					executing task so a yield is required. */
+					taskYIELD_IF_USING_PREEMPTION();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_TASK_NOTIFICATIONS */
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TASK_NOTIFICATIONS == 1 )
+
+	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
+	{
+	TCB_t * pxTCB;
+	uint8_t ucOriginalNotifyState;
+	BaseType_t xReturn = pdPASS;
+	UBaseType_t uxSavedInterruptStatus;
+
+		configASSERT( xTaskToNotify );
+
+		/* RTOS ports that support interrupt nesting have the concept of a
+		maximum	system call (or maximum API call) interrupt priority.
+		Interrupts that are	above the maximum system call priority are keep
+		permanently enabled, even when the RTOS kernel is in a critical section,
+		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
+		is defined in FreeRTOSConfig.h then
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+		failure if a FreeRTOS API function is called from an interrupt that has
+		been assigned a priority above the configured maximum system call
+		priority.  Only FreeRTOS functions that end in FromISR can be called
+		from interrupts	that have been assigned a priority at or (logically)
+		below the maximum system call interrupt priority.  FreeRTOS maintains a
+		separate interrupt safe API to ensure interrupt entry is as fast and as
+		simple as possible.  More information (albeit Cortex-M specific) is
+		provided on the following link:
+		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+		pxTCB = ( TCB_t * ) xTaskToNotify;
+
+		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+		{
+			if( pulPreviousNotificationValue != NULL )
+			{
+				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
+			}
+
+			ucOriginalNotifyState = pxTCB->ucNotifyState;
+			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
+
+			switch( eAction )
+			{
+				case eSetBits	:
+					pxTCB->ulNotifiedValue |= ulValue;
+					break;
+
+				case eIncrement	:
+					( pxTCB->ulNotifiedValue )++;
+					break;
+
+				case eSetValueWithOverwrite	:
+					pxTCB->ulNotifiedValue = ulValue;
+					break;
+
+				case eSetValueWithoutOverwrite :
+					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
+					{
+						pxTCB->ulNotifiedValue = ulValue;
+					}
+					else
+					{
+						/* The value could not be written to the task. */
+						xReturn = pdFAIL;
+					}
+					break;
+
+				case eNoAction :
+					/* The task is being notified without its notify value being
+					updated. */
+					break;
+			}
+
+			traceTASK_NOTIFY_FROM_ISR();
+
+			/* If the task is in the blocked state specifically to wait for a
+			notification then unblock it now. */
+			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
+			{
+				/* The task should not have been on an event list. */
+				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
+
+				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+				{
+					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+					prvAddTaskToReadyList( pxTCB );
+				}
+				else
+				{
+					/* The delayed and ready lists cannot be accessed, so hold
+					this task pending until the scheduler is resumed. */
+					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
+				}
+
+				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
+				{
+					/* The notified task has a priority above the currently
+					executing task so a yield is required. */
+					if( pxHigherPriorityTaskWoken != NULL )
+					{
+						*pxHigherPriorityTaskWoken = pdTRUE;
+					}
+					else
+					{
+						/* Mark that a yield is pending in case the user is not
+						using the "xHigherPriorityTaskWoken" parameter to an ISR
+						safe FreeRTOS function. */
+						xYieldPending = pdTRUE;
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+
+		return xReturn;
+	}
+
+#endif /* configUSE_TASK_NOTIFICATIONS */
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TASK_NOTIFICATIONS == 1 )
+
+	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
+	{
+	TCB_t * pxTCB;
+	uint8_t ucOriginalNotifyState;
+	UBaseType_t uxSavedInterruptStatus;
+
+		configASSERT( xTaskToNotify );
+
+		/* RTOS ports that support interrupt nesting have the concept of a
+		maximum	system call (or maximum API call) interrupt priority.
+		Interrupts that are	above the maximum system call priority are keep
+		permanently enabled, even when the RTOS kernel is in a critical section,
+		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
+		is defined in FreeRTOSConfig.h then
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
+		failure if a FreeRTOS API function is called from an interrupt that has
+		been assigned a priority above the configured maximum system call
+		priority.  Only FreeRTOS functions that end in FromISR can be called
+		from interrupts	that have been assigned a priority at or (logically)
+		below the maximum system call interrupt priority.  FreeRTOS maintains a
+		separate interrupt safe API to ensure interrupt entry is as fast and as
+		simple as possible.  More information (albeit Cortex-M specific) is
+		provided on the following link:
+		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
+		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
+
+		pxTCB = ( TCB_t * ) xTaskToNotify;
+
+		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
+		{
+			ucOriginalNotifyState = pxTCB->ucNotifyState;
+			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
+
+			/* 'Giving' is equivalent to incrementing a count in a counting
+			semaphore. */
+			( pxTCB->ulNotifiedValue )++;
+
+			traceTASK_NOTIFY_GIVE_FROM_ISR();
+
+			/* If the task is in the blocked state specifically to wait for a
+			notification then unblock it now. */
+			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
+			{
+				/* The task should not have been on an event list. */
+				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
+
+				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
+				{
+					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
+					prvAddTaskToReadyList( pxTCB );
+				}
+				else
+				{
+					/* The delayed and ready lists cannot be accessed, so hold
+					this task pending until the scheduler is resumed. */
+					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
+				}
+
+				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
+				{
+					/* The notified task has a priority above the currently
+					executing task so a yield is required. */
+					if( pxHigherPriorityTaskWoken != NULL )
+					{
+						*pxHigherPriorityTaskWoken = pdTRUE;
+					}
+					else
+					{
+						/* Mark that a yield is pending in case the user is not
+						using the "xHigherPriorityTaskWoken" parameter in an ISR
+						safe FreeRTOS function. */
+						xYieldPending = pdTRUE;
+					}
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
+	}
+
+#endif /* configUSE_TASK_NOTIFICATIONS */
+
+/*-----------------------------------------------------------*/
+
+#if( configUSE_TASK_NOTIFICATIONS == 1 )
+
+	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
+	{
+	TCB_t *pxTCB;
+	BaseType_t xReturn;
+
+		/* If null is passed in here then it is the calling task that is having
+		its notification state cleared. */
+		pxTCB = prvGetTCBFromHandle( xTask );
+
+		taskENTER_CRITICAL();
+		{
+			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
+			{
+				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
+				xReturn = pdPASS;
+			}
+			else
+			{
+				xReturn = pdFAIL;
+			}
+		}
+		taskEXIT_CRITICAL();
+
+		return xReturn;
+	}
+
+#endif /* configUSE_TASK_NOTIFICATIONS */
+/*-----------------------------------------------------------*/
+
+
+static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
+{
+TickType_t xTimeToWake;
+const TickType_t xConstTickCount = xTickCount;
+
+	#if( INCLUDE_xTaskAbortDelay == 1 )
+	{
+		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
+		reset to pdFALSE so it can be detected as having been set to pdTRUE
+		when the task leaves the Blocked state. */
+		pxCurrentTCB->ucDelayAborted = pdFALSE;
+	}
+	#endif
+
+	/* Remove the task from the ready list before adding it to the blocked list
+	as the same list item is used for both lists. */
+	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
+	{
+		/* The current task must be in a ready list, so there is no need to
+		check, and the port reset macro can be called directly. */
+		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	#if ( INCLUDE_vTaskSuspend == 1 )
+	{
+		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
+		{
+			/* Add the task to the suspended task list instead of a delayed task
+			list to ensure it is not woken by a timing event.  It will block
+			indefinitely. */
+			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
+		}
+		else
+		{
+			/* Calculate the time at which the task should be woken if the event
+			does not occur.  This may overflow but this doesn't matter, the
+			kernel will manage it correctly. */
+			xTimeToWake = xConstTickCount + xTicksToWait;
+
+			/* The list item will be inserted in wake time order. */
+			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
+
+			if( xTimeToWake < xConstTickCount )
+			{
+				/* Wake time has overflowed.  Place this item in the overflow
+				list. */
+				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
+			}
+			else
+			{
+				/* The wake time has not overflowed, so the current block list
+				is used. */
+				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
+
+				/* If the task entering the blocked state was placed at the
+				head of the list of blocked tasks then xNextTaskUnblockTime
+				needs to be updated too. */
+				if( xTimeToWake < xNextTaskUnblockTime )
+				{
+					xNextTaskUnblockTime = xTimeToWake;
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+	}
+	#else /* INCLUDE_vTaskSuspend */
+	{
+		/* Calculate the time at which the task should be woken if the event
+		does not occur.  This may overflow but this doesn't matter, the kernel
+		will manage it correctly. */
+		xTimeToWake = xConstTickCount + xTicksToWait;
+
+		/* The list item will be inserted in wake time order. */
+		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
+
+		if( xTimeToWake < xConstTickCount )
+		{
+			/* Wake time has overflowed.  Place this item in the overflow list. */
+			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
+		}
+		else
+		{
+			/* The wake time has not overflowed, so the current block list is used. */
+			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
+
+			/* If the task entering the blocked state was placed at the head of the
+			list of blocked tasks then xNextTaskUnblockTime needs to be updated
+			too. */
+			if( xTimeToWake < xNextTaskUnblockTime )
+			{
+				xNextTaskUnblockTime = xTimeToWake;
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+
+		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
+		( void ) xCanBlockIndefinitely;
+	}
+	#endif /* INCLUDE_vTaskSuspend */
+}
+
+/* Code below here allows additional code to be inserted into this source file,
+especially where access to file scope functions and data is needed (for example
+when performing module tests). */
+
+#ifdef FREERTOS_MODULE_TEST
+	#include "tasks_test_access_functions.h"
+#endif
+
+
+#if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
+
+	#include "freertos_tasks_c_additions.h"
+
+	static void freertos_tasks_c_additions_init( void )
+	{
+		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
+			FREERTOS_TASKS_C_ADDITIONS_INIT();
+		#endif
+	}
+
+#endif
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/source/timers.c ./libs/freertos/source/timers.c
--- a_bRU7kv/libs/freertos/source/timers.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/source/timers.c	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,1076 @@
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/* Standard includes. */
+#include <stdlib.h>
+
+/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
+all the API functions to use the MPU wrappers.  That should only be done when
+task.h is included from an application file. */
+#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include "queue.h"
+#include "timers.h"
+
+#if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
+	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
+#endif
+
+/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
+MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
+header files above, but not in this file, in order to generate the correct
+privileged Vs unprivileged linkage and placement. */
+#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
+
+
+/* This entire source file will be skipped if the application is not configured
+to include software timer functionality.  This #if is closed at the very bottom
+of this file.  If you want to include software timer functionality then ensure
+configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
+#if ( configUSE_TIMERS == 1 )
+
+/* Misc definitions. */
+#define tmrNO_DELAY		( TickType_t ) 0U
+
+/* The name assigned to the timer service task.  This can be overridden by
+defining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. */
+#ifndef configTIMER_SERVICE_TASK_NAME
+	#define configTIMER_SERVICE_TASK_NAME "Tmr Svc"
+#endif
+
+/* The definition of the timers themselves. */
+typedef struct tmrTimerControl
+{
+	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
+	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
+	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
+	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
+	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
+	#if( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
+	#endif
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t 			ucStaticallyAllocated; /*<< Set to pdTRUE if the timer was created statically so no attempt is made to free the memory again if the timer is later deleted. */
+	#endif
+} xTIMER;
+
+/* The old xTIMER name is maintained above then typedefed to the new Timer_t
+name below to enable the use of older kernel aware debuggers. */
+typedef xTIMER Timer_t;
+
+/* The definition of messages that can be sent and received on the timer queue.
+Two types of message can be queued - messages that manipulate a software timer,
+and messages that request the execution of a non-timer related callback.  The
+two message types are defined in two separate structures, xTimerParametersType
+and xCallbackParametersType respectively. */
+typedef struct tmrTimerParameters
+{
+	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
+	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
+} TimerParameter_t;
+
+
+typedef struct tmrCallbackParameters
+{
+	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
+	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
+	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
+} CallbackParameters_t;
+
+/* The structure that contains the two message types, along with an identifier
+that is used to determine which message type is valid. */
+typedef struct tmrTimerQueueMessage
+{
+	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
+	union
+	{
+		TimerParameter_t xTimerParameters;
+
+		/* Don't include xCallbackParameters if it is not going to be used as
+		it makes the structure (and therefore the timer queue) larger. */
+		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
+			CallbackParameters_t xCallbackParameters;
+		#endif /* INCLUDE_xTimerPendFunctionCall */
+	} u;
+} DaemonTaskMessage_t;
+
+/*lint -save -e956 A manual analysis and inspection has been used to determine
+which static variables must be declared volatile. */
+
+/* The list in which active timers are stored.  Timers are referenced in expire
+time order, with the nearest expiry time at the front of the list.  Only the
+timer service task is allowed to access these lists. */
+PRIVILEGED_DATA static List_t xActiveTimerList1;
+PRIVILEGED_DATA static List_t xActiveTimerList2;
+PRIVILEGED_DATA static List_t *pxCurrentTimerList;
+PRIVILEGED_DATA static List_t *pxOverflowTimerList;
+
+/* A queue that is used to send commands to the timer service task. */
+PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
+PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
+
+/*lint -restore */
+
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	/* If static allocation is supported then the application must provide the
+	following callback function - which enables the application to optionally
+	provide the memory that will be used by the timer task as the task's stack
+	and TCB. */
+	extern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );
+
+#endif
+
+/*
+ * Initialise the infrastructure used by the timer service task if it has not
+ * been initialised already.
+ */
+static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * The timer service task (daemon).  Timer functionality is controlled by this
+ * task.  Other tasks communicate with the timer service task using the
+ * xTimerQueue queue.
+ */
+static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
+
+/*
+ * Called by the timer service task to interpret and process a command it
+ * received on the timer queue.
+ */
+static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
+ * depending on if the expire time causes a timer counter overflow.
+ */
+static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
+
+/*
+ * An active timer has reached its expire time.  Reload the timer if it is an
+ * auto reload timer, then call its callback.
+ */
+static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
+
+/*
+ * The tick count has overflowed.  Switch the timer lists after ensuring the
+ * current timer list does not still reference some timers.
+ */
+static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
+ * if a tick count overflow occurred since prvSampleTimeNow() was last called.
+ */
+static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
+
+/*
+ * If the timer list contains any active timers then return the expire time of
+ * the timer that will expire first and set *pxListWasEmpty to false.  If the
+ * timer list does not contain any timers then return 0 and set *pxListWasEmpty
+ * to pdTRUE.
+ */
+static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
+
+/*
+ * If a timer has expired, process it.  Otherwise, block the timer service task
+ * until either a timer does expire or a command is received.
+ */
+static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
+
+/*
+ * Called after a Timer_t structure has been allocated either statically or
+ * dynamically to fill in the structure's members.
+ */
+static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const TickType_t xTimerPeriodInTicks,
+									const UBaseType_t uxAutoReload,
+									void * const pvTimerID,
+									TimerCallbackFunction_t pxCallbackFunction,
+									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
+/*-----------------------------------------------------------*/
+
+BaseType_t xTimerCreateTimerTask( void )
+{
+BaseType_t xReturn = pdFAIL;
+
+	/* This function is called when the scheduler is started if
+	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
+	timer service task has been created/initialised.  If timers have already
+	been created then the initialisation will already have been performed. */
+	prvCheckForValidListAndQueue();
+
+	if( xTimerQueue != NULL )
+	{
+		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+		{
+			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
+			StackType_t *pxTimerTaskStackBuffer = NULL;
+			uint32_t ulTimerTaskStackSize;
+
+			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
+			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
+													configTIMER_SERVICE_TASK_NAME,
+													ulTimerTaskStackSize,
+													NULL,
+													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
+													pxTimerTaskStackBuffer,
+													pxTimerTaskTCBBuffer );
+
+			if( xTimerTaskHandle != NULL )
+			{
+				xReturn = pdPASS;
+			}
+		}
+		#else
+		{
+			xReturn = xTaskCreate(	prvTimerTask,
+									configTIMER_SERVICE_TASK_NAME,
+									configTIMER_TASK_STACK_DEPTH,
+									NULL,
+									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
+									&xTimerTaskHandle );
+		}
+		#endif /* configSUPPORT_STATIC_ALLOCATION */
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	configASSERT( xReturn );
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+
+	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+								const TickType_t xTimerPeriodInTicks,
+								const UBaseType_t uxAutoReload,
+								void * const pvTimerID,
+								TimerCallbackFunction_t pxCallbackFunction )
+	{
+	Timer_t *pxNewTimer;
+
+		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
+
+		if( pxNewTimer != NULL )
+		{
+			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
+
+			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+			{
+				/* Timers can be created statically or dynamically, so note this
+				timer was created dynamically in case the timer is later
+				deleted. */
+				pxNewTimer->ucStaticallyAllocated = pdFALSE;
+			}
+			#endif /* configSUPPORT_STATIC_ALLOCATION */
+		}
+
+		return pxNewTimer;
+	}
+
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+										const TickType_t xTimerPeriodInTicks,
+										const UBaseType_t uxAutoReload,
+										void * const pvTimerID,
+										TimerCallbackFunction_t pxCallbackFunction,
+										StaticTimer_t *pxTimerBuffer )
+	{
+	Timer_t *pxNewTimer;
+
+		#if( configASSERT_DEFINED == 1 )
+		{
+			/* Sanity check that the size of the structure used to declare a
+			variable of type StaticTimer_t equals the size of the real timer
+			structure. */
+			volatile size_t xSize = sizeof( StaticTimer_t );
+			configASSERT( xSize == sizeof( Timer_t ) );
+		}
+		#endif /* configASSERT_DEFINED */
+
+		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
+		configASSERT( pxTimerBuffer );
+		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
+
+		if( pxNewTimer != NULL )
+		{
+			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
+
+			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+			{
+				/* Timers can be created statically or dynamically so note this
+				timer was created statically in case it is later deleted. */
+				pxNewTimer->ucStaticallyAllocated = pdTRUE;
+			}
+			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+		}
+
+		return pxNewTimer;
+	}
+
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+/*-----------------------------------------------------------*/
+
+static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const TickType_t xTimerPeriodInTicks,
+									const UBaseType_t uxAutoReload,
+									void * const pvTimerID,
+									TimerCallbackFunction_t pxCallbackFunction,
+									Timer_t *pxNewTimer )
+{
+	/* 0 is not a valid value for xTimerPeriodInTicks. */
+	configASSERT( ( xTimerPeriodInTicks > 0 ) );
+
+	if( pxNewTimer != NULL )
+	{
+		/* Ensure the infrastructure used by the timer service task has been
+		created/initialised. */
+		prvCheckForValidListAndQueue();
+
+		/* Initialise the timer structure members using the function
+		parameters. */
+		pxNewTimer->pcTimerName = pcTimerName;
+		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
+		pxNewTimer->uxAutoReload = uxAutoReload;
+		pxNewTimer->pvTimerID = pvTimerID;
+		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
+		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
+		traceTIMER_CREATE( pxNewTimer );
+	}
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
+{
+BaseType_t xReturn = pdFAIL;
+DaemonTaskMessage_t xMessage;
+
+	configASSERT( xTimer );
+
+	/* Send a message to the timer service task to perform a particular action
+	on a particular timer definition. */
+	if( xTimerQueue != NULL )
+	{
+		/* Send a command to the timer service task to start the xTimer timer. */
+		xMessage.xMessageID = xCommandID;
+		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
+		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
+
+		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
+		{
+			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
+			{
+				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
+			}
+			else
+			{
+				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
+			}
+		}
+		else
+		{
+			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
+		}
+
+		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
+{
+	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
+	started, then xTimerTaskHandle will be NULL. */
+	configASSERT( ( xTimerTaskHandle != NULL ) );
+	return xTimerTaskHandle;
+}
+/*-----------------------------------------------------------*/
+
+TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
+{
+Timer_t *pxTimer = ( Timer_t * ) xTimer;
+
+	configASSERT( xTimer );
+	return pxTimer->xTimerPeriodInTicks;
+}
+/*-----------------------------------------------------------*/
+
+TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
+{
+Timer_t * pxTimer = ( Timer_t * ) xTimer;
+TickType_t xReturn;
+
+	configASSERT( xTimer );
+	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+{
+Timer_t *pxTimer = ( Timer_t * ) xTimer;
+
+	configASSERT( xTimer );
+	return pxTimer->pcTimerName;
+}
+/*-----------------------------------------------------------*/
+
+static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
+{
+BaseType_t xResult;
+Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
+
+	/* Remove the timer from the list of active timers.  A check has already
+	been performed to ensure the list is not empty. */
+	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
+	traceTIMER_EXPIRED( pxTimer );
+
+	/* If the timer is an auto reload timer then calculate the next
+	expiry time and re-insert the timer in the list of active timers. */
+	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
+	{
+		/* The timer is inserted into a list using a time relative to anything
+		other than the current time.  It will therefore be inserted into the
+		correct list relative to the time this task thinks it is now. */
+		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
+		{
+			/* The timer expired before it was added to the active timer
+			list.  Reload it now.  */
+			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
+			configASSERT( xResult );
+			( void ) xResult;
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	else
+	{
+		mtCOVERAGE_TEST_MARKER();
+	}
+
+	/* Call the timer callback. */
+	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
+}
+/*-----------------------------------------------------------*/
+
+static void prvTimerTask( void *pvParameters )
+{
+TickType_t xNextExpireTime;
+BaseType_t xListWasEmpty;
+
+	/* Just to avoid compiler warnings. */
+	( void ) pvParameters;
+
+	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
+	{
+		extern void vApplicationDaemonTaskStartupHook( void );
+
+		/* Allow the application writer to execute some code in the context of
+		this task at the point the task starts executing.  This is useful if the
+		application includes initialisation code that would benefit from
+		executing after the scheduler has been started. */
+		vApplicationDaemonTaskStartupHook();
+	}
+	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
+
+	for( ;; )
+	{
+		/* Query the timers list to see if it contains any timers, and if so,
+		obtain the time at which the next timer will expire. */
+		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
+
+		/* If a timer has expired, process it.  Otherwise, block this task
+		until either a timer does expire, or a command is received. */
+		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
+
+		/* Empty the command queue. */
+		prvProcessReceivedCommands();
+	}
+}
+/*-----------------------------------------------------------*/
+
+static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
+{
+TickType_t xTimeNow;
+BaseType_t xTimerListsWereSwitched;
+
+	vTaskSuspendAll();
+	{
+		/* Obtain the time now to make an assessment as to whether the timer
+		has expired or not.  If obtaining the time causes the lists to switch
+		then don't process this timer as any timers that remained in the list
+		when the lists were switched will have been processed within the
+		prvSampleTimeNow() function. */
+		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
+		if( xTimerListsWereSwitched == pdFALSE )
+		{
+			/* The tick count has not overflowed, has the timer expired? */
+			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
+			{
+				( void ) xTaskResumeAll();
+				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
+			}
+			else
+			{
+				/* The tick count has not overflowed, and the next expire
+				time has not been reached yet.  This task should therefore
+				block to wait for the next expire time or a command to be
+				received - whichever comes first.  The following line cannot
+				be reached unless xNextExpireTime > xTimeNow, except in the
+				case when the current timer list is empty. */
+				if( xListWasEmpty != pdFALSE )
+				{
+					/* The current timer list is empty - is the overflow list
+					also empty? */
+					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
+				}
+
+				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
+
+				if( xTaskResumeAll() == pdFALSE )
+				{
+					/* Yield to wait for either a command to arrive, or the
+					block time to expire.  If a command arrived between the
+					critical section being exited and this yield then the yield
+					will not cause the task to block. */
+					portYIELD_WITHIN_API();
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+		}
+		else
+		{
+			( void ) xTaskResumeAll();
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
+{
+TickType_t xNextExpireTime;
+
+	/* Timers are listed in expiry time order, with the head of the list
+	referencing the task that will expire first.  Obtain the time at which
+	the timer with the nearest expiry time will expire.  If there are no
+	active timers then just set the next expire time to 0.  That will cause
+	this task to unblock when the tick count overflows, at which point the
+	timer lists will be switched and the next expiry time can be
+	re-assessed.  */
+	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
+	if( *pxListWasEmpty == pdFALSE )
+	{
+		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
+	}
+	else
+	{
+		/* Ensure the task unblocks when the tick count rolls over. */
+		xNextExpireTime = ( TickType_t ) 0U;
+	}
+
+	return xNextExpireTime;
+}
+/*-----------------------------------------------------------*/
+
+static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
+{
+TickType_t xTimeNow;
+PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
+
+	xTimeNow = xTaskGetTickCount();
+
+	if( xTimeNow < xLastTime )
+	{
+		prvSwitchTimerLists();
+		*pxTimerListsWereSwitched = pdTRUE;
+	}
+	else
+	{
+		*pxTimerListsWereSwitched = pdFALSE;
+	}
+
+	xLastTime = xTimeNow;
+
+	return xTimeNow;
+}
+/*-----------------------------------------------------------*/
+
+static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
+{
+BaseType_t xProcessTimerNow = pdFALSE;
+
+	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
+	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
+
+	if( xNextExpiryTime <= xTimeNow )
+	{
+		/* Has the expiry time elapsed between the command to start/reset a
+		timer was issued, and the time the command was processed? */
+		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
+		{
+			/* The time between a command being issued and the command being
+			processed actually exceeds the timers period.  */
+			xProcessTimerNow = pdTRUE;
+		}
+		else
+		{
+			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
+		}
+	}
+	else
+	{
+		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
+		{
+			/* If, since the command was issued, the tick count has overflowed
+			but the expiry time has not, then the timer must have already passed
+			its expiry time and should be processed immediately. */
+			xProcessTimerNow = pdTRUE;
+		}
+		else
+		{
+			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
+		}
+	}
+
+	return xProcessTimerNow;
+}
+/*-----------------------------------------------------------*/
+
+static void	prvProcessReceivedCommands( void )
+{
+DaemonTaskMessage_t xMessage;
+Timer_t *pxTimer;
+BaseType_t xTimerListsWereSwitched, xResult;
+TickType_t xTimeNow;
+
+	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
+	{
+		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
+		{
+			/* Negative commands are pended function calls rather than timer
+			commands. */
+			if( xMessage.xMessageID < ( BaseType_t ) 0 )
+			{
+				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
+
+				/* The timer uses the xCallbackParameters member to request a
+				callback be executed.  Check the callback is not NULL. */
+				configASSERT( pxCallback );
+
+				/* Call the function. */
+				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+		}
+		#endif /* INCLUDE_xTimerPendFunctionCall */
+
+		/* Commands that are positive are timer commands rather than pended
+		function calls. */
+		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
+		{
+			/* The messages uses the xTimerParameters member to work on a
+			software timer. */
+			pxTimer = xMessage.u.xTimerParameters.pxTimer;
+
+			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
+			{
+				/* The timer is in a list, remove it. */
+				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
+			}
+			else
+			{
+				mtCOVERAGE_TEST_MARKER();
+			}
+
+			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
+
+			/* In this case the xTimerListsWereSwitched parameter is not used, but
+			it must be present in the function call.  prvSampleTimeNow() must be
+			called after the message is received from xTimerQueue so there is no
+			possibility of a higher priority task adding a message to the message
+			queue with a time that is ahead of the timer daemon task (because it
+			pre-empted the timer daemon task after the xTimeNow value was set). */
+			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
+
+			switch( xMessage.xMessageID )
+			{
+				case tmrCOMMAND_START :
+			    case tmrCOMMAND_START_FROM_ISR :
+			    case tmrCOMMAND_RESET :
+			    case tmrCOMMAND_RESET_FROM_ISR :
+				case tmrCOMMAND_START_DONT_TRACE :
+					/* Start or restart a timer. */
+					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
+					{
+						/* The timer expired before it was added to the active
+						timer list.  Process it now. */
+						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
+						traceTIMER_EXPIRED( pxTimer );
+
+						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
+						{
+							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
+							configASSERT( xResult );
+							( void ) xResult;
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					else
+					{
+						mtCOVERAGE_TEST_MARKER();
+					}
+					break;
+
+				case tmrCOMMAND_STOP :
+				case tmrCOMMAND_STOP_FROM_ISR :
+					/* The timer has already been removed from the active list.
+					There is nothing to do here. */
+					break;
+
+				case tmrCOMMAND_CHANGE_PERIOD :
+				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
+					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
+					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
+
+					/* The new period does not really have a reference, and can
+					be longer or shorter than the old one.  The command time is
+					therefore set to the current time, and as the period cannot
+					be zero the next expiry time can only be in the future,
+					meaning (unlike for the xTimerStart() case above) there is
+					no fail case that needs to be handled here. */
+					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
+					break;
+
+				case tmrCOMMAND_DELETE :
+					/* The timer has already been removed from the active list,
+					just free up the memory if the memory was dynamically
+					allocated. */
+					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
+					{
+						/* The timer can only have been allocated dynamically -
+						free it again. */
+						vPortFree( pxTimer );
+					}
+					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+					{
+						/* The timer could have been allocated statically or
+						dynamically, so check before attempting to free the
+						memory. */
+						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
+						{
+							vPortFree( pxTimer );
+						}
+						else
+						{
+							mtCOVERAGE_TEST_MARKER();
+						}
+					}
+					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
+					break;
+
+				default	:
+					/* Don't expect to get here. */
+					break;
+			}
+		}
+	}
+}
+/*-----------------------------------------------------------*/
+
+static void prvSwitchTimerLists( void )
+{
+TickType_t xNextExpireTime, xReloadTime;
+List_t *pxTemp;
+Timer_t *pxTimer;
+BaseType_t xResult;
+
+	/* The tick count has overflowed.  The timer lists must be switched.
+	If there are any timers still referenced from the current timer list
+	then they must have expired and should be processed before the lists
+	are switched. */
+	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
+	{
+		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
+
+		/* Remove the timer from the list. */
+		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
+		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
+		traceTIMER_EXPIRED( pxTimer );
+
+		/* Execute its callback, then send a command to restart the timer if
+		it is an auto-reload timer.  It cannot be restarted here as the lists
+		have not yet been switched. */
+		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
+
+		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
+		{
+			/* Calculate the reload value, and if the reload value results in
+			the timer going into the same timer list then it has already expired
+			and the timer should be re-inserted into the current list so it is
+			processed again within this loop.  Otherwise a command should be sent
+			to restart the timer to ensure it is only inserted into a list after
+			the lists have been swapped. */
+			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
+			if( xReloadTime > xNextExpireTime )
+			{
+				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
+				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
+				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
+			}
+			else
+			{
+				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
+				configASSERT( xResult );
+				( void ) xResult;
+			}
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+
+	pxTemp = pxCurrentTimerList;
+	pxCurrentTimerList = pxOverflowTimerList;
+	pxOverflowTimerList = pxTemp;
+}
+/*-----------------------------------------------------------*/
+
+static void prvCheckForValidListAndQueue( void )
+{
+	/* Check that the list from which active timers are referenced, and the
+	queue used to communicate with the timer service, have been
+	initialised. */
+	taskENTER_CRITICAL();
+	{
+		if( xTimerQueue == NULL )
+		{
+			vListInitialise( &xActiveTimerList1 );
+			vListInitialise( &xActiveTimerList2 );
+			pxCurrentTimerList = &xActiveTimerList1;
+			pxOverflowTimerList = &xActiveTimerList2;
+
+			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+			{
+				/* The timer queue is allocated statically in case
+				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
+				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
+				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
+
+				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
+			}
+			#else
+			{
+				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
+			}
+			#endif
+
+			#if ( configQUEUE_REGISTRY_SIZE > 0 )
+			{
+				if( xTimerQueue != NULL )
+				{
+					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
+				}
+				else
+				{
+					mtCOVERAGE_TEST_MARKER();
+				}
+			}
+			#endif /* configQUEUE_REGISTRY_SIZE */
+		}
+		else
+		{
+			mtCOVERAGE_TEST_MARKER();
+		}
+	}
+	taskEXIT_CRITICAL();
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
+{
+BaseType_t xTimerIsInActiveList;
+Timer_t *pxTimer = ( Timer_t * ) xTimer;
+
+	configASSERT( xTimer );
+
+	/* Is the timer in the list of active timers? */
+	taskENTER_CRITICAL();
+	{
+		/* Checking to see if it is in the NULL list in effect checks to see if
+		it is referenced from either the current or the overflow timer lists in
+		one go, but the logic has to be reversed, hence the '!'. */
+		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) ); /*lint !e961. Cast is only redundant when NULL is passed into the macro. */
+	}
+	taskEXIT_CRITICAL();
+
+	return xTimerIsInActiveList;
+} /*lint !e818 Can't be pointer to const due to the typedef. */
+/*-----------------------------------------------------------*/
+
+void *pvTimerGetTimerID( const TimerHandle_t xTimer )
+{
+Timer_t * const pxTimer = ( Timer_t * ) xTimer;
+void *pvReturn;
+
+	configASSERT( xTimer );
+
+	taskENTER_CRITICAL();
+	{
+		pvReturn = pxTimer->pvTimerID;
+	}
+	taskEXIT_CRITICAL();
+
+	return pvReturn;
+}
+/*-----------------------------------------------------------*/
+
+void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
+{
+Timer_t * const pxTimer = ( Timer_t * ) xTimer;
+
+	configASSERT( xTimer );
+
+	taskENTER_CRITICAL();
+	{
+		pxTimer->pvTimerID = pvNewID;
+	}
+	taskEXIT_CRITICAL();
+}
+/*-----------------------------------------------------------*/
+
+#if( INCLUDE_xTimerPendFunctionCall == 1 )
+
+	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
+	{
+	DaemonTaskMessage_t xMessage;
+	BaseType_t xReturn;
+
+		/* Complete the message with the function parameters and post it to the
+		daemon task. */
+		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
+		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
+		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
+		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
+
+		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
+
+		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
+
+		return xReturn;
+	}
+
+#endif /* INCLUDE_xTimerPendFunctionCall */
+/*-----------------------------------------------------------*/
+
+#if( INCLUDE_xTimerPendFunctionCall == 1 )
+
+	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
+	{
+	DaemonTaskMessage_t xMessage;
+	BaseType_t xReturn;
+
+		/* This function can only be called after a timer has been created or
+		after the scheduler has been started because, until then, the timer
+		queue does not exist. */
+		configASSERT( xTimerQueue );
+
+		/* Complete the message with the function parameters and post it to the
+		daemon task. */
+		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
+		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
+		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
+		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
+
+		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
+
+		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
+
+		return xReturn;
+	}
+
+#endif /* INCLUDE_xTimerPendFunctionCall */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
+	{
+		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+#if ( configUSE_TRACE_FACILITY == 1 )
+
+	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
+	{
+		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
+	}
+
+#endif /* configUSE_TRACE_FACILITY */
+/*-----------------------------------------------------------*/
+
+/* This entire source file will be skipped if the application is not configured
+to include software timer functionality.  If you want to include software timer
+functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
+#endif /* configUSE_TIMERS == 1 */
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/freertos/version.txt ./libs/freertos/version.txt
--- a_bRU7kv/libs/freertos/version.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/freertos/version.txt	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1 @@
+FreeRTOS Kernel V10.0.1
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/documentation/api_reference_es.md ./libs/sapi/documentation/api_reference_es.md
--- a_bRU7kv/libs/sapi/documentation/api_reference_es.md	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/documentation/api_reference_es.md	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,804 @@
+# API de la biblioteca sAPI
+
+## Módulos
+
+### DataTypes
+
+Define las siguientes constantes:
+
+Estados lógicos
+
+- ``FALSE = 0``
+- ``TRUE  = !FALSE``
+
+Estados funcionales
+
+- ``ON  = 1``
+- ``OFF = 0``
+
+Estados eléctricos
+
+- ``HIGH = 1``
+- ``LOW  = 0``
+
+Estados de habilitación
+
+- ``ENABLE  = 1``
+- ``DISABLE = 0``
+
+Además define los tipos de datos:
+
+- **Booleano** ``bool_t``
+- **Enteros sin signo** ``uint8_t, uint16_t, uint32_t, uint64_t``
+- **Enteros con signo** ``int8_t, int16_t, int32_t, int64_t``
+- **Flotantes** ``float32_t, float64_t``
+- **String** ``string_t`` *(lo modelamos?? imagino una struct con el puntero al array y el tamaño)*
+
+El tipo de datos para el conteo de tiempo en la unidad Tick
+
+``typedef uint64_t tick_t;``
+
+Un tipo de datos para puntero a función:
+
+``typedef bool_t (*sapiFuncPtr_t)(void *);``
+
+- Parámetro: ``void *`` Para poder pasar cualquier argumento.
+- Retorna: ``bool_t`` Para reportar errores (TRUE si todo está bien).
+
+Utilizando este tipo de datos define la finción Nula que no hace nada y Retorna
+siempre TRUE, esta se utiliza para evitar errores de NULL POINTER.
+
+``bool_t sapiNullFuncPtr(void *);``
+
+- Parámetro: ``void *`` No usado.
+- Retorna: ``bool_t``Retorna siempre TRUE.
+
+
+### Peripheral Map
+
+Contiene el mapa de periféricos.
+
+**GPIO Map**
+
+EDU-CIAA-NXP:
+
+- P1 header
+
+	``T_FIL0, T_FIL1, T_FIL2, T_FIL3, 
+	 T_COL0,  T_COL1, T_COL2, 
+	 CAN_TD, CAN_RD, 
+	 RS232_TXD, RS232_RXD``
+
+	``GPIO25, GPIO26, GPIO27, GPIO28, 
+	 GPIO29, GPIO30, GPIO31, 
+	 GPIO32, GPIO33, 
+	 GPIO34, GPIO35``
+
+
+- P2 header
+
+	``GPIO0, GPIO1, GPIO2, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO8
+	 LCD1, LCD2, LCD3, LCD4, LCDEN, LCDRS,
+	 SPI_MISO, SPI_MOSI,
+	 ENET_TXD0, ENET_TXD1, ENET_TXEN, ENET_RXD0, ENET_RXD1, ENET_MDIO, ENET_CRS_DV, ENET_MDC,``
+
+	``GPIO0, GPIO1, GPIO2, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO8
+	 GPIO9, GPIO10, GPIO11, GPIO12, GPIO13, GPIO14,
+	 GPIO15, GPIO16,
+	 GPIO17, GPIO18, GPIO19, GPIO20, GPIO21, GPIO22, GPIO23, GPIO24,``
+
+
+- Switches
+
+	``TEC1,  TEC2,  TEC3,  TEC4``
+
+
+- Leds
+
+	``LED1,  LED2,  LED3,  LEDR,  LEDG,  LEDB``
+
+
+CIAA-NXP:
+
+``DI0,   DI1,   DI2,   DI3,   DI4,   DI5,   DI6,   DI7,
+ DO0,   DO1,   DO2,   DO3,   DO4,   DO5,   DO6,   DO7``
+
+**ADC Map**
+
+EDU-CIAA-NXP: ``CH1, CH2, CH3``
+
+EDU-CIAA-NXP: ``ADC0CH0, ADC0CH1, ADC0CH2``
+
+CIAA-NXP: ``AI0, AI1, AI2, AI3``
+
+**DAC Map**
+
+EDU-CIAA-NXP: ``DAC``
+
+CIAA-NXP: ``AO``
+
+**Uart Map**
+
+``UART_USB, UART_232, UART_485``
+``UART0, UART1, UART2``
+
+**Timer Map**
+
+``TIMER0, TIMER1, TIMER2, TIMER3, TIMER4``
+
+**Pwm Map**
+
+``PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6, PWM7, PWM8, PWM9, PWM10``
+
+**Servo Map**
+
+``SERVO0, SERVO1, SERVO2, SERVO3, SERVO4, SERVO5, SERVO6, SERVO7, SERVO8``
+
+**I2C Map**
+
+``I2C0``
+
+
+
+### GPIO
+
+Manejo de Entradas y Salidas (booleanas) de propósito general.
+
+**Configuración inicial y modo de una entrada o salida**
+
+``bool_t gpioConfig( gpioMap_t pin, gpioConfig_t config );``
+
+- Parámetro: ``gpioMap_t pin`` pin a configurar (ver GPIO Map).
+- Parámetro: ``gpioConfig_t config`` configuración.
+- Retorna: ``bool_t`` TRUE si la configuración es correcta.
+
+Posibles configuraciones:
+
+- ``GPIO_ENABLE`` Habilita las entradas y salidas de porpósito general.
+- ``GPIO_INPUT, GPIO_INPUT_PULLUP, GPIO_INPUT_PULLDOWN, GPIO_INPUT_PULLUP_PULLDOWN`` Pin configurado como entrada en sus distintas variantes.
+- ``GPIO_OUTPUT`` Pin configurado como salida.
+
+**Lectura de Entrada**
+
+``bool_t gpioRead( gpioMap_t pin );``
+
+- Parámetro: ``gpioMap_t pin`` pin a leer (ver GPIO Map).
+- Retorna: ``bool_t`` valor de la entrada.
+
+
+**Escritura de Salida**
+
+``bool_t gpioWrite( gpioMap_t pin, bool_t value );``
+
+- Parámetro: ``gpioMap_t pin`` pin a escribir (ver GPIO Map).
+- Parámetro: ``bool_t value`` valor a escribir en el pin.
+- Retorna: ``bool_t`` FALSE en caso de errores.
+
+
+### Tick
+
+**Configuración de interrupción periódica**
+
+``bool_t tickConfig(tick_t tickRateMSvalue, sAPI_FuncPtr_t tickHook );``
+
+- Parámetro: ``tick_t tickRateMSvalue`` cada cuantos ms ocurre un tick.
+- Parámetro: ``sAPI_FuncPtr_t tickHook`` función a ejecutar en cada tick.
+- Retorna: ``bool_t`` TRUE en en caso correcto o FALSE en caso de errores.
+
+Configura una interrupción periódica de temporizador cada tickRateMSvalue
+milisegundos para utilizar de base de tiempo del sistema. Una vez ejecutada
+esta función se dice que ocurre un tick del sistema cada tickRateMSvalue
+milisegundos.
+
+La tasa de ticks en ms, tickRateMS, es un parámetro con rango de 1 a 50 ms.
+
+Además de aumentar el conteo de ticks en cada interrupción, la función
+tickConfig ejecuta la función pasada como parámero cada vez que ocurre un tick.
+Si no se desea ejecutar ninguna función debe poner en cero este parámetro.
+
+**Leer la variable del conteo actual de ticks**
+
+``tick_t tickRead( void );``
+
+- Parámetro: ``void`` sin parámetro.
+- Retorna: ``tick_t`` el valor actual del contador de ticks.
+
+La variable del conteo actual de ticks se incrementa en 1 cada tickRateMSvalue
+milisegundos.
+
+**Escribir la variable del conteo actual de ticks**
+
+``void tickWrite( tick_t ticks );``
+
+- Parámetro: ``tick_t ticks`` el nuevo valor a setear del contador de ticks.
+- Retorna: ``void``
+
+Se utiliza si se necesita cambiar el valor del contador de ticks, por ejemplo,
+para resetearlo.
+
+En la implementación para la CIAA utiliza internaente el peiférico temporizador
+Systick para configurar una interrupción periódica.
+
+
+### Delay
+
+Para utilizar los retardos (con excepción del retardo inexacto) se debe
+configurar el Tick ya que utiliza estas interrupciones como base de tiempo.
+
+Todos los tiempos de parámetros están en milisegundos.
+
+Define la constante ``#define INACCURATE_TO_MS 20400`` y contiene las funciones:
+
+**Retardo inexacto bloqueante** ``void delayInaccurate( tick_t delay_ms );``
+
+- Parámetros: ``tick_t delay_ms`` tiempo de duración del retardo en ms.
+- Retorna: ``void``
+
+Utiliza un bloque for bloqueante que tiene una constante calculada "a ojo"
+(INACCURATE_TO_MS) para perder muchos ciclos de reloj y lograr hacer un retado.
+
+**Retardo bloqueante** ``void delay ( tick_t time );``
+
+- Parámetros: ``tick_t time``
+- Retorna: ``void``
+
+Utiliza el conteo de ticks para determinar el tiempo transcurrido resultando en
+un retardo exacto. Es bloqueante pues se queda en un bucle while hasta que se
+cuentan los ticks necesarios para lograr el tiempo especificado.
+
+**Retardo no bloqueante**
+
+Este tipo de retardo permite realizar otras tareas mientras se ejecuta ya que
+simplemente se chequea si el tiempo de retardo se ha arribado en lugar de
+quedarse bloqueado esperando a que se complete el tiempo como en los casos
+anteriores.
+
+Define el tipo de datos estructurado ``delay_t``
+
+Contiene las funciones:
+
+``void delayConfig( delay_t* delay, tick_t duration );``
+
+- Parámetro: ``delay_t * delay`` dirección de memoria de una variable del tipo delay_t.
+- Parámetro: ``tick_t duration`` tiempo de duración del retardo en ms.
+- Retorna: ``void``
+
+``bool_t delayRead( delay_t* delay );``
+
+- Parámetro: ``delay_t* delay`` dirección de memoria de una variable del tipo delay_t.
+- Retorna: ``bool_t`` TRUE cuando el delay se cumplió, FALSE en caso contrario.
+
+``void delayWrite( delay_t* delay, tick_t duration );``
+
+- Parámetro: ``delay_t* delay`` dirección de memoria de una variable del tipo delay_t.
+- Parámetro: ``tick_t duration`` tiempo de duración del retardo en ms.
+- Retorna: ``void``
+
+
+Uso:
+
+Se utiliza declarando una variable de estructura del tipo delay_t, por ejemplo:
+
+``delay_t myDelay;``
+
+Luego, se configura inicialmente pasando como parámetro la variable recién
+declarada
+
+``delayConfig( &myDelay, 500 );``
+
+Se detecta con un bloque if si se cumplió el delay leyéndolo con
+
+``delayRead( &myDelay );``
+
+La primera vez que se ejecuta delayRead activa el mismo. delayRead devuelve TRUE
+cuando se completo y se vuelve a relanzar automáticamente.
+
+Con ``delayWrite( &myDelay, 1000 );`` se puede cambiar la duración de un delay
+en tiempo de ejecución.
+
+
+
+### ADC
+
+Manejo de conversor analógico-digital.
+
+**Configuración inicial de conversor analógico-digital**
+
+``void adcConfig( adcConfig_t config );``
+
+- Parámetro: ``adcConfig_t config`` configuración.
+- Retorna: ``void``.
+
+Posibles configuraciones:
+
+- ``ADC_ENABLE`` Habilita el periférico ADC.
+- ``ADC_DISABLE`` Deshabilita el periférico ADC.
+
+**Lectura de Entrada analógica**
+
+``uint16_t adcRead( adcMap_t analogInput );``
+
+- Parámetro: ``adcMap_t analogInput`` pin a leer (ver ADC Map).
+- Retorna: ``uint16_t`` el valor actual de la entrada analógica.
+
+
+### DAC
+
+Manejo de conversor digital-analógico.
+
+**Configuración inicial de conversor digital-analógico**
+
+``void dacConfig( dacConfig_t config );``
+
+- Parámetro: ``dacConfig_t config`` configuración.
+- Retorna: ``void``.
+
+Posibles configuraciones:
+
+- ``DAC_ENABLE`` Habilita el periférico DAC.
+- ``DAC_DISABLE`` Deshabilita el periférico DAC.
+
+**Escritura de Salida analógica**
+
+``void dacWrite( dacMap_t analogOutput, uint16_t value );``
+
+- Parámetro: ``dacMap_t analogOutput`` pin a escribir (ver DAC Map).
+- Parámetro: ``uint16_t value`` valor del pin a escribir.
+- Retorna: ``void``.
+
+
+### UART
+
+Manejo del periférico de comunicación UART (puerto serie asincrónico).
+
+**Configuración**
+
+``void uartConfig( uartMap_t uart, uint32_t baudRate )``
+
+- Parámetro: ``uartMap_t uart`` UART a configurar (ver UART MAP).
+- Parámetro: ``uint32_t baudRate`` tasa de  bits.
+- Retorna: ``void``.
+
+Posibles configuraciones de baudRate: ``9600, 57600, 115200, etc.``
+
+**Recibir Byte**
+
+``bool_t uartReadByte( uartMap_t uart, uint8_t* receivedByte );``
+
+- Parámetro: ``uartMap_t uart`` UART a configurar (ver UART Map).
+- Parámetro: ``uint8_t* byte`` Dirección de memoria a donde se escribirá el dato recibido en caso de que haya un dato para recibir.
+- Retorna: ``bool_t`` TRUE si recibió un dato, FALSE en caso contrario.
+
+**Enviar Byte**
+
+``void uartWriteByte( uartMap_t uart, uint8_t byte );``
+
+- Parámetro: ``uartMap_t uart`` UART a configurar (ver UART Map).
+- Parámetro: ``uint8_t byte`` Byte a enviar.
+- Retorna: ``void``.
+
+**Enviar String**
+
+``void uartWriteString( uartMap_t uart, char* str );``
+
+- Parámetro: ``uartMap_t uart`` UART a configurar (ver UART Map).
+- Parámetro: ``char* str`` String a enviar, puede ser un literal, por ejemplo "hola", o un vector de uint8_t terminado en 0 o '\0' (caracter NULL).
+- Retorna: ``void``.
+
+
+### I2C
+
+Manejo del periférico bus comunicación I2C (Inter Integrated Circuits).
+
+**Configuración**
+
+``bool_t i2cConfig( i2cMap_t i2cNumber, uint32_t clockRateHz );``
+
+- Parámetro: ``i2cMap_t i2cNumber`` I2C a configurar (ver I2C Map).
+- Parámetro: ``uint32_t clockRateHz`` configuración de velocidad del bus I2C.
+- Retorna: ``bool_t`` TRUE si la configuración es correcta.
+
+Posibles configuraciones de clockRateHz: 100000, etc.
+
+**Lectura**
+
+``bool_t i2cRead( i2cMap_t  i2cNumber,
+                  uint8_t  i2cSlaveAddress,
+                  uint8_t* dataToReadBuffer,
+                  uint16_t dataToReadBufferSize,
+                  bool_t   sendWriteStop,
+                  uint8_t* receiveDataBuffer,
+                  uint16_t receiveDataBufferSize,
+                  bool_t   sendReadStop );``
+
+- Parámetro: ``i2cMap_t i2cNumber`` I2C a leer (ver I2C Map).
+- Parámetro: ``uint8_t i2cSlaveAddress`` Dirección del sensor conectado por I2C a leer.
+- Parámetro: ``uint8_t* dataToReadBuffer`` puntero al buffer con los bytes a escribir para indicar que se debe leer.
+- Parámetro: ``uint16_t dataToReadBufferSize`` tamaño del buffer con los bytes a escribir.
+- Parámetro: ``bool_t sendWriteStop`` setear en 1 para enviar stop al finalizar el comando de escritura, con 0 no se envía. Algunos periféricos pueden no necesitar el stop.
+- Parámetro: ``uint8_t* receiveDataBuffer`` puntero al buffer donde se almacenarán los datos leídos.
+- Parámetro: ``uint16_t receiveDataBufferSize`` tamaño del buffer donde se almacenarán los datos leídos.
+- Parámetro: ``bool_t sendReadStop`` setear en 1 para enviar stop al finalizar el comando de lectura, con 0 no se envía. Algunos periféricos pueden no necesitar el stop.
+- Retorna: ``bool_t`` TRUE si se pudo leer correctamente.
+
+**Escritura**
+
+``bool_t i2cWrite( i2cMap_t  i2cNumber,
+                   uint8_t  i2cSlaveAddress,
+                   uint8_t* transmitDataBuffer,
+                   uint16_t transmitDataBufferSize,
+                   bool_t   sendWriteStop );``
+
+- Parámetro: ``i2cMap_t i2cNumber`` ID de periférico I2C a escribir (ver I2C Map). Actualmente funciona únicamente el I2C0.
+- Parámetro: ``uint8_t i2cSlaveAddress`` Dirección del sensor conectado por I2C a escribir.
+- Parámetro: ``uint8_t* transmitDataBuffer`` puntero al buffer donde se encuentran los datos a escribir.
+- Parámetro: ``uint16_t transmitDataBufferSize`` tamaño del buffer donde se encuentran los datos a escribir.
+- Parámetro: ``bool_t sendWriteStop`` setear en 1 para enviar stop al finalizar el comando de escritura, con 0 no se envía. Algunos periféricos pueden no necesitar el stop.
+- Retorna: ``bool_t`` TRUE si se pudo escribir correctamente.
+
+### Sleep
+
+Manejo de modos de bajo consumo del microcontrolador.
+
+**Dormir hasta que ocurra la próxima interrupción**
+
+``void sleepUntilNextInterrupt( void );``
+
+- Parámetro: ninguno.
+- Retorna: nada.
+
+
+### RTC
+
+Manejo del periférico RTC (reloj de tiempo real).
+
+**Configuración**
+
+``bool_t rtcConfig( rtc_t * rtc );``
+
+- Parámetro: ``rtc_t * rtc`` Puntero a estructura de configuración del tipo RTC_t.
+- Retorna: ``bool_t`` TRUE si la configuración es correcta.
+
+La estructura del tipo ``RTC_t`` contiene los parámetros:
+
+- ``uint16_t year`` año, con valores desde 1 a 4095.
+- ``uint8_t month`` mes, con valores desde 1 a 12.
+- ``uint8_t mday`` día, con valores desde 1 a 31.
+- ``uint8_t wday`` día de la semana, con valores desde 1 a 7.
+- ``uint8_t hour`` horas, con valores desde 0 a 23.
+- ``uint8_t min`` minutos, con valores desde 0 a 59.
+- ``uint8_t sec`` segundos, con valores desde 0 a 59.
+
+**Lectura de fecha y hora**
+
+``bool_t rtcRead( rtc_t * rtc );``
+
+- Parámetro: ``rtc_t * rtc`` Puntero a estructura del tipo RTC_t donde se guarda la fecha y hora.
+- Retorna: ``bool_t`` TRUE.
+
+**Establecer la fecha y hora**
+
+``bool_t rtcWrite( rtc_t * rtc );``
+
+- Parámetro: ``rtc_t * rtc`` Puntero a estructura del tipo RTC_t con la nueva fecha y hora a setear.
+- Retorna: ``bool_t`` TRUE.
+
+
+### PWM
+
+Manejo de salidas PWM (modulación por ancho de pulso). En la EDU-CIAA-NXP se
+utiliza internamente el periférico SCT para generar los PWM.
+
+**Configuración**
+
+``bool_t pwmConfig( pwmMap_t pwmNumber, pwmConfig_t config);``
+
+- Parámetro: ``pwmMap_t pwmNumber`` pin a configurar como salida PWM (ver PWM Map).
+- Parámetro: ``uint8_t config`` configuración.
+- Retorna: ``bool_t`` TRUE si la configuración es correcta.
+
+Posibles configuraciones:
+
+- ``PWM_ENABLE`` habilita el o los Timers en modo PWM.
+- ``PWM_DISABLES`` deshabilita el o los Timers en modo PWM.
+- ``PWM_ENABLE_OUTPUT`` habilita la salida PWM particular.
+- ``PWM_DISABLE_OUTPUT`` deshabilita la salida PWM particular.
+
+**Lectura del ciclo de trabajo (duty cycle) de la salida PWM**
+
+``uint8_t pwmRead( pwmMap_t pwmNumber );``
+
+- Parámetro: ``pwmMap_t pwmNumber`` salida PWM a leer el ciclo de trabajo.
+- Retorna: ``uint8_t`` el ciclo de trabajo de la salida PWM.
+
+ **Establecer el ciclo de trabajo de la salida PWM**
+
+``bool_t pwmWrite( pwmMap_t pwmNumber, uint8_t percent );``
+
+- Parámetro: ``pwmMap_t pwmNumber`` salida PWM a leer el ciclo de trabajo.
+- Parámetro: ``uint8_t percent`` valor de ciclo de trabajo a setear en la salida PWM.
+- Retorna: ``bool_t`` TRUE.
+
+
+### Servo
+
+Manejo de salidas para Servomortores angulares (usan modulación por ancho de pulso). En la EDU-CIAA-NXP se utilizan internamente los periféricos TIMER para
+generar estas salidas.
+
+**Configuración**
+
+``bool_t servoConfig( servoMap_t servoNumber, servoConfig_t config );``
+
+- Parámetro: ``servoMap_t servoNumber`` pin a configurar como salida Servo (ver Servo Map).
+- Parámetro: ``servoConfig_t config`` configuración.
+- Retorna: ``bool_t`` TRUE si la configuración es correcta.
+
+Posibles configuraciones:
+
+- ``SERVO_ENABLE`` habilita el o los Timers en modo PWM para Servo.
+- ``SERVO_DISABLE`` deshabilita el o los Timers en modo PWM para Servo.
+- ``SERVO_ENABLE_OUTPUT`` habilita la salida PWM particular.
+- ``SERVO_DISABLE_OUTPUT`` deshabilita la salida PWM particular.
+
+**Lectura del valor angular actual de la salida Servo**
+
+``uint16_t servoRead( servoMap_t servoNumber);``
+
+- Parámetro: ``servoMap_t servoNumber`` pin como salida Servo a leer.
+- Retorna: ``uint16_t`` el valor angular actual de la salida Servo (de 0 a 180°).
+
+**Establecer el valor angular de la salida Servo**
+
+``bool_t servoWrite( servoMap_t servoNumber, uint16_t angle );``
+
+- Parámetro: ``servoMap_t servoNumber`` pin como salida Servo a escribir.
+- Parámetro: ``uint16_t angle`` valor angular a establecer en la salida Servo (de 0 a 180°).
+- Retorna: ``bool_t`` TRUE.
+
+
+### Display 7 segmentos
+
+**Configuración**
+
+Configurar los pines conectados al display 7 segmentos como salida:
+
+``void display7SegmentPinConfig( gpioMap_t* display7SegmentPins );``
+
+- Parámetro: ``gpioMap_t* display7SegmentPins`` puntero a un vector con los 8 pines conectados al display 7 segmentos, deben estar en el orden *a* a *h*.
+- Retorna: nada.
+
+![Imagen "7-segment-display.png" no encontrada](assets/img/7-segment-display.png "Display 7 segmentos")
+
+Ejemplo:
+
+``uint8_t display7Segment[8] = {
+    GPIO5, // Segment 'a'
+    GPIO7, // Segment 'b'
+    GPIO6, // Segment 'c'
+    GPIO1, // Segment 'd'
+    GPIO2, // Segment 'e'
+    GPIO4, // Segment 'f'
+    GPIO3, // Segment 'g'
+    GPIO8  // Segment 'h' or 'dp'
+ };``
+
+
+Testear en que orden están conectados los pines a los segmentos *a* a *h*:
+
+``void display7SegmentTestPins( gpioMap_t* display7SegmentPins, gpioMap_t pin );``
+
+- Parámetro: ``gpioMap_t* display7SegmentPins`` puntero a un vector con los 8 pines conectados al display 7 segmentos, deben estar en el orden *a* a *h*.
+- Parámetro: ``gpioMap_t pin`` un pin aparte que indica cuando escribe el segmento *a* para iniciar la secuencia de la *a* a *h*. Por ejemplo, LEDB.
+- Retorna: nada.
+
+Mediante esta función se puede completar la siguiente tabla que indica a qué pines se conecto el display 7 segmentos:
+
+| Segmento encendido     | Valor Binario | Valor Hexadecimal | Pin de salida |
+|:----------------------:|:-------------:|:-----------------:|:-------------:|
+| Segmento 'a' encendido | 0b00000001    |   0x20            | (a completar) |
+| Segmento 'b' encendido | 0b00000010    |   0x80            |               |
+| Segmento 'c' encendido | 0b00000100    |   0x40            |               |
+| Segmento 'd' encendido | 0b00001000    |   0x02            |               |
+| Segmento 'e' encendido | 0b00010000    |   0x04            |               |
+| Segmento 'f' encendido | 0b00100000    |   0x10            |               |
+| Segmento 'g' encendido | 0b01000000    |   0x08            |               |
+| Segmento 'h' encendido | 0b10000000    |   0x80            |               |
+
+
+**Escribir símbolo en display 7 segmentos**
+
+Escribe un símbolo en el display 7 segmentos.
+
+``void display7SegmentWrite( gpioMap_t* display7SegmentPins, uint8_t symbolIndex );``
+
+- Parámetro: ``gpioMap_t* display7SegmentPins`` puntero a un vector con los 8 pines conectados al display 7 segmentos, deben estar en el orden *a* a *h*.
+- Parámetro: ``uint8_t symbolIndex`` índice del valor a mostrar de la tabla de símbolos.
+- Retorna: nada.
+
+Tabla de símbolos:
+
+``0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
+ a, b, c, d, e, f,
+ A, C, E, H, J, L, P, U
+ ., DISPLAY_OFF``
+
+
+### Teclado matricial
+
+**Configuración**
+
+``bool_t keypadConfig( keypad_t* keypad,
+                      gpioMap_t* keypadRowPins, uint8_t keypadRowSize,
+                      gpioMap_t* keypadColPins, uint8_t keypadColSize );``
+
+- Parámetro: ``keypad_t* keypad`` puntero a estructura del teclado matricial donde se almacenan todos los parámetros necesarios del mismo.
+- Parámetro: ``gpioMap_t* keypadRowPins`` puntero a vector que contiene la lista de pines conectados a las filas del teclado matricial.
+- Parámetro: ``uint8_t keypadRowSize`` cantidad de filas del teclado matricial.
+- Parámetro: ``gpioMap_t* keypadColPins`` puntero a vector que contiene la lista de pines conectados a las columnas del teclado matricial.
+- Parámetro: ``uint8_t keypadColSize`` cantidad de columnas del teclado matricial.
+- Retorna: ``bool_t`` TRUE si los parámetros de configuración son válidos.
+
+![Imagen "keypad.png" no encontrada](assets/img/keypad.png "Teclado matricial 4x4")
+
+Ejemplo:
+
+- Variable del teclado
+
+      ``keypad_t keypad;``
+
+
+- Filas a configuar como Salidas
+
+      ``uint8_t keypadRowPins1[4] = {
+          RS232_TXD, // Row 0
+          CAN_RD,    // Row 1
+          CAN_TD,    // Row 2
+          T_COL1     // Row 3
+       };``
+
+
+- Columnas a configurar como Entradas con pull-up (MODO = GPIO_INPUT_PULLUP)
+
+      ``uint8_t keypadColPins1[4] = {
+          T_FIL0,    // Column 0
+          T_FIL3,    // Column 1
+          T_FIL2,    // Column 2
+          T_COL0     // Column 3
+       };``
+
+
+- Función de configuración
+
+      ``keypadConfig( &keypad, keypadRowPins1, 4, keypadColPins1, 4 );``
+
+**Lectura de teclado matricial**
+
+``bool_t keypadRead( keypad_t* keypad, uint16_t* key );``
+
+- Parámetro: ``keypad_t* keypad`` puntero a estructura del teclado matricial.
+- Parámetro: ``uint16_t* key`` puntero a variable donde escribe la tecla leida del teclado matricial.
+- Retorna: ``bool_t`` TRUE si hay tecla leida o FALSE en caso contrario.
+
+
+### sAPI HMC5883L
+
+Manejo del sensor magnetómetro vectorial (x,y,z) HMC5883L de Honeywell.
+Este sensor se conecta mediante I2C.
+
+**Configuración**
+
+``bool_t hmc5883lPrepareDefaultConfig( HMC5883L_config_t* config );``
+
+- Parámetro: ``HMC5883L_config_t *config`` puntero a estructura del tipo HMC5883L_config_t a donde se cargarán los valores por defecto de configuración.
+- Retorna: ``bool_t`` TRUE.
+
+``bool_t hmc5883lConfig( HMC5883L_config_t config );``
+
+- Parámetro: ``HMC5883L_config_t *config`` estructura del tipo HMC5883L_config_t desde donde se cargarán los valores de configuración.
+- Retorna: ``bool_t`` TRUE si la configuración es correcta.
+
+La estructura del tipo ``HMC5883L_config_t`` contiene:
+
+- ``HMC5883L_samples_t samples`` Numero de muestras que promedia para calcular la salida de la medición. Valores admitidos:
+    - HMC5883L_1_sample
+    - HMC5883L_2_sample
+    - HMC5883L_4_sample
+    - HMC5883L_8_sample
+    - HMC5883L_DEFAULT_sample = HMC5883L_1_sample
+- ``HMC5883L_rate_t rate`` Bits de tasa de datos de salida. Estos bits establecen la tasa de escritura de los 3 registros de datos de salida del sensor. Valores admitidos:
+    - HMC5883L_0_75_Hz
+    - HMC5883L_1_50_Hz
+    - HMC5883L_3_Hz
+    - HMC5883L_7_50_Hz
+    - HMC5883L_15_Hz
+    - HMC5883L_30_Hz
+    - HMC5883L_75_Hz
+    - HMC5883L_DEFAULT_rate = HMC5883L_15_Hz
+- ``HMC5883L_messurement_t meassurement`` Bits de configuración de medición. Estos bits definen el flujo de medición del sensor. Específicamente si se aplica, o no, un bias a la medición. Valores admitidos:
+    - HMC5883L_normal
+    - HMC5883L_positive
+    - HMC5883L_regative
+    - HMC5883L_DEFAULT_messurement = HMC5883L_normal
+- ``HMC5883L_gain_t gain`` Bits de configuración de ganancia. Estos bits configuran la ganancia del sensor. Esta configuración se aplica a todos los canales. Valores admitidos:
+    - HMC5883L_1370 para ± 0.88 Ga
+    - HMC5883L_1090 para ± 1.3 Ga
+    - HMC5883L_820 para ± 1.9 Ga
+    - HMC5883L_660 para ± 2.5 Ga
+    - HMC5883L_440 para ± 4.0 Ga
+    - HMC5883L_390 para ± 4.7 Ga
+    - HMC5883L_330 para ± 5.6 Ga
+    - HMC5883L_230 para ± 8.1 Ga
+    - HMC5883L_DEFAULT_gain = HMC5883L_1090
+- ``HMC5883L_mode_t mode``. Modo de medición. Valores admitidos:
+    - HMC5883L_continuous_measurement
+    - HMC5883L_single_measurement
+    - HMC5883L_idle
+    - HMC5883L_DEFAULT_mode = HMC5883L_single_measurement
+
+**Prueba de lectura del magnetómetro**
+
+``bool_t hmc5883lIsAlive( void );``
+
+- Parámetro: ``void`` ninguno.
+- Retorna: ``bool_t`` TRUE si puede comunicarse con el sensor.
+
+**Lectura del valor del magnetómetro en (x,y,z)**
+
+``bool_t hmc5883lRead( int16_t* x, int16_t* y, int16_t* z );``
+
+- Parámetro: ``int16_t * x`` puntero entero de 16 bits con signo donde se guardará el valor leído del sensor HMC5883L en la componente x.
+- Parámetro: ``int16_t * y`` puntero entero de 16 bits con signo donde se guardará el valor leído del sensor HMC5883L en la componente y.
+- Parámetro: ``int16_t * z`` puntero entero de 16 bits con signo donde se guardará el valor leído del sensor HMC5883L en la componente z.
+- Retorna: ``bool_t`` TRUE si puede leer correctamente el sensor magnetómetro.
+
+
+
+## Archivos que componen la biblioteca
+
+**src** (.c):
+
+- sapi_7_segment_display.c
+- sapi_adc.c
+- sapi_board.c
+- sapi_dac.c
+- sapi_datatypes.c
+- sapi_delay.c
+- sapi_gpio.c
+- sapi_hmc5883l.c
+- sapi_i2c.c
+- sapi_isr_vector.c
+- sapi_keypad.c
+- sapi_pwm.c
+- sapi_rtc.c
+- sapi_sct.c
+- sapi_servo.c
+- sapi_sleep.c
+- sapi_spi.c
+- sapi_tick.c
+- sapi_timer.c
+- sapi_uart.c
+
+**inc** (.h):
+
+- sapi_7_segment_display.h
+- sapi_adc.h
+- sapi_board.h
+- sapi_dac.h
+- sapi_datatypes.h
+- sapi_delay.h
+- sapi_gpio.h
+- sapi_hmc5883l.h
+- sapi_i2c.h
+- sapi_isr_vector.h
+- sapi_keypad.h
+- sapi_peripheral_map.h
+- sapi_pwm.h
+- sapi_rtc.h
+- sapi_sct.h
+- sapi_servo.h
+- sapi_sleep.h
+- sapi_spi.h
+- sapi_tick.h
+- sapi_timer.h
+- sapi_uart.h
+- sapi.h
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/documentation/PeripheralMap_CIAA-NXP.txt ./libs/sapi/documentation/PeripheralMap_CIAA-NXP.txt
--- a_bRU7kv/libs/sapi/documentation/PeripheralMap_CIAA-NXP.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/documentation/PeripheralMap_CIAA-NXP.txt	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,58 @@
+GPIO
+====
+
+Digital Inputs
+--------------
+
+DI0   BORN_24
+DI1   BORN_25
+DI2   BORN_26
+DI3   BORN_27
+DI4   BORN_28
+DI5   BORN_29
+DI6   BORN_30
+DI7   BORN_31
+
+Digital Outputs
+---------------
+
+DO0   BORN_04
+DO1   BORN_06
+DO2   BORN_08
+DO3   BORN_10
+DO4   BORN_14
+DO5   BORN_15
+DO6   BORN_16
+DO7   BORN_17
+
+
+UART
+====
+
+UART_USB   USB_DEBUG
+UART_232   CON_DB9_RS232
+UART_485   RS485_A         BORN_21  (sin implementar)
+           RS485_B         BORN_22
+           RS485_GND       BORN_23
+
+
+ADC
+===
+
+Analog Inputs
+-------------
+
+AI0   BORN_33
+AI1   BORN_34
+AI2   BORN_35
+AI3   BORN_36
+
+
+DAC
+===
+
+Analog Output
+-------------
+
+AO   BORN_01
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/documentation/PeripheralMap_EDU-CIAA-NXP.txt ./libs/sapi/documentation/PeripheralMap_EDU-CIAA-NXP.txt
--- a_bRU7kv/libs/sapi/documentation/PeripheralMap_EDU-CIAA-NXP.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/documentation/PeripheralMap_EDU-CIAA-NXP.txt	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,118 @@
+GPIO
+====
+
+P1
+--
+
+RS232_RXD     P1_PIN23
+RS232_TXD     P1_PIN25
+CAN_RD        P1_PIN27
+CAN_TD        P1_PIN29
+T_FIL0        P1_PIN33
+T_FIL3        P1_PIN35
+T_FIL1        P1_PIN36
+T_FIL2        P1_PIN37
+T_COL0        P1_PIN39
+T_COL1        P1_PIN31
+T_COL2        P1_PIN34
+
+P2
+--
+			 			
+ENET_RXD1     P2_PIN04
+ENET_TXEN     P2_PIN06
+ENET_MDC      P2_PIN08
+ENET_RXD0     P2_PIN09
+ENET_CRS_DV   P2_PIN10
+ENET_MDIO     P2_PIN12
+ENET_TXD0     P2_PIN14
+ENET_TXD1     P2_PIN16
+SPI_MISO      P2_PIN18
+SPI_MOSI      P2_PIN21
+LCDEN         P2_PIN23
+LCDRS         P2_PIN24 
+LCD1          P2_PIN30
+LCD2          P2_PIN28
+LCD3          P2_PIN26
+LCD4          P2_PIN22
+GPIO0         P2_PIN29
+GPIO1         P2_PIN32
+GPIO2         P2_PIN31
+GPIO3         P2_PIN34
+GPIO4         P2_PIN33
+GPIO5         P2_PIN36
+GPIO6         P2_PIN35
+GPIO7         P2_PIN38
+GPIO8         P2_PIN40
+
+
+UART
+====
+
+UART_USB   USB_DEBUG
+
+UART_232   P1_PIN23   RS232_RXD
+           P1_PIN25   RS232_TXD
+
+UART_485   BORN_RS485   (sin implementar)
+
+
+ADC
+===
+
+CH1   P1_PIN13
+CH2   P1_PIN11
+CH3   P1_PIN09
+
+
+DAC
+===
+
+DAC   P1_PIN15
+
+
+I2C
+===
+
+I2C0   P1_PIN19   I2C_SDA
+       P1_PIN21   I2C_SCL
+
+
+SPI
+===
+
+SPI0   P2_PIN18   SPI_MISO
+       P2_PIN20   SPI_SCK
+       P2_PIN21   SPI_MOSI
+       P2_PIN29   GPIO0 (SPI_SS)
+
+
+PWM
+====
+
+PWM0    T_FIL1   (CTOUT1)
+PWM1    T_COL2   (CTOUT12)
+PWM2    T_COL0   (CTOUT10)
+PWM3    T_FIL2   (CTOUT0)
+PWM4    T_FIL3   (CTOUT3)
+PWM5    T_COL1   (CTOUT13)
+PWM6    GPIO8    (CTOUT7)
+PWM7    LED1     (CTOUT2)
+PWM8    LED2     (CTOUT5)
+PWM9    LED3     (CTOUT4)
+PWM10   GPIO2    (CTOUT6)
+
+
+SERVO
+=====
+
+SERVO0   T_FIL1
+SERVO1   T_COL0
+SERVO2   T_FIL2
+SERVO3   T_FIL3
+SERVO4   GPIO8 
+SERVO5   LCD1
+SERVO6   LCD2
+SERVO7   LCD3
+SERVO8   GPIO2
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/LICENSE ./libs/sapi/LICENSE
--- a_bRU7kv/libs/sapi/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/LICENSE	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,27 @@
+Copyright (c) 2015-2017, Eric Pernia
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of sAPI nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/module.mk ./libs/sapi/module.mk
--- a_bRU7kv/libs/sapi/module.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/module.mk	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,8 @@
+ifeq ($(USE_SAPI),y)
+
+SAPI_BASE=libs/sapi
+DEFINES+=USE_SAPI
+INCLUDES += -I$(SAPI_BASE)/sapi_v0.5.1/inc
+SRC+=$(wildcard $(SAPI_BASE)/sapi_v0.5.1/src/*.c)
+
+endif
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/README.md ./libs/sapi/README.md
--- a_bRU7kv/libs/sapi/README.md	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/README.md	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,53 @@
+# sAPI library for microcontrollers
+
+This library implements a simple API that acts as a HAL (Hardware Abstraction
+Layer) for microcontrollers.
+
+It takes ideas from *Wiring library*, but use the concept of *peripheral* instead
+the concept of *pin*, making the API regardless of the number of pins that use
+certain peripheral.
+
+## Documentation
+
+**NOTE:** Always use the [released versions](../../releases) because these are tested all examples and the API documentation is consistent. The master branch may contain inconsistencies because this library is currently under development.
+
+### Included modules
+
+**Internal Peripherals**
+
+- Data types.
+- Peripheral Map.
+- Board.
+- Tick.
+- GPIO.
+- UART.
+- ADC.
+- DAC.
+- I2C.
+- RTC.
+- Sleep.
+- PWM.
+
+**Delays**
+
+- Delay.
+
+**External Peripherals**
+
+- 7-segment display.
+- Keypad.
+- Angular Servo (0 to 180°).
+- Magnetometer (compass) sensor HMC5883L.
+
+Every module includes an example.
+
+### Software layers
+
+![ "sapi-modulos-capas.png" image not found](docs/assets/img/sapi-modulos-capas.png "Modules an layers of sAPI library")
+
+### Boards
+
+Now available for boards:
+
+- EDU-CIAA-NXP (NXP LPC4337 microcontroller). [Download documentation.](docs/assets/pdf/EDU-CIAA-NXP_sAPI_bm_A4_v1r0_ES.pdf)
+- CIAA-NXP (NXP LPC4337 microcontroller).
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.c ./libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.c	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,304 @@
+/* Copyright 2017, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+    Copyright 2001 Georges Menie
+    https://www.menie.org/georges/embedded/small_printf_source_code.html
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+	putchar is the only external dependency for this file,
+	if you have a working putchar, just remove the following
+	define. If the function should be called something else,
+	replace outbyte(c) by your own function call.
+ */
+
+/*
+ * Date: 2017-11-01
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_stdio.h"
+
+/*==================[macros and definitions]=================================*/
+
+#define putchar(c)      outbyte(c)
+#define PAD_RIGHT       1
+#define PAD_ZERO        2
+#define PRINT_BUF_LEN   12
+
+/*==================[internal data declaration]==============================*/
+
+static uartMap_t UartPrintf = UART_USB;
+
+/*==================[internal functions declaration]=========================*/
+
+static void printchar (char **str, int c);
+
+static int  prints    (char **out, const char *string, int width, int pad);
+
+static int  printi    (char **out, int i, int b, int sg, int width, int pad, int letbase);
+
+static int  print     (char **out, int *varg);
+
+/*==================[internal data definition]===============================*/
+
+void        _outbyte  (int c)
+{
+   uartWriteByte(UartPrintf, (char)c);
+}
+
+void        outbyte   (int c)
+{
+   static char prev = 0;
+   if (c < ' ' && c != '\r' && c != '\n' && c != '\t' && c != '\b')
+      return;
+   if (c == '\n' && prev != '\r') _outbyte('\r');
+   _outbyte(c);
+   prev = c;
+}
+
+/**
+ * Imprime un char en un string o por la UART.
+ * Si str es distinto de null (es decir sprintf)
+ * entra en el if y guarda el char en str.
+ * Sino, llama a putchar, que a fin de cuentas
+ * termina sacando un dato por la UART.
+ * @param str
+ * @param c
+ */
+static void printchar (char **str, int c)
+{
+   extern void putchar(int c);
+   if (str) {
+      **str = c;
+      ++(*str);
+   } else {
+      (void)putchar(c);
+   }
+}
+
+static int  prints    (char **out, const char *string, int width, int pad)
+{
+   register int pc = 0, padchar = ' ';
+
+   if (width > 0) {
+      register int len = 0;
+      register const char *ptr;
+      for (ptr = string; *ptr; ++ptr) ++len;
+      if (len >= width) width = 0;
+      else width -= len;
+      if (pad & PAD_ZERO) padchar = '0';
+   }
+   if (!(pad & PAD_RIGHT)) {
+      for ( ; width > 0; --width) {
+         printchar (out, padchar);
+         ++pc;
+      }
+   }
+   for ( ; *string ; ++string) {
+      printchar (out, *string);
+      ++pc;
+   }
+   for ( ; width > 0; --width) {
+      printchar (out, padchar);
+      ++pc;
+   }
+   return pc;
+}
+
+static int  printi    (char **out, int i, int b, int sg, int width, int pad, int letbase)
+{
+   char print_buf[PRINT_BUF_LEN];
+   register char *s;
+   register int t, neg = 0, pc = 0;
+   register unsigned int u = i;
+
+   if (i == 0) {
+      print_buf[0] = '0';
+      print_buf[1] = '\0';
+      return prints (out, print_buf, width, pad);
+   }
+
+   if (sg && b == 10 && i < 0) {
+      neg = 1;
+      u = -i;
+   }
+
+   s = print_buf + PRINT_BUF_LEN-1;
+   *s = '\0';
+
+   while (u) {
+      t = u % b;
+      if( t >= 10 )
+         t += letbase - '0' - 10;
+      *--s = t + '0';
+      u /= b;
+   }
+
+   if (neg) {
+      if( width && (pad & PAD_ZERO) ) {
+         printchar (out, '-');
+         ++pc;
+         --width;
+      } else {
+         *--s = '-';
+      }
+   }
+
+   return pc + prints (out, s, width, pad);
+}
+
+static int  print     (char **out, int *varg)
+{
+   register int width, pad;
+   register int pc = 0;
+   register char *format = (char *)(*varg++);
+   char scr[2];
+
+   for (; *format != 0; ++format) {
+      if (*format == '%') {
+         ++format;
+         width = pad = 0;
+         if (*format == '\0') break;
+         if (*format == '%') goto out;
+         if (*format == '-') {
+            ++format;
+            pad = PAD_RIGHT;
+         }
+         while (*format == '0') {
+            ++format;
+            pad |= PAD_ZERO;
+         }
+         for ( ; *format >= '0' && *format <= '9'; ++format) {
+            width *= 10;
+            width += *format - '0';
+         }
+         if( *format == 's' ) {
+            register char *s = *((char **)varg++);
+            pc += prints (out, s?s:"(null)", width, pad);
+            continue;
+         }
+         if( *format == 'd' ) {
+            pc += printi (out, *varg++, 10, 1, width, pad, 'a');
+            continue;
+         }
+         if( *format == 'x' ) {
+            pc += printi (out, *varg++, 16, 0, width, pad, 'a');
+            continue;
+         }
+         if( *format == 'X' ) {
+            pc += printi (out, *varg++, 16, 0, width, pad, 'A');
+            continue;
+         }
+         if( *format == 'u' ) {
+            pc += printi (out, *varg++, 10, 0, width, pad, 'a');
+            continue;
+         }
+         if( *format == 'c' ) {
+            /* char are converted to int then pushed on the stack */
+            scr[0] = *varg++;
+            scr[1] = '\0';
+            pc += prints (out, scr, width, pad);
+            continue;
+         }
+      } else {
+out:
+         printchar (out, *format);
+         ++pc;
+      }
+   }
+   if (out) **out = '\0';
+   return pc;
+}
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* Se asume que sizeof(void *) == sizeof(int) */
+
+/**
+ * Configura la UART por la que va a salir el printf.
+ * No es necesario usarla en esta version.
+ * @param uartPrintf UART para printf
+ * @return TRUE
+ */
+bool_t stdioInit( uartMap_t uartPrintf )
+{
+   UartPrintf = uartPrintf;
+   return TRUE;
+}
+
+/**
+ * Realiza un printf sobre la UART seleccionada
+ * @param uartPrintf UART_USB, UART_232 o UART_485
+ * @param format el string formateado con argumentos.
+ * @return TRUE si salio bien, FALSE caso contrario.
+ */
+int stdioPrintf(uartMap_t uartPrintf, const char *format, ...)
+{
+   register int *varg = (int *)(&format);
+   UartPrintf = uartPrintf;
+   return print(0, varg);
+}
+
+/**
+ * Realiza un prinft sobre un array.
+ * Esta funcion es una adaptacion de la funcion
+ * sprintf de la libreria standard de C.
+ * @param out el array a guardar los datos.
+ * @param format el string formateado con argumentos.
+ * @return TRUE si salio bien, FALSE caso contrario.
+ */
+int stdioSprintf(char *out, const char *format, ...)
+{
+   register int *varg = (int *)(&format);
+   return print(&out, varg);
+}
+
+/*==================[end of file]============================================*/
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.h ./libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/deprecated/sapi_stdio.h	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,61 @@
+/* Copyright 2017, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-30-10 */
+
+#ifndef _SAPI_STDIO_H_
+#define _SAPI_STDIO_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi.h"
+
+/*==================[macros]=================================================*/
+
+#define stdioConfig stdioInit
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t stdioInit( uartMap_t uartPrintf );
+
+int stdioPrintf( uartMap_t uartPrintf, const char* format, ... );
+
+int stdioSprintf( char* out, const char* format, ... );
+
+/*==================[end of file]============================================*/
+
+#endif /* #ifndef _SAPI_STDIO_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_7_segment_display.h ./libs/sapi/sapi_v0.5.1/inc/sapi_7_segment_display.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_7_segment_display.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_7_segment_display.h	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,89 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _SAPI_7_SEGMENT_DISPLAY_H_
+#define _SAPI_7_SEGMENT_DISPLAY_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[macros]=================================================*/
+
+#define DISPLAY_7_SEGMENT_OFF 25
+
+#define display7SegmentPinConfig display7SegmentPinInit
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/* Test 7-segment display connected pins */
+/*
+----------------+------------+-----------+------------
+ Segment ON     | BIN Value  | HEX Value | Output pin
+----------------+------------+-----------+------------
+ Segment 'a' ON | 0b00000001 |   0x20    | ..... (to be complete)
+ Segment 'b' ON | 0b00000010 |   0x80    | .....
+ Segment 'c' ON | 0b00000100 |   0x40    | .....
+ Segment 'd' ON | 0b00001000 |   0x02    | .....
+ Segment 'e' ON | 0b00010000 |   0x04    | .....
+ Segment 'f' ON | 0b00100000 |   0x10    | .....
+ Segment 'g' ON | 0b01000000 |   0x08    | .....
+ Segment 'h' ON | 0b10000000 |   0x80    | .....
+----------------+------------+-----------+------------
+
+             a
+           -----
+       f /     / b
+        /  g  /
+        -----
+    e /     / c
+     /  d  /
+     -----    O h = dp (decimal point).
+
+*/
+void display7SegmentTestPins( gpioMap_t* display7SegmentPins, gpioMap_t pin );
+
+/* Configure 7-segment display GPIOs as Outputs */
+void display7SegmentPinInit( gpioMap_t* display7SegmentPins );
+
+/* Write a symbol on 7-segment display */
+void display7SegmentWrite( gpioMap_t* display7SegmentPins, uint8_t symbolIndex );
+
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_7_SEGMENT_DISPLAY_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_adc.h ./libs/sapi/sapi_v0.5.1/inc/sapi_adc.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_adc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_adc.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,76 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+#ifndef SAPI_ADC_H_
+#define SAPI_ADC_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#define adcConfig adcInit
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+   ADC_ENABLE, ADC_DISABLE
+} adcInit_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void adcInit( adcInit_t config );
+
+uint16_t adcRead( adcMap_t analogInput );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef SAPI_ADC_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_board.h ./libs/sapi/sapi_v0.5.1/inc/sapi_board.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_board.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_board.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,68 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_BOARD_H_
+#define _SAPI_BOARD_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define boardConfig boardInit
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void boardInit(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_BOARD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_circularBuffer.h ./libs/sapi/sapi_v0.5.1/inc/sapi_circularBuffer.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_circularBuffer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_circularBuffer.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,204 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Date: 2016-10-06 */
+
+#ifndef _CIRCULAR_BUFFER_H_
+#define _CIRCULAR_BUFFER_H_
+
+/*==================[inclusions]=============================================*/
+
+//#include <stdint.h>
+#include "sapi_datatypes.h"        // data types
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define circularBufferConfig circularBufferInit
+
+#define circularBufferNew( buffName, elementSize, amountOfElements )   circularBuffer_t buffName; \
+   uint8_t buffName##_BufferMemory[ ((amountOfElements) + 1) * (elementSize) ];
+
+/*
+#define circularBufferNew( buffName, elementsSize, amountOfElements )   uint8_t buffName##_BufferMemory[ ((amountOfElements) + 1) * (elementsSize) ]; \
+   circularBuffer_t buffName = { .memoryAddress    = (buffName##_BufferMemory), \
+                                 .amountOfElements = ((amountOfElements) + 1),  \
+                                 .elementSize      = (elementsSize),            \
+                                 .readIndex        = 0,                         \
+                                 .writeIndex       = 0,                         \
+                                 .status           = CIRCULAR_BUFFER_EMPTY      \
+   }
+ */
+
+
+#define circularBufferUse( buffName );   extern circularBuffer_t buffName;
+
+#define circularBufferInit( buffName, elementSize, amountOfElements );   circularBuffer_Init( &(buffName), buffName##_BufferMemory, amountOfElements, elementSize );
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+   CIRCULAR_BUFFER_NORMAL,
+   CIRCULAR_BUFFER_EMPTY,
+   CIRCULAR_BUFFER_FULL
+} circularBufferStatus_t;
+
+
+typedef struct {
+   uint8_t* memoryAddress;
+   uint32_t amountOfElements;
+   uint32_t elementSize;
+   uint32_t readIndex;
+   uint32_t writeIndex;
+   circularBufferStatus_t status;
+   callBackFuncPtr_t emptyBufferCallback;
+   callBackFuncPtr_t fullBufferCalback;
+} circularBuffer_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void circularBuffer_Init(
+   circularBuffer_t* buffer,    // buffer structure
+   uint8_t* bufferMemory,       // buffer array of memory
+   uint32_t amountOfElements,   // amount of elements in buffer
+   uint32_t elementSize         // each element size in bytes
+);
+
+void circularBufferEmptyBufferCallbackSet(
+   circularBuffer_t* buffer,              // buffer structure
+   callBackFuncPtr_t emptyBufferCallback  // pointer to emptyBuffer function
+);
+
+void circularBufferFullBufferCallbackSet(
+   circularBuffer_t* buffer,              // buffer structure
+   callBackFuncPtr_t fullBufferCalback    // pointer to fullBuffer function
+);
+
+circularBufferStatus_t circularBufferRead( circularBuffer_t* buffer,
+      uint8_t *dataByte );
+
+circularBufferStatus_t circularBufferWrite( circularBuffer_t* buffer,
+      uint8_t *dataByte );
+
+/*==================[cplusplus]==============================================*/
+
+
+
+/*==================[example]==============================================*/
+
+/*
+#include "sapi.h"        // <= Biblioteca sAPI
+
+#ifndef UART_DEBUG
+   #define UART_DEBUG UART_USB
+#endif
+
+void emptyBuff( void ){
+   uartWriteString( UART_DEBUG, "Buffer vacio.\r\n" );
+}
+
+void fullBuff( void ){
+   uartWriteString( UART_DEBUG, "Buffer lleno.\r\n" );
+}
+
+// FUNCION PRINCIPAL, PUNTO DE ENTRADA AL PROGRAMA LUEGO DE ENCENDIDO O RESET.
+int main( void ){
+
+   // ---------- CONFIGURACIONES ------------------------------
+
+   // Inicializar y configurar la plataforma
+   boardInit();
+
+   // Inicializar UART_USB como salida de consola
+   consolePrintInitUart( UART_DEBUG, 115200 );
+
+
+   static uint8_t txData = '1';
+   static uint8_t rxData;
+
+   // myBuff, buffer name (strcture)
+   // 1, each element size in bytes
+   // 8, amount of elements in buffer
+   circularBufferNew( myBuff, 1, 8 );
+   circularBufferInit( myBuff, 1, 8 );
+
+   circularBufferSetEmptyBufferCallback( &myBuff,     // buffer structure
+	                                     emptyBuff ); // pointer to emptyBuffer function
+
+   circularBufferSetFullBufferCallback( &myBuff,      // buffer structure
+		                                fullBuff );   // pointer to fullBuffer function
+
+   // ---------- REPETIR POR SIEMPRE --------------------------
+   while( TRUE )
+   {
+	   if( uartReadByte( UART_DEBUG, &rxData ) ){
+
+		  if( rxData == 'w' ){
+			 if( circularBufferWrite( &myBuff, &txData ) == CIRCULAR_BUFFER_NORMAL ){
+				uartWriteString( UART_DEBUG, "guarde un " );
+				uartWriteByte( UART_DEBUG, txData );
+				uartWriteString( UART_DEBUG, " en el buffer.\r\n" );
+				txData++;
+			 }
+
+		  }
+
+		  if( rxData == 'r' ){
+			 if( circularBufferRead( &myBuff, &rxData ) == CIRCULAR_BUFFER_NORMAL ){
+				uartWriteString( UART_DEBUG, "Lei un " );
+				uartWriteByte( UART_DEBUG, rxData );
+				uartWriteString( UART_DEBUG, " del buffer.\r\n" );
+			 }
+		  }
+	   }
+
+	   if(txData > '9')
+		  txData = '1';
+   }
+
+   return 0;
+}
+*/
+
+// -----------------------------------------
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _CIRCULAR_BUFFER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_consolePrint.h ./libs/sapi/sapi_v0.5.1/inc/sapi_consolePrint.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_consolePrint.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_consolePrint.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,60 @@
+/* Copyright 2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * Author: Eng. Eric Pernia.
+ * Date: 2017-04-17
+ */
+
+#ifndef _CONSOLE_PRINT_H_
+#define _CONSOLE_PRINT_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_print.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define consolePrintConfigUart consolePrintInitUart
+
+// Initialize
+#define CONSOLE_PRINT_ENABLE                      static print_t consolePrint;
+#define consolePrintSetUart(uart)                 printSetUart(&(consolePrint),(uart))
+#define consolePrintInitUart(uart,baudRate)       printInitUart(&(consolePrint),(uart),(baudRate))
+
+// Print String
+#define consolePrintString(string)                printString((consolePrint),(string))
+#define consolePrintEnter()                       printEnter(consolePrint)
+#define consolePrintlnString(string)              printlnString((consolePrint),(string))
+
+// Print Integer
+#define consolePrintIntFormat(number,format)      printIntFormat((consolePrint),(number),(format))
+#define consolePrintUIntFormat(number,format)     printUIntFormat((consolePrint),(number),(format))
+#define consolePrintlnIntFormat(number,format)    printlnIntFormat((consolePrint),(number),(format))
+#define consolePrintlnUIntFormat(number,format)   printlnUIntFormat((consolePrint),(number),(format))
+#define consolePrintInt(number)                   printInt((consolePrint),(number))
+#define consolePrintUInt(number)                  printUInt((consolePrint),(number))
+#define consolePrintlnInt(number)                 printlnInt((consolePrint),(number))
+#define consolePrintlnUInt(number)                printlnUInt((consolePrint),(number))
+#define consolePrintHex(number,bitSize)           printHex((consolePrint),(number),(bitSize))
+#define consolePrintlnHex(number,bitSize)         printlnHex((consolePrint),(number),(bitSize))
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _CONSOLE_PRINT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_convert.h ./libs/sapi/sapi_v0.5.1/inc/sapi_convert.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_convert.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_convert.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,79 @@
+/* Copyright 2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Date: 2017-04-17 */
+
+#ifndef _SAPI_CONVERT_H_
+#define _SAPI_CONVERT_H_
+
+/*
+
+API
+---
+
+// C++ version 0.4 char* style "itoa":
+bool_t int64ToString( int64_t value, char* result, uint8_t base );
+bool_t uint64ToString( uint64_t value, char* result, uint8_t base );
+
+char* uintToAsciiHex( uint64_t value, uint8_t bitSize );
+*/
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+   BIN_FORMAT = 2,
+   DEC_FORMAT = 10,
+   HEX_FORMAT = 16
+} numberFormat_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+// C++ version 0.4 char* style "itoa":
+bool_t int64ToString( int64_t value, char* result, uint8_t base );
+bool_t uint64ToString( uint64_t value, char* result, uint8_t base );
+
+char* uintToAsciiHex( uint64_t value, uint8_t bitSize );
+
+char* intToString( int64_t value );
+
+/*==================[examples]===============================================*/
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_CONVERT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_cyclesCounter.h ./libs/sapi/sapi_v0.5.1/inc/sapi_cyclesCounter.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_cyclesCounter.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_cyclesCounter.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,84 @@
+/* Copyright 2017, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-30-10 */
+
+// More information at:
+// https://groups.google.com/forum/#!msg/embebidos32/tPntHHUSnyE/S3CDyCwXsaMJ
+
+#ifndef _SAPI_CYCLES_COUNTER_H_
+#define _SAPI_CYCLES_COUNTER_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+// TODO: Check CPU core speed using SystemCoreClock
+#define EDU_CIAA_NXP_CLOCK_SPEED	204000000
+
+#define cyclesCounterConfig cyclesCounterInit
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[ISR external functions definition]======================*/
+
+/*==================[external functions definition]==========================*/
+
+bool_t cyclesCounterInit( uint32_t clockSpeed );
+
+uint32_t cyclesCounterRead( void );
+
+void cyclesCounterReset( void );
+
+float cyclesCounterToUs( uint32_t cycles );
+
+float cyclesCounterToMs( uint32_t cycles );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_CYCLES_COUNTER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_dac.h ./libs/sapi/sapi_v0.5.1/inc/sapi_dac.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_dac.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_dac.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,76 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+#ifndef SAPI_DAC_H_
+#define SAPI_DAC_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#define dacConfig dacInit
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+   DAC_ENABLE, DAC_DISABLE
+} dacInit_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void dacInit( dacInit_t config );
+
+void dacWrite( dacMap_t analogOutput, uint16_t value );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_DAC_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_datatypes.h ./libs/sapi/sapi_v0.5.1/inc/sapi_datatypes.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_datatypes.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_datatypes.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,124 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_DATATYPES_H_
+#define _SAPI_DATATYPES_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "stdint.h"
+#include "chip.h"
+#include "board.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+/* Functional states */
+#ifndef ON
+#define ON     1
+#endif
+#ifndef OFF
+#define OFF    0
+#endif
+
+/* Electrical states */
+#ifndef HIGH
+#define HIGH   1
+#endif
+#ifndef LOW
+#define LOW    0
+#endif
+
+/* Logical states */
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+#ifndef TRUE
+#define TRUE   (!FALSE)
+#endif
+
+/*==================[typedef]================================================*/
+
+/* Define Boolean Data Type */
+typedef uint8_t bool_t;
+
+/* Define real Data Types (floating point) */
+typedef float  real32_t;
+//typedef double real64_t; // In LPC4337 float = double (Floating Point single precision, 32 bits)
+
+/* Define Tick Data Type */
+typedef uint64_t tick_t;
+
+/*
+ * Function Pointer definition
+ * --------------------------------------
+ * param:  void * - For passing arguments
+ * return: bool_t - For Error Reports
+ */
+typedef bool_t (*sAPI_FuncPtr_t)(void *);
+
+/*
+ * Function Pointer definition
+ * --------------------------------------
+ * param:  void
+ * return: void
+ */
+typedef void (*callBackFuncPtr_t)(void *);
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * Null Function Pointer definition
+ * --------------------------------------
+ * param:  void * - Not used
+ * return: bool_t - Return always true
+ */
+bool_t sAPI_NullFuncPtr(void *);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_DATATYPES_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_debugPrint.h ./libs/sapi/sapi_v0.5.1/inc/sapi_debugPrint.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_debugPrint.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_debugPrint.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,153 @@
+/* Copyright 2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * Author: Eng. Eric Pernia.
+ * Date: 2017-04-17
+ */
+
+#ifndef _DEBUG_PRINT_H_
+#define _DEBUG_PRINT_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_print.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define DEBUG_PRINT   ON
+
+#define debugPrintConfigUart debugPrintInitUart
+
+/*
+API
+---
+
+// Initialize
+void debugPrintInit( uartMap_t uart, uint32_t baudRate );
+void debugPrintSetUart( uartMap_t uart );
+
+// Print String
+void debugPrintString( const char* string );
+void debugPrintlnString( const char* string );
+void debugPrintEnter( void );
+
+// Print Integer
+void debugPrintIntFormat( int64_t number, numberFormat_t format );
+void debugPrintUIntFormat( uint64_t number, numberFormat_t format );
+void debugPrintlnIntFormat( int64_t number, numberFormat_t format );
+void debugPrintlnUIntFormat( uint64_t number, numberFormat_t format );
+void debugPrintInt( int64_t number );
+void debugPrintUInt( uint64_t number );
+void debugPrintlnInt( int64_t number );
+void debugPrintlnUInt( uint64_t number );
+void debugPrintHex( uint64_t number, uint8_t bitSize );
+void debugPrintlnHex( uint64_t number, uint8_t bitSize );
+*/
+
+// Initialize
+
+#if( DEBUG_PRINT == ON )
+
+// Initialize
+#define DEBUG_PRINT_ENABLE                      static print_t debugPrint;
+#define debugPrintSetUart(uart)                 printSetUart(&(debugPrint),(uart))
+#define debugPrintInitUart(uart,baudRate)       printInitUart(&(debugPrint),(uart),(baudRate))
+
+// Print String
+#define debugPrintString(string)                printString((debugPrint),(string))
+#define debugPrintEnter()                       printEnter(debugPrint)
+#define debugPrintlnString(string)              printlnString((debugPrint),(string))
+
+// Print Integer
+#define debugPrintIntFormat(number,format)      printIntFormat((debugPrint),(number),(format))
+#define debugPrintUIntFormat(number,format)     printUIntFormat((debugPrint),(number),(format))
+#define debugPrintlnIntFormat(number,format)    printlnIntFormat((debugPrint),(number),(format))
+#define debugPrintlnUIntFormat(number,format)   printlnUIntFormat((debugPrint),(number),(format))
+#define debugPrintInt(number)                   printInt((debugPrint),(number))
+#define debugPrintUInt(number)                  printUInt((debugPrint),(number))
+#define debugPrintlnInt(number)                 printlnInt((debugPrint),(number))
+#define debugPrintlnUInt(number)                printlnUInt((debugPrint),(number))
+#define debugPrintHex(number,bitSize)           printHex((debugPrint),(number),(bitSize))
+#define debugPrintlnHex(number,bitSize)         printlnHex((debugPrint),(number),(bitSize))
+
+#else
+
+// Initialize
+#define DEBUG_PRINT_ENABLE                      (void)
+#define debugPrintSetUart(uart)                 do { (void) (uart); (void) (baudRate); } while(0)
+#define debugPrintConfigUart(uart,baudRate)     do { (void) (uart); (void) (baudRate); } while(0)
+
+// Print String
+#define debugPrintString(string)                do { (void) (string); } while(0)
+#define debugPrintEnter()                       (void)
+#define debugPrintlnString(string)              do { (void) (string); } while(0)
+
+// Print Integer
+#define debugPrintIntFormat(number,format)      do { (void) (number); (void) (format); } while(0)
+#define debugPrintUIntFormat(number,format)     do { (void) (number); (void) (format); } while(0)
+#define debugPrintlnIntFormat(number,format)    do { (void) (number); (void) (format); } while(0)
+#define debugPrintlnUIntFormat(number,format)   do { (void) (number); (void) (format); } while(0)
+#define debugPrintInt(number)                   do { (void) (number); } while(0)
+#define debugPrintUInt(number)                  do { (void) (number); } while(0)
+#define debugPrintlnInt(number)                 do { (void) (number); } while(0)
+#define debugPrintlnUInt(number)                do { (void) (number); } while(0)
+#define debugPrintHex(number,bitSize)           do { (void) (number); (void) (bitSize); } while(0)
+#define debugPrintlnHex(number,bitSize)         do { (void) (number); (void) (bitSize); } while(0)
+#endif
+
+
+/*
+#define MACRO(num, str) {\
+            printf("%d", num);\
+            printf(" is");\
+            printf(" %s number", str);\
+            printf("\n");\
+           }
+*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[examples]===============================================*/
+
+/*
+debugPrintLnString( "Uart Debug configurada." );
+debugPrintLnString( "Uart LoRa RN2903 configurada." );
+
+debugPrintString( "Numero de algo: " );
+debugPrintInt( 45454578 );
+debugPrintLnString( "" );
+
+debugPrintLnInt( -457 );
+debugPrintLnUInt( -457 );
+
+debugPrintString( "Numero de algo: " );
+debugPrintIntFormat( 45454578, DEC_FORMAT );
+debugPrintLnString( "" );
+
+debugPrintString( "Numero de algo: 0b" );
+debugPrintIntFormat( 45454578, BIN_FORMAT );
+debugPrintLnString( "" );
+
+debugPrintString( "Numero de algo: 0x" );
+debugPrintIntFormat( 45454578, HEX_FORMAT );
+debugPrintLnString( "" );
+*/
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _DEBUG_PRINT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_delay.h ./libs/sapi/sapi_v0.5.1/inc/sapi_delay.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_delay.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_delay.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,89 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_DELAY_H_
+#define _SAPI_DELAY_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/* Define the number of cycles for 1ms */
+#define INACCURATE_TO_MS       20400
+#define INACCURATE_TO_US_x10   204
+
+#define delayConfig delayInit
+
+/*==================[typedef]================================================*/
+
+typedef struct{
+   tick_t startTime;
+   tick_t duration;
+   bool_t running;
+} delay_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/* ---- Inaccurate Delay ---- */
+void delayInaccurate( tick_t delay );
+void delayInaccurateUs(tick_t delay_us);
+
+/* ---- Blocking Delay ---- */
+void delay( tick_t delay );
+void delayUs(tick_t delay_us);
+
+/* ---- Non Blocking Delay ---- */
+void delayInit( delay_t * delay, tick_t duration );
+bool_t delayRead( delay_t * delay );
+void delayWrite( delay_t * delay, tick_t duration );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_DELAY_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_dht11.h ./libs/sapi/sapi_v0.5.1/inc/sapi_dht11.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_dht11.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_dht11.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,47 @@
+/* Copyright 2017, Sebastian Pablo Bedin <sebabedin@gmail.com>
+ * Copyright 2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-11-13 */
+
+#ifndef _DHT11_H_
+#define _DHT11_H_
+
+#include "sapi_datatypes.h"
+
+#define dht11Config dht11Init
+
+void dht11Init( int32_t gpio );
+bool_t dht11Read( float *phum, float *ptemp );
+
+#endif /* _DHT11_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_esp8266.h ./libs/sapi/sapi_v0.5.1/inc/sapi_esp8266.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_esp8266.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_esp8266.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,78 @@
+/* Copyright 2016, Marcelo Vieytes.
+ * Copyright 2017, Pablo Gomez, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-14-11 */
+
+#ifndef _SAPI_ESP8266_
+#define _SAPI_ESP8266_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define esp8266ConfigHttpServer esp8266InitHttpServer
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t esp8266InitHttpServer( char * wifiName, char * wifiPass, uartMap_t debugUart, uint32_t debugBaudRate );
+bool_t esp8266ReadHttpServer();
+bool_t esp8266WriteHttpServer( const char * webHttpHeader, char * webHttpBody, const char * webHttpEnd );
+
+char* esp8266GetIpAddress();
+char* esp8266GetWifiName();
+char* esp8266GetWifiPass();
+uint8_t esp8266GetConnectionId();
+
+void uart232Callback(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_ESP8266_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_gpio.h ./libs/sapi/sapi_v0.5.1/inc/sapi_gpio.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_gpio.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_gpio.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,104 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_GPIO_H_
+#define _SAPI_GPIO_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define gpioConfig gpioInit
+
+/*==================[typedef]================================================*/
+
+/* Pin modes */
+/*
+ *  INPUT  =  0    (No PULLUP or PULLDOWN)
+ *  OUTPUT =  1
+ *  INPUT_PULLUP
+ *  INPUT_PULLDOWN
+ *  INPUT_REPEATER (PULLUP and PULLDOWN)
+ *  INITIALIZE
+ */
+typedef enum {
+   GPIO_INPUT, GPIO_OUTPUT,
+   GPIO_INPUT_PULLUP, GPIO_INPUT_PULLDOWN,
+   GPIO_INPUT_PULLUP_PULLDOWN,
+   GPIO_ENABLE
+} gpioInit_t;
+
+
+/* ----- Begin Pin Init Structs NXP LPC4337 ----- */
+
+typedef struct {
+   int8_t port;
+   int8_t pin;
+} gpioInitLpc4337_t;
+
+typedef struct {
+   pinInitLpc4337_t pinName;
+   int8_t func;
+   gpioInitLpc4337_t gpio;
+} pinInitGpioLpc4337_t;
+
+/* ------ End Pin Init Structs NXP LPC4337 ------ */
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t gpioInit( gpioMap_t pin, gpioInit_t config );
+bool_t gpioRead( gpioMap_t pin );
+bool_t gpioWrite( gpioMap_t pin, bool_t value );
+bool_t gpioToggle( gpioMap_t pin );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_GPIO_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi.h ./libs/sapi/sapi_v0.5.1/inc/sapi.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi.h	2018-12-01 17:15:06.613606091 -0300
@@ -0,0 +1,112 @@
+/* Copyright 2015-2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_H_
+#define _SAPI_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+//#include "sapi_isr_vector.h"
+
+// Peripheral Drivers
+
+#include "sapi_board.h"                  // Use clock peripheral
+#include "sapi_tick.h"                   // Use Systick peripheral
+#include "sapi_gpio.h"                   // Use GPIO peripherals
+#include "sapi_uart.h"                   // Use UART peripherals
+#include "sapi_adc.h"                    // Use ADC0 peripheral
+#include "sapi_dac.h"                    // Use DAC peripheral
+#include "sapi_i2c.h"                    // Use I2C0 peripheral
+#include "sapi_spi.h"                    // Use SPI0 peripheral
+#include "sapi_rtc.h"                    // Use RTC peripheral
+#include "sapi_sleep.h"                  // Use ARM ASM instructions
+#include "sapi_cyclesCounter.h"          // Use ARM Debug Registers
+
+// High Level drivers     
+
+//#include "sapi_stdio.h"                  // Use sapi_uart module
+
+#include "sapi_print.h"                  // Use sapi_uart module
+#include "sapi_debugPrint.h"             // Use sapi_print module
+#include "sapi_consolePrint.h"           // Use sapi_print module
+
+#include "sapi_convert.h"                // Use <string.h>
+
+#include "sapi_delay.h"                  // Use sapi_tick module
+#include "sapi_pwm.h"                    // Use sapi_sct and sapi_gpio modules
+#include "sapi_circularBuffer.h"         // It has no dependencies
+
+// External Peripheral Drivers
+
+#include "sapi_7_segment_display.h"      // Use sapi_gpio and sapi_delay modules
+#include "sapi_keypad.h"                 // Use sapi_gpio and sapi_delay modules
+#include "sapi_servo.h"                  // Use sapi_timer and sapi_gpio modules
+#include "sapi_rgb.h"                    // Use TIMER peripheral
+#include "sapi_dht11.h"                  // Use sapi_gpio peripheral
+#include "sapi_esp8266.h"                // Use sapi_uart module
+#include "sapi_lcd.h"                    // Use sapi_gpio peripherals
+
+#include "sapi_ultrasonic_hcsr04.h"      //
+#include "sapi_magnetometer_hmc5883l.h"  // Use sapi_i2c module
+#include "sapi_magnetometer_qmc5883l.h"  // Use sapi_i2c module
+#include "sapi_imu_mpu9250.h"            // Use sapi_i2c module
+
+
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_i2c.h ./libs/sapi/sapi_v0.5.1/inc/sapi_i2c.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_i2c.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_i2c.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,141 @@
+/* Copyright 2016, Eric Pernia
+ * Copyright 2016, Alejandro Permingeat.
+ * Copyright 2016, Eric Pernia
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Date:
+ * 2016-05-02 Eric Pernia - Only define API
+ * 2016-06-23 Alejandro Permingeat - First functional version
+ * 2016-08-07 Eric Pernia - Improve names
+ * 2016-09-10 Eric Pernia - Add unlimited buffer transfer
+ * 2016-11-20 Eric Pernia - Software I2C
+ */
+
+#ifndef _SAPI_I2C_H_
+#define _SAPI_I2C_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[macros]=================================================*/
+
+#define I2C_SOFTWARE_SDA_DIR   GPIO7
+#define I2C_SOFTWARE_SDA_IN    GPIO7
+#define I2C_SOFTWARE_SDA_OUT   GPIO7
+
+#define I2C_SOFTWARE_SCL_DIR   GPIO8
+#define I2C_SOFTWARE_SCL_IN    GPIO8
+#define I2C_SOFTWARE_SCL_OUT   GPIO8
+
+#define I2C_SOFTWARE           0
+#define SOFTWARE_I2C_DEBUG     0
+
+#define i2cConfig i2cInit
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[typedef]================================================*/
+
+#if( I2C_SOFTWARE == 1 )
+typedef enum {
+   I2C_SOFTWARE_WRITE = 0,
+   I2C_SOFTWARE_READ  = 1
+} I2C_Software_rw_t;
+
+typedef enum {
+   I2C_SOFTWARE_NACK = 0,
+   I2C_SOFTWARE_ACK  = 1
+} I2C_Software_ack_t;
+#endif
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t i2cInit( i2cMap_t i2cNumber, uint32_t clockRateHz );
+
+bool_t i2cRead( i2cMap_t  i2cNumber,
+                uint8_t  i2cSlaveAddress,
+                uint8_t* dataToReadBuffer,
+                uint16_t dataToReadBufferSize,
+                bool_t   sendWriteStop,
+                uint8_t* receiveDataBuffer,
+                uint16_t receiveDataBufferSize,
+                bool_t   sendReadStop );
+
+bool_t i2cWrite( i2cMap_t  i2cNumber,
+                 uint8_t  i2cSlaveAddress,
+                 uint8_t* transmitDataBuffer,
+                 uint16_t transmitDataBufferSize,
+                 bool_t   sendWriteStop );
+
+
+// Software Master I2C
+
+#if( SOFTWARE_I2C_DEBUG == 1 )
+void i2cSoftwareMasterPinTestInit( void );
+void i2cSoftwareMasterPinTest( void );
+#endif
+
+#if( I2C_SOFTWARE == 1 )
+void i2cSoftwareDelay( tick_t duration );
+
+void i2cSoftwareMasterWriteStart( void );
+
+void i2cSoftwareMasterWriteStop( void );
+
+bool_t i2cSoftwareMasterWriteAddress( uint8_t i2cSlaveAddress,
+                                      I2C_Software_rw_t readOrWrite );
+
+bool_t i2cSoftwareMasterWriteByte( uint8_t dataByte );
+
+uint8_t i2cSoftwareMasterReadByte( bool_t ack );
+#endif
+
+/*==================[ISR external functions declaration]=====================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_I2C_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_imu_mpu9250.h ./libs/sapi/sapi_v0.5.1/inc/sapi_imu_mpu9250.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_imu_mpu9250.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_imu_mpu9250.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,312 @@
+/* Copyright 2017 Bolder Flight Systems <brian.taylor@bolderflight.com>.
+ * Copyright 2018, Sergio Renato De Jesus Melean <sergiordj@gmail.com>.
+ * Copyright 2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Date: 2018-07-06 */
+
+#ifndef _SAPI_IMU_MPU9250_H_
+#define _SAPI_IMU_MPU9250_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+// physical constants
+#define MPU9250_G                     9.807f
+#define MPU9250_D2R                   3.14159265359f/180.0f
+
+// MPU9250 registers
+#define MPU9250_ACCEL_OUT             0x3B
+#define MPU9250_GYRO_OUT              0x43
+#define MPU9250_TEMP_OUT              0x41
+#define MPU9250_EXT_SENS_DATA_00      0x49
+#define MPU9250_ACCEL_CONFIG 	        0x1C
+#define MPU9250_ACCEL_FS_SEL_2G       0x00
+#define MPU9250_ACCEL_FS_SEL_4G       0x08
+#define MPU9250_ACCEL_FS_SEL_8G       0x10
+#define MPU9250_ACCEL_FS_SEL_16G      0x18
+#define MPU9250_GYRO_CONFIG           0x1B
+#define MPU9250_GYRO_FS_SEL_250DPS    0x00
+#define MPU9250_GYRO_FS_SEL_500DPS    0x08
+#define MPU9250_GYRO_FS_SEL_1000DPS   0x10
+#define MPU9250_GYRO_FS_SEL_2000DPS   0x18
+
+#define MPU9250_ACCEL_CONFIG2         0x1D
+#define MPU9250_ACCEL_DLPF_184        0x01
+#define MPU9250_ACCEL_DLPF_92         0x02
+#define MPU9250_ACCEL_DLPF_41         0x03
+#define MPU9250_ACCEL_DLPF_20         0x04
+#define MPU9250_ACCEL_DLPF_10         0x05
+#define MPU9250_ACCEL_DLPF_5          0x06
+#define MPU9250_CONFIG                0x1A
+#define MPU9250_GYRO_DLPF_184         0x01
+#define MPU9250_GYRO_DLPF_92          0x02
+#define MPU9250_GYRO_DLPF_41          0x03
+#define MPU9250_GYRO_DLPF_20          0x04
+#define MPU9250_GYRO_DLPF_10          0x05
+#define MPU9250_GYRO_DLPF_5           0x06
+#define MPU9250_SMPDIV                0x19
+#define MPU9250_INT_PIN_CFG           0x37
+#define MPU9250_INT_ENABLE            0x38
+#define MPU9250_INT_DISABLE           0x00
+#define MPU9250_INT_PULSE_50US        0x00
+#define MPU9250_INT_WOM_EN            0x40
+#define MPU9250_INT_RAW_RDY_EN        0x01
+#define MPU9250_PWR_MGMNT_1           0x6B
+#define MPU9250_PWR_CYCLE             0x20
+#define MPU9250_PWR_RESET             0x80
+#define MPU9250_CLOCK_SEL_PLL         0x01
+#define MPU9250_PWR_MGMNT_2           0x6C
+#define MPU9250_SEN_ENABLE            0x00
+#define MPU9250_DIS_GYRO              0x07
+#define MPU9250_USER_CTRL             0x6A
+#define MPU9250_I2C_MST_EN            0x20
+#define MPU9250_I2C_MST_CLK           0x0D
+#define MPU9250_I2C_MST_CTRL          0x24
+#define MPU9250_I2C_SLV0_ADDR         0x25
+#define MPU9250_I2C_SLV0_REG          0x26
+#define MPU9250_I2C_SLV0_DO           0x63
+#define MPU9250_I2C_SLV0_CTRL         0x27
+#define MPU9250_I2C_SLV0_EN           0x80
+#define MPU9250_I2C_READ_FLAG         0x80
+#define MPU9250_MOT_DETECT_CTRL       0x69
+#define MPU9250_ACCEL_INTEL_EN        0x80
+#define MPU9250_ACCEL_INTEL_MODE      0x40
+#define MPU9250_LP_ACCEL_ODR          0x1E
+#define MPU9250_WOM_THR               0x1F
+#define MPU9250_WHO_AM_I              0x75
+#define MPU9250_FIFO_EN               0x23
+#define MPU9250_FIFO_TEMP             0x80
+#define MPU9250_FIFO_GYRO             0x70
+#define MPU9250_FIFO_ACCEL            0x08
+#define MPU9250_FIFO_MAG              0x01
+#define MPU9250_FIFO_COUNT            0x72
+#define MPU9250_FIFO_READ             0x74
+
+// AK8963 registers
+#define MPU9250_AK8963_I2C_ADDR       0x0C
+#define MPU9250_AK8963_HXL            0x03
+#define MPU9250_AK8963_CNTL1          0x0A
+#define MPU9250_AK8963_PWR_DOWN       0x00
+#define MPU9250_AK8963_CNT_MEAS1      0x12
+#define MPU9250_AK8963_CNT_MEAS2      0x16
+#define MPU9250_AK8963_FUSE_ROM       0x0F
+#define MPU9250_AK8963_CNTL2          0x0B
+#define MPU9250_AK8963_RESET          0x01
+#define MPU9250_AK8963_ASA            0x10
+#define MPU9250_AK8963_WHO_AM_I       0x00
+
+// I2C baudrate
+#define MPU9250_I2C_RATE              400000 // 400 kHz
+
+/*==================[typedef]================================================*/
+
+//Different options for basic MPU9250 setting registers
+
+typedef enum {
+   MPU9250_ADDRESS_0 = 0x68,
+   MPU9250_ADDRESS_1 = 0x69
+} MPU9250_address_t;
+
+typedef enum
+{
+   MPU9250_ACCEL_RANGE_2G,
+   MPU9250_ACCEL_RANGE_4G,
+   MPU9250_ACCEL_RANGE_8G,
+   MPU9250_ACCEL_RANGE_16G
+} MPU9250_AccelRange_t;
+
+typedef enum
+{
+   MPU9250_GYRO_RANGE_250DPS,
+   MPU9250_GYRO_RANGE_500DPS,
+   MPU9250_GYRO_RANGE_1000DPS,
+   MPU9250_GYRO_RANGE_2000DPS
+} MPU9250_GyroRange_t;
+
+typedef enum
+{
+   MPU9250_DLPF_BANDWIDTH_184HZ,
+   MPU9250_DLPF_BANDWIDTH_92HZ,
+   MPU9250_DLPF_BANDWIDTH_41HZ,
+   MPU9250_DLPF_BANDWIDTH_20HZ,
+   MPU9250_DLPF_BANDWIDTH_10HZ,
+   MPU9250_DLPF_BANDWIDTH_5HZ
+} MPU9250_DlpfBandwidth_t;
+
+typedef enum
+{
+   MPU9250_LP_ACCEL_ODR_0_24HZ  = 0,
+   MPU9250_LP_ACCEL_ODR_0_49HZ  = 1,
+   MPU9250_LP_ACCEL_ODR_0_98HZ  = 2,
+   MPU9250_LP_ACCEL_ODR_1_95HZ  = 3,
+   MPU9250_LP_ACCEL_ODR_3_91HZ  = 4,
+   MPU9250_LP_ACCEL_ODR_7_81HZ  = 5,
+   MPU9250_LP_ACCEL_ODR_15_63HZ = 6,
+   MPU9250_LP_ACCEL_ODR_31_25HZ = 7,
+   MPU9250_LP_ACCEL_ODR_62_50HZ = 8,
+   MPU9250_LP_ACCEL_ODR_125HZ   = 9,
+   MPU9250_LP_ACCEL_ODR_250HZ   = 10,
+   MPU9250_LP_ACCEL_ODR_500HZ   = 11
+} MPU9250_LpAccelOdr_t;
+
+//Control structure for MPU9250 operation (only one IMU per project)
+typedef struct {
+   MPU9250_address_t address; //MPU9250 address can be configured through AD0 pin
+   
+   // scale factors
+   float _accelScale;
+   float _gyroScale;
+   float _magScaleX;
+   float _magScaleY;
+   float _magScaleZ;
+   float _tempScale;
+   float _tempOffset;
+   
+   // configuration
+   MPU9250_AccelRange_t    _accelRange;
+   MPU9250_GyroRange_t     _gyroRange;
+   MPU9250_DlpfBandwidth_t _bandwidth;
+   uint8_t _srd;
+
+   // buffer for reading from sensor
+   uint8_t _buffer[21];
+
+   // data buffer
+   float _ax, _ay, _az;
+   float _gx, _gy, _gz;
+   float _hx, _hy, _hz;
+   float _t;
+
+   // gyro bias estimation
+   uint8_t _numSamples;
+   double _gxbD, _gybD, _gzbD;
+   float _gxb, _gyb, _gzb;
+
+   // accel bias and scale factor estimation
+   double _axbD, _aybD, _azbD;
+   float _axmax, _aymax, _azmax;
+   float _axmin, _aymin, _azmin;
+   float _axb, _ayb, _azb;
+   float _axs;
+   float _ays;
+   float _azs;
+
+   // magnetometer bias and scale factor estimation
+   uint16_t _maxCounts;
+   float _deltaThresh;
+   uint8_t _coeff;
+   uint16_t _counter;
+   float _framedelta, _delta;
+   float _hxfilt, _hyfilt, _hzfilt;
+   float _hxmax, _hymax, _hzmax;
+   float _hxmin, _hymin, _hzmin;
+   float _hxb, _hyb, _hzb;
+   float _hxs;
+   float _hys;
+   float _hzs;
+   float _avgs;
+
+   // data counts
+   int16_t _axcounts, _aycounts, _azcounts;
+   int16_t _gxcounts, _gycounts, _gzcounts;
+   int16_t _hxcounts, _hycounts, _hzcounts;
+   int16_t _tcounts;
+
+   // transformation matrix
+   /* transform the accel and gyro axes to match the magnetometer axes */
+   int16_t tX[3];
+   int16_t tY[3];
+   int16_t tZ[3];
+
+   // track success of interacting with sensor
+   int8_t _status;
+
+} MPU9250_control_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+// Initialize MPU9250 (Only I2C)
+int8_t mpu9250Init( MPU9250_address_t address );
+
+// Read sensor registers and store data at control structure
+bool_t mpu9250Read(void);
+
+
+// Returns the accelerometer measurement in the x direction, m/s/s
+float mpu9250GetAccelX_mss( void );
+
+// Returns the accelerometer measurement in the y direction, m/s/s
+float mpu9250GetAccelY_mss( void );
+
+// Returns the accelerometer measurement in the z direction, m/s/s
+float mpu9250GetAccelZ_mss( void );
+
+// Returns the gyroscope measurement in the x direction, rad/s
+float mpu9250GetGyroX_rads( void );
+
+// Returns the gyroscope measurement in the y direction, rad/s
+float mpu9250GetGyroY_rads( void );
+
+// Returns the gyroscope measurement in the z direction, rad/s
+float mpu9250GetGyroZ_rads( void );
+
+// Returns the magnetometer measurement in the x direction, uT
+float mpu9250GetMagX_uT( void );
+
+// Returns the magnetometer measurement in the y direction, uT
+float mpu9250GetMagY_uT( void );
+
+// Returns the magnetometer measurement in the z direction, uT
+float mpu9250GetMagZ_uT( void );
+
+// Returns the die temperature, C
+float mpu9250GetTemperature_C( void );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_IMU_MPU9250_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_keypad.h ./libs/sapi/sapi_v0.5.1/inc/sapi_keypad.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_keypad.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_keypad.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,69 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _SAPI_KEYPAD_H_
+#define _SAPI_KEYPAD_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[macros]=================================================*/
+
+#define keypadConfig keypadInit
+
+/*==================[typedef]================================================*/
+
+typedef struct {
+   gpioMap_t* keypadRowPins;
+   uint8_t keypadRowSize;
+   gpioMap_t* keypadColPins;
+   uint8_t keypadColSize;
+} keypad_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/* Configure keypad pins */
+bool_t keypadInit( keypad_t* keypad,
+                   gpioMap_t* keypadRowPins, uint8_t keypadRowSize,
+                   gpioMap_t* keypadColPins, uint8_t keypadColSize );
+
+/* Return TRUE if any key is pressed or FALSE (0) in other cases.
+ * If exist key pressed write pressed key on key variable */
+bool_t keypadRead( keypad_t* keypad, uint16_t* key );
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_KEYPAD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_lcd.h ./libs/sapi/sapi_v0.5.1/inc/sapi_lcd.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_lcd.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_lcd.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,129 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-12-05 */
+
+#ifndef _SAPI_LCD_H_
+#define _SAPI_LCD_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi.h"        // <= Biblioteca sAPI
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+// Configure LCD pins
+#define LCD_HD44780_RS   LCDRS   // RS = 0 to select command register, RS = 1 to select data register
+#define LCD_HD44780_EN   LCDEN   // Enable
+#define LCD_HD44780_RW   0       // R/W = 0 for write, R/W = 1 for read
+
+#define LCD_HD44780_D7   LCD4
+#define LCD_HD44780_D6   LCD3
+#define LCD_HD44780_D5   LCD2
+#define LCD_HD44780_D4   LCD1
+
+// LCD delay Times
+#define LCD_EN_PULSE_WAIT_US   25    // 25 us
+#define LCD_LOW_WAIT_US        25    // 25 us
+#define LCD_HIGH_WAIT_US       100   // 100 us
+
+#define LCD_CMD_WAIT_US        45    // Wait time for every command 45 us, except:
+#define LCD_CLR_DISP_WAIT_MS   3     // - Clear Display 1.52 ms
+#define LCD_RET_HOME_WAIT_MS   3     // - Return Home  1.52 ms
+// - Read Busy flag and address 0 us
+
+#define LCD_STARTUP_WAIT_MS    1000  // 3000 ms
+
+// LCD delay HAL
+#define lcdDelay_ms(duration)       delay(duration)
+#define lcdDelay_us(duration)       delayInaccurateUs(duration) //delayUs(duration)
+#define lcdCommandDelay()           lcdDelay_us(LCD_CMD_WAIT_US)
+#define lcdInitPinAsOutput(pin)     gpioInit( (pin), GPIO_OUTPUT );
+#define lcdPinWrite( pin, value )   gpioWrite( (pin), (value) )
+
+#define lcdConfig lcdInit
+
+/*==================[typedef]================================================*/
+
+// Enumeration defining the HD44780 commands
+enum enLcdCommands {
+   E_CLEAR_DISPLAY        = 0x01,
+   E_RETURN_HOME          = 0x02,
+   E_ENTRY_MODE_SET       = 0x04,
+   E_DISPLAY_ON_OFF_CTRL  = 0x08,
+   E_CURSOR_DISPLAY_SHIFT = 0x10,
+   E_FUNCTION_SET         = 0x20,
+   E_SET_CGRAM_ADDR       = 0x40,
+   E_SET_DDRAM_ADDR       = 0x80
+};
+
+// This enumeration defines the available cursor modes
+enum enLCDCursorModes {
+   E_LCD_CURSOR_OFF      = 0x00,
+   E_LCD_CURSOR_ON       = 0x02,
+   E_LCD_CURSOR_ON_BLINK = 0x03
+};
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+void lcdCommand( uint8_t cmd );
+
+void lcdData( uint8_t data );
+
+void lcdInit( uint16_t lineWidth, uint16_t amountOfLines,
+              uint16_t charWidth, uint16_t charHeight );
+
+void lcdGoToXY( uint8_t x, uint8_t y );
+
+void lcdClear( void );
+
+void lcdSendStringRaw( char* str );
+
+void lcdCreateChar( uint8_t charnum, const char* chardata );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_LCD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_hmc5883l.h ./libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_hmc5883l.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_hmc5883l.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_hmc5883l.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,156 @@
+/* Copyright 2016, Alejandro Permingeat
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-06-27 */
+
+#ifndef _SAPI_HMC5883L_H_
+#define _SAPI_HMC5883L_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define HMC5883L_ADD              0x1E
+
+#define HMC5883L_REG_CONFIG_A     0x00
+#define HMC5883L_REG_CONFIG_B     0x01
+
+#define HMC5883L_REG_MODE         0x02
+
+#define HMC5883L_REG_X_MSB        0x03
+#define HMC5883L_REG_X_LSB        0x04
+
+#define HMC5883L_REG_Z_MSB        0x05
+#define HMC5883L_REG_Z_LSB        0x06
+
+#define HMC5883L_REG_Y_MSB        0x07
+#define HMC5883L_REG_Y_LSB        0x08
+
+#define HMC5883L_REG_STATUS       0x09
+
+#define HMC5883L_REG_ID_REG_A     0x0A
+#define HMC5883L_REG_ID_REG_B     0x0B
+#define HMC5883L_REG_ID_REG_C     0x0C
+
+#define HMC5883L_VALUE_ID_REG_A   0x48
+#define HMC5883L_VALUE_ID_REG_B   0x34
+#define HMC5883L_VALUE_ID_REG_C   0x33
+
+#define hmc5883lConfig hmc5883lInit
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+   HMC5883L_1_sample = 0,
+   HMC5883L_2_sample = 1,
+   HMC5883L_4_sample = 2,
+   HMC5883L_8_sample = 3,
+   HMC5883L_DEFAULT_sample = HMC5883L_1_sample
+} HMC5883L_samples_t;
+
+typedef enum {
+   HMC5883L_0_75_Hz = 0,
+   HMC5883L_1_50_Hz = 1,
+   HMC5883L_3_Hz    = 2,
+   HMC5883L_7_50_Hz = 3,
+   HMC5883L_15_Hz   = 4,
+   HMC5883L_30_Hz   = 5,
+   HMC5883L_75_Hz   = 6,
+   HMC5883L_DEFAULT_rate = HMC5883L_15_Hz
+} HMC5883L_rate_t;
+
+typedef enum {
+   HMC5883L_normal   = 0,
+   HMC5883L_positive = 1,
+   HMC5883L_regative = 2,
+   HMC5883L_DEFAULT_messurement = HMC5883L_normal
+} HMC5883L_messurement_t;
+
+typedef enum {
+   HMC5883L_1370 = 0, /* ± 0.88 Ga */
+   HMC5883L_1090 = 1, /* ± 1.3 Ga  */
+   HMC5883L_820  = 2, /* ± 1.9 Ga  */
+   HMC5883L_660  = 3, /* ± 2.5 Ga  */
+   HMC5883L_440  = 4, /* ± 4.0 Ga  */
+   HMC5883L_390  = 5, /* ± 4.7 Ga  */
+   HMC5883L_330  = 6, /* ± 5.6 Ga  */
+   HMC5883L_230  = 7, /* ± 8.1 Ga  */
+   HMC5883L_DEFAULT_gain = HMC5883L_1090
+} HMC5883L_gain_t;
+
+typedef enum {
+   HMC5883L_continuous_measurement = 0,
+   HMC5883L_single_measurement = 1,
+   HMC5883L_idle = 2,
+   HMC5883L_DEFAULT_mode = HMC5883L_single_measurement
+} HMC5883L_mode_t;
+
+typedef struct {
+   HMC5883L_samples_t samples; /*number of samples averaged (1 to 8) per measurement output.*/
+   HMC5883L_rate_t    rate;    /* Data Output Rate Bits. These bits set the rate at which data
+                                * is written to all three data output registers.*/
+   HMC5883L_messurement_t meassurement; /*Measurement Configuration Bits. These bits define the
+                                         * measurement flow of the device, specifically whether or not
+                                         * to incorporate an applied bias into the measurement.*/
+   HMC5883L_gain_t gain; /* Gain Configuration Bits. These bits configure the gain for
+                          * the device. The gain configuration is common for all
+                          * channels.*/
+   HMC5883L_mode_t mode;
+} HMC5883L_config_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t hmc5883lIsAlive(void);
+bool_t hmc5883lPrepareDefaultInit( HMC5883L_config_t * config );
+bool_t hmc5883lInit( HMC5883L_config_t config );
+bool_t hmc5883lRead( int16_t * x, int16_t * y, int16_t * z );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_HMC5883L_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_qmc5883l.h ./libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_qmc5883l.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_qmc5883l.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_magnetometer_qmc5883l.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,152 @@
+/* Copyright 2017, Rodrigo Furlani
+ * Copyright 2017, Alejandro Permingeat
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-11-14 */
+
+#ifndef _SAPI_QMC5883L_H_
+#define _SAPI_QMC5883L_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define QMC5883L_ADD              0x0D
+
+#define QMC5883L_REG_MODE         0x02
+
+#define QMC5883L_REG_X_LSB        0x00
+#define QMC5883L_REG_X_MSB        0x01
+
+#define QMC5883L_REG_Y_LSB        0x02
+#define QMC5883L_REG_Y_MSB        0x03
+
+#define QMC5883L_REG_Z_LSB        0x04
+#define QMC5883L_REG_Z_MSB        0x05
+
+#define QMC5883L_REG_STATUS       0x06
+
+#define QMC5883L_REG_TEMP_LSB     0x07
+#define QMC5883L_REG_TEMP_MSB     0x08
+
+#define QMC5883L_REG_CTRL_1       0x09
+#define QMC5883L_REG_CTRL_2       0x0A
+
+#define QMC5883L_SET_RESET_PERIOD 0x0B
+
+#define QMC5883LConfig QMC5883LInit
+
+/*==================[typedef]================================================*/
+/** The following type represents
+    all possible values of the MODE
+    */
+typedef enum {
+   QMC5883L_standby = 0,
+   QMC5883L_continuous_measurement = 1,
+   QMC5883L_DEFAULT_mode = QMC5883L_standby
+} QMC5883L_mode_t;
+
+
+/** The following type represents
+    all possible values of the ODR
+    (Output Data Update Rate)*/
+typedef enum {
+   QMC5883L_10_Hz  = 0,
+   QMC5883L_50_Hz  = 1,
+   QMC5883L_100_Hz = 2,
+   QMC5883L_500_Hz = 3,
+   QMC5883L_DEFAULT_rate = QMC5883L_10_Hz
+} QMC5883L_rate_t;
+
+/** The following type represents
+    all possible values of the RNG
+    (magnetic field measurement range
+     or sensitivity of the sensors)
+    */
+typedef enum {
+   QMC5883L_2_Gauss = 0, /* � 2 Ga */
+   QMC5883L_8_Gauss = 1, /* � 8 Ga  */
+   QMC5883L_DEFAULT_gain = QMC5883L_8_Gauss
+} QMC5883L_gain_t;
+
+/** The following type represents
+    all possible values of the OSR
+    (Over sample Rate)
+    */
+typedef enum {
+   QMC5883L_512_sample = 0,
+   QMC5883L_256_sample = 1,
+   QMC5883L_126_sample = 2,
+   QMC5883L_64_sample = 3,
+   QMC5883L_DEFAULT_sample = QMC5883L_512_sample
+} QMC5883L_samples_t;
+
+
+
+typedef struct {
+   QMC5883L_samples_t samples; /*number of over samples averaged per measurement output.*/
+
+   QMC5883L_gain_t gain; /* Gain Configuration Bits. These bits configure the gain for
+                          * the device. The gain configuration is common for all
+                          * channels.*/
+   QMC5883L_rate_t    rate;    /* Data Output Rate Bits. These bits set the rate at which data
+                                * is written to all three data output registers.*/
+   QMC5883L_mode_t mode;
+
+
+} QMC5883L_config_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+bool_t QMC5883LPrepareDefaultInit( QMC5883L_config_t * config );
+bool_t QMC5883LInit( QMC5883L_config_t config );
+bool_t QMC5883LRead( int16_t * x, int16_t * y, int16_t * z );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_QMC5883L_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_peripheral_map.h ./libs/sapi/sapi_v0.5.1/inc/sapi_peripheral_map.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_peripheral_map.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_peripheral_map.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,192 @@
+/* Copyright 2015, Eric Pernia.
+ * Copyright 2016, Ian Olivieri.
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_PERIPHERALMAP_H_
+#define _SAPI_PERIPHERALMAP_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+/* ----- Begin Pin Init Structs NXP LPC4337 ----- */
+
+typedef struct {
+   int8_t port;
+   int8_t pin;
+} pinInitLpc4337_t;
+
+typedef struct {
+   uint8_t lpcScuPort;
+   uint8_t lpcScuPin;
+   uint8_t lpcScuFunc;
+} lpc4337ScuPin_t;
+
+/* ------ End Pin Init Structs NXP LPC4337 ------ */
+
+
+/* ------- Begin EDU-CIAA-NXP Peripheral Map ------ */
+
+/* Defined for sapi_gpio.h */
+typedef enum {
+   /* EDU-CIAA-NXP */
+
+   // P1 header
+   T_FIL1,    T_COL2,    T_COL0,    T_FIL2,      T_FIL3,  T_FIL0,     T_COL1,
+   CAN_TD,    CAN_RD,    RS232_TXD, RS232_RXD,
+
+   // P2 header
+   GPIO8,     GPIO7,     GPIO5,     GPIO3,       GPIO1,
+   LCD1,      LCD2,      LCD3,      LCDRS,       LCD4,
+   SPI_MISO,
+   ENET_TXD1, ENET_TXD0, ENET_MDIO, ENET_CRS_DV, ENET_MDC, ENET_TXEN, ENET_RXD1,
+   GPIO6,     GPIO4,     GPIO2,     GPIO0,
+   LCDEN,
+   SPI_MOSI,
+   ENET_RXD0,
+
+   // Switches
+   // 36   37     38     39
+   TEC1,  TEC2,  TEC3,  TEC4,
+
+   // Leds
+   // 40   41     42     43     44     45
+   LEDR,  LEDG,  LEDB,  LED1,  LED2,  LED3,
+
+   /* CIAA-NXP */
+   /* 46     47     48     49     50     51     52     53 */
+   DI0,   DI1,   DI2,   DI3,   DI4,   DI5,   DI6,   DI7,
+   /* 54     55     56     57     58     59     60     61 */
+   DO0,   DO1,   DO2,   DO3,   DO4,   DO5,   DO6,   DO7
+} gpioMap_t;
+
+#define CIAA_BOARD_BUTTON   TEC1
+#define CIAA_BOARD_LED      LEDB
+
+
+/* Defined for sapi_adc.h */
+typedef enum {
+   /* 62         63       64        65       */
+   AI3 = 62, AI2 = 63, AI1 = 64, AI0 = 65,
+   CH3 = 63, CH2 = 64, CH1 = 65
+                             /*  46        47   48  49 */
+// AI2 = 46, AI1, AI0, AO
+} adcMap_t;
+
+/* Defined for sapi_dac.h */
+typedef enum {
+   /* 66 */
+   AO = 66,
+   DAC = 66
+} dacMap_t;
+
+/* Defined for sapi_uart.h */
+// Note that:
+// - If use UART_GPIO you can't use UART_485 and vice versa.
+// - If use UART_USB you can't use UART_ENET and vice versa.
+typedef enum {
+   UART_GPIO = 0, // Hardware UART0 via GPIO1(TX), GPIO2(RX) pins on header P0
+   UART_485  = 1, // Hardware UART0 via RS_485 A, B and GND Borns
+   //UART_1  = 2, // Hardware UART1 not routed
+   UART_USB  = 3, // Hardware UART2 via USB DEBUG port
+   UART_ENET = 4, // Hardware UART2 via ENET_RXD0(TX), ENET_CRS_DV(RX) pins on header P0
+   UART_232  = 5  // Hardware UART3 via 232_RX and 232_tx pins on header P1
+} uartMap_t;
+
+/*Defined for sapi_timer.h*/
+//NOTE: if servo is enable (servoInit used) the only available timer to use is TIMER0
+typedef enum {
+   TIMER0, TIMER1, TIMER2, TIMER3
+} timerMap_t;
+typedef enum {
+   TIMERCOMPAREMATCH0, TIMERCOMPAREMATCH1, TIMERCOMPAREMATCH2, TIMERCOMPAREMATCH3
+} timerCompareMatch_t;
+
+/*Defined for sapi_sct.h*/
+// NOTE: CTOUT11 has no SCT mode associated, so it can't be used!
+// NOTE: if pwm is enable (pwmInit used) there will be no sct channels available
+typedef enum {
+   CTOUT0, CTOUT1, CTOUT2, CTOUT3, CTOUT4, CTOUT5, CTOUT6, CTOUT7, CTOUT8,
+   CTOUT9, CTOUT10, CTOUT11, CTOUT12, CTOUT13
+} sctMap_t;
+
+/*Defined for sapi_pwm.h*/
+typedef enum {
+   PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6, PWM7, PWM8, PWM9, PWM10
+} pwmMap_t;
+
+/*Defined for sapi_servo.h*/
+typedef enum {
+   SERVO0, SERVO1, SERVO2, SERVO3, SERVO4, SERVO5, SERVO6, SERVO7, SERVO8
+} servoMap_t;
+
+/*Defined for sapi_i2c.h*/
+/* Comment because already defined in "i2c_18xx_43xx.h"*/
+/*
+typedef enum{
+   I2C0 // TODO: Add support for I2C1
+} i2cMap_t;
+*/
+typedef uint8_t i2cMap_t;
+
+typedef enum {
+   SPI0
+} spiMap_t;
+
+/* ------- End EDU-CIAA-NXP Peripheral Map -------- */
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_PERIPHERALMAP_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_print.h ./libs/sapi/sapi_v0.5.1/inc/sapi_print.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_print.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_print.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,165 @@
+/* Copyright 2017-2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Date: 2017-04-17 */
+
+#ifndef _SAPI_PRINT_H_
+#define _SAPI_PRINT_H_
+
+/*
+
+API
+---
+
+// Initialize
+void printSetUart( print_t* printer, uartMap_t uart );
+void printInit( print_t printer, uartMap_t uart, uint32_t baudRate );
+
+
+// Print String
+void printString( print_t printer, const char* string );
+void printlnString( print_t printer, const char* string );
+void printEnter( print_t printer );
+
+// Print Integer
+void printIntFormat( print_t printer, int64_t number, numberFormat_t format );
+void printUIntFormat( print_t printer, uint64_t number, numberFormat_t format );
+void printlnIntFormat( print_t printer, int64_t number, numberFormat_t format );
+void printlnUIntFormat( print_t printer, uint64_t number, numberFormat_t format );
+void printInt( print_t printer, int64_t number );
+void printUInt( print_t printer, uint64_t number );
+void printlnInt( print_t printer, int64_t number );
+void printlnUInt( print_t printer, uint64_t number );
+void printHex( uint64_t number, uint8_t bitSize );
+*/
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_convert.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[macros]=================================================*/
+
+#define PRINT_ENTER_STRING   "\r\n"
+
+// Any printer
+
+#define printlnString(printer,string);  {printString((printer),(string));\
+                                        printEnter((printer));}
+
+
+#define printInt(printer,number)        printIntFormat((printer),(number),(DEC_FORMAT))
+
+#define printUInt(printer,number)       printUIntFormat((printer),(number),(DEC_FORMAT))
+
+
+#define printlnInt(printer,number);     {printInt((printer),number);\
+                                        printEnter((printer));}
+
+#define printlnUInt(printer,number);    {printUInt((printer),number);\
+                                        printEnter((printer));}
+
+// Ver que pueden molestar dentro de un bucle!
+#define printlnIntFormat(printer,number,format);   {printIntFormat((printer),(number),(format));\
+                                                   printEnter((printer));}
+
+#define printlnUIntFormat(printer,number,format);  {printUIntFormat((printer),(number),(format));\
+                                                   printEnter((printer));}
+
+#define printlnHex(printer,number,bitSize);        {printHex((printer),(number),(bitSize));\
+                                                   printEnter((printer));}
+
+#define printInitUart printInitUart
+
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[typedef]================================================*/
+
+typedef uartMap_t print_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+// Initialize
+void printSetUart( print_t* printer, uartMap_t uart );
+void printInitUart( print_t* printer, uartMap_t uart, uint32_t baudRate );
+
+// Print String
+void printString( print_t printer, const char* string );
+void printEnter( print_t printer );
+
+// Print Integer
+void printIntFormat( print_t printer, int64_t number, numberFormat_t format );
+void printUIntFormat( print_t printer, uint64_t number, numberFormat_t format );
+void printHex( print_t printer, uint64_t number, uint8_t bitSize );
+
+/*==================[examples]===============================================*/
+
+/*
+printlnString( printer, "Uart Debug configurada." );
+printlnString( printer, "Uart LoRa RN2903 configurada." );
+
+printString( printer, "Numero de algo: " );
+printInt( printer, 45454578 );
+printlnString( printer, "" );
+
+printlnInt( printer, -457 );
+printlnUInt( printer, -457 );
+
+printString( printer, "Numero de algo: " );
+printIntFormat( printer, 45454578, DEC_FORMAT );
+printlnString( printer, "" );
+
+printString( printer, "Numero de algo: 0b" );
+printIntFormat( printer, 45454578, BIN_FORMAT );
+printlnString( printer, "" );
+
+printString( printer, "Numero de algo: 0x" );
+printIntFormat( printer, 45454578, HEX_FORMAT );
+printlnString( printer, "" );
+*/
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_PRINT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_pwm.h ./libs/sapi/sapi_v0.5.1/inc/sapi_pwm.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_pwm.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_pwm.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,104 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, aire permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef PWM_DRIVER_H_
+#define PWM_DRIVER_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#define pwmConfig pwmInit
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   PWM_ENABLE, PWM_DISABLE,
+   PWM_ENABLE_OUTPUT, PWM_DISABLE_OUTPUT
+} pwmInit_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Initializes the pwm peripheral.
+ * @param  uint8_t pwmNumber
+ * @param  uint8_t config
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t pwmInit( pwmMap_t pwmNumber, pwmInit_t config);
+
+/*
+ * @brief:   Tells if the pwm is currently active, and its position
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   position (1 ~ PWM_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t pwmIsAttached( pwmMap_t pwmNumber );
+
+/*
+ * @brief:   read the value of the pwm in the pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   value of the pwm in the pin (0 ~ 255).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint8_t pwmRead( pwmMap_t pwmNumber );
+
+/*
+ * @brief:   change the value of the pwm at the selected pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @param:   value:   8bit value, from 0 to 255
+ * @return:   True if the value was successfully changed, False if not.
+ */
+bool_t pwmWrite( pwmMap_t pwmNumber, uint8_t percent );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* PWM_DRIVER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_rgb.h ./libs/sapi/sapi_v0.5.1/inc/sapi_rgb.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_rgb.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_rgb.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,113 @@
+/* Copyright 2017, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Date: 2017-11-01
+ */
+
+#ifndef _SAPI_RGB_H_
+#define _SAPI_RGB_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define MAX_AMOUNT_OF_RGB_LEDS 9
+
+#define rgbConfig rgbInit
+
+/*==================[typedef]================================================*/
+
+// Colores predefinidos
+typedef enum Color {
+	BLACK,
+	WHITE,
+	VIOLET,
+	RED,
+	CYAN,
+	BLUE,
+	YELLOW,
+	GREEN
+} Color_t;
+
+typedef enum LedRgbMap {
+	RGB_1,
+	RGB_2,
+	RGB_3,
+	RGB_4,
+	RGB_5,
+	RGB_6,
+	RGB_7,
+	RGB_8,
+	RGB_9,
+} LedRgbMap_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/** Configura los pines que se van a manejar como salidas PWM por soft. */
+bool_t rgbInit( LedRgbMap_t rgbLed, uint8_t pinRed, uint8_t pinGreen, uint8_t pinBlue );
+
+/** Manda por los pines PWM uno de los posibles colores definidos en color_t*/
+void rgbWriteColor( LedRgbMap_t rgbLed, Color_t color );
+
+/** Manda una configuracion individual de cada canal. */
+void rgbWriteRaw( LedRgbMap_t rgbLed, int8_t dutyRed, int8_t dutyGreen, int8_t dutyBlue );
+
+/** Setea el brillo sin cambiar el color (multiplica por una constante). */
+void rgbWriteBright( LedRgbMap_t rgbLed, uint32_t bright );
+
+uint8_t rgbReadDutyRed( LedRgbMap_t rgbLed );
+
+uint8_t rgbReadDutyGreen( LedRgbMap_t rgbLed );
+
+uint8_t rgbReadDutyBlue( LedRgbMap_t rgbLed );
+
+void rgbToggleLed( LedRgbMap_t rgbLed );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_RGB_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_rtc.h ./libs/sapi/sapi_v0.5.1/inc/sapi_rtc.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_rtc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_rtc.h	2018-12-01 17:15:06.617606140 -0300
@@ -0,0 +1,99 @@
+/* Copyright 2011, ChaN.
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-03-07 */
+
+#ifndef _SAPI_RTC_H_
+#define _SAPI_RTC_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#define rtcConfig rtcInit
+
+/*==================[typedef]================================================*/
+
+typedef struct {
+   uint16_t year;	 /* 1 to 4095 */
+   uint8_t  month; /* 1 to 12   */
+   uint8_t  mday;	 /* 1 to 31   */
+   uint8_t  wday;	 /* 1 to 7    */
+   uint8_t  hour;	 /* 0 to 23   */
+   uint8_t  min;	 /* 0 to 59   */
+   uint8_t  sec;	 /* 0 to 59   */
+} rtc_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Configure RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcInit( rtc_t* rtc );
+
+/*
+ * @Brief: Get time from RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcRead( rtc_t* rtc );
+
+/*
+ * @Brief: Set time on RTC peripheral.
+ * @param  RTC_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcWrite( rtc_t* rtc );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* _SAPI_RTC_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_sct.h ./libs/sapi/sapi_v0.5.1/inc/sapi_sct.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_sct.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_sct.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,108 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef SAPI_SCT_H_
+#define SAPI_SCT_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+/*  SCT names are defined in sAPI_PeripheralMap.h:
+ * NOTE: CTOUT11 has no SCT mode associated, so it can't be used!
+
+typedef enum{
+   CTOUT0, CTOUT1, CTOUT2, CTOUT3, CTOUT4, CTOUT5, CTOUT6, CTOUT7, CTOUT8,
+   CTOUT9, CTOUT10, CTOUT11, CTOUT12, CTOUT13
+} SctMap_t;
+*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+/*
+ * @brief:   Initialize the SCT peripheral with the given frequency
+ * @param:   frequency:   value in Hz
+ * @note:   there can only be 1 frequency in all the SCT peripheral.
+ */
+void Sct_Init(uint32_t frequency);
+
+/*
+ * @brief	Enables pwm function for the given pin
+ * @param	sctNumber:   pin where the pwm signal will be generated
+ */
+void Sct_EnablePwmFor(uint8_t sctNumber);
+
+/*
+ * @brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   value:   8bit value, from 0 to 255
+ * @return   Equivalent in Ticks for the LPC4337
+ */
+uint32_t Sct_Uint8ToTicks(uint8_t value);
+
+/*
+ * @brief:   Sets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @param	value:   8bit value, from 0 to 255
+ * @note   For the 'ticks' parameter, see function Sct_Uint8ToTicks
+ */
+void Sct_SetDutyCycle(uint8_t sctNumber, uint8_t value);
+
+/*
+ * @brief:   Gets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @return:   duty cycle of the channel, from 0 to 255
+ */
+uint8_t Sct_GetDutyCycle(uint8_t sctNumber);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_SCT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_servo.h ./libs/sapi/sapi_v0.5.1/inc/sapi_servo.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_servo.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_servo.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,131 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef SAPI_SERVO_H_
+#define SAPI_SERVO_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#define servoConfig servoInit
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   SERVO_ENABLE, SERVO_DISABLE,
+   SERVO_ENABLE_OUTPUT, SERVO_DISABLE_OUTPUT
+} servoInit_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Initializes the servo peripheral
+ * @param  uint8_t servoNumber
+ * @param  uint8_t config
+ * @return bool_t true (1) if config it is ok
+ * @IMPORTANT:   this function uses Timer 1, 2 and 3 to generate the servo signals, so
+ *   they won't be available to use.
+ */
+bool_t servoInit( servoMap_t servoNumber, servoInit_t config );
+
+/*
+ * @brief:   Tells if the servo is currently active, and its position
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return:   position (1 ~ SERVO_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t servoIsAttached( servoMap_t servoNumber );
+
+/*
+ * @brief: read the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @return: value of the servo (0 ~ 180).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint16_t servoRead( servoMap_t servoNumber );
+
+/*
+ * @brief: change the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return: True if the value was successfully changed, False if not.
+ */
+bool_t servoWrite( servoMap_t servoNumber, uint16_t angle );
+
+
+
+uint32_t valueToMicroseconds( uint8_t );
+
+void servoInitTimers( void );
+bool_t servoAttach( servoMap_t servoNumber );
+bool_t servoDetach( servoMap_t servoNumber );
+
+
+void timer1CompareMatch0func( void* ptr );
+void timer1CompareMatch1func( void* ptr );
+void timer1CompareMatch2func( void* ptr );
+void timer1CompareMatch3func( void* ptr );
+
+void timer2CompareMatch0func( void* ptr );
+void timer2CompareMatch1func( void* ptr );
+void timer2CompareMatch2func( void* ptr );
+void timer2CompareMatch3func( void* ptr );
+
+void timer3CompareMatch0func( void* ptr );
+void timer3CompareMatch1func( void* ptr );
+void timer3CompareMatch2func( void* ptr );
+void timer3CompareMatch3func( void* ptr );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_SERVO_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_sleep.h ./libs/sapi/sapi_v0.5.1/inc/sapi_sleep.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_sleep.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_sleep.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,72 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-08-15 */
+
+#ifndef SAPI_SCT_H_
+#define SAPI_SCT_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief: Sleep mode, sleep until next interrupt occur.
+ * @param  nothing
+ * @return nothing
+ */
+void sleepUntilNextInterrupt( void );
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_SCT_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_spi.h ./libs/sapi/sapi_v0.5.1/inc/sapi_spi.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_spi.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_spi.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,75 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-05-02 */
+
+#ifndef _SAPI_SPI_H_
+#define _SAPI_SPI_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define spiConfig spiInit
+
+/*==================[typedef]================================================*/
+
+/*==================[external data declaration]==============================*/
+
+/*==================[ISR external functions definition]======================*/
+
+/*==================[external functions definition]==========================*/
+
+bool_t spiInit( spiMap_t spi );
+
+bool_t spiRead( spiMap_t spi, uint8_t* buffer, uint32_t bufferSize );
+
+bool_t spiWrite( spiMap_t spi, uint8_t* buffer, uint32_t bufferSize);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_SPI_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_tick.h ./libs/sapi/sapi_v0.5.1/inc/sapi_tick.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_tick.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_tick.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,84 @@
+/* Copyright 2015-2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+#ifndef _SAPI_TICK_H_
+#define _SAPI_TICK_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define tickConfig tickInit
+
+/*==================[typedef]================================================*/
+
+/*==================[external functions definition]==========================*/
+
+// Tick Initialization and rate configuration from 1 to 50 ms
+bool_t tickInit( tick_t tickRateMSvalue );
+
+// Read Tick Counter
+tick_t tickRead( void );
+
+// Write Tick Counter
+void tickWrite( tick_t ticks );
+
+// Tick interrupt callback
+bool_t tickCallbackSet( callBackFuncPtr_t tickCallback, void* tickCallbackParams );
+
+// Enable or disable the peripheral energy and clock
+void tickPowerSet( bool_t power );
+
+/*==================[ISR external functions declaration]======================*/
+
+// SysTick Timer ISR Handler
+void SysTick_Handler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* #ifndef _SAPI_TICK_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_timer.h ./libs/sapi/sapi_v0.5.1/inc/sapi_timer.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_timer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_timer.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,129 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+#ifndef SAPI_TIMER_H_
+#define SAPI_TIMER_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[typedef]================================================*/
+//typedef void (*voidFunctionPointer_t)(void);
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+/*
+ * @Brief   Initialize Timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   ticks:   Number of ticks required to finish the cycle.
+ * @param   voidFunctionPointer:   function to be executed at the end of the timer cycle
+ * @return   nothing
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_Init( uint8_t timerNumber , uint32_t ticks, callBackFuncPtr_t voidFunctionPointer );
+
+/*
+ * @Brief   Disables timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @return   nothing
+ */
+void Timer_DeInit( uint8_t timerNumber );
+
+/*
+ * @Brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   uS:   Value in microseconds
+ * @return   Equivalent in Ticks for the LPC4337
+ * @note   Can be used for the second parameter in the Timer_init
+ */
+uint32_t Timer_microsecondsToTicks( uint32_t uS );
+
+/*
+ * @Brief   Enables a compare match in a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @param   ticks:   Number of ticks required to reach the compare match.
+ * @param   voidFunctionPointer: function to be executed when the compare match is reached
+ * @return   None
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_EnableCompareMatch( uint8_t timerNumber, uint8_t compareMatchNumber, 
+                               uint32_t ticks, callBackFuncPtr_t voidFunctionPointer );
+
+/*
+ * @brief   Disables a compare match of a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @return   None
+ */
+void Timer_DisableCompareMatch( uint8_t timerNumber, uint8_t compareMatchNumber );
+
+/*
+ * @Purpose:   Allows the user to change the compare value n? 'compareMatchNumber' of timer 'timerNumber'.
+ *    This is specially useful to generate square waves if used in the function for the TIMERCOMPAREMATCH0 (because
+ *    that compare match resets the timer counter), which will be passed as a parameter when initializing a timer
+ * @note:  The selected time (3rd parameter) must be less than TIMERCOMPAREMATCH0's compareMatchTime_uS
+ *   for the compare match to make the interruption
+ */
+void Timer_SetCompareMatch( uint8_t timerNumber, uint8_t compareMatchNumber, uint32_t ticks );
+
+/*==================[ISR external functions declaration]=====================*/
+/*
+ * @Brief:   Executes the functions passed by parameter in the Timer_init,
+ *   at the chosen frequencies
+ */
+void TIMER0_IRQHandler(void);
+void TIMER1_IRQHandler(void);
+void TIMER2_IRQHandler(void);
+void TIMER3_IRQHandler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* SAPI_TIMER_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_uart.h ./libs/sapi/sapi_v0.5.1/inc/sapi_uart.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_uart.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_uart.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,172 @@
+/* Copyright 2015-2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-26 */
+
+#ifndef _SAPI_UART_H_
+#define _SAPI_UART_H_
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_delay.h"
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define uartConfig uartInit
+
+/*==================[typedef]================================================*/
+
+typedef enum{
+   UART_RECEIVE_STRING_CONFIG,
+   UART_RECEIVE_STRING_RECEIVING,
+   UART_RECEIVE_STRING_RECEIVED_OK,
+   UART_RECEIVE_STRING_FULL_BUFFER,
+   UART_RECEIVE_STRING_TIMEOUT
+} waitForReceiveStringOrTimeoutState_t;
+
+typedef struct{
+   waitForReceiveStringOrTimeoutState_t state;
+   char*    string;
+   uint16_t stringSize;
+   uint16_t stringIndex;
+   tick_t   timeout;
+   delay_t  delay;
+} waitForReceiveStringOrTimeout_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+// Check for Receive a given pattern
+
+waitForReceiveStringOrTimeoutState_t waitForReceiveStringOrTimeout(
+   uartMap_t uart, waitForReceiveStringOrTimeout_t* instance );
+
+// Recibe bytes hasta que llegue el string patron que se le manda en el
+// parametro string, stringSize es la cantidad de caracteres del string.
+// Devuelve TRUE cuando recibio la cadena patron, si paso el tiempo timeout
+// en milisegundos antes de recibir el patron devuelve FALSE.
+// No almacena los datos recibidos!! Simplemente espera a recibir cierto patron.
+
+bool_t waitForReceiveStringOrTimeoutBlocking(
+   uartMap_t uart, char* string, uint16_t stringSize, tick_t timeout );
+
+
+// Store bytes until receive a given pattern
+
+waitForReceiveStringOrTimeoutState_t receiveBytesUntilReceiveStringOrTimeout(
+   uartMap_t uart, waitForReceiveStringOrTimeout_t* instance,
+   char* receiveBuffer, uint32_t* receiveBufferSize );
+
+// Guarda todos los bytes que va recibiendo hasta que llegue el string
+// patron que se le manda en el parametro string, stringSize es la cantidad
+// de caracteres del string.
+// receiveBuffer es donde va almacenando los caracteres recibidos y
+// receiveBufferSize es el tamaño de buffer receiveBuffer.
+// Devuelve TRUE cuando recibio la cadena patron, si paso el tiempo timeout
+// en milisegundos antes de recibir el patron devuelve FALSE.
+
+bool_t receiveBytesUntilReceiveStringOrTimeoutBlocking(
+   uartMap_t uart, char* string, uint16_t stringSize,
+   char* receiveBuffer, uint32_t* receiveBufferSize,
+   tick_t timeout );
+
+//-------------------------------------------------------------
+
+// UART RX Interrupt Enable/Disable
+void uartRxInterruptSet( uartMap_t uart, bool_t enable );
+// UART TX Interrupt Enable/Disable
+void uartTxInterruptSet( uartMap_t uart, bool_t enable );
+
+// UART RX Interrupt set callback function that is excecuted when event ocurrs
+void uartRxInterruptCallbackSet( 
+   uartMap_t uart,                  // UART
+   callBackFuncPtr_t rxIsrCallback  // pointer to function
+);
+// UART TX Interrupt set callback function that is excecuted when event ocurrs
+void uartTxInterruptCallbackSet( 
+   uartMap_t uart,                  // UART
+   callBackFuncPtr_t txIsrCallback  // pointer to function
+);
+
+//-------------------------------------------------------------
+
+// Return TRUE if have unread data in RX FIFO
+bool_t uartRxReady( uartMap_t uart );
+// Return TRUE if have space in TX FIFO
+bool_t uartTxReady( uartMap_t uart );
+// Read from RX FIFO
+uint8_t uartRxRead( uartMap_t uart );
+// Write in TX FIFO
+void uartTxWrite( uartMap_t uart, uint8_t value );
+
+//-------------------------------------------------------------
+// UART Initialization
+void uartInit( uartMap_t uart, uint32_t baudRate );
+
+// Read 1 byte from RX FIFO, check first if exist aviable data
+bool_t uartReadByte( uartMap_t uart, uint8_t* receivedByte );
+// Blocking, Write 1 byte to TX FIFO
+void uartWriteByte( uartMap_t uart, const uint8_t value );
+
+// Blocking, Send a string
+void uartWriteString( uartMap_t uart, const char* str );
+
+// Blocking, Send a Byte Array
+void uartWriteByteArray( uartMap_t uart, const uint8_t* byteArray, uint32_t byteArrayLen );
+
+/*==================[ISR external functions declaration]======================*/
+
+/* 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24) */
+void UART0_IRQHandler(void);
+/* 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26) */
+void UART2_IRQHandler(void);
+/* 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27) */
+void UART3_IRQHandler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*==================[end of file]============================================*/
+#endif /* _SAPI_UART_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_ultrasonic_hcsr04.h ./libs/sapi/sapi_v0.5.1/inc/sapi_ultrasonic_hcsr04.h
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/inc/sapi_ultrasonic_hcsr04.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/inc/sapi_ultrasonic_hcsr04.h	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,102 @@
+/* Copyright 2017, Danilo Zecchin.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Ultrasonic sensor HC-SR04 API
+ * Date: 2017-11-17
+ */
+
+#ifndef _SAPI_ULTRASONICSENSOR_H_
+#define _SAPI_ULTRASONICSENSOR_H_
+
+/*==================[inclusions]=============================================*/
+#include "sapi_datatypes.h"
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*==================[macros]=================================================*/
+
+#define ultrasonicSensorConfig ultrasonicSensorInit
+
+/*==================[typedef]================================================*/
+
+typedef enum {
+	ULTRASONIC_SENSOR_0, ULTRASONIC_SENSOR_1, ULTRASONIC_SENSOR_2
+} ultrasonicSensorMap_t;
+
+typedef enum {
+	ULTRASONIC_SENSOR_ENABLE, ULTRASONIC_SENSOR_DISABLE
+} ultrasonicSensorInit_t;
+
+typedef enum {
+	CM, INCH
+} unitMap_t;
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+/*
+ * @Brief   Configure an ultrasonic sensor
+ * @param   aSensor:   sensor number (0 to 2)
+ * @param   aConfig:   enable or disable sensor
+ * @return   nothing
+ */
+void ultrasonicSensorInit( ultrasonicSensorMap_t aSensor, ultrasonicSensorInit_t aConfig );
+
+/*
+ * @Brief   retrieves sensor actual distance in the specified unit
+ * @param   aSensor:	sensor number (0 to 2)
+ * @param   anUnit:		returned value unit (centimeters, inch, etc)
+ * @return  float value with measured distance
+ */
+float ultrasonicSensorGetDistance( ultrasonicSensorMap_t aSensor, unitMap_t anUnit );
+
+/*==================[ISR external functions declaration]=====================*/
+/*
+ * @Brief:   GPIO Echo interrupt handler for each sensor
+ */
+void GPIO0_IRQHandler(void);
+void GPIO1_IRQHandler(void);
+void GPIO2_IRQHandler(void);
+
+/*==================[cplusplus]==============================================*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SAPI_ULTRASONICSENSOR_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_7_segment_display.c ./libs/sapi/sapi_v0.5.1/src/sapi_7_segment_display.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_7_segment_display.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_7_segment_display.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,203 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Date: 2016-07-28
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_7_segment_display.h"   /* <= own header */
+
+#include "sapi_delay.h"               /* <= delay header */
+#include "sapi_gpio.h"                /* <= GPIO header */
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+
+// Symbols formed by segmens
+/*
+------------+------+---------
+  Segmentos | HEX  | Simbolo
+------------+------+---------
+   hgfedcba |      |
+ 0b00111111 | 0x0F |   0
+ 0b00000110 | 0x00 |   1
+ 0b01011011 | 0x00 |   2
+ 0b01001111 | 0x00 |   3
+ 0b01100110 | 0x00 |   4
+ 0b01101101 | 0x00 |   5
+ 0b01111101 | 0x00 |   6
+ 0b00000111 | 0x00 |   7
+ 0b01111111 | 0x00 |   8
+ 0b01101111 | 0x00 |   9
+
+ 0b01011111 | 0x00 |   a
+ 0b01111100 | 0x00 |   b
+ 0b01011000 | 0x00 |   c
+ 0b01011110 | 0x00 |   d
+ 0b01111011 | 0x00 |   e
+ 0b01110001 | 0x00 |   F
+
+ 0b01110111 | 0x00 |   A
+ 0b00111001 | 0x00 |   C
+ 0b01111001 | 0x00 |   E
+ 0b01110110 | 0x00 |   H
+ 0b00011110 | 0x00 |   J
+ 0b00111000 | 0x00 |   L
+ 0b01110011 | 0x00 |   P
+ 0b00111110 | 0x00 |   U
+
+ 0b10000000 | 0x00 |   .
+
+             a
+           -----
+       f /     / b
+        /  g  /
+        -----
+    e /     / c
+     /  d  /
+     -----    O h = dp (decimal point).
+
+*/
+uint8_t display7SegmentOutputs[26] = {
+   0b00111111, // 0
+   0b00000110, // 1
+   0b01011011, // 2
+   0b01001111, // 3
+   0b01100110, // 4
+   0b01101101, // 5
+   0b01111101, // 6
+   0b00000111, // 7
+   0b01111111, // 8
+   0b01101111, // 9
+
+   0b01011111, // a
+   0b01111100, // b
+   0b01011000, // c
+   0b01011110, // d
+   0b01111011, // e
+   0b01110001, // f
+
+   0b01110111, // A
+   0b00111001, // C
+   0b01111001, // E
+   0b01110110, // H
+   0b00011110, // J
+   0b00111000, // L
+   0b01110011, // P
+   0b00111110, // U
+
+   0b10000000, // .
+
+   0b00000000  // display off
+};
+
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* Test 7-segment display connected pins */
+/*
+----------------+------------+-----------+------------
+ Segment ON     | BIN Value  | HEX Value | Output pin
+----------------+------------+-----------+------------
+ Segment 'a' ON | 0b00000001 |   0x20    | ..... (to be complete)
+ Segment 'b' ON | 0b00000010 |   0x80    | .....
+ Segment 'c' ON | 0b00000100 |   0x40    | .....
+ Segment 'd' ON | 0b00001000 |   0x02    | .....
+ Segment 'e' ON | 0b00010000 |   0x04    | .....
+ Segment 'f' ON | 0b00100000 |   0x10    | .....
+ Segment 'g' ON | 0b01000000 |   0x08    | .....
+ Segment 'h' ON | 0b10000000 |   0x80    | .....
+----------------+------------+-----------+------------
+
+                a
+              -----
+	  f /     / b
+	   /  g  /
+	   -----
+       e /     / c
+	/  d  /
+	-----    O h = dp (decimal pint).
+
+*/
+void display7SegmentTestPins( gpioMap_t* display7SegmentPins, gpioMap_t pin )
+{
+
+   uint8_t i = 0;
+
+   for(i=0; i<=7; i++) {
+      gpioWrite( display7SegmentPins[i], ON  );
+      if( i == 0 )
+         gpioWrite( pin, ON );
+      delay(1000);
+      gpioWrite( display7SegmentPins[i], OFF );
+      if( i == 0 )
+         gpioWrite( pin, OFF );
+   }
+
+}
+
+
+/* Configure 7-segment display GPIOs as Outputs */
+void display7SegmentPinInit( gpioMap_t* display7SegmentPins )
+{
+
+   uint8_t i = 0;
+
+   for( i=0; i<=7; i++ )
+      gpioInit( display7SegmentPins[i], GPIO_OUTPUT );
+}
+
+
+/* Write a symbol on 7-segment display */
+void display7SegmentWrite( gpioMap_t* display7SegmentPins, uint8_t symbolIndex )
+{
+
+   uint8_t i = 0;
+
+   for( i=0; i<=7; i++ )
+      gpioWrite( display7SegmentPins[i], display7SegmentOutputs[symbolIndex] & (1<<i) );
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_adc.c ./libs/sapi/sapi_v0.5.1/src/sapi_adc.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_adc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_adc.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,136 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_adc.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @brief:  enable/disable the ADC and DAC peripheral
+ * @param:  ADC_ENABLE, ADC_DISABLE
+ * @return: none
+*/
+void adcInit( adcInit_t config )
+{
+
+   switch(config) {
+
+   case ADC_ENABLE: {
+
+      /* Config ADC0 sample mode */
+      /*
+      ADC_CLOCK_SETUP_T ADCSetup = {
+         400000,   // ADC rate
+         10,       // ADC bit accuracy
+         0         // ADC Burt Mode (true or false)
+      };
+      */
+      ADC_CLOCK_SETUP_T ADCSetup;
+
+      /* Initialized to default values:
+      *   - Sample rate:ADC_MAX_SAMPLE_RATE=400KHz
+      *   - resolution: ADC_10BITS
+      *   - burst mode: DISABLE */
+      Chip_ADC_Init( LPC_ADC0, &ADCSetup );
+      /* Disable burst mode */
+      Chip_ADC_SetBurstCmd( LPC_ADC0, DISABLE );
+      /* Set sample rate to 200KHz */
+      Chip_ADC_SetSampleRate( LPC_ADC0, &ADCSetup, ADC_MAX_SAMPLE_RATE/2 );
+      /* Disable all channels */
+      Chip_ADC_EnableChannel( LPC_ADC0,ADC_CH1, DISABLE );
+      Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH1, DISABLE );
+
+      Chip_ADC_EnableChannel( LPC_ADC0, ADC_CH2, DISABLE );
+      Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH2, DISABLE );
+
+      Chip_ADC_EnableChannel( LPC_ADC0, ADC_CH3, DISABLE );
+      Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH3, DISABLE );
+
+      Chip_ADC_EnableChannel( LPC_ADC0, ADC_CH4, DISABLE );
+      Chip_ADC_Int_SetChannelCmd( LPC_ADC0, ADC_CH4, DISABLE );
+
+      // Chip_SCU_ADC_Channel_Config( 0, 4 ); // Pablo Gomez
+   }
+   break;
+
+   case ADC_DISABLE:
+      /* Disable ADC peripheral */
+      Chip_ADC_DeInit( LPC_ADC0 );
+      break;
+   }
+
+}
+
+
+/*
+ * @brief   Get the value of one ADC channel. Mode: BLOCKING
+ * @param   AI0 ... AIn
+ * @return  analog value
+ */
+uint16_t adcRead( adcMap_t analogInput )
+{
+
+   uint8_t lpcAdcChannel = 66 - analogInput;
+   uint16_t analogValue = 0;
+
+   Chip_ADC_EnableChannel(LPC_ADC0, lpcAdcChannel, ENABLE);
+   Chip_ADC_SetStartMode(LPC_ADC0, ADC_START_NOW, ADC_TRIGGERMODE_RISING);
+
+   while(
+      (Chip_ADC_ReadStatus(LPC_ADC0, lpcAdcChannel, ADC_DR_DONE_STAT) != SET)
+   );
+   Chip_ADC_ReadValue( LPC_ADC0, lpcAdcChannel, &analogValue );
+
+   Chip_ADC_EnableChannel( LPC_ADC0, lpcAdcChannel, DISABLE );
+
+   return analogValue;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_board.c ./libs/sapi/sapi_v0.5.1/src/sapi_board.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_board.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_board.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,109 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_board.h"
+
+#include "sapi_tick.h"
+#include "sapi_gpio.h"
+#include "sapi_cyclesCounter.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* Set up and initialize board hardware */
+void boardInit(void)
+{
+   // Read clock settings and update SystemCoreClock variable
+   SystemCoreClockUpdate();
+
+   cyclesCounterInit( SystemCoreClock );
+
+   // Inicializar el conteo de Ticks con resolucion de 1ms
+   tickInit( 1 );
+
+   // Inicializar GPIOs
+   gpioInit( 0, GPIO_ENABLE );
+
+   // Configuracion de pines de entrada para Teclas de la EDU-CIAA-NXP
+   gpioInit( TEC1, GPIO_INPUT );
+   gpioInit( TEC2, GPIO_INPUT );
+   gpioInit( TEC3, GPIO_INPUT );
+   gpioInit( TEC4, GPIO_INPUT );
+
+   // Configuracion de pines de salida para Leds de la EDU-CIAA-NXP
+   gpioInit( LEDR, GPIO_OUTPUT );
+   gpioInit( LEDG, GPIO_OUTPUT );
+   gpioInit( LEDB, GPIO_OUTPUT );
+   gpioInit( LED1, GPIO_OUTPUT );
+   gpioInit( LED2, GPIO_OUTPUT );
+   gpioInit( LED3, GPIO_OUTPUT );
+
+
+   // Configuracion de pines de entrada de la CIAA-NXP
+   gpioInit( DI0, GPIO_INPUT );
+   gpioInit( DI1, GPIO_INPUT );
+   gpioInit( DI2, GPIO_INPUT );
+   gpioInit( DI3, GPIO_INPUT );
+   gpioInit( DI4, GPIO_INPUT );
+   gpioInit( DI5, GPIO_INPUT );
+   gpioInit( DI6, GPIO_INPUT );
+   gpioInit( DI7, GPIO_INPUT );
+
+   // Configuracion de pines de salida de la CIAA-NXP
+   gpioInit( DO0, GPIO_OUTPUT );
+   gpioInit( DO1, GPIO_OUTPUT );
+   gpioInit( DO2, GPIO_OUTPUT );
+   gpioInit( DO3, GPIO_OUTPUT );
+   gpioInit( DO4, GPIO_OUTPUT );
+   gpioInit( DO5, GPIO_OUTPUT );
+   gpioInit( DO6, GPIO_OUTPUT );
+   gpioInit( DO7, GPIO_OUTPUT );
+
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_circularBuffer.c ./libs/sapi/sapi_v0.5.1/src/sapi_circularBuffer.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_circularBuffer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_circularBuffer.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,195 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Date: 2016-10-06 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_circularBuffer.h"   // <= own header
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+static bool_t isSetEmptyBufferCallback = FALSE;
+static bool_t isSetFullBufferCallback  = FALSE;
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+void PLC_IL_ST(void* newValue, PLC_WORD lenght, PLC_EnumModifiers modifier)
+{
+   extern PLC_SymbolicRegister CR;
+
+   // MEMORY COPY
+   uint8_t *source;
+   uint8_t *destination;
+   uint16_t i = 0;
+
+   destination = newValue;
+   source = &(CR.VALUE);
+
+   for( i = 0; i < lenght; i++ )
+   {
+      if (modifier == N)
+      {
+         *destination = ~(*source);
+      }
+      else
+      {
+         *destination = *source;
+      }
+      destination++;
+      source++;
+   }
+}
+*/
+
+void circularBuffer_Init(
+   circularBuffer_t* buffer,    // buffer structure
+   uint8_t* bufferMemory,       // buffer array of memory
+   uint32_t amountOfElements,   // amount of elements in buffer
+   uint32_t elementSize         // each element size in bytes
+)
+{
+
+   buffer->memoryAddress    = bufferMemory;
+   buffer->amountOfElements = amountOfElements + 1;
+   buffer->elementSize      = elementSize;
+   buffer->readIndex        = 0;
+   buffer->writeIndex       = 0;
+   buffer->status           = CIRCULAR_BUFFER_EMPTY;
+}
+
+
+void circularBufferEmptyBufferCallbackSet(
+   circularBuffer_t* buffer,              // buffer structure
+   callBackFuncPtr_t emptyBufferCallback  // pointer to emptyBuffer function
+)
+{
+
+   // Empty buffer callback
+   if( emptyBufferCallback != 0 ) {
+      buffer->emptyBufferCallback = emptyBufferCallback;
+      isSetEmptyBufferCallback = TRUE;
+   }
+}
+
+
+void circularBufferFullBufferCallbackSet(
+   circularBuffer_t* buffer,              // buffer structure
+   callBackFuncPtr_t fullBufferCalback    // pointer to fullBuffer function
+)
+{
+   // Full buffer callback
+   if( fullBufferCalback != 0 ) {
+      buffer->fullBufferCalback = fullBufferCalback;
+      isSetFullBufferCallback = TRUE;
+   }
+}
+
+
+circularBufferStatus_t circularBufferRead( circularBuffer_t* buffer,
+      uint8_t *dataByte )
+{
+
+   uint8_t i = 0;
+
+   // Is Empty?
+   if ( (buffer->readIndex) == (buffer->writeIndex) ) {
+
+      // Error, empty buffer
+      buffer->status = CIRCULAR_BUFFER_EMPTY;
+
+      // Execute emptyBufferCallback
+      if( isSetEmptyBufferCallback ) {
+         (* (buffer->emptyBufferCallback) )(0);
+      }
+
+   } else {
+
+      buffer->status = CIRCULAR_BUFFER_NORMAL;
+
+      // TODO:
+      for( i=0; i<(buffer->elementSize); i++ ) {
+         dataByte[i] = (buffer->memoryAddress)[ buffer->readIndex + i ];
+      }
+
+      // Increment readIndex (circular)
+      buffer->readIndex = (buffer->readIndex + buffer->elementSize) % (buffer->amountOfElements * buffer->elementSize);
+
+   }
+
+   return buffer->status;
+}
+
+
+circularBufferStatus_t circularBufferWrite( circularBuffer_t* buffer,
+      uint8_t *dataByte )
+{
+
+   uint8_t i = 0;
+
+   // Is Full?
+   if( ((buffer->writeIndex + buffer->elementSize) % (buffer->amountOfElements * buffer->elementSize) ) == (buffer->readIndex) ) {
+
+      // Error, full buffer
+      buffer->status = CIRCULAR_BUFFER_FULL;
+
+      // Execute fullBufferCalback
+      if( isSetFullBufferCallback ) {
+         (* (buffer->fullBufferCalback) )(0);
+      }
+
+   } else {
+
+      buffer->status = CIRCULAR_BUFFER_NORMAL;
+
+      // TODO:
+      for( i=0; i<(buffer->elementSize); i++ ) {
+         (buffer->memoryAddress)[ buffer->writeIndex + i ] = dataByte[i];
+      }
+
+      // Increment writeIndex (circular)
+      buffer->writeIndex = (buffer->writeIndex + buffer->elementSize) % (buffer->amountOfElements * buffer->elementSize);
+   }
+
+   return buffer->status;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_convert.c ./libs/sapi/sapi_v0.5.1/src/sapi_convert.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_convert.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_convert.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,140 @@
+/* Copyright 2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-04-17 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_convert.h"     // <= own header
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+// C++ version 0.4 char* style "itoa":
+// Written by Luk�s Chmela
+// Released under GPLv3.
+// Modified by Eric Pernia.
+bool_t int64ToString( int64_t value, char* result, uint8_t base )
+{
+   // check that the base if valid
+   if( base < 2 || base > 36 ) {
+      *result = '\0';
+      return FALSE;
+   }
+
+   char* ptr = result, *ptr1 = result, tmp_char;
+   int64_t tmp_value;
+
+   do {
+      tmp_value = value;
+      value /= (int64_t)base;
+      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * (int64_t)base)];
+   } while ( value );
+
+   // Apply negative sign
+   if (tmp_value < 0) *ptr++ = '-';
+   *ptr-- = '\0';
+   while(ptr1 < ptr) {
+      tmp_char = *ptr;
+      *ptr--= *ptr1;
+      *ptr1++ = tmp_char;
+   }
+   return TRUE;
+}
+
+// C++ version 0.4 char* style "itoa":
+// Written by Luk�s Chmela
+// Released under GPLv3.
+// Modified by Eric Pernia.
+bool_t uint64ToString( uint64_t value, char* result, uint8_t base )
+{
+   // check that the base if valid
+   if( base < 2 || base > 36 ) {
+      *result = '\0';
+      return FALSE;
+   }
+
+   char* ptr = result, *ptr1 = result, tmp_char;
+   uint64_t tmp_value;
+
+   do {
+      tmp_value = value;
+      value /= (uint64_t)base;
+      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * (uint64_t)base)];
+   } while ( value );
+
+   // Apply negative sign
+   if (tmp_value < 0) *ptr++ = '-';
+   *ptr-- = '\0';
+   while(ptr1 < ptr) {
+      tmp_char = *ptr;
+      *ptr--= *ptr1;
+      *ptr1++ = tmp_char;
+   }
+   return TRUE;
+}
+
+char* uintToAsciiHex( uint64_t value, uint8_t bitSize )
+{
+   static char result[17];
+   uint8_t i = 0;
+   uint8_t vectorNumHex[] = "0123456789ABCDEF";
+   result[bitSize/4] = 0;
+
+   for( i=0; i<bitSize/4; i++ ) {
+      result[(bitSize/4)-i-1] = vectorNumHex[ (uint8_t)(( value & (((uint64_t)0x0F)<<(4*i)) ) >> (4*i)) ];
+   }
+
+   return result;
+}
+
+char* intToString( int64_t value )
+{
+   static char result[20];
+   result[0] = 0;
+   int64ToString( value, result, 10 );
+   return result;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_cyclesCounter.c ./libs/sapi/sapi_v0.5.1/src/sapi_cyclesCounter.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_cyclesCounter.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_cyclesCounter.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,129 @@
+/* Copyright 2017, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-30-10 */
+
+// More information at:
+// https://groups.google.com/forum/#!msg/embebidos32/tPntHHUSnyE/S3CDyCwXsaMJ
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_cyclesCounter.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/** Registros correspondientes al nucleo. Probados con Cortex-M3 y Cortex-M4. */
+
+//Registro para configurar el contador de ciclos de clock.
+volatile uint32_t * DWT_CTRL   = (uint32_t *)0xE0001000;
+//Registro donde se cuentan los ciclos de clock.
+volatile uint32_t * DWT_CYCCNT = (uint32_t *)0xE0001004;
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+static uint32_t ClockSpeed = EDU_CIAA_NXP_CLOCK_SPEED;
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/**
+ * Funcion para configurar los registros para contar ciclos de clock.
+ * @return TRUE si esta OK, FALSE en caso de error.
+ */
+bool_t cyclesCounterInit( uint32_t clockSpeed )
+{
+   //Asigna  a la variable local ClockSpeed el valor recibido como argumento.
+   ClockSpeed = clockSpeed;
+   //Iniciar el contador de ciclos de clock.
+   *DWT_CTRL  |= 1;
+   return TRUE;
+}
+
+/**
+ * Funcion para leer el registro con la cuenta de ciclos de clock.
+ * @return el valor del contador de ciclos de clock.
+ */
+uint32_t cyclesCounterRead( void )
+{
+   return *DWT_CYCCNT;
+}
+
+/**
+ * Resetea el contador de ciclos de clock.
+ * Esta funcion debe ser llamada antes de querer
+ * contar el tiempo a medir. Luego de ejecutar la accion,
+ * se debe llamar a la funcion cyclesCounterRead(). Asi se
+ * obtendra la cantidad de ciclos que pasaron.
+ */
+void cyclesCounterReset( void )
+{
+   //resetea el contador de ciclos de clock
+   *DWT_CYCCNT = 0;
+}
+
+/**
+ * Funcion que convierte el valor en ciclos a micro segundos.
+ * Para que esta cuenta se realice correctamente, se tuvo que haber
+ * llamado previamente a la funcion cyclesCounterInit (CLOCK_SPEED);
+ * @param cycles la cantidad de ciclos.
+ * @return el valor convertido a micro segundos.
+ */
+float cyclesCounterToUs( uint32_t cycles )
+{
+   float valueInMicroSeconds = 0;
+   valueInMicroSeconds = (float)cycles/(ClockSpeed/1000000);
+   return valueInMicroSeconds;
+}
+
+/**
+ * Funcion que convierte el valor en ciclos a mili segundos.
+ * Para que esta cuenta se realice correctamente, se tuvo que haber
+ * llamado previamente a la funcion cyclesCounterInit (CLOCK_SPEED);
+ * @param cycles la cantidad de ciclos.
+ * @return el valor convertido a mili segundos.
+ */
+float cyclesCounterToMs( uint32_t cycles )
+{
+   float valueInMilliSeconds = 0;
+   valueInMilliSeconds = (float)cycles/(ClockSpeed/1000);
+   return valueInMilliSeconds;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_dac.c ./libs/sapi/sapi_v0.5.1/src/sapi_dac.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_dac.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_dac.c	2018-12-01 17:15:06.621606191 -0300
@@ -0,0 +1,102 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-20 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_dac.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @brief:  enable/disable the ADC and DAC peripheral
+ * @param:  DAC_ENABLE, DAC_DISABLE
+ * @return: none
+*/
+void dacInit( dacInit_t config )
+{
+
+   switch(config) {
+
+   case DAC_ENABLE:
+      /* Initialize the DAC peripheral */
+      Chip_DAC_Init(LPC_DAC);
+
+      /* Enables the DMA operation and controls DMA timer */
+      Chip_DAC_ConfigDAConverterControl(LPC_DAC, DAC_DMA_ENA);
+      /* DCAR DMA access */
+      /* Update value to DAC buffer*/
+      Chip_DAC_UpdateValue(LPC_DAC, 0);
+      break;
+
+   case DAC_DISABLE:
+      /* Disable DAC peripheral */
+      Chip_DAC_DeInit( LPC_DAC );
+      break;
+   }
+
+}
+
+
+/*
+ * @brief   Write a value in the DAC.
+ * @param   analogOutput: AO0 ... AOn
+ * @param   value: analog value to be writen in the DAC, from 0 to 1023
+ * @return  none
+ */
+void dacWrite( dacMap_t analogOutput, uint16_t value )
+{
+
+   if( analogOutput == AO ) {
+      if( value > 1023 ) {
+         value = 1023;
+      }
+      Chip_DAC_UpdateValue( LPC_DAC, value );
+   }
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_datatypes.c ./libs/sapi/sapi_v0.5.1/src/sapi_datatypes.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_datatypes.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_datatypes.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,91 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-06-05 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_datatypes.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * Null Function Pointer definition
+ * --------------------------------------
+ * param:  void * - Not used
+ * return: bool_t - Return always true
+ */
+bool_t sAPI_NullFuncPtr(void *ptr)
+{
+   return 1;
+}
+
+/*==================[ISR external functions definition]======================*/
+
+/*
+// FUNCTION POINTER VECTOR EXAMPLE
+
+// Función para no tener NULL pointer
+   void dummy(void){
+   }
+
+// Definición de un tipo con typedef.
+   typedef void (*voidFunctionPointer_t)(void);
+
+// Definición de una variable con el tipo de typedef, incializo en dummy (NULL)
+   voidFunctionPointer_t voidFunctionPointer[2] = {dummy, dummy};
+
+// Ejecuto la funcion
+   (* voidFunctionPointer[0] )();
+   (* voidFunctionPointer[1] )();
+
+// Asigno una funcion a cada posición del vector
+   voidFunctionPointer[0] = ledB;
+   voidFunctionPointer[1] = led1;
+*/
+
+
+/** @} doxygen end group definition */
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_delay.c ./libs/sapi/sapi_v0.5.1/src/sapi_delay.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_delay.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_delay.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,133 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_delay.h"
+#include "sapi_tick.h"
+#include "sapi_cyclesCounter.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+extern volatile tick_t tickRateMS;
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/* ---- Inaccurate Blocking Delay ---- */
+
+void delayInaccurate(tick_t delay_ms)
+{
+   volatile tick_t i;
+   volatile tick_t delay;
+
+   delay = INACCURATE_TO_MS * delay_ms;
+
+   for( i=delay; i>0; i-- );
+}
+
+void delayInaccurateUs(tick_t delay_us)
+{
+   volatile tick_t i;
+   volatile tick_t delay;
+
+   delay = (INACCURATE_TO_US_x10 * delay_us) / 10;
+
+   for( i=delay; i>0; i-- );
+}
+
+/* ---- Blocking Delay ---- */
+
+// delay( 1, DELAY_US );
+
+void delay(tick_t duration)
+{
+   tick_t startTime = tickRead();
+   while ( (tick_t)(tickRead() - startTime) < duration/tickRateMS );
+}
+
+void delayUs(tick_t delay_us)
+{
+
+   volatile float timeElapsedUs = 0;
+   volatile uint32_t startCycles = cyclesCounterRead();
+
+   while( ((tick_t)timeElapsedUs) < delay_us ) {
+      timeElapsedUs = cyclesCounterToUs( cyclesCounterRead() - startCycles );
+   }
+}
+
+
+/* ---- Non Blocking Delay ---- */
+
+void delayInit( delay_t * delay, tick_t duration )
+{
+   delay->duration = duration/tickRateMS;
+   delay->running = 0;
+}
+
+bool_t delayRead( delay_t * delay )
+{
+
+   bool_t timeArrived = 0;
+
+   if( !delay->running ) {
+      delay->startTime = tickRead();
+      delay->running = 1;
+   } else {
+      if ( (tick_t)(tickRead() - delay->startTime) >= delay->duration ) {
+         timeArrived = 1;
+         delay->running = 0;
+      }
+   }
+
+   return timeArrived;
+}
+
+void delayWrite( delay_t * delay, tick_t duration )
+{
+   delay->duration = duration/tickRateMS;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_dht11.c ./libs/sapi/sapi_v0.5.1/src/sapi_dht11.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_dht11.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_dht11.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,251 @@
+/* Copyright 2017, Sebastian Pablo Bedin <sebabedin@gmail.com>
+ * Copyright 2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-11-13 */
+
+#include "sapi_dht11.h"
+
+#include "sapi_datatypes.h"
+#include "sapi_peripheral_map.h"
+#include "sapi_gpio.h"
+#include "sapi_delay.h"
+
+#define DHT11_TIMEOUT_MAX			(1000)
+#define DHT11_LEN_dht11_ticks_array	(82)
+#define DHT11_LEN_dht11_byte		(5)
+
+static uint32_t dht11_ticks_array[DHT11_LEN_dht11_ticks_array];
+static uint8_t dht11_byte[DHT11_LEN_dht11_byte];
+
+static int32_t dht11Pin;
+
+enum dht11_state_e {
+   dht11_state_start,
+   dht11_state_low,
+   dht11_state_high,
+   dht11_state_timeout,
+   dht11_state_error,
+   dht11_state_end,
+};
+
+static void dht11_GPIO_Low( void )
+{
+   gpioInit( dht11Pin, GPIO_OUTPUT );
+   gpioWrite( dht11Pin, FALSE);
+}
+
+static void dht11_GPIO_High( void )
+{
+   gpioInit( dht11Pin, GPIO_INPUT_PULLUP );
+}
+
+static bool_t dht11_GPIO_Read(void)
+{
+   return gpioRead( dht11Pin );
+}
+
+uint32_t dht11_timeout;
+uint32_t dht11_timeout_max;
+static void dht11_TimeOutReset(uint32_t max)
+{
+   if(0 < max) {
+      dht11_timeout_max = max;
+   } else {
+      dht11_timeout_max = DHT11_TIMEOUT_MAX;
+   }
+   dht11_timeout = dht11_timeout_max;
+}
+
+static bool_t dht11_TimeOutCheck(void)
+{
+   if(0 < dht11_timeout) {
+      dht11_timeout--;
+      return TRUE;
+   }
+   dht11_TimeOutReset(0);
+   return FALSE;
+}
+
+static bool_t dht11_StartRead(void)
+{
+   uint8_t  state          = dht11_state_start;
+   bool_t   flag_loop_end	= FALSE;
+   bool_t   flag_timeout   = FALSE;
+   bool_t   flag_error	   = FALSE;
+   uint32_t n_tick         = 0;
+   uint32_t n_bit          = 0;
+
+   (void) flag_timeout;   // Use a variable to not produce compiler Warnings
+   (void) flag_error;     // Use a variable to not produce compiler Warnings
+
+   dht11_GPIO_Low();
+   delay(20);
+   dht11_GPIO_High();
+
+   while(FALSE == flag_loop_end) {
+      switch(state) {
+      case dht11_state_start:
+
+         dht11_TimeOutReset(DHT11_TIMEOUT_MAX);
+         while(dht11_state_start == state) {
+            if(dht11_GPIO_Read() == FALSE) {
+               state = dht11_state_low;
+            }
+            if(!dht11_TimeOutCheck()) {
+               state = dht11_state_timeout;
+            }
+         }
+         break;
+
+      case dht11_state_low:
+
+         dht11_TimeOutReset(0);
+         while(dht11_state_low == state) {
+            n_tick++;
+            if(dht11_GPIO_Read() == TRUE) {
+               dht11_ticks_array[n_bit] = n_tick;
+               n_bit++;
+               n_tick = 0;
+               state = dht11_state_high;
+            }
+
+            if(!dht11_TimeOutCheck()) {
+               state = dht11_state_timeout;
+            }
+         }
+         break;
+
+      case dht11_state_high:
+
+         dht11_TimeOutReset(0);
+         while(dht11_state_high == state) {
+            n_tick++;
+            if(dht11_GPIO_Read() == FALSE) {
+               dht11_ticks_array[n_bit] = n_tick;
+               n_bit++;
+               n_tick = 0;
+               state = dht11_state_low;
+            }
+
+            if(!dht11_TimeOutCheck()) {
+               state = dht11_state_timeout;
+            }
+         }
+         break;
+
+      case dht11_state_timeout:
+         flag_timeout = TRUE;
+         state = dht11_state_end;
+         break;
+
+      case dht11_state_end:
+         flag_loop_end = TRUE;
+         break;
+
+      default:
+      case dht11_state_error:
+         flag_error = TRUE;
+         state = dht11_state_end;
+         break;
+      }
+
+
+      if(DHT11_LEN_dht11_ticks_array <= n_bit) {
+         state = dht11_state_end;
+      }
+   }
+
+   if(82 == n_bit) {
+      return TRUE;
+   }
+
+   return FALSE;
+}
+
+static bool_t dht11_ProcessData(void)
+{
+   int i, i_i, i_f, j;
+   uint32_t valf, valt;
+
+   valf = dht11_ticks_array[0];
+   valt = dht11_ticks_array[1];
+   for(i = 2; i < 81; i++) {
+      if((valf <= dht11_ticks_array[i]) || (valt <= dht11_ticks_array[i])) {
+         return FALSE;
+      }
+   }
+
+   i_i = 2;
+   for(j = 0; j < DHT11_LEN_dht11_byte; j++) {
+      dht11_byte[j] = 0x00;
+      i_f = i_i + 8 * 2 - 1;
+      for(i = i_i; i < i_f; i = i + 2) {
+         valf = dht11_ticks_array[i];
+         valt = dht11_ticks_array[i+1];
+
+         if(valt < valf) {
+            dht11_byte[j] = (dht11_byte[j] << 1);
+         } else {
+            dht11_byte[j] = (dht11_byte[j] << 1) | 0x01;
+         }
+      }
+      i_i = i_f + 1;
+   }
+
+   uint8_t crc;
+   crc = dht11_byte[0] + dht11_byte[1] + dht11_byte[2] + dht11_byte[3];
+   if(crc != dht11_byte[4]) {
+      return FALSE;
+   }
+
+   return TRUE;
+}
+
+void dht11Init( int32_t gpio )
+{
+   dht11Pin = (int32_t)gpio;
+   dht11_GPIO_High();
+}
+
+bool_t dht11Read( float *phum, float *ptemp )
+{
+   if(TRUE == dht11_StartRead()) {
+      if(TRUE == dht11_ProcessData()) {
+         *phum 	= ((float)dht11_byte[0]) + ((float)dht11_byte[1])/10;
+         *ptemp 	= ((float)dht11_byte[2]) + ((float)dht11_byte[3])/10;
+         return TRUE;
+      }
+   }
+   return FALSE;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_esp8266.c ./libs/sapi/sapi_v0.5.1/src/sapi_esp8266.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_esp8266.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_esp8266.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,668 @@
+/* Copyright 2016, Marcelo Vieytes.
+ * Copyright 2017, Pablo Gomez, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-14-11 */
+
+/*==================[inlcusiones]============================================*/
+
+#include "sapi_esp8266.h"
+#include "sapi.h"
+
+#include <string.h>
+
+/*==================[definiciones y macros]==================================*/
+
+#define ESP8266_UART        UART_232
+#define ESP8266_BAUD_RATE   115200
+#define ESP8266_TMO         5000
+#define ESP8266_PAUSE       5000
+#define ESP8266_WAIT        1000
+
+#define MAX_COMMAND_LENGHT  40
+#define MAX_HTTP_WEB_LENGHT 3000
+
+typedef enum Esp8266State {
+   ESP_INIT,
+   ESP_SEND_AT,
+   ESP_WAIT_AT,
+   ESP_SEND_CWJAP_CONS,
+   ESP_WAIT_CWJAP_CONS_1,
+   ESP_WAIT_CWJAP_CONS_2,
+   ESP_SEND_CWMODE_SET,
+   ESP_WAIT_CWMODE_SET,
+   ESP_SEND_CWJAP_SET,
+   ESP_WAIT_CWJAP_SET_1,
+   ESP_WAIT_CWJAP_SET_2,
+   ESP_WAIT_CWJAP_SET_3,
+   ESP_CONNECTED,
+   ESP_SEND_START,
+   ESP_WAIT_START_1,
+   ESP_WAIT_START_2,
+   ESP_SEND_SEND,
+   ESP_WAIT_SEND,
+   ESP_SEND_DATA,
+   ESP_WAIT_DATA_1,
+   ESP_WAIT_DATA_2,
+   ESP_CIPMUX_SEND,
+   ESP_WAIT_CIPMUX,
+   ESP_SEND_CIPSERVER,
+   ESP_WAIT_CIPSERVER,
+   ESP_WAIT_GET,
+   ESP_SEND_CIPSTATUS,
+   ESP_WAIT_CIPSTATUS_3,
+   ESP_WAIT_GET_ID,
+   ESP_SEND_CIPSEND,
+   ESP_WAIT_CIPSEND,
+   ESP_SEND_HTTP,
+   ESP_WAIT_HTTP,
+   ESP_WAIT_CIPSTATUS_OK,
+   ESP_WAIT_CIPSTATUS,
+   ESP_SEND_CIPCLOSE,
+   ESP_WAIT_CIPCLOSE,
+   ESP_SEND_CIFSR,
+   ESP_WAIT_CIFSR,
+   ESP_LOAD_IP
+} Esp8266Status_t;
+
+/*==================[definiciones de datos internos]=========================*/
+
+//Nombres de los estados en forma de strings para imprimir por pantalla.
+/*
+static const char Esp8266StatusToString[][MAX_COMMAND_LENGHT] = {
+   "ESP_INIT",
+   "ESP_SEND_AT",
+   "ESP_WAIT_AT",
+   "ESP_SEND_CWJAP_CONS",
+   "ESP_WAIT_CWJAP_CONS_1",
+   "ESP_WAIT_CWJAP_CONS_2",
+   "ESP_SEND_CWMODE_SET",
+   "ESP_WAIT_CWMODE_SET",
+   "ESP_SEND_CWJAP_SET",
+   "ESP_WAIT_CWJAP_SET_1",
+   "ESP_WAIT_CWJAP_SET_2",
+   "ESP_WAIT_CWJAP_SET_3",
+   "ESP_CONNECTED",
+   "ESP_SEND_START",
+   "ESP_WAIT_START_1",
+   "ESP_WAIT_START_2",
+   "ESP_SEND_SEND",
+   "ESP_WAIT_SEND",
+   "ESP_SEND_DATA",
+   "ESP_WAIT_DATA_1",
+   "ESP_WAIT_DATA_2",
+   "ESP_CIPMUX_SEND",
+   "ESP_WAIT_CIPMUX",
+   "ESP_SEND_CIPSERVER",
+   "ESP_WAIT_CIPSERVER",
+   "ESP_WAIT_GET",
+   "ESP_SEND_CIPSTATUS",
+   "ESP_WAIT_CIPSTATUS_3",
+   "ESP_WAIT_GET_ID",
+   "ESP_SEND_CIPSEND",
+   "ESP_WAIT_CIPSEND",
+   "ESP_SEND_HTTP",
+   "ESP_WAIT_HTTP",
+   "ESP_WAIT_CIPSTATUS_OK",
+   "ESP_WAIT_CIPSTATUS",
+   "ESP_SEND_CIPCLOSE",
+   "ESP_WAIT_CIPCLOSE",
+   "ESP_SEND_CIFSR",
+   "ESP_WAIT_CIFSR",
+   "ESP_LOAD_IP"
+};
+*/
+
+// Respuestas del ESP8266
+static const char Response_OK[]        = "OK";
+static const char Response_CWJAP_OK[]  = "+CWJAP:";
+static const char Response_CWJAP_1[]   = "WIFI CONNECTED";
+static const char Response_CWJAP_2[]   = "WIFI GOT IP";
+static const char Response_SEND_OK[]   = "SEND OK";
+static const char Response_STATUS_3[]  = "STATUS:3";
+static const char Response_CIPSTATUS[] = "+CIPSTATUS:";
+static const char Response_CIPCLOSE[]  = "CLOSED";
+static const char Response_CIFSR[]     = "+CIFSR:STAIP,\"";
+// Memoria asociada a las conexiones
+static uint8_t      CurrentConnectionId;
+static char         WifiName [30] = "";
+static char         WifiPass [30] = "";
+static char	        WifiIp   [20];
+// Punteros a la pagina web a mostrar
+static char *       PointerOfHttpBody;
+static const char * PointerOfHttpHeader;
+static const char * PointerOfHttpEnd;
+// Variables utilizadas en la maquina de estados.
+static const char * Esp8266ResponseToWait;
+static delay_t      Esp8266Delay;
+static uint8_t      Esp8266Status = ESP_INIT;
+static uartMap_t	Esp8266DebugUart = UART_485;
+static uint32_t	    Esp8266DebugBaudRate = 0;
+
+/*==================[definiciones de datos externos]=========================*/
+
+/*==================[declaraciones de funciones internas]====================*/
+
+static bool_t 	IsWaitedResponse            (void);
+static void 	SetEsp8622Status            (uint8_t statusToSend);
+static void     ExcecuteHttpServerFsm       (void);
+
+/*==================[declaraciones de funciones externas]====================*/
+
+/**
+ * Funcion para obtener la direccion IP del modulo Esp8266
+ * @return devuelve un puntero al arreglo local donde esta alojado el dato.
+ */
+char * esp8266GetIpAddress    ()
+{
+   return WifiIp;
+}
+
+/**
+ * Funcion para obtener el nombre de la red del modulo Esp8266
+ * @return devuelve un puntero al arreglo local donde esta alojado el dato.
+ */
+char * esp8266GetWifiName     ()
+{
+   return WifiName;
+}
+
+/**
+ * Funcion para obtener la contrasenia de la red del modulo Esp8266
+ * @return devuelve un puntero al arreglo local donde esta alojado el dato.
+ */
+char * esp8266GetWifiPass     ()
+{
+   return WifiPass;
+}
+
+/**
+ * Devuelve al usuario el indice de la conexion establecida
+ * @return un entero correspondiente a
+ */
+uint8_t esp8266GetConnectionId ()
+{
+   return CurrentConnectionId - '0';
+}
+
+/**
+ * Configura la conexion para que el modulo Esp8266 sea un servidor HTTP.
+ * Realiza llamadas no bloqueantes a la maquina de estados que maneja la conexion.
+ * La variable parametersReceived sirve para cargar por unica vez los datos de la red
+ * @param wifiName puntero con el nombre de la red Wifi
+ * @param wifiPass puntero con la contrasenia de la red Wifi
+ * @param debugUart es la uart por donde va a reportar los datos. Este parametro es opcional, poner 0 sino se necesita.
+ * @param debugBaudRate es la velocidad de la uart de debug. Poner en 0 si no se necesita.
+ * @return TRUE si se configuro correctamente como servidor HTTP, FALSE caso contrario.
+ */
+bool_t esp8266InitHttpServer(char * wifiName, char * wifiPass, uartMap_t debugUart, uint32_t debugBaudRate)
+{
+   static bool_t parametersReceived = FALSE;
+
+   if (!parametersReceived) {
+      strcpy(WifiName, wifiName);
+      strcpy(WifiPass, wifiPass);
+      SetEsp8622Status(ESP_INIT);
+      parametersReceived = TRUE;
+      if (debugBaudRate > 0) {
+         Esp8266DebugUart     = debugUart;
+         Esp8266DebugBaudRate = debugBaudRate;
+      }
+   }
+   ExcecuteHttpServerFsm();
+
+   return (Esp8266Status == ESP_SEND_CIPSTATUS);
+}
+
+/**
+ * Funcion para determinar si hay alguna peticion HTTP realizada desde una
+ * pagina web, realizada por algun cliente.
+ * Ademas realiza llamadas no bloqueantes a la maquina de estados del
+ * modulo que administra las conexiones y peticiones de clientes.
+ * @return TRUE si se recibio una peticion, FALSE caso contrario.
+ */
+bool_t esp8266ReadHttpServer  ()
+{
+   ExcecuteHttpServerFsm();
+   return (Esp8266Status == ESP_SEND_CIPSEND);
+}
+
+/**
+ * Funcion para enviar una pagina web actualizada en respuesta a la
+ * peticion del cliente.
+ * Corrobora quue haya una peticion real del usuario antes de enviar datos.
+ * Si hay una peticion, carga en los punteros correspondientes toda la
+ * pagina web que se le enviara al cliente.
+ * Un detalle importante es que tanto el header como el end de la web son
+ * constantes, ya que se supone que no cambian a lo largo del programa.
+ * Lo que si cambiara es el body HTTP que es el que contiene la informacion
+ * actualizada del estado del sistema.
+ * @param webHttpHeader puntero al header http (debe ser parte de la aplicacion de usuario).
+ * @param webHttpBody puntero al body http (debe ser parte de la aplicacion de usuario).
+ * @param webHttpEnd puntero al end http (debe ser parte de la aplicacion de usuario).
+ * @return TRUE si pudo mandar la web correctamente, FALSE caso contrario.
+ */
+bool_t esp8266WriteHttpServer (const char * webHttpHeader, char * webHttpBody, const char * webHttpEnd)
+{
+   //antes de enviar se asegura que haya datos pendientes para enviar
+   if (Esp8266Status == ESP_SEND_CIPSEND) {
+      PointerOfHttpHeader = webHttpHeader;
+      PointerOfHttpBody   = webHttpBody;
+      PointerOfHttpEnd    = webHttpEnd;
+   }
+   ExcecuteHttpServerFsm();
+
+   return (Esp8266Status == ESP_SEND_CIPCLOSE);
+}
+
+/*==================[definiciones de funciones internas]=====================*/
+
+/**
+ * Funcion principal del modulo Wifi Esp8266 para funcionar como servidor HTTP.
+ * Desde aca se manejan los comandos a enviar, los tiempos a esperar y
+ * las respuestas a recibir.
+ * Automaticamente cambia de estados en funcion de los eventos que ocurran.
+ */
+static void    ExcecuteHttpServerFsm   (void)
+{
+   uint16_t lenghtOfHttpLines;
+   static uint8_t byteReceived, auxIndex;
+
+   switch (Esp8266Status) {
+
+   case ESP_INIT:
+      uartInit(ESP8266_UART, ESP8266_BAUD_RATE);
+      if (Esp8266DebugBaudRate > 0) {
+         uartInit(Esp8266DebugUart, Esp8266DebugBaudRate);
+      }
+      delayInit(&Esp8266Delay, ESP8266_PAUSE);
+      SetEsp8622Status(ESP_SEND_AT);
+      break;
+
+   case ESP_SEND_AT:
+      if (delayRead(&Esp8266Delay)) {
+         printf("AT\r\n");
+         Esp8266ResponseToWait = Response_OK;
+         delayInit(&Esp8266Delay, ESP8266_TMO);
+         SetEsp8622Status(ESP_WAIT_AT);
+      }
+      break;
+
+   case ESP_WAIT_AT:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CWJAP_CONS);
+      }
+      //Si no recibe OK vuelve a enviar AT
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_SEND_CWJAP_CONS:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CWJAP?\r\n");
+         Esp8266ResponseToWait = Response_CWJAP_OK;
+         delayInit(&Esp8266Delay, ESP8266_TMO);
+         SetEsp8622Status(ESP_WAIT_CWJAP_CONS_1);
+      }
+      break;
+
+   case ESP_WAIT_CWJAP_CONS_1:
+      if (IsWaitedResponse()) {
+         Esp8266ResponseToWait = Response_OK;
+         SetEsp8622Status(ESP_WAIT_CWJAP_CONS_2);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CWMODE_SET);
+      }
+      break;
+
+   case ESP_WAIT_CWJAP_CONS_2:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_CIPMUX_SEND);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_SEND_CWMODE_SET:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CWMODE=3\r\n");
+         Esp8266ResponseToWait = Response_OK;
+         delayInit(&Esp8266Delay, ESP8266_TMO);
+         SetEsp8622Status(ESP_WAIT_CWMODE_SET);
+      }
+      break;
+
+   case ESP_WAIT_CWMODE_SET:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CWJAP_SET);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_SEND_CWJAP_SET:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CWJAP=\"%s\",\"%s\"", WifiName, WifiPass);
+         Esp8266ResponseToWait = Response_CWJAP_1;
+         delayInit(&Esp8266Delay, ESP8266_TMO);
+         SetEsp8622Status(ESP_WAIT_CWJAP_SET_1);
+      }
+      break;
+
+   case ESP_WAIT_CWJAP_SET_1:
+      if (IsWaitedResponse()) {
+         Esp8266ResponseToWait = Response_CWJAP_2;
+         SetEsp8622Status(ESP_WAIT_CWJAP_SET_2);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_WAIT_CWJAP_SET_2:
+      if (IsWaitedResponse()) {
+         Esp8266ResponseToWait = Response_OK;
+         SetEsp8622Status(ESP_WAIT_CWJAP_SET_3);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_WAIT_CWJAP_SET_3:
+      if (IsWaitedResponse())
+         SetEsp8622Status(ESP_CIPMUX_SEND);
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_CIPMUX_SEND:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CIPMUX=1\r\n");
+         Esp8266ResponseToWait = Response_OK;
+         delayInit(&Esp8266Delay, ESP8266_TMO);
+         SetEsp8622Status(ESP_WAIT_CIPMUX);
+         auxIndex=0;
+      }
+      break;
+
+   case ESP_WAIT_CIPMUX:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSERVER);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         // cierra todas las posibles conexioes
+         printf( "AT+CIPCLOSE=%d\r\n", auxIndex);
+         if (++auxIndex >= 4) {
+            SetEsp8622Status(ESP_CIPMUX_SEND);
+         }
+      }
+      break;
+
+   case ESP_SEND_CIPSERVER:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CIPSERVER=1,80\r\n");
+         Esp8266ResponseToWait = Response_OK;
+         delayInit(&Esp8266Delay, ESP8266_TMO);
+         SetEsp8622Status(ESP_WAIT_CIPSERVER);
+      }
+      break;
+
+   case ESP_WAIT_CIPSERVER:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIFSR);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_AT);
+      }
+      break;
+
+   case ESP_SEND_CIFSR:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CIFSR\r\n");
+         Esp8266ResponseToWait = Response_CIFSR;
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_WAIT_CIFSR);
+      }
+      break;
+
+   case ESP_WAIT_CIFSR:
+      if (IsWaitedResponse()) {
+         SetEsp8622Status(ESP_LOAD_IP);
+         auxIndex=0;
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIFSR);
+      }
+      break;
+
+   //Recibe byte a byte la direccion IP y la almacena en WifiIp
+   case ESP_LOAD_IP:
+      if (uartReadByte(ESP8266_UART, &byteReceived)) {
+         if (byteReceived != '"') {
+            WifiIp [auxIndex] = byteReceived;
+            auxIndex++;
+         } else {
+            WifiIp [auxIndex] = '\0';
+            SetEsp8622Status(ESP_SEND_CIPSTATUS);
+         }
+      }
+      break;
+
+   // En este estado el modulo ya esta configurado como servidor HTTP
+   // entonces cada vez que pasa el delay ESP8266_PAUSE mediante
+   // el compando CIP_STATUS le pregunta al moduloWifi si hay una nueva peticion
+   case ESP_SEND_CIPSTATUS:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CIPSTATUS\r\n");
+         Esp8266ResponseToWait = Response_STATUS_3;
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_WAIT_CIPSTATUS_3);
+      }
+      break;
+
+   case ESP_WAIT_CIPSTATUS_3:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         Esp8266ResponseToWait = Response_CIPSTATUS;
+         SetEsp8622Status(ESP_WAIT_CIPSTATUS);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSTATUS);
+      }
+      break;
+
+   case ESP_WAIT_CIPSTATUS:
+      if (IsWaitedResponse()) {
+         SetEsp8622Status(ESP_WAIT_GET_ID);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSTATUS);
+      }
+      break;
+
+   case ESP_WAIT_GET_ID:
+      if (uartReadByte(ESP8266_UART, &byteReceived)) {
+         CurrentConnectionId = byteReceived;
+         Esp8266ResponseToWait = Response_OK;
+         SetEsp8622Status(ESP_WAIT_CIPSTATUS_OK);
+         auxIndex = 0;
+      }
+      break;
+
+   case ESP_WAIT_CIPSTATUS_OK:
+      if (IsWaitedResponse()) {
+         SetEsp8622Status(ESP_SEND_CIPSEND);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSTATUS);
+      }
+      break;
+
+   //En este estado le dice al modulo cuantos bytes va a mandar
+   // El comando esta compuesto por el comando CIPSEND, mas el ID
+   // de la conexion abierta, mas la cantidad en ASCII de los bytes
+   // que tiene la pagina web (o al menos los bytes de la primer linea).
+   case ESP_SEND_CIPSEND:
+
+      lenghtOfHttpLines = (strlen(PointerOfHttpHeader) + strlen(PointerOfHttpBody) + strlen(PointerOfHttpEnd));
+      // Si se pasa del maximo largo permitido lo avisa en la web
+      if (lenghtOfHttpLines >= MAX_HTTP_WEB_LENGHT) {
+         sprintf(PointerOfHttpBody, "ERROR: La longitud de datos HTTP supera el maximo permitido de %d bytes.", MAX_HTTP_WEB_LENGHT);
+         lenghtOfHttpLines = (strlen(PointerOfHttpHeader) + strlen(PointerOfHttpBody) + strlen(PointerOfHttpEnd));
+      }
+      printf( "AT+CIPSEND=%c,%d\r\n", CurrentConnectionId, lenghtOfHttpLines);
+      SetEsp8622Status(ESP_WAIT_CIPSEND);
+      Esp8266ResponseToWait = Response_OK;
+      break;
+
+   case ESP_WAIT_CIPSEND:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_HTTP);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSTATUS);
+      }
+      break;
+
+   case ESP_SEND_HTTP:
+      printf( "%s%s%s", PointerOfHttpHeader, PointerOfHttpBody, PointerOfHttpEnd);
+      SetEsp8622Status(ESP_WAIT_HTTP);
+      Esp8266ResponseToWait = Response_SEND_OK;
+      break;
+
+   case ESP_WAIT_HTTP:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPCLOSE);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSEND);
+      }
+      break;
+
+   case ESP_SEND_CIPCLOSE:
+      if (delayRead(&Esp8266Delay)) {
+         printf( "AT+CIPCLOSE=%c\r\n", CurrentConnectionId);
+         Esp8266ResponseToWait  = Response_CIPCLOSE;
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_WAIT_CIPCLOSE);
+      }
+      break;
+
+   case ESP_WAIT_CIPCLOSE:
+      if (IsWaitedResponse()) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSTATUS);
+      }
+      if (delayRead(&Esp8266Delay)) {
+         delayInit(&Esp8266Delay, ESP8266_PAUSE);
+         SetEsp8622Status(ESP_SEND_CIPSTATUS);
+      }
+      break;
+   }
+}
+
+/**
+ * Determina si la respuesta que envio el modulo Esp8266 al
+ * sistema embebido sea correcta.
+ * Dentro de esta funcion va leyendo datos de la UART asociada
+ * al modulo Esp8266 hasta encontrar el patron de datos necesario.
+ * @return TRUE si es la respuesta esperada, FALSE caso contrario.
+ */
+static bool_t  IsWaitedResponse        (void)
+{
+   static uint8_t index = 0;
+   uint8_t byteReceived;
+   bool_t moduleResponse = FALSE;
+
+   if (uartReadByte(ESP8266_UART, &byteReceived)) {
+      if (Esp8266DebugBaudRate > 0) {
+         printf( "%c", byteReceived);
+      }
+      if (byteReceived == Esp8266ResponseToWait[index]) {
+         index++;
+         if (Esp8266ResponseToWait[index] == '\0') {
+            index = 0;
+            moduleResponse = TRUE;
+            if (Esp8266DebugBaudRate > 0) {
+               printf( "\n\r", byteReceived);
+            }
+         }
+      } else {
+         index = 0;
+      }
+   }
+   return moduleResponse;
+}
+
+/**
+ * Setea el estado global del modulo Esp8266.
+ * @param status Estado a setear.
+ */
+static void    SetEsp8622Status        (Esp8266Status_t status)
+{
+   Esp8266Status = status;
+   if (Esp8266DebugBaudRate > 0) {
+//		printf( "\n\rESP8266 State = %s\n\r", Esp8266StatusToString[status]);
+   }
+}
+
+/*==================[fin del archivo]========================================*/
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_gpio.c ./libs/sapi/sapi_v0.5.1/src/sapi_gpio.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_gpio.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_gpio.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,341 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_gpio.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+const pinInitGpioLpc4337_t gpioPinsInit[] = {
+
+   /*{ {PinNamePortN ,PinNamePinN}, PinFUNC, {GpioPortN, GpioPinN} }*/
+
+   /* --------------------------------------------------------------- */
+   /*                           EDU-CIAA-NXP                          */
+   /* --------------------------------------------------------------- */
+   /*                             Snap  sAPI   Connector  Serigraphy  */
+   /* --------------------------------------------------------------- */
+
+   // { {1,15}, FUNC0, {0, 2} },   /*  0   DIO0    CON2_09   ENET_RXD0   */
+
+   // { {1, 4}, FUNC0, {0,11} },   /*  1   DIO1    CON2_21   SPI_MOSI    */
+   // { {4, 9}, FUNC4, {5,13} },   /*  2   DIO2    CON2_23   LCD_EN      */
+
+   // { {6, 1}, FUNC0, {3, 0} },   /*  3   DIO3    CON2_29   GPIO0       */
+   // { {6, 5}, FUNC0, {3, 4} },   /*  4   DIO4    CON2_31   GPIO2       */
+   // { {6, 8}, FUNC4, {5,16} },   /*  5   DIO5    CON2_33   GPIO4       */
+   // { {6,10}, FUNC0, {3, 6} },   /*  6   DIO6    CON2_35   GPIO6       */
+
+   // { {0, 0}, FUNC0, {0, 0} },   /*  7   DIO7    CON2_04   ENET_RXD1   */
+   // { {0, 1}, FUNC0, {0, 1} },   /*  8   DIO8    CON2_06   ENET_TXEN   */
+   // { {7, 7}, FUNC0, {3,15} },   /*  9   DIO9    CON2_08   ENET_MDC    */
+   // { {1,16}, FUNC0, {0, 3} },   /* 10   DIO10   CON2_10   ENET_CRS_DV */
+   // { {1,17}, FUNC0, {0,12} },   /* 11   DIO11   CON2_12   ENET_MDIO   */
+   // { {1,18}, FUNC0, {0,13} },   /* 12   DIO12   CON2_14   ENET_TXD0   */
+   // { {1,20}, FUNC0, {0,15} },   /* 13   DIO13   CON2_16   ENET_TXD1   */
+   // { {1, 3}, FUNC0, {0,10} },   /* 14   DIO14   CON2_18   SPI_MISO    */
+
+   // { {4,10}, FUNC4, {5,14} },   /* 15   DIO15   CON2_22   LCD4        */
+   // { {4, 8}, FUNC4, {5,12} },   /* 16   DIO16   CON2_24   LCDRS       */
+   // { {4, 6}, FUNC0, {2, 6} },   /* 17   DIO17   CON2_26   LCD3        */
+   // { {4, 5}, FUNC0, {2, 5} },   /* 18   DIO18   CON2_28   LCD2        */
+   // { {4, 4}, FUNC0, {2, 4} },   /* 19   DIO19   CON2_30   LCD1        */
+
+   // { {6, 4}, FUNC0, {3, 3} },   /* 20   DIO20   CON2_32   GPIO1       */
+   // { {6, 7}, FUNC4, {5,15} },   /* 21   DIO21   CON2_34   GPIO3       */
+   // { {6, 9}, FUNC0, {3, 5} },   /* 22   DIO22   CON2_36   GPIO5       */
+   // { {6,11}, FUNC0, {3, 7} },   /* 23   DIO23   CON2_38   GPIO7       */
+   // { {6,12}, FUNC0, {2, 8} },   /* 24   DIO24   CON2_40   GPIO8       */
+
+   // { {2, 4}, FUNC4, {5, 4} },   /* 25   DIO25   CON1_23   RS232_RXD   */
+   // { {2, 3}, FUNC4, {5, 3} },   /* 26   DIO26   CON1_25   RS232_TXD   */
+   // { {3, 1}, FUNC4, {5, 8} },   /* 27   DIO27   CON1_27   CAN_RD      */
+   // { {3, 2}, FUNC4, {5, 9} },   /* 28   DIO28   CON1_29   CAN_TD      */
+   // { {7, 4}, FUNC0, {3,12} },   /* 29   DIO29   CON1_31   T_COL1      */
+   // { {4, 0}, FUNC0, {2, 0} },   /* 30   DIO30   CON1_33   T_FIL0      */
+   // { {4, 3}, FUNC0, {2, 3} },   /* 31   DIO31   CON1_35   T_FIL3      */
+   // { {4, 2}, FUNC0, {2, 2} },   /* 32   DIO32   CON1_37   T_FIL2      */
+   // { {1, 5}, FUNC0, {1, 8} },   /* 33   DIO33   CON1_39   T_COL0      */
+
+   // { {7, 5}, FUNC0, {3,13} },   /* 34   DIO34   CON1_34   T_COL2      */
+   // { {4, 1}, FUNC0, {2, 1} },   /* 35   DIO35   CON1_36   T_FIL1      */
+
+
+   { {4, 1}, FUNC0, {2, 1} },   /*   0   CON1_36   T_FIL1           */
+   { {7, 5}, FUNC0, {3,13} },   /*   1   CON1_34   T_COL2           */
+
+   { {1, 5}, FUNC0, {1, 8} },   /*   2   CON1_39   T_COL0           */
+   { {4, 2}, FUNC0, {2, 2} },   /*   3   CON1_37   T_FIL2           */
+   { {4, 3}, FUNC0, {2, 3} },   /*   4   CON1_35   T_FIL3           */
+   { {4, 0}, FUNC0, {2, 0} },   /*   5   CON1_33   T_FIL0           */
+   { {7, 4}, FUNC0, {3,12} },   /*   6   CON1_31   T_COL1           */
+
+   { {3, 2}, FUNC4, {5, 9} },   /*   7   CON1_29   CAN_TD           */
+   { {3, 1}, FUNC4, {5, 8} },   /*   8   CON1_27   CAN_RD           */
+
+   { {2, 3}, FUNC4, {5, 3} },   /*   9   CON1_25   RS232_TXD        */
+   { {2, 4}, FUNC4, {5, 4} },   /*  10   CON1_23   RS232_RXD        */
+
+   { {6,12}, FUNC0, {2, 8} },   /*  11   CON2_40   GPIO8            */
+   { {6,11}, FUNC0, {3, 7} },   /*  12   CON2_38   GPIO7            */
+   { {6, 9}, FUNC0, {3, 5} },   /*  13   CON2_36   GPIO5            */
+   { {6, 7}, FUNC4, {5,15} },   /*  14   CON2_34   GPIO3            */
+   { {6, 4}, FUNC0, {3, 3} },   /*  15   CON2_32   GPIO1            */
+
+   { {4, 4}, FUNC0, {2, 4} },   /*  16   CON2_30   LCD1             */
+   { {4, 5}, FUNC0, {2, 5} },   /*  17   CON2_28   LCD2             */
+   { {4, 6}, FUNC0, {2, 6} },   /*  18   CON2_26   LCD3             */
+   { {4, 8}, FUNC4, {5,12} },   /*  19   CON2_24   LCDRS            */
+   { {4,10}, FUNC4, {5,14} },   /*  20   CON2_22   LCD4             */
+
+   { {1, 3}, FUNC0, {0,10} },   /*  21   CON2_18   SPI_MISO         */
+
+   { {1,20}, FUNC0, {0,15} },   /*  22   CON2_16   ENET_TXD1        */
+   { {1,18}, FUNC0, {0,13} },   /*  23   CON2_14   ENET_TXD0        */
+   { {1,17}, FUNC0, {0,12} },   /*  24   CON2_12   ENET_MDIO        */
+   { {1,16}, FUNC0, {0, 3} },   /*  25   CON2_10   ENET_CRS_DV      */
+   { {7, 7}, FUNC0, {3,15} },   /*  26   CON2_08   ENET_MDC         */
+   { {0, 1}, FUNC0, {0, 1} },   /*  27   CON2_06   ENET_TXEN        */
+   { {0, 0}, FUNC0, {0, 0} },   /*  28   CON2_04   ENET_RXD1        */
+
+   { {6,10}, FUNC0, {3, 6} },   /*  29   CON2_35   GPIO6            */
+   { {6, 8}, FUNC4, {5,16} },   /*  30   CON2_33   GPIO4            */
+   { {6, 5}, FUNC0, {3, 4} },   /*  31   CON2_31   GPIO2            */
+   { {6, 1}, FUNC0, {3, 0} },   /*  32   CON2_29   GPIO0            */
+
+   { {4, 9}, FUNC4, {5,13} },   /*  33   CON2_23   LCDEN            */
+
+   { {1, 4}, FUNC0, {0,11} },   /*  34   CON2_21   SPI_MOSI         */
+
+   { {1,15}, FUNC0, {0, 2} },   /*  35   CON2_09   ENET_RXD0        */
+
+
+   { {1, 0}, FUNC0, {0, 4} },   /* 36   TEC1    TEC_1                 */
+   { {1, 1}, FUNC0, {0, 8} },   /* 37   TEC2    TEC_2                 */
+   { {1, 2}, FUNC0, {0, 9} },   /* 38   TEC3    TEC_3                 */
+   { {1, 6}, FUNC0, {1, 9} },   /* 39   TEC4    TEC_4                 */
+
+   { {2, 0}, FUNC4, {5, 0} },   /* 43   LEDR    LED0_R                */
+   { {2, 1}, FUNC4, {5, 1} },   /* 44   LEDG    LED0_G                */
+   { {2, 2}, FUNC4, {5, 2} },   /* 45   LEDB    LED0_B                */
+   { {2,10}, FUNC0, {0,14} },   /* 40   LED1    LED1                  */
+   { {2,11}, FUNC0, {1,11} },   /* 41   LED2    LED2                  */
+   { {2,12}, FUNC0, {1,12} },   /* 42   LED3    LED3                  */
+
+   /* --------------------------------------------------------------- */
+   /*                             CIAA-NXP                            */
+   /* --------------------------------------------------------------- */
+   /*                             Snap  sAPI   Connector  Serigraphy  */
+   /* --------------------------------------------------------------- */
+
+   { {4, 0}, FUNC0, {2, 0} },   /* 46   DI0     BORN_24   DIN0        */
+   { {4, 1}, FUNC0, {2, 1} },   /* 47   DI1     BORN_25   DIN1        */
+   { {4, 2}, FUNC0, {2, 2} },   /* 48   DI2     BORN_26   DIN2        */
+   { {4, 3}, FUNC0, {2, 3} },   /* 49   DI3     BORN_27   DIN3        */
+   { {7, 3}, FUNC0, {3,11} },   /* 50   DI4     BORN_28   DIN4        */
+   { {7, 4}, FUNC0, {3,12} },   /* 51   DI5     BORN_29   DIN5        */
+   { {7, 5}, FUNC0, {3,13} },   /* 52   DI6     BORN_30   DIN6        */
+   { {7, 6}, FUNC0, {3,14} },   /* 53   DI7     BORN_31   DIN7        */
+
+   { {2, 1}, FUNC4, {5, 1} },   /* 54   DO0     BORN_14   DOUT0       */
+   { {4, 6}, FUNC0, {2, 6} },   /* 55   DO1     BORN_06   DOUT1       */
+   { {4, 5}, FUNC0, {2, 5} },   /* 56   DO2     BORN_08   DOUT2       */
+   { {4, 4}, FUNC0, {2, 4} },   /* 57   DO3     BORN_10   DOUT3       */
+   { {4, 8}, FUNC4, {5,12} },   /* 58   DO4     BORN_14   DOUT4       */
+   { {4, 9}, FUNC4, {5,13} },   /* 59   DO5     BORN_15   DOUT5       */
+   { {4,10}, FUNC4, {5,14} },   /* 60   DO6     BORN_16   DOUT6       */
+   { {1, 5}, FUNC0, {1, 8} }    /* 61   DO7     BORN_17   DOUT7       */
+};
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+static void gpioObtainPinInit( gpioMap_t pin,
+                               int8_t *pinNamePort, int8_t *pinNamePin,
+                               int8_t *func, int8_t *gpioPort,
+                               int8_t *gpioPin )
+{
+
+   *pinNamePort = gpioPinsInit[pin].pinName.port;
+   *pinNamePin  = gpioPinsInit[pin].pinName.pin;
+   *func        = gpioPinsInit[pin].func;
+   *gpioPort    = gpioPinsInit[pin].gpio.port;
+   *gpioPin     = gpioPinsInit[pin].gpio.pin;
+}
+
+/*==================[external functions definition]==========================*/
+
+bool_t gpioInit( gpioMap_t pin, gpioInit_t config )
+{
+
+   bool_t ret_val     = 1;
+
+   int8_t pinNamePort = 0;
+   int8_t pinNamePin  = 0;
+
+   int8_t func        = 0;
+
+   int8_t gpioPort    = 0;
+   int8_t gpioPin     = 0;
+
+   gpioObtainPinInit( pin, &pinNamePort, &pinNamePin, &func,
+                      &gpioPort, &gpioPin );
+
+   switch(config) {
+
+   case GPIO_ENABLE:
+      /* Initializes GPIO */
+      Chip_GPIO_Init(LPC_GPIO_PORT);
+      break;
+
+   case GPIO_INPUT:
+      Chip_SCU_PinMux(
+         pinNamePort,
+         pinNamePin,
+         SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+         func
+      );
+      Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+
+   case GPIO_INPUT_PULLUP:
+      Chip_SCU_PinMux(
+         pinNamePort,
+         pinNamePin,
+         SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+         func
+      );
+      Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+
+   case GPIO_INPUT_PULLDOWN:
+      Chip_SCU_PinMux(
+         pinNamePort,
+         pinNamePin,
+         SCU_MODE_PULLDOWN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+         func
+      );
+      Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+   case GPIO_INPUT_PULLUP_PULLDOWN:
+      Chip_SCU_PinMux(
+         pinNamePort,
+         pinNamePin,
+         SCU_MODE_REPEATER | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS,
+         func
+      );
+      Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
+      break;
+
+   case GPIO_OUTPUT:
+      Chip_SCU_PinMux(
+         pinNamePort,
+         pinNamePin,
+         SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_INBUFF_EN,
+         func
+      );
+      Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_OUTPUT );
+      Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, 0);
+      break;
+
+   default:
+      ret_val = 0;
+      break;
+   }
+
+   return ret_val;
+
+}
+
+
+bool_t gpioWrite( gpioMap_t pin, bool_t value )
+{
+
+   bool_t ret_val     = 1;
+
+   int8_t pinNamePort = 0;
+   int8_t pinNamePin  = 0;
+
+   int8_t func        = 0;
+
+   int8_t gpioPort    = 0;
+   int8_t gpioPin     = 0;
+
+   gpioObtainPinInit( pin, &pinNamePort, &pinNamePin, &func,
+                      &gpioPort, &gpioPin );
+
+   Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, value);
+
+   return ret_val;
+}
+
+
+bool_t gpioToggle( gpioMap_t pin )
+{
+
+   return gpioWrite( pin, !gpioRead(pin) );
+}
+
+
+bool_t gpioRead( gpioMap_t pin )
+{
+
+   bool_t ret_val     = OFF;
+
+   int8_t pinNamePort = 0;
+   int8_t pinNamePin  = 0;
+
+   int8_t func        = 0;
+
+   int8_t gpioPort    = 0;
+   int8_t gpioPin     = 0;
+
+   gpioObtainPinInit( pin, &pinNamePort, &pinNamePin, &func,
+                      &gpioPort, &gpioPin );
+
+   ret_val = (bool_t) Chip_GPIO_ReadPortBit( LPC_GPIO_PORT, gpioPort, gpioPin );
+
+   return ret_val;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_i2c.c ./libs/sapi/sapi_v0.5.1/src/sapi_i2c.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_i2c.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_i2c.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,790 @@
+/* Copyright 2016, Eric Pernia
+ * Copyright 2016, Alejandro Permingeat.
+ * Copyright 2016, Eric Pernia
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Date:
+ * 2016-05-02 Eric Pernia - Only define API
+ * 2016-06-23 Alejandro Permingeat - First functional version
+ * 2016-08-07 Eric Pernia - Improve names
+ * 2016-09-10 Eric Pernia - Add unlimited buffer transfer
+ * 2016-11-20 Eric Pernia - Software I2C
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_i2c.h"
+#include "sapi_gpio.h"
+#include "sapi_delay.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+#if( I2C_SOFTWARE == 1 )
+
+static bool_t i2cSoftwareInit( i2cMap_t i2cNumber, uint32_t clockRateHz );
+
+static bool_t i2cSoftwareRead( i2cMap_t  i2cNumber,
+                               uint8_t  i2cSlaveAddress,
+                               uint8_t* dataToReadBuffer,
+                               uint16_t dataToReadBufferSize,
+                               bool_t   sendWriteStop,
+                               uint8_t* receiveDataBuffer,
+                               uint16_t receiveDataBufferSize,
+                               bool_t   sendReadStop );
+
+static bool_t i2cSoftwareWrite( i2cMap_t  i2cNumber,
+                                uint8_t  i2cSlaveAddress,
+                                uint8_t* transmitDataBuffer,
+                                uint16_t transmitDataBufferSize,
+                                bool_t   sendWriteStop );
+
+static void i2cSoftwarePinInit( gpioMap_t pin, uint8_t mode );
+static void i2cSoftwarePinWrite( gpioMap_t pin, bool_t value );
+static bool_t i2cSoftwarePinRead( gpioMap_t pin );
+
+#else
+
+static bool_t i2cHardwareInit( i2cMap_t i2cNumber, uint32_t clockRateHz );
+
+static bool_t i2cHardwareRead( i2cMap_t  i2cNumber,
+                               uint8_t  i2cSlaveAddress,
+                               uint8_t* dataToReadBuffer,
+                               uint16_t dataToReadBufferSize,
+                               bool_t   sendWriteStop,
+                               uint8_t* receiveDataBuffer,
+                               uint16_t receiveDataBufferSize,
+                               bool_t   sendReadStop );
+
+static bool_t i2cHardwareWrite( i2cMap_t  i2cNumber,
+                                uint8_t  i2cSlaveAddress,
+                                uint8_t* transmitDataBuffer,
+                                uint16_t transmitDataBufferSize,
+                                bool_t   sendWriteStop );
+
+#endif
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+#if( I2C_SOFTWARE == 1 )
+
+static bool_t i2cSoftwareInit( i2cMap_t i2cNumber, uint32_t clockRateHz )
+{
+
+   bool_t retVal = TRUE;
+
+   i2cSoftwarePinInit( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT_PULLUP );
+   i2cSoftwarePinInit( I2C_SOFTWARE_SCL_DIR, GPIO_INPUT_PULLUP );
+
+   return retVal;
+}
+
+static bool_t i2cSoftwareRead( i2cMap_t  i2cNumber,
+                               uint8_t  i2cSlaveAddress,
+                               uint8_t* dataToReadBuffer,
+                               uint16_t dataToReadBufferSize,
+                               bool_t   sendWriteStop,
+                               uint8_t* receiveDataBuffer,
+                               uint16_t receiveDataBufferSize,
+                               bool_t   sendReadStop )
+{
+
+   bool_t retVal = TRUE;
+   uint16_t i = 0;
+
+   // Check Errors
+   if( (dataToReadBuffer == NULL)  || (dataToReadBufferSize < 0) ||
+       (receiveDataBuffer == NULL) || (receiveDataBufferSize <= 0) ) {
+      return FALSE;
+   }
+
+   // First Write
+
+   if( dataToReadBufferSize > 0 ) {
+      retVal &= i2cSoftwareWrite( i2cNumber,
+                                  i2cSlaveAddress,
+                                  dataToReadBuffer,
+                                  dataToReadBufferSize,
+                                  sendWriteStop );
+   }
+
+   // Then Read
+
+   // Start condition
+   i2cSoftwareMasterWriteStart();
+   // 7 bit address + Read = 1
+   i2cSoftwareMasterWriteAddress( i2cSlaveAddress, I2C_SOFTWARE_READ );
+   // Write all data buffer
+   for( i=0; i<receiveDataBufferSize; i++ ) {
+      receiveDataBuffer[i] = i2cSoftwareMasterReadByte( TRUE ); // TRUE send ACK, FALSE not
+   }
+   // Send Stop condition
+   if( sendReadStop ) {
+      i2cSoftwareMasterWriteStop();
+   }
+   return retVal;
+}
+
+static bool_t i2cSoftwareWrite( i2cMap_t  i2cNumber,
+                                uint8_t  i2cSlaveAddress,
+                                uint8_t* transmitDataBuffer,
+                                uint16_t transmitDataBufferSize,
+                                bool_t   sendWriteStop )
+{
+
+   bool_t retVal = TRUE;
+   uint16_t i = 0;
+
+   // Check Errors
+   if( (transmitDataBuffer == NULL) || (transmitDataBufferSize <= 0) ) {
+      return FALSE;
+   }
+   // Start condition
+   i2cSoftwareMasterWriteStart();
+   // 7 bit address + Write = 0
+   i2cSoftwareMasterWriteAddress( i2cSlaveAddress, I2C_SOFTWARE_WRITE );
+   // Write all data buffer
+   for( i=0; i<transmitDataBufferSize; i++ ) {
+      i2cSoftwareMasterWriteByte( transmitDataBuffer[i] );
+   }
+   // Send Stop condition
+   if(sendWriteStop) {
+      i2cSoftwareMasterWriteStop();
+   }
+
+   return retVal;
+}
+
+
+// Point of contact with sapi_gpio module
+
+static void i2cSoftwarePinInit( uint8_t pin, uint8_t mode )
+{
+
+   if( pin == I2C_SOFTWARE_SDA_DIR ) {
+      if( mode == GPIO_OUTPUT ) {
+         //IO_DIR_PORT_PIN( OCM_DATA_PORT, OCM_DATA_PIN, IO_OUT );
+         gpioInit( I2C_SOFTWARE_SDA_DIR, GPIO_OUTPUT );
+      } else if( mode == GPIO_INPUT_PULLUP ) {
+         // Seteo de pines como ENTRADA
+         //IO_DIR_PORT_PIN( OCM_DATA_PORT, OCM_DATA_PIN, IO_IN );
+         // Seteo de pines con pull-up
+         //IO_PUD_PORT( OCM_DATA_PORT, IO_PUP );
+         gpioInit( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT );
+      }
+   } else if( pin == I2C_SOFTWARE_SCL_DIR ) {
+      if( mode == GPIO_OUTPUT ) {
+         //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_OUT );
+         gpioInit( I2C_SOFTWARE_SCL_DIR, GPIO_OUTPUT );
+      } else if( mode == GPIO_INPUT_PULLUP ) {
+         // Seteo de pines como ENTRADA
+         //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_IN );
+         // Seteo de pines con pull-up
+         //IO_PUD_PORT( OCM_CLK_PORT, IO_PUP );
+         gpioInit( I2C_SOFTWARE_SCL_DIR, GPIO_INPUT );
+      }
+   }
+
+}
+static void i2cSoftwarePinWrite( uint8_t pin, bool_t value )
+{
+
+   if( pin == I2C_SOFTWARE_SDA_OUT ) {
+      gpioWrite( I2C_SOFTWARE_SDA_OUT, value );
+   } else if( pin == I2C_SOFTWARE_SCL_OUT ) {
+      if(value) {
+         //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_IN );
+         gpioInit( I2C_SOFTWARE_SCL_DIR, GPIO_INPUT );
+         while( !gpioRead( I2C_SOFTWARE_SCL_IN ) );   // Espera hasta que el clock este en alto
+         i2cSoftwareDelay(1); // 1 clock time delay
+      } else {
+         //IO_DIR_PORT_PIN( OCM_CLK_PORT, OCM_CLK_PIN, IO_OUT );
+         //OCM_SCL = 0;                //Setea el clock a LOW
+         gpioInit( I2C_SOFTWARE_SCL_DIR, GPIO_OUTPUT );
+         gpioWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      }
+      // 1 clock time delay
+      i2cSoftwareDelay(1);
+   }
+}
+
+
+static bool_t i2cSoftwarePinRead( uint8_t pin )
+{
+
+   bool_t retVal = 0;
+
+   retVal = gpioRead( (int8_t)pin );
+   return retVal;
+}
+#else
+
+static bool_t i2cHardwareInit( i2cMap_t i2cNumber, uint32_t clockRateHz )
+{
+
+   // Configuracion de las lineas de SDA y SCL de la placa
+   Chip_SCU_I2C0PinConfig( I2C0_STANDARD_FAST_MODE );
+
+   // Inicializacion del periferico
+   Chip_I2C_Init( i2cNumber );
+   // Seleccion de velocidad del bus
+   Chip_I2C_SetClockRate( i2cNumber, clockRateHz );
+   // Configuracion para que los eventos se resuelvan por polliong
+   // (la otra opcion es por interrupcion)
+   Chip_I2C_SetMasterEventHandler( i2cNumber, Chip_I2C_EventHandlerPolling );
+
+   return TRUE;
+}
+
+static bool_t i2cHardwareRead( i2cMap_t  i2cNumber,
+                               uint8_t  i2cSlaveAddress,
+                               uint8_t* dataToReadBuffer,
+                               uint16_t dataToReadBufferSize,
+                               bool_t   sendWriteStop,
+                               uint8_t* receiveDataBuffer,
+                               uint16_t receiveDataBufferSize,
+                               bool_t   sendReadStop )
+{
+
+   //TODO: ver i2cData.options si se puede poner la condicion opcional de stop
+
+   I2CM_XFER_T i2cData;
+
+   i2cData.slaveAddr = i2cSlaveAddress;
+   i2cData.options   = 0;
+   i2cData.status    = 0;
+   i2cData.txBuff    = dataToReadBuffer;
+   i2cData.txSz      = dataToReadBufferSize;
+   i2cData.rxBuff    = receiveDataBuffer;
+   i2cData.rxSz      = receiveDataBufferSize;
+
+   if( Chip_I2CM_XferBlocking( LPC_I2C0, &i2cData ) == 0 ) {
+      return FALSE;
+   }
+
+   return TRUE;
+}
+
+static bool_t i2cHardwareWrite( i2cMap_t  i2cNumber,
+                                uint8_t  i2cSlaveAddress,
+                                uint8_t* transmitDataBuffer,
+                                uint16_t transmitDataBufferSize,
+                                bool_t   sendWriteStop )
+{
+
+   //TODO: ver i2cData.options si se puede poner la condicion opcional de stop
+
+   I2CM_XFER_T i2cData;
+
+   if( i2cNumber != I2C0 ) {
+      return FALSE;
+   }
+
+   // Prepare the i2cData register
+   i2cData.slaveAddr = i2cSlaveAddress;
+   i2cData.options   = 0;
+   i2cData.status    = 0;
+   i2cData.txBuff    = transmitDataBuffer;
+   i2cData.txSz      = transmitDataBufferSize;
+   i2cData.rxBuff    = 0;
+   i2cData.rxSz      = 0;
+
+   /* Send the i2c data */
+   if( Chip_I2CM_XferBlocking( LPC_I2C0, &i2cData ) == 0 ) {
+      return FALSE;
+   }
+
+   /* *** TEST I2C Response ***
+
+   Chip_I2CM_XferBlocking( LPC_I2C0, &i2cData );
+
+   if( i2cData.status == I2CM_STATUS_OK){
+      while(1){
+         gpioWrite( LEDB, ON );
+         delay(100);
+         gpioWrite( LEDB, OFF );
+         delay(100);
+      }
+   }
+
+   *** END - TEST I2C Response *** */
+
+   return TRUE;
+}
+
+#endif
+
+
+/*==================[external functions definition]==========================*/
+
+bool_t i2cInit( i2cMap_t i2cNumber, uint32_t clockRateHz )
+{
+
+   bool_t retVal = FALSE;
+
+   if( i2cNumber != I2C0 ) {
+      return FALSE;
+   }
+
+#if( I2C_SOFTWARE == 1 )
+   retVal = i2cSoftwareInit( i2cNumber, clockRateHz );
+#else
+   retVal = i2cHardwareInit( i2cNumber, clockRateHz );
+#endif
+
+   return retVal;
+}
+
+
+bool_t i2cRead( i2cMap_t  i2cNumber,
+                uint8_t  i2cSlaveAddress,
+                uint8_t* dataToReadBuffer,
+                uint16_t dataToReadBufferSize,
+                bool_t   sendWriteStop,
+                uint8_t* receiveDataBuffer,
+                uint16_t receiveDataBufferSize,
+                bool_t   sendReadStop )
+{
+
+   bool_t retVal = FALSE;
+
+   if( i2cNumber != I2C0 ) {
+      return FALSE;
+   }
+
+#if( I2C_SOFTWARE == 1 )
+   retVal = i2cSoftwareRead( i2cNumber,
+                             i2cSlaveAddress,
+                             dataToReadBuffer,
+                             dataToReadBufferSize,
+                             sendWriteStop,
+                             receiveDataBuffer,
+                             receiveDataBufferSize,
+                             sendReadStop );
+#else
+   retVal = i2cHardwareRead( i2cNumber,
+                             i2cSlaveAddress,
+                             dataToReadBuffer,
+                             dataToReadBufferSize,
+                             sendWriteStop,
+                             receiveDataBuffer,
+                             receiveDataBufferSize,
+                             sendReadStop );
+#endif
+
+   return retVal;
+}
+
+
+bool_t i2cWrite( i2cMap_t  i2cNumber,
+                 uint8_t  i2cSlaveAddress,
+                 uint8_t* transmitDataBuffer,
+                 uint16_t transmitDataBufferSize,
+                 bool_t   sendWriteStop )
+{
+
+   bool_t retVal = FALSE;
+
+   if( i2cNumber != I2C0 ) {
+      return FALSE;
+   }
+
+#if( I2C_SOFTWARE == 1 )
+   retVal = i2cSoftwareWrite( i2cNumber,
+                              i2cSlaveAddress,
+                              transmitDataBuffer,
+                              transmitDataBufferSize,
+                              sendWriteStop );
+#else
+   retVal = i2cHardwareWrite( i2cNumber,
+                              i2cSlaveAddress,
+                              transmitDataBuffer,
+                              transmitDataBufferSize,
+                              sendWriteStop );
+#endif
+
+   return retVal;
+}
+
+
+#if( I2C_SOFTWARE == 1 )
+// Software Master I2C
+
+void i2cSoftwareDelay( tick_t duration )
+{
+   volatile tick_t i;
+
+   duration = 13 * duration;
+   for( i=duration; i>0; i-- );
+}
+
+// Ver!!!
+// communication reset: DATA-line=1 and at least 9 SCK cycles followed by transstart
+//       _____________________________________________________         ________
+// DATA:                                                      |_______|
+//          _    _    _    _    _    _    _    _    _        ___     ___
+// SCK : __| |__| |__| |__| |__| |__| |__| |__| |__| |______|   |___|   |______
+
+
+// Generates a transmission start bit sequence
+//      ________
+// SCL:         |_
+//      _____
+// SDA:      |____
+//
+void i2cSoftwareMasterWriteStart( void )
+{
+
+   // Clock (SCL) pin HIGH
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+   // Data (SDA) pin HIGH
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, HIGH );
+   // 1 clock time delay
+   i2cSoftwareDelay(10);
+
+   // Data (SDA) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+   // 1/2 clock time delay
+   i2cSoftwareDelay(5);
+
+   // Clock (SCL) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+   // 3/10 clock time delay
+   i2cSoftwareDelay(3);
+}
+
+// Generates a transmission stop bit sequence
+//        ________
+// SCL: _|
+//           _____
+// SDA: ____|
+
+void i2cSoftwareMasterWriteStop( void )
+{
+   // Data (SDA) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+   // Clock (SCL) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+   // 1/5 clock time delay
+   i2cSoftwareDelay(2);
+
+   // Clock (SCL) pin HIGH
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+   // 1/2 clock time delay
+   i2cSoftwareDelay(5);
+
+   // Data (SDA) pin HIGH
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, HIGH );
+   // 1 clock time delay
+   i2cSoftwareDelay(10);
+}
+
+// Write data byte
+//          ___     ___     ___     ___     ___     ___     ___     ___     ___
+// SCL: ___| 1 |___| 2 |___| 3 |___| 4 |___| 5 |___| 6 |___| 7 |___| 8 |___| 9 |___
+//         _______ _______ _______ _______ _______ _______ _______ _______
+// SDA: __|   D7  |   D6  |   D5  |   D4  |   D3  |   D2  |   D1  |   D0  |__ACK?__
+//
+bool_t i2cSoftwareMasterWriteByte( uint8_t dataByte )
+{
+
+   uint8_t i;
+   static bool_t ackOrNack;
+
+   for( i=8; i>0; i-- ) {
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // Data (SDA) pin with MSB bit value of dataByte
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, (dataByte & 0x80) );
+      // 1/5 clock time delay
+      i2cSoftwareDelay(2);
+
+      // Clock (SCL) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+      // 1/2 clock time delay
+      i2cSoftwareDelay(5);
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 3/10 clock time delay
+      i2cSoftwareDelay(3);
+
+      // left shift dataByte
+      dataByte <<= 1;
+   }
+
+   // Maintain SCL LOW for 1/10 clock time delay
+   i2cSoftwareDelay(1);
+   // Configure SDA pin as input
+   i2cSoftwarePinInit( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT_PULLUP );
+   // Maintain SCL LOW for 1/10 clock time delay more
+   i2cSoftwareDelay(1);
+
+   // Clock (SCL) pin HIGH
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+   // 1/10 clock time delay
+   i2cSoftwareDelay(1);
+   // Read Data (SDA) pin for possible ACK bit
+   ackOrNack = i2cSoftwarePinRead( I2C_SOFTWARE_SDA_IN );
+   // 2/5 clock time delay
+   i2cSoftwareDelay(4);
+
+   // Clock (SCL) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+   // 1/5 clock time delay
+   i2cSoftwareDelay(2);
+   // Configure SDA pin as output. This prevent that SCL master, the
+   // microcontroller, and SCL Slave, device, both OUTPUT at the same time.
+   // This Output-Output condition can damage devices.
+   i2cSoftwarePinInit( I2C_SOFTWARE_SDA_DIR, GPIO_OUTPUT );
+   // 1/10 clock time delay
+   i2cSoftwareDelay(1);
+
+   return ackOrNack;
+}
+
+// Read data byte
+//          ___     ___     ___     ___     ___     ___     ___     ___     ___
+// SCL: ___| 1 |___| 2 |___| 3 |___| 4 |___| 5 |___| 6 |___| 7 |___| 8 |___| 9 |___
+//         _______ _______ _______ _______ _______ _______ _______ _______
+// SDA: __|   D7  |   D6  |   D5  |   D4  |   D3  |   D2  |   D1  |   D0  |__ACK?__
+//
+uint8_t i2cSoftwareMasterReadByte( bool_t ack )
+{
+
+   uint8_t i, receivedData = 0;
+   bool_t receivedBit = 0;
+
+   // Configure SDA pin as input
+   i2cSoftwarePinInit( I2C_SOFTWARE_SDA_DIR, GPIO_INPUT_PULLUP );
+
+   for( i=8; i>0; i-- ) {
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 1/5 clock time delay
+      i2cSoftwareDelay(2);
+
+      //do{
+      // Clock (SCL) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+      //}while( SCL_IN == 0 );    // wait for any SCL clock stretching
+      // 1/10 clock time delay
+      i2cSoftwareDelay(1);
+      // Read Data (SDA) pin
+      receivedBit = i2cSoftwarePinRead( I2C_SOFTWARE_SDA_IN );
+      // 2/5 clock time delay
+      i2cSoftwareDelay(4);
+
+      // Shift left receivedData
+      receivedData <<= 1;
+
+      if( receivedBit ) {
+         receivedData |= 0x01;
+      }
+
+      // Clock (SCL) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+      // 3/10 clock time delay
+      i2cSoftwareDelay(3);
+   }
+
+   // Maintain SCL LOW for 1/10 clock time delay
+   i2cSoftwareDelay(1);
+   // Configure SDA pin as output
+   i2cSoftwarePinInit( I2C_SOFTWARE_SDA_DIR, GPIO_OUTPUT );
+
+   // send (N)ACK bit (ACK=LOW, NACK=HIGH)
+   if( ack ) {
+      // Data (SDA) pin LOW
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+   } else {
+      // Data (SDA) pin HIGH
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, HIGH );
+   }
+   // Maintain SCL LOW for 1/10 clock time delay more
+   i2cSoftwareDelay(1);
+
+   // Clock (SCL) pin HIGH
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, HIGH );
+   // 1/2 clock time delay
+   i2cSoftwareDelay(5);
+
+   // Clock (SCL) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, LOW );
+   // 1/10 clock time delay
+   i2cSoftwareDelay(1);
+   // Data (SDA) pin LOW
+   i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, LOW );
+   // 1/5 clock time delay
+   i2cSoftwareDelay(2);
+
+   return receivedData;
+}
+/* That's almost it for simple I2C communications, but there is one more
+ * complication. When the master is reading from the slave, its the slave that
+ * places the data on the SDA line, but its the master that controls the clock.
+ * What if the slave is not ready to send the data! With devices such as
+ * EEPROMs this is not a problem, but when the slave device is actually a
+ * microprocessor with other things to do, it can be a problem. The
+ * microprocessor on the slave device will need to go to an interrupt routine,
+ * save its working registers, find out what address the master wants to read
+ * from, get the data and place it in its transmission register. This can take
+ * many uS to happen, meanwhile the master is blissfully sending out clock
+ * pulses on the SCL line that the slave cannot respond to. The I2C protocol
+ * provides a solution to this: the slave is allowed to hold the SCL line low!
+ * This is called clock stretching. When the slave gets the read command from
+ * the master it holds the clock line low. The microprocessor then gets the
+ * requested data, places it in the transmission register and releases the
+ * clock line allowing the pull-up resistor to finally pull it high. From the
+ * masters point of view, it will issue the first clock pulse of the read by
+ * making SCL high and then check to see if it really has gone high. If its
+ * still low then its the slave that holding it low and the master should wait
+ * until it goes high before continuing. Luckily the hardware I2C ports on
+ * most microprocessors will handle this automatically.
+ *
+ * Sometimes however, the master I2C is just a collection of subroutines and
+ * there are a few implementations out there that completely ignore clock
+ * stretching. They work with things like EEPROM's but not with microprocessor
+ * slaves that use clock stretching. The result is that erroneous data is read
+ * from the slave. Beware!
+ *
+ * http://www.robot-electronics.co.uk/i2c-tutorial
+ */
+
+
+// Write 7 bit address + R or W bit
+//              ___
+// SDA: _______|
+//          _______
+// SCL: ___|
+//
+bool_t i2cSoftwareMasterWriteAddress( uint8_t i2cSlaveAddress,
+                                      I2C_Software_rw_t readOrWrite )
+{
+
+   bool_t ackOrNack = FALSE;
+
+   if( readOrWrite == I2C_SOFTWARE_WRITE ) {
+      // 7 bit address + Write = 0
+      i2cSlaveAddress <<= 1;
+      ackOrNack = i2cSoftwareMasterWriteByte( i2cSlaveAddress );
+
+   } else if( readOrWrite == I2C_SOFTWARE_READ ) {
+      // 7 bit address + Read = 1
+      i2cSlaveAddress <<= 1;
+      i2cSlaveAddress |= 0x01;
+      ackOrNack = i2cSoftwareMasterWriteByte( i2cSlaveAddress );
+   }
+
+   return ackOrNack;
+}
+#endif
+
+
+#if( SOFTWARE_I2C_DEBUG == 1 )
+
+/*
+ * Conexión:
+ *
+ * Se debe conectar un led al pin elegido como SCL con una R de 470ohm.
+ * Otro led al pin elegido como SDA con una R de 470ohm.
+ * Una R de pull-up de 4K7 entre VDD=+3.3V y SDA.
+ * Un pulsador entre GND y SDA.
+ *
+ * Funcionamiento:
+ *
+ * Cada 10 segundos toglea el modo del pin SDA entre Input y Output.
+ * Mientras SDA es input escribe el valor del pulsador en el pin SCL.
+ * Cada 500ms se toglea una variable llamada clockStatus.
+ * Mientras el pin SDA es Output se escribe en el led conectado a SDA
+ * el valor de la variable clockStatus.
+ */
+
+//#include "sapi_delay.h"
+
+// Test vars
+bool_t clockStatus = FALSE;
+delay_t clockDelay;
+bool_t direction = FALSE;
+delay_t delayDir;
+
+void i2cSoftwareMasterPinTestInit( void )
+{
+   delayInit( &clockDelay, 500 );
+   delayInit( &delayDir, 10000 );
+}
+
+void i2cSoftwareMasterPinTest( void )
+{
+
+   if( delayRead( &delayDir ) ) {
+      if( direction ) {
+         direction = FALSE;
+      } else {
+         direction = TRUE;
+      }
+//          I2C_SOFTWARE_SDA_DIR = direction;
+   }
+
+   if( delayRead( &clockDelay ) ) {
+      if( clockStatus ) {
+         clockStatus = FALSE;
+      } else {
+         clockStatus = TRUE;
+      }
+      //I2C_SOFTWARE_SCL_OUT = clockStatus;
+   }
+
+   if( direction ) { // Input
+      //I2C_SOFTWARE_SCL_OUT = I2C_SOFTWARE_SDA_IN;
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SCL_OUT, I2C_SOFTWARE_SDA_IN );
+   } else {         // Output
+      //I2C_SOFTWARE_SDA_OUT = clockStatus;
+      i2cSoftwarePinWrite( I2C_SOFTWARE_SDA_OUT, clockStatus );
+   }
+}
+#endif
+
+/*==================[ISR external functions definition]======================*/
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_imu_mpu9250.c ./libs/sapi/sapi_v0.5.1/src/sapi_imu_mpu9250.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_imu_mpu9250.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_imu_mpu9250.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,614 @@
+/* Copyright 2017 Bolder Flight Systems <brian.taylor@bolderflight.com>.
+ * Copyright 2018, Sergio Renato De Jesus Melean <sergiordj@gmail.com>.
+ * Copyright 2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+ 
+/* Date: 2018-07-06 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_imu_mpu9250.h"   /* <= sAPI HMC5883L header */
+#include "sapi_i2c.h"           /* <= sAPI I2C header */
+#include "sapi_delay.h"         /* <= sAPI Delay header */
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+static int8_t mpu9250InitializeControlStructure( void );
+static int8_t mpu9250WriteRegister( uint8_t subAddress, uint8_t data );
+static int8_t mpu9250ReadRegisters( uint8_t subAddress, uint8_t count );
+static int8_t mpu9250WriteAK8963Register( uint8_t subAddress, uint8_t data );
+static int8_t mpu9250WhoAmI( void );
+static int8_t mpu9250WhoAmIAK8963( void );
+static int8_t mpu9250ReadAK8963Registers( uint8_t subAddress, uint8_t count );
+static int8_t mpu9250CalibrateGyro( void );
+static int8_t mpu9250SetGyroRange( MPU9250_GyroRange_t range );
+static int8_t mpu9250SetDlpfBandwidth( MPU9250_DlpfBandwidth_t bandwidth );
+static int8_t mpu9250SetSrd( uint8_t srd );
+
+/*==================[internal data definition]===============================*/
+
+//MPU control structure
+static MPU9250_control_t control;
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+static int8_t mpu9250InitializeControlStructure( void )
+{
+	control._tempScale = 333.87f;
+	control._tempOffset = 21.0f;
+	control._numSamples = 100;
+	control._axs = 1.0f;
+	control._ays = 1.0f;
+	control._azs = 1.0f;
+	control._maxCounts = 1000;
+	control._deltaThresh = 0.3f;
+	control._coeff = 8;
+	control._hxs = 1.0f;
+	control._hys = 1.0f;
+	control._hzs = 1.0f;
+	control.tX[0] = 0;
+	control.tX[1] = 1;
+	control.tX[2] = 0;
+	control.tY[0] = 1;
+	control.tY[1] = 0;
+	control.tY[2] = 0;
+	control.tZ[0] = 0;
+	control.tZ[1] = 0;
+	control.tZ[2] = -1;
+}
+
+static int8_t mpu9250WriteRegister( uint8_t subAddress, uint8_t data )
+{
+	uint8_t transmitDataBuffer[2];
+	transmitDataBuffer[0] = subAddress;
+	transmitDataBuffer[1] = data;
+	i2cWrite(I2C0, control.address, transmitDataBuffer, 2, TRUE);
+
+	delay(10);
+
+	/* read back the register */
+	mpu9250ReadRegisters(subAddress,1);
+	/* check the read back register against the written register */
+	if(control._buffer[0] == data) {
+      return 1;
+	}
+	else{
+      return -1;
+	}
+}
+
+static int8_t mpu9250ReadRegisters( uint8_t subAddress, uint8_t count )
+{
+	if( i2cRead( I2C0,control.address,&subAddress,1,TRUE,control._buffer,count,TRUE) ){
+		return 1;
+	} else {
+		return -1;
+	}
+}
+
+static int8_t mpu9250WriteAK8963Register( uint8_t subAddress, uint8_t data )
+{
+	// set slave 0 to the AK8963 and set for write
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_ADDR, MPU9250_AK8963_I2C_ADDR) < 0) {
+		return -1;
+	}
+	// set the register to the desired AK8963 sub address
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_REG, subAddress) < 0) {
+		return -2;
+	}
+	// store the data for write
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_DO, data) < 0) {
+		return -3;
+	}
+	// enable I2C and send 1 byte
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_CTRL, MPU9250_I2C_SLV0_EN | (uint8_t)1) < 0) {
+		return -4;
+	}
+	// read the register and confirm
+	if (mpu9250ReadAK8963Registers(subAddress,1) < 0) {
+		return -5;
+	}
+	if(control._buffer[0] == data) {
+		return 1;
+	} else{
+		return -6;
+	}
+}
+
+static int8_t mpu9250WhoAmI( void )
+{
+	// read the WHO AM I register
+	if (mpu9250ReadRegisters(MPU9250_WHO_AM_I,1) < 0) {
+		return -1;
+	}
+	// return the register value
+	return control._buffer[0];
+}
+
+static int8_t mpu9250WhoAmIAK8963( void )
+{
+	// read the WHO AM I register
+	if (mpu9250ReadAK8963Registers(MPU9250_AK8963_WHO_AM_I,1) < 0) {
+		return -1;
+	}
+	// return the register value
+	return control._buffer[0];
+}
+
+static int8_t mpu9250ReadAK8963Registers( uint8_t subAddress, uint8_t count )
+{
+	// set slave 0 to the AK8963 and set for read
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_ADDR, MPU9250_AK8963_I2C_ADDR | MPU9250_I2C_READ_FLAG) < 0) {
+		return -1;
+	}
+	// set the register to the desired AK8963 sub address
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_REG, subAddress) < 0) {
+		return -2;
+	}
+	// enable I2C and request the bytes
+	if (mpu9250WriteRegister( MPU9250_I2C_SLV0_CTRL, MPU9250_I2C_SLV0_EN | count) < 0) {
+		return -3;
+	}
+	delay(1); // takes some time for these registers to fill
+	// read the bytes off the MPU9250 EXT_SENS_DATA registers
+	control._status = mpu9250ReadRegisters(MPU9250_EXT_SENS_DATA_00,count);
+	return control._status;
+}
+
+static int8_t mpu9250CalibrateGyro( void )
+{
+	// set the range, bandwidth, and srd
+	if (mpu9250SetGyroRange(MPU9250_GYRO_RANGE_250DPS) < 0) {
+		return -1;
+	}
+	if (mpu9250SetDlpfBandwidth(MPU9250_DLPF_BANDWIDTH_20HZ) < 0) {
+		return -2;
+	}
+	if (mpu9250SetSrd(19) < 0) {
+		return -3;
+	}
+
+	// take samples and find bias
+	control._gxbD = 0;
+	control._gybD = 0;
+	control._gzbD = 0;
+	for (uint8_t i=0; i < control._numSamples; i++) {
+		mpu9250Read();
+		control._gxbD += ((mpu9250GetGyroX_rads() + control._gxb)/control._numSamples);
+		control._gybD += ((mpu9250GetGyroY_rads() + control._gyb)/control._numSamples);
+		control._gzbD += ((mpu9250GetGyroZ_rads() + control._gzb)/control._numSamples);
+		delay(20);
+	}
+	control._gxb = (float)control._gxbD;
+	control._gyb = (float)control._gybD;
+	control._gzb = (float)control._gzbD;
+
+	// set the range, bandwidth, and srd back to what they were
+	if (mpu9250SetGyroRange(control._gyroRange) < 0) {
+		return -4;
+	}
+	if (mpu9250SetDlpfBandwidth(control._bandwidth) < 0) {
+		return -5;
+	}
+	if (mpu9250SetSrd(control._srd) < 0) {
+		return -6;
+	}
+	return 1;
+}
+
+static int8_t mpu9250SetGyroRange( MPU9250_GyroRange_t range )
+{
+	switch(range) {
+		case MPU9250_GYRO_RANGE_250DPS: {
+		  // setting the gyro range to 250DPS
+		  if(mpu9250WriteRegister(MPU9250_GYRO_CONFIG, MPU9250_GYRO_FS_SEL_250DPS) < 0){
+			return -1;
+		  }
+        // setting the gyro scale to 250DPS
+		  control._gyroScale = 250.0f/32767.5f * MPU9250_D2R; 
+		  break;
+		}
+		case MPU9250_GYRO_RANGE_500DPS: {
+		  // setting the gyro range to 500DPS
+		  if(mpu9250WriteRegister(MPU9250_GYRO_CONFIG, MPU9250_GYRO_FS_SEL_500DPS) < 0){
+			return -1;
+		  }
+        // setting the gyro scale to 500DPS
+		  control._gyroScale = 500.0f/32767.5f * MPU9250_D2R; 
+		  break;
+		}
+		case MPU9250_GYRO_RANGE_1000DPS: {
+		  // setting the gyro range to 1000DPS
+		  if(mpu9250WriteRegister(MPU9250_GYRO_CONFIG, MPU9250_GYRO_FS_SEL_1000DPS) < 0){
+			return -1;
+		  }
+        // setting the gyro scale to 1000DPS
+		  control._gyroScale = 1000.0f/32767.5f * MPU9250_D2R; 
+		  break;
+		}
+		case MPU9250_GYRO_RANGE_2000DPS: {
+		  // setting the gyro range to 2000DPS
+		  if(mpu9250WriteRegister(MPU9250_GYRO_CONFIG, MPU9250_GYRO_FS_SEL_2000DPS) < 0){
+			return -1;
+		  }
+        // setting the gyro scale to 2000DPS
+		  control._gyroScale = 2000.0f/32767.5f * MPU9250_D2R; 
+		  break;
+		}
+	}
+	control._gyroRange = range;
+	return 1;
+}
+
+static int8_t mpu9250SetDlpfBandwidth( MPU9250_DlpfBandwidth_t bandwidth )
+{
+	switch (bandwidth) {
+		case MPU9250_DLPF_BANDWIDTH_184HZ: {
+         // setting accel bandwidth to 184Hz
+			if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_184) < 0) { 
+				return -1;
+			}
+         // setting gyro bandwidth to 184Hz
+			if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_184) < 0) { 
+				return -2;
+			}
+			break;
+		}
+		case MPU9250_DLPF_BANDWIDTH_92HZ: {
+         // setting accel bandwidth to 92Hz
+			if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_92) < 0) { 
+				return -1;
+			}
+         // setting gyro bandwidth to 92Hz
+			if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_92) < 0) { 
+				return -2;
+			}
+			break;
+		}
+		case MPU9250_DLPF_BANDWIDTH_41HZ: {
+         // setting accel bandwidth to 41Hz
+			if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_41) < 0) { 
+				return -1;
+			}
+         // setting gyro bandwidth to 41Hz
+			if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_41) < 0) { 
+				return -2;
+			}
+			break;
+		}
+		case MPU9250_DLPF_BANDWIDTH_20HZ: {
+         // setting accel bandwidth to 20Hz
+			if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_20) < 0) { 
+				return -1;
+			}
+         // setting gyro bandwidth to 20Hz
+			if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_20) < 0) { 
+				return -2;
+			}
+			break;
+		}
+		case MPU9250_DLPF_BANDWIDTH_10HZ: {
+         // setting accel bandwidth to 10Hz
+			if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_10) < 0) { 
+				return -1;
+			}
+         // setting gyro bandwidth to 10Hz
+			if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_10) < 0) { 
+				return -2;
+			}
+			break;
+		}
+		case MPU9250_DLPF_BANDWIDTH_5HZ: {
+         // setting accel bandwidth to 5Hz
+			if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_5) < 0) { 
+				return -1;
+			}
+         // setting gyro bandwidth to 5Hz
+			if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_5) < 0) { 
+				return -2;
+			}
+			break;
+		}
+	}
+	control._bandwidth = bandwidth;
+	return 1;
+}
+
+static int8_t mpu9250SetSrd( uint8_t srd )
+{
+	/* setting the sample rate divider to 19 to facilitate setting up 
+      magnetometer */
+   // setting the sample rate divider
+	if (mpu9250WriteRegister(MPU9250_SMPDIV, 19) < 0) {
+		return -1;
+	}
+	if (srd > 9) {
+		// set AK8963 to Power Down
+		if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_PWR_DOWN) < 0) {
+			return -2;
+		}
+		delay(100); // long wait between AK8963 mode changes
+		// set AK8963 to 16 bit resolution, 8 Hz update rate
+		if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_CNT_MEAS1) < 0) {
+			return -3;
+		}
+		delay(100); // long wait between AK8963 mode changes
+		// instruct the MPU9250 to get 7 bytes of data from the AK8963 at the sample rate
+		mpu9250ReadAK8963Registers(MPU9250_AK8963_HXL, 7);
+	} else {
+		// set AK8963 to Power Down
+		if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_PWR_DOWN) < 0) {
+			return -2;
+		}
+		delay(100); // long wait between AK8963 mode changes
+		// set AK8963 to 16 bit resolution, 100 Hz update rate
+		if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_CNT_MEAS2) < 0) {
+			return -3;
+		}
+		delay(100); // long wait between AK8963 mode changes
+		// instruct the MPU9250 to get 7 bytes of data from the AK8963 at the sample rate
+		mpu9250ReadAK8963Registers(MPU9250_AK8963_HXL, 7);
+	}
+	/* setting the sample rate divider */
+	if (mpu9250WriteRegister(MPU9250_SMPDIV, srd) < 0) { // setting the sample rate divider
+		return -4;
+	}
+	control._srd = srd;
+	return 1;
+}
+
+/*==================[external functions definition]==========================*/
+
+//Initialize MPU9250 (TODO: include SPI communication)
+int8_t mpu9250Init( MPU9250_address_t address )
+{
+	mpu9250InitializeControlStructure();
+
+	control.address = address;
+
+	// using I2C for communication
+	// starting the I2C bus
+	i2cInit(I2C0, MPU9250_I2C_RATE);
+
+	// select clock source to gyro
+	if (mpu9250WriteRegister(MPU9250_PWR_MGMNT_1, MPU9250_CLOCK_SEL_PLL) < 0) {
+		return -1;
+	}
+	// enable I2C master mode
+	if (mpu9250WriteRegister(MPU9250_USER_CTRL, MPU9250_I2C_MST_EN) < 0) {
+		return -2;
+	}
+	// set the I2C bus speed to 400 kHz
+	if (mpu9250WriteRegister(MPU9250_I2C_MST_CTRL, MPU9250_I2C_MST_CLK) < 0) {
+		return -3;
+	}
+	// set AK8963 to Power Down
+	mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_PWR_DOWN);
+	// reset the MPU9250
+	mpu9250WriteRegister(MPU9250_PWR_MGMNT_1, MPU9250_PWR_RESET);
+	// wait for MPU-9250 to come back up
+	delay(1);
+	// reset the AK8963
+	mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL2, MPU9250_AK8963_RESET);
+	// select clock source to gyro
+	if (mpu9250WriteRegister(MPU9250_PWR_MGMNT_1, MPU9250_CLOCK_SEL_PLL) < 0) {
+		return -4;
+	}
+	// check the WHO AM I byte, expected value is 0x71 (decimal 113) or 0x73 (decimal 115)
+	if ((mpu9250WhoAmI() != 113) && (mpu9250WhoAmI() != 115)) {
+		return -5;
+	}
+	// enable accelerometer and gyro
+	if (mpu9250WriteRegister(MPU9250_PWR_MGMNT_2, MPU9250_SEN_ENABLE) < 0) {
+		return -6;
+	}
+	// setting accel range to 16G as default
+	if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG, MPU9250_ACCEL_FS_SEL_16G) < 0) {
+		return -7;
+	}
+	control._accelScale = MPU9250_G * 16.0f / 32767.5f; // setting the accel scale to 16G
+	control._accelRange = MPU9250_ACCEL_RANGE_16G;
+	// setting the gyro range to 2000DPS as default
+	if (mpu9250WriteRegister(MPU9250_GYRO_CONFIG, MPU9250_GYRO_FS_SEL_2000DPS) < 0) {
+		return -8;
+	}
+   // setting the gyro scale to 2000DPS
+	control._gyroScale = 2000.0f / 32767.5f * MPU9250_D2R; 
+	control._gyroRange = MPU9250_GYRO_RANGE_2000DPS;
+	// setting bandwidth to 184Hz as default
+	if (mpu9250WriteRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_DLPF_184) < 0) {
+		return -9;
+	}
+   // setting gyro bandwidth to 184Hz
+	if (mpu9250WriteRegister(MPU9250_CONFIG, MPU9250_GYRO_DLPF_184) < 0) { 
+		return -10;
+	}
+	control._bandwidth = MPU9250_DLPF_BANDWIDTH_184HZ;
+	// setting the sample rate divider to 0 as default
+	if (mpu9250WriteRegister(MPU9250_SMPDIV, 0x00) < 0) {
+		return -11;
+	}
+	control._srd = 0;
+	// enable I2C master mode
+	if (mpu9250WriteRegister(MPU9250_USER_CTRL, MPU9250_I2C_MST_EN) < 0) {
+		return -12;
+	}
+	// set the I2C bus speed to 400 kHz
+	if (mpu9250WriteRegister(MPU9250_I2C_MST_CTRL, MPU9250_I2C_MST_CLK) < 0) {
+		return -13;
+	}
+	// check AK8963 WHO AM I register, expected value is 0x48 (decimal 72)
+	if (mpu9250WhoAmIAK8963() != 72) {
+		return -14;
+	}
+	/* get the magnetometer calibration */
+	// set AK8963 to Power Down
+	if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_PWR_DOWN) < 0) {
+		return -15;
+	}
+	delay(100); // long wait between AK8963 mode changes
+	// set AK8963 to FUSE ROM access
+	if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_FUSE_ROM) < 0) {
+		return -16;
+	}
+	delay(100); // long wait between AK8963 mode changes
+	// read the AK8963 ASA registers and compute magnetometer scale factors
+	mpu9250ReadAK8963Registers(MPU9250_AK8963_ASA, 3);
+	control._magScaleX = ((((float) control._buffer[0]) - 128.0f) / (256.0f) + 1.0f) * 4912.0f
+			/ 32760.0f; // micro Tesla
+	control._magScaleY = ((((float) control._buffer[1]) - 128.0f) / (256.0f) + 1.0f) * 4912.0f
+			/ 32760.0f; // micro Tesla
+	control._magScaleZ = ((((float) control._buffer[2]) - 128.0f) / (256.0f) + 1.0f) * 4912.0f
+			/ 32760.0f; // micro Tesla
+	// set AK8963 to Power Down
+	if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_PWR_DOWN) < 0) {
+		return -17;
+	}
+	delay(100); // long wait between AK8963 mode changes
+	// set AK8963 to 16 bit resolution, 100 Hz update rate
+	if (mpu9250WriteAK8963Register(MPU9250_AK8963_CNTL1, MPU9250_AK8963_CNT_MEAS2) < 0) {
+		return -18;
+	}
+	delay(100); // long wait between AK8963 mode changes
+	// select clock source to gyro
+	if (mpu9250WriteRegister(MPU9250_PWR_MGMNT_1, MPU9250_CLOCK_SEL_PLL) < 0) {
+		return -19;
+	}
+	// instruct the MPU9250 to get 7 bytes of data from the AK8963 at the sample rate
+	mpu9250ReadAK8963Registers(MPU9250_AK8963_HXL, 7);
+	// estimate gyro bias
+	if (mpu9250CalibrateGyro() < 0) {
+		return -20;
+	}
+	// successful init, return 1
+	return 1;
+}
+
+//Read sensor registers and store data at control structure
+bool_t mpu9250Read(void)
+{
+	// grab the data from the MPU9250
+	if( !mpu9250ReadRegisters(MPU9250_ACCEL_OUT, 21) ){
+		return 0;
+	}
+	// combine into 16 bit values
+	control._axcounts = (((int16_t)control._buffer[0]) << 8)  | control._buffer[1];
+	control._aycounts = (((int16_t)control._buffer[2]) << 8)  | control._buffer[3];
+	control._azcounts = (((int16_t)control._buffer[4]) << 8)  | control._buffer[5];
+	control._tcounts  = (((int16_t)control._buffer[6]) << 8)  | control._buffer[7];
+	control._gxcounts = (((int16_t)control._buffer[8]) << 8)  | control._buffer[9];
+	control._gycounts = (((int16_t)control._buffer[10]) << 8) | control._buffer[11];
+	control._gzcounts = (((int16_t)control._buffer[12]) << 8) | control._buffer[13];
+	control._hxcounts = (((int16_t)control._buffer[15]) << 8) | control._buffer[14];
+	control._hycounts = (((int16_t)control._buffer[17]) << 8) | control._buffer[16];
+	control._hzcounts = (((int16_t)control._buffer[19]) << 8) | control._buffer[18];
+	// transform and convert to float values
+	control._ax = (((float)(control.tX[0]*control._axcounts + control.tX[1]*control._aycounts + control.tX[2]*control._azcounts) * control._accelScale) - control._axb)*control._axs;
+	control._ay = (((float)(control.tY[0]*control._axcounts + control.tY[1]*control._aycounts + control.tY[2]*control._azcounts) * control._accelScale) - control._ayb)*control._ays;
+	control._az = (((float)(control.tZ[0]*control._axcounts + control.tZ[1]*control._aycounts + control.tZ[2]*control._azcounts) * control._accelScale) - control._azb)*control._azs;
+	control._gx = ((float) (control.tX[0]*control._gxcounts + control.tX[1]*control._gycounts + control.tX[2]*control._gzcounts) * control._gyroScale) -  control._gxb;
+	control._gy = ((float) (control.tY[0]*control._gxcounts + control.tY[1]*control._gycounts + control.tY[2]*control._gzcounts) * control._gyroScale) -  control._gyb;
+	control._gz = ((float) (control.tZ[0]*control._gxcounts + control.tZ[1]*control._gycounts + control.tZ[2]*control._gzcounts) * control._gyroScale) -  control._gzb;
+	control._hx = (((float)(control._hxcounts) * control._magScaleX) - control._hxb)*control._hxs;
+	control._hy = (((float)(control._hycounts) * control._magScaleY) - control._hyb)*control._hys;
+	control._hz = (((float)(control._hzcounts) * control._magScaleZ) - control._hzb)*control._hzs;
+	control._t = ((((float) control._tcounts)  - control._tempOffset)/ control._tempScale) + control._tempOffset;
+	return 1;
+}
+
+// Returns the accelerometer measurement in the x direction, m/s/s
+float mpu9250GetAccelX_mss( void )
+{
+	return control._ax;
+}
+
+// Returns the accelerometer measurement in the y direction, m/s/s
+float mpu9250GetAccelY_mss( void )
+{
+	return control._ay;
+}
+
+// Returns the accelerometer measurement in the z direction, m/s/s
+float mpu9250GetAccelZ_mss( void )
+{
+	return control._az;
+}
+
+// Returns the gyroscope measurement in the x direction, rad/s
+float mpu9250GetGyroX_rads( void )
+{
+	return control._gx;
+}
+
+// Returns the gyroscope measurement in the y direction, rad/s
+float mpu9250GetGyroY_rads( void )
+{
+	return control._gy;
+}
+
+// Returns the gyroscope measurement in the z direction, rad/s
+float mpu9250GetGyroZ_rads( void )
+{
+	return control._gz;
+}
+
+// Returns the magnetometer measurement in the x direction, uT
+float mpu9250GetMagX_uT( void )
+{
+  return control._hx;
+}
+
+// Returns the magnetometer measurement in the y direction, uT
+float mpu9250GetMagY_uT( void )
+{
+  return control._hy;
+}
+
+// Returns the magnetometer measurement in the z direction, uT
+float mpu9250GetMagZ_uT( void )
+{
+  return control._hz;
+}
+
+// Returns the die temperature, C
+float mpu9250GetTemperature_C( void )
+{
+  return control._t;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_keypad.c ./libs/sapi/sapi_v0.5.1/src/sapi_keypad.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_keypad.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_keypad.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,160 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Date: 2016-07-28
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_keypad.h"       /* <= own header */
+
+#include "sapi_delay.h"               /* <= delay header */
+#include "sapi_gpio.h"                /* <= GPIO header */
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+
+/* Configure keypad pins */
+bool_t keypadInit( keypad_t* keypad,
+                   gpioMap_t* keypadRowPins, uint8_t keypadRowSize,
+                   gpioMap_t* keypadColPins, uint8_t keypadColSize )
+{
+
+   bool_t retVal = TRUE;
+
+   uint8_t i = 0;
+
+   // Check if values are not invalid
+   if( keypadRowPins == NULL || keypadColPins == NULL ||
+       keypadRowSize <= 0 || keypadColSize <= 0  ) {
+      retVal = FALSE;
+   }
+
+   // Configure keypad instance
+   keypad->keypadRowPins = keypadRowPins;
+   keypad->keypadRowSize = keypadRowSize;
+   keypad->keypadColPins = keypadColPins;
+   keypad->keypadColSize = keypadColSize;
+
+   // Configure Rows as Outputs
+   for( i=0; i<keypadRowSize; i++ ) {
+      gpioInit( keypad->keypadRowPins[i], GPIO_OUTPUT );
+   }
+
+   // Configure Columns as Inputs with pull-up resistors enable
+   for( i=0; i<keypadColSize; i++ ) {
+      gpioInit( keypad->keypadColPins[i], GPIO_INPUT_PULLUP );
+   }
+
+   return retVal;
+}
+
+
+/* Return TRUE if any key is pressed or FALSE (0) in other cases.
+ * If exist key pressed write pressed key on key variable */
+bool_t keypadRead( keypad_t* keypad, uint16_t* key )
+{
+
+   bool_t retVal = FALSE;
+
+   uint8_t r = 0; // Rows
+   uint8_t c = 0; // Columns
+
+   // Put all Rows in LOW state
+   for( r=0; r<keypad->keypadRowSize; r++ ) {
+      gpioWrite( keypad->keypadRowPins[r], LOW );
+   }
+
+   // Check all Columns to search if any key is pressed
+   for( c=0; c<keypad->keypadColSize; c++ ) {
+
+      // If reads a LOW state in a column then that key may be pressed
+      if( !gpioRead( keypad->keypadColPins[c] ) ) {
+
+         delay( 50 ); // Debounce 50 ms
+
+         // Put all Rows in HIGH state except first one
+         for( r=1; r<keypad->keypadRowSize; r++ ) {
+            gpioWrite( keypad->keypadRowPins[r], HIGH );
+         }
+
+         // Search what key are pressed
+         for( r=0; r<keypad->keypadRowSize; r++ ) {
+
+            // Put the Row[r-1] in HIGH state and the Row[r] in LOW state
+            if( r>0 ) { // Prevents negative index in array
+               gpioWrite( keypad->keypadRowPins[r-1], HIGH );
+            }
+            gpioWrite( keypad->keypadRowPins[r], LOW );
+
+            // Check Columns[c] at Row[r] to search if the key is pressed
+            // if that key is pressed (LOW state) then retuns the key
+            if( !gpioRead( keypad->keypadColPins[c] ) ) {
+               *key = (uint16_t)r * (uint16_t)(keypad->keypadColSize) + (uint16_t)c;
+               retVal = TRUE;
+               return retVal;
+            }
+         }
+
+      }
+   }
+
+   /*
+      4 rows * 5 columns Keypad
+
+         c0 c1 c2 c3 c4
+      r0  0  1  2  3  4
+      r1  5  6  7  8  9    Press r[i] c[j] => (i) * amountOfColumns + (j)
+      r2 10 11 12 13 14
+      r3 15 16 17 18 19
+   */
+
+   // if no key are pressed then retun FALSE
+   return retVal;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_lcd.c ./libs/sapi/sapi_v0.5.1/src/sapi_lcd.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_lcd.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_lcd.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,176 @@
+/* Copyright 2015-2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-12-05 */
+
+/*==================[inlcusiones]============================================*/
+
+#include "sapi_lcd.h"    // <= su propio archivo de cabecera (opcional)
+
+/*==================[definiciones y macros]==================================*/
+
+/*==================[definiciones de datos internos]=========================*/
+
+/*==================[definiciones de datos externos]=========================*/
+
+/*==================[declaraciones de funciones internas]====================*/
+
+static void lcdEnablePulse( void );
+
+static void lcdSendNibble( uint8_t nibble );
+
+/*==================[declaraciones de funciones externas]====================*/
+
+/*==================[definiciones de funciones internas]=====================*/
+
+static void lcdEnablePulse( void )
+{
+   lcdPinWrite( LCD_HD44780_EN, ON );     // EN = 1 for H-to-L pulse
+   lcdDelay_us( LCD_EN_PULSE_WAIT_US );   // Wait to make EN wider
+   lcdPinWrite( LCD_HD44780_EN, OFF );    // EN = 0 for H-to-L pulse
+}
+
+static void lcdSendNibble( uint8_t nibble )
+{
+   lcdPinWrite( LCD_HD44780_D7, ( nibble & 0x80 ) );
+   lcdPinWrite( LCD_HD44780_D6, ( nibble & 0x40 ) );
+   lcdPinWrite( LCD_HD44780_D5, ( nibble & 0x20 ) );
+   lcdPinWrite( LCD_HD44780_D4, ( nibble & 0x10 ) );
+}
+
+/*==================[definiciones de funciones externas]=====================*/
+
+void lcdCommand( uint8_t cmd )
+{
+   lcdSendNibble( cmd & 0xF0 );          // Send high nibble to D7-D4
+
+   lcdPinWrite( LCD_HD44780_RS, OFF );   // RS = 0 for command
+   lcdPinWrite( LCD_HD44780_RW, OFF );   // RW = 0 for write
+
+   lcdEnablePulse();
+   lcdDelay_us( LCD_LOW_WAIT_US );       // Wait
+
+   lcdSendNibble( cmd << 4 );            // Send low nibble to D7-D4
+   lcdEnablePulse();
+}
+
+void lcdData( uint8_t data )
+{
+   lcdSendNibble( data & 0xF0 );         // Send high nibble to D7-D4
+
+   lcdPinWrite( LCD_HD44780_RS, ON );    // RS = 1 for data
+   lcdPinWrite( LCD_HD44780_RW, OFF );   // RW = 0 for write
+
+   lcdEnablePulse();
+
+   lcdSendNibble( data << 4 );           // Send low nibble to D7-D4
+   lcdEnablePulse();
+}
+
+void lcdInit( uint16_t lineWidth, uint16_t amountOfLines,
+              uint16_t charWidth, uint16_t charHeight )
+{
+   // Configure LCD Pins as Outputs
+   lcdInitPinAsOutput( LCD_HD44780_RS );
+   lcdInitPinAsOutput( LCD_HD44780_RW );
+   lcdInitPinAsOutput( LCD_HD44780_EN );
+
+   lcdInitPinAsOutput( LCD_HD44780_D4 );
+   lcdInitPinAsOutput( LCD_HD44780_D5 );
+   lcdInitPinAsOutput( LCD_HD44780_D6 );
+   lcdInitPinAsOutput( LCD_HD44780_D7 );
+
+   // Configure LCD for 4-bit mode
+   lcdPinWrite( LCD_HD44780_RW, OFF );   // RW = 0
+   lcdPinWrite( LCD_HD44780_RS, OFF );   // RS = 0
+
+   lcdPinWrite( LCD_HD44780_EN, OFF );   // EN = 0
+
+   lcdDelay_ms( LCD_STARTUP_WAIT_MS );   // Wait for stable power
+
+   lcdCommand( 0x33 );                   // Command 0x33 for 4-bit mode
+   lcdCommandDelay();                    // Wait
+
+   lcdCommand( 0x32 );                   // Command 0x32 for 4-bit mode
+   lcdCommandDelay();                    // Wait
+
+   lcdCommand( 0x28 );                   // Command 0x28 for 4-bit mode
+   lcdCommandDelay();                    // Wait
+
+   // Initialize LCD
+   lcdCommand( 0x0E );                   // Command 0x0E for display on, cursor on
+   lcdCommandDelay();                    // Wait
+
+   lcdClear();                           // Command for clear LCD
+
+   lcdCommand( 0x06 );                   // Command 0x06 for Shift cursor right
+   lcdCommandDelay();                    // Wait
+
+   lcdDelay_ms( 1 );                     // Wait
+}
+
+void lcdGoToXY( uint8_t x, uint8_t y )
+{
+   uint8_t firstCharAdress[] = { 0x80, 0xC0, 0x94, 0xD4 };   // See table 12-5
+   lcdCommand( firstCharAdress[ y - 1 ] + x - 1 );
+   lcdDelay_us( LCD_HIGH_WAIT_US );      // Wait
+}
+
+void lcdClear( void )
+{
+   lcdCommand( 0x01 );                   // Command 0x01 for clear LCD
+   lcdDelay_ms(LCD_CLR_DISP_WAIT_MS);    // Wait
+}
+
+void lcdSendStringRaw( char* str )
+{
+   uint8_t i = 0;
+   while( str[i] != 0 ) {
+      lcdData( str[i] );
+      i++;
+   }
+}
+
+void lcdCreateChar( uint8_t charnum, const char* chardata )
+{
+   uint8_t i;
+   charnum &= 0x07;
+   lcdCommand( E_SET_CGRAM_ADDR | (charnum << 3) );
+   for (i = 0; i < 8; i++) {
+      lcdData( chardata[i] );
+   }
+   delay(1);
+}
+
+
+/*==================[fin del archivo]========================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_hmc5883l.c ./libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_hmc5883l.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_hmc5883l.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_hmc5883l.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,153 @@
+/* Copyright 2016, Alejandro Permingeat
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-06-27 */
+
+#include "sapi_magnetometer_hmc5883l.h"   /* <= sAPI HMC5883L header */
+#include "sapi_i2c.h"         	         /* <= sAPI I2C header */
+
+bool_t hmc5883lIsAlive( void )
+{
+   uint8_t idRegister[3] = { 0, 0, 0 };
+
+   // i2cRead( I2C0, HMC5883L_ADD, HMC5883L_REG_ID_REG_A, &idRegister, 3 );
+
+   if( (HMC5883L_VALUE_ID_REG_A == idRegister[0]) &&
+       (HMC5883L_VALUE_ID_REG_B == idRegister[1]) &&
+       (HMC5883L_VALUE_ID_REG_C == idRegister[2])
+     ) {
+      return (TRUE);
+   } else {
+      return (FALSE);
+   }
+}
+
+bool_t hmc5883lPrepareDefaultInit( HMC5883L_config_t * config )
+{
+   config->gain = HMC5883L_DEFAULT_gain;
+   config->meassurement = HMC5883L_DEFAULT_messurement;
+   config->rate = HMC5883L_DEFAULT_rate;
+   config->samples = HMC5883L_DEFAULT_sample;
+   config->mode = HMC5883L_DEFAULT_mode;
+
+   return (TRUE);
+}
+
+
+bool_t hmc5883lInit( HMC5883L_config_t config )
+{
+   uint8_t registerA, registerB, registerMode;
+
+   uint8_t transmitDataBuffer[2];
+
+   registerA = config.samples;
+   registerA = registerA<<3;
+   registerA |= config.rate;
+   registerA = registerA<<2;
+   registerA |= config.meassurement;
+
+   registerB = config.gain;
+   registerB = registerB << 5;
+
+   registerMode = config.mode;
+
+   i2cInit( I2C0, 100000 );
+
+   transmitDataBuffer[0] = HMC5883L_REG_CONFIG_A;
+   transmitDataBuffer[1] = registerA;
+   i2cWrite( I2C0, HMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   transmitDataBuffer[0] = HMC5883L_REG_CONFIG_B;
+   transmitDataBuffer[1] = registerB;
+   i2cWrite( I2C0, HMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   transmitDataBuffer[0] = HMC5883L_REG_MODE;
+   transmitDataBuffer[1] = registerMode;
+   i2cWrite( I2C0, HMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   return ( hmc5883lIsAlive() );
+}
+
+
+bool_t hmc5883lRead( int16_t * x, int16_t * y, int16_t * z )
+{
+   bool_t result = TRUE;
+
+   uint8_t x_MSB, x_LSB;
+   uint8_t y_MSB, y_LSB;
+   uint8_t z_MSB, z_LSB;
+
+   uint8_t dataToReadBuffer;
+
+   dataToReadBuffer = HMC5883L_REG_X_MSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &x_MSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_X_LSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &x_LSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Y_MSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &y_MSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Y_LSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &y_LSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Z_MSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &z_MSB, 1, TRUE );
+
+   dataToReadBuffer = HMC5883L_REG_Z_LSB;
+   i2cRead( I2C0, HMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &z_LSB, 1, TRUE );
+
+   *x = x_MSB;
+   *x = (*x << 8) | x_LSB;
+
+   *y = y_MSB;
+   *y = (*y << 8) | y_LSB;
+
+   *z = z_MSB;
+   *z = (*z << 8) | z_LSB;
+
+   return(result); /** TODO: return value must reflect the result of the operation */
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_qmc5883l.c ./libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_qmc5883l.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_qmc5883l.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_magnetometer_qmc5883l.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,144 @@
+/* Copyright 2017, Rodrigo Furlani
+ * Copyright 2017, Alejandro Permingeat
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-11-14 */
+
+#include "sapi_magnetometer_qmc5883l.h"         /* <= sAPI QMC5883L header */
+#include "sapi_i2c.h"         	   /* <= sAPI I2C header */
+
+
+bool_t qmc5883lPrepareDefaultInit( QMC5883L_config_t * config )
+{
+
+   config->samples = QMC5883L_DEFAULT_sample;
+   config->gain = QMC5883L_DEFAULT_gain;
+   config->rate = QMC5883L_DEFAULT_rate;
+
+   config->mode = QMC5883L_DEFAULT_mode;
+
+   return (TRUE);
+}
+
+
+bool_t qmc5883lInit( QMC5883L_config_t config )
+{
+
+   uint8_t register1;//, register2, registerMode;
+
+   uint8_t transmitDataBuffer[2];
+
+   register1 = 0;
+
+   /*OSR bit 7 and bit 6 */
+   register1 |= ((uint8_t)config.samples) << 6;
+
+   /*RNG bit 5 and bit 4*/
+   register1 |= ((uint8_t)config.gain) << 4;
+
+   /*ODR bit 3 and bit 2*/
+   register1 |= ((uint8_t)config.rate) << 2;
+
+   /*MODE bit 1 and bit 0*/
+   register1 |= config.mode;
+
+   i2cInit( I2C0, 100000 );
+
+   transmitDataBuffer[0] = QMC5883L_SET_RESET_PERIOD;
+   transmitDataBuffer[1] = 1; /* value recomeended in datasheet for this register*/
+   i2cWrite( I2C0, QMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   transmitDataBuffer[0] = QMC5883L_REG_CTRL_1;
+   transmitDataBuffer[1] = register1;
+   i2cWrite( I2C0, QMC5883L_ADD, transmitDataBuffer, 2, TRUE );
+
+   /** TODO: Implement the configuration of register QMC5883L_REG_CTRL_2: possition 0x0A*/
+
+   return ( TRUE);
+}
+
+
+bool_t qmc5883lRead( int16_t * x, int16_t * y, int16_t * z )
+{
+
+   bool_t result = TRUE;
+
+   uint8_t x_MSB, x_LSB;
+   uint8_t y_MSB, y_LSB;
+   uint8_t z_MSB, z_LSB;
+
+   uint8_t dataToReadBuffer;
+
+
+   dataToReadBuffer = QMC5883L_REG_X_LSB;
+   i2cRead( I2C0, QMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &x_LSB, 1, TRUE );
+
+   dataToReadBuffer = QMC5883L_REG_X_MSB;
+   i2cRead( I2C0, QMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &x_MSB, 1, TRUE );
+
+   dataToReadBuffer = QMC5883L_REG_Y_LSB;
+   i2cRead( I2C0, QMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &y_LSB, 1, TRUE );
+
+   dataToReadBuffer = QMC5883L_REG_Y_MSB;
+   i2cRead( I2C0, QMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &y_MSB, 1, TRUE );
+
+
+   dataToReadBuffer = QMC5883L_REG_Z_LSB;
+   i2cRead( I2C0, QMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &z_LSB, 1, TRUE );
+
+   dataToReadBuffer = QMC5883L_REG_Z_MSB;
+   i2cRead( I2C0, QMC5883L_ADD,
+            &dataToReadBuffer, 1, TRUE,
+            &z_MSB, 1, TRUE );
+
+   *x = x_MSB;
+   *x = (*x << 8)|x_LSB;
+
+   *y = y_MSB;
+   *y = (*y << 8)|y_LSB;
+
+   *z = z_MSB;
+   *z = (*z << 8)|z_LSB;
+
+   return(result); /** TODO: return value must reflect the result of the operation */
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_print.c ./libs/sapi/sapi_v0.5.1/src/sapi_print.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_print.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_print.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,112 @@
+/* Copyright 2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2017-04-17 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_print.h"     // <= own header
+
+#include "sapi_convert.h"   // <= Convert header
+#include "sapi_uart.h"      // <= UART header
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+// Print uart configuration
+
+void printSetUart( print_t* printer, uartMap_t uart )
+{
+   *printer = uart;
+}
+
+void printInitUart( print_t* printer, uartMap_t uart, uint32_t baudRate )
+{
+   *printer = uart;
+   uartInit( uart, baudRate );
+}
+
+
+// Print String
+
+void printString( print_t printer, const char* string )
+{
+   uartWriteString( printer, string );
+}
+
+void printEnter( print_t printer )
+{
+   uartWriteString( printer, PRINT_ENTER_STRING );
+}
+
+
+// Print Integer
+
+void printIntFormat( print_t printer, int64_t number, numberFormat_t format )
+{
+
+   char strNumber[65];
+
+   if( int64ToString( number, strNumber, format ) ) {
+      uartWriteString( printer, strNumber );
+   }
+}
+
+void printUIntFormat( print_t printer, uint64_t number, numberFormat_t format )
+{
+
+   char strNumber[65];
+
+   if( uint64ToString( number, strNumber, format ) ) {
+      uartWriteString( printer, strNumber );
+   }
+}
+
+void printHex( print_t printer, uint64_t number, uint8_t bitSize )
+{
+   printString( printer, uintToAsciiHex( number , bitSize ) );
+}
+
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_pwm.c ./libs/sapi/sapi_v0.5.1/src/sapi_pwm.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_pwm.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_pwm.c	2018-12-01 17:15:06.625606241 -0300
@@ -0,0 +1,279 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/* TODO: hacer una forma de buscar las funciones que tocan el modulo siguiente
+ * All functions relative to the microcontroller */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_pwm.h"
+#include "sapi_sct.h"
+
+/*==================[macros and definitions]=================================*/
+
+#ifndef EMPTY_POSITION
+#define EMPTY_POSITION 255
+#endif
+
+#define PWM_TOTALNUMBER   11   /* From PWM0 to PWM10 */
+
+#define PWM_FREC          1000 /* 1Khz */
+#define PWM_PERIOD        1000 /* 1000uS = 1ms*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*
+ * @Brief: Initializes the pwm timers.
+ * @param  none
+ * @return nothing
+ */
+static void pwmInitTimers(void);
+
+/*
+ * @brief:   adds pwm to the the list of working pwms
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   True if pwm was successfully attached, False if not.
+ */
+static bool_t pwmAttach( pwmMap_t pwmNumber );
+
+/*
+ * @brief:   removes pwm (attached to pwmNumber) from the list
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:    True if pwm was successfully detached, False if not.
+ */
+static bool_t pwmDetach( pwmMap_t pwmNumber );
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/* Enter a pwm number, get a sct number
+ * Since this module works with pwm numbers, but uses sct channels to generate
+ * the signal, its necessary to connect pwm number with the SctMap_t (sAPI_PeripheralMap.h).
+ * This way the user sets "pwms", while using the sct peripheral internally*/
+static const uint8_t pwmMap[PWM_TOTALNUMBER] = {
+   /* PWM0 */  CTOUT1,  /* T_FIL1 */
+   /* PWM1 */  CTOUT12, /* T_COL2 */
+   /* PWM2 */  CTOUT10, /* T_COL0 */
+   /* PWM3 */  CTOUT0,  /* T_FIL2 */
+   /* PWM4 */  CTOUT3,  /* T_FIL3 */
+   /* PWM5 */  CTOUT13, /* T_COL1 */
+   /* PWM6 */  CTOUT7,  /* GPIO8  */
+   /* PWM7 */  CTOUT2,  /* LED1   */
+   /* PWM8 */  CTOUT5,  /* LED2   */
+   /* PWM9 */  CTOUT4,  /* LED3   */
+   /* PWM10 */ CTOUT6   /* GPIO2  */
+};
+
+/*when the user adds a pwm with pwmAttach the list updates with the pin number of the element*/
+static uint8_t AttachedPWMList[PWM_TOTALNUMBER] = {
+   /*Position | Pwm Number*/
+   /*0*/  EMPTY_POSITION,
+   /*1*/  EMPTY_POSITION,
+   /*2*/  EMPTY_POSITION,
+   /*3*/  EMPTY_POSITION,
+   /*4*/  EMPTY_POSITION,
+   /*5*/  EMPTY_POSITION,
+   /*6*/  EMPTY_POSITION,
+   /*7*/  EMPTY_POSITION,
+   /*8*/  EMPTY_POSITION,
+   /*9*/	EMPTY_POSITION,
+   /*10*/ EMPTY_POSITION,
+};
+
+/*==================[internal functions definition]==========================*/
+
+/*
+ * @Brief:   Initializes the pwm timers.
+ * @param   none
+ * @return   nothing
+ */
+static void pwmInitTimers(void)
+{
+   Sct_Init(PWM_FREC);
+}
+
+/*
+ * @brief:   adds pwm to the the list of working pwms
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   True if pwm was successfully attached, False if not.
+ */
+static bool_t pwmAttach( pwmMap_t pwmNumber)
+{
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = pwmIsAttached(pwmNumber);
+   if(position==0) {
+      position = pwmIsAttached(EMPTY_POSITION); /* Searches for the first empty position */
+      if(position) { /* if position==0 => there is no room in the list for another pwm */
+         AttachedPWMList[position-1] = pwmNumber;
+         Sct_EnablePwmFor(pwmMap[pwmNumber]);
+         success = TRUE;
+      }
+   }
+   return success;
+}
+
+/*
+ * @brief:   removes pwm (attached to pwmNumber) from the list
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:    True if pwm was successfully detached, False if not.
+ */
+static bool_t pwmDetach( pwmMap_t pwmNumber )
+{
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = pwmIsAttached(pwmNumber);
+
+   if(position) {
+      AttachedPWMList[position-1] = EMPTY_POSITION;
+      success = TRUE;
+   }
+   return success;
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @brief:   change the value of the pwm at the selected pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @param:   value:   8bit value, from 0 to 255
+ * @return:   True if the value was successfully changed, False if not.
+ */
+bool_t pwmWrite( pwmMap_t pwmNumber, uint8_t value )
+{
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = pwmIsAttached(pwmNumber);
+
+   if(position) {
+      Sct_SetDutyCycle(pwmMap[pwmNumber], value);
+      success = TRUE;
+   }
+
+   return success;
+}
+
+/*
+ * @brief:   read the value of the pwm in the pin
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   value of the pwm in the pin (0 ~ 255).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint8_t pwmRead( pwmMap_t pwmNumber )
+{
+
+   uint8_t position = 0, value = 0;
+   position = pwmIsAttached(pwmNumber);
+
+   if(position) {
+      value = Sct_GetDutyCycle(pwmMap[pwmNumber]);
+   } else {
+      value = EMPTY_POSITION;
+   }
+
+   return value;
+}
+
+
+/*
+ * @Brief: Initializes the pwm peripheral.
+ * @param  uint8_t pwmNumber
+ * @param  uint8_t config
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t pwmInit( pwmMap_t pwmNumber, pwmInit_t config)
+{
+
+   bool_t ret_val = 1;
+
+   switch(config) {
+
+   case PWM_ENABLE:
+      pwmInitTimers();
+      break;
+
+   case PWM_DISABLE:
+      ret_val = 0;
+      break;
+
+   case PWM_ENABLE_OUTPUT:
+      ret_val = pwmAttach( pwmNumber );
+      break;
+
+   case PWM_DISABLE_OUTPUT:
+      ret_val = pwmDetach( pwmNumber );
+      break;
+
+   default:
+      ret_val = 0;
+      break;
+   }
+
+   return ret_val;
+}
+
+/*
+ * @brief:   Tells if the pwm is currently active, and its position
+ * @param:   pwmNumber:   ID of the pwm, from 0 to 10
+ * @return:   position (1 ~ PWM_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t pwmIsAttached( pwmMap_t pwmNumber )
+{
+   uint8_t position = 0, positionInList = 0;
+   while ( (position < PWM_TOTALNUMBER) &&
+           (pwmNumber != AttachedPWMList[position]) ) {
+      position++;
+   }
+
+   if (position < PWM_TOTALNUMBER) {
+      positionInList = position + 1;
+   } else {
+      positionInList = 0;
+   }
+
+   return positionInList;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_rgb.c ./libs/sapi/sapi_v0.5.1/src/sapi_rgb.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_rgb.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_rgb.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,325 @@
+/* Copyright 2017, Agustin Bassi.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Date: 2017-11-01
+ */
+
+/*==================[inlcusiones]============================================*/
+
+#include "sapi_rgb.h"
+#include "chip.h"
+#include "sapi_timer.h"
+
+/*==================[definiciones y macros]==================================*/
+
+//Cantidad de ticks para que pase un milisegundo
+#define TICS_1_MS		 1000
+//Tiempo maximo del periodo PWM para que vuelva a comenzar el ciclo
+#define PWM_PERIOD      25
+//Valor predefinido para indicar el periodo maximo del ciclo de trabajo.
+#define MAX_DUTY_CYCLE  25
+//Valor predefinido para indicar el periodo minimo del ciclo de trabajo.
+#define MIN_DUTY_CYCLE   0
+
+//Define MACRO para setear el timer a 1 ms y configurar el callback del timer a la funcion UpdateLedsStates
+#define SetTimerInterrupt() Timer_Init(TIMER3,Timer_microsecondsToTicks(TICS_1_MS),UpdateLedsStates)
+
+// Composicion de un LED RGB
+typedef struct RgbLed {
+   uint8_t pinRed;
+   uint8_t pinGreen;
+   uint8_t pinBlue;
+   int8_t dutyCycleRed;
+   int8_t dutyCycleGreen;
+   int8_t dutyCycleBlue;
+   int8_t toggleDutyCycleRed;	//Los valores toggle seran guardados para poder togglear con el valor actual del led
+   int8_t toggleDutyCycleGreen;
+   int8_t toggleDutyCycleBlue;
+   bool_t toggled;
+   uint8_t bright;	//Factor de escala para el brillo del LED
+} RgbLed_t;
+
+/*==================[definiciones de datos internos]=========================*/
+
+/** Arreglo que contiene de manera estatica los datos correspondientes a cada led RGB*/
+static RgbLed_t RgbLeds [MAX_AMOUNT_OF_RGB_LEDS];
+
+/*==================[definiciones de datos externos]=========================*/
+
+/*==================[declaraciones de funciones internas]====================*/
+
+static void UpdateLedsStates( void *param);
+static void StabilizePwmValues( LedRgbMap_t rgbLed );
+static void	InitRgbFirstTime( void );
+
+/*==================[declaraciones de funciones externas]====================*/
+
+/*==================[definiciones de funciones internas]=====================*/
+
+/**
+ * FUNCION de INTERRUPCION DEL Timer que se ejecuta cada vezque ocurre un Tick.
+ */
+static void UpdateLedsStates( void *param )
+{
+// Variable para contar el paso del tiempo
+   static uint32_t ticksCounter = 0;
+   uint8_t index;
+
+   for (index = 0; index < MAX_AMOUNT_OF_RGB_LEDS; index++) {
+      //Si el led fue inicializado
+      if (RgbLeds[index].pinRed != 0) {
+         if (ticksCounter == RgbLeds[index].dutyCycleRed)  gpioWrite (RgbLeds[index].pinRed,   OFF);
+         if (ticksCounter == RgbLeds[index].dutyCycleGreen)gpioWrite (RgbLeds[index].pinGreen, OFF);
+         if (ticksCounter == RgbLeds[index].dutyCycleBlue) gpioWrite (RgbLeds[index].pinBlue,  OFF);
+      }
+   }
+   if (++ticksCounter == PWM_PERIOD) {
+      for (index = 0; index < MAX_AMOUNT_OF_RGB_LEDS; index++) {
+         //Si el led fue inicializado
+         if (RgbLeds[index].pinRed != 0) {
+            if (RgbLeds[index].dutyCycleRed > MIN_DUTY_CYCLE) 	gpioWrite (RgbLeds[index].pinRed,   ON);
+            if (RgbLeds[index].dutyCycleGreen > MIN_DUTY_CYCLE) gpioWrite (RgbLeds[index].pinGreen, ON);
+            if (RgbLeds[index].dutyCycleBlue > MIN_DUTY_CYCLE) 	gpioWrite (RgbLeds[index].pinBlue,  ON);
+            ticksCounter = 0;
+         }
+      }
+   }
+   //return TRUE;
+}
+
+/**
+ * Funcion para estabilizar los valores de ciclos de trabajo de cada LED.
+ * Puede darse el caso que los valores superen los valores minimos o maximos.
+ */
+static void   StabilizePwmValues   (LedRgbMap_t rgbLed)
+{
+   //Estabilizar valores para el rojo
+   if       (RgbLeds[rgbLed].dutyCycleRed < MIN_DUTY_CYCLE) {
+      RgbLeds[rgbLed].dutyCycleRed   = MIN_DUTY_CYCLE;
+   } else if  (RgbLeds[rgbLed].dutyCycleRed > MAX_DUTY_CYCLE) {
+      RgbLeds[rgbLed].dutyCycleRed   = MAX_DUTY_CYCLE;
+   }
+   //Estabilizar valores para el verde
+   if       (RgbLeds[rgbLed].dutyCycleGreen < MIN_DUTY_CYCLE) {
+      RgbLeds[rgbLed].dutyCycleGreen = MIN_DUTY_CYCLE;
+   } else if  (RgbLeds[rgbLed].dutyCycleGreen > MAX_DUTY_CYCLE) {
+      RgbLeds[rgbLed].dutyCycleGreen = MAX_DUTY_CYCLE;
+   }
+   //Estabilizar valores para el azul
+   if       (RgbLeds[rgbLed].dutyCycleBlue < MIN_DUTY_CYCLE) {
+      RgbLeds[rgbLed].dutyCycleBlue  = MIN_DUTY_CYCLE;
+   } else if  (RgbLeds[rgbLed].dutyCycleBlue > MAX_DUTY_CYCLE) {
+      RgbLeds[rgbLed].dutyCycleBlue  = MAX_DUTY_CYCLE;
+   }
+}
+
+/**
+ * Inicializa el timer pwm y el arreglo con los datos de cada LED RGB.
+ */
+static void	  InitRgbFirstTime     ()
+{
+   static bool_t rgbInitialized;
+   uint8_t auxVariable;
+   if (!rgbInitialized) {
+      Timer_Init(TIMER3, Timer_microsecondsToTicks(TICS_1_MS), UpdateLedsStates);
+//		SetTimerInterrupt();
+      // Inicializa todos los leds RGB.
+      for (auxVariable = 0; auxVariable < MAX_AMOUNT_OF_RGB_LEDS; auxVariable++) {
+         RgbLeds[auxVariable].pinRed         = 0;
+         RgbLeds[auxVariable].pinGreen       = 0;
+         RgbLeds[auxVariable].pinBlue        = 0;
+         RgbLeds[auxVariable].dutyCycleRed   = 0;
+         RgbLeds[auxVariable].dutyCycleGreen = 0;
+         RgbLeds[auxVariable].dutyCycleBlue  = 0;
+         RgbLeds[auxVariable].bright         = 100;
+      }
+      rgbInitialized = TRUE;
+   }
+}
+
+/*==================[definiciones de funciones externas]=====================*/
+
+/**
+ * Funcion para configurar el driver RGB.
+ * Se le debe pasar desde la aplicacion, cual es el pin rojo, verde y azul.
+ * Ademas configura el timer3 para que genere una interrupcion cada 1 ms
+ * y cuando ocurra la interrupcion llame a la funcion UpdateLedsStates(), que sirve
+ * para actualizar el ciclo de trabajo de cada led.
+ * Devuelve TRUE.
+ */
+bool_t rgbInit       (LedRgbMap_t rgbLed, uint8_t pinRed, uint8_t pinGreen, uint8_t pinBlue)
+{
+   InitRgbFirstTime();
+
+   RgbLeds[rgbLed].pinRed   = pinRed;
+   RgbLeds[rgbLed].pinGreen = pinGreen;
+   RgbLeds[rgbLed].pinBlue  = pinBlue;
+
+   gpioConfig(RgbLeds[rgbLed].pinRed,   GPIO_OUTPUT);
+   gpioConfig(RgbLeds[rgbLed].pinGreen, GPIO_OUTPUT);
+   gpioConfig(RgbLeds[rgbLed].pinBlue,  GPIO_OUTPUT);
+
+   return TRUE;
+}
+
+/**
+ * Manda por los pines PWM uno de los posibles colores definidos en color_t
+ */
+void 	rgbWriteColor  (LedRgbMap_t rgbLed, Color_t color)
+{
+   switch (color) {
+   case WHITE:
+      RgbLeds[rgbLed].dutyCycleBlue  = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MAX_DUTY_CYCLE;
+      break;
+   case VIOLET:
+      RgbLeds[rgbLed].dutyCycleBlue  = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MIN_DUTY_CYCLE;
+      break;
+   case CYAN:
+      RgbLeds[rgbLed].dutyCycleBlue  = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MAX_DUTY_CYCLE;
+      break;
+   case BLUE:
+      RgbLeds[rgbLed].dutyCycleBlue  = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MIN_DUTY_CYCLE;
+      break;
+   case YELLOW:
+      RgbLeds[rgbLed].dutyCycleBlue  = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MAX_DUTY_CYCLE;
+      break;
+   case RED:
+      RgbLeds[rgbLed].dutyCycleBlue  = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MAX_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MIN_DUTY_CYCLE;
+      break;
+   case GREEN:
+      RgbLeds[rgbLed].dutyCycleBlue  = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MAX_DUTY_CYCLE;
+      break;
+   case BLACK:
+      RgbLeds[rgbLed].dutyCycleBlue  = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MIN_DUTY_CYCLE;
+      break;
+   default:
+      RgbLeds[rgbLed].dutyCycleBlue  = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleRed   = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen = MIN_DUTY_CYCLE;
+      break;
+   }
+   RgbLeds[rgbLed].toggled = FALSE;
+}
+
+/**
+ * Manda una configuracion individual de cada canal del LED RGB seleccionado.
+ */
+void 	rgbWriteRaw    (LedRgbMap_t rgbLed, int8_t dutyRed, int8_t dutyGreen, int8_t dutyBlue)
+{
+   RgbLeds[rgbLed].dutyCycleRed   = dutyRed;
+   RgbLeds[rgbLed].dutyCycleGreen = dutyGreen;
+   RgbLeds[rgbLed].dutyCycleBlue  = dutyBlue;
+   RgbLeds[rgbLed].toggled        = FALSE;
+   //Estabiliza los valores por si se pasan del rango permitido.
+   StabilizePwmValues(rgbLed);
+}
+
+/**
+ * Setea el brillo sin cambiar el color (multiplica por una constante).
+ */
+void 	rgbWriteBright (LedRgbMap_t rgbLed, uint32_t bright)
+{
+   RgbLeds[rgbLed].bright  = bright;
+   RgbLeds[rgbLed].toggled = FALSE;
+}
+
+/**
+ * Lee el valor del duty cycle del LED Rojo
+ * @param rgbLed led rgb a leer el duty cycle
+ * @return valor del duty cycle
+ */
+uint8_t rgbReadDutyRed	(LedRgbMap_t rgbLed)
+{
+   return RgbLeds[rgbLed].dutyCycleRed;
+}
+
+/**
+ * Lee el valor del duty cycle del LED Verde
+ * @param rgbLed led rgb a leer el duty cycle
+ * @return valor del duty cycle
+ */
+uint8_t rgbReadDutyGreen(LedRgbMap_t rgbLed)
+{
+   return RgbLeds[rgbLed].dutyCycleGreen;
+}
+
+/**
+ * Lee el valor del duty cycle del LED Azul
+ * @param rgbLed led rgb a leer el duty cycle
+ * @return valor del duty cycle
+ */
+uint8_t rgbReadDutyBlue	(LedRgbMap_t rgbLed)
+{
+   return RgbLeds[rgbLed].dutyCycleBlue;
+}
+
+/**
+ * Realiza un toggle del LED con el color que tenga guardado
+ * @param rgbLed led a togglear.
+ */
+void rgbToggleLed (LedRgbMap_t rgbLed)
+{
+   if (!RgbLeds[rgbLed].toggled) {
+      RgbLeds[rgbLed].toggleDutyCycleRed   = RgbLeds[rgbLed].dutyCycleRed;
+      RgbLeds[rgbLed].toggleDutyCycleGreen = RgbLeds[rgbLed].dutyCycleGreen;
+      RgbLeds[rgbLed].toggleDutyCycleBlue  = RgbLeds[rgbLed].dutyCycleBlue;
+      RgbLeds[rgbLed].dutyCycleRed         = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleGreen       = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].dutyCycleBlue        = MIN_DUTY_CYCLE;
+   } else {
+      RgbLeds[rgbLed].dutyCycleRed         = RgbLeds[rgbLed].toggleDutyCycleRed;
+      RgbLeds[rgbLed].dutyCycleGreen       = RgbLeds[rgbLed].toggleDutyCycleGreen;
+      RgbLeds[rgbLed].dutyCycleBlue        = RgbLeds[rgbLed].toggleDutyCycleBlue;
+      RgbLeds[rgbLed].toggleDutyCycleRed   = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].toggleDutyCycleGreen = MIN_DUTY_CYCLE;
+      RgbLeds[rgbLed].toggleDutyCycleBlue  = MIN_DUTY_CYCLE;
+   }
+   RgbLeds[rgbLed].toggled = !RgbLeds[rgbLed].toggled;
+}
+/*==================[fin del archivo]========================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_rtc.c ./libs/sapi/sapi_v0.5.1/src/sapi_rtc.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_rtc.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_rtc.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,145 @@
+/* Copyright 2011, ChaN.
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-03-07 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_rtc.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief: Configure RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcInit( rtc_t * rtc )
+{
+   bool_t ret_val = 1;
+
+   static bool_t init;
+
+   if( init ) {
+      /* Already initialized */
+      ret_val = 0;
+   } else {
+
+      /* RTC Block section ------------------------- */
+      Chip_RTC_Init(LPC_RTC);
+
+      /* Set current time for RTC */
+      /* Current time is 22:00:00 , 2016-07-02 */
+      /*
+      rtcTime.time[RTC_TIMETYPE_SECOND]     = 0;
+      rtcTime.time[RTC_TIMETYPE_MINUTE]     = 0;
+      rtcTime.time[RTC_TIMETYPE_HOUR]       = 22;
+      rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = 2;
+      rtcTime.time[RTC_TIMETYPE_MONTH]      = 7;
+      rtcTime.time[RTC_TIMETYPE_YEAR]       = 2016;
+      Chip_RTC_SetFullAlarmTime(LPC_RTC, &rtcTime);
+      */
+      rtcWrite( rtc );
+
+      /* Enable rtc (starts increase the tick counter
+         and second counter register) */
+      Chip_RTC_Enable(LPC_RTC, ENABLE);
+
+      init = 1;
+   }
+
+   return ret_val;
+}
+
+/*
+ * @Brief: Get time from RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcRead( rtc_t * rtc )
+{
+   bool_t ret_val = 1;
+
+   RTC_TIME_T rtcTime;
+
+   Chip_RTC_GetFullTime(LPC_RTC, &rtcTime);
+
+   rtc->sec = rtcTime.time[RTC_TIMETYPE_SECOND];
+   rtc->min = rtcTime.time[RTC_TIMETYPE_MINUTE];
+   rtc->hour = rtcTime.time[RTC_TIMETYPE_HOUR];
+   rtc->wday = rtcTime.time[RTC_TIMETYPE_DAYOFWEEK];
+   rtc->mday = rtcTime.time[RTC_TIMETYPE_DAYOFMONTH];
+   rtc->month = rtcTime.time[RTC_TIMETYPE_MONTH];
+   rtc->year = rtcTime.time[RTC_TIMETYPE_YEAR];
+
+   return ret_val;
+}
+
+/*
+ * @Brief: Set time on RTC peripheral.
+ * @param  rtc_t rtc: RTC structure
+ * @return bool_t true (1) if config it is ok
+ */
+bool_t rtcWrite( rtc_t * rtc )
+{
+   bool_t ret_val = 1;
+
+   RTC_TIME_T rtcTime;
+
+   rtcTime.time[RTC_TIMETYPE_SECOND]     = rtc->sec;
+   rtcTime.time[RTC_TIMETYPE_MINUTE]     = rtc->min;
+   rtcTime.time[RTC_TIMETYPE_HOUR]       = rtc->hour;
+   rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->wday;
+   rtcTime.time[RTC_TIMETYPE_DAYOFMONTH] = rtc->mday;
+   rtcTime.time[RTC_TIMETYPE_MONTH]      = rtc->month;
+   rtcTime.time[RTC_TIMETYPE_YEAR]	     = rtc->year;
+
+   Chip_RTC_SetFullTime(LPC_RTC, &rtcTime);
+
+   return ret_val;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_sct.c ./libs/sapi/sapi_v0.5.1/src/sapi_sct.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_sct.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_sct.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,166 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/*The SCT (State Configurable Timer) is a feature included in some of LPC's microcontrollers
+ * that provides a high resolution PWM (or just another timer).
+ * It's like a normal timer but with multiple Compare Match values (16),
+ * and can be therefore used to generate several PWM signals with THE SAME PERIOD
+ * For more information about the STCPWM peripheral, refer to the Chapter 39 of
+ * the LPC43xx user manual
+ */
+
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_sct.h"
+
+/* Specific modules used:
+   #include "scu_18xx_43xx.h" for Chip_SCU funtions
+   #include "sct_pwm_18xx_43xx.h" for Chip_SCTPWM funtions
+*/
+
+/*==================[macros and definitions]=================================*/
+
+/* Because all pins have their CTOUT in the FUNC1 there is no need to
+   save the same number for every pin in this case. */
+#define CTOUT_FUNC   FUNC1
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+/*
+ * List of ports and pins corresponding to the sct channels.
+ * Each channel is asociated with a CTOUT number. Some pins, like
+ * LED 1 and LCD1, have the same channel, so you can only generate 1 signal
+ * for both. Because of that only one of them will be used.
+ */
+static pinInitLpc4337_t SCTdataList[] = {
+   /* Sct n° | port | pin | name in board */
+   /* CTOUT0 */ { 4 , 2 }, /* T_FIL2 */
+   /* CTOUT1 */ { 4 , 1 }, /* T_FIL1 */
+   /* CTOUT2 */ { 2 , 10 }, /* LED1 (also for LCD1) */
+   /* CTOUT3 */ { 4 , 3 }, /* T_FIL3 */
+   /* CTOUT4 */ { 2 , 12 }, /* LED3 (also for LCD3) */
+   /* CTOUT5 */ { 2 , 11 }, /* LED2 (also for LCD2) */
+   /* CTOUT6 */ { 6 , 5 }, /* GPIO2 */
+   /* CTOUT7 */ { 6 , 12 }, /* GPIO8 */
+   /* CTOUT8 */ { 1 , 3 }, /* MDC / SPI_MISO */
+   /* CTOUT9 */ { 1 , 4 }, /* SPI_MOSI */
+   /* CTOUT10 */ { 1 , 5 }, /* T_COL0 */
+   /* CTOUT11 */ { 0 , 0 }, /* DO NOT USE */
+   /* CTOUT12 */ { 7 , 5 }, /* T_COL2 */
+   /* CTOUT13 */ { 7 , 4 } /* T_COL1 */
+};
+
+/*Configuration data for LCD1, LCD2 and LCD3:
+ CTOUT_2 { 4 , 4 }, LCD1
+ CTOUT_5 { 4 , 5 }, LCD2
+ CTOUT_4 { 4 , 6 }, LCD3
+ */
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+/*
+ * @brief:   Initialize the SCT peripheral with the given frequency
+ * @param:   frequency:   value in Hz
+ * @note:   there can only be 1 frequency in all the SCT peripheral.
+ */
+void Sct_Init(uint32_t frequency)
+{
+   /* Source: https://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen */
+   /* Initialize the SCT as PWM and set frequency */
+   Chip_SCTPWM_Init(LPC_SCT);
+   Chip_SCTPWM_SetRate(LPC_SCT, frequency);
+
+   Chip_SCTPWM_Start(LPC_SCT);
+}
+
+/*
+ * @brief	Enables pwm function for the given pin
+ * @param	sctNumber:   pin where the pwm signal will be generated
+ */
+void Sct_EnablePwmFor(uint8_t sctNumber)
+{
+   /*Enable SCT function on pin*/
+   Chip_SCU_PinMux(SCTdataList[sctNumber].port , SCTdataList[sctNumber].pin , SCU_MODE_INACT , CTOUT_FUNC);
+   /*Sets pin as PWM output and gives it an index (SCTdataList[sctNumber].mode+1)*/
+   Chip_SCTPWM_SetOutPin(LPC_SCT, sctNumber+1, sctNumber);
+
+   /* Start with 0% duty cycle */
+   Sct_SetDutyCycle(sctNumber, Chip_SCTPWM_PercentageToTicks(LPC_SCT,0));
+}
+
+/*
+ * @brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   value:   8bit value, from 0 to 255
+ * @return   Equivalent in Ticks for the LPC4337
+ */
+uint32_t Sct_Uint8ToTicks(uint8_t value)
+{
+   return ( (Chip_SCTPWM_GetTicksPerCycle(LPC_SCT) * value)/ 255 );
+}
+
+
+/*
+ * @brief:   Sets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @param	value:   8bit value, from 0 to 255
+ * @note   For the 'ticks' parameter, see function Sct_Uint8ToTicks
+ */
+void Sct_SetDutyCycle(uint8_t sctNumber, uint8_t value)
+{
+   Chip_SCTPWM_SetDutyCycle(LPC_SCT, sctNumber+1, Sct_Uint8ToTicks(value));
+}
+
+/*
+ * @brief:   Gets the pwm duty cycle
+ * @param:	sctNumber:   pin where the pwm signal is generated
+ * @return:   duty cycle of the channel, from 0 to 255
+ */
+/* TODO: function not tested */
+uint8_t Sct_GetDutyCycle(uint8_t sctNumber)
+{
+   uint8_t value = 0;
+
+   value = (uint8_t) ((Chip_SCTPWM_GetDutyCycle(LPC_SCT, sctNumber+1)*255)/Chip_SCTPWM_GetTicksPerCycle(LPC_SCT));
+
+   return value;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_servo.c ./libs/sapi/sapi_v0.5.1/src/sapi_servo.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_servo.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_servo.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,401 @@
+/* Copyright 2016, Ian Olivieri
+ * Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/*TODO: make a graphic and explanation of the timer ramp and compare match values
+ to make everything clear */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_gpio.h"
+#include "sapi_servo.h"
+#include "sapi_timer.h"
+
+/*==================[macros and definitions]=================================*/
+
+#define EMPTY_POSITION               255
+#define SERVO_TOTALNUMBER            9
+#define SERVO_COMPLETECYCLE_PERIOD   20000  /* value in uSec */
+#define SERVO_MAXUPTIME_PERIOD       2000   /* value in uSec */
+#define SERVO_MINUPTIME_PERIOD       500    /* value in uSec */
+
+/*==================[internal data declaration]==============================*/
+
+typedef struct {
+   uint8_t servo; /*Servo number. It's mapped to the DIOMap_t in the servoMap*/
+   uint8_t value; /*Value of the servo*/
+   /*To manage each servo more efficiently, every one of them has a default
+   * timer, match number and function associated depending of their position in the list
+   * This can be done because all timers initialize with the same period (20ms). So,  if
+   * you need different frequencies for different timers you will have to change that since
+   * it won't be the same to attach a servo in one position or another in the list*/
+   uint8_t associatedTimer;
+   uint8_t associatedCompareMatch;
+   callBackFuncPtr_t associatedFunction;
+
+} attachedServo_t;
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/* Enter a servo number, get a Gpio number
+ * Since this module works with servo numbers, but uses gpio pins to generate
+ * the signal, its necessary to connect servo number with the DIOMap_t (sAPI_PeripheralMap.h).
+ * This way the user sets "servos", while using gpio outputs internally so the gpioWrite()
+ * function can be easily used*/
+static const uint8_t servoMap[ SERVO_TOTALNUMBER ] = {
+   /* Servo name | DIOMap name | Name in the board*/
+   /* SERVO0 */ T_FIL1, /* T_FIL1 */
+   /* SERVO1 */ T_COL0, /* T_COL0 */
+   /* SERVO2 */ T_FIL2, /* T_FIL2 */
+   /* SERVO3 */ T_FIL3, /* T_FIL3 */
+   /* SERVO4 */ GPIO8,  /* GPIO8  */
+   /* SERVO5 */ LCD1,   /* LCD1   */
+   /* SERVO6 */ LCD2,   /* LCD2   */
+   /* SERVO7 */ LCD3,   /* LCD3   */
+   /* SERVO8 */ GPIO2   /* GPIO2  */
+};
+
+/*when the user adds a servo with servoAttach the list updates with the servo number*/
+static attachedServo_t AttachedServoList[ SERVO_TOTALNUMBER ] = {
+   /*position |Servo number | value | asociatedTimer | associatedCompareMatch | associatedFunction*/
+   /*0*/	{ EMPTY_POSITION , 0,  TIMER1 , TIMERCOMPAREMATCH1 , timer1CompareMatch1func },
+   /*1*/	{ EMPTY_POSITION , 0 , TIMER1 , TIMERCOMPAREMATCH2 , timer1CompareMatch2func },
+   /*2*/	{ EMPTY_POSITION , 0 , TIMER1 , TIMERCOMPAREMATCH3 , timer1CompareMatch3func },
+   /*3*/	{ EMPTY_POSITION , 0 , TIMER2 , TIMERCOMPAREMATCH1 , timer2CompareMatch1func },
+   /*4*/	{ EMPTY_POSITION , 0 , TIMER2 , TIMERCOMPAREMATCH2 , timer2CompareMatch2func },
+   /*5*/	{ EMPTY_POSITION , 0 , TIMER2 , TIMERCOMPAREMATCH3 , timer2CompareMatch3func },
+   /*6*/	{ EMPTY_POSITION , 0 , TIMER3 , TIMERCOMPAREMATCH1 , timer3CompareMatch1func },
+   /*7*/	{ EMPTY_POSITION , 0 , TIMER3 , TIMERCOMPAREMATCH2 , timer3CompareMatch2func },
+   /*8*/	{ EMPTY_POSITION , 0 , TIMER3 , TIMERCOMPAREMATCH3 , timer3CompareMatch3func }
+};
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*
+ * @brief   Converts a value in value to micro seconds for a specific type of servo (see the defines)
+ * @param   value:   value of the servo, from 0 to 180
+ * @return   Equivalent in microseconds for a specific type of servo (see the defines)
+ * @note   Should be used with Timer_microsecondsToTicks to use some of
+ *   the functions in the sAPI_Timer that requires ticks as a parameter
+*/
+uint32_t valueToMicroseconds( uint8_t value )
+{
+
+   return (SERVO_MINUPTIME_PERIOD+(value*SERVO_MAXUPTIME_PERIOD)/180);
+}
+
+/*
+ * @brief:	compare match 0 function. The one that is executed when the cycle ends
+ * (to visualize it, think about the 'timer ramp')
+ * @note:   this function can't be generalized because sAPI_Timer functions expect void-void function pointers
+ */
+void timer1CompareMatch0func( void* ptr )
+{
+
+   uint8_t servoListPosition= 0;
+
+   for(servoListPosition=0; servoListPosition<3; servoListPosition++) {
+      if(AttachedServoList[servoListPosition].servo != EMPTY_POSITION) {
+         gpioWrite(servoMap[AttachedServoList[servoListPosition].servo],TRUE);
+         Timer_SetCompareMatch( 	AttachedServoList[servoListPosition].associatedTimer,
+                                 AttachedServoList[servoListPosition].associatedCompareMatch,
+                                 Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[servoListPosition].value)));
+      }
+   }
+}
+
+void timer1CompareMatch1func( void* ptr )
+{
+   gpioWrite(servoMap[AttachedServoList[0].servo],FALSE);
+}
+
+void timer1CompareMatch2func( void* ptr )
+{
+   gpioWrite(servoMap[AttachedServoList[1].servo],FALSE);
+}
+
+void timer1CompareMatch3func( void* ptr )
+{
+   gpioWrite(servoMap[AttachedServoList[2].servo],FALSE);
+}
+
+void timer2CompareMatch0func( void* ptr )
+{
+   uint8_t servoListPosition= 3;
+
+   for(servoListPosition=3; servoListPosition<6; servoListPosition++) {
+      if(AttachedServoList[servoListPosition].servo != EMPTY_POSITION) {
+         gpioWrite(servoMap[AttachedServoList[servoListPosition].servo],TRUE);
+         Timer_SetCompareMatch( AttachedServoList[servoListPosition].associatedTimer,
+                                AttachedServoList[servoListPosition].associatedCompareMatch,
+                                Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[servoListPosition].value)));
+      }
+   }
+}
+
+void timer2CompareMatch1func( void* ptr )
+{
+   gpioWrite(servoMap[AttachedServoList[3].servo],FALSE);
+}
+
+void timer2CompareMatch2func( void* ptr )
+{
+   gpioWrite(servoMap[AttachedServoList[4].servo],FALSE);
+}
+
+void timer2CompareMatch3func( void* ptr )
+{
+   gpioWrite(servoMap[AttachedServoList[5].servo],FALSE);
+}
+
+void timer3CompareMatch0func( void* ptr )
+{
+
+   uint8_t servoListPosition= 6;
+
+   for(servoListPosition=6; servoListPosition<9; servoListPosition++) {
+      if(AttachedServoList[servoListPosition].servo != EMPTY_POSITION) {
+         gpioWrite(servoMap[AttachedServoList[servoListPosition].servo],TRUE);
+         Timer_SetCompareMatch( AttachedServoList[servoListPosition].associatedTimer,
+                                AttachedServoList[servoListPosition].associatedCompareMatch,
+                                Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[servoListPosition].value)));
+      }
+   }
+}
+
+void timer3CompareMatch1func( void* ptr )
+{
+   gpioWrite( servoMap[AttachedServoList[6].servo], FALSE );
+}
+
+void timer3CompareMatch2func( void* ptr )
+{
+   gpioWrite( servoMap[AttachedServoList[7].servo], FALSE );
+}
+
+void timer3CompareMatch3func( void* ptr )
+{
+   gpioWrite( servoMap[AttachedServoList[8].servo], FALSE );
+}
+
+
+/*
+ * @Brief: Initializes the servo peripheral
+ * @param   none
+ * @return   nothing
+ * @IMPORTANT:   this function uses Timer 1, 2 and 3 to generate the servo signals, so
+ *   they won't be available to use.
+ */
+void servoInitTimers(void)
+{
+   Timer_Init( TIMER1,
+               Timer_microsecondsToTicks(SERVO_COMPLETECYCLE_PERIOD),
+               timer1CompareMatch0func
+             );
+   Timer_Init( TIMER2,
+               Timer_microsecondsToTicks(SERVO_COMPLETECYCLE_PERIOD),
+               timer2CompareMatch0func
+             );
+   Timer_Init( TIMER3,
+               Timer_microsecondsToTicks(SERVO_COMPLETECYCLE_PERIOD),
+               timer3CompareMatch0func
+             );
+}
+
+/*
+ * @brief: adds a servo to the active servos list
+ * @param   servoNumber:   ID of the servo, from 0 to 8
+ * @return: True if servo was successfully attached, False if not.
+ */
+bool_t servoAttach( servoMap_t servoNumber )
+{
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   /* Pin must be configure as Output */
+   gpioConfig( (gpioMap_t)servoMap[servoNumber], GPIO_OUTPUT );
+
+   position = servoIsAttached(servoNumber);
+   if( position==0 ) {
+      position = servoIsAttached(EMPTY_POSITION); /* Searches for the first empty position */
+      if(position) { /* if position==0 => there is no room in the list for another servo */
+         AttachedServoList[position-1].servo = servoNumber;
+         /* Enables the compare match interrupt */
+         Timer_EnableCompareMatch( AttachedServoList[position-1].associatedTimer,
+                                   AttachedServoList[position-1].associatedCompareMatch,
+                                   Timer_microsecondsToTicks(valueToMicroseconds(AttachedServoList[position-1].value)),
+                                   AttachedServoList[position-1].associatedFunction
+                                 );
+         success = TRUE;
+      }
+   }
+
+   return success;
+}
+
+/*
+ * @brief: removes a servo from the active servos list
+ * @param   servoNumber:   ID of the servo, from 0 to 8
+ * @return: True if servo was successfully detached, False if not.
+ */
+bool_t servoDetach( servoMap_t servoNumber )
+{
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = servoIsAttached(servoNumber);
+
+   if(position) {
+      AttachedServoList[position-1].servo = EMPTY_POSITION;
+      AttachedServoList[position-1].value = 0;
+      Timer_DisableCompareMatch( AttachedServoList[position-1].associatedTimer,
+                                 AttachedServoList[position-1].associatedCompareMatch);
+      success = TRUE;
+   }
+   return success;
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief: Initializes the servo peripheral
+ * @param  uint8_t servoNumber
+ * @param  uint8_t config
+ * @return   nothing
+ * @IMPORTANT:   this function uses Timer 1, 2 and 3 to generate the servo signals, so
+ *   they won't be available to use.
+ */
+bool_t servoInit( servoMap_t servoNumber, servoInit_t config )
+{
+
+   bool_t ret_val = 1;
+
+   switch(config) {
+
+   case SERVO_ENABLE:
+      servoInitTimers();
+      break;
+
+   case SERVO_DISABLE:
+      ret_val = 0;
+      break;
+
+   case SERVO_ENABLE_OUTPUT:
+      ret_val = servoAttach( servoNumber );
+      break;
+
+   case SERVO_DISABLE_OUTPUT:
+      ret_val = servoDetach( servoNumber );
+      break;
+
+   default:
+      ret_val = 0;
+      break;
+   }
+
+   return ret_val;
+}
+
+/*
+ * @brief:   Tells if the servo is currently active, and its position
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return:   position (1 ~ SERVO_TOTALNUMBER), 0 if the element was not found.
+ */
+uint8_t servoIsAttached( servoMap_t servoNumber )
+{
+
+   uint8_t position = 0, positionInList = 0;
+   while ( (position < SERVO_TOTALNUMBER) &&
+           (servoNumber != AttachedServoList[position].servo) ) {
+      position++;
+   }
+
+   if (position < SERVO_TOTALNUMBER) {
+      positionInList = position + 1;
+   } else {
+      positionInList = 0;
+   }
+
+   return positionInList;
+}
+
+/*
+ * @brief: read the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @return: value of the servo (0 ~ 180).
+ *   If an error ocurred, return = EMPTY_POSITION = 255
+ */
+uint16_t servoRead( servoMap_t servoNumber )
+{
+
+   uint8_t position = 0, value = 0;
+   position = servoIsAttached(servoNumber);
+
+   if(position) {
+      value = AttachedServoList[position-1].value;
+   } else {
+      value = EMPTY_POSITION;
+   }
+   return value;
+}
+
+/*
+ * @brief: change the value of the servo
+ * @param:   servoNumber:   ID of the servo, from 0 to 8
+ * @param:   value:   value of the servo, from 0 to 180
+ * @return: True if the value was successfully changed, False if not.
+ */
+bool_t servoWrite( servoMap_t servoNumber, uint16_t angle )
+{
+
+   bool_t success = FALSE;
+   uint8_t position = 0;
+
+   position = servoIsAttached(servoNumber);
+
+   if(position && (angle>=0 && angle<=180)) {
+      AttachedServoList[position-1].value = angle;
+      success = TRUE;
+   }
+
+   return success;
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_sleep.c ./libs/sapi/sapi_v0.5.1/src/sapi_sleep.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_sleep.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_sleep.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,67 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-08-15 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_sleep.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief: Sleep mode, sleep until next interrupt occur.
+ * @param  nothing
+ * @return nothing
+ */
+void sleepUntilNextInterrupt( void )
+{
+
+   /* Instert an assembly instruction wfi (wait for interrupt) */
+   __asm volatile( "wfi" );
+
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_spi.c ./libs/sapi/sapi_v0.5.1/src/sapi_spi.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_spi.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_spi.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,138 @@
+/* Copyright 2016, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * modification history (new versions first)
+ * -----------------------------------------------------------
+ * 2016-05-02   v0.0.1   ENP   First version
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_spi.h"
+#include "chip.h"
+
+/*==================[macros and definitions]=================================*/
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+bool_t spiInit( spiMap_t spi )
+{
+
+   bool_t retVal = TRUE;
+
+   if( spi == SPI0 ) {
+
+      /* Set up clock and power for SSP1 module */
+      // Configure SSP SSP1 pins
+      Chip_SCU_PinMuxSet(0xf, 4, (SCU_MODE_PULLUP | SCU_MODE_FUNC0)); // CLK0
+      Chip_SCU_PinMuxSet(0x1, 3, (SCU_MODE_PULLUP | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC5)); // MISO1
+      Chip_SCU_PinMuxSet(0x1, 4, (SCU_MODE_PULLUP | SCU_MODE_FUNC5)); // MOSI1
+
+      Chip_SCU_PinMuxSet(0x6, 1, (SCU_MODE_PULLUP | SCU_MODE_FUNC0)); // CS1 configured as GPIO
+      Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, 3, 0);
+
+      // Initialize SSP Peripheral
+      Chip_SSP_Init( LPC_SSP1 );
+      Chip_SSP_Enable( LPC_SSP1 );
+
+   } else {
+      retVal = FALSE;
+   }
+
+   return retVal;
+}
+
+
+bool_t spiRead( spiMap_t spi, uint8_t* buffer, uint32_t bufferSize )
+{
+
+   bool_t retVal = TRUE;
+
+   Chip_SSP_DATA_SETUP_T xferConfig;
+
+   xferConfig.tx_data = NULL;
+   xferConfig.tx_cnt  = 0;
+   xferConfig.rx_data = buffer;
+   xferConfig.rx_cnt  = 0;
+   xferConfig.length  = bufferSize;
+
+   if( spi == SPI0 ) {
+      Chip_SSP_RWFrames_Blocking( LPC_SSP1, &xferConfig );
+   } else {
+      retVal = FALSE;
+   }
+
+   return retVal;
+}
+
+
+bool_t spiWrite( spiMap_t spi, uint8_t* buffer, uint32_t bufferSize)
+{
+
+   bool_t retVal = TRUE;
+
+   Chip_SSP_DATA_SETUP_T xferConfig;
+
+   xferConfig.tx_data = buffer;
+   xferConfig.tx_cnt  = 0;
+   xferConfig.rx_data = NULL;
+   xferConfig.rx_cnt  = 0;
+   xferConfig.length  = bufferSize;
+
+   if( spi == SPI0 ) {
+      Chip_SSP_RWFrames_Blocking( LPC_SSP1, &xferConfig );
+   } else {
+      retVal = FALSE;
+   }
+
+   return retVal;
+}
+
+
+/*==================[ISR external functions definition]======================*/
+
+
+
+/** @} doxygen end group definition */
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_tick.c ./libs/sapi/sapi_v0.5.1/src/sapi_tick.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_tick.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_tick.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,188 @@
+/* Copyright 2015-2018, Eric Pernia.
+ * Copyright 2018, Martin Ribelotta.
+ * Copyright 2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_tick.h"
+
+#ifdef TICK_OVER_RTOS
+   #ifdef USE_FREERTOS
+      #include <FreeRTOS.h>
+      #include <timers.h>
+   #endif
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#ifndef TICK_OVER_RTOS
+   #define tickerCallback SysTick_Handler
+#endif
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+// This global variable holds the tick count
+volatile tick_t tickCounter;
+
+volatile tick_t tickRateMS;
+
+volatile callBackFuncPtr_t tickHookFunction = NULL;
+void* callBackFuncParams = NULL;
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+void tickerCallback( void );
+
+// Tick Initialization and rate configuration from 1 to 50 ms
+bool_t tickInit( tick_t tickRateMSvalue )
+{
+   #ifndef TICK_OVER_RTOS
+      bool_t ret_val = 1;
+      tick_t tickRateHz = 0;
+      if( tickRateMSvalue == 0 ) {
+         tickPowerSet( OFF );
+         ret_val = 0;
+      } else {
+         if( (tickRateMSvalue >= 1) && (tickRateMSvalue <= 50) ) {
+            tickRateMS = tickRateMSvalue;
+            /*
+            tickRateHz = 1000 => 1000 ticks per second =>  1 ms tick
+            tickRateHz =  200 =>  200 ticks per second =>  5 ms tick
+            tickRateHz =  100 =>  100 ticks per second => 10 ms tick
+            tickRateHz =   20 =>   20 ticks per second => 50 ms tick
+            */
+            // Init SysTick interrupt, tickRateHz ticks per second
+            SysTick_Config( SystemCoreClock * tickRateMSvalue / 1000 );
+            /*
+            if ( SysTick_Config( CMU_ClockFreqGet(cmuClock_CORE) / tickRateHz) ){
+               //DEBUG_BREAK;
+               ret_val = 0;
+            }
+            */
+            tickPowerSet( ON );
+         } else {
+            // Error, tickRateMS variable not in range (1 <= tickRateMS <= 50)
+            ret_val = 0;
+         }
+      }
+      return ret_val;
+   #else
+      #ifdef USE_FREERTOS
+         static StaticTimer_t tickerObject;
+         TimerHandle_t h = xTimerCreateStatic( "tikcerTimer",
+                                               (TickType_t)(tickRateMSvalue),
+                                               pdTRUE,
+                                               (void * const) (0),
+                                               (TimerCallbackFunction_t)(tickerCallback),
+                                               &tickerObject 
+                                             );
+         if (h == NULL)
+            return 0;
+         return xTimerStart(h, 0) == pdPASS;
+      #else
+         #warning "Unknown RTOS. Ticker disabled"
+            return 0;
+      #endif
+   #endif
+}
+
+// Read Tick Counter
+tick_t tickRead( void )
+{
+   return tickCounter;
+}
+
+// Write Tick Counter
+void tickWrite( tick_t ticks )
+{
+   tickCounter = ticks;
+}
+
+// Tick interrupt callback
+bool_t tickCallbackSet( callBackFuncPtr_t tickCallback, void* tickCallbackParams )
+{
+   bool_t retVal = TRUE;
+   if( tickCallback != NULL ) {
+      tickHookFunction = tickCallback;
+   } else {
+      retVal = FALSE;
+   }
+   if( tickCallbackParams != NULL ) {
+      callBackFuncParams = tickCallbackParams;
+   } else {
+      retVal &= FALSE;
+   }
+   return retVal;
+}
+
+// Enable or disable the peripheral energy and clock
+void tickPowerSet( bool_t power )
+{
+   if( power ) {
+      // Enable SysTick IRQ and SysTick Timer
+      SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
+                      SysTick_CTRL_TICKINT_Msk   |
+                      SysTick_CTRL_ENABLE_Msk;
+   } else {
+      // Disable SysTick IRQ and SysTick Timer
+      SysTick->CTRL = 0x0000000;
+   }
+}
+
+/*==================[ISR external functions definition]======================*/
+
+//__attribute__ ((section(".after_vectors")))
+
+// SysTick Timer ISR Handler
+void tickerCallback( void )   // Before SysTick_Handler
+{
+   // Increment Tick counters
+   tickCounter++;
+   // Execute Tick Hook function if pointer is not NULL
+   if( (tickHookFunction != NULL) ) {
+      (* tickHookFunction )( callBackFuncParams );
+   }
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_tick.c.txt ./libs/sapi/sapi_v0.5.1/src/sapi_tick.c.txt
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_tick.c.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_tick.c.txt	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,153 @@
+/* Copyright 2015-2018, Eric Pernia.
+ * Copyright 2018, Martin Ribelotta.
+ * Copyright 2018, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part of CIAA Firmware.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2015-09-23 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_tick.h"
+
+#ifdef TICK_OVER_RTOS
+#ifdef USE_FREERTOS
+#include <FreeRTOS.h>
+#include <timers.h>
+#endif
+#endif
+
+/*==================[macros and definitions]=================================*/
+
+#ifndef TICK_OVER_RTOS
+#define tickerCallback SysTick_Handler
+#endif
+
+/*==================[internal data declaration]==============================*/
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+/*==================[external data definition]===============================*/
+
+/* This global variable holds the tick count */
+volatile tick_t tickCounter;
+volatile tick_t tickRateMS;
+volatile sAPI_FuncPtr_t tickHookFunction = sAPI_NullFuncPtr;
+
+/*==================[internal functions definition]==========================*/
+
+/*==================[external functions definition]==========================*/
+
+// #define TICK_OVER_RTOS
+// #define USE_FREERTOS
+
+void tickerCallback(void);
+
+/* Tick rate configuration 1 to 50 ms */
+bool_t tickConfig( tick_t tickRateMSvalue, sAPI_FuncPtr_t tickHook )
+{
+#ifndef TICK_OVER_RTOS
+   bool_t ret_val = 1;
+   tick_t tickRateHz = 0;
+
+   if( tickHook ) {
+      tickHookFunction = tickHook;
+   }
+
+   if( (tickRateMSvalue >= 1) && (tickRateMSvalue <= 50) ) {
+
+      tickRateMS = tickRateMSvalue;
+
+      /*
+      tickRateHz = 1000 => 1000 ticks per second =>  1 ms tick
+      tickRateHz =  200 =>  200 ticks per second =>  5 ms tick
+      tickRateHz =  100 =>  100 ticks per second => 10 ms tick
+      tickRateHz =   20 =>   20 ticks per second => 50 ms tick
+      */
+      tickRateHz = 1000 / tickRateMSvalue;
+
+      /* Init SysTick interrupt, tickRateHz ticks per second */
+      SysTick_Config( SystemCoreClock / tickRateHz);
+   } else {
+      /* Error, tickRateMS variable not in range (1 <= tickRateMS <= 50) */
+      ret_val = 0;
+   }
+
+   return ret_val;
+#else
+#ifdef USE_FREERTOS
+   static StaticTimer_t tickerObject;
+   TimerHandle_t h = xTimerCreateStatic("tikcerTimer",
+                                        (TickType_t)(tickRateMSvalue),
+                                        pdTRUE,
+                                        (void * const) (0),
+                                        (TimerCallbackFunction_t)(tickerCallback),
+                                        &tickerObject );
+   if (h == NULL)
+      return 0;
+   return xTimerStart(h, 0) == pdPASS;
+#else
+#warning "Unknown RTOS. Ticker disabled"
+   return 0;
+#endif
+#endif
+}
+
+/* Read Tick Counter */
+tick_t tickRead( void )
+{
+   return tickCounter;
+}
+
+
+/* Write Tick Counter */
+void tickWrite( tick_t ticks )
+{
+   tickCounter = ticks;
+}
+
+/*==================[ISR external functions definition]======================*/
+
+//__attribute__ ((section(".after_vectors")))
+
+/* SysTick Timer ISR Handler */
+void tickerCallback(void)
+{
+   tickCounter++;
+
+   /* Execute Tick Hook function */
+   (* tickHookFunction )( 0 );
+}
+
+/*==================[end of file]============================================*/
\ No hay ningún carácter de nueva línea al final del archivo
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_timer.c ./libs/sapi/sapi_v0.5.1/src/sapi_timer.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_timer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_timer.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,301 @@
+/* Copyright 2016, Ian Olivieri
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-10 */
+
+/*
+ * For more information about the Timer peripheral, refer to the Chapter 32 of
+ * the LPC43xx user manual
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_timer.h"
+
+//#include "chip.h"
+//#include "timer_18xx_43xx.h"
+/* Specific modules used:
+   #include "timer_18xx_43xx.h" for Chip_TIMER functions
+   #include "rgu_18xx_43xx.h" for Chip_RGU functions
+   #include "core_cm4.h" for NVIC functions
+*/
+
+/*==================[macros and definitions]=================================*/
+
+#define LPC4337_MAX_FREC 204000000 /* Microcontroller frequency */
+#define MAX_SYSCALL_INTERRUPT_PRIORITY 5
+
+/*==================[internal data declaration]==============================*/
+
+typedef struct {
+   LPC_TIMER_T *name;
+   uint32_t RGU; /* Reset Generator Unit */
+   uint32_t IRQn;
+} timerStaticData_t;
+
+typedef struct {
+   callBackFuncPtr_t timerCompareMatchFunctionPointer[4];
+} timerDinamicData_t;
+
+/*==================[internal functions declaration]=========================*/
+
+static void errorOcurred( void* ptr );
+static void doNothing( void* ptr );
+
+/*==================[internal data definition]===============================*/
+
+/*Timers Static Data, given by the uC libraries*/
+static const timerStaticData_t timer_sd[4] = {
+   { LPC_TIMER0, RGU_TIMER0_RST, TIMER0_IRQn },
+   { LPC_TIMER1, RGU_TIMER1_RST, TIMER1_IRQn },
+   { LPC_TIMER2, RGU_TIMER2_RST, TIMER2_IRQn },
+   { LPC_TIMER3, RGU_TIMER3_RST, TIMER3_IRQn }
+};
+
+/*Timers dynamic data. Function pointers and Compare match frequencies, which can vary.
+ * This is the default initialization*/
+static timerDinamicData_t timer_dd[4] = {
+   doNothing, errorOcurred, errorOcurred, errorOcurred,
+   doNothing, errorOcurred, errorOcurred, errorOcurred,
+   doNothing, errorOcurred, errorOcurred, errorOcurred,
+   doNothing, errorOcurred, errorOcurred, errorOcurred
+};
+
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+/* Causes:
+ * User forgot to initialize the functions for the compare match interrupt on Timer_init call
+ */
+static void errorOcurred( void* ptr )
+{
+   while(1);
+}
+
+static void doNothing( void* ptr )
+{
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief   Initialize Timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   ticks:   Number of ticks required to finish the cycle.
+ * @param   voidFunctionPointer:   function to be executed at the end of the timer cycle
+ * @return   nothing
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_Init( uint8_t timerNumber, uint32_t ticks,
+                 callBackFuncPtr_t voidFunctionPointer )
+{
+   /* Source:
+   http://docs.lpcware.com/lpcopen/v1.03/lpc18xx__43xx_2examples_2periph_2periph__blinky_2blinky_8c_source.html */
+
+   /*If timer period = CompareMatch0 Period = 0 => ERROR*/
+   if (ticks==0) {
+      errorOcurred(0);
+   }
+
+   /* Enable timer clock and reset it */
+   Chip_TIMER_Init(timer_sd[timerNumber].name);
+   Chip_RGU_TriggerReset(timer_sd[timerNumber].RGU);
+   while (Chip_RGU_InReset(timer_sd[timerNumber].RGU)) {}
+   Chip_TIMER_Reset(timer_sd[timerNumber].name);
+
+   /* Update the defalut function pointer name of the Compare match 0*/
+   timer_dd[timerNumber].timerCompareMatchFunctionPointer[TIMERCOMPAREMATCH0] = voidFunctionPointer;
+
+   /* Initialize compare match with the specified ticks (number of counts needed to clear the match counter) */
+   Chip_TIMER_MatchEnableInt( timer_sd[timerNumber].name, TIMERCOMPAREMATCH0 );
+   Chip_TIMER_SetMatch( timer_sd[timerNumber].name, TIMERCOMPAREMATCH0, ticks );
+
+   /* Makes Timer Match 0 period the timer period*/
+   Chip_TIMER_ResetOnMatchEnable( timer_sd[timerNumber].name, TIMERCOMPAREMATCH0 );
+
+   /*Enable timer*/
+   Chip_TIMER_Enable(timer_sd[timerNumber].name);
+
+   /* Enable timer interrupt */
+   NVIC_SetPriority(timer_sd[timerNumber].IRQn, MAX_SYSCALL_INTERRUPT_PRIORITY+1);
+   NVIC_EnableIRQ(timer_sd[timerNumber].IRQn);
+   NVIC_ClearPendingIRQ(timer_sd[timerNumber].IRQn);
+}
+
+/*
+ * @Brief   Disables timer peripheral
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @return   nothing
+ */
+void Timer_DeInit( uint8_t timerNumber )
+{
+   NVIC_DisableIRQ(timer_sd[timerNumber].IRQn);
+   Chip_TIMER_Disable(timer_sd[timerNumber].name);
+   Chip_TIMER_DeInit(timer_sd[timerNumber].name);
+}
+
+/*
+ * @Brief   Converts a value in microseconds (uS = 1x10^-6 sec) to ticks
+ * @param   uS:   Value in microseconds
+ * @return   Equivalent in Ticks for the LPC4337
+ * @note   Can be used for the second parameter in the Timer_init
+ */
+uint32_t Timer_microsecondsToTicks( uint32_t uS )
+{
+   return (uS*(LPC4337_MAX_FREC/1000000));
+}
+
+/*
+ * @Brief   Enables a compare match in a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @param   ticks:   Number of ticks required to reach the compare match.
+ * @param   voidFunctionPointer: function to be executed when the compare match is reached
+ * @return   None
+ * @note   For the 'ticks' parameter, see function Timer_microsecondsToTicks
+ */
+void Timer_EnableCompareMatch( uint8_t timerNumber, uint8_t compareMatchNumber,
+                               uint32_t ticks,
+                               callBackFuncPtr_t voidFunctionPointer )
+{
+
+   timer_dd[timerNumber].timerCompareMatchFunctionPointer[compareMatchNumber] = voidFunctionPointer;
+
+   Chip_TIMER_MatchEnableInt(timer_sd[timerNumber].name, compareMatchNumber);
+   Chip_TIMER_SetMatch(timer_sd[timerNumber].name, compareMatchNumber, ticks);
+}
+
+/*
+ * @brief   Disables a compare match of a timer
+ * @param   timerNumber:   Timer number, 0 to 3
+ * @param   compareMatchNumber:   Compare match number, 1 to 3
+ * @return   None
+ */
+void Timer_DisableCompareMatch( uint8_t timerNumber,
+                                uint8_t compareMatchNumber )
+{
+
+   timer_dd[timerNumber].timerCompareMatchFunctionPointer[compareMatchNumber] = doNothing;
+
+   Chip_TIMER_ClearMatch(timer_sd[timerNumber].name, compareMatchNumber);
+   Chip_TIMER_MatchDisableInt(timer_sd[timerNumber].name, compareMatchNumber);
+}
+
+/*
+ * @Purpose:   Allows the user to change the compare value nº
+ *    'compareMatchNumber' of timer 'timerNumber'.  This is specially useful to
+ *    generate square waves if used in the function for the TIMERCOMPAREMATCH0
+ *    (because that compare match resets the timer counter), which will be
+ *    passed as a parameter when initializing a timer
+ * @note:  The selected time (3rd parameter) must be less than
+ *    TIMERCOMPAREMATCH0's compareMatchTime_uS for the compare match to make the
+ *    interruption
+ */
+void Timer_SetCompareMatch( uint8_t timerNumber,
+                            uint8_t compareMatchNumber,
+                            uint32_t ticks )
+{
+   Chip_TIMER_SetMatch(timer_sd[timerNumber].name, compareMatchNumber,ticks);
+}
+
+/*==================[ISR external functions definition]======================*/
+/*
+ * @Brief:   Executes the functions passed by parameter in the Timer_init,
+ *   at the chosen frequencies
+ */
+void TIMER0_IRQHandler(void)
+{
+
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ) {
+      if( Chip_TIMER_MatchPending(LPC_TIMER0, compareMatchNumber) ) {
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER0].timerCompareMatchFunctionPointer[compareMatchNumber])(0);
+         Chip_TIMER_ClearMatch(LPC_TIMER0, compareMatchNumber);
+      }
+   }
+}
+
+void TIMER1_IRQHandler( void )
+{
+
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ) {
+      if( Chip_TIMER_MatchPending(LPC_TIMER1, compareMatchNumber) ) {
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER1].timerCompareMatchFunctionPointer[compareMatchNumber])(0);
+         Chip_TIMER_ClearMatch(LPC_TIMER1, compareMatchNumber);
+      }
+   }
+}
+
+void TIMER2_IRQHandler( void )
+{
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ) {
+      if( Chip_TIMER_MatchPending(LPC_TIMER2, compareMatchNumber) ) {
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER2].timerCompareMatchFunctionPointer[compareMatchNumber])(0);
+         Chip_TIMER_ClearMatch(LPC_TIMER2, compareMatchNumber);
+      }
+   }
+}
+
+/*fixme __attribute__ ((section(".after_vectors")))*/
+void TIMER3_IRQHandler( void )
+{
+
+   uint8_t compareMatchNumber = 0;
+
+   for( compareMatchNumber = TIMERCOMPAREMATCH0;
+        compareMatchNumber <= TIMERCOMPAREMATCH3;
+        compareMatchNumber++ ) {
+      if (Chip_TIMER_MatchPending(LPC_TIMER3, compareMatchNumber)) {
+         /*Run the functions saved in the timer dynamic data structure*/
+         (*timer_dd[TIMER3].timerCompareMatchFunctionPointer[compareMatchNumber])(0);
+         Chip_TIMER_ClearMatch(LPC_TIMER3, compareMatchNumber);
+      }
+   }
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_uart.c ./libs/sapi/sapi_v0.5.1/src/sapi_uart.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_uart.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_uart.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,587 @@
+/* Copyright 2014, Pablo Ridolfi (UTN-FRBA).
+ * Copyright 2014, Juan Cecconi.
+ * Copyright 2015-2017, Eric Pernia.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Date: 2016-02-26 */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_uart.h"
+
+#include "string.h"
+#include "sapi_circularBuffer.h"
+
+/*==================[macros]=================================================*/
+
+/*==================[typedef]================================================*/
+
+typedef struct {
+   LPC_USART_T*      uartAddr;
+   lpc4337ScuPin_t   txPin;
+   lpc4337ScuPin_t   rxPin;
+   IRQn_Type         uartIrqAddr;
+} uartLpcInit_t;
+
+/*==================[internal data declaration]==============================*/
+
+static volatile callBackFuncPtr_t rxIsrCallbackUART0 = 0;
+static volatile callBackFuncPtr_t rxIsrCallbackUART2 = 0;
+static volatile callBackFuncPtr_t rxIsrCallbackUART3 = 0;
+
+static volatile callBackFuncPtr_t txIsrCallbackUART0 = 0;
+static volatile callBackFuncPtr_t txIsrCallbackUART2 = 0;
+static volatile callBackFuncPtr_t txIsrCallbackUART3 = 0;
+
+static const uartLpcInit_t lpcUarts[] = {
+// { uartAddr, { txPort, txpin, txfunc }, { rxPort, rxpin, rxfunc }, uartIrqAddr  },
+   // UART_GPIO (GPIO1 = U0_TXD, GPIO2 = U0_RXD)
+   { LPC_USART0, { 6, 4, FUNC2 }, { 6, 5, FUNC2 }, USART0_IRQn }, // 0
+   // UART_485 (RS485/Profibus)
+   { LPC_USART0, { 9, 5, FUNC7 }, { 9, 6, FUNC7 }, USART0_IRQn }, // 1
+   // UART not routed
+   {  LPC_UART1, { 0, 0, 0     }, { 0, 0, 0     }, UART1_IRQn  }, // 2
+   // UART_USB
+   { LPC_USART2, { 7, 1, FUNC6 }, { 7, 2, FUNC6 }, USART2_IRQn }, // 3
+   // UART_ENET
+   { LPC_USART2, { 1,15, FUNC1 }, { 1,16, FUNC1 }, USART2_IRQn }, // 4
+   // UART_232
+   { LPC_USART3, { 2, 3, FUNC2 }, { 2, 4, FUNC2 }, USART3_IRQn }  // 5
+};
+
+static const lpc4337ScuPin_t lpcUart485DirPin = {
+   6, 2, FUNC2
+};
+
+
+
+/*
+   callBackFuncPtr_t txIsrCallback;
+   callBackFuncPtr_t rxIsrCallback;
+*/
+
+/*==================[internal functions declaration]=========================*/
+
+static void uartProcessIRQ( uartMap_t uart );
+
+/*==================[internal functions definition]==========================*/
+
+static void uartProcessIRQ( uartMap_t uart )
+{
+   uint8_t status = Chip_UART_ReadLineStatus( lpcUarts[uart].uartAddr );
+
+   // Rx Interrupt
+   if(status & UART_LSR_RDR) { // uartRxReady
+      // Execute callback
+      if( ( uart == UART_GPIO ) && (rxIsrCallbackUART0 != 0) )
+         (*rxIsrCallbackUART0)(0);
+
+      if( ( uart == UART_USB )  && (rxIsrCallbackUART2 != 0) )
+         (*rxIsrCallbackUART2)(0);
+
+      if( ( uart == UART_232 )  && (rxIsrCallbackUART3 != 0) )
+         (*rxIsrCallbackUART3)(0);
+   }
+
+   // Tx Interrupt
+   if( ( status & UART_LSR_THRE ) && // uartTxReady
+       ( Chip_UART_GetIntsEnabled( lpcUarts[uart].uartAddr ) & UART_IER_THREINT ) ) {
+
+      // Execute callback
+      if( ( uart == UART_GPIO ) && (txIsrCallbackUART0 != 0) )
+         (*txIsrCallbackUART0)(0);
+
+      if( ( uart == UART_USB )  && (txIsrCallbackUART2 != 0) )
+         (*txIsrCallbackUART2)(0);
+
+      if( ( uart == UART_232 )  && (txIsrCallbackUART3 != 0) )
+         (*txIsrCallbackUART3)(0);
+   }
+}
+
+/*==================[external data declaration]==============================*/
+
+/*==================[external functions declaration]=========================*/
+
+// Check for Receive a given pattern
+
+waitForReceiveStringOrTimeoutState_t waitForReceiveStringOrTimeout(
+   uartMap_t uart, waitForReceiveStringOrTimeout_t* instance )
+{
+
+   uint8_t receiveByte;
+   //char receiveBuffer[100];
+
+   switch( instance->state ) {
+
+   case UART_RECEIVE_STRING_CONFIG:
+
+      delayInit( &(instance->delay), instance->timeout );
+
+      instance->stringIndex = 0;
+
+      instance->state = UART_RECEIVE_STRING_RECEIVING;
+
+      break;
+
+   case UART_RECEIVE_STRING_RECEIVING:
+
+      if( uartReadByte( uart, &receiveByte ) ) {
+
+         //uartWriteByte( UART_DEBUG, receiveByte ); // TODO: DEBUG
+         /*            if( (instance->stringIndex) <= 100 ){
+                        receiveBuffer[instance->stringIndex] = receiveByte;
+                     }
+         */
+         if( (instance->string)[(instance->stringIndex)] == receiveByte ) {
+
+            (instance->stringIndex)++;
+
+            if( (instance->stringIndex) == (instance->stringSize - 1) ) {
+               instance->state = UART_RECEIVE_STRING_RECEIVED_OK;
+
+//                  receiveBuffer[instance->stringIndex] = '\0';
+
+               //uartWriteString( UART_DEBUG, receiveBuffer ); // TODO: DEBUG
+               //uartWriteString( UART_DEBUG, "\r\n" );        // TODO: DEBUG
+            }
+
+         }
+
+      }
+
+      if( delayRead( &(instance->delay) ) ) {
+         instance->state = UART_RECEIVE_STRING_TIMEOUT;
+         //uartWriteString( UART_DEBUG, "\r\n" ); // TODO: DEBUG
+      }
+
+      break;
+
+   case UART_RECEIVE_STRING_RECEIVED_OK:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+   case UART_RECEIVE_STRING_TIMEOUT:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+   default:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+   }
+
+   return instance->state;
+}
+
+// Recibe bytes hasta que llegue el string patron que se le manda en el
+// parametro string, stringSize es la cantidad de caracteres del string.
+// Devuelve TRUE cuando recibio la cadena patron, si paso el tiempo timeout
+// en milisegundos antes de recibir el patron devuelve FALSE.
+// No almacena los datos recibidos!! Simplemente espera a recibir cierto patron.
+bool_t waitForReceiveStringOrTimeoutBlocking(
+   uartMap_t uart, char* string, uint16_t stringSize, tick_t timeout )
+{
+
+   bool_t retVal = TRUE; // True if OK
+
+   waitForReceiveStringOrTimeout_t waitText;
+   waitForReceiveStringOrTimeoutState_t waitTextState;
+
+   waitTextState = UART_RECEIVE_STRING_CONFIG;
+
+   waitText.state = UART_RECEIVE_STRING_CONFIG;
+   waitText.string =  string;
+   waitText.stringSize = stringSize;
+   waitText.timeout = timeout;
+
+   while( waitTextState != UART_RECEIVE_STRING_RECEIVED_OK &&
+          waitTextState != UART_RECEIVE_STRING_TIMEOUT ) {
+      waitTextState = waitForReceiveStringOrTimeout( uart, &waitText );
+   }
+
+   if( waitTextState == UART_RECEIVE_STRING_TIMEOUT ) {
+      retVal = FALSE;
+   }
+
+   return retVal;
+}
+
+
+// Store bytes until receive a given pattern
+waitForReceiveStringOrTimeoutState_t receiveBytesUntilReceiveStringOrTimeout(
+   uartMap_t uart, waitForReceiveStringOrTimeout_t* instance,
+   char* receiveBuffer, uint32_t* receiveBufferSize )
+{
+
+   uint8_t receiveByte;
+   static uint32_t i = 0;
+   //uint32_t j = 0;
+   //uint32_t savedReceiveBufferSize = *receiveBufferSize;
+
+   switch( instance->state ) {
+
+   case UART_RECEIVE_STRING_CONFIG:
+
+      delayInit( &(instance->delay), instance->timeout );
+
+      instance->stringIndex = 0;
+      i = 0;
+
+      instance->state = UART_RECEIVE_STRING_RECEIVING;
+
+      break;
+
+   case UART_RECEIVE_STRING_RECEIVING:
+
+      if( uartReadByte( uart, &receiveByte ) ) {
+
+         //uartWriteByte( UART_DEBUG, receiveByte ); // TODO: DEBUG
+         if( i < *receiveBufferSize ) {
+            receiveBuffer[i] = receiveByte;
+            i++;
+         } else {
+            instance->state = UART_RECEIVE_STRING_FULL_BUFFER;
+            *receiveBufferSize = i;
+            i = 0;
+            return instance->state;
+         }
+
+         if( (instance->string)[(instance->stringIndex)] == receiveByte ) {
+
+            (instance->stringIndex)++;
+
+            if( (instance->stringIndex) == (instance->stringSize - 1) ) {
+               instance->state = UART_RECEIVE_STRING_RECEIVED_OK;
+               *receiveBufferSize = i;
+               /*
+               // TODO: For debug purposes
+               for( j=0; j<i; j++ ){
+                  uartWriteByte( UART_DEBUG, receiveBuffer[j] );
+               }
+               uartWriteString( UART_DEBUG, "\r\n" );
+               */
+               i = 0;
+            }
+
+         }
+
+      }
+
+      if( delayRead( &(instance->delay) ) ) {
+         instance->state = UART_RECEIVE_STRING_TIMEOUT;
+         //uartWriteString( UART_DEBUG, "\r\n" ); // TODO: DEBUG
+         *receiveBufferSize = i;
+         i = 0;
+      }
+
+      break;
+
+   case UART_RECEIVE_STRING_RECEIVED_OK:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+   case UART_RECEIVE_STRING_TIMEOUT:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+   case UART_RECEIVE_STRING_FULL_BUFFER:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+
+   default:
+      instance->state = UART_RECEIVE_STRING_CONFIG;
+      break;
+   }
+
+   return instance->state;
+}
+
+// Guarda todos los bytes que va recibiendo hasta que llegue el string
+// patron que se le manda en el parametro string, stringSize es la cantidad
+// de caracteres del string.
+// receiveBuffer es donde va almacenando los caracteres recibidos y
+// receiveBufferSize es el tamaño de buffer receiveBuffer.
+// Devuelve TRUE cuando recibio la cadena patron, si paso el tiempo timeout
+// en milisegundos antes de recibir el patron devuelve FALSE.
+bool_t receiveBytesUntilReceiveStringOrTimeoutBlocking(
+   uartMap_t uart, char* string, uint16_t stringSize,
+   char* receiveBuffer, uint32_t* receiveBufferSize,
+   tick_t timeout )
+{
+
+   bool_t retVal = TRUE; // True if OK
+
+   waitForReceiveStringOrTimeout_t waitText;
+   waitForReceiveStringOrTimeoutState_t waitTextState;
+
+   waitTextState = UART_RECEIVE_STRING_CONFIG;
+
+   waitText.state = UART_RECEIVE_STRING_CONFIG;
+   waitText.string =  string;
+   waitText.stringSize = stringSize;
+   waitText.timeout = timeout;
+
+   while( waitTextState != UART_RECEIVE_STRING_RECEIVED_OK &&
+          waitTextState != UART_RECEIVE_STRING_TIMEOUT ) {
+      waitTextState = receiveBytesUntilReceiveStringOrTimeout(
+                         uart, &waitText,
+                         receiveBuffer, receiveBufferSize );
+   }
+
+   if( waitTextState == UART_RECEIVE_STRING_TIMEOUT ) {
+      retVal = FALSE;
+   }
+
+   return retVal;
+}
+
+//-------------------------------------------------------------
+
+// UART RX Interrupt Enable/Disable
+void uartRxInterruptSet( uartMap_t uart, bool_t enable )
+{
+   if( enable ) {
+      // Enable UART Receiver Buffer Register Interrupt
+      Chip_UART_IntEnable( lpcUarts[uart].uartAddr, UART_IER_RBRINT );
+      // Enable UART line status interrupt. LPC43xx User manual page 1118
+      //NVIC_SetPriority( lpcUarts[uart].uartIrqAddr, 6 );
+      // Enable Interrupt for UART channel
+      NVIC_EnableIRQ( lpcUarts[uart].uartIrqAddr );
+   } else {
+      // Disable UART Receiver Buffer Register Interrupt
+      Chip_UART_IntDisable( lpcUarts[uart].uartAddr, UART_IER_RBRINT );
+      // Disable Interrupt for UART channel
+      NVIC_DisableIRQ( lpcUarts[uart].uartIrqAddr );
+   }
+}
+
+// UART TX Interrupt Enable/Disable
+void uartTxInterruptSet( uartMap_t uart, bool_t enable )
+{
+   if( enable ) {
+      // Enable THRE irq (TX)
+      Chip_UART_IntEnable( lpcUarts[uart].uartAddr, UART_IER_THREINT );
+      NVIC_EnableIRQ( lpcUarts[uart].uartIrqAddr );
+   } else {
+      // Disable THRE irq (TX)
+      Chip_UART_IntDisable( lpcUarts[uart].uartAddr, UART_IER_THREINT );
+      NVIC_DisableIRQ( lpcUarts[uart].uartIrqAddr );
+   }
+}
+
+// UART RX Interrupt set callback function that is excecuted when event ocurrs
+void uartRxInterruptCallbackSet(
+   uartMap_t uart,                  // UART
+   callBackFuncPtr_t rxIsrCallback  // pointer to function
+)
+{
+   if( rxIsrCallback != 0 ) {
+      // Set callback
+      if( uart == UART_GPIO ) rxIsrCallbackUART0 = rxIsrCallback;
+      if( uart == UART_485  ) rxIsrCallbackUART0 = rxIsrCallback;
+      if( uart == UART_USB  ) rxIsrCallbackUART2 = rxIsrCallback;
+      if( uart == UART_ENET ) rxIsrCallbackUART2 = rxIsrCallback;
+      if( uart == UART_232  ) rxIsrCallbackUART3 = rxIsrCallback;
+   }
+}
+
+// UART TX Interrupt set callback function that is excecuted when event ocurrs
+void uartTxInterruptCallbackSet(
+   uartMap_t uart,                  // UART
+   callBackFuncPtr_t txIsrCallback  // pointer to function
+)
+{
+   if( txIsrCallback != 0 ) {
+      // Set callback
+      if( uart == UART_GPIO ) txIsrCallbackUART0 = txIsrCallback;
+      if( uart == UART_485  ) txIsrCallbackUART0 = txIsrCallback;
+      if( uart == UART_USB  ) txIsrCallbackUART2 = txIsrCallback;
+      if( uart == UART_ENET ) txIsrCallbackUART2 = txIsrCallback;
+      if( uart == UART_232  ) txIsrCallbackUART3 = txIsrCallback;
+   }
+}
+
+// disable tx and rx interrupt
+//Chip_UART_IntDisable( LPC_USART2,
+//                      UART_IER_THREINT |
+//                      UART_IER_RBRINT );
+
+//case STARTTX:
+// disable THRE irq (TX)
+//Chip_UART_IntDisable((LPC_USART_T *)device->loLayer, UART_IER_THREINT);
+// this one calls write
+//ciaaDriverUart_txConfirmation(device);
+// enable THRE irq (TX)
+//Chip_UART_IntEnable((LPC_USART_T *)device->loLayer, UART_IER_THREINT);
+//break;
+//case SET_FIFO_TRIGGER_LEVEL:
+//Chip_UART_SetupFIFOS((LPC_USART_T *)device->loLayer,  UART_FCR_FIFO_EN | UART_FCR_TX_RS | UART_FCR_RX_RS | (int32_t)param);
+//break;
+
+//#define UART_RX_FIFO_SIZE       (16)
+
+
+//-------------------------------------------------------------
+
+// Return TRUE if have unread data in RX FIFO
+bool_t uartRxReady( uartMap_t uart )
+{
+   return Chip_UART_ReadLineStatus( lpcUarts[uart].uartAddr ) & UART_LSR_RDR;
+}
+// Return TRUE if have space in TX FIFO
+bool_t uartTxReady( uartMap_t uart )
+{
+   return Chip_UART_ReadLineStatus( lpcUarts[uart].uartAddr ) & UART_LSR_THRE;
+}
+// Read from RX FIFO
+uint8_t uartRxRead( uartMap_t uart )
+{
+   return Chip_UART_ReadByte( lpcUarts[uart].uartAddr );
+}
+// Write in TX FIFO
+void uartTxWrite( uartMap_t uart, const uint8_t value )
+{
+   Chip_UART_SendByte( lpcUarts[uart].uartAddr, value );
+}
+
+//-------------------------------------------------------------
+
+// UART Initialization
+void uartInit( uartMap_t uart, uint32_t baudRate )
+{
+   // Initialize UART
+   Chip_UART_Init( lpcUarts[uart].uartAddr );
+   // Set Baud rate
+   Chip_UART_SetBaud( lpcUarts[uart].uartAddr, baudRate );
+   // Restart FIFOS using FCR (FIFO Control Register).
+   // Set Enable, Reset content, set trigger level
+   Chip_UART_SetupFIFOS( lpcUarts[uart].uartAddr,
+                         UART_FCR_FIFO_EN |
+                         UART_FCR_TX_RS   |
+                         UART_FCR_RX_RS   |
+                         UART_FCR_TRG_LEV0 );
+   // Dummy read
+   Chip_UART_ReadByte( lpcUarts[uart].uartAddr );
+   // Enable UART Transmission
+   Chip_UART_TXEnable( lpcUarts[uart].uartAddr );
+   // Configure SCU UARTn_TXD pin
+   Chip_SCU_PinMux( lpcUarts[uart].txPin.lpcScuPort,
+                    lpcUarts[uart].txPin.lpcScuPin,
+                    MD_PDN,
+                    lpcUarts[uart].txPin.lpcScuFunc );
+   // Configure SCU UARTn_RXD pin
+   Chip_SCU_PinMux( lpcUarts[uart].rxPin.lpcScuPort,
+                    lpcUarts[uart].rxPin.lpcScuPin,
+                    MD_PLN | MD_EZI | MD_ZI,
+                    lpcUarts[uart].rxPin.lpcScuFunc );
+
+   // Specific configurations for RS485
+   if( uart == UART_485 ) {
+      // Specific RS485 Flags
+      Chip_UART_SetRS485Flags( LPC_USART0,
+                               UART_RS485CTRL_DCTRL_EN |
+                               UART_RS485CTRL_OINV_1     );
+      // UARTn_DIR extra pin for RS485
+      Chip_SCU_PinMux( lpcUart485DirPin.lpcScuPort,
+                       lpcUart485DirPin.lpcScuPin,
+                       MD_PDN,
+                       lpcUart485DirPin.lpcScuFunc );
+   }
+}
+
+// Read 1 byte from RX FIFO, check first if exist aviable data
+bool_t uartReadByte( uartMap_t uart, uint8_t* receivedByte )
+{
+   bool_t retVal = TRUE;
+   if ( uartRxReady(uart) ) {
+      *receivedByte = uartRxRead(uart);
+   } else {
+      retVal = FALSE;
+   }
+   return retVal;
+}
+
+// Blocking Write 1 byte to TX FIFO
+void uartWriteByte( uartMap_t uart, const uint8_t value )
+{
+   // Wait for space in FIFO (blocking)
+   while( uartTxReady( uart ) == FALSE );
+   // Send byte
+   uartTxWrite( uart, value );
+}
+
+// Blocking Send a string
+void uartWriteString( uartMap_t uart, const char* str )
+{
+   while( *str != 0 ) {
+      uartWriteByte( uart, (uint8_t)*str );
+      str++;
+   }
+}
+
+// Blocking, Send a Byte Array
+void uartWriteByteArray( uartMap_t uart,
+                         const uint8_t* byteArray, uint32_t byteArrayLen )
+{
+   uint32_t i = 0;
+   for( i=0; i<byteArrayLen; i++ ) {
+      uartWriteByte( uart, byteArray[i] );
+   }
+}
+
+/*==================[ISR external functions definition]======================*/
+
+__attribute__ ((section(".after_vectors")))
+
+// UART0 (GPIO1 y GPIO2 or RS485/Profibus)
+// 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24)
+void UART0_IRQHandler(void)
+{
+   uartProcessIRQ( UART_GPIO );
+}
+
+// UART2 (USB-UART) or UART_ENET
+// 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26)
+void UART2_IRQHandler(void)
+{
+   uartProcessIRQ( UART_USB );
+}
+
+// UART3 (RS232)
+// 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27)
+void UART3_IRQHandler(void)
+{
+   uartProcessIRQ( UART_232 );
+}
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_ultrasonic_hcsr04.c ./libs/sapi/sapi_v0.5.1/src/sapi_ultrasonic_hcsr04.c
--- a_bRU7kv/libs/sapi/sapi_v0.5.1/src/sapi_ultrasonic_hcsr04.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/sapi_v0.5.1/src/sapi_ultrasonic_hcsr04.c	2018-12-01 17:15:06.629606292 -0300
@@ -0,0 +1,285 @@
+/* Copyright 2017, Danilo Zecchin.
+ * All rights reserved.
+ *
+ * This file is part sAPI library for microcontrollers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+/*
+ * Ultrasonic sensor HC-SR04 API
+ * Date: 2017-11-17
+ */
+
+/*==================[inclusions]=============================================*/
+
+#include "sapi_ultrasonic_hcsr04.h"
+#include "sapi_timer.h"
+#include "sapi_gpio.h"
+
+/*==================[macros and definitions]=================================*/
+
+#define ULTRASONIC_SENSOR_NUMBER 		3     /* Support for 3 ultrasonic sensors */
+#define ULTRASONIC_SENSOR_TRIGGER_GPIO 	GPIO0 /* Trigger mapped to GPIO0 */
+#define RAISING_EDGE 					0	  /* IRQs defines */
+#define FALLING_EDGE 					1
+#define BOTH_EDGES 						2
+#define SENSOR_SAMPLING_RATE 			60000 /* Value in uSec. */
+#define SENSOR_TRIGGER_PULSE_WIDTH		10 	  /* Value in uSec */
+#define TICKS_TO_US_FACTOR				(204000000 / 1000000 )	/* Ticks = us * LPC_MAX_FREQ / 1000000 */
+#define US_TO_CMS_FACTOR				58	  /* From datasheet -> distance = pulse width time in us * velocity (340 m/s) / 2 */
+#define US_TO_INCHS_FACTOR 				148	  /* From datasheet -> distance = pulse width time in us * velocity (340 m/s) / 2 */
+
+/*==================[internal data declaration]==============================*/
+
+typedef struct {
+   uint8_t irqChannel;				/* IRQ channel */
+   gpioInitLpc4337_t gpioInit;	/* GPIO config: port and pin */
+
+} ultrasonicSensorIrqInit_t;
+
+typedef struct {
+   ultrasonicSensorMap_t ultrasonicSensor; /* Sensor ID */
+   uint32_t echoRiseTime,					/* Ticks of echo pulse rise edge */
+            echoFallTime,					/* Ticks of echo pulse fall edge */
+            lastEchoWidth;					/* Echo pulse width in ticks */
+   gpioMap_t echoGpio;						/* Gpio configured for echo pin */
+   uint8_t enabled;						/* boolean flag */
+   ultrasonicSensorIrqInit_t irqConfig;	/* Sensor IRQ config */
+} ultrasonicSensor_t;
+
+/*==================[internal functions declaration]=========================*/
+
+/*==================[internal data definition]===============================*/
+
+static ultrasonicSensor_t ultrasonicSensors[ULTRASONIC_SENSOR_NUMBER] = {
+   /*position | Sensor number | echoRiseTime | echoFallTime | lastEchoWidth | echoGpio | enabled | irqConfig (irqChannel, GpioPort, GpioPin) */
+   /*0*/	{ULTRASONIC_SENSOR_0 , 0 , 0 , 0 , GPIO2 , ULTRASONIC_SENSOR_DISABLE, { 0, { 3, 4 } } },
+   /*1*/	{ULTRASONIC_SENSOR_1 , 0 , 0 , 0 , GPIO4 , ULTRASONIC_SENSOR_DISABLE, { 1, { 5, 16 } } },
+   /*2*/	{ULTRASONIC_SENSOR_2 , 0 , 0 , 0 , GPIO6 , ULTRASONIC_SENSOR_DISABLE, { 2, { 3, 6 }  } }
+};
+
+static ultrasonicSensorMap_t ultrasonicSensorsIrqMap[ULTRASONIC_SENSOR_NUMBER] = {
+   /* position (irqChannel) | Sensor number */
+   /*0*/ ULTRASONIC_SENSOR_0,
+   /*1*/ ULTRASONIC_SENSOR_1,
+   /*2*/ ULTRASONIC_SENSOR_2
+};
+/*==================[external data definition]===============================*/
+
+/*==================[internal functions definition]==========================*/
+
+static void initGPIOIrqs()
+{
+
+   Chip_PININT_Init(LPC_GPIO_PIN_INT);
+}
+
+static void enableGPIOIrq(uint8_t irqChannel, uint8_t port, uint8_t pin, uint8_t edge)
+{
+
+   /*
+    * Select irq channel to handle a GPIO interrupt, using its port and pin to specify it
+    * From EduCiaa pin out spec: GPIO1[9] -> port 1 and pin 9
+    */
+   Chip_SCU_GPIOIntPinSel(irqChannel , port, pin);
+   /* Clear actual configured interrupt status */
+   Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(irqChannel));
+   /* Set edge interrupt mode */
+   Chip_PININT_SetPinModeEdge(LPC_GPIO_PIN_INT, PININTCH(irqChannel));
+
+   if ( edge == RAISING_EDGE) {
+      /* Enable high edge gpio interrupt */
+      Chip_PININT_EnableIntHigh(LPC_GPIO_PIN_INT, PININTCH(irqChannel));
+   } else if ( edge == FALLING_EDGE) {
+      /* Enable low edge gpio interrupt */
+      Chip_PININT_EnableIntLow(LPC_GPIO_PIN_INT, PININTCH(irqChannel));
+   } else {
+      /* Enable high and low edge */
+      Chip_PININT_EnableIntHigh(LPC_GPIO_PIN_INT, PININTCH(irqChannel));
+      Chip_PININT_EnableIntLow(LPC_GPIO_PIN_INT, PININTCH(irqChannel));
+   }
+
+   /* Clear pending irq channel interrupts */
+   NVIC_ClearPendingIRQ(PIN_INT0_IRQn + irqChannel);
+   /* Enable irqChannel interrupt */
+   NVIC_EnableIRQ(PIN_INT0_IRQn + irqChannel);
+}
+
+static void disableGPIOIrq(uint8_t irqChannel)
+{
+   /* Clear pending irq channel interrupts */
+   NVIC_ClearPendingIRQ(PIN_INT0_IRQn + irqChannel);
+   /* Disable irqChannel interrupt */
+   NVIC_DisableIRQ(PIN_INT0_IRQn + irqChannel);
+}
+
+static void clearInterrupt(uint8_t irqChannel)
+{
+   /* Clear interrupt flag for irqChannel */
+   Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT,PININTCH(irqChannel));
+}
+
+static void serveInterrupt(uint8_t irqChannel)
+{
+   ultrasonicSensorMap_t aSensor = ultrasonicSensorsIrqMap[irqChannel];
+   /* If interrupt was because a rising edge */
+   if ( Chip_PININT_GetRiseStates(LPC_GPIO_PIN_INT) & PININTCH(irqChannel) ) {
+      //TODO add method to sapi_timer.h in order to get a timer count -> avoid using LPC_TIMER0 directly
+
+      /* Save actual timer count in echoRiseTime */
+      ultrasonicSensors[aSensor].echoRiseTime = Chip_TIMER_ReadCount(LPC_TIMER0);
+      /* Clear rise edge irq */
+      Chip_PININT_ClearRiseStates(LPC_GPIO_PIN_INT,PININTCH(irqChannel));
+   }
+   /* If not, interrupt was because a falling edge */
+   else {
+      //TODO add method to sapi_timer.h in order to get a timer count -> avoid using LPC_TIMER0 directly
+      //TODO echoFallTime may not be necesary
+
+      /* Save actual timer count in echoFallTime */
+      ultrasonicSensors[aSensor].echoFallTime = Chip_TIMER_ReadCount(LPC_TIMER0);
+      /* Compute echo pulse width in timer ticks and save in lastEchoWidth */
+      ultrasonicSensors[aSensor].lastEchoWidth = ultrasonicSensors[aSensor].echoFallTime - ultrasonicSensors[aSensor].echoRiseTime;
+      /* Clear falling edge irq */
+      Chip_PININT_ClearFallStates(LPC_GPIO_PIN_INT,PININTCH(irqChannel));
+   }
+
+   /* Clear IRQ status */
+   clearInterrupt(irqChannel);
+}
+
+/*
+ * When timer expires, ULTRASONIC_SENSOR_TRIGGER_GPIO is on
+ */
+static void timerExpired()
+{
+   gpioWrite(ULTRASONIC_SENSOR_TRIGGER_GPIO,ON);
+}
+
+/*
+ * When trigger time expires (TIMER0 reachs TIMECOMPAREMATCH1),
+ * ULTRASONIC_SENSOR_TRIGGER_GPIO is off
+ */
+static void triggerExpired()
+{
+   gpioWrite(ULTRASONIC_SENSOR_TRIGGER_GPIO,OFF);
+}
+
+/*==================[external functions definition]==========================*/
+
+/*
+ * @Brief   Configure an ultrasonic sensor
+ * @param   aSensor:   sensor number (0 to 2)
+ * @param   aConfig:   enable or disable sensor
+ * @return   nothing
+ */
+void ultrasonicSensorInit(ultrasonicSensorMap_t aSensor, ultrasonicSensorInit_t aConfig)
+{
+   static uint8_t firstTime = 1;
+
+   if ( aConfig == ULTRASONIC_SENSOR_ENABLE ) {
+
+      /* If first time, trigger GPIO is set as output */
+      if ( firstTime ) {
+         gpioInit(ULTRASONIC_SENSOR_TRIGGER_GPIO, GPIO_OUTPUT);
+         initGPIOIrqs();
+      }
+
+      /* Enable sensor echo GPIO pin as INPUT */
+      gpioInit(ultrasonicSensors[aSensor].echoGpio, GPIO_INPUT);
+
+      /* IRQ Enable to capture sensor echo pulse edges */
+      enableGPIOIrq(ultrasonicSensors[aSensor].irqConfig.irqChannel,
+                    ultrasonicSensors[aSensor].irqConfig.gpioInit.port,
+                    ultrasonicSensors[aSensor].irqConfig.gpioInit.pin,
+                    BOTH_EDGES);
+
+      /* If first time, TIMER0 is set to cycle sensor trigger ever SENSOR_SAMPLING_RATE */
+      if ( firstTime ) {
+         /* Set TIMER0 to call "timerExpired" function every SENSOR_SAMPLING_RATE */
+         Timer_Init(TIMER0,Timer_microsecondsToTicks(SENSOR_SAMPLING_RATE),timerExpired);
+         /* Set TIMERCOMPAREMATCH1 to SENSOR_TRIGGER_PULSE_WIDTH. When timer counter reachs this value, "triggerExpired" function is called */
+         Timer_EnableCompareMatch(TIMER0,TIMERCOMPAREMATCH1, Timer_microsecondsToTicks(SENSOR_TRIGGER_PULSE_WIDTH), triggerExpired);
+         firstTime = 0;
+      }
+
+   } else {
+      disableGPIOIrq(ultrasonicSensors[aSensor].irqConfig.irqChannel);
+   }
+
+   ultrasonicSensors[aSensor].enabled = aConfig;
+
+}
+
+/*
+ * @Brief   retrieves sensor actual distance in the specified unit
+ * @param   aSensor:	sensor number (0 to 2)
+ * @param   anUnit:		returned value unit (centimeters, inch, etc)
+ * @return  float value with measured distance
+ */
+float ultrasonicSensorGetDistance(ultrasonicSensorMap_t aSensor, unitMap_t anUnit)
+{
+   float result;
+
+   /* Convert pulse width in timer ticks to microseconds */
+   result = (float)((ultrasonicSensors[aSensor].lastEchoWidth/TICKS_TO_US_FACTOR));
+
+   /* If CM requested */
+   if ( anUnit == CM )
+      /* Convert time in microseconds to distance in centimeters (from formula distance = pulse width time in us * velocity (340 m/s) / 2 )*/
+      result = result / US_TO_CMS_FACTOR;
+   else
+      /* Convert time in microseconds to distance in inchs (from formula distance = pulse width time in us * velocity (340 m/s) / 2 )*/
+      result = result / US_TO_INCHS_FACTOR;
+
+   return(result);
+}
+
+/*==================[ISR external functions definition]======================*/
+/*
+ * @Brief:   GPIO Echo interrupt handler for each sensor
+ */
+void GPIO0_IRQHandler(void)
+{
+   serveInterrupt(0);
+}
+
+void GPIO1_IRQHandler(void)
+{
+   serveInterrupt(1);
+}
+
+void GPIO2_IRQHandler(void)
+{
+   serveInterrupt(2);
+}
+
+
+/*==================[end of file]============================================*/
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/sapi/version.txt ./libs/sapi/version.txt
--- a_bRU7kv/libs/sapi/version.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/sapi/version.txt	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1 @@
+sAPI v0.5.1
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lib/flat.ld ./libs/vendor_libs/lib/flat.ld
--- a_bRU7kv/libs/vendor_libs/lib/flat.ld	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lib/flat.ld	2018-12-01 17:51:47.202340136 -0300
@@ -0,0 +1,118 @@
+INCLUDE libs.ld
+
+MEMORY
+{
+  FLATRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 64K
+}
+
+ENTRY(ResetISR)
+
+SECTIONS
+{
+    .text : ALIGN(4)
+    {
+        FILL(0xff)
+        __vectors_start__ = ABSOLUTE(.) ;
+        KEEP(*(.isr_vector))
+
+        /* Global Section Table */
+        . = ALIGN(4) ;
+        __section_table_start = .;
+        __data_section_table = .;
+        __data_section_table_end = .;
+        __bss_section_table = .;
+        LONG(    ADDR(.bss));
+        LONG(  SIZEOF(.bss));
+        __bss_section_table_end = .;
+        __section_table_end = . ;
+        *(.after_vectors*)
+    } >FLATRAM
+    . = ALIGN(4);
+
+   .preinit_array     :
+   {
+     PROVIDE_HIDDEN (__preinit_array_start = .);
+     KEEP (*(.preinit_array*))
+     PROVIDE_HIDDEN (__preinit_array_end = .);
+   } >FLATRAM
+   
+   .init_array :
+   {
+     PROVIDE_HIDDEN (__init_array_start = .);
+     KEEP (*(SORT(.init_array.*)))
+     KEEP (*(.init_array*))
+     PROVIDE_HIDDEN (__init_array_end = .);
+   } >FLATRAM
+  
+    . = ALIGN(4);
+
+    .text : ALIGN(4)
+    {
+         *(.text*)
+        *(.rodata .rodata.* .constdata .constdata.*)
+        . = ALIGN(4);
+
+    } > FLATRAM
+
+    /*
+     * for exception handling/unwind - some Newlib functions (in common
+     * with C++ and STDC++) use this.
+     */
+    .ARM.extab : ALIGN(4)
+    {
+       *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > FLATRAM
+    __exidx_start = .;
+
+    .ARM.exidx : ALIGN(4)
+    {
+       *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > FLATRAM
+    __exidx_end = .;
+
+    _etext = .;
+
+   /* Main DATA section (RamLoc32) */
+   .data : ALIGN(4)
+   {
+      FILL(0xff)
+      _data = . ;
+      *(vtable)
+      *(.ramfunc*)
+      *(.data*)
+      . = ALIGN(4) ;
+      _edata = . ;
+   } > FLATRAM
+
+    /* MAIN BSS SECTION */
+    .bss : ALIGN(4)
+    {
+        _bss = .;
+        *(.bss*)
+        *(COMMON)
+        . = ALIGN(4) ;
+        _ebss = .;
+        PROVIDE(end = .);
+    } > FLATRAM
+
+    /* DEFAULT NOINIT SECTION */
+    .noinit (NOLOAD): ALIGN(4)
+    {
+        _noinit = .;
+        *(.noinit*)
+         . = ALIGN(4) ;
+        _end_noinit = .;
+    } > FLATRAM
+
+    PROVIDE(_pvHeapStart = .);
+    PROVIDE(_vStackTop = ORIGIN(FLATRAM) + LENGTH(FLATRAM) );
+    PROVIDE(__valid_user_code_checksum = 0 -
+         (_vStackTop
+         + (ResetISR + 1)
+         + (NMI_Handler + 1)
+         + (HardFault_Handler + 1)
+         + (( DEFINED(MemManage_Handler) ? MemManage_Handler : 0 ) + 1)   /* MemManage_Handler may not be defined */
+         + (( DEFINED(BusFault_Handler) ? BusFault_Handler : 0 ) + 1)     /* BusFault_Handler may not be defined */
+         + (( DEFINED(UsageFault_Handler) ? UsageFault_Handler : 0 ) + 1) /* UsageFault_Handler may not be defined */
+         ) );
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lib/libs.ld ./libs/vendor_libs/lib/libs.ld
--- a_bRU7kv/libs/vendor_libs/lib/libs.ld	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lib/libs.ld	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,5 @@
+GROUP(
+  libgcc.a
+  libc.a
+  libm.a
+)
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lib/link.ld ./libs/vendor_libs/lib/link.ld
--- a_bRU7kv/libs/vendor_libs/lib/link.ld	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lib/link.ld	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,280 @@
+INCLUDE mem.ld
+INCLUDE libs.ld
+
+ENTRY(ResetISR)
+
+SECTIONS
+{
+    .text_Flash2 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.text_Flash2*) /* for compatibility with previous releases */
+       *(.text_MFlashB512*) /* for compatibility with previous releases */
+       *(.text.$Flash2*)
+       *(.text.$MFlashB512*)
+       *(.rodata.$Flash2*)
+       *(.rodata.$MFlashB512*)
+    } > MFlashB512
+
+    /* MAIN TEXT SECTION */
+    .text : ALIGN(4)
+    {
+        FILL(0xff)
+        __vectors_start__ = ABSOLUTE(.) ;
+        KEEP(*(.isr_vector))
+
+        /* Global Section Table */
+        . = ALIGN(4) ;
+        __section_table_start = .;
+        __data_section_table = .;
+        LONG(LOADADDR(.data));
+        LONG(    ADDR(.data));
+        LONG(  SIZEOF(.data));
+        LONG(LOADADDR(.data_RAM2));
+        LONG(    ADDR(.data_RAM2));
+        LONG(  SIZEOF(.data_RAM2));
+        LONG(LOADADDR(.data_RAM3));
+        LONG(    ADDR(.data_RAM3));
+        LONG(  SIZEOF(.data_RAM3));
+        LONG(LOADADDR(.data_RAM4));
+        LONG(    ADDR(.data_RAM4));
+        LONG(  SIZEOF(.data_RAM4));
+        LONG(LOADADDR(.data_RAM5));
+        LONG(    ADDR(.data_RAM5));
+        LONG(  SIZEOF(.data_RAM5));
+        __data_section_table_end = .;
+        __bss_section_table = .;
+        LONG(    ADDR(.bss));
+        LONG(  SIZEOF(.bss));
+        LONG(    ADDR(.bss_RAM2));
+        LONG(  SIZEOF(.bss_RAM2));
+        LONG(    ADDR(.bss_RAM3));
+        LONG(  SIZEOF(.bss_RAM3));
+        LONG(    ADDR(.bss_RAM4));
+        LONG(  SIZEOF(.bss_RAM4));
+        LONG(    ADDR(.bss_RAM5));
+        LONG(  SIZEOF(.bss_RAM5));
+        __bss_section_table_end = .;
+        __section_table_end = . ;
+        /* End of Global Section Table */
+
+
+        *(.after_vectors*)
+
+        /* Code Read Protect data */
+        . = 0x000002FC ;
+        PROVIDE(__CRP_WORD_START__ = .) ;
+        KEEP(*(.crp))
+        PROVIDE(__CRP_WORD_END__ = .) ;
+        ASSERT(!(__CRP_WORD_START__ == __CRP_WORD_END__), "Linker CRP Enabled, but no CRP_WORD provided within application");
+        /* End of Code Read Protect */
+
+    } >MFlashA512
+    . = ALIGN(4);
+
+   .preinit_array     :
+   {
+     PROVIDE_HIDDEN (__preinit_array_start = .);
+     KEEP (*(.preinit_array*))
+     PROVIDE_HIDDEN (__preinit_array_end = .);
+   } >MFlashA512
+   
+   .init_array :
+   {
+     PROVIDE_HIDDEN (__init_array_start = .);
+     KEEP (*(SORT(.init_array.*)))
+     KEEP (*(.init_array*))
+     PROVIDE_HIDDEN (__init_array_end = .);
+   } >MFlashA512
+  
+    . = ALIGN(4);
+
+    .text : ALIGN(4)
+    {
+         *(.text*)
+        *(.rodata .rodata.* .constdata .constdata.*)
+        . = ALIGN(4);
+
+    } > MFlashA512
+
+    /*
+     * for exception handling/unwind - some Newlib functions (in common
+     * with C++ and STDC++) use this.
+     */
+    .ARM.extab : ALIGN(4)
+    {
+       *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > MFlashA512
+    __exidx_start = .;
+
+    .ARM.exidx : ALIGN(4)
+    {
+       *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > MFlashA512
+    __exidx_end = .;
+
+    _etext = .;
+
+
+    /* DATA section for RamLoc40 */
+   .data_RAM2 : ALIGN(4)
+    {
+       FILL(0xff)
+      /*  __core_m0app_START__ = .; start of slave image
+         KEEP(*(.core_m0app))
+       __core_m0app_END__ = .;  end of slave image
+       ASSERT(!(__core_m0app_START__ == __core_m0app_END__), "No slave code for _core_m0app");
+       ASSERT( (ABSOLUTE(__core_m0app_START__) == __vectors_start___core_m0app), "M0APP execute address differs from address provided in source image");*/
+       *(.ramfunc.$RAM2)
+       *(.ramfunc.$RamLoc40)
+       *(.data.$RAM2*)
+       *(.data.$RamLoc40*)
+       . = ALIGN(4) ;
+    } > RamLoc40 AT>MFlashA512
+
+    /* DATA section for RamAHB32 */
+    .data_RAM3 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.ramfunc.$RAM3)
+       *(.ramfunc.$RamAHB32)
+       *(.data.$RAM3*)
+       *(.data.$RamAHB32*)
+       . = ALIGN(4) ;
+    } > RamAHB32 AT>MFlashA512
+
+    /* DATA section for RamAHB16 */
+    .data_RAM4 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.ramfunc.$RAM4)
+       *(.ramfunc.$RamAHB16)
+       *(.data.$RAM4*)
+       *(.data.$RamAHB16*)
+       . = ALIGN(4) ;
+    } > RamAHB16 AT>MFlashA512
+
+    /* DATA section for RamAHB_ETB16 */
+    .data_RAM5 : ALIGN(4)
+    {
+       FILL(0xff)
+       *(.ramfunc.$RAM5)
+       *(.ramfunc.$RamAHB_ETB16)
+       *(.data.$RAM5*)
+       *(.data.$RamAHB_ETB16*)
+       . = ALIGN(4) ;
+    } > RamAHB_ETB16 AT>MFlashA512
+
+    /* MAIN DATA SECTION */
+
+
+    .uninit_RESERVED : ALIGN(4)
+    {
+        KEEP(*(.bss.$RESERVED*))
+        . = ALIGN(4) ;
+        _end_uninit_RESERVED = .;
+    } > RamLoc32
+
+
+   /* Main DATA section (RamLoc32) */
+   .data : ALIGN(4)
+   {
+      FILL(0xff)
+      _data = . ;
+      *(vtable)
+      *(.ramfunc*)
+      *(.data*)
+      . = ALIGN(4) ;
+      _edata = . ;
+   } > RamLoc32 AT>MFlashA512
+
+    /* BSS section for RamLoc40 */
+    .bss_RAM2 : ALIGN(4)
+    {
+       *(.bss.$RAM2*)
+       *(.bss.$RamLoc40*)
+       . = ALIGN(4) ;
+    } > RamLoc40
+    /* BSS section for RamAHB32 */
+    .bss_RAM3 : ALIGN(4)
+    {
+       *(.bss.$RAM3*)
+       *(.bss.$RamAHB32*)
+       . = ALIGN(4) ;
+    } > RamAHB32
+    /* BSS section for RamAHB16 */
+    .bss_RAM4 : ALIGN(4)
+    {
+       *(.bss.$RAM4*)
+       *(.bss.$RamAHB16*)
+       . = ALIGN(4) ;
+    } > RamAHB16
+    /* BSS section for RamAHB_ETB16 */
+    .bss_RAM5 : ALIGN(4)
+    {
+       *(.bss.$RAM5*)
+       *(.bss.$RamAHB_ETB16*)
+       . = ALIGN(4) ;
+    } > RamAHB_ETB16
+
+    /* MAIN BSS SECTION */
+    .bss : ALIGN(4)
+    {
+        _bss = .;
+        *(.bss*)
+        *(COMMON)
+        . = ALIGN(4) ;
+        _ebss = .;
+        PROVIDE(end = .);
+    } > RamLoc32
+
+    /* NOINIT section for RamLoc40 */
+    .noinit_RAM2 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM2*)
+       *(.noinit.$RamLoc40*)
+       . = ALIGN(4) ;
+    } > RamLoc40
+    /* NOINIT section for RamAHB32 */
+    .noinit_RAM3 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM3*)
+       *(.noinit.$RamAHB32*)
+       . = ALIGN(4) ;
+    } > RamAHB32
+    /* NOINIT section for RamAHB16 */
+    .noinit_RAM4 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM4*)
+       *(.noinit.$RamAHB16*)
+       . = ALIGN(4) ;
+    } > RamAHB16
+    /* NOINIT section for RamAHB_ETB16 */
+    .noinit_RAM5 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM5*)
+       *(.noinit.$RamAHB_ETB16*)
+       . = ALIGN(4) ;
+    } > RamAHB_ETB16
+
+    /* DEFAULT NOINIT SECTION */
+    .noinit (NOLOAD): ALIGN(4)
+    {
+        _noinit = .;
+        *(.noinit*)
+         . = ALIGN(4) ;
+        _end_noinit = .;
+    } > RamLoc32
+
+    PROVIDE(_pvHeapStart = .);
+    PROVIDE(_vStackTop = __top_RamLoc32 - 0);
+    PROVIDE(__valid_user_code_checksum = 0 -
+         (_vStackTop
+         + (ResetISR + 1)
+         + (NMI_Handler + 1)
+         + (HardFault_Handler + 1)
+         + (( DEFINED(MemManage_Handler) ? MemManage_Handler : 0 ) + 1)   /* MemManage_Handler may not be defined */
+         + (( DEFINED(BusFault_Handler) ? BusFault_Handler : 0 ) + 1)     /* BusFault_Handler may not be defined */
+         + (( DEFINED(UsageFault_Handler) ? UsageFault_Handler : 0 ) + 1) /* UsageFault_Handler may not be defined */
+         ) );
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lib/mem.ld ./libs/vendor_libs/lib/mem.ld
--- a_bRU7kv/libs/vendor_libs/lib/mem.ld	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lib/mem.ld	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,20 @@
+MEMORY
+{
+  /* Define each memory region */
+  MFlashA512 (rx) : ORIGIN = 0x1a000000, LENGTH = 0x80000 /* 512K bytes */
+  MFlashB512 (rx) : ORIGIN = 0x1b000000, LENGTH = 0x80000 /* 512K bytes */
+  RamLoc32 (rwx) : ORIGIN = 0x10000000, LENGTH = 0x8000 /* 32K bytes */
+  RamLoc40 (rwx) : ORIGIN = 0x10080000, LENGTH = 0xa000 /* 40K bytes */
+  RamAHB32 (rwx) : ORIGIN = 0x20000000, LENGTH = 0x8000 /* 32K bytes */
+  RamAHB16 (rwx) : ORIGIN = 0x20008000, LENGTH = 0x4000 /* 16K bytes */
+  RamAHB_ETB16 (rwx) : ORIGIN = 0x2000c000, LENGTH = 0x4000 /* 16K bytes */
+}
+
+/* Define a symbol for the top of each memory region */
+__top_MFlashA512 = 0x1a000000 + 0x80000;
+__top_MFlashB512 = 0x1b000000 + 0x80000;
+__top_RamLoc32 = 0x10000000 + 0x8000;
+__top_RamLoc40 = 0x10080000 + 0xa000;
+__top_RamAHB32 = 0x20000000 + 0x8000;
+__top_RamAHB16 = 0x20008000 + 0x4000;
+__top_RamAHB_ETB16 = 0x2000c000 + 0x4000;
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board_api.h ./libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board_api.h
--- a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board_api.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board_api.h	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,176 @@
+/*
+ * @brief Common board API functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __BOARD_API_H_
+#define __BOARD_API_H_
+
+#include "lpc_types.h"
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup BOARD_COMMON_API BOARD: Common board functions
+ * @ingroup BOARD_Common
+ * This file contains common board definitions that are shared across
+ * boards and devices. All of these functions do not need to be
+ * implemented for a specific board, but if they are implemented, they
+ * should use this API standard.
+ * @{
+ */
+
+/**
+ * @brief  Setup and initialize hardware prior to call to main()
+ * @return None
+ * @note   Board_SystemInit() is called prior to the application and sets up system
+ * clocking, memory, and any resources needed prior to the application
+ * starting.
+ */
+void Board_SystemInit(void);
+
+/**
+ * @brief  Setup pin multiplexer per board schematics
+ * @return None
+ * @note   Board_SetupMuxing() should be called from SystemInit() prior to application
+ * main() is called. So that the PINs are set in proper state.
+ */
+void Board_SetupMuxing(void);
+
+/**
+ * @brief  Setup system clocking
+ * @return None
+ * @note   This sets up board clocking.
+ */
+void Board_SetupClocking(void);
+
+/**
+ * @brief  Setup external system memory
+ * @return None
+ * @note   This function is typically called after pin mux setup and clock setup and
+ * sets up any external memory needed by the system (DRAM, SRAM, etc.). Not all
+ * boards need this function.
+ */
+void Board_SetupExtMemory(void);
+
+/**
+ * @brief  Set up and initialize all required blocks and functions related to the board hardware.
+ * @return None
+ */
+void Board_Init(void);
+
+/**
+ * @brief  Initializes board UART for output, required for printf redirection
+ * @return None
+ */
+void Board_Debug_Init(void);
+
+/**
+ * @brief  Sends a single character on the UART, required for printf redirection
+ * @param  ch  : character to send
+ * @return None
+ */
+void Board_UARTPutChar(char ch);
+
+/**
+ * @brief  Get a single character from the UART, required for scanf input
+ * @return EOF if not character was received, or character value
+ */
+int Board_UARTGetChar(void);
+
+/**
+ * @brief  Prints a string to the UART
+ * @param  str : Terminated string to output
+ * @return None
+ */
+void Board_UARTPutSTR(const char *str);
+
+/**
+ * @brief  Sets the state of a board LED to on or off
+ * @param  LEDNumber   : LED number to set state for
+ * @param  State       : true for on, false for off
+ * @return None
+ */
+void Board_LED_Set(uint8_t LEDNumber, bool State);
+
+/**
+ * @brief  Returns the current state of a board LED
+ * @param  LEDNumber   : LED number to set state for
+ * @return true if the LED is on, otherwise false
+ */
+bool Board_LED_Test(uint8_t LEDNumber);
+
+/**
+ * @brief  Toggles the current state of a board LED
+ * @param  LEDNumber   : LED number to change state for
+ * @return None
+ */
+void Board_LED_Toggle(uint8_t LEDNumber);
+
+/**
+ * @brief Function prototype for a MS delay function. Board layers or example code may
+ *        define this function as needed.
+ */
+typedef void (*p_msDelay_func_t)(uint32_t);
+
+/* The DEBUG* functions are selected based on system configuration.
+   Code that uses the DEBUG* functions will have their I/O routed to
+   the UART, semihosting, or nowhere. */
+#if defined(DEBUG_ENABLE)
+#if defined(DEBUG_SEMIHOSTING)
+#define DEBUGINIT()
+#define DEBUGOUT(...) printf(__VA_ARGS__)
+#define DEBUGSTR(str) printf(str)
+#define DEBUGIN() (int) EOF
+
+#else
+#define DEBUGINIT() Board_Debug_Init()
+#define DEBUGOUT(...) printf(__VA_ARGS__)
+#define DEBUGSTR(str) Board_UARTPutSTR(str)
+#define DEBUGIN() Board_UARTGetChar()
+#endif /* defined(DEBUG_SEMIHOSTING) */
+
+#else
+#define DEBUGINIT()
+#define DEBUGOUT(...)
+#define DEBUGSTR(str)
+#define DEBUGIN() (int) EOF
+#endif /* defined(DEBUG_ENABLE) */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BOARD_API_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board.h ./libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board.h
--- a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_board_ciaa_edu_4337/inc/board.h	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,118 @@
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+#include "chip.h"
+#define DEBUG_ENABLE
+#include "board_api.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BOARD_CIAA_EDU_NXP_4337
+#define USE_RMII
+#define BOARD_ENET_PHY_ADDR         0x00
+
+#define LED_RED                     0
+#define LED_GREEN                   1
+#define LED_BLUE                    2
+#define LED_1                       3
+#define LED_2                       4
+#define LED_3                       5
+
+#define BOARD_TEC_1                 0
+#define BOARD_TEC_2                 1
+#define BOARD_TEC_3                 2
+#define BOARD_TEC_4                 3
+
+#define BOARD_GPIO_0                0
+#define BOARD_GPIO_1                1
+#define BOARD_GPIO_2                2
+#define BOARD_GPIO_3                3
+#define BOARD_GPIO_4                4
+#define BOARD_GPIO_5                5
+#define BOARD_GPIO_6                6
+#define BOARD_GPIO_7                7
+#define BOARD_GPIO_8                8
+
+#define BOARD_I2C_PORT              I2C0
+#define BOARD_SPI_PORT              LPC_SSP1
+
+#define DEBUG_UART                  LPC_USART2
+
+
+// Debug UART defaults: 115200, 8N1.
+#ifndef DEBUG_UART_BAUD_RATE
+    #define DEBUG_UART_BAUD_RATE    115200
+#endif
+
+#ifndef DEBUG_UART_DATA_BITS
+    #define DEBUG_UART_DATA_BITS    UART_LCR_WLEN8
+#endif
+
+#ifndef DEBUG_UART_PARITY
+    #define DEBUG_UART_PARITY       UART_LCR_PARITY_DIS
+#endif
+
+#ifndef DEBUG_UART_STOP_BITS
+    #define DEBUG_UART_STOP_BITS    UART_LCR_SBS_1BIT
+#endif
+
+#define DEBUG_UART_CONFIG           (DEBUG_UART_DATA_BITS | DEBUG_UART_PARITY \
+                                    | DEBUG_UART_STOP_BITS)
+
+
+// I2C defaults to Standard/Fast mode, 100 Khz
+#ifndef BOARD_I2C_MODE
+    #define BOARD_I2C_MODE          I2C0_STANDARD_FAST_MODE
+#endif
+
+#ifndef BOARD_I2C_SPEED
+    #define BOARD_I2C_SPEED         1000000
+#endif
+
+
+// SPI default config: Master, 8 Bits, SPI format, CPHA0/CPOL0 polarity.
+#ifndef BOARD_SPI_MODE
+    #define BOARD_SPI_MODE          SSP_MODE_MASTER
+#endif
+
+#ifndef BOARD_SPI_BITS
+    #define BOARD_SPI_BITS          SSP_BITS_8
+#endif
+
+#ifndef BOARD_SPI_FORMAT
+    #define BOARD_SPI_FORMAT        SSP_FRAMEFORMAT_SPI
+#endif
+
+#ifndef BOARD_SPI_POLARITY
+    #define BOARD_SPI_POLARITY      SSP_CLOCK_CPHA0_CPOL0
+#endif
+
+#ifndef BOARD_SPI_SPEED
+    #define BOARD_SPI_SPEED         100000
+#endif
+
+
+// ADC maximum sampling rate: (4.5 Mhz / 11 bits) = ~400 Khz
+#ifndef BOARD_ADC_SAMPLE_RATE
+    #define BOARD_ADC_SAMPLE_RATE   400000
+#endif
+
+#ifndef BOARD_ADC_RESOLUTION
+    #define BOARD_ADC_RESOLUTION    ADC_10BITS
+#endif
+
+
+bool        Board_TEC_GetStatus     (uint8_t button);
+void        Board_ADC_ReadBegin     (ADC_CHANNEL_T channel);
+bool        Board_ADC_ReadWait      ();
+uint16_t    Board_ADC_ReadEnd       ();
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BOARD_H_ */
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board.c ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board.c
--- a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board.c	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,296 @@
+/*
+    LPCOpen Edu-CIAA Board port
+    Copyright 2018 Santiago Germino (royconejo@gmail.com)
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are met:
+
+    1.  Redistributions of source code must retain the above copyright notice,
+        this list of conditions and the following disclaimer.
+
+    2.  Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    3.  Neither the name of the copyright holder nor the names of its
+        contributors may be used to endorse or promote products derived from
+        this software without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+    ----------------------------------------------------------------------------
+
+    This source is a new LPCOpen board port for Edu-CIAA.
+
+    It exposes the same API found in board_api.h, along with new functions for
+    input handling (TEC_1 to TEC_4 buttons), getting ADC samples and such.
+
+    Most functionality exposed on P1/P2 headers are initialized and configured
+    based on original intend/label: ETHERNET, 232_RX/TX, SPI, GPIO, I2C & ADC.
+
+    GPIO pins are configured as INPUT with pullups as if they were buttons.
+
+    ETHERNET port requires a specific PONCHO with an ethernet Physical layer
+    (PHY). As a result, there is no code ported to initialize that IC as it
+    could be any. All there is here is MUX configuration to enable RMII and
+    start the peripheral clock.
+
+    External hardware is also required for CAN, 4 bit Character display (LCD
+    port) and keyboard (port T_*).
+
+    DEBUG UART (wired to FT2232 IC and exposed on the development PC as a
+    USB serial port) is configured with this default settings: 115200, 8N1.
+
+    But -as it happens with I2C, SPI, ADC, ect- its defaults can be configured
+    at will before including board.h (please look at that file to know the
+    corresponding #defines)
+
+    Pin MUXING is configured on board_sysinit.c. While it is known the intend of
+    that file is to configure a SDRAM interface before main(), I prefer to have
+    the amount of mux configurations enclosed on that file alone, letting this
+    one cleaner.
+
+    ----------------------------------------------------------------------------
+
+    Changelog:
+
+    v0.9 - 4/4/2018, sgermino:
+        First version. TODO: To be feature complete on a stock Edu-CIAA, it
+        should be neccesary to implement RS-485 communication.
+*/
+
+
+#include "board.h"
+#if defined(DEBUG_ENABLE) && !defined(DEBUG_UART)
+    #error "Definir DEBUG_UART como LPC_USART{numero de UART}"
+#endif
+
+
+// CHIP module configuration. Edu-CIAA clock is based on a 12 Mhz crystal.
+const uint32_t ExtRateIn = 0;
+const uint32_t OscRateIn = 12000000;
+
+
+struct gpio_t
+{
+    uint8_t port;
+    uint8_t pin;
+};
+
+
+static const struct gpio_t GpioLeds[] = {
+    {5, 0}, {5, 1}, {5, 2}, {0, 14}, {1, 11}, {1, 12}
+};
+
+
+static const struct gpio_t GpioButtons[] = {
+    {0, 4}, {0, 8}, {0, 9}, {1, 9}
+};
+
+
+static const struct gpio_t GpioPorts[] = {
+    {3, 0}, {3, 3}, {3, 4}, {5,15}, {5,16}, {3, 5}, {3, 6}, {3, 7}, {2, 8}
+};
+
+
+static ADC_CHANNEL_T curADCChannel = 0xFF;
+
+
+#define GPIO_LEDS_SIZE      (sizeof(GpioLeds) / sizeof(struct gpio_t))
+#define GPIO_BUTTONS_SIZE   (sizeof(GpioButtons) / sizeof(struct gpio_t))
+#define GPIO_PORTS_SIZE     (sizeof(GpioPorts) / sizeof(struct gpio_t))
+
+
+static void Board_LED_Init()
+{
+    for (uint32_t i = 0; i < GPIO_LEDS_SIZE; ++i) {
+        const struct gpio_t *io = &GpioLeds[i];
+        Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, io->port, io->pin);
+        Chip_GPIO_SetPinState(LPC_GPIO_PORT, io->port, io->pin, false);
+    }
+}
+
+
+static void Board_TEC_Init()
+{
+    for (uint32_t i = 0; i < GPIO_BUTTONS_SIZE; ++i) {
+        const struct gpio_t *io = &GpioButtons[i];
+        Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, io->port, io->pin);
+    }
+}
+
+
+static void Board_GPIO_Init()
+{
+    for (uint32_t i = 0; i < GPIO_PORTS_SIZE; ++i) {
+        const struct gpio_t *io = &GpioPorts[i];
+        Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, io->port, io->pin);
+    }
+}
+
+
+static void Board_I2C_Init()
+{
+    Chip_I2C_Init(I2C0);
+    Chip_SCU_I2C0PinConfig(BOARD_I2C_MODE);
+    Chip_I2C_SetClockRate(I2C0, BOARD_I2C_SPEED);
+}
+
+
+static void Board_SPI_Init()
+{
+    Chip_SSP_Init(LPC_SSP1);
+    Chip_SSP_Set_Mode(LPC_SSP1, BOARD_SPI_MODE);
+    Chip_SSP_SetFormat(LPC_SSP1, BOARD_SPI_BITS, BOARD_SPI_FORMAT,
+                       BOARD_SPI_POLARITY);
+    Chip_SSP_SetBitRate(LPC_SSP1, BOARD_SPI_SPEED);
+    Chip_SSP_Enable(LPC_SSP1);
+}
+
+
+static void Board_ADC_Init()
+{
+    ADC_CLOCK_SETUP_T cs;
+
+    Chip_ADC_Init(LPC_ADC0, &cs);
+    Chip_ADC_SetSampleRate(LPC_ADC0, &cs, BOARD_ADC_SAMPLE_RATE);
+    Chip_ADC_SetResolution(LPC_ADC0, &cs, BOARD_ADC_RESOLUTION);
+}
+
+
+void Board_Debug_Init(void)
+{
+    Chip_UART_Init(DEBUG_UART);
+    Chip_UART_SetBaudFDR(DEBUG_UART, DEBUG_UART_BAUD_RATE);
+    Chip_UART_ConfigData(DEBUG_UART, DEBUG_UART_CONFIG);
+    Chip_UART_TXEnable(DEBUG_UART);
+}
+
+
+void Board_UARTPutChar(char ch)
+{
+    while ( !(Chip_UART_ReadLineStatus(DEBUG_UART) & UART_LSR_THRE));
+    Chip_UART_SendByte(DEBUG_UART, (uint8_t) ch);
+}
+
+
+int Board_UARTGetChar(void)
+{
+    if (Chip_UART_ReadLineStatus(DEBUG_UART) & UART_LSR_RDR) {
+       return (int) Chip_UART_ReadByte(DEBUG_UART);
+    }
+    return EOF;
+}
+
+
+void Board_UARTPutSTR(const char *str)
+{
+    while (*str != '\0') {
+        Board_UARTPutChar(*str++);
+    }
+}
+
+
+void Board_LED_Set(uint8_t LEDNumber, bool On)
+{
+    if (LEDNumber >= GPIO_LEDS_SIZE) {
+        return;
+    }
+
+    const struct gpio_t *io = &GpioLeds[LEDNumber];
+    Chip_GPIO_SetPinState(LPC_GPIO_PORT, io->port, io->pin, !On);
+}
+
+
+bool Board_LED_Test(uint8_t LEDNumber)
+{
+    if (LEDNumber >= GPIO_LEDS_SIZE) {
+        return false;
+    }
+
+    const struct gpio_t *io = &GpioLeds[LEDNumber];
+    return !Chip_GPIO_GetPinState(LPC_GPIO_PORT, io->port, io->pin);
+}
+
+
+void Board_LED_Toggle(uint8_t LEDNumber)
+{
+    Board_LED_Set(LEDNumber, !Board_LED_Test(LEDNumber));
+}
+
+
+void Board_Init(void)
+{
+   DEBUGINIT();
+   Chip_GPIO_Init (LPC_GPIO_PORT);
+
+   Board_LED_Init();
+   Board_TEC_Init();
+   Board_SPI_Init();
+   Board_GPIO_Init();
+   Board_I2C_Init();
+   Board_ADC_Init();
+
+   Chip_ENET_RMIIEnable(LPC_ETHERNET);
+}
+
+
+bool Board_TEC_GetStatus(uint8_t button)
+{
+   if (button >= GPIO_BUTTONS_SIZE) {
+       return false;
+   }
+
+   return Chip_GPIO_GetPinState(LPC_GPIO_PORT, GpioButtons[button].port,
+                                GpioButtons[button].pin);
+}
+
+
+void Board_ADC_ReadBegin(ADC_CHANNEL_T channel)
+{
+    if (channel < ADC_CH0 || channel > ADC_CH3) {
+        return;
+    }
+
+    if (curADCChannel >= ADC_CH0 || curADCChannel <= ADC_CH3) {
+        Chip_ADC_EnableChannel (LPC_ADC0, curADCChannel, DISABLE);
+    }
+
+    curADCChannel = channel;
+
+    Chip_SCU_ADC_Channel_Config(0, channel);
+    Chip_ADC_EnableChannel(LPC_ADC0, channel, ENABLE);
+    Chip_ADC_SetBurstCmd(LPC_ADC0, DISABLE);
+    Chip_ADC_SetStartMode(LPC_ADC0, ADC_START_NOW, ADC_TRIGGERMODE_RISING);
+}
+
+
+bool Board_ADC_ReadWait()
+{
+    return (Chip_ADC_ReadStatus(LPC_ADC0, curADCChannel, ADC_DR_DONE_STAT)
+            == RESET);
+}
+
+
+uint16_t Board_ADC_ReadEnd()
+{
+    uint16_t data;
+
+    if (Chip_ADC_ReadValue(LPC_ADC0, curADCChannel, &data) != SUCCESS) {
+        data = 0xFFFF;
+    }
+
+    Chip_ADC_EnableChannel(LPC_ADC0, curADCChannel, DISABLE);
+    curADCChannel = 0xFF;
+    return data;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board_sysinit.c ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board_sysinit.c
--- a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board_sysinit.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/board_sysinit.c	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,156 @@
+/*
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+
+/*
+    Code reworking to fit the Edu-CIAA board.
+    Santiago Germino, 2018.
+    royconejo@gmail.com
+
+    Please see board.c for comments on this implementation.
+*/
+
+#include "board.h"
+
+/* The System initialization code is called prior to the application and
+   initializes the board for run-time operation. Board initialization
+   includes clock setup and default pin muxing configuration. */
+
+
+struct CLK_BASE_STATES
+{
+   CHIP_CGU_BASE_CLK_T clk;     /* Base clock */
+   CHIP_CGU_CLKIN_T clkin;      /* Base clock source, see UM for allowable souorces per base clock */
+   bool autoblock_enab;         /* Set to true to enable autoblocking on frequency change */
+   bool powerdn;                /* Set to true if the base clock is initially powered down */
+};
+
+
+/* Initial base clock states are mostly on */
+STATIC const struct CLK_BASE_STATES InitClkStates[] =
+{
+   /* Ethernet Clock base */
+   {CLK_BASE_PHY_TX, CLKIN_ENET_TX, true, false},
+   {CLK_BASE_PHY_RX, CLKIN_ENET_TX, true, false},
+   /* Clocks derived from dividers */
+   {CLK_BASE_USB0, CLKIN_IDIVD, true, true}
+};
+
+
+STATIC const PINMUX_GRP_T pinmuxing[] =
+{
+    /* Board LEDs */
+    {2, 0, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC4)},
+    {2, 1, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC4)},
+    {2, 2, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC4)},
+    {2, 10, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC0)},
+    {2, 11, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC0)},
+    {2, 12, (SCU_MODE_INBUFF_EN | SCU_MODE_PULLUP | SCU_MODE_FUNC0)},
+
+    /* Board Buttons */
+    {1, 0, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {1, 1, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {1, 2, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {1, 6, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+
+    /* GPIO0/8 */
+    {6, 1, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {6, 4, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {6, 5, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {6, 7, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC4)},
+    {6, 8, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC4)},
+    {6, 9, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {6,10, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {6,11, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+    {6,12, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC0)},
+
+    /* SPI port (LPC_SSP1) PF_4: SSP1_SCK, P1_3: SSP1_MISO, P1_4: SSP1_MOSI */
+    {0xF, 4, (SCU_PINIO_FAST | SCU_MODE_FUNC0)},
+    {0x1, 3, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC5)},
+    {0x1, 4, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC5)},
+
+    /* UART2 directly wired to FT2232 IC; P7_1: U2_TXD, P7_2: U2_RXD */
+    {7, 1, (SCU_MODE_INACT | SCU_MODE_FUNC6)},
+    {7, 2, (SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_FUNC6)},
+
+    /* UART3: 232_TX/RX on P1 header */
+    {2, 3, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC2)},
+    {2, 4, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC2)},
+
+    /* UART0: RS-485 with on-board transceiver */
+    {9, 5, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC2)},
+    {9, 6, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC7)},
+    {6, 2, (SCU_MODE_INBUFF_EN | SCU_MODE_INACT | SCU_MODE_FUNC7)},
+
+    /* ENET Pin mux (RMII Pins) */
+    {1, 15, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* RXD0 */
+    {1, 16, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC7)}, /* CRS_DV */
+    {1, 17, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* MDIO */
+    {1, 18, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* TXD0 */
+    {1, 19, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC0)}, /* REFCLK */
+    {1, 20, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC3)}, /* TXD1 */
+    {7,  7, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC6)}, /* MDC */
+    {0,  0, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC2)},  /* RXD1 */
+    {0,  1, (SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INACT | SCU_MODE_ZIF_DIS | SCU_MODE_FUNC6)}, /* TXEN */
+};
+
+
+void Board_SetupMuxing(void)
+{
+    Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
+}
+
+
+void Board_SetupClocking(void)
+{
+    Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);
+    Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
+
+    /* Setup system base clocks and initial states. This won't enable and
+       disable individual clocks, but sets up the base clock sources for
+       each individual peripheral clock. */
+    for (uint32_t i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); ++i)
+    {
+        const struct CLK_BASE_STATES *c = &InitClkStates[i];
+        Chip_Clock_SetBaseClock (c->clk, c->clkin, c->autoblock_enab,
+                                c->powerdn);
+    }
+
+    /* Reset and enable 32Khz oscillator */
+    LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
+    LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);
+}
+
+
+/* Set up and initialize hardware prior to call to main */
+void Board_SystemInit(void)
+{
+    /* Setup system clocking and memory. This is done early to allow the
+       application and tools to clear memory and use scatter loading to
+       external memory. */
+    Board_SetupMuxing();
+    Board_SetupClocking();
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/sysinit.c ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/sysinit.c
--- a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/sysinit.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/sysinit.c	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,71 @@
+/*
+ * @brief Common SystemInit function for LPC18xx/LPC43xx chips
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+#if defined(NO_BOARD_LIB)
+#include "chip.h"
+const uint32_t ExtRateIn = 0;
+const uint32_t OscRateIn = 12000000;
+#else
+#include "board.h"
+#endif
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set up and initialize hardware prior to call to main */
+void SystemInit(void)
+{
+   unsigned int *pSCB_VTOR = (unsigned int *) 0xE000ED08;
+
+   extern void *g_pfnVectors;
+
+   *pSCB_VTOR = (unsigned int) &g_pfnVectors;
+
+#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
+   fpuInit();
+#endif
+
+   /* Board specific SystemInit */
+   Board_SystemInit();
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/system.c ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/system.c
--- a_bRU7kv/libs/vendor_libs/lpc_board_ciaa_edu_4337/src/system.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_board_ciaa_edu_4337/src/system.c	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,220 @@
+#include <reent.h>
+#include <errno.h>
+#include <signal.h>
+
+#include <board.h>
+
+#define UNUSED(x) (void)x
+#define SET_ERR(e) (r->_errno = e)
+
+void _exit(int code) {
+   register int __params__ __asm__("r0") = code;
+   while (1)
+       __asm__ __volatile__("bkpt 0");
+
+   (void) __params__;
+}
+
+int _close_r(struct _reent *r, int fd) {
+   UNUSED(fd);
+   SET_ERR(EBADF);
+   return -1;
+}
+
+int _execve_r(struct _reent *r, const char *f, char * const *args,
+       char * const *env) {
+   UNUSED(f);
+   UNUSED(args);
+   UNUSED(env);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _fcntl_r(struct _reent *r, int fd, int cmd, int arg) {
+   UNUSED(fd);
+   UNUSED(cmd);
+   UNUSED(arg);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _fork_r(struct _reent *r) {
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _fstat_r(struct _reent *r, int fd, struct stat *st) {
+   UNUSED(fd);
+   UNUSED(st);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _getpid_r(struct _reent *r) {
+   UNUSED(r);
+   return 1;
+}
+
+int _isatty_r(struct _reent *r, int fd) {
+   switch (fd) {
+   case 0:
+   case 1:
+   case 2:
+       return 1;
+   default:
+       SET_ERR(EBADF);
+       return -1;
+   }
+}
+
+int _kill_r(struct _reent *r, int pid, int signal) {
+   if (pid == _getpid_r(r)) {
+       switch (signal) {
+       case SIGHUP:
+       case SIGINT:
+       case SIGQUIT:
+       case SIGILL:
+       case SIGTRAP:
+       case SIGEMT:
+       case SIGFPE:
+       case SIGKILL:
+       case SIGBUS:
+       case SIGSEGV:
+       case SIGSYS:
+       case SIGPIPE:
+       case SIGALRM:
+       case SIGTERM:
+       default:
+           _exit(0);
+       }
+   } else {
+       SET_ERR(ECHILD);
+   }
+   return -1;
+}
+
+int _link_r(struct _reent *r, const char *oldf, const char *newf) {
+   UNUSED(oldf);
+   UNUSED(newf);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+_off_t _lseek_r(struct _reent *r, int fd, _off_t off, int w) {
+   UNUSED(fd);
+   UNUSED(off);
+   UNUSED(w);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _mkdir_r(struct _reent *r, const char *name, int m) {
+   UNUSED(name);
+   UNUSED(m);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _open_r(struct _reent *r, const char *name, int f, int m) {
+   UNUSED(name);
+   UNUSED(f);
+   UNUSED(m);
+   SET_ERR(EBADF);
+   return -1;
+}
+
+_ssize_t _read_r(struct _reent *r, int fd, void *b, size_t n) {
+  size_t i = 0;
+  char c = 0;
+  switch (fd) {
+  case 0:
+  case 1:
+  case 2:
+      while( i < n ){
+         c = (char)Board_UARTGetChar();
+         if( c != 255 ){
+            if( c != '\r' && c != '\n' ){
+               ((char*) b)[i] = c;
+               i++;
+            }else{
+               ((char*) b)[i] = c;
+               i++;
+               c = (char)Board_UARTGetChar(); // read anotherone to prevent \r\n
+               return i;
+            }
+         }
+      }
+      SET_ERR(ENODEV);
+      return -1;
+  default:
+      SET_ERR(ENODEV);
+      return -1;
+  }
+}
+
+int _rename_r(struct _reent *r, const char *oldf, const char *newf) {
+   UNUSED(oldf);
+   UNUSED(newf);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+void *_sbrk_r(struct _reent *r, ptrdiff_t incr) {
+   extern int _pvHeapStart;
+   static void *heap_end;
+   void *prev_heap_end;
+   if (heap_end == 0) {
+       heap_end = &_pvHeapStart;
+   }
+   prev_heap_end = heap_end;
+   heap_end += incr;
+   return prev_heap_end;
+}
+
+int _stat_r(struct _reent *r, const char *name, struct stat *s) {
+   UNUSED(name);
+   UNUSED(s);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+_CLOCK_T_ _times_r(struct _reent *r, struct tms *tm) {
+   UNUSED(tm);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _unlink_r(struct _reent *r, const char *name) {
+   UNUSED(name);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+int _wait_r(struct _reent *r, int *st) {
+   UNUSED(st);
+   SET_ERR(ENOSYS);
+   return -1;
+}
+
+_ssize_t _write_r(struct _reent *r, int fd, const void *b, size_t n) {
+   size_t i;
+   switch (fd) {
+   case 0:
+   case 1:
+   case 2:
+       for (i = 0; i < n; i++)
+           Board_UARTPutChar(((char*) b)[i]);
+       return n;
+   default:
+       SET_ERR(ENODEV);
+       return -1;
+   }
+}
+
+/* This one is not guaranteed to be available on all targets.  */
+int _gettimeofday_r(struct _reent *r, struct timeval *__tp, void *__tzp) {
+   UNUSED(__tp);
+   UNUSED(__tzp);
+   SET_ERR(ENOSYS);
+   return -1;
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/adc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/adc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/adc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/adc_18xx_43xx.h	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,274 @@
+/*
+ * @brief  LPC18xx/43xx A/D conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ADC_18XX_43XX_H_
+#define __ADC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ADC_18XX_43XX CHIP:  LPC18xx/43xx A/D conversion driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define ADC_ACC_10BITS
+
+#define ADC_MAX_SAMPLE_RATE 400000
+
+/**
+ * @brief 10 or 12-bit ADC register block structure
+ */
+typedef struct {					/*!< ADCn Structure */
+	__IO uint32_t CR;				/*!< A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur. */
+	__I  uint32_t GDR;				/*!< A/D Global Data Register. Contains the result of the most recent A/D conversion. */
+	__I  uint32_t RESERVED0;
+	__IO uint32_t INTEN;			/*!< A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt. */
+	__I  uint32_t DR[8];			/*!< A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel n. */
+	__I  uint32_t STAT;				/*!< A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag. */
+} LPC_ADC_T;
+
+/**
+ * @brief ADC register support bitfields and mask
+ */
+
+#define ADC_DR_RESULT(n)        ((((n) >> 6) & 0x3FF))	/*!< Mask for getting the 10 bits ADC data read value */
+#define ADC_CR_BITACC(n)        ((((n) & 0x7) << 17))	/*!< Number of ADC accuracy bits */
+#define ADC_DR_DONE(n)          (((n) >> 31))			/*!< Mask for reading the ADC done status */
+#define ADC_DR_OVERRUN(n)       ((((n) >> 30) & (1UL)))	/*!< Mask for reading the ADC overrun status */
+#define ADC_CR_CH_SEL(n)        ((1UL << (n)))			/*!< Selects which of the AD0.0:7 pins is (are) to be sampled and converted */
+#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 8))	/*!< The APB clock (PCLK) is divided by (this value plus one) to produce the clock for the A/D */
+#define ADC_CR_BURST            ((1UL << 16))			/*!< Repeated conversions A/D enable bit */
+#define ADC_CR_PDN              ((1UL << 21))			/*!< ADC convert is operational */
+#define ADC_CR_START_MASK       ((7UL << 24))			/*!< ADC start mask bits */
+#define ADC_CR_START_MODE_SEL(SEL)  ((SEL << 24))		/*!< Select Start Mode */
+#define ADC_CR_START_NOW        ((1UL << 24))			/*!< Start conversion now */
+#define ADC_CR_START_CTOUT15    ((2UL << 24))			/*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_15 */
+#define ADC_CR_START_CTOUT8     ((3UL << 24))			/*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_8 */
+#define ADC_CR_START_ADCTRIG0   ((4UL << 24))			/*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG0 */
+#define ADC_CR_START_ADCTRIG1   ((5UL << 24))			/*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG1 */
+#define ADC_CR_START_MCOA2      ((6UL << 24))			/*!< Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2 */
+#define ADC_CR_EDGE             ((1UL << 27))			/*!< Start conversion on a falling edge on the selected CAP/MAT signal */
+#define ADC_SAMPLE_RATE_CONFIG_MASK         (ADC_CR_CLKDIV(0xFF) | ADC_CR_BITACC(0x07))
+
+/**
+ * @brief	ADC status register used for IP drivers
+ */
+typedef enum IP_ADC_STATUS {
+	ADC_DR_DONE_STAT,	/*!< ADC data register staus */
+	ADC_DR_OVERRUN_STAT,/*!< ADC data overrun staus */
+	ADC_DR_ADINT_STAT	/*!< ADC interrupt status */
+} ADC_STATUS_T;
+
+/** The channels on one ADC peripheral*/
+typedef enum CHIP_ADC_CHANNEL {
+	ADC_CH0 = 0,	/**< ADC channel 0 */
+	ADC_CH1,		/**< ADC channel 1 */
+	ADC_CH2,		/**< ADC channel 2 */
+	ADC_CH3,		/**< ADC channel 3 */
+	ADC_CH4,		/**< ADC channel 4 */
+	ADC_CH5,		/**< ADC channel 5 */
+	ADC_CH6,		/**< ADC channel 6 */
+	ADC_CH7,		/**< ADC channel 7 */
+} ADC_CHANNEL_T;
+
+/** The number of bits of accuracy of the result in the LS bits of ADDR*/
+typedef enum CHIP_ADC_RESOLUTION {
+	ADC_10BITS = 0,		/**< ADC 10 bits */
+	ADC_9BITS,			/**< ADC 9 bits  */
+	ADC_8BITS,			/**< ADC 8 bits  */
+	ADC_7BITS,			/**< ADC 7 bits  */
+	ADC_6BITS,			/**< ADC 6 bits  */
+	ADC_5BITS,			/**< ADC 5 bits  */
+	ADC_4BITS,			/**< ADC 4 bits  */
+	ADC_3BITS,			/**< ADC 3 bits  */
+} ADC_RESOLUTION_T;
+
+/** Edge configuration, which controls rising or falling edge on the selected signal for the start of a conversion */
+typedef enum CHIP_ADC_EDGE_CFG {
+	ADC_TRIGGERMODE_RISING = 0,		/**< Trigger event: rising edge */
+	ADC_TRIGGERMODE_FALLING,		/**< Trigger event: falling edge */
+} ADC_EDGE_CFG_T;
+
+/** Start mode, which controls the start of an A/D conversion when the BURST bit is 0. */
+typedef enum CHIP_ADC_START_MODE {
+	ADC_NO_START = 0,
+	ADC_START_NOW,			/*!< Start conversion now */
+	ADC_START_ON_CTOUT15,	/*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_15 */
+	ADC_START_ON_CTOUT8,	/*!< Start conversion when the edge selected by bit 27 occurs on CTOUT_8 */
+	ADC_START_ON_ADCTRIG0,	/*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG0 */
+	ADC_START_ON_ADCTRIG1,	/*!< Start conversion when the edge selected by bit 27 occurs on ADCTRIG1 */
+	ADC_START_ON_MCOA2		/*!< Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2 */
+} ADC_START_MODE_T;
+
+/** Clock setup structure for ADC controller passed to the initialize function */
+typedef struct {
+	uint32_t adcRate;		/*!< ADC rate */
+	uint8_t  bitsAccuracy;	/*!< ADC bit accuracy */
+	bool     burstMode;		/*!< ADC Burt Mode */
+} ADC_CLOCK_SETUP_T;
+
+/**
+ * @brief	Initialize the ADC peripheral and the ADC setup structure to default value
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	ADCSetup	: ADC setup structure to be set
+ * @return	Nothing
+ * @note	Default setting for ADC is 400kHz - 10bits
+ */
+void Chip_ADC_Init(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup);
+
+/**
+ * @brief	Shutdown ADC
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_ADC_DeInit(LPC_ADC_T *pADC);
+
+/**
+ * @brief	Read the ADC value from a channel
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	channel		: ADC channel to read
+ * @param	data		: Pointer to where to put data
+ * @return	SUCCESS or ERROR if no conversion is ready
+ */
+Status Chip_ADC_ReadValue(LPC_ADC_T *pADC, uint8_t channel, uint16_t *data);
+
+/**
+ * @brief	Read the ADC value and convert it to 8bits value
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	channel:	selected channel
+ * @param	data		: Storage for data
+ * @return	Status	: ERROR or SUCCESS
+ */
+Status Chip_ADC_ReadByte(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, uint8_t *data);
+
+/**
+ * @brief	Read the ADC channel status
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	channel		: ADC channel to read
+ * @param	StatusType	: Status type of ADC_DR_*
+ * @return	SET or RESET
+ */
+FlagStatus Chip_ADC_ReadStatus(LPC_ADC_T *pADC, uint8_t channel, uint32_t StatusType);
+
+/**
+ * @brief	Enable/Disable interrupt for ADC channel
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	channel		: ADC channel to read
+ * @param	NewState	: New state, ENABLE or DISABLE
+ * @return	SET or RESET
+ */
+void Chip_ADC_Int_SetChannelCmd(LPC_ADC_T *pADC, uint8_t channel, FunctionalState NewState);
+
+/**
+ * @brief	Enable/Disable global interrupt for ADC channel
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	NewState	: New state, ENABLE or DISABLE
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ADC_Int_SetGlobalCmd(LPC_ADC_T *pADC, FunctionalState NewState)
+{
+	Chip_ADC_Int_SetChannelCmd(pADC, 8, NewState);
+}
+
+/**
+ * @brief	Select the mode starting the AD conversion
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	mode		: Stating mode, should be :
+ *							- ADC_NO_START				: Must be set for Burst mode
+ *							- ADC_START_NOW				: Start conversion now
+ *							- ADC_START_ON_CTOUT15		: Start conversion when the edge selected by bit 27 occurs on CTOUT_15
+ *							- ADC_START_ON_CTOUT8		: Start conversion when the edge selected by bit 27 occurs on CTOUT_8
+ *							- ADC_START_ON_ADCTRIG0		: Start conversion when the edge selected by bit 27 occurs on ADCTRIG0
+ *							- ADC_START_ON_ADCTRIG1		: Start conversion when the edge selected by bit 27 occurs on ADCTRIG1
+ *							- ADC_START_ON_MCOA2		: Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2
+ * @param	EdgeOption	: Stating Edge Condition, should be :
+ *							- ADC_TRIGGERMODE_RISING	: Trigger event on rising edge
+ *							- ADC_TRIGGERMODE_FALLING	: Trigger event on falling edge
+ * @return	Nothing
+ */
+void Chip_ADC_SetStartMode(LPC_ADC_T *pADC, ADC_START_MODE_T mode, ADC_EDGE_CFG_T EdgeOption);
+
+/**
+ * @brief	Set the ADC Sample rate
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	ADCSetup	: ADC setup structure to be modified
+ * @param	rate		: Sample rate, should be set so the clock for A/D converter is less than or equal to 4.5MHz.
+ * @return	Nothing
+ */
+void Chip_ADC_SetSampleRate(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, uint32_t rate);
+
+/**
+ * @brief	Set the ADC accuracy bits
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	ADCSetup	: ADC setup structure to be modified
+ * @param	resolution	: The resolution, should be ADC_10BITS -> ADC_3BITS
+ * @return	Nothing
+ */
+void Chip_ADC_SetResolution(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, ADC_RESOLUTION_T resolution);
+
+/**
+ * @brief	Enable or disable the ADC channel on ADC peripheral
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	channel		: Channel to be enable or disable
+ * @param	NewState	: New state, should be:
+ *								- ENABLE
+ *								- DISABLE
+ * @return	Nothing
+ */
+void Chip_ADC_EnableChannel(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, FunctionalState NewState);
+
+/**
+ * @brief	Enable burst mode
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	NewState	: New state, should be:
+ *							- ENABLE
+ *							- DISABLE
+ * @return	Nothing
+ */
+void Chip_ADC_SetBurstCmd(LPC_ADC_T *pADC, FunctionalState NewState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ADC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/aes_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/aes_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/aes_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/aes_18xx_43xx.h	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,167 @@
+/*
+ * @brief LPC18xx/43xx AES Engine driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __AES_18XX_43XX_H_
+#define __AES_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup AES_18XX_43XX CHIP: LPC18xx/43xx AES Engine driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief	AES Engine operation mode
+ */
+typedef enum CHIP_AES_OP_MODE {
+	CHIP_AES_API_CMD_ENCODE_ECB,	/*!< ECB Encode mode */
+	CHIP_AES_API_CMD_DECODE_ECB,	/*!< ECB Decode mode */
+	CHIP_AES_API_CMD_ENCODE_CBC,	/*!< CBC Encode mode */
+	CHIP_AES_API_CMD_DECODE_CBC,	/*!< CBC Decode mode */
+} CHIP_AES_OP_MODE_T;
+
+/**
+ * @brief	Initialize the AES Engine function
+ * @return	None
+ * This function will initialize all the AES Engine driver function pointers
+ * and call the AES Engine Initialization function.
+ */
+void Chip_AES_Init(void);
+
+/**
+ * @brief	Set operation mode in AES Engine
+ * @param	AesMode		: AES Operation Mode
+ * @return	Status
+ */
+uint32_t Chip_AES_SetMode(CHIP_AES_OP_MODE_T AesMode);
+
+/**
+ * @brief	Load 128-bit AES user key in AES Engine
+ * @param	keyNum: 0 - Load AES 128-bit user key 1, else load user key2
+ * @return	None
+ */
+void Chip_AES_LoadKey(uint32_t keyNum);
+
+/**
+ * @brief	Load randomly generated key in AES engine
+ * @return	None
+ * To update the RNG and load a new random number,
+ * the API call Chip_OTP_GenRand should be used
+ */
+void Chip_AES_LoadKeyRNG(void);
+
+/**
+ * @brief	Load 128-bit AES software defined user key in AES Engine
+ * @param	pKey		: Pointer to 16 byte user key
+ * @return	None
+ */
+void Chip_AES_LoadKeySW(uint8_t *pKey);
+
+/**
+ * @brief Load 128-bit AES initialization vector in AES Engine
+ * @param	pVector		: Pointer to 16 byte Initialisation vector
+ * @return	None
+ */
+void Chip_AES_LoadIV_SW(uint8_t *pVector);
+
+/**
+ * @brief Load IC specific 128-bit AES initialization vector in AES Engine
+ * @return	None
+ * This loads 128-bit AES IC specific initialization vector,
+ * which is used to decrypt a boot image
+ */
+void Chip_AES_LoadIV_IC(void);
+
+/**
+ * @brief Operate AES Engine
+ * @param	pDatOut		: Pointer to output data stream
+ * @param	pDatIn		: Pointer to input data stream
+ * @param	Size		: Size of the data stream (128-bit)
+ * @return	Status
+ * This function performs the AES operation after the AES mode
+ * has been set using Chip_AES_SetMode and the appropriate keys
+ * and init vectors have been loaded
+ */
+uint32_t Chip_AES_Operate(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t Size);
+
+/**
+ * @brief	Program 128-bit AES Key in OTP
+ * @param	KeyNum		: Key Number (Select 0 or 1)
+ * @param	pKey		: Pointer to AES Key (16 bytes required)
+ * @return	Status
+ * When calling the aes_ProgramKey2 function, ensure that VPP = 2.7 V to 3.6 V.
+ */
+uint32_t Chip_AES_ProgramKey(uint32_t KeyNum, uint8_t *pKey);
+
+/**
+ * @brief	Checks for valid AES configuration of the chip and setup 
+ *			DMA channel to process an AES data block.
+ * @param	channel_id	: channel id
+ * @return	Status
+ */
+uint32_t Chip_AES_Config_DMA(uint32_t channel_id);
+
+/**
+ * @brief	Checks for valid AES configuration of the chip and 
+ *			enables DMA channel to process an AES data block.
+ * @param	channel_id	: channel_id
+ * @param	dataOutAddr	: destination address(16 x size of consecutive bytes)
+ * @param	dataInAddr	: source address(16 x size of consecutive bytes)
+ * @param	size		: number of 128 bit AES blocks
+ * @return	Status
+ */
+uint32_t Chip_AES_OperateDMA(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size);
+
+/**
+ * @brief	Read status of DMA channels that process an AES data block.
+ * @param	channel_id	: channel id
+ * @return	Status
+ */
+ uint32_t Chip_AES_GetStatusDMA(uint32_t channel_id);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __AES_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/arm_common_tables.h ./libs/vendor_libs/lpc_chip_43xx/inc/arm_common_tables.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/arm_common_tables.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/arm_common_tables.h	2018-12-01 17:15:06.633606341 -0300
@@ -0,0 +1,99 @@
+/* ----------------------------------------------------------------------
+* Copyright (C) 2010-2013 ARM Limited. All rights reserved.
+*
+* $Date:        17. January 2013
+* $Revision:    V1.4.1
+*
+* Project:      CMSIS DSP Library
+* Title:        arm_common_tables.h
+*
+* Description:  This file has extern declaration for common tables like Bitreverse, reciprocal etc which are used across different functions
+*
+* Target Processor: Cortex-M4/Cortex-M3
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*   - Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   - Redistributions in binary form must reproduce the above copyright
+*     notice, this list of conditions and the following disclaimer in
+*     the documentation and/or other materials provided with the
+*     distribution.
+*   - Neither the name of ARM LIMITED nor the names of its contributors
+*     may be used to endorse or promote products derived from this
+*     software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+* -------------------------------------------------------------------- */
+
+#ifndef _ARM_COMMON_TABLES_H
+#define _ARM_COMMON_TABLES_H
+
+#include "arm_math.h"
+
+extern const uint16_t armBitRevTable[1024];
+extern const q15_t armRecipTableQ15[64];
+extern const q31_t armRecipTableQ31[64];
+extern const q31_t realCoefAQ31[1024];
+extern const q31_t realCoefBQ31[1024];
+extern const float32_t twiddleCoef_16[32];
+extern const float32_t twiddleCoef_32[64];
+extern const float32_t twiddleCoef_64[128];
+extern const float32_t twiddleCoef_128[256];
+extern const float32_t twiddleCoef_256[512];
+extern const float32_t twiddleCoef_512[1024];
+extern const float32_t twiddleCoef_1024[2048];
+extern const float32_t twiddleCoef_2048[4096];
+extern const float32_t twiddleCoef_4096[8192];
+#define twiddleCoef twiddleCoef_4096
+extern const q31_t twiddleCoefQ31[6144];
+extern const q15_t twiddleCoefQ15[6144];
+extern const float32_t twiddleCoef_rfft_32[32];
+extern const float32_t twiddleCoef_rfft_64[64];
+extern const float32_t twiddleCoef_rfft_128[128];
+extern const float32_t twiddleCoef_rfft_256[256];
+extern const float32_t twiddleCoef_rfft_512[512];
+extern const float32_t twiddleCoef_rfft_1024[1024];
+extern const float32_t twiddleCoef_rfft_2048[2048];
+extern const float32_t twiddleCoef_rfft_4096[4096];
+
+
+#define ARMBITREVINDEXTABLE__16_TABLE_LENGTH ((uint16_t)20  )
+#define ARMBITREVINDEXTABLE__32_TABLE_LENGTH ((uint16_t)48  )
+#define ARMBITREVINDEXTABLE__64_TABLE_LENGTH ((uint16_t)56  )
+#define ARMBITREVINDEXTABLE_128_TABLE_LENGTH ((uint16_t)208 )
+#define ARMBITREVINDEXTABLE_256_TABLE_LENGTH ((uint16_t)440 )
+#define ARMBITREVINDEXTABLE_512_TABLE_LENGTH ((uint16_t)448 )
+#define ARMBITREVINDEXTABLE1024_TABLE_LENGTH ((uint16_t)1800)
+#define ARMBITREVINDEXTABLE2048_TABLE_LENGTH ((uint16_t)3808)
+#define ARMBITREVINDEXTABLE4096_TABLE_LENGTH ((uint16_t)4032)
+
+extern const uint16_t armBitRevIndexTable16[ARMBITREVINDEXTABLE__16_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable32[ARMBITREVINDEXTABLE__32_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable64[ARMBITREVINDEXTABLE__64_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable128[ARMBITREVINDEXTABLE_128_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable256[ARMBITREVINDEXTABLE_256_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable512[ARMBITREVINDEXTABLE_512_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable1024[ARMBITREVINDEXTABLE1024_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable2048[ARMBITREVINDEXTABLE2048_TABLE_LENGTH];
+extern const uint16_t armBitRevIndexTable4096[ARMBITREVINDEXTABLE4096_TABLE_LENGTH];
+
+#endif /*  ARM_COMMON_TABLES_H */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/arm_math.h ./libs/vendor_libs/lpc_chip_43xx/inc/arm_math.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/arm_math.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/arm_math.h	2018-12-01 17:15:06.637606391 -0300
@@ -0,0 +1,7312 @@
+/* ----------------------------------------------------------------------
+* Copyright (C) 2010-2013 ARM Limited. All rights reserved.
+*
+* $Date:        17. January 2013
+* $Revision:    V1.4.1
+*
+* Project:      CMSIS DSP Library
+* Title:        arm_math.h
+*
+* Description:  Public header file for CMSIS DSP Library
+*
+* Target Processor: Cortex-M4/Cortex-M3/Cortex-M0
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*   - Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   - Redistributions in binary form must reproduce the above copyright
+*     notice, this list of conditions and the following disclaimer in
+*     the documentation and/or other materials provided with the
+*     distribution.
+*   - Neither the name of ARM LIMITED nor the names of its contributors
+*     may be used to endorse or promote products derived from this
+*     software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------- */
+
+/**
+   \mainpage CMSIS DSP Software Library
+   *
+   * <b>Introduction</b>
+   *
+   * This user manual describes the CMSIS DSP software library,
+   * a suite of common signal processing functions for use on Cortex-M processor based devices.
+   *
+   * The library is divided into a number of functions each covering a specific category:
+   * - Basic math functions
+   * - Fast math functions
+   * - Complex math functions
+   * - Filters
+   * - Matrix functions
+   * - Transforms
+   * - Motor control functions
+   * - Statistical functions
+   * - Support functions
+   * - Interpolation functions
+   *
+   * The library has separate functions for operating on 8-bit integers, 16-bit integers,
+   * 32-bit integer and 32-bit floating-point values.
+   *
+   * <b>Using the Library</b>
+   *
+   * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> folder.
+   * - arm_cortexM4lf_math.lib (Little endian and Floating Point Unit on Cortex-M4)
+   * - arm_cortexM4bf_math.lib (Big endian and Floating Point Unit on Cortex-M4)
+   * - arm_cortexM4l_math.lib (Little endian on Cortex-M4)
+   * - arm_cortexM4b_math.lib (Big endian on Cortex-M4)
+   * - arm_cortexM3l_math.lib (Little endian on Cortex-M3)
+   * - arm_cortexM3b_math.lib (Big endian on Cortex-M3)
+   * - arm_cortexM0l_math.lib (Little endian on Cortex-M0)
+   * - arm_cortexM0b_math.lib (Big endian on Cortex-M3)
+   *
+   * The library functions are declared in the public file <code>arm_math.h</code> which is placed in the <code>Include</code> folder.
+   * Simply include this file and link the appropriate library in the application and begin calling the library functions. The Library supports single
+   * public header file <code> arm_math.h</code> for Cortex-M4/M3/M0 with little endian and big endian. Same header file will be used for floating point unit(FPU) variants.
+   * Define the appropriate pre processor MACRO ARM_MATH_CM4 or  ARM_MATH_CM3 or
+   * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
+   *
+   * <b>Examples</b>
+   *
+   * The library ships with a number of examples which demonstrate how to use the library functions.
+   *
+   * <b>Toolchain Support</b>
+   *
+   * The library has been developed and tested with MDK-ARM version 4.60.
+   * The library is being tested in GCC and IAR toolchains and updates on this activity will be made available shortly.
+   *
+   * <b>Building the Library</b>
+   *
+   * The library installer contains project files to re build libraries on MDK Tool chain in the <code>CMSIS\\DSP_Lib\\Source\\ARM</code> folder.
+   * - arm_cortexM0b_math.uvproj
+   * - arm_cortexM0l_math.uvproj
+   * - arm_cortexM3b_math.uvproj
+   * - arm_cortexM3l_math.uvproj
+   * - arm_cortexM4b_math.uvproj
+   * - arm_cortexM4l_math.uvproj
+   * - arm_cortexM4bf_math.uvproj
+   * - arm_cortexM4lf_math.uvproj
+   *
+   *
+   * The project can be built by opening the appropriate project in MDK-ARM 4.60 chain and defining the optional pre processor MACROs detailed above.
+   *
+   * <b>Pre-processor Macros</b>
+   *
+   * Each library project have differant pre-processor macros.
+   *
+   * - UNALIGNED_SUPPORT_DISABLE:
+   *
+   * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory access
+   *
+   * - ARM_MATH_BIG_ENDIAN:
+   *
+   * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default library builds for little endian targets.
+   *
+   * - ARM_MATH_MATRIX_CHECK:
+   *
+   * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
+   *
+   * - ARM_MATH_ROUNDING:
+   *
+   * Define macro ARM_MATH_ROUNDING for rounding on support functions
+   *
+   * - ARM_MATH_CMx:
+   *
+   * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for building library on Cortex-M3 target
+   * and ARM_MATH_CM0 for building library on cortex-M0 target, ARM_MATH_CM0PLUS for building library on cortex-M0+ target.
+   *
+   * - __FPU_PRESENT:
+   *
+   * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro for M4bf and M4lf libraries
+   *
+   * <b>Copyright Notice</b>
+   *
+   * Copyright (C) 2010-2013 ARM Limited. All rights reserved.
+   */
+
+
+/**
+ * @defgroup groupMath Basic Math Functions
+ */
+
+/**
+ * @defgroup groupFastMath Fast Math Functions
+ * This set of functions provides a fast approximation to sine, cosine, and square root.
+ * As compared to most of the other functions in the CMSIS math library, the fast math functions
+ * operate on individual values and not arrays.
+ * There are separate functions for Q15, Q31, and floating-point data.
+ *
+ */
+
+/**
+ * @defgroup groupCmplxMath Complex Math Functions
+ * This set of functions operates on complex data vectors.
+ * The data in the complex arrays is stored in an interleaved fashion
+ * (real, imag, real, imag, ...).
+ * In the API functions, the number of samples in a complex array refers
+ * to the number of complex values; the array contains twice this number of
+ * real values.
+ */
+
+/**
+ * @defgroup groupFilters Filtering Functions
+ */
+
+/**
+ * @defgroup groupMatrix Matrix Functions
+ *
+ * This set of functions provides basic matrix math operations.
+ * The functions operate on matrix data structures.  For example,
+ * the type
+ * definition for the floating-point matrix structure is shown
+ * below:
+ * <pre>
+ *     typedef struct
+ *     {
+ *       uint16_t numRows;     // number of rows of the matrix.
+ *       uint16_t numCols;     // number of columns of the matrix.
+ *       float32_t *pData;     // points to the data of the matrix.
+ *     } arm_matrix_instance_f32;
+ * </pre>
+ * There are similar definitions for Q15 and Q31 data types.
+ *
+ * The structure specifies the size of the matrix and then points to
+ * an array of data.  The array is of size <code>numRows X numCols</code>
+ * and the values are arranged in row order.  That is, the
+ * matrix element (i, j) is stored at:
+ * <pre>
+ *     pData[i*numCols + j]
+ * </pre>
+ *
+ * \par Init Functions
+ * There is an associated initialization function for each type of matrix
+ * data structure.
+ * The initialization function sets the values of the internal structure fields.
+ * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
+ * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
+ *
+ * \par
+ * Use of the initialization function is optional. However, if initialization function is used
+ * then the instance structure cannot be placed into a const data section.
+ * To place the instance structure in a const data
+ * section, manually initialize the data structure.  For example:
+ * <pre>
+ * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
+ * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
+ * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
+ * </pre>
+ * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
+ * specifies the number of columns, and <code>pData</code> points to the
+ * data array.
+ *
+ * \par Size Checking
+ * By default all of the matrix functions perform size checking on the input and
+ * output matrices.  For example, the matrix addition function verifies that the
+ * two input matrices and the output matrix all have the same number of rows and
+ * columns.  If the size check fails the functions return:
+ * <pre>
+ *     ARM_MATH_SIZE_MISMATCH
+ * </pre>
+ * Otherwise the functions return
+ * <pre>
+ *     ARM_MATH_SUCCESS
+ * </pre>
+ * There is some overhead associated with this matrix size checking.
+ * The matrix size checking is enabled via the \#define
+ * <pre>
+ *     ARM_MATH_MATRIX_CHECK
+ * </pre>
+ * within the library project settings.  By default this macro is defined
+ * and size checking is enabled.  By changing the project settings and
+ * undefining this macro size checking is eliminated and the functions
+ * run a bit faster.  With size checking disabled the functions always
+ * return <code>ARM_MATH_SUCCESS</code>.
+ */
+
+/**
+ * @defgroup groupTransforms Transform Functions
+ */
+
+/**
+ * @defgroup groupController Controller Functions
+ */
+
+/**
+ * @defgroup groupStats Statistics Functions
+ */
+/**
+ * @defgroup groupSupport Support Functions
+ */
+
+/**
+ * @defgroup groupInterpolation Interpolation Functions
+ * These functions perform 1- and 2-dimensional interpolation of data.
+ * Linear interpolation is used for 1-dimensional data and
+ * bilinear interpolation is used for 2-dimensional data.
+ */
+
+/**
+ * @defgroup groupExamples Examples
+ */
+#ifndef _ARM_MATH_H
+#define _ARM_MATH_H
+
+#define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
+
+#if defined (ARM_MATH_CM4)
+#include "core_cm4.h"
+#elif defined (ARM_MATH_CM3)
+#include "core_cm3.h"
+#elif defined (ARM_MATH_CM0)
+#include "core_cm0.h"
+#define ARM_MATH_CM0_FAMILY
+#elif defined (ARM_MATH_CM0PLUS)
+#include "core_cm0plus.h"
+#define ARM_MATH_CM0_FAMILY
+#else
+#include "ARMCM4.h"
+#warning "Define either ARM_MATH_CM4 OR ARM_MATH_CM3...By Default building on ARM_MATH_CM4....."
+#endif
+
+#undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
+#include "string.h"
+#include "math.h"
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+
+  /**
+   * @brief Macros required for reciprocal calculation in Normalized LMS
+   */
+
+#define DELTA_Q31 			(0x100)
+#define DELTA_Q15 			0x5
+#define INDEX_MASK 			0x0000003F
+#ifndef PI
+#define PI					3.14159265358979f
+#endif
+
+  /**
+   * @brief Macros required for SINE and COSINE Fast math approximations
+   */
+
+#define TABLE_SIZE			256
+#define TABLE_SPACING_Q31	0x800000
+#define TABLE_SPACING_Q15	0x80
+
+  /**
+   * @brief Macros required for SINE and COSINE Controller functions
+   */
+  /* 1.31(q31) Fixed value of 2/360 */
+  /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
+#define INPUT_SPACING			0xB60B61
+
+  /**
+   * @brief Macro for Unaligned Support
+   */
+#ifndef UNALIGNED_SUPPORT_DISABLE
+    #define ALIGN4
+#else
+  #if defined  (__GNUC__)
+    #define ALIGN4 __attribute__((aligned(4)))
+  #else
+    #define ALIGN4 __align(4)
+  #endif
+#endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
+
+  /**
+   * @brief Error status returned by some functions in the library.
+   */
+
+  typedef enum
+  {
+    ARM_MATH_SUCCESS = 0,                /**< No error */
+    ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
+    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
+    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
+    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
+    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
+    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
+  } arm_status;
+
+  /**
+   * @brief 8-bit fractional data type in 1.7 format.
+   */
+  typedef int8_t q7_t;
+
+  /**
+   * @brief 16-bit fractional data type in 1.15 format.
+   */
+  typedef int16_t q15_t;
+
+  /**
+   * @brief 32-bit fractional data type in 1.31 format.
+   */
+  typedef int32_t q31_t;
+
+  /**
+   * @brief 64-bit fractional data type in 1.63 format.
+   */
+  typedef int64_t q63_t;
+
+  /**
+   * @brief 32-bit floating-point type definition.
+   */
+  typedef float float32_t;
+
+  /**
+   * @brief 64-bit floating-point type definition.
+   */
+  typedef double float64_t;
+
+  /**
+   * @brief definition to read/write two 16 bit values.
+   */
+#if defined __CC_ARM
+#define __SIMD32_TYPE int32_t __packed
+#define CMSIS_UNUSED __attribute__((unused))
+#elif defined __ICCARM__
+#define CMSIS_UNUSED
+#define __SIMD32_TYPE int32_t __packed
+#elif defined __GNUC__
+#define __SIMD32_TYPE int32_t
+#define CMSIS_UNUSED __attribute__((unused))
+#else
+#error Unknown compiler
+#endif
+
+#define __SIMD32(addr)  (*(__SIMD32_TYPE **) & (addr))
+#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
+
+#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
+
+#define __SIMD64(addr)  (*(int64_t **) & (addr))
+
+#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
+  /**
+   * @brief definition to pack two 16 bit values.
+   */
+#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) | \
+                                         (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
+#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) | \
+                                         (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
+
+#endif
+
+
+   /**
+   * @brief definition to pack four 8 bit values.
+   */
+#ifndef ARM_MATH_BIG_ENDIAN
+
+#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |	\
+                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |	\
+							    (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |	\
+							    (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
+#else
+
+#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |	\
+                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |	\
+							    (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |	\
+							    (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
+
+#endif
+
+
+  /**
+   * @brief Clips Q63 to Q31 values.
+   */
+  static __INLINE q31_t clip_q63_to_q31(
+  q63_t x)
+  {
+    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
+      ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
+  }
+
+  /**
+   * @brief Clips Q63 to Q15 values.
+   */
+  static __INLINE q15_t clip_q63_to_q15(
+  q63_t x)
+  {
+    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
+      ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
+  }
+
+  /**
+   * @brief Clips Q31 to Q7 values.
+   */
+  static __INLINE q7_t clip_q31_to_q7(
+  q31_t x)
+  {
+    return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
+      ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
+  }
+
+  /**
+   * @brief Clips Q31 to Q15 values.
+   */
+  static __INLINE q15_t clip_q31_to_q15(
+  q31_t x)
+  {
+    return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
+      ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
+  }
+
+  /**
+   * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
+   */
+
+  static __INLINE q63_t mult32x64(
+  q63_t x,
+  q31_t y)
+  {
+    return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
+            (((q63_t) (x >> 32) * y)));
+  }
+
+
+#if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
+#define __CLZ __clz
+#endif
+
+#if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__)) ||(defined (__GNUC__)) || defined (__TASKING__) )
+
+  static __INLINE uint32_t __CLZ(
+  q31_t data);
+
+
+  static __INLINE uint32_t __CLZ(
+  q31_t data)
+  {
+    uint32_t count = 0;
+    uint32_t mask = 0x80000000;
+
+    while((data & mask) == 0)
+    {
+      count += 1u;
+      mask = mask >> 1u;
+    }
+
+    return (count);
+
+  }
+
+#endif
+
+  /**
+   * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
+   */
+
+  static __INLINE uint32_t arm_recip_q31(
+  q31_t in,
+  q31_t * dst,
+  q31_t * pRecipTable)
+  {
+
+    uint32_t out, tempVal;
+    uint32_t index, i;
+    uint32_t signBits;
+
+    if(in > 0)
+    {
+      signBits = __CLZ(in) - 1;
+    }
+    else
+    {
+      signBits = __CLZ(-in) - 1;
+    }
+
+    /* Convert input sample to 1.31 format */
+    in = in << signBits;
+
+    /* calculation of index for initial approximated Val */
+    index = (uint32_t) (in >> 24u);
+    index = (index & INDEX_MASK);
+
+    /* 1.31 with exp 1 */
+    out = pRecipTable[index];
+
+    /* calculation of reciprocal value */
+    /* running approximation for two iterations */
+    for (i = 0u; i < 2u; i++)
+    {
+      tempVal = (q31_t) (((q63_t) in * out) >> 31u);
+      tempVal = 0x7FFFFFFF - tempVal;
+      /*      1.31 with exp 1 */
+      //out = (q31_t) (((q63_t) out * tempVal) >> 30u);
+      out = (q31_t) clip_q63_to_q31(((q63_t) out * tempVal) >> 30u);
+    }
+
+    /* write output */
+    *dst = out;
+
+    /* return num of signbits of out = 1/in value */
+    return (signBits + 1u);
+
+  }
+
+  /**
+   * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
+   */
+  static __INLINE uint32_t arm_recip_q15(
+  q15_t in,
+  q15_t * dst,
+  q15_t * pRecipTable)
+  {
+
+    uint32_t out = 0, tempVal = 0;
+    uint32_t index = 0, i = 0;
+    uint32_t signBits = 0;
+
+    if(in > 0)
+    {
+      signBits = __CLZ(in) - 17;
+    }
+    else
+    {
+      signBits = __CLZ(-in) - 17;
+    }
+
+    /* Convert input sample to 1.15 format */
+    in = in << signBits;
+
+    /* calculation of index for initial approximated Val */
+    index = in >> 8;
+    index = (index & INDEX_MASK);
+
+    /*      1.15 with exp 1  */
+    out = pRecipTable[index];
+
+    /* calculation of reciprocal value */
+    /* running approximation for two iterations */
+    for (i = 0; i < 2; i++)
+    {
+      tempVal = (q15_t) (((q31_t) in * out) >> 15);
+      tempVal = 0x7FFF - tempVal;
+      /*      1.15 with exp 1 */
+      out = (q15_t) (((q31_t) out * tempVal) >> 14);
+    }
+
+    /* write output */
+    *dst = out;
+
+    /* return num of signbits of out = 1/in value */
+    return (signBits + 1);
+
+  }
+
+
+  /*
+   * @brief C custom defined intrinisic function for only M0 processors
+   */
+#if defined(ARM_MATH_CM0_FAMILY)
+
+  static __INLINE q31_t __SSAT(
+  q31_t x,
+  uint32_t y)
+  {
+    int32_t posMax, negMin;
+    uint32_t i;
+
+    posMax = 1;
+    for (i = 0; i < (y - 1); i++)
+    {
+      posMax = posMax * 2;
+    }
+
+    if(x > 0)
+    {
+      posMax = (posMax - 1);
+
+      if(x > posMax)
+      {
+        x = posMax;
+      }
+    }
+    else
+    {
+      negMin = -posMax;
+
+      if(x < negMin)
+      {
+        x = negMin;
+      }
+    }
+    return (x);
+
+
+  }
+
+#endif /* end of ARM_MATH_CM0_FAMILY */
+
+
+
+  /*
+   * @brief C custom defined intrinsic function for M3 and M0 processors
+   */
+#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
+
+  /*
+   * @brief C custom defined QADD8 for M3 and M0 processors
+   */
+  static __INLINE q31_t __QADD8(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q7_t r, s, t, u;
+
+    r = (q7_t) x;
+    s = (q7_t) y;
+
+    r = __SSAT((q31_t) (r + s), 8);
+    s = __SSAT(((q31_t) (((x << 16) >> 24) + ((y << 16) >> 24))), 8);
+    t = __SSAT(((q31_t) (((x << 8) >> 24) + ((y << 8) >> 24))), 8);
+    u = __SSAT(((q31_t) ((x >> 24) + (y >> 24))), 8);
+
+    sum =
+      (((q31_t) u << 24) & 0xFF000000) | (((q31_t) t << 16) & 0x00FF0000) |
+      (((q31_t) s << 8) & 0x0000FF00) | (r & 0x000000FF);
+
+    return sum;
+
+  }
+
+  /*
+   * @brief C custom defined QSUB8 for M3 and M0 processors
+   */
+  static __INLINE q31_t __QSUB8(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q31_t r, s, t, u;
+
+    r = (q7_t) x;
+    s = (q7_t) y;
+
+    r = __SSAT((r - s), 8);
+    s = __SSAT(((q31_t) (((x << 16) >> 24) - ((y << 16) >> 24))), 8) << 8;
+    t = __SSAT(((q31_t) (((x << 8) >> 24) - ((y << 8) >> 24))), 8) << 16;
+    u = __SSAT(((q31_t) ((x >> 24) - (y >> 24))), 8) << 24;
+
+    sum =
+      (u & 0xFF000000) | (t & 0x00FF0000) | (s & 0x0000FF00) | (r &
+                                                                0x000000FF);
+
+    return sum;
+  }
+
+  /*
+   * @brief C custom defined QADD16 for M3 and M0 processors
+   */
+
+  /*
+   * @brief C custom defined QADD16 for M3 and M0 processors
+   */
+  static __INLINE q31_t __QADD16(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q31_t r, s;
+
+    r = (short) x;
+    s = (short) y;
+
+    r = __SSAT(r + s, 16);
+    s = __SSAT(((q31_t) ((x >> 16) + (y >> 16))), 16) << 16;
+
+    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
+
+    return sum;
+
+  }
+
+  /*
+   * @brief C custom defined SHADD16 for M3 and M0 processors
+   */
+  static __INLINE q31_t __SHADD16(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q31_t r, s;
+
+    r = (short) x;
+    s = (short) y;
+
+    r = ((r >> 1) + (s >> 1));
+    s = ((q31_t) ((x >> 17) + (y >> 17))) << 16;
+
+    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
+
+    return sum;
+
+  }
+
+  /*
+   * @brief C custom defined QSUB16 for M3 and M0 processors
+   */
+  static __INLINE q31_t __QSUB16(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q31_t r, s;
+
+    r = (short) x;
+    s = (short) y;
+
+    r = __SSAT(r - s, 16);
+    s = __SSAT(((q31_t) ((x >> 16) - (y >> 16))), 16) << 16;
+
+    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
+
+    return sum;
+  }
+
+  /*
+   * @brief C custom defined SHSUB16 for M3 and M0 processors
+   */
+  static __INLINE q31_t __SHSUB16(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t diff;
+    q31_t r, s;
+
+    r = (short) x;
+    s = (short) y;
+
+    r = ((r >> 1) - (s >> 1));
+    s = (((x >> 17) - (y >> 17)) << 16);
+
+    diff = (s & 0xFFFF0000) | (r & 0x0000FFFF);
+
+    return diff;
+  }
+
+  /*
+   * @brief C custom defined QASX for M3 and M0 processors
+   */
+  static __INLINE q31_t __QASX(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum = 0;
+
+    sum =
+      ((sum +
+        clip_q31_to_q15((q31_t) ((short) (x >> 16) + (short) y))) << 16) +
+      clip_q31_to_q15((q31_t) ((short) x - (short) (y >> 16)));
+
+    return sum;
+  }
+
+  /*
+   * @brief C custom defined SHASX for M3 and M0 processors
+   */
+  static __INLINE q31_t __SHASX(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q31_t r, s;
+
+    r = (short) x;
+    s = (short) y;
+
+    r = ((r >> 1) - (y >> 17));
+    s = (((x >> 17) + (s >> 1)) << 16);
+
+    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
+
+    return sum;
+  }
+
+
+  /*
+   * @brief C custom defined QSAX for M3 and M0 processors
+   */
+  static __INLINE q31_t __QSAX(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum = 0;
+
+    sum =
+      ((sum +
+        clip_q31_to_q15((q31_t) ((short) (x >> 16) - (short) y))) << 16) +
+      clip_q31_to_q15((q31_t) ((short) x + (short) (y >> 16)));
+
+    return sum;
+  }
+
+  /*
+   * @brief C custom defined SHSAX for M3 and M0 processors
+   */
+  static __INLINE q31_t __SHSAX(
+  q31_t x,
+  q31_t y)
+  {
+
+    q31_t sum;
+    q31_t r, s;
+
+    r = (short) x;
+    s = (short) y;
+
+    r = ((r >> 1) + (y >> 17));
+    s = (((x >> 17) - (s >> 1)) << 16);
+
+    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
+
+    return sum;
+  }
+
+  /*
+   * @brief C custom defined SMUSDX for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMUSDX(
+  q31_t x,
+  q31_t y)
+  {
+
+    return ((q31_t) (((short) x * (short) (y >> 16)) -
+                     ((short) (x >> 16) * (short) y)));
+  }
+
+  /*
+   * @brief C custom defined SMUADX for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMUADX(
+  q31_t x,
+  q31_t y)
+  {
+
+    return ((q31_t) (((short) x * (short) (y >> 16)) +
+                     ((short) (x >> 16) * (short) y)));
+  }
+
+  /*
+   * @brief C custom defined QADD for M3 and M0 processors
+   */
+  static __INLINE q31_t __QADD(
+  q31_t x,
+  q31_t y)
+  {
+    return clip_q63_to_q31((q63_t) x + y);
+  }
+
+  /*
+   * @brief C custom defined QSUB for M3 and M0 processors
+   */
+  static __INLINE q31_t __QSUB(
+  q31_t x,
+  q31_t y)
+  {
+    return clip_q63_to_q31((q63_t) x - y);
+  }
+
+  /*
+   * @brief C custom defined SMLAD for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMLAD(
+  q31_t x,
+  q31_t y,
+  q31_t sum)
+  {
+
+    return (sum + ((short) (x >> 16) * (short) (y >> 16)) +
+            ((short) x * (short) y));
+  }
+
+  /*
+   * @brief C custom defined SMLADX for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMLADX(
+  q31_t x,
+  q31_t y,
+  q31_t sum)
+  {
+
+    return (sum + ((short) (x >> 16) * (short) (y)) +
+            ((short) x * (short) (y >> 16)));
+  }
+
+  /*
+   * @brief C custom defined SMLSDX for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMLSDX(
+  q31_t x,
+  q31_t y,
+  q31_t sum)
+  {
+
+    return (sum - ((short) (x >> 16) * (short) (y)) +
+            ((short) x * (short) (y >> 16)));
+  }
+
+  /*
+   * @brief C custom defined SMLALD for M3 and M0 processors
+   */
+  static __INLINE q63_t __SMLALD(
+  q31_t x,
+  q31_t y,
+  q63_t sum)
+  {
+
+    return (sum + ((short) (x >> 16) * (short) (y >> 16)) +
+            ((short) x * (short) y));
+  }
+
+  /*
+   * @brief C custom defined SMLALDX for M3 and M0 processors
+   */
+  static __INLINE q63_t __SMLALDX(
+  q31_t x,
+  q31_t y,
+  q63_t sum)
+  {
+
+    return (sum + ((short) (x >> 16) * (short) y)) +
+      ((short) x * (short) (y >> 16));
+  }
+
+  /*
+   * @brief C custom defined SMUAD for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMUAD(
+  q31_t x,
+  q31_t y)
+  {
+
+    return (((x >> 16) * (y >> 16)) +
+            (((x << 16) >> 16) * ((y << 16) >> 16)));
+  }
+
+  /*
+   * @brief C custom defined SMUSD for M3 and M0 processors
+   */
+  static __INLINE q31_t __SMUSD(
+  q31_t x,
+  q31_t y)
+  {
+
+    return (-((x >> 16) * (y >> 16)) +
+            (((x << 16) >> 16) * ((y << 16) >> 16)));
+  }
+
+
+  /*
+   * @brief C custom defined SXTB16 for M3 and M0 processors
+   */
+  static __INLINE q31_t __SXTB16(
+  q31_t x)
+  {
+
+    return ((((x << 24) >> 24) & 0x0000FFFF) |
+            (((x << 8) >> 8) & 0xFFFF0000));
+  }
+
+
+#endif /* defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
+
+
+  /**
+   * @brief Instance structure for the Q7 FIR filter.
+   */
+  typedef struct
+  {
+    uint16_t numTaps;        /**< number of filter coefficients in the filter. */
+    q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
+  } arm_fir_instance_q7;
+
+  /**
+   * @brief Instance structure for the Q15 FIR filter.
+   */
+  typedef struct
+  {
+    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
+    q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
+  } arm_fir_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 FIR filter.
+   */
+  typedef struct
+  {
+    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
+    q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
+  } arm_fir_instance_q31;
+
+  /**
+   * @brief Instance structure for the floating-point FIR filter.
+   */
+  typedef struct
+  {
+    uint16_t numTaps;     /**< number of filter coefficients in the filter. */
+    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
+  } arm_fir_instance_f32;
+
+
+  /**
+   * @brief Processing function for the Q7 FIR filter.
+   * @param[in] *S points to an instance of the Q7 FIR filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_q7(
+  const arm_fir_instance_q7 * S,
+  q7_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Initialization function for the Q7 FIR filter.
+   * @param[in,out] *S points to an instance of the Q7 FIR structure.
+   * @param[in] numTaps  Number of filter coefficients in the filter.
+   * @param[in] *pCoeffs points to the filter coefficients.
+   * @param[in] *pState points to the state buffer.
+   * @param[in] blockSize number of samples that are processed.
+   * @return none
+   */
+  void arm_fir_init_q7(
+  arm_fir_instance_q7 * S,
+  uint16_t numTaps,
+  q7_t * pCoeffs,
+  q7_t * pState,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Processing function for the Q15 FIR filter.
+   * @param[in] *S points to an instance of the Q15 FIR structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_q15(
+  const arm_fir_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
+   * @param[in] *S points to an instance of the Q15 FIR filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_fast_q15(
+  const arm_fir_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q15 FIR filter.
+   * @param[in,out] *S points to an instance of the Q15 FIR filter structure.
+   * @param[in] numTaps  Number of filter coefficients in the filter. Must be even and greater than or equal to 4.
+   * @param[in] *pCoeffs points to the filter coefficients.
+   * @param[in] *pState points to the state buffer.
+   * @param[in] blockSize number of samples that are processed at a time.
+   * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if
+   * <code>numTaps</code> is not a supported value.
+   */
+
+  arm_status arm_fir_init_q15(
+  arm_fir_instance_q15 * S,
+  uint16_t numTaps,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q31 FIR filter.
+   * @param[in] *S points to an instance of the Q31 FIR filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_q31(
+  const arm_fir_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
+   * @param[in] *S points to an instance of the Q31 FIR structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_fast_q31(
+  const arm_fir_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q31 FIR filter.
+   * @param[in,out] *S points to an instance of the Q31 FIR structure.
+   * @param[in] 	numTaps  Number of filter coefficients in the filter.
+   * @param[in] 	*pCoeffs points to the filter coefficients.
+   * @param[in] 	*pState points to the state buffer.
+   * @param[in] 	blockSize number of samples that are processed at a time.
+   * @return 		none.
+   */
+  void arm_fir_init_q31(
+  arm_fir_instance_q31 * S,
+  uint16_t numTaps,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the floating-point FIR filter.
+   * @param[in] *S points to an instance of the floating-point FIR structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_f32(
+  const arm_fir_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the floating-point FIR filter.
+   * @param[in,out] *S points to an instance of the floating-point FIR filter structure.
+   * @param[in] 	numTaps  Number of filter coefficients in the filter.
+   * @param[in] 	*pCoeffs points to the filter coefficients.
+   * @param[in] 	*pState points to the state buffer.
+   * @param[in] 	blockSize number of samples that are processed at a time.
+   * @return    	none.
+   */
+  void arm_fir_init_f32(
+  arm_fir_instance_f32 * S,
+  uint16_t numTaps,
+  float32_t * pCoeffs,
+  float32_t * pState,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Instance structure for the Q15 Biquad cascade filter.
+   */
+  typedef struct
+  {
+    int8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+    q15_t *pState;            /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
+    q15_t *pCoeffs;           /**< Points to the array of coefficients.  The array is of length 5*numStages. */
+    int8_t postShift;         /**< Additional shift, in bits, applied to each output sample. */
+
+  } arm_biquad_casd_df1_inst_q15;
+
+
+  /**
+   * @brief Instance structure for the Q31 Biquad cascade filter.
+   */
+  typedef struct
+  {
+    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+    q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
+    q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
+    uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
+
+  } arm_biquad_casd_df1_inst_q31;
+
+  /**
+   * @brief Instance structure for the floating-point Biquad cascade filter.
+   */
+  typedef struct
+  {
+    uint32_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+    float32_t *pState;          /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
+    float32_t *pCoeffs;         /**< Points to the array of coefficients.  The array is of length 5*numStages. */
+
+
+  } arm_biquad_casd_df1_inst_f32;
+
+
+
+  /**
+   * @brief Processing function for the Q15 Biquad cascade filter.
+   * @param[in]  *S points to an instance of the Q15 Biquad cascade structure.
+   * @param[in]  *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in]  blockSize number of samples to process.
+   * @return     none.
+   */
+
+  void arm_biquad_cascade_df1_q15(
+  const arm_biquad_casd_df1_inst_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q15 Biquad cascade filter.
+   * @param[in,out] *S           points to an instance of the Q15 Biquad cascade structure.
+   * @param[in]     numStages    number of 2nd order stages in the filter.
+   * @param[in]     *pCoeffs     points to the filter coefficients.
+   * @param[in]     *pState      points to the state buffer.
+   * @param[in]     postShift    Shift to be applied to the output. Varies according to the coefficients format
+   * @return        none
+   */
+
+  void arm_biquad_cascade_df1_init_q15(
+  arm_biquad_casd_df1_inst_q15 * S,
+  uint8_t numStages,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  int8_t postShift);
+
+
+  /**
+   * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.
+   * @param[in]  *S points to an instance of the Q15 Biquad cascade structure.
+   * @param[in]  *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in]  blockSize number of samples to process.
+   * @return     none.
+   */
+
+  void arm_biquad_cascade_df1_fast_q15(
+  const arm_biquad_casd_df1_inst_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Processing function for the Q31 Biquad cascade filter
+   * @param[in]  *S         points to an instance of the Q31 Biquad cascade structure.
+   * @param[in]  *pSrc      points to the block of input data.
+   * @param[out] *pDst      points to the block of output data.
+   * @param[in]  blockSize  number of samples to process.
+   * @return     none.
+   */
+
+  void arm_biquad_cascade_df1_q31(
+  const arm_biquad_casd_df1_inst_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.
+   * @param[in]  *S         points to an instance of the Q31 Biquad cascade structure.
+   * @param[in]  *pSrc      points to the block of input data.
+   * @param[out] *pDst      points to the block of output data.
+   * @param[in]  blockSize  number of samples to process.
+   * @return     none.
+   */
+
+  void arm_biquad_cascade_df1_fast_q31(
+  const arm_biquad_casd_df1_inst_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q31 Biquad cascade filter.
+   * @param[in,out] *S           points to an instance of the Q31 Biquad cascade structure.
+   * @param[in]     numStages      number of 2nd order stages in the filter.
+   * @param[in]     *pCoeffs     points to the filter coefficients.
+   * @param[in]     *pState      points to the state buffer.
+   * @param[in]     postShift    Shift to be applied to the output. Varies according to the coefficients format
+   * @return        none
+   */
+
+  void arm_biquad_cascade_df1_init_q31(
+  arm_biquad_casd_df1_inst_q31 * S,
+  uint8_t numStages,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  int8_t postShift);
+
+  /**
+   * @brief Processing function for the floating-point Biquad cascade filter.
+   * @param[in]  *S         points to an instance of the floating-point Biquad cascade structure.
+   * @param[in]  *pSrc      points to the block of input data.
+   * @param[out] *pDst      points to the block of output data.
+   * @param[in]  blockSize  number of samples to process.
+   * @return     none.
+   */
+
+  void arm_biquad_cascade_df1_f32(
+  const arm_biquad_casd_df1_inst_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the floating-point Biquad cascade filter.
+   * @param[in,out] *S           points to an instance of the floating-point Biquad cascade structure.
+   * @param[in]     numStages    number of 2nd order stages in the filter.
+   * @param[in]     *pCoeffs     points to the filter coefficients.
+   * @param[in]     *pState      points to the state buffer.
+   * @return        none
+   */
+
+  void arm_biquad_cascade_df1_init_f32(
+  arm_biquad_casd_df1_inst_f32 * S,
+  uint8_t numStages,
+  float32_t * pCoeffs,
+  float32_t * pState);
+
+
+  /**
+   * @brief Instance structure for the floating-point matrix structure.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;     /**< number of rows of the matrix.     */
+    uint16_t numCols;     /**< number of columns of the matrix.  */
+    float32_t *pData;     /**< points to the data of the matrix. */
+  } arm_matrix_instance_f32;
+
+  /**
+   * @brief Instance structure for the Q15 matrix structure.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;     /**< number of rows of the matrix.     */
+    uint16_t numCols;     /**< number of columns of the matrix.  */
+    q15_t *pData;         /**< points to the data of the matrix. */
+
+  } arm_matrix_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 matrix structure.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;     /**< number of rows of the matrix.     */
+    uint16_t numCols;     /**< number of columns of the matrix.  */
+    q31_t *pData;         /**< points to the data of the matrix. */
+
+  } arm_matrix_instance_q31;
+
+
+
+  /**
+   * @brief Floating-point matrix addition.
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_add_f32(
+  const arm_matrix_instance_f32 * pSrcA,
+  const arm_matrix_instance_f32 * pSrcB,
+  arm_matrix_instance_f32 * pDst);
+
+  /**
+   * @brief Q15 matrix addition.
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_add_q15(
+  const arm_matrix_instance_q15 * pSrcA,
+  const arm_matrix_instance_q15 * pSrcB,
+  arm_matrix_instance_q15 * pDst);
+
+  /**
+   * @brief Q31 matrix addition.
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_add_q31(
+  const arm_matrix_instance_q31 * pSrcA,
+  const arm_matrix_instance_q31 * pSrcB,
+  arm_matrix_instance_q31 * pDst);
+
+
+  /**
+   * @brief Floating-point matrix transpose.
+   * @param[in]  *pSrc points to the input matrix
+   * @param[out] *pDst points to the output matrix
+   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
+   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_trans_f32(
+  const arm_matrix_instance_f32 * pSrc,
+  arm_matrix_instance_f32 * pDst);
+
+
+  /**
+   * @brief Q15 matrix transpose.
+   * @param[in]  *pSrc points to the input matrix
+   * @param[out] *pDst points to the output matrix
+   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
+   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_trans_q15(
+  const arm_matrix_instance_q15 * pSrc,
+  arm_matrix_instance_q15 * pDst);
+
+  /**
+   * @brief Q31 matrix transpose.
+   * @param[in]  *pSrc points to the input matrix
+   * @param[out] *pDst points to the output matrix
+   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
+   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_trans_q31(
+  const arm_matrix_instance_q31 * pSrc,
+  arm_matrix_instance_q31 * pDst);
+
+
+  /**
+   * @brief Floating-point matrix multiplication
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_mult_f32(
+  const arm_matrix_instance_f32 * pSrcA,
+  const arm_matrix_instance_f32 * pSrcB,
+  arm_matrix_instance_f32 * pDst);
+
+  /**
+   * @brief Q15 matrix multiplication
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @param[in]		  *pState points to the array for storing intermediate results
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_mult_q15(
+  const arm_matrix_instance_q15 * pSrcA,
+  const arm_matrix_instance_q15 * pSrcB,
+  arm_matrix_instance_q15 * pDst,
+  q15_t * pState);
+
+  /**
+   * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
+   * @param[in]       *pSrcA  points to the first input matrix structure
+   * @param[in]       *pSrcB  points to the second input matrix structure
+   * @param[out]      *pDst   points to output matrix structure
+   * @param[in]		  *pState points to the array for storing intermediate results
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_mult_fast_q15(
+  const arm_matrix_instance_q15 * pSrcA,
+  const arm_matrix_instance_q15 * pSrcB,
+  arm_matrix_instance_q15 * pDst,
+  q15_t * pState);
+
+  /**
+   * @brief Q31 matrix multiplication
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_mult_q31(
+  const arm_matrix_instance_q31 * pSrcA,
+  const arm_matrix_instance_q31 * pSrcB,
+  arm_matrix_instance_q31 * pDst);
+
+  /**
+   * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_mult_fast_q31(
+  const arm_matrix_instance_q31 * pSrcA,
+  const arm_matrix_instance_q31 * pSrcB,
+  arm_matrix_instance_q31 * pDst);
+
+
+  /**
+   * @brief Floating-point matrix subtraction
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_sub_f32(
+  const arm_matrix_instance_f32 * pSrcA,
+  const arm_matrix_instance_f32 * pSrcB,
+  arm_matrix_instance_f32 * pDst);
+
+  /**
+   * @brief Q15 matrix subtraction
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_sub_q15(
+  const arm_matrix_instance_q15 * pSrcA,
+  const arm_matrix_instance_q15 * pSrcB,
+  arm_matrix_instance_q15 * pDst);
+
+  /**
+   * @brief Q31 matrix subtraction
+   * @param[in]       *pSrcA points to the first input matrix structure
+   * @param[in]       *pSrcB points to the second input matrix structure
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_sub_q31(
+  const arm_matrix_instance_q31 * pSrcA,
+  const arm_matrix_instance_q31 * pSrcB,
+  arm_matrix_instance_q31 * pDst);
+
+  /**
+   * @brief Floating-point matrix scaling.
+   * @param[in]  *pSrc points to the input matrix
+   * @param[in]  scale scale factor
+   * @param[out] *pDst points to the output matrix
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_scale_f32(
+  const arm_matrix_instance_f32 * pSrc,
+  float32_t scale,
+  arm_matrix_instance_f32 * pDst);
+
+  /**
+   * @brief Q15 matrix scaling.
+   * @param[in]       *pSrc points to input matrix
+   * @param[in]       scaleFract fractional portion of the scale factor
+   * @param[in]       shift number of bits to shift the result by
+   * @param[out]      *pDst points to output matrix
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_scale_q15(
+  const arm_matrix_instance_q15 * pSrc,
+  q15_t scaleFract,
+  int32_t shift,
+  arm_matrix_instance_q15 * pDst);
+
+  /**
+   * @brief Q31 matrix scaling.
+   * @param[in]       *pSrc points to input matrix
+   * @param[in]       scaleFract fractional portion of the scale factor
+   * @param[in]       shift number of bits to shift the result by
+   * @param[out]      *pDst points to output matrix structure
+   * @return     The function returns either
+   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
+   */
+
+  arm_status arm_mat_scale_q31(
+  const arm_matrix_instance_q31 * pSrc,
+  q31_t scaleFract,
+  int32_t shift,
+  arm_matrix_instance_q31 * pDst);
+
+
+  /**
+   * @brief  Q31 matrix initialization.
+   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
+   * @param[in]     nRows          number of rows in the matrix.
+   * @param[in]     nColumns       number of columns in the matrix.
+   * @param[in]     *pData	       points to the matrix data array.
+   * @return        none
+   */
+
+  void arm_mat_init_q31(
+  arm_matrix_instance_q31 * S,
+  uint16_t nRows,
+  uint16_t nColumns,
+  q31_t * pData);
+
+  /**
+   * @brief  Q15 matrix initialization.
+   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
+   * @param[in]     nRows          number of rows in the matrix.
+   * @param[in]     nColumns       number of columns in the matrix.
+   * @param[in]     *pData	       points to the matrix data array.
+   * @return        none
+   */
+
+  void arm_mat_init_q15(
+  arm_matrix_instance_q15 * S,
+  uint16_t nRows,
+  uint16_t nColumns,
+  q15_t * pData);
+
+  /**
+   * @brief  Floating-point matrix initialization.
+   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
+   * @param[in]     nRows          number of rows in the matrix.
+   * @param[in]     nColumns       number of columns in the matrix.
+   * @param[in]     *pData	       points to the matrix data array.
+   * @return        none
+   */
+
+  void arm_mat_init_f32(
+  arm_matrix_instance_f32 * S,
+  uint16_t nRows,
+  uint16_t nColumns,
+  float32_t * pData);
+
+
+
+  /**
+   * @brief Instance structure for the Q15 PID Control.
+   */
+  typedef struct
+  {
+    q15_t A0;    /**< The derived gain, A0 = Kp + Ki + Kd . */
+#ifdef ARM_MATH_CM0_FAMILY
+    q15_t A1;
+    q15_t A2;
+#else
+    q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
+#endif
+    q15_t state[3];       /**< The state array of length 3. */
+    q15_t Kp;           /**< The proportional gain. */
+    q15_t Ki;           /**< The integral gain. */
+    q15_t Kd;           /**< The derivative gain. */
+  } arm_pid_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 PID Control.
+   */
+  typedef struct
+  {
+    q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
+    q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
+    q31_t A2;            /**< The derived gain, A2 = Kd . */
+    q31_t state[3];      /**< The state array of length 3. */
+    q31_t Kp;            /**< The proportional gain. */
+    q31_t Ki;            /**< The integral gain. */
+    q31_t Kd;            /**< The derivative gain. */
+
+  } arm_pid_instance_q31;
+
+  /**
+   * @brief Instance structure for the floating-point PID Control.
+   */
+  typedef struct
+  {
+    float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
+    float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
+    float32_t A2;          /**< The derived gain, A2 = Kd . */
+    float32_t state[3];    /**< The state array of length 3. */
+    float32_t Kp;               /**< The proportional gain. */
+    float32_t Ki;               /**< The integral gain. */
+    float32_t Kd;               /**< The derivative gain. */
+  } arm_pid_instance_f32;
+
+
+
+  /**
+   * @brief  Initialization function for the floating-point PID Control.
+   * @param[in,out] *S      points to an instance of the PID structure.
+   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
+   * @return none.
+   */
+  void arm_pid_init_f32(
+  arm_pid_instance_f32 * S,
+  int32_t resetStateFlag);
+
+  /**
+   * @brief  Reset function for the floating-point PID Control.
+   * @param[in,out] *S is an instance of the floating-point PID Control structure
+   * @return none
+   */
+  void arm_pid_reset_f32(
+  arm_pid_instance_f32 * S);
+
+
+  /**
+   * @brief  Initialization function for the Q31 PID Control.
+   * @param[in,out] *S points to an instance of the Q15 PID structure.
+   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
+   * @return none.
+   */
+  void arm_pid_init_q31(
+  arm_pid_instance_q31 * S,
+  int32_t resetStateFlag);
+
+
+  /**
+   * @brief  Reset function for the Q31 PID Control.
+   * @param[in,out] *S points to an instance of the Q31 PID Control structure
+   * @return none
+   */
+
+  void arm_pid_reset_q31(
+  arm_pid_instance_q31 * S);
+
+  /**
+   * @brief  Initialization function for the Q15 PID Control.
+   * @param[in,out] *S points to an instance of the Q15 PID structure.
+   * @param[in] resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
+   * @return none.
+   */
+  void arm_pid_init_q15(
+  arm_pid_instance_q15 * S,
+  int32_t resetStateFlag);
+
+  /**
+   * @brief  Reset function for the Q15 PID Control.
+   * @param[in,out] *S points to an instance of the q15 PID Control structure
+   * @return none
+   */
+  void arm_pid_reset_q15(
+  arm_pid_instance_q15 * S);
+
+
+  /**
+   * @brief Instance structure for the floating-point Linear Interpolate function.
+   */
+  typedef struct
+  {
+    uint32_t nValues;           /**< nValues */
+    float32_t x1;               /**< x1 */
+    float32_t xSpacing;         /**< xSpacing */
+    float32_t *pYData;          /**< pointer to the table of Y values */
+  } arm_linear_interp_instance_f32;
+
+  /**
+   * @brief Instance structure for the floating-point bilinear interpolation function.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;   /**< number of rows in the data table. */
+    uint16_t numCols;   /**< number of columns in the data table. */
+    float32_t *pData;   /**< points to the data table. */
+  } arm_bilinear_interp_instance_f32;
+
+   /**
+   * @brief Instance structure for the Q31 bilinear interpolation function.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;   /**< number of rows in the data table. */
+    uint16_t numCols;   /**< number of columns in the data table. */
+    q31_t *pData;       /**< points to the data table. */
+  } arm_bilinear_interp_instance_q31;
+
+   /**
+   * @brief Instance structure for the Q15 bilinear interpolation function.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;   /**< number of rows in the data table. */
+    uint16_t numCols;   /**< number of columns in the data table. */
+    q15_t *pData;       /**< points to the data table. */
+  } arm_bilinear_interp_instance_q15;
+
+   /**
+   * @brief Instance structure for the Q15 bilinear interpolation function.
+   */
+
+  typedef struct
+  {
+    uint16_t numRows;   /**< number of rows in the data table. */
+    uint16_t numCols;   /**< number of columns in the data table. */
+    q7_t *pData;                /**< points to the data table. */
+  } arm_bilinear_interp_instance_q7;
+
+
+  /**
+   * @brief Q7 vector multiplication.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst  points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_mult_q7(
+  q7_t * pSrcA,
+  q7_t * pSrcB,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q15 vector multiplication.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst  points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_mult_q15(
+  q15_t * pSrcA,
+  q15_t * pSrcB,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q31 vector multiplication.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_mult_q31(
+  q31_t * pSrcA,
+  q31_t * pSrcB,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Floating-point vector multiplication.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_mult_f32(
+  float32_t * pSrcA,
+  float32_t * pSrcB,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+
+
+
+
+
+  /**
+   * @brief Instance structure for the Q15 CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                 /**< length of the FFT. */
+    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    q15_t *pTwiddle;                     /**< points to the Sin twiddle factor table. */
+    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+  } arm_cfft_radix2_instance_q15;
+
+  arm_status arm_cfft_radix2_init_q15(
+  arm_cfft_radix2_instance_q15 * S,
+  uint16_t fftLen,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+  void arm_cfft_radix2_q15(
+  const arm_cfft_radix2_instance_q15 * S,
+  q15_t * pSrc);
+
+
+
+  /**
+   * @brief Instance structure for the Q15 CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                 /**< length of the FFT. */
+    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
+    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+  } arm_cfft_radix4_instance_q15;
+
+  arm_status arm_cfft_radix4_init_q15(
+  arm_cfft_radix4_instance_q15 * S,
+  uint16_t fftLen,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+  void arm_cfft_radix4_q15(
+  const arm_cfft_radix4_instance_q15 * S,
+  q15_t * pSrc);
+
+  /**
+   * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                 /**< length of the FFT. */
+    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    q31_t *pTwiddle;                     /**< points to the Twiddle factor table. */
+    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+  } arm_cfft_radix2_instance_q31;
+
+  arm_status arm_cfft_radix2_init_q31(
+  arm_cfft_radix2_instance_q31 * S,
+  uint16_t fftLen,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+  void arm_cfft_radix2_q31(
+  const arm_cfft_radix2_instance_q31 * S,
+  q31_t * pSrc);
+
+  /**
+   * @brief Instance structure for the Q31 CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                 /**< length of the FFT. */
+    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
+    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+  } arm_cfft_radix4_instance_q31;
+
+
+  void arm_cfft_radix4_q31(
+  const arm_cfft_radix4_instance_q31 * S,
+  q31_t * pSrc);
+
+  arm_status arm_cfft_radix4_init_q31(
+  arm_cfft_radix4_instance_q31 * S,
+  uint16_t fftLen,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+  /**
+   * @brief Instance structure for the floating-point CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                   /**< length of the FFT. */
+    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
+    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
+    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+    float32_t onebyfftLen;                 /**< value of 1/fftLen. */
+  } arm_cfft_radix2_instance_f32;
+
+/* Deprecated */
+  arm_status arm_cfft_radix2_init_f32(
+  arm_cfft_radix2_instance_f32 * S,
+  uint16_t fftLen,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+/* Deprecated */
+  void arm_cfft_radix2_f32(
+  const arm_cfft_radix2_instance_f32 * S,
+  float32_t * pSrc);
+
+  /**
+   * @brief Instance structure for the floating-point CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                   /**< length of the FFT. */
+    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
+    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
+    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+    float32_t onebyfftLen;                 /**< value of 1/fftLen. */
+  } arm_cfft_radix4_instance_f32;
+
+/* Deprecated */
+  arm_status arm_cfft_radix4_init_f32(
+  arm_cfft_radix4_instance_f32 * S,
+  uint16_t fftLen,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+/* Deprecated */
+  void arm_cfft_radix4_f32(
+  const arm_cfft_radix4_instance_f32 * S,
+  float32_t * pSrc);
+
+  /**
+   * @brief Instance structure for the floating-point CFFT/CIFFT function.
+   */
+
+  typedef struct
+  {
+    uint16_t fftLen;                   /**< length of the FFT. */
+    const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
+    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
+    uint16_t bitRevLength;             /**< bit reversal table length. */
+  } arm_cfft_instance_f32;
+
+  void arm_cfft_f32(
+  const arm_cfft_instance_f32 * S,
+  float32_t * p1,
+  uint8_t ifftFlag,
+  uint8_t bitReverseFlag);
+
+  /**
+   * @brief Instance structure for the Q15 RFFT/RIFFT function.
+   */
+
+  typedef struct
+  {
+    uint32_t fftLenReal;                      /**< length of the real FFT. */
+    uint32_t fftLenBy2;                       /**< length of the complex FFT. */
+    uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
+    uint8_t bitReverseFlagR;                      /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
+    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
+    q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
+    arm_cfft_radix4_instance_q15 *pCfft;          /**< points to the complex FFT instance. */
+  } arm_rfft_instance_q15;
+
+  arm_status arm_rfft_init_q15(
+  arm_rfft_instance_q15 * S,
+  arm_cfft_radix4_instance_q15 * S_CFFT,
+  uint32_t fftLenReal,
+  uint32_t ifftFlagR,
+  uint32_t bitReverseFlag);
+
+  void arm_rfft_q15(
+  const arm_rfft_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst);
+
+  /**
+   * @brief Instance structure for the Q31 RFFT/RIFFT function.
+   */
+
+  typedef struct
+  {
+    uint32_t fftLenReal;                        /**< length of the real FFT. */
+    uint32_t fftLenBy2;                         /**< length of the complex FFT. */
+    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
+    uint8_t bitReverseFlagR;                        /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
+    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
+    q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
+    arm_cfft_radix4_instance_q31 *pCfft;        /**< points to the complex FFT instance. */
+  } arm_rfft_instance_q31;
+
+  arm_status arm_rfft_init_q31(
+  arm_rfft_instance_q31 * S,
+  arm_cfft_radix4_instance_q31 * S_CFFT,
+  uint32_t fftLenReal,
+  uint32_t ifftFlagR,
+  uint32_t bitReverseFlag);
+
+  void arm_rfft_q31(
+  const arm_rfft_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst);
+
+  /**
+   * @brief Instance structure for the floating-point RFFT/RIFFT function.
+   */
+
+  typedef struct
+  {
+    uint32_t fftLenReal;                        /**< length of the real FFT. */
+    uint16_t fftLenBy2;                         /**< length of the complex FFT. */
+    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
+    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
+    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
+    float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
+    arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
+  } arm_rfft_instance_f32;
+
+  arm_status arm_rfft_init_f32(
+  arm_rfft_instance_f32 * S,
+  arm_cfft_radix4_instance_f32 * S_CFFT,
+  uint32_t fftLenReal,
+  uint32_t ifftFlagR,
+  uint32_t bitReverseFlag);
+
+  void arm_rfft_f32(
+  const arm_rfft_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst);
+
+  /**
+   * @brief Instance structure for the floating-point RFFT/RIFFT function.
+   */
+
+typedef struct
+  {
+    arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
+    uint16_t fftLenRFFT;                        /**< length of the real sequence */
+	float32_t * pTwiddleRFFT;					/**< Twiddle factors real stage  */
+  } arm_rfft_fast_instance_f32 ;
+
+arm_status arm_rfft_fast_init_f32 (
+	arm_rfft_fast_instance_f32 * S,
+	uint16_t fftLen);
+
+void arm_rfft_fast_f32(
+  arm_rfft_fast_instance_f32 * S,
+  float32_t * p, float32_t * pOut,
+  uint8_t ifftFlag);
+
+  /**
+   * @brief Instance structure for the floating-point DCT4/IDCT4 function.
+   */
+
+  typedef struct
+  {
+    uint16_t N;                         /**< length of the DCT4. */
+    uint16_t Nby2;                      /**< half of the length of the DCT4. */
+    float32_t normalize;                /**< normalizing factor. */
+    float32_t *pTwiddle;                /**< points to the twiddle factor table. */
+    float32_t *pCosFactor;              /**< points to the cosFactor table. */
+    arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
+    arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
+  } arm_dct4_instance_f32;
+
+  /**
+   * @brief  Initialization function for the floating-point DCT4/IDCT4.
+   * @param[in,out] *S         points to an instance of floating-point DCT4/IDCT4 structure.
+   * @param[in]     *S_RFFT    points to an instance of floating-point RFFT/RIFFT structure.
+   * @param[in]     *S_CFFT    points to an instance of floating-point CFFT/CIFFT structure.
+   * @param[in]     N          length of the DCT4.
+   * @param[in]     Nby2       half of the length of the DCT4.
+   * @param[in]     normalize  normalizing factor.
+   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length.
+   */
+
+  arm_status arm_dct4_init_f32(
+  arm_dct4_instance_f32 * S,
+  arm_rfft_instance_f32 * S_RFFT,
+  arm_cfft_radix4_instance_f32 * S_CFFT,
+  uint16_t N,
+  uint16_t Nby2,
+  float32_t normalize);
+
+  /**
+   * @brief Processing function for the floating-point DCT4/IDCT4.
+   * @param[in]       *S             points to an instance of the floating-point DCT4/IDCT4 structure.
+   * @param[in]       *pState        points to state buffer.
+   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
+   * @return none.
+   */
+
+  void arm_dct4_f32(
+  const arm_dct4_instance_f32 * S,
+  float32_t * pState,
+  float32_t * pInlineBuffer);
+
+  /**
+   * @brief Instance structure for the Q31 DCT4/IDCT4 function.
+   */
+
+  typedef struct
+  {
+    uint16_t N;                         /**< length of the DCT4. */
+    uint16_t Nby2;                      /**< half of the length of the DCT4. */
+    q31_t normalize;                    /**< normalizing factor. */
+    q31_t *pTwiddle;                    /**< points to the twiddle factor table. */
+    q31_t *pCosFactor;                  /**< points to the cosFactor table. */
+    arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
+    arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
+  } arm_dct4_instance_q31;
+
+  /**
+   * @brief  Initialization function for the Q31 DCT4/IDCT4.
+   * @param[in,out] *S         points to an instance of Q31 DCT4/IDCT4 structure.
+   * @param[in]     *S_RFFT    points to an instance of Q31 RFFT/RIFFT structure
+   * @param[in]     *S_CFFT    points to an instance of Q31 CFFT/CIFFT structure
+   * @param[in]     N          length of the DCT4.
+   * @param[in]     Nby2       half of the length of the DCT4.
+   * @param[in]     normalize  normalizing factor.
+   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
+   */
+
+  arm_status arm_dct4_init_q31(
+  arm_dct4_instance_q31 * S,
+  arm_rfft_instance_q31 * S_RFFT,
+  arm_cfft_radix4_instance_q31 * S_CFFT,
+  uint16_t N,
+  uint16_t Nby2,
+  q31_t normalize);
+
+  /**
+   * @brief Processing function for the Q31 DCT4/IDCT4.
+   * @param[in]       *S             points to an instance of the Q31 DCT4 structure.
+   * @param[in]       *pState        points to state buffer.
+   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
+   * @return none.
+   */
+
+  void arm_dct4_q31(
+  const arm_dct4_instance_q31 * S,
+  q31_t * pState,
+  q31_t * pInlineBuffer);
+
+  /**
+   * @brief Instance structure for the Q15 DCT4/IDCT4 function.
+   */
+
+  typedef struct
+  {
+    uint16_t N;                         /**< length of the DCT4. */
+    uint16_t Nby2;                      /**< half of the length of the DCT4. */
+    q15_t normalize;                    /**< normalizing factor. */
+    q15_t *pTwiddle;                    /**< points to the twiddle factor table. */
+    q15_t *pCosFactor;                  /**< points to the cosFactor table. */
+    arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
+    arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
+  } arm_dct4_instance_q15;
+
+  /**
+   * @brief  Initialization function for the Q15 DCT4/IDCT4.
+   * @param[in,out] *S         points to an instance of Q15 DCT4/IDCT4 structure.
+   * @param[in]     *S_RFFT    points to an instance of Q15 RFFT/RIFFT structure.
+   * @param[in]     *S_CFFT    points to an instance of Q15 CFFT/CIFFT structure.
+   * @param[in]     N          length of the DCT4.
+   * @param[in]     Nby2       half of the length of the DCT4.
+   * @param[in]     normalize  normalizing factor.
+   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
+   */
+
+  arm_status arm_dct4_init_q15(
+  arm_dct4_instance_q15 * S,
+  arm_rfft_instance_q15 * S_RFFT,
+  arm_cfft_radix4_instance_q15 * S_CFFT,
+  uint16_t N,
+  uint16_t Nby2,
+  q15_t normalize);
+
+  /**
+   * @brief Processing function for the Q15 DCT4/IDCT4.
+   * @param[in]       *S             points to an instance of the Q15 DCT4 structure.
+   * @param[in]       *pState        points to state buffer.
+   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
+   * @return none.
+   */
+
+  void arm_dct4_q15(
+  const arm_dct4_instance_q15 * S,
+  q15_t * pState,
+  q15_t * pInlineBuffer);
+
+  /**
+   * @brief Floating-point vector addition.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_add_f32(
+  float32_t * pSrcA,
+  float32_t * pSrcB,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q7 vector addition.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_add_q7(
+  q7_t * pSrcA,
+  q7_t * pSrcB,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q15 vector addition.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_add_q15(
+  q15_t * pSrcA,
+  q15_t * pSrcB,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q31 vector addition.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_add_q31(
+  q31_t * pSrcA,
+  q31_t * pSrcB,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Floating-point vector subtraction.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_sub_f32(
+  float32_t * pSrcA,
+  float32_t * pSrcB,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q7 vector subtraction.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_sub_q7(
+  q7_t * pSrcA,
+  q7_t * pSrcB,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q15 vector subtraction.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_sub_q15(
+  q15_t * pSrcA,
+  q15_t * pSrcB,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q31 vector subtraction.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_sub_q31(
+  q31_t * pSrcA,
+  q31_t * pSrcB,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Multiplies a floating-point vector by a scalar.
+   * @param[in]       *pSrc points to the input vector
+   * @param[in]       scale scale factor to be applied
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_scale_f32(
+  float32_t * pSrc,
+  float32_t scale,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Multiplies a Q7 vector by a scalar.
+   * @param[in]       *pSrc points to the input vector
+   * @param[in]       scaleFract fractional portion of the scale value
+   * @param[in]       shift number of bits to shift the result by
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_scale_q7(
+  q7_t * pSrc,
+  q7_t scaleFract,
+  int8_t shift,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Multiplies a Q15 vector by a scalar.
+   * @param[in]       *pSrc points to the input vector
+   * @param[in]       scaleFract fractional portion of the scale value
+   * @param[in]       shift number of bits to shift the result by
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_scale_q15(
+  q15_t * pSrc,
+  q15_t scaleFract,
+  int8_t shift,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Multiplies a Q31 vector by a scalar.
+   * @param[in]       *pSrc points to the input vector
+   * @param[in]       scaleFract fractional portion of the scale value
+   * @param[in]       shift number of bits to shift the result by
+   * @param[out]      *pDst points to the output vector
+   * @param[in]       blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_scale_q31(
+  q31_t * pSrc,
+  q31_t scaleFract,
+  int8_t shift,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q7 vector absolute value.
+   * @param[in]       *pSrc points to the input buffer
+   * @param[out]      *pDst points to the output buffer
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_abs_q7(
+  q7_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Floating-point vector absolute value.
+   * @param[in]       *pSrc points to the input buffer
+   * @param[out]      *pDst points to the output buffer
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_abs_f32(
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q15 vector absolute value.
+   * @param[in]       *pSrc points to the input buffer
+   * @param[out]      *pDst points to the output buffer
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_abs_q15(
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Q31 vector absolute value.
+   * @param[in]       *pSrc points to the input buffer
+   * @param[out]      *pDst points to the output buffer
+   * @param[in]       blockSize number of samples in each vector
+   * @return none.
+   */
+
+  void arm_abs_q31(
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Dot product of floating-point vectors.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[in]       blockSize number of samples in each vector
+   * @param[out]      *result output result returned here
+   * @return none.
+   */
+
+  void arm_dot_prod_f32(
+  float32_t * pSrcA,
+  float32_t * pSrcB,
+  uint32_t blockSize,
+  float32_t * result);
+
+  /**
+   * @brief Dot product of Q7 vectors.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[in]       blockSize number of samples in each vector
+   * @param[out]      *result output result returned here
+   * @return none.
+   */
+
+  void arm_dot_prod_q7(
+  q7_t * pSrcA,
+  q7_t * pSrcB,
+  uint32_t blockSize,
+  q31_t * result);
+
+  /**
+   * @brief Dot product of Q15 vectors.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[in]       blockSize number of samples in each vector
+   * @param[out]      *result output result returned here
+   * @return none.
+   */
+
+  void arm_dot_prod_q15(
+  q15_t * pSrcA,
+  q15_t * pSrcB,
+  uint32_t blockSize,
+  q63_t * result);
+
+  /**
+   * @brief Dot product of Q31 vectors.
+   * @param[in]       *pSrcA points to the first input vector
+   * @param[in]       *pSrcB points to the second input vector
+   * @param[in]       blockSize number of samples in each vector
+   * @param[out]      *result output result returned here
+   * @return none.
+   */
+
+  void arm_dot_prod_q31(
+  q31_t * pSrcA,
+  q31_t * pSrcB,
+  uint32_t blockSize,
+  q63_t * result);
+
+  /**
+   * @brief  Shifts the elements of a Q7 vector a specified number of bits.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_shift_q7(
+  q7_t * pSrc,
+  int8_t shiftBits,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Shifts the elements of a Q15 vector a specified number of bits.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_shift_q15(
+  q15_t * pSrc,
+  int8_t shiftBits,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Shifts the elements of a Q31 vector a specified number of bits.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_shift_q31(
+  q31_t * pSrc,
+  int8_t shiftBits,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Adds a constant offset to a floating-point vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  offset is the offset to be added
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_offset_f32(
+  float32_t * pSrc,
+  float32_t offset,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Adds a constant offset to a Q7 vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  offset is the offset to be added
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_offset_q7(
+  q7_t * pSrc,
+  q7_t offset,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Adds a constant offset to a Q15 vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  offset is the offset to be added
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_offset_q15(
+  q15_t * pSrc,
+  q15_t offset,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Adds a constant offset to a Q31 vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[in]  offset is the offset to be added
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_offset_q31(
+  q31_t * pSrc,
+  q31_t offset,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Negates the elements of a floating-point vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_negate_f32(
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Negates the elements of a Q7 vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_negate_q7(
+  q7_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Negates the elements of a Q15 vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_negate_q15(
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Negates the elements of a Q31 vector.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  blockSize number of samples in the vector
+   * @return none.
+   */
+
+  void arm_negate_q31(
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+  /**
+   * @brief  Copies the elements of a floating-point vector.
+   * @param[in]  *pSrc input pointer
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_copy_f32(
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Copies the elements of a Q7 vector.
+   * @param[in]  *pSrc input pointer
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_copy_q7(
+  q7_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Copies the elements of a Q15 vector.
+   * @param[in]  *pSrc input pointer
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_copy_q15(
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Copies the elements of a Q31 vector.
+   * @param[in]  *pSrc input pointer
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_copy_q31(
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+  /**
+   * @brief  Fills a constant value into a floating-point vector.
+   * @param[in]  value input value to be filled
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_fill_f32(
+  float32_t value,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Fills a constant value into a Q7 vector.
+   * @param[in]  value input value to be filled
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_fill_q7(
+  q7_t value,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Fills a constant value into a Q15 vector.
+   * @param[in]  value input value to be filled
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_fill_q15(
+  q15_t value,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Fills a constant value into a Q31 vector.
+   * @param[in]  value input value to be filled
+   * @param[out]  *pDst output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_fill_q31(
+  q31_t value,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+/**
+ * @brief Convolution of floating-point sequences.
+ * @param[in] *pSrcA points to the first input sequence.
+ * @param[in] srcALen length of the first input sequence.
+ * @param[in] *pSrcB points to the second input sequence.
+ * @param[in] srcBLen length of the second input sequence.
+ * @param[out] *pDst points to the location where the output result is written.  Length srcALen+srcBLen-1.
+ * @return none.
+ */
+
+  void arm_conv_f32(
+  float32_t * pSrcA,
+  uint32_t srcALen,
+  float32_t * pSrcB,
+  uint32_t srcBLen,
+  float32_t * pDst);
+
+
+  /**
+   * @brief Convolution of Q15 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
+   * @return none.
+   */
+
+
+  void arm_conv_opt_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+/**
+ * @brief Convolution of Q15 sequences.
+ * @param[in] *pSrcA points to the first input sequence.
+ * @param[in] srcALen length of the first input sequence.
+ * @param[in] *pSrcB points to the second input sequence.
+ * @param[in] srcBLen length of the second input sequence.
+ * @param[out] *pDst points to the location where the output result is written.  Length srcALen+srcBLen-1.
+ * @return none.
+ */
+
+  void arm_conv_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst);
+
+  /**
+   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @return none.
+   */
+
+  void arm_conv_fast_q15(
+			  q15_t * pSrcA,
+			 uint32_t srcALen,
+			  q15_t * pSrcB,
+			 uint32_t srcBLen,
+			 q15_t * pDst);
+
+  /**
+   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
+   * @return none.
+   */
+
+  void arm_conv_fast_opt_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+
+  /**
+   * @brief Convolution of Q31 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @return none.
+   */
+
+  void arm_conv_q31(
+  q31_t * pSrcA,
+  uint32_t srcALen,
+  q31_t * pSrcB,
+  uint32_t srcBLen,
+  q31_t * pDst);
+
+  /**
+   * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @return none.
+   */
+
+  void arm_conv_fast_q31(
+  q31_t * pSrcA,
+  uint32_t srcALen,
+  q31_t * pSrcB,
+  uint32_t srcBLen,
+  q31_t * pDst);
+
+
+    /**
+   * @brief Convolution of Q7 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
+   * @return none.
+   */
+
+  void arm_conv_opt_q7(
+  q7_t * pSrcA,
+  uint32_t srcALen,
+  q7_t * pSrcB,
+  uint32_t srcBLen,
+  q7_t * pDst,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+
+  /**
+   * @brief Convolution of Q7 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
+   * @return none.
+   */
+
+  void arm_conv_q7(
+  q7_t * pSrcA,
+  uint32_t srcALen,
+  q7_t * pSrcB,
+  uint32_t srcBLen,
+  q7_t * pDst);
+
+
+  /**
+   * @brief Partial convolution of floating-point sequences.
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_f32(
+  float32_t * pSrcA,
+  uint32_t srcALen,
+  float32_t * pSrcB,
+  uint32_t srcBLen,
+  float32_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints);
+
+    /**
+   * @brief Partial convolution of Q15 sequences.
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_opt_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+/**
+   * @brief Partial convolution of Q15 sequences.
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints);
+
+  /**
+   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_fast_q15(
+				        q15_t * pSrcA,
+				       uint32_t srcALen,
+				        q15_t * pSrcB,
+				       uint32_t srcBLen,
+				       q15_t * pDst,
+				       uint32_t firstIndex,
+				       uint32_t numPoints);
+
+
+  /**
+   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_fast_opt_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+  /**
+   * @brief Partial convolution of Q31 sequences.
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_q31(
+  q31_t * pSrcA,
+  uint32_t srcALen,
+  q31_t * pSrcB,
+  uint32_t srcBLen,
+  q31_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints);
+
+
+  /**
+   * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_fast_q31(
+  q31_t * pSrcA,
+  uint32_t srcALen,
+  q31_t * pSrcB,
+  uint32_t srcBLen,
+  q31_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints);
+
+
+  /**
+   * @brief Partial convolution of Q7 sequences
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_opt_q7(
+  q7_t * pSrcA,
+  uint32_t srcALen,
+  q7_t * pSrcB,
+  uint32_t srcBLen,
+  q7_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+/**
+   * @brief Partial convolution of Q7 sequences.
+   * @param[in]       *pSrcA points to the first input sequence.
+   * @param[in]       srcALen length of the first input sequence.
+   * @param[in]       *pSrcB points to the second input sequence.
+   * @param[in]       srcBLen length of the second input sequence.
+   * @param[out]      *pDst points to the block of output data
+   * @param[in]       firstIndex is the first output sample to start with.
+   * @param[in]       numPoints is the number of output points to be computed.
+   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
+   */
+
+  arm_status arm_conv_partial_q7(
+  q7_t * pSrcA,
+  uint32_t srcALen,
+  q7_t * pSrcB,
+  uint32_t srcBLen,
+  q7_t * pDst,
+  uint32_t firstIndex,
+  uint32_t numPoints);
+
+
+
+  /**
+   * @brief Instance structure for the Q15 FIR decimator.
+   */
+
+  typedef struct
+  {
+    uint8_t M;                      /**< decimation factor. */
+    uint16_t numTaps;               /**< number of coefficients in the filter. */
+    q15_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numTaps.*/
+    q15_t *pState;                   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+  } arm_fir_decimate_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 FIR decimator.
+   */
+
+  typedef struct
+  {
+    uint8_t M;                  /**< decimation factor. */
+    uint16_t numTaps;           /**< number of coefficients in the filter. */
+    q31_t *pCoeffs;              /**< points to the coefficient array. The array is of length numTaps.*/
+    q31_t *pState;               /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+
+  } arm_fir_decimate_instance_q31;
+
+  /**
+   * @brief Instance structure for the floating-point FIR decimator.
+   */
+
+  typedef struct
+  {
+    uint8_t M;                          /**< decimation factor. */
+    uint16_t numTaps;                   /**< number of coefficients in the filter. */
+    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numTaps.*/
+    float32_t *pState;                   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+
+  } arm_fir_decimate_instance_f32;
+
+
+
+  /**
+   * @brief Processing function for the floating-point FIR decimator.
+   * @param[in] *S points to an instance of the floating-point FIR decimator structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none
+   */
+
+  void arm_fir_decimate_f32(
+  const arm_fir_decimate_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Initialization function for the floating-point FIR decimator.
+   * @param[in,out] *S points to an instance of the floating-point FIR decimator structure.
+   * @param[in] numTaps  number of coefficients in the filter.
+   * @param[in] M  decimation factor.
+   * @param[in] *pCoeffs points to the filter coefficients.
+   * @param[in] *pState points to the state buffer.
+   * @param[in] blockSize number of input samples to process per call.
+   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
+   * <code>blockSize</code> is not a multiple of <code>M</code>.
+   */
+
+  arm_status arm_fir_decimate_init_f32(
+  arm_fir_decimate_instance_f32 * S,
+  uint16_t numTaps,
+  uint8_t M,
+  float32_t * pCoeffs,
+  float32_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q15 FIR decimator.
+   * @param[in] *S points to an instance of the Q15 FIR decimator structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none
+   */
+
+  void arm_fir_decimate_q15(
+  const arm_fir_decimate_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
+   * @param[in] *S points to an instance of the Q15 FIR decimator structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none
+   */
+
+  void arm_fir_decimate_fast_q15(
+  const arm_fir_decimate_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+
+
+  /**
+   * @brief  Initialization function for the Q15 FIR decimator.
+   * @param[in,out] *S points to an instance of the Q15 FIR decimator structure.
+   * @param[in] numTaps  number of coefficients in the filter.
+   * @param[in] M  decimation factor.
+   * @param[in] *pCoeffs points to the filter coefficients.
+   * @param[in] *pState points to the state buffer.
+   * @param[in] blockSize number of input samples to process per call.
+   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
+   * <code>blockSize</code> is not a multiple of <code>M</code>.
+   */
+
+  arm_status arm_fir_decimate_init_q15(
+  arm_fir_decimate_instance_q15 * S,
+  uint16_t numTaps,
+  uint8_t M,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q31 FIR decimator.
+   * @param[in] *S points to an instance of the Q31 FIR decimator structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none
+   */
+
+  void arm_fir_decimate_q31(
+  const arm_fir_decimate_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
+   * @param[in] *S points to an instance of the Q31 FIR decimator structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none
+   */
+
+  void arm_fir_decimate_fast_q31(
+  arm_fir_decimate_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Initialization function for the Q31 FIR decimator.
+   * @param[in,out] *S points to an instance of the Q31 FIR decimator structure.
+   * @param[in] numTaps  number of coefficients in the filter.
+   * @param[in] M  decimation factor.
+   * @param[in] *pCoeffs points to the filter coefficients.
+   * @param[in] *pState points to the state buffer.
+   * @param[in] blockSize number of input samples to process per call.
+   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
+   * <code>blockSize</code> is not a multiple of <code>M</code>.
+   */
+
+  arm_status arm_fir_decimate_init_q31(
+  arm_fir_decimate_instance_q31 * S,
+  uint16_t numTaps,
+  uint8_t M,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  uint32_t blockSize);
+
+
+
+  /**
+   * @brief Instance structure for the Q15 FIR interpolator.
+   */
+
+  typedef struct
+  {
+    uint8_t L;                      /**< upsample factor. */
+    uint16_t phaseLength;           /**< length of each polyphase filter component. */
+    q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
+    q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
+  } arm_fir_interpolate_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 FIR interpolator.
+   */
+
+  typedef struct
+  {
+    uint8_t L;                      /**< upsample factor. */
+    uint16_t phaseLength;           /**< length of each polyphase filter component. */
+    q31_t *pCoeffs;                  /**< points to the coefficient array. The array is of length L*phaseLength. */
+    q31_t *pState;                   /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
+  } arm_fir_interpolate_instance_q31;
+
+  /**
+   * @brief Instance structure for the floating-point FIR interpolator.
+   */
+
+  typedef struct
+  {
+    uint8_t L;                     /**< upsample factor. */
+    uint16_t phaseLength;          /**< length of each polyphase filter component. */
+    float32_t *pCoeffs;             /**< points to the coefficient array. The array is of length L*phaseLength. */
+    float32_t *pState;              /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
+  } arm_fir_interpolate_instance_f32;
+
+
+  /**
+   * @brief Processing function for the Q15 FIR interpolator.
+   * @param[in] *S        points to an instance of the Q15 FIR interpolator structure.
+   * @param[in] *pSrc     points to the block of input data.
+   * @param[out] *pDst    points to the block of output data.
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_interpolate_q15(
+  const arm_fir_interpolate_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Initialization function for the Q15 FIR interpolator.
+   * @param[in,out] *S        points to an instance of the Q15 FIR interpolator structure.
+   * @param[in]     L         upsample factor.
+   * @param[in]     numTaps   number of filter coefficients in the filter.
+   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
+   * @param[in]     *pState   points to the state buffer.
+   * @param[in]     blockSize number of input samples to process per call.
+   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
+   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
+   */
+
+  arm_status arm_fir_interpolate_init_q15(
+  arm_fir_interpolate_instance_q15 * S,
+  uint8_t L,
+  uint16_t numTaps,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q31 FIR interpolator.
+   * @param[in] *S        points to an instance of the Q15 FIR interpolator structure.
+   * @param[in] *pSrc     points to the block of input data.
+   * @param[out] *pDst    points to the block of output data.
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_interpolate_q31(
+  const arm_fir_interpolate_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q31 FIR interpolator.
+   * @param[in,out] *S        points to an instance of the Q31 FIR interpolator structure.
+   * @param[in]     L         upsample factor.
+   * @param[in]     numTaps   number of filter coefficients in the filter.
+   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
+   * @param[in]     *pState   points to the state buffer.
+   * @param[in]     blockSize number of input samples to process per call.
+   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
+   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
+   */
+
+  arm_status arm_fir_interpolate_init_q31(
+  arm_fir_interpolate_instance_q31 * S,
+  uint8_t L,
+  uint16_t numTaps,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Processing function for the floating-point FIR interpolator.
+   * @param[in] *S        points to an instance of the floating-point FIR interpolator structure.
+   * @param[in] *pSrc     points to the block of input data.
+   * @param[out] *pDst    points to the block of output data.
+   * @param[in] blockSize number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_interpolate_f32(
+  const arm_fir_interpolate_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the floating-point FIR interpolator.
+   * @param[in,out] *S        points to an instance of the floating-point FIR interpolator structure.
+   * @param[in]     L         upsample factor.
+   * @param[in]     numTaps   number of filter coefficients in the filter.
+   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
+   * @param[in]     *pState   points to the state buffer.
+   * @param[in]     blockSize number of input samples to process per call.
+   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
+   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
+   */
+
+  arm_status arm_fir_interpolate_init_f32(
+  arm_fir_interpolate_instance_f32 * S,
+  uint8_t L,
+  uint16_t numTaps,
+  float32_t * pCoeffs,
+  float32_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Instance structure for the high precision Q31 Biquad cascade filter.
+   */
+
+  typedef struct
+  {
+    uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+    q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
+    q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
+    uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
+
+  } arm_biquad_cas_df1_32x64_ins_q31;
+
+
+  /**
+   * @param[in]  *S        points to an instance of the high precision Q31 Biquad cascade filter structure.
+   * @param[in]  *pSrc     points to the block of input data.
+   * @param[out] *pDst     points to the block of output data
+   * @param[in]  blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_biquad_cas_df1_32x64_q31(
+  const arm_biquad_cas_df1_32x64_ins_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @param[in,out] *S           points to an instance of the high precision Q31 Biquad cascade filter structure.
+   * @param[in]     numStages    number of 2nd order stages in the filter.
+   * @param[in]     *pCoeffs     points to the filter coefficients.
+   * @param[in]     *pState      points to the state buffer.
+   * @param[in]     postShift    shift to be applied to the output. Varies according to the coefficients format
+   * @return        none
+   */
+
+  void arm_biquad_cas_df1_32x64_init_q31(
+  arm_biquad_cas_df1_32x64_ins_q31 * S,
+  uint8_t numStages,
+  q31_t * pCoeffs,
+  q63_t * pState,
+  uint8_t postShift);
+
+
+
+  /**
+   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
+   */
+
+  typedef struct
+  {
+    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
+    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
+  } arm_biquad_cascade_df2T_instance_f32;
+
+
+  /**
+   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
+   * @param[in]  *S        points to an instance of the filter data structure.
+   * @param[in]  *pSrc     points to the block of input data.
+   * @param[out] *pDst     points to the block of output data
+   * @param[in]  blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_biquad_cascade_df2T_f32(
+  const arm_biquad_cascade_df2T_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
+   * @param[in,out] *S           points to an instance of the filter data structure.
+   * @param[in]     numStages    number of 2nd order stages in the filter.
+   * @param[in]     *pCoeffs     points to the filter coefficients.
+   * @param[in]     *pState      points to the state buffer.
+   * @return        none
+   */
+
+  void arm_biquad_cascade_df2T_init_f32(
+  arm_biquad_cascade_df2T_instance_f32 * S,
+  uint8_t numStages,
+  float32_t * pCoeffs,
+  float32_t * pState);
+
+
+
+  /**
+   * @brief Instance structure for the Q15 FIR lattice filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numStages;                          /**< number of filter stages. */
+    q15_t *pState;                               /**< points to the state variable array. The array is of length numStages. */
+    q15_t *pCoeffs;                              /**< points to the coefficient array. The array is of length numStages. */
+  } arm_fir_lattice_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 FIR lattice filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numStages;                          /**< number of filter stages. */
+    q31_t *pState;                               /**< points to the state variable array. The array is of length numStages. */
+    q31_t *pCoeffs;                              /**< points to the coefficient array. The array is of length numStages. */
+  } arm_fir_lattice_instance_q31;
+
+  /**
+   * @brief Instance structure for the floating-point FIR lattice filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numStages;                  /**< number of filter stages. */
+    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
+    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
+  } arm_fir_lattice_instance_f32;
+
+  /**
+   * @brief Initialization function for the Q15 FIR lattice filter.
+   * @param[in] *S points to an instance of the Q15 FIR lattice structure.
+   * @param[in] numStages  number of filter stages.
+   * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
+   * @param[in] *pState points to the state buffer.  The array is of length numStages.
+   * @return none.
+   */
+
+  void arm_fir_lattice_init_q15(
+  arm_fir_lattice_instance_q15 * S,
+  uint16_t numStages,
+  q15_t * pCoeffs,
+  q15_t * pState);
+
+
+  /**
+   * @brief Processing function for the Q15 FIR lattice filter.
+   * @param[in] *S points to an instance of the Q15 FIR lattice structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+  void arm_fir_lattice_q15(
+  const arm_fir_lattice_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Initialization function for the Q31 FIR lattice filter.
+   * @param[in] *S points to an instance of the Q31 FIR lattice structure.
+   * @param[in] numStages  number of filter stages.
+   * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
+   * @param[in] *pState points to the state buffer.   The array is of length numStages.
+   * @return none.
+   */
+
+  void arm_fir_lattice_init_q31(
+  arm_fir_lattice_instance_q31 * S,
+  uint16_t numStages,
+  q31_t * pCoeffs,
+  q31_t * pState);
+
+
+  /**
+   * @brief Processing function for the Q31 FIR lattice filter.
+   * @param[in]  *S        points to an instance of the Q31 FIR lattice structure.
+   * @param[in]  *pSrc     points to the block of input data.
+   * @param[out] *pDst     points to the block of output data
+   * @param[in]  blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_fir_lattice_q31(
+  const arm_fir_lattice_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+/**
+ * @brief Initialization function for the floating-point FIR lattice filter.
+ * @param[in] *S points to an instance of the floating-point FIR lattice structure.
+ * @param[in] numStages  number of filter stages.
+ * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
+ * @param[in] *pState points to the state buffer.  The array is of length numStages.
+ * @return none.
+ */
+
+  void arm_fir_lattice_init_f32(
+  arm_fir_lattice_instance_f32 * S,
+  uint16_t numStages,
+  float32_t * pCoeffs,
+  float32_t * pState);
+
+  /**
+   * @brief Processing function for the floating-point FIR lattice filter.
+   * @param[in]  *S        points to an instance of the floating-point FIR lattice structure.
+   * @param[in]  *pSrc     points to the block of input data.
+   * @param[out] *pDst     points to the block of output data
+   * @param[in]  blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_fir_lattice_f32(
+  const arm_fir_lattice_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Instance structure for the Q15 IIR lattice filter.
+   */
+  typedef struct
+  {
+    uint16_t numStages;                         /**< number of stages in the filter. */
+    q15_t *pState;                              /**< points to the state variable array. The array is of length numStages+blockSize. */
+    q15_t *pkCoeffs;                            /**< points to the reflection coefficient array. The array is of length numStages. */
+    q15_t *pvCoeffs;                            /**< points to the ladder coefficient array. The array is of length numStages+1. */
+  } arm_iir_lattice_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q31 IIR lattice filter.
+   */
+  typedef struct
+  {
+    uint16_t numStages;                         /**< number of stages in the filter. */
+    q31_t *pState;                              /**< points to the state variable array. The array is of length numStages+blockSize. */
+    q31_t *pkCoeffs;                            /**< points to the reflection coefficient array. The array is of length numStages. */
+    q31_t *pvCoeffs;                            /**< points to the ladder coefficient array. The array is of length numStages+1. */
+  } arm_iir_lattice_instance_q31;
+
+  /**
+   * @brief Instance structure for the floating-point IIR lattice filter.
+   */
+  typedef struct
+  {
+    uint16_t numStages;                         /**< number of stages in the filter. */
+    float32_t *pState;                          /**< points to the state variable array. The array is of length numStages+blockSize. */
+    float32_t *pkCoeffs;                        /**< points to the reflection coefficient array. The array is of length numStages. */
+    float32_t *pvCoeffs;                        /**< points to the ladder coefficient array. The array is of length numStages+1. */
+  } arm_iir_lattice_instance_f32;
+
+  /**
+   * @brief Processing function for the floating-point IIR lattice filter.
+   * @param[in] *S points to an instance of the floating-point IIR lattice structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_iir_lattice_f32(
+  const arm_iir_lattice_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Initialization function for the floating-point IIR lattice filter.
+   * @param[in] *S points to an instance of the floating-point IIR lattice structure.
+   * @param[in] numStages number of stages in the filter.
+   * @param[in] *pkCoeffs points to the reflection coefficient buffer.  The array is of length numStages.
+   * @param[in] *pvCoeffs points to the ladder coefficient buffer.  The array is of length numStages+1.
+   * @param[in] *pState points to the state buffer.  The array is of length numStages+blockSize-1.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_iir_lattice_init_f32(
+  arm_iir_lattice_instance_f32 * S,
+  uint16_t numStages,
+  float32_t * pkCoeffs,
+  float32_t * pvCoeffs,
+  float32_t * pState,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Processing function for the Q31 IIR lattice filter.
+   * @param[in] *S points to an instance of the Q31 IIR lattice structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_iir_lattice_q31(
+  const arm_iir_lattice_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Initialization function for the Q31 IIR lattice filter.
+   * @param[in] *S points to an instance of the Q31 IIR lattice structure.
+   * @param[in] numStages number of stages in the filter.
+   * @param[in] *pkCoeffs points to the reflection coefficient buffer.  The array is of length numStages.
+   * @param[in] *pvCoeffs points to the ladder coefficient buffer.  The array is of length numStages+1.
+   * @param[in] *pState points to the state buffer.  The array is of length numStages+blockSize.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_iir_lattice_init_q31(
+  arm_iir_lattice_instance_q31 * S,
+  uint16_t numStages,
+  q31_t * pkCoeffs,
+  q31_t * pvCoeffs,
+  q31_t * pState,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Processing function for the Q15 IIR lattice filter.
+   * @param[in] *S points to an instance of the Q15 IIR lattice structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[out] *pDst points to the block of output data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_iir_lattice_q15(
+  const arm_iir_lattice_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+
+/**
+ * @brief Initialization function for the Q15 IIR lattice filter.
+ * @param[in] *S points to an instance of the fixed-point Q15 IIR lattice structure.
+ * @param[in] numStages  number of stages in the filter.
+ * @param[in] *pkCoeffs points to reflection coefficient buffer.  The array is of length numStages.
+ * @param[in] *pvCoeffs points to ladder coefficient buffer.  The array is of length numStages+1.
+ * @param[in] *pState points to state buffer.  The array is of length numStages+blockSize.
+ * @param[in] blockSize number of samples to process per call.
+ * @return none.
+ */
+
+  void arm_iir_lattice_init_q15(
+  arm_iir_lattice_instance_q15 * S,
+  uint16_t numStages,
+  q15_t * pkCoeffs,
+  q15_t * pvCoeffs,
+  q15_t * pState,
+  uint32_t blockSize);
+
+  /**
+   * @brief Instance structure for the floating-point LMS filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;    /**< number of coefficients in the filter. */
+    float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
+    float32_t mu;        /**< step size that controls filter coefficient updates. */
+  } arm_lms_instance_f32;
+
+  /**
+   * @brief Processing function for floating-point LMS filter.
+   * @param[in]  *S points to an instance of the floating-point LMS filter structure.
+   * @param[in]  *pSrc points to the block of input data.
+   * @param[in]  *pRef points to the block of reference data.
+   * @param[out] *pOut points to the block of output data.
+   * @param[out] *pErr points to the block of error data.
+   * @param[in]  blockSize number of samples to process.
+   * @return     none.
+   */
+
+  void arm_lms_f32(
+  const arm_lms_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pRef,
+  float32_t * pOut,
+  float32_t * pErr,
+  uint32_t blockSize);
+
+  /**
+   * @brief Initialization function for floating-point LMS filter.
+   * @param[in] *S points to an instance of the floating-point LMS filter structure.
+   * @param[in] numTaps  number of filter coefficients.
+   * @param[in] *pCoeffs points to the coefficient buffer.
+   * @param[in] *pState points to state buffer.
+   * @param[in] mu step size that controls filter coefficient updates.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_lms_init_f32(
+  arm_lms_instance_f32 * S,
+  uint16_t numTaps,
+  float32_t * pCoeffs,
+  float32_t * pState,
+  float32_t mu,
+  uint32_t blockSize);
+
+  /**
+   * @brief Instance structure for the Q15 LMS filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;    /**< number of coefficients in the filter. */
+    q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
+    q15_t mu;            /**< step size that controls filter coefficient updates. */
+    uint32_t postShift;  /**< bit shift applied to coefficients. */
+  } arm_lms_instance_q15;
+
+
+  /**
+   * @brief Initialization function for the Q15 LMS filter.
+   * @param[in] *S points to an instance of the Q15 LMS filter structure.
+   * @param[in] numTaps  number of filter coefficients.
+   * @param[in] *pCoeffs points to the coefficient buffer.
+   * @param[in] *pState points to the state buffer.
+   * @param[in] mu step size that controls filter coefficient updates.
+   * @param[in] blockSize number of samples to process.
+   * @param[in] postShift bit shift applied to coefficients.
+   * @return    none.
+   */
+
+  void arm_lms_init_q15(
+  arm_lms_instance_q15 * S,
+  uint16_t numTaps,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  q15_t mu,
+  uint32_t blockSize,
+  uint32_t postShift);
+
+  /**
+   * @brief Processing function for Q15 LMS filter.
+   * @param[in] *S points to an instance of the Q15 LMS filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[in] *pRef points to the block of reference data.
+   * @param[out] *pOut points to the block of output data.
+   * @param[out] *pErr points to the block of error data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_lms_q15(
+  const arm_lms_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pRef,
+  q15_t * pOut,
+  q15_t * pErr,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Instance structure for the Q31 LMS filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;    /**< number of coefficients in the filter. */
+    q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
+    q31_t mu;            /**< step size that controls filter coefficient updates. */
+    uint32_t postShift;  /**< bit shift applied to coefficients. */
+
+  } arm_lms_instance_q31;
+
+  /**
+   * @brief Processing function for Q31 LMS filter.
+   * @param[in]  *S points to an instance of the Q15 LMS filter structure.
+   * @param[in]  *pSrc points to the block of input data.
+   * @param[in]  *pRef points to the block of reference data.
+   * @param[out] *pOut points to the block of output data.
+   * @param[out] *pErr points to the block of error data.
+   * @param[in]  blockSize number of samples to process.
+   * @return     none.
+   */
+
+  void arm_lms_q31(
+  const arm_lms_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pRef,
+  q31_t * pOut,
+  q31_t * pErr,
+  uint32_t blockSize);
+
+  /**
+   * @brief Initialization function for Q31 LMS filter.
+   * @param[in] *S points to an instance of the Q31 LMS filter structure.
+   * @param[in] numTaps  number of filter coefficients.
+   * @param[in] *pCoeffs points to coefficient buffer.
+   * @param[in] *pState points to state buffer.
+   * @param[in] mu step size that controls filter coefficient updates.
+   * @param[in] blockSize number of samples to process.
+   * @param[in] postShift bit shift applied to coefficients.
+   * @return none.
+   */
+
+  void arm_lms_init_q31(
+  arm_lms_instance_q31 * S,
+  uint16_t numTaps,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  q31_t mu,
+  uint32_t blockSize,
+  uint32_t postShift);
+
+  /**
+   * @brief Instance structure for the floating-point normalized LMS filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;     /**< number of coefficients in the filter. */
+    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
+    float32_t mu;        /**< step size that control filter coefficient updates. */
+    float32_t energy;    /**< saves previous frame energy. */
+    float32_t x0;        /**< saves previous input sample. */
+  } arm_lms_norm_instance_f32;
+
+  /**
+   * @brief Processing function for floating-point normalized LMS filter.
+   * @param[in] *S points to an instance of the floating-point normalized LMS filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[in] *pRef points to the block of reference data.
+   * @param[out] *pOut points to the block of output data.
+   * @param[out] *pErr points to the block of error data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_lms_norm_f32(
+  arm_lms_norm_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pRef,
+  float32_t * pOut,
+  float32_t * pErr,
+  uint32_t blockSize);
+
+  /**
+   * @brief Initialization function for floating-point normalized LMS filter.
+   * @param[in] *S points to an instance of the floating-point LMS filter structure.
+   * @param[in] numTaps  number of filter coefficients.
+   * @param[in] *pCoeffs points to coefficient buffer.
+   * @param[in] *pState points to state buffer.
+   * @param[in] mu step size that controls filter coefficient updates.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_lms_norm_init_f32(
+  arm_lms_norm_instance_f32 * S,
+  uint16_t numTaps,
+  float32_t * pCoeffs,
+  float32_t * pState,
+  float32_t mu,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Instance structure for the Q31 normalized LMS filter.
+   */
+  typedef struct
+  {
+    uint16_t numTaps;     /**< number of coefficients in the filter. */
+    q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
+    q31_t mu;             /**< step size that controls filter coefficient updates. */
+    uint8_t postShift;    /**< bit shift applied to coefficients. */
+    q31_t *recipTable;    /**< points to the reciprocal initial value table. */
+    q31_t energy;         /**< saves previous frame energy. */
+    q31_t x0;             /**< saves previous input sample. */
+  } arm_lms_norm_instance_q31;
+
+  /**
+   * @brief Processing function for Q31 normalized LMS filter.
+   * @param[in] *S points to an instance of the Q31 normalized LMS filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[in] *pRef points to the block of reference data.
+   * @param[out] *pOut points to the block of output data.
+   * @param[out] *pErr points to the block of error data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_lms_norm_q31(
+  arm_lms_norm_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pRef,
+  q31_t * pOut,
+  q31_t * pErr,
+  uint32_t blockSize);
+
+  /**
+   * @brief Initialization function for Q31 normalized LMS filter.
+   * @param[in] *S points to an instance of the Q31 normalized LMS filter structure.
+   * @param[in] numTaps  number of filter coefficients.
+   * @param[in] *pCoeffs points to coefficient buffer.
+   * @param[in] *pState points to state buffer.
+   * @param[in] mu step size that controls filter coefficient updates.
+   * @param[in] blockSize number of samples to process.
+   * @param[in] postShift bit shift applied to coefficients.
+   * @return none.
+   */
+
+  void arm_lms_norm_init_q31(
+  arm_lms_norm_instance_q31 * S,
+  uint16_t numTaps,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  q31_t mu,
+  uint32_t blockSize,
+  uint8_t postShift);
+
+  /**
+   * @brief Instance structure for the Q15 normalized LMS filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;    /**< Number of coefficients in the filter. */
+    q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
+    q15_t mu;            /**< step size that controls filter coefficient updates. */
+    uint8_t postShift;   /**< bit shift applied to coefficients. */
+    q15_t *recipTable;   /**< Points to the reciprocal initial value table. */
+    q15_t energy;        /**< saves previous frame energy. */
+    q15_t x0;            /**< saves previous input sample. */
+  } arm_lms_norm_instance_q15;
+
+  /**
+   * @brief Processing function for Q15 normalized LMS filter.
+   * @param[in] *S points to an instance of the Q15 normalized LMS filter structure.
+   * @param[in] *pSrc points to the block of input data.
+   * @param[in] *pRef points to the block of reference data.
+   * @param[out] *pOut points to the block of output data.
+   * @param[out] *pErr points to the block of error data.
+   * @param[in] blockSize number of samples to process.
+   * @return none.
+   */
+
+  void arm_lms_norm_q15(
+  arm_lms_norm_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pRef,
+  q15_t * pOut,
+  q15_t * pErr,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief Initialization function for Q15 normalized LMS filter.
+   * @param[in] *S points to an instance of the Q15 normalized LMS filter structure.
+   * @param[in] numTaps  number of filter coefficients.
+   * @param[in] *pCoeffs points to coefficient buffer.
+   * @param[in] *pState points to state buffer.
+   * @param[in] mu step size that controls filter coefficient updates.
+   * @param[in] blockSize number of samples to process.
+   * @param[in] postShift bit shift applied to coefficients.
+   * @return none.
+   */
+
+  void arm_lms_norm_init_q15(
+  arm_lms_norm_instance_q15 * S,
+  uint16_t numTaps,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  q15_t mu,
+  uint32_t blockSize,
+  uint8_t postShift);
+
+  /**
+   * @brief Correlation of floating-point sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @return none.
+   */
+
+  void arm_correlate_f32(
+  float32_t * pSrcA,
+  uint32_t srcALen,
+  float32_t * pSrcB,
+  uint32_t srcBLen,
+  float32_t * pDst);
+
+
+   /**
+   * @brief Correlation of Q15 sequences
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @return none.
+   */
+  void arm_correlate_opt_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  q15_t * pScratch);
+
+
+  /**
+   * @brief Correlation of Q15 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @return none.
+   */
+
+  void arm_correlate_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst);
+
+  /**
+   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @return none.
+   */
+
+  void arm_correlate_fast_q15(
+			       q15_t * pSrcA,
+			      uint32_t srcALen,
+			       q15_t * pSrcB,
+			      uint32_t srcBLen,
+			      q15_t * pDst);
+
+
+
+  /**
+   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @return none.
+   */
+
+  void arm_correlate_fast_opt_q15(
+  q15_t * pSrcA,
+  uint32_t srcALen,
+  q15_t * pSrcB,
+  uint32_t srcBLen,
+  q15_t * pDst,
+  q15_t * pScratch);
+
+  /**
+   * @brief Correlation of Q31 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @return none.
+   */
+
+  void arm_correlate_q31(
+  q31_t * pSrcA,
+  uint32_t srcALen,
+  q31_t * pSrcB,
+  uint32_t srcBLen,
+  q31_t * pDst);
+
+  /**
+   * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @return none.
+   */
+
+  void arm_correlate_fast_q31(
+  q31_t * pSrcA,
+  uint32_t srcALen,
+  q31_t * pSrcB,
+  uint32_t srcBLen,
+  q31_t * pDst);
+
+
+
+ /**
+   * @brief Correlation of Q7 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
+   * @return none.
+   */
+
+  void arm_correlate_opt_q7(
+  q7_t * pSrcA,
+  uint32_t srcALen,
+  q7_t * pSrcB,
+  uint32_t srcBLen,
+  q7_t * pDst,
+  q15_t * pScratch1,
+  q15_t * pScratch2);
+
+
+  /**
+   * @brief Correlation of Q7 sequences.
+   * @param[in] *pSrcA points to the first input sequence.
+   * @param[in] srcALen length of the first input sequence.
+   * @param[in] *pSrcB points to the second input sequence.
+   * @param[in] srcBLen length of the second input sequence.
+   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+   * @return none.
+   */
+
+  void arm_correlate_q7(
+  q7_t * pSrcA,
+  uint32_t srcALen,
+  q7_t * pSrcB,
+  uint32_t srcBLen,
+  q7_t * pDst);
+
+
+  /**
+   * @brief Instance structure for the floating-point sparse FIR filter.
+   */
+  typedef struct
+  {
+    uint16_t numTaps;             /**< number of coefficients in the filter. */
+    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+    float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
+    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+  } arm_fir_sparse_instance_f32;
+
+  /**
+   * @brief Instance structure for the Q31 sparse FIR filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;             /**< number of coefficients in the filter. */
+    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+    q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
+    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+  } arm_fir_sparse_instance_q31;
+
+  /**
+   * @brief Instance structure for the Q15 sparse FIR filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;             /**< number of coefficients in the filter. */
+    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+    q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
+    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+  } arm_fir_sparse_instance_q15;
+
+  /**
+   * @brief Instance structure for the Q7 sparse FIR filter.
+   */
+
+  typedef struct
+  {
+    uint16_t numTaps;             /**< number of coefficients in the filter. */
+    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+    q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
+    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+  } arm_fir_sparse_instance_q7;
+
+  /**
+   * @brief Processing function for the floating-point sparse FIR filter.
+   * @param[in]  *S          points to an instance of the floating-point sparse FIR structure.
+   * @param[in]  *pSrc       points to the block of input data.
+   * @param[out] *pDst       points to the block of output data
+   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
+   * @param[in]  blockSize   number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_sparse_f32(
+  arm_fir_sparse_instance_f32 * S,
+  float32_t * pSrc,
+  float32_t * pDst,
+  float32_t * pScratchIn,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the floating-point sparse FIR filter.
+   * @param[in,out] *S         points to an instance of the floating-point sparse FIR structure.
+   * @param[in]     numTaps    number of nonzero coefficients in the filter.
+   * @param[in]     *pCoeffs   points to the array of filter coefficients.
+   * @param[in]     *pState    points to the state buffer.
+   * @param[in]     *pTapDelay points to the array of offset times.
+   * @param[in]     maxDelay   maximum offset time supported.
+   * @param[in]     blockSize  number of samples that will be processed per block.
+   * @return none
+   */
+
+  void arm_fir_sparse_init_f32(
+  arm_fir_sparse_instance_f32 * S,
+  uint16_t numTaps,
+  float32_t * pCoeffs,
+  float32_t * pState,
+  int32_t * pTapDelay,
+  uint16_t maxDelay,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q31 sparse FIR filter.
+   * @param[in]  *S          points to an instance of the Q31 sparse FIR structure.
+   * @param[in]  *pSrc       points to the block of input data.
+   * @param[out] *pDst       points to the block of output data
+   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
+   * @param[in]  blockSize   number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_sparse_q31(
+  arm_fir_sparse_instance_q31 * S,
+  q31_t * pSrc,
+  q31_t * pDst,
+  q31_t * pScratchIn,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q31 sparse FIR filter.
+   * @param[in,out] *S         points to an instance of the Q31 sparse FIR structure.
+   * @param[in]     numTaps    number of nonzero coefficients in the filter.
+   * @param[in]     *pCoeffs   points to the array of filter coefficients.
+   * @param[in]     *pState    points to the state buffer.
+   * @param[in]     *pTapDelay points to the array of offset times.
+   * @param[in]     maxDelay   maximum offset time supported.
+   * @param[in]     blockSize  number of samples that will be processed per block.
+   * @return none
+   */
+
+  void arm_fir_sparse_init_q31(
+  arm_fir_sparse_instance_q31 * S,
+  uint16_t numTaps,
+  q31_t * pCoeffs,
+  q31_t * pState,
+  int32_t * pTapDelay,
+  uint16_t maxDelay,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q15 sparse FIR filter.
+   * @param[in]  *S           points to an instance of the Q15 sparse FIR structure.
+   * @param[in]  *pSrc        points to the block of input data.
+   * @param[out] *pDst        points to the block of output data
+   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
+   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
+   * @param[in]  blockSize    number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_sparse_q15(
+  arm_fir_sparse_instance_q15 * S,
+  q15_t * pSrc,
+  q15_t * pDst,
+  q15_t * pScratchIn,
+  q31_t * pScratchOut,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Initialization function for the Q15 sparse FIR filter.
+   * @param[in,out] *S         points to an instance of the Q15 sparse FIR structure.
+   * @param[in]     numTaps    number of nonzero coefficients in the filter.
+   * @param[in]     *pCoeffs   points to the array of filter coefficients.
+   * @param[in]     *pState    points to the state buffer.
+   * @param[in]     *pTapDelay points to the array of offset times.
+   * @param[in]     maxDelay   maximum offset time supported.
+   * @param[in]     blockSize  number of samples that will be processed per block.
+   * @return none
+   */
+
+  void arm_fir_sparse_init_q15(
+  arm_fir_sparse_instance_q15 * S,
+  uint16_t numTaps,
+  q15_t * pCoeffs,
+  q15_t * pState,
+  int32_t * pTapDelay,
+  uint16_t maxDelay,
+  uint32_t blockSize);
+
+  /**
+   * @brief Processing function for the Q7 sparse FIR filter.
+   * @param[in]  *S           points to an instance of the Q7 sparse FIR structure.
+   * @param[in]  *pSrc        points to the block of input data.
+   * @param[out] *pDst        points to the block of output data
+   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
+   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
+   * @param[in]  blockSize    number of input samples to process per call.
+   * @return none.
+   */
+
+  void arm_fir_sparse_q7(
+  arm_fir_sparse_instance_q7 * S,
+  q7_t * pSrc,
+  q7_t * pDst,
+  q7_t * pScratchIn,
+  q31_t * pScratchOut,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Initialization function for the Q7 sparse FIR filter.
+   * @param[in,out] *S         points to an instance of the Q7 sparse FIR structure.
+   * @param[in]     numTaps    number of nonzero coefficients in the filter.
+   * @param[in]     *pCoeffs   points to the array of filter coefficients.
+   * @param[in]     *pState    points to the state buffer.
+   * @param[in]     *pTapDelay points to the array of offset times.
+   * @param[in]     maxDelay   maximum offset time supported.
+   * @param[in]     blockSize  number of samples that will be processed per block.
+   * @return none
+   */
+
+  void arm_fir_sparse_init_q7(
+  arm_fir_sparse_instance_q7 * S,
+  uint16_t numTaps,
+  q7_t * pCoeffs,
+  q7_t * pState,
+  int32_t * pTapDelay,
+  uint16_t maxDelay,
+  uint32_t blockSize);
+
+
+  /*
+   * @brief  Floating-point sin_cos function.
+   * @param[in]  theta    input value in degrees
+   * @param[out] *pSinVal points to the processed sine output.
+   * @param[out] *pCosVal points to the processed cos output.
+   * @return none.
+   */
+
+  void arm_sin_cos_f32(
+  float32_t theta,
+  float32_t * pSinVal,
+  float32_t * pCcosVal);
+
+  /*
+   * @brief  Q31 sin_cos function.
+   * @param[in]  theta    scaled input value in degrees
+   * @param[out] *pSinVal points to the processed sine output.
+   * @param[out] *pCosVal points to the processed cosine output.
+   * @return none.
+   */
+
+  void arm_sin_cos_q31(
+  q31_t theta,
+  q31_t * pSinVal,
+  q31_t * pCosVal);
+
+
+  /**
+   * @brief  Floating-point complex conjugate.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_conj_f32(
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q31 complex conjugate.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_conj_q31(
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q15 complex conjugate.
+   * @param[in]  *pSrc points to the input vector
+   * @param[out]  *pDst points to the output vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_conj_q15(
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t numSamples);
+
+
+
+  /**
+   * @brief  Floating-point complex magnitude squared
+   * @param[in]  *pSrc points to the complex input vector
+   * @param[out]  *pDst points to the real output vector
+   * @param[in]  numSamples number of complex samples in the input vector
+   * @return none.
+   */
+
+  void arm_cmplx_mag_squared_f32(
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q31 complex magnitude squared
+   * @param[in]  *pSrc points to the complex input vector
+   * @param[out]  *pDst points to the real output vector
+   * @param[in]  numSamples number of complex samples in the input vector
+   * @return none.
+   */
+
+  void arm_cmplx_mag_squared_q31(
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q15 complex magnitude squared
+   * @param[in]  *pSrc points to the complex input vector
+   * @param[out]  *pDst points to the real output vector
+   * @param[in]  numSamples number of complex samples in the input vector
+   * @return none.
+   */
+
+  void arm_cmplx_mag_squared_q15(
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t numSamples);
+
+
+ /**
+   * @ingroup groupController
+   */
+
+  /**
+   * @defgroup PID PID Motor Control
+   *
+   * A Proportional Integral Derivative (PID) controller is a generic feedback control
+   * loop mechanism widely used in industrial control systems.
+   * A PID controller is the most commonly used type of feedback controller.
+   *
+   * This set of functions implements (PID) controllers
+   * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
+   * of data and each call to the function returns a single processed value.
+   * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
+   * is the input sample value. The functions return the output value.
+   *
+   * \par Algorithm:
+   * <pre>
+   *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
+   *    A0 = Kp + Ki + Kd
+   *    A1 = (-Kp ) - (2 * Kd )
+   *    A2 = Kd  </pre>
+   *
+   * \par
+   * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative constant
+   *
+   * \par
+   * \image html PID.gif "Proportional Integral Derivative Controller"
+   *
+   * \par
+   * The PID controller calculates an "error" value as the difference between
+   * the measured output and the reference input.
+   * The controller attempts to minimize the error by adjusting the process control inputs.
+   * The proportional value determines the reaction to the current error,
+   * the integral value determines the reaction based on the sum of recent errors,
+   * and the derivative value determines the reaction based on the rate at which the error has been changing.
+   *
+   * \par Instance Structure
+   * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instance data structure.
+   * A separate instance structure must be defined for each PID Controller.
+   * There are separate instance structure declarations for each of the 3 supported data types.
+   *
+   * \par Reset Functions
+   * There is also an associated reset function for each data type which clears the state array.
+   *
+   * \par Initialization Functions
+   * There is also an associated initialization function for each data type.
+   * The initialization function performs the following operations:
+   * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
+   * - Zeros out the values in the state buffer.
+   *
+   * \par
+   * Instance structure cannot be placed into a const data section and it is recommended to use the initialization function.
+   *
+   * \par Fixed-Point Behavior
+   * Care must be taken when using the fixed-point versions of the PID Controller functions.
+   * In particular, the overflow and saturation behavior of the accumulator used in each function must be considered.
+   * Refer to the function specific documentation below for usage guidelines.
+   */
+
+  /**
+   * @addtogroup PID
+   * @{
+   */
+
+  /**
+   * @brief  Process function for the floating-point PID Control.
+   * @param[in,out] *S is an instance of the floating-point PID Control structure
+   * @param[in] in input sample to process
+   * @return out processed output sample.
+   */
+
+
+  static __INLINE float32_t arm_pid_f32(
+  arm_pid_instance_f32 * S,
+  float32_t in)
+  {
+    float32_t out;
+
+    /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
+    out = (S->A0 * in) +
+      (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
+
+    /* Update state */
+    S->state[1] = S->state[0];
+    S->state[0] = in;
+    S->state[2] = out;
+
+    /* return to application */
+    return (out);
+
+  }
+
+  /**
+   * @brief  Process function for the Q31 PID Control.
+   * @param[in,out] *S points to an instance of the Q31 PID Control structure
+   * @param[in] in input sample to process
+   * @return out processed output sample.
+   *
+   * <b>Scaling and Overflow Behavior:</b>
+   * \par
+   * The function is implemented using an internal 64-bit accumulator.
+   * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit.
+   * Thus, if the accumulator result overflows it wraps around rather than clip.
+   * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there are four additions.
+   * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format and then saturated to 1.31 format.
+   */
+
+  static __INLINE q31_t arm_pid_q31(
+  arm_pid_instance_q31 * S,
+  q31_t in)
+  {
+    q63_t acc;
+    q31_t out;
+
+    /* acc = A0 * x[n]  */
+    acc = (q63_t) S->A0 * in;
+
+    /* acc += A1 * x[n-1] */
+    acc += (q63_t) S->A1 * S->state[0];
+
+    /* acc += A2 * x[n-2]  */
+    acc += (q63_t) S->A2 * S->state[1];
+
+    /* convert output to 1.31 format to add y[n-1] */
+    out = (q31_t) (acc >> 31u);
+
+    /* out += y[n-1] */
+    out += S->state[2];
+
+    /* Update state */
+    S->state[1] = S->state[0];
+    S->state[0] = in;
+    S->state[2] = out;
+
+    /* return to application */
+    return (out);
+
+  }
+
+  /**
+   * @brief  Process function for the Q15 PID Control.
+   * @param[in,out] *S points to an instance of the Q15 PID Control structure
+   * @param[in] in input sample to process
+   * @return out processed output sample.
+   *
+   * <b>Scaling and Overflow Behavior:</b>
+   * \par
+   * The function is implemented using a 64-bit internal accumulator.
+   * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30 result.
+   * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
+   * There is no risk of internal overflow with this approach and the full precision of intermediate multiplications is preserved.
+   * After all additions have been performed, the accumulator is truncated to 34.15 format by discarding low 15 bits.
+   * Lastly, the accumulator is saturated to yield a result in 1.15 format.
+   */
+
+  static __INLINE q15_t arm_pid_q15(
+  arm_pid_instance_q15 * S,
+  q15_t in)
+  {
+    q63_t acc;
+    q15_t out;
+
+#ifndef ARM_MATH_CM0_FAMILY
+    __SIMD32_TYPE *vstate;
+
+    /* Implementation of PID controller */
+
+    /* acc = A0 * x[n]  */
+    acc = (q31_t) __SMUAD(S->A0, in);
+
+    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
+    vstate = __SIMD32_CONST(S->state);
+    acc = __SMLALD(S->A1, (q31_t) *vstate, acc);
+
+#else
+    /* acc = A0 * x[n]  */
+    acc = ((q31_t) S->A0) * in;
+
+    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
+    acc += (q31_t) S->A1 * S->state[0];
+    acc += (q31_t) S->A2 * S->state[1];
+
+#endif
+
+    /* acc += y[n-1] */
+    acc += (q31_t) S->state[2] << 15;
+
+    /* saturate the output */
+    out = (q15_t) (__SSAT((acc >> 15), 16));
+
+    /* Update state */
+    S->state[1] = S->state[0];
+    S->state[0] = in;
+    S->state[2] = out;
+
+    /* return to application */
+    return (out);
+
+  }
+
+  /**
+   * @} end of PID group
+   */
+
+
+  /**
+   * @brief Floating-point matrix inverse.
+   * @param[in]  *src points to the instance of the input floating-point matrix structure.
+   * @param[out] *dst points to the instance of the output floating-point matrix structure.
+   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
+   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
+   */
+
+  arm_status arm_mat_inverse_f32(
+  const arm_matrix_instance_f32 * src,
+  arm_matrix_instance_f32 * dst);
+
+
+
+  /**
+   * @ingroup groupController
+   */
+
+
+  /**
+   * @defgroup clarke Vector Clarke Transform
+   * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time invariant vector.
+   * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calculate currents
+   * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
+   * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
+   * \image html clarke.gif Stator current space vector and its components in (a,b).
+   * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code>
+   * can be calculated using only <code>Ia</code> and <code>Ib</code>.
+   *
+   * The function operates on a single sample of data and each call to the function returns the processed output.
+   * The library provides separate functions for Q31 and floating-point data types.
+   * \par Algorithm
+   * \image html clarkeFormula.gif
+   * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
+   * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
+   * \par Fixed-Point Behavior
+   * Care must be taken when using the Q31 version of the Clarke transform.
+   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
+   * Refer to the function specific documentation below for usage guidelines.
+   */
+
+  /**
+   * @addtogroup clarke
+   * @{
+   */
+
+  /**
+   *
+   * @brief  Floating-point Clarke transform
+   * @param[in]       Ia       input three-phase coordinate <code>a</code>
+   * @param[in]       Ib       input three-phase coordinate <code>b</code>
+   * @param[out]      *pIalpha points to output two-phase orthogonal vector axis alpha
+   * @param[out]      *pIbeta  points to output two-phase orthogonal vector axis beta
+   * @return none.
+   */
+
+  static __INLINE void arm_clarke_f32(
+  float32_t Ia,
+  float32_t Ib,
+  float32_t * pIalpha,
+  float32_t * pIbeta)
+  {
+    /* Calculate pIalpha using the equation, pIalpha = Ia */
+    *pIalpha = Ia;
+
+    /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
+    *pIbeta =
+      ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
+
+  }
+
+  /**
+   * @brief  Clarke transform for Q31 version
+   * @param[in]       Ia       input three-phase coordinate <code>a</code>
+   * @param[in]       Ib       input three-phase coordinate <code>b</code>
+   * @param[out]      *pIalpha points to output two-phase orthogonal vector axis alpha
+   * @param[out]      *pIbeta  points to output two-phase orthogonal vector axis beta
+   * @return none.
+   *
+   * <b>Scaling and Overflow Behavior:</b>
+   * \par
+   * The function is implemented using an internal 32-bit accumulator.
+   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
+   * There is saturation on the addition, hence there is no risk of overflow.
+   */
+
+  static __INLINE void arm_clarke_q31(
+  q31_t Ia,
+  q31_t Ib,
+  q31_t * pIalpha,
+  q31_t * pIbeta)
+  {
+    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
+
+    /* Calculating pIalpha from Ia by equation pIalpha = Ia */
+    *pIalpha = Ia;
+
+    /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
+    product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
+
+    /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
+    product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
+
+    /* pIbeta is calculated by adding the intermediate products */
+    *pIbeta = __QADD(product1, product2);
+  }
+
+  /**
+   * @} end of clarke group
+   */
+
+  /**
+   * @brief  Converts the elements of the Q7 vector to Q31 vector.
+   * @param[in]  *pSrc     input pointer
+   * @param[out]  *pDst    output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_q7_to_q31(
+  q7_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+
+
+
+  /**
+   * @ingroup groupController
+   */
+
+  /**
+   * @defgroup inv_clarke Vector Inverse Clarke Transform
+   * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous stator phases.
+   *
+   * The function operates on a single sample of data and each call to the function returns the processed output.
+   * The library provides separate functions for Q31 and floating-point data types.
+   * \par Algorithm
+   * \image html clarkeInvFormula.gif
+   * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
+   * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
+   * \par Fixed-Point Behavior
+   * Care must be taken when using the Q31 version of the Clarke transform.
+   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
+   * Refer to the function specific documentation below for usage guidelines.
+   */
+
+  /**
+   * @addtogroup inv_clarke
+   * @{
+   */
+
+   /**
+   * @brief  Floating-point Inverse Clarke transform
+   * @param[in]       Ialpha  input two-phase orthogonal vector axis alpha
+   * @param[in]       Ibeta   input two-phase orthogonal vector axis beta
+   * @param[out]      *pIa    points to output three-phase coordinate <code>a</code>
+   * @param[out]      *pIb    points to output three-phase coordinate <code>b</code>
+   * @return none.
+   */
+
+
+  static __INLINE void arm_inv_clarke_f32(
+  float32_t Ialpha,
+  float32_t Ibeta,
+  float32_t * pIa,
+  float32_t * pIb)
+  {
+    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
+    *pIa = Ialpha;
+
+    /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibeta */
+    *pIb = -0.5 * Ialpha + (float32_t) 0.8660254039 *Ibeta;
+
+  }
+
+  /**
+   * @brief  Inverse Clarke transform for Q31 version
+   * @param[in]       Ialpha  input two-phase orthogonal vector axis alpha
+   * @param[in]       Ibeta   input two-phase orthogonal vector axis beta
+   * @param[out]      *pIa    points to output three-phase coordinate <code>a</code>
+   * @param[out]      *pIb    points to output three-phase coordinate <code>b</code>
+   * @return none.
+   *
+   * <b>Scaling and Overflow Behavior:</b>
+   * \par
+   * The function is implemented using an internal 32-bit accumulator.
+   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
+   * There is saturation on the subtraction, hence there is no risk of overflow.
+   */
+
+  static __INLINE void arm_inv_clarke_q31(
+  q31_t Ialpha,
+  q31_t Ibeta,
+  q31_t * pIa,
+  q31_t * pIb)
+  {
+    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
+
+    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
+    *pIa = Ialpha;
+
+    /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
+    product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
+
+    /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
+    product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
+
+    /* pIb is calculated by subtracting the products */
+    *pIb = __QSUB(product2, product1);
+
+  }
+
+  /**
+   * @} end of inv_clarke group
+   */
+
+  /**
+   * @brief  Converts the elements of the Q7 vector to Q15 vector.
+   * @param[in]  *pSrc     input pointer
+   * @param[out] *pDst     output pointer
+   * @param[in]  blockSize number of samples to process
+   * @return none.
+   */
+  void arm_q7_to_q15(
+  q7_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+
+
+  /**
+   * @ingroup groupController
+   */
+
+  /**
+   * @defgroup park Vector Park Transform
+   *
+   * Forward Park transform converts the input two-coordinate vector to flux and torque components.
+   * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and the <code>Ibeta</code> currents
+   * from the stationary to the moving reference frame and control the spatial relationship between
+   * the stator vector current and rotor flux vector.
+   * If we consider the d axis aligned with the rotor flux, the diagram below shows the
+   * current vector and the relationship from the two reference frames:
+   * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q rotating reference frame"
+   *
+   * The function operates on a single sample of data and each call to the function returns the processed output.
+   * The library provides separate functions for Q31 and floating-point data types.
+   * \par Algorithm
+   * \image html parkFormula.gif
+   * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
+   * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
+   * cosine and sine values of theta (rotor flux position).
+   * \par Fixed-Point Behavior
+   * Care must be taken when using the Q31 version of the Park transform.
+   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
+   * Refer to the function specific documentation below for usage guidelines.
+   */
+
+  /**
+   * @addtogroup park
+   * @{
+   */
+
+  /**
+   * @brief Floating-point Park transform
+   * @param[in]       Ialpha input two-phase vector coordinate alpha
+   * @param[in]       Ibeta  input two-phase vector coordinate beta
+   * @param[out]      *pId   points to output	rotor reference frame d
+   * @param[out]      *pIq   points to output	rotor reference frame q
+   * @param[in]       sinVal sine value of rotation angle theta
+   * @param[in]       cosVal cosine value of rotation angle theta
+   * @return none.
+   *
+   * The function implements the forward Park transform.
+   *
+   */
+
+  static __INLINE void arm_park_f32(
+  float32_t Ialpha,
+  float32_t Ibeta,
+  float32_t * pId,
+  float32_t * pIq,
+  float32_t sinVal,
+  float32_t cosVal)
+  {
+    /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
+    *pId = Ialpha * cosVal + Ibeta * sinVal;
+
+    /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
+    *pIq = -Ialpha * sinVal + Ibeta * cosVal;
+
+  }
+
+  /**
+   * @brief  Park transform for Q31 version
+   * @param[in]       Ialpha input two-phase vector coordinate alpha
+   * @param[in]       Ibeta  input two-phase vector coordinate beta
+   * @param[out]      *pId   points to output rotor reference frame d
+   * @param[out]      *pIq   points to output rotor reference frame q
+   * @param[in]       sinVal sine value of rotation angle theta
+   * @param[in]       cosVal cosine value of rotation angle theta
+   * @return none.
+   *
+   * <b>Scaling and Overflow Behavior:</b>
+   * \par
+   * The function is implemented using an internal 32-bit accumulator.
+   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
+   * There is saturation on the addition and subtraction, hence there is no risk of overflow.
+   */
+
+
+  static __INLINE void arm_park_q31(
+  q31_t Ialpha,
+  q31_t Ibeta,
+  q31_t * pId,
+  q31_t * pIq,
+  q31_t sinVal,
+  q31_t cosVal)
+  {
+    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
+    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
+
+    /* Intermediate product is calculated by (Ialpha * cosVal) */
+    product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
+
+    /* Intermediate product is calculated by (Ibeta * sinVal) */
+    product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
+
+
+    /* Intermediate product is calculated by (Ialpha * sinVal) */
+    product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
+
+    /* Intermediate product is calculated by (Ibeta * cosVal) */
+    product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
+
+    /* Calculate pId by adding the two intermediate products 1 and 2 */
+    *pId = __QADD(product1, product2);
+
+    /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
+    *pIq = __QSUB(product4, product3);
+  }
+
+  /**
+   * @} end of park group
+   */
+
+  /**
+   * @brief  Converts the elements of the Q7 vector to floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q7_to_float(
+  q7_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @ingroup groupController
+   */
+
+  /**
+   * @defgroup inv_park Vector Inverse Park transform
+   * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
+   *
+   * The function operates on a single sample of data and each call to the function returns the processed output.
+   * The library provides separate functions for Q31 and floating-point data types.
+   * \par Algorithm
+   * \image html parkInvFormula.gif
+   * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
+   * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
+   * cosine and sine values of theta (rotor flux position).
+   * \par Fixed-Point Behavior
+   * Care must be taken when using the Q31 version of the Park transform.
+   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
+   * Refer to the function specific documentation below for usage guidelines.
+   */
+
+  /**
+   * @addtogroup inv_park
+   * @{
+   */
+
+   /**
+   * @brief  Floating-point Inverse Park transform
+   * @param[in]       Id        input coordinate of rotor reference frame d
+   * @param[in]       Iq        input coordinate of rotor reference frame q
+   * @param[out]      *pIalpha  points to output two-phase orthogonal vector axis alpha
+   * @param[out]      *pIbeta   points to output two-phase orthogonal vector axis beta
+   * @param[in]       sinVal    sine value of rotation angle theta
+   * @param[in]       cosVal    cosine value of rotation angle theta
+   * @return none.
+   */
+
+  static __INLINE void arm_inv_park_f32(
+  float32_t Id,
+  float32_t Iq,
+  float32_t * pIalpha,
+  float32_t * pIbeta,
+  float32_t sinVal,
+  float32_t cosVal)
+  {
+    /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
+    *pIalpha = Id * cosVal - Iq * sinVal;
+
+    /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
+    *pIbeta = Id * sinVal + Iq * cosVal;
+
+  }
+
+
+  /**
+   * @brief  Inverse Park transform for	Q31 version
+   * @param[in]       Id        input coordinate of rotor reference frame d
+   * @param[in]       Iq        input coordinate of rotor reference frame q
+   * @param[out]      *pIalpha  points to output two-phase orthogonal vector axis alpha
+   * @param[out]      *pIbeta   points to output two-phase orthogonal vector axis beta
+   * @param[in]       sinVal    sine value of rotation angle theta
+   * @param[in]       cosVal    cosine value of rotation angle theta
+   * @return none.
+   *
+   * <b>Scaling and Overflow Behavior:</b>
+   * \par
+   * The function is implemented using an internal 32-bit accumulator.
+   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
+   * There is saturation on the addition, hence there is no risk of overflow.
+   */
+
+
+  static __INLINE void arm_inv_park_q31(
+  q31_t Id,
+  q31_t Iq,
+  q31_t * pIalpha,
+  q31_t * pIbeta,
+  q31_t sinVal,
+  q31_t cosVal)
+  {
+    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
+    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
+
+    /* Intermediate product is calculated by (Id * cosVal) */
+    product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
+
+    /* Intermediate product is calculated by (Iq * sinVal) */
+    product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
+
+
+    /* Intermediate product is calculated by (Id * sinVal) */
+    product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
+
+    /* Intermediate product is calculated by (Iq * cosVal) */
+    product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
+
+    /* Calculate pIalpha by using the two intermediate products 1 and 2 */
+    *pIalpha = __QSUB(product1, product2);
+
+    /* Calculate pIbeta by using the two intermediate products 3 and 4 */
+    *pIbeta = __QADD(product4, product3);
+
+  }
+
+  /**
+   * @} end of Inverse park group
+   */
+
+
+  /**
+   * @brief  Converts the elements of the Q31 vector to floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q31_to_float(
+  q31_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @ingroup groupInterpolation
+   */
+
+  /**
+   * @defgroup LinearInterpolate Linear Interpolation
+   *
+   * Linear interpolation is a method of curve fitting using linear polynomials.
+   * Linear interpolation works by effectively drawing a straight line between two neighboring samples and returning the appropriate point along that line
+   *
+   * \par
+   * \image html LinearInterp.gif "Linear interpolation"
+   *
+   * \par
+   * A  Linear Interpolate function calculates an output value(y), for the input(x)
+   * using linear interpolation of the input values x0, x1( nearest input values) and the output values y0 and y1(nearest output values)
+   *
+   * \par Algorithm:
+   * <pre>
+   *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
+   *       where x0, x1 are nearest values of input x
+   *             y0, y1 are nearest values to output y
+   * </pre>
+   *
+   * \par
+   * This set of functions implements Linear interpolation process
+   * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
+   * sample of data and each call to the function returns a single processed value.
+   * <code>S</code> points to an instance of the Linear Interpolate function data structure.
+   * <code>x</code> is the input sample value. The functions returns the output value.
+   *
+   * \par
+   * if x is outside of the table boundary, Linear interpolation returns first value of the table
+   * if x is below input range and returns last value of table if x is above range.
+   */
+
+  /**
+   * @addtogroup LinearInterpolate
+   * @{
+   */
+
+  /**
+   * @brief  Process function for the floating-point Linear Interpolation Function.
+   * @param[in,out] *S is an instance of the floating-point Linear Interpolation structure
+   * @param[in] x input sample to process
+   * @return y processed output sample.
+   *
+   */
+
+  static __INLINE float32_t arm_linear_interp_f32(
+  arm_linear_interp_instance_f32 * S,
+  float32_t x)
+  {
+
+    float32_t y;
+    float32_t x0, x1;                            /* Nearest input values */
+    float32_t y0, y1;                            /* Nearest output values */
+    float32_t xSpacing = S->xSpacing;            /* spacing between input values */
+    int32_t i;                                   /* Index variable */
+    float32_t *pYData = S->pYData;               /* pointer to output table */
+
+    /* Calculation of index */
+    i = (int32_t) ((x - S->x1) / xSpacing);
+
+    if(i < 0)
+    {
+      /* Iniatilize output for below specified range as least output value of table */
+      y = pYData[0];
+    }
+    else if((uint32_t)i >= S->nValues)
+    {
+      /* Iniatilize output for above specified range as last output value of table */
+      y = pYData[S->nValues - 1];
+    }
+    else
+    {
+      /* Calculation of nearest input values */
+      x0 = S->x1 + i * xSpacing;
+      x1 = S->x1 + (i + 1) * xSpacing;
+
+      /* Read of nearest output values */
+      y0 = pYData[i];
+      y1 = pYData[i + 1];
+
+      /* Calculation of output */
+      y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
+
+    }
+
+    /* returns output value */
+    return (y);
+  }
+
+   /**
+   *
+   * @brief  Process function for the Q31 Linear Interpolation Function.
+   * @param[in] *pYData  pointer to Q31 Linear Interpolation table
+   * @param[in] x input sample to process
+   * @param[in] nValues number of table values
+   * @return y processed output sample.
+   *
+   * \par
+   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
+   * This function can support maximum of table size 2^12.
+   *
+   */
+
+
+  static __INLINE q31_t arm_linear_interp_q31(
+  q31_t * pYData,
+  q31_t x,
+  uint32_t nValues)
+  {
+    q31_t y;                                     /* output */
+    q31_t y0, y1;                                /* Nearest output values */
+    q31_t fract;                                 /* fractional part */
+    int32_t index;                               /* Index to read nearest output values */
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    index = ((x & 0xFFF00000) >> 20);
+
+    if(index >= (int32_t)(nValues - 1))
+    {
+      return (pYData[nValues - 1]);
+    }
+    else if(index < 0)
+    {
+      return (pYData[0]);
+    }
+    else
+    {
+
+      /* 20 bits for the fractional part */
+      /* shift left by 11 to keep fract in 1.31 format */
+      fract = (x & 0x000FFFFF) << 11;
+
+      /* Read two nearest output values from the index in 1.31(q31) format */
+      y0 = pYData[index];
+      y1 = pYData[index + 1u];
+
+      /* Calculation of y0 * (1-fract) and y is in 2.30 format */
+      y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
+
+      /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
+      y += ((q31_t) (((q63_t) y1 * fract) >> 32));
+
+      /* Convert y to 1.31 format */
+      return (y << 1u);
+
+    }
+
+  }
+
+  /**
+   *
+   * @brief  Process function for the Q15 Linear Interpolation Function.
+   * @param[in] *pYData  pointer to Q15 Linear Interpolation table
+   * @param[in] x input sample to process
+   * @param[in] nValues number of table values
+   * @return y processed output sample.
+   *
+   * \par
+   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
+   * This function can support maximum of table size 2^12.
+   *
+   */
+
+
+  static __INLINE q15_t arm_linear_interp_q15(
+  q15_t * pYData,
+  q31_t x,
+  uint32_t nValues)
+  {
+    q63_t y;                                     /* output */
+    q15_t y0, y1;                                /* Nearest output values */
+    q31_t fract;                                 /* fractional part */
+    int32_t index;                               /* Index to read nearest output values */
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    index = ((x & 0xFFF00000) >> 20u);
+
+    if(index >= (int32_t)(nValues - 1))
+    {
+      return (pYData[nValues - 1]);
+    }
+    else if(index < 0)
+    {
+      return (pYData[0]);
+    }
+    else
+    {
+      /* 20 bits for the fractional part */
+      /* fract is in 12.20 format */
+      fract = (x & 0x000FFFFF);
+
+      /* Read two nearest output values from the index */
+      y0 = pYData[index];
+      y1 = pYData[index + 1u];
+
+      /* Calculation of y0 * (1-fract) and y is in 13.35 format */
+      y = ((q63_t) y0 * (0xFFFFF - fract));
+
+      /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
+      y += ((q63_t) y1 * (fract));
+
+      /* convert y to 1.15 format */
+      return (y >> 20);
+    }
+
+
+  }
+
+  /**
+   *
+   * @brief  Process function for the Q7 Linear Interpolation Function.
+   * @param[in] *pYData  pointer to Q7 Linear Interpolation table
+   * @param[in] x input sample to process
+   * @param[in] nValues number of table values
+   * @return y processed output sample.
+   *
+   * \par
+   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
+   * This function can support maximum of table size 2^12.
+   */
+
+
+  static __INLINE q7_t arm_linear_interp_q7(
+  q7_t * pYData,
+  q31_t x,
+  uint32_t nValues)
+  {
+    q31_t y;                                     /* output */
+    q7_t y0, y1;                                 /* Nearest output values */
+    q31_t fract;                                 /* fractional part */
+    uint32_t index;                              /* Index to read nearest output values */
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    if (x < 0)
+    {
+      return (pYData[0]);
+    }
+    index = (x >> 20) & 0xfff;
+
+
+    if(index >= (nValues - 1))
+    {
+      return (pYData[nValues - 1]);
+    }
+    else
+    {
+
+      /* 20 bits for the fractional part */
+      /* fract is in 12.20 format */
+      fract = (x & 0x000FFFFF);
+
+      /* Read two nearest output values from the index and are in 1.7(q7) format */
+      y0 = pYData[index];
+      y1 = pYData[index + 1u];
+
+      /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
+      y = ((y0 * (0xFFFFF - fract)));
+
+      /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
+      y += (y1 * fract);
+
+      /* convert y to 1.7(q7) format */
+      return (y >> 20u);
+
+    }
+
+  }
+  /**
+   * @} end of LinearInterpolate group
+   */
+
+  /**
+   * @brief  Fast approximation to the trigonometric sine function for floating-point data.
+   * @param[in] x input value in radians.
+   * @return  sin(x).
+   */
+
+  float32_t arm_sin_f32(
+  float32_t x);
+
+  /**
+   * @brief  Fast approximation to the trigonometric sine function for Q31 data.
+   * @param[in] x Scaled input value in radians.
+   * @return  sin(x).
+   */
+
+  q31_t arm_sin_q31(
+  q31_t x);
+
+  /**
+   * @brief  Fast approximation to the trigonometric sine function for Q15 data.
+   * @param[in] x Scaled input value in radians.
+   * @return  sin(x).
+   */
+
+  q15_t arm_sin_q15(
+  q15_t x);
+
+  /**
+   * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
+   * @param[in] x input value in radians.
+   * @return  cos(x).
+   */
+
+  float32_t arm_cos_f32(
+  float32_t x);
+
+  /**
+   * @brief Fast approximation to the trigonometric cosine function for Q31 data.
+   * @param[in] x Scaled input value in radians.
+   * @return  cos(x).
+   */
+
+  q31_t arm_cos_q31(
+  q31_t x);
+
+  /**
+   * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
+   * @param[in] x Scaled input value in radians.
+   * @return  cos(x).
+   */
+
+  q15_t arm_cos_q15(
+  q15_t x);
+
+
+  /**
+   * @ingroup groupFastMath
+   */
+
+
+  /**
+   * @defgroup SQRT Square Root
+   *
+   * Computes the square root of a number.
+   * There are separate functions for Q15, Q31, and floating-point data types.
+   * The square root function is computed using the Newton-Raphson algorithm.
+   * This is an iterative algorithm of the form:
+   * <pre>
+   *      x1 = x0 - f(x0)/f'(x0)
+   * </pre>
+   * where <code>x1</code> is the current estimate,
+   * <code>x0</code> is the previous estimate, and
+   * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
+   * For the square root function, the algorithm reduces to:
+   * <pre>
+   *     x0 = in/2                         [initial guess]
+   *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
+   * </pre>
+   */
+
+
+  /**
+   * @addtogroup SQRT
+   * @{
+   */
+
+  /**
+   * @brief  Floating-point square root function.
+   * @param[in]  in     input value.
+   * @param[out] *pOut  square root of input value.
+   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
+   * <code>in</code> is negative value and returns zero output for negative values.
+   */
+
+  static __INLINE arm_status arm_sqrt_f32(
+  float32_t in,
+  float32_t * pOut)
+  {
+    if(in > 0)
+    {
+
+//      #if __FPU_USED
+#if (__FPU_USED == 1) && defined ( __CC_ARM   )
+      *pOut = __sqrtf(in);
+#else
+      *pOut = sqrtf(in);
+#endif
+
+      return (ARM_MATH_SUCCESS);
+    }
+    else
+    {
+      *pOut = 0.0f;
+      return (ARM_MATH_ARGUMENT_ERROR);
+    }
+
+  }
+
+
+  /**
+   * @brief Q31 square root function.
+   * @param[in]   in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF.
+   * @param[out]  *pOut square root of input value.
+   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
+   * <code>in</code> is negative value and returns zero output for negative values.
+   */
+  arm_status arm_sqrt_q31(
+  q31_t in,
+  q31_t * pOut);
+
+  /**
+   * @brief  Q15 square root function.
+   * @param[in]   in     input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
+   * @param[out]  *pOut  square root of input value.
+   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
+   * <code>in</code> is negative value and returns zero output for negative values.
+   */
+  arm_status arm_sqrt_q15(
+  q15_t in,
+  q15_t * pOut);
+
+  /**
+   * @} end of SQRT group
+   */
+
+
+
+
+
+
+  /**
+   * @brief floating-point Circular write function.
+   */
+
+  static __INLINE void arm_circularWrite_f32(
+  int32_t * circBuffer,
+  int32_t L,
+  uint16_t * writeOffset,
+  int32_t bufferInc,
+  const int32_t * src,
+  int32_t srcInc,
+  uint32_t blockSize)
+  {
+    uint32_t i = 0u;
+    int32_t wOffset;
+
+    /* Copy the value of Index pointer that points
+     * to the current location where the input samples to be copied */
+    wOffset = *writeOffset;
+
+    /* Loop over the blockSize */
+    i = blockSize;
+
+    while(i > 0u)
+    {
+      /* copy the input sample to the circular buffer */
+      circBuffer[wOffset] = *src;
+
+      /* Update the input pointer */
+      src += srcInc;
+
+      /* Circularly update wOffset.  Watch out for positive and negative value */
+      wOffset += bufferInc;
+      if(wOffset >= L)
+        wOffset -= L;
+
+      /* Decrement the loop counter */
+      i--;
+    }
+
+    /* Update the index pointer */
+    *writeOffset = wOffset;
+  }
+
+
+
+  /**
+   * @brief floating-point Circular Read function.
+   */
+  static __INLINE void arm_circularRead_f32(
+  int32_t * circBuffer,
+  int32_t L,
+  int32_t * readOffset,
+  int32_t bufferInc,
+  int32_t * dst,
+  int32_t * dst_base,
+  int32_t dst_length,
+  int32_t dstInc,
+  uint32_t blockSize)
+  {
+    uint32_t i = 0u;
+    int32_t rOffset, dst_end;
+
+    /* Copy the value of Index pointer that points
+     * to the current location from where the input samples to be read */
+    rOffset = *readOffset;
+    dst_end = (int32_t) (dst_base + dst_length);
+
+    /* Loop over the blockSize */
+    i = blockSize;
+
+    while(i > 0u)
+    {
+      /* copy the sample from the circular buffer to the destination buffer */
+      *dst = circBuffer[rOffset];
+
+      /* Update the input pointer */
+      dst += dstInc;
+
+      if(dst == (int32_t *) dst_end)
+      {
+        dst = dst_base;
+      }
+
+      /* Circularly update rOffset.  Watch out for positive and negative value  */
+      rOffset += bufferInc;
+
+      if(rOffset >= L)
+      {
+        rOffset -= L;
+      }
+
+      /* Decrement the loop counter */
+      i--;
+    }
+
+    /* Update the index pointer */
+    *readOffset = rOffset;
+  }
+
+  /**
+   * @brief Q15 Circular write function.
+   */
+
+  static __INLINE void arm_circularWrite_q15(
+  q15_t * circBuffer,
+  int32_t L,
+  uint16_t * writeOffset,
+  int32_t bufferInc,
+  const q15_t * src,
+  int32_t srcInc,
+  uint32_t blockSize)
+  {
+    uint32_t i = 0u;
+    int32_t wOffset;
+
+    /* Copy the value of Index pointer that points
+     * to the current location where the input samples to be copied */
+    wOffset = *writeOffset;
+
+    /* Loop over the blockSize */
+    i = blockSize;
+
+    while(i > 0u)
+    {
+      /* copy the input sample to the circular buffer */
+      circBuffer[wOffset] = *src;
+
+      /* Update the input pointer */
+      src += srcInc;
+
+      /* Circularly update wOffset.  Watch out for positive and negative value */
+      wOffset += bufferInc;
+      if(wOffset >= L)
+        wOffset -= L;
+
+      /* Decrement the loop counter */
+      i--;
+    }
+
+    /* Update the index pointer */
+    *writeOffset = wOffset;
+  }
+
+
+
+  /**
+   * @brief Q15 Circular Read function.
+   */
+  static __INLINE void arm_circularRead_q15(
+  q15_t * circBuffer,
+  int32_t L,
+  int32_t * readOffset,
+  int32_t bufferInc,
+  q15_t * dst,
+  q15_t * dst_base,
+  int32_t dst_length,
+  int32_t dstInc,
+  uint32_t blockSize)
+  {
+    uint32_t i = 0;
+    int32_t rOffset, dst_end;
+
+    /* Copy the value of Index pointer that points
+     * to the current location from where the input samples to be read */
+    rOffset = *readOffset;
+
+    dst_end = (int32_t) (dst_base + dst_length);
+
+    /* Loop over the blockSize */
+    i = blockSize;
+
+    while(i > 0u)
+    {
+      /* copy the sample from the circular buffer to the destination buffer */
+      *dst = circBuffer[rOffset];
+
+      /* Update the input pointer */
+      dst += dstInc;
+
+      if(dst == (q15_t *) dst_end)
+      {
+        dst = dst_base;
+      }
+
+      /* Circularly update wOffset.  Watch out for positive and negative value */
+      rOffset += bufferInc;
+
+      if(rOffset >= L)
+      {
+        rOffset -= L;
+      }
+
+      /* Decrement the loop counter */
+      i--;
+    }
+
+    /* Update the index pointer */
+    *readOffset = rOffset;
+  }
+
+
+  /**
+   * @brief Q7 Circular write function.
+   */
+
+  static __INLINE void arm_circularWrite_q7(
+  q7_t * circBuffer,
+  int32_t L,
+  uint16_t * writeOffset,
+  int32_t bufferInc,
+  const q7_t * src,
+  int32_t srcInc,
+  uint32_t blockSize)
+  {
+    uint32_t i = 0u;
+    int32_t wOffset;
+
+    /* Copy the value of Index pointer that points
+     * to the current location where the input samples to be copied */
+    wOffset = *writeOffset;
+
+    /* Loop over the blockSize */
+    i = blockSize;
+
+    while(i > 0u)
+    {
+      /* copy the input sample to the circular buffer */
+      circBuffer[wOffset] = *src;
+
+      /* Update the input pointer */
+      src += srcInc;
+
+      /* Circularly update wOffset.  Watch out for positive and negative value */
+      wOffset += bufferInc;
+      if(wOffset >= L)
+        wOffset -= L;
+
+      /* Decrement the loop counter */
+      i--;
+    }
+
+    /* Update the index pointer */
+    *writeOffset = wOffset;
+  }
+
+
+
+  /**
+   * @brief Q7 Circular Read function.
+   */
+  static __INLINE void arm_circularRead_q7(
+  q7_t * circBuffer,
+  int32_t L,
+  int32_t * readOffset,
+  int32_t bufferInc,
+  q7_t * dst,
+  q7_t * dst_base,
+  int32_t dst_length,
+  int32_t dstInc,
+  uint32_t blockSize)
+  {
+    uint32_t i = 0;
+    int32_t rOffset, dst_end;
+
+    /* Copy the value of Index pointer that points
+     * to the current location from where the input samples to be read */
+    rOffset = *readOffset;
+
+    dst_end = (int32_t) (dst_base + dst_length);
+
+    /* Loop over the blockSize */
+    i = blockSize;
+
+    while(i > 0u)
+    {
+      /* copy the sample from the circular buffer to the destination buffer */
+      *dst = circBuffer[rOffset];
+
+      /* Update the input pointer */
+      dst += dstInc;
+
+      if(dst == (q7_t *) dst_end)
+      {
+        dst = dst_base;
+      }
+
+      /* Circularly update rOffset.  Watch out for positive and negative value */
+      rOffset += bufferInc;
+
+      if(rOffset >= L)
+      {
+        rOffset -= L;
+      }
+
+      /* Decrement the loop counter */
+      i--;
+    }
+
+    /* Update the index pointer */
+    *readOffset = rOffset;
+  }
+
+
+  /**
+   * @brief  Sum of the squares of the elements of a Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_power_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q63_t * pResult);
+
+  /**
+   * @brief  Sum of the squares of the elements of a floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_power_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult);
+
+  /**
+   * @brief  Sum of the squares of the elements of a Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_power_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q63_t * pResult);
+
+  /**
+   * @brief  Sum of the squares of the elements of a Q7 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_power_q7(
+  q7_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult);
+
+  /**
+   * @brief  Mean value of a Q7 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_mean_q7(
+  q7_t * pSrc,
+  uint32_t blockSize,
+  q7_t * pResult);
+
+  /**
+   * @brief  Mean value of a Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+  void arm_mean_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q15_t * pResult);
+
+  /**
+   * @brief  Mean value of a Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+  void arm_mean_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult);
+
+  /**
+   * @brief  Mean value of a floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+  void arm_mean_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult);
+
+  /**
+   * @brief  Variance of the elements of a floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_var_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult);
+
+  /**
+   * @brief  Variance of the elements of a Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_var_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q63_t * pResult);
+
+  /**
+   * @brief  Variance of the elements of a Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_var_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult);
+
+  /**
+   * @brief  Root Mean Square of the elements of a floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_rms_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult);
+
+  /**
+   * @brief  Root Mean Square of the elements of a Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_rms_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult);
+
+  /**
+   * @brief  Root Mean Square of the elements of a Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_rms_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q15_t * pResult);
+
+  /**
+   * @brief  Standard deviation of the elements of a floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_std_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult);
+
+  /**
+   * @brief  Standard deviation of the elements of a Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_std_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult);
+
+  /**
+   * @brief  Standard deviation of the elements of a Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output value.
+   * @return none.
+   */
+
+  void arm_std_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q15_t * pResult);
+
+  /**
+   * @brief  Floating-point complex magnitude
+   * @param[in]  *pSrc points to the complex input vector
+   * @param[out]  *pDst points to the real output vector
+   * @param[in]  numSamples number of complex samples in the input vector
+   * @return none.
+   */
+
+  void arm_cmplx_mag_f32(
+  float32_t * pSrc,
+  float32_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q31 complex magnitude
+   * @param[in]  *pSrc points to the complex input vector
+   * @param[out]  *pDst points to the real output vector
+   * @param[in]  numSamples number of complex samples in the input vector
+   * @return none.
+   */
+
+  void arm_cmplx_mag_q31(
+  q31_t * pSrc,
+  q31_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q15 complex magnitude
+   * @param[in]  *pSrc points to the complex input vector
+   * @param[out]  *pDst points to the real output vector
+   * @param[in]  numSamples number of complex samples in the input vector
+   * @return none.
+   */
+
+  void arm_cmplx_mag_q15(
+  q15_t * pSrc,
+  q15_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q15 complex dot product
+   * @param[in]  *pSrcA points to the first input vector
+   * @param[in]  *pSrcB points to the second input vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @param[out]  *realResult real part of the result returned here
+   * @param[out]  *imagResult imaginary part of the result returned here
+   * @return none.
+   */
+
+  void arm_cmplx_dot_prod_q15(
+  q15_t * pSrcA,
+  q15_t * pSrcB,
+  uint32_t numSamples,
+  q31_t * realResult,
+  q31_t * imagResult);
+
+  /**
+   * @brief  Q31 complex dot product
+   * @param[in]  *pSrcA points to the first input vector
+   * @param[in]  *pSrcB points to the second input vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @param[out]  *realResult real part of the result returned here
+   * @param[out]  *imagResult imaginary part of the result returned here
+   * @return none.
+   */
+
+  void arm_cmplx_dot_prod_q31(
+  q31_t * pSrcA,
+  q31_t * pSrcB,
+  uint32_t numSamples,
+  q63_t * realResult,
+  q63_t * imagResult);
+
+  /**
+   * @brief  Floating-point complex dot product
+   * @param[in]  *pSrcA points to the first input vector
+   * @param[in]  *pSrcB points to the second input vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @param[out]  *realResult real part of the result returned here
+   * @param[out]  *imagResult imaginary part of the result returned here
+   * @return none.
+   */
+
+  void arm_cmplx_dot_prod_f32(
+  float32_t * pSrcA,
+  float32_t * pSrcB,
+  uint32_t numSamples,
+  float32_t * realResult,
+  float32_t * imagResult);
+
+  /**
+   * @brief  Q15 complex-by-real multiplication
+   * @param[in]  *pSrcCmplx points to the complex input vector
+   * @param[in]  *pSrcReal points to the real input vector
+   * @param[out]  *pCmplxDst points to the complex output vector
+   * @param[in]  numSamples number of samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_mult_real_q15(
+  q15_t * pSrcCmplx,
+  q15_t * pSrcReal,
+  q15_t * pCmplxDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q31 complex-by-real multiplication
+   * @param[in]  *pSrcCmplx points to the complex input vector
+   * @param[in]  *pSrcReal points to the real input vector
+   * @param[out]  *pCmplxDst points to the complex output vector
+   * @param[in]  numSamples number of samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_mult_real_q31(
+  q31_t * pSrcCmplx,
+  q31_t * pSrcReal,
+  q31_t * pCmplxDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Floating-point complex-by-real multiplication
+   * @param[in]  *pSrcCmplx points to the complex input vector
+   * @param[in]  *pSrcReal points to the real input vector
+   * @param[out]  *pCmplxDst points to the complex output vector
+   * @param[in]  numSamples number of samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_mult_real_f32(
+  float32_t * pSrcCmplx,
+  float32_t * pSrcReal,
+  float32_t * pCmplxDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Minimum value of a Q7 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *result is output pointer
+   * @param[in]  index is the array index of the minimum value in the input buffer.
+   * @return none.
+   */
+
+  void arm_min_q7(
+  q7_t * pSrc,
+  uint32_t blockSize,
+  q7_t * result,
+  uint32_t * index);
+
+  /**
+   * @brief  Minimum value of a Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output pointer
+   * @param[in]  *pIndex is the array index of the minimum value in the input buffer.
+   * @return none.
+   */
+
+  void arm_min_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q15_t * pResult,
+  uint32_t * pIndex);
+
+  /**
+   * @brief  Minimum value of a Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output pointer
+   * @param[out]  *pIndex is the array index of the minimum value in the input buffer.
+   * @return none.
+   */
+  void arm_min_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult,
+  uint32_t * pIndex);
+
+  /**
+   * @brief  Minimum value of a floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @param[out]  *pResult is output pointer
+   * @param[out]  *pIndex is the array index of the minimum value in the input buffer.
+   * @return none.
+   */
+
+  void arm_min_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult,
+  uint32_t * pIndex);
+
+/**
+ * @brief Maximum value of a Q7 vector.
+ * @param[in]       *pSrc points to the input buffer
+ * @param[in]       blockSize length of the input vector
+ * @param[out]      *pResult maximum value returned here
+ * @param[out]      *pIndex index of maximum value returned here
+ * @return none.
+ */
+
+  void arm_max_q7(
+  q7_t * pSrc,
+  uint32_t blockSize,
+  q7_t * pResult,
+  uint32_t * pIndex);
+
+/**
+ * @brief Maximum value of a Q15 vector.
+ * @param[in]       *pSrc points to the input buffer
+ * @param[in]       blockSize length of the input vector
+ * @param[out]      *pResult maximum value returned here
+ * @param[out]      *pIndex index of maximum value returned here
+ * @return none.
+ */
+
+  void arm_max_q15(
+  q15_t * pSrc,
+  uint32_t blockSize,
+  q15_t * pResult,
+  uint32_t * pIndex);
+
+/**
+ * @brief Maximum value of a Q31 vector.
+ * @param[in]       *pSrc points to the input buffer
+ * @param[in]       blockSize length of the input vector
+ * @param[out]      *pResult maximum value returned here
+ * @param[out]      *pIndex index of maximum value returned here
+ * @return none.
+ */
+
+  void arm_max_q31(
+  q31_t * pSrc,
+  uint32_t blockSize,
+  q31_t * pResult,
+  uint32_t * pIndex);
+
+/**
+ * @brief Maximum value of a floating-point vector.
+ * @param[in]       *pSrc points to the input buffer
+ * @param[in]       blockSize length of the input vector
+ * @param[out]      *pResult maximum value returned here
+ * @param[out]      *pIndex index of maximum value returned here
+ * @return none.
+ */
+
+  void arm_max_f32(
+  float32_t * pSrc,
+  uint32_t blockSize,
+  float32_t * pResult,
+  uint32_t * pIndex);
+
+  /**
+   * @brief  Q15 complex-by-complex multiplication
+   * @param[in]  *pSrcA points to the first input vector
+   * @param[in]  *pSrcB points to the second input vector
+   * @param[out]  *pDst  points to the output vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_mult_cmplx_q15(
+  q15_t * pSrcA,
+  q15_t * pSrcB,
+  q15_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Q31 complex-by-complex multiplication
+   * @param[in]  *pSrcA points to the first input vector
+   * @param[in]  *pSrcB points to the second input vector
+   * @param[out]  *pDst  points to the output vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_mult_cmplx_q31(
+  q31_t * pSrcA,
+  q31_t * pSrcB,
+  q31_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief  Floating-point complex-by-complex multiplication
+   * @param[in]  *pSrcA points to the first input vector
+   * @param[in]  *pSrcB points to the second input vector
+   * @param[out]  *pDst  points to the output vector
+   * @param[in]  numSamples number of complex samples in each vector
+   * @return none.
+   */
+
+  void arm_cmplx_mult_cmplx_f32(
+  float32_t * pSrcA,
+  float32_t * pSrcB,
+  float32_t * pDst,
+  uint32_t numSamples);
+
+  /**
+   * @brief Converts the elements of the floating-point vector to Q31 vector.
+   * @param[in]       *pSrc points to the floating-point input vector
+   * @param[out]      *pDst points to the Q31 output vector
+   * @param[in]       blockSize length of the input vector
+   * @return none.
+   */
+  void arm_float_to_q31(
+  float32_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Converts the elements of the floating-point vector to Q15 vector.
+   * @param[in]       *pSrc points to the floating-point input vector
+   * @param[out]      *pDst points to the Q15 output vector
+   * @param[in]       blockSize length of the input vector
+   * @return          none
+   */
+  void arm_float_to_q15(
+  float32_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief Converts the elements of the floating-point vector to Q7 vector.
+   * @param[in]       *pSrc points to the floating-point input vector
+   * @param[out]      *pDst points to the Q7 output vector
+   * @param[in]       blockSize length of the input vector
+   * @return          none
+   */
+  void arm_float_to_q7(
+  float32_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Converts the elements of the Q31 vector to Q15 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q31_to_q15(
+  q31_t * pSrc,
+  q15_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Converts the elements of the Q31 vector to Q7 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q31_to_q7(
+  q31_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+  /**
+   * @brief  Converts the elements of the Q15 vector to floating-point vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q15_to_float(
+  q15_t * pSrc,
+  float32_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Converts the elements of the Q15 vector to Q31 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q15_to_q31(
+  q15_t * pSrc,
+  q31_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @brief  Converts the elements of the Q15 vector to Q7 vector.
+   * @param[in]  *pSrc is input pointer
+   * @param[out]  *pDst is output pointer
+   * @param[in]  blockSize is the number of samples to process
+   * @return none.
+   */
+  void arm_q15_to_q7(
+  q15_t * pSrc,
+  q7_t * pDst,
+  uint32_t blockSize);
+
+
+  /**
+   * @ingroup groupInterpolation
+   */
+
+  /**
+   * @defgroup BilinearInterpolate Bilinear Interpolation
+   *
+   * Bilinear interpolation is an extension of linear interpolation applied to a two dimensional grid.
+   * The underlying function <code>f(x, y)</code> is sampled on a regular grid and the interpolation process
+   * determines values between the grid points.
+   * Bilinear interpolation is equivalent to two step linear interpolation, first in the x-dimension and then in the y-dimension.
+   * Bilinear interpolation is often used in image processing to rescale images.
+   * The CMSIS DSP library provides bilinear interpolation functions for Q7, Q15, Q31, and floating-point data types.
+   *
+   * <b>Algorithm</b>
+   * \par
+   * The instance structure used by the bilinear interpolation functions describes a two dimensional data table.
+   * For floating-point, the instance structure is defined as:
+   * <pre>
+   *   typedef struct
+   *   {
+   *     uint16_t numRows;
+   *     uint16_t numCols;
+   *     float32_t *pData;
+   * } arm_bilinear_interp_instance_f32;
+   * </pre>
+   *
+   * \par
+   * where <code>numRows</code> specifies the number of rows in the table;
+   * <code>numCols</code> specifies the number of columns in the table;
+   * and <code>pData</code> points to an array of size <code>numRows*numCols</code> values.
+   * The data table <code>pTable</code> is organized in row order and the supplied data values fall on integer indexes.
+   * That is, table element (x,y) is located at <code>pTable[x + y*numCols]</code> where x and y are integers.
+   *
+   * \par
+   * Let <code>(x, y)</code> specify the desired interpolation point.  Then define:
+   * <pre>
+   *     XF = floor(x)
+   *     YF = floor(y)
+   * </pre>
+   * \par
+   * The interpolated output point is computed as:
+   * <pre>
+   *  f(x, y) = f(XF, YF) * (1-(x-XF)) * (1-(y-YF))
+   *           + f(XF+1, YF) * (x-XF)*(1-(y-YF))
+   *           + f(XF, YF+1) * (1-(x-XF))*(y-YF)
+   *           + f(XF+1, YF+1) * (x-XF)*(y-YF)
+   * </pre>
+   * Note that the coordinates (x, y) contain integer and fractional components.
+   * The integer components specify which portion of the table to use while the
+   * fractional components control the interpolation processor.
+   *
+   * \par
+   * if (x,y) are outside of the table boundary, Bilinear interpolation returns zero output.
+   */
+
+  /**
+   * @addtogroup BilinearInterpolate
+   * @{
+   */
+
+  /**
+  *
+  * @brief  Floating-point bilinear interpolation.
+  * @param[in,out] *S points to an instance of the interpolation structure.
+  * @param[in] X interpolation coordinate.
+  * @param[in] Y interpolation coordinate.
+  * @return out interpolated value.
+  */
+
+
+  static __INLINE float32_t arm_bilinear_interp_f32(
+  const arm_bilinear_interp_instance_f32 * S,
+  float32_t X,
+  float32_t Y)
+  {
+    float32_t out;
+    float32_t f00, f01, f10, f11;
+    float32_t *pData = S->pData;
+    int32_t xIndex, yIndex, index;
+    float32_t xdiff, ydiff;
+    float32_t b1, b2, b3, b4;
+
+    xIndex = (int32_t) X;
+    yIndex = (int32_t) Y;
+
+    /* Care taken for table outside boundary */
+    /* Returns zero output when values are outside table boundary */
+    if(xIndex < 0 || xIndex > (S->numRows - 1) || yIndex < 0
+       || yIndex > (S->numCols - 1))
+    {
+      return (0);
+    }
+
+    /* Calculation of index for two nearest points in X-direction */
+    index = (xIndex - 1) + (yIndex - 1) * S->numCols;
+
+
+    /* Read two nearest points in X-direction */
+    f00 = pData[index];
+    f01 = pData[index + 1];
+
+    /* Calculation of index for two nearest points in Y-direction */
+    index = (xIndex - 1) + (yIndex) * S->numCols;
+
+
+    /* Read two nearest points in Y-direction */
+    f10 = pData[index];
+    f11 = pData[index + 1];
+
+    /* Calculation of intermediate values */
+    b1 = f00;
+    b2 = f01 - f00;
+    b3 = f10 - f00;
+    b4 = f00 - f01 - f10 + f11;
+
+    /* Calculation of fractional part in X */
+    xdiff = X - xIndex;
+
+    /* Calculation of fractional part in Y */
+    ydiff = Y - yIndex;
+
+    /* Calculation of bi-linear interpolated output */
+    out = b1 + b2 * xdiff + b3 * ydiff + b4 * xdiff * ydiff;
+
+    /* return to application */
+    return (out);
+
+  }
+
+  /**
+  *
+  * @brief  Q31 bilinear interpolation.
+  * @param[in,out] *S points to an instance of the interpolation structure.
+  * @param[in] X interpolation coordinate in 12.20 format.
+  * @param[in] Y interpolation coordinate in 12.20 format.
+  * @return out interpolated value.
+  */
+
+  static __INLINE q31_t arm_bilinear_interp_q31(
+  arm_bilinear_interp_instance_q31 * S,
+  q31_t X,
+  q31_t Y)
+  {
+    q31_t out;                                   /* Temporary output */
+    q31_t acc = 0;                               /* output */
+    q31_t xfract, yfract;                        /* X, Y fractional parts */
+    q31_t x1, x2, y1, y2;                        /* Nearest output values */
+    int32_t rI, cI;                              /* Row and column indices */
+    q31_t *pYData = S->pData;                    /* pointer to output table values */
+    uint32_t nCols = S->numCols;                 /* num of rows */
+
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    rI = ((X & 0xFFF00000) >> 20u);
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    cI = ((Y & 0xFFF00000) >> 20u);
+
+    /* Care taken for table outside boundary */
+    /* Returns zero output when values are outside table boundary */
+    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
+    {
+      return (0);
+    }
+
+    /* 20 bits for the fractional part */
+    /* shift left xfract by 11 to keep 1.31 format */
+    xfract = (X & 0x000FFFFF) << 11u;
+
+    /* Read two nearest output values from the index */
+    x1 = pYData[(rI) + nCols * (cI)];
+    x2 = pYData[(rI) + nCols * (cI) + 1u];
+
+    /* 20 bits for the fractional part */
+    /* shift left yfract by 11 to keep 1.31 format */
+    yfract = (Y & 0x000FFFFF) << 11u;
+
+    /* Read two nearest output values from the index */
+    y1 = pYData[(rI) + nCols * (cI + 1)];
+    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
+
+    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 3.29(q29) format */
+    out = ((q31_t) (((q63_t) x1 * (0x7FFFFFFF - xfract)) >> 32));
+    acc = ((q31_t) (((q63_t) out * (0x7FFFFFFF - yfract)) >> 32));
+
+    /* x2 * (xfract) * (1-yfract)  in 3.29(q29) and adding to acc */
+    out = ((q31_t) ((q63_t) x2 * (0x7FFFFFFF - yfract) >> 32));
+    acc += ((q31_t) ((q63_t) out * (xfract) >> 32));
+
+    /* y1 * (1 - xfract) * (yfract)  in 3.29(q29) and adding to acc */
+    out = ((q31_t) ((q63_t) y1 * (0x7FFFFFFF - xfract) >> 32));
+    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
+
+    /* y2 * (xfract) * (yfract)  in 3.29(q29) and adding to acc */
+    out = ((q31_t) ((q63_t) y2 * (xfract) >> 32));
+    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
+
+    /* Convert acc to 1.31(q31) format */
+    return (acc << 2u);
+
+  }
+
+  /**
+  * @brief  Q15 bilinear interpolation.
+  * @param[in,out] *S points to an instance of the interpolation structure.
+  * @param[in] X interpolation coordinate in 12.20 format.
+  * @param[in] Y interpolation coordinate in 12.20 format.
+  * @return out interpolated value.
+  */
+
+  static __INLINE q15_t arm_bilinear_interp_q15(
+  arm_bilinear_interp_instance_q15 * S,
+  q31_t X,
+  q31_t Y)
+  {
+    q63_t acc = 0;                               /* output */
+    q31_t out;                                   /* Temporary output */
+    q15_t x1, x2, y1, y2;                        /* Nearest output values */
+    q31_t xfract, yfract;                        /* X, Y fractional parts */
+    int32_t rI, cI;                              /* Row and column indices */
+    q15_t *pYData = S->pData;                    /* pointer to output table values */
+    uint32_t nCols = S->numCols;                 /* num of rows */
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    rI = ((X & 0xFFF00000) >> 20);
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    cI = ((Y & 0xFFF00000) >> 20);
+
+    /* Care taken for table outside boundary */
+    /* Returns zero output when values are outside table boundary */
+    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
+    {
+      return (0);
+    }
+
+    /* 20 bits for the fractional part */
+    /* xfract should be in 12.20 format */
+    xfract = (X & 0x000FFFFF);
+
+    /* Read two nearest output values from the index */
+    x1 = pYData[(rI) + nCols * (cI)];
+    x2 = pYData[(rI) + nCols * (cI) + 1u];
+
+
+    /* 20 bits for the fractional part */
+    /* yfract should be in 12.20 format */
+    yfract = (Y & 0x000FFFFF);
+
+    /* Read two nearest output values from the index */
+    y1 = pYData[(rI) + nCols * (cI + 1)];
+    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
+
+    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 13.51 format */
+
+    /* x1 is in 1.15(q15), xfract in 12.20 format and out is in 13.35 format */
+    /* convert 13.35 to 13.31 by right shifting  and out is in 1.31 */
+    out = (q31_t) (((q63_t) x1 * (0xFFFFF - xfract)) >> 4u);
+    acc = ((q63_t) out * (0xFFFFF - yfract));
+
+    /* x2 * (xfract) * (1-yfract)  in 1.51 and adding to acc */
+    out = (q31_t) (((q63_t) x2 * (0xFFFFF - yfract)) >> 4u);
+    acc += ((q63_t) out * (xfract));
+
+    /* y1 * (1 - xfract) * (yfract)  in 1.51 and adding to acc */
+    out = (q31_t) (((q63_t) y1 * (0xFFFFF - xfract)) >> 4u);
+    acc += ((q63_t) out * (yfract));
+
+    /* y2 * (xfract) * (yfract)  in 1.51 and adding to acc */
+    out = (q31_t) (((q63_t) y2 * (xfract)) >> 4u);
+    acc += ((q63_t) out * (yfract));
+
+    /* acc is in 13.51 format and down shift acc by 36 times */
+    /* Convert out to 1.15 format */
+    return (acc >> 36);
+
+  }
+
+  /**
+  * @brief  Q7 bilinear interpolation.
+  * @param[in,out] *S points to an instance of the interpolation structure.
+  * @param[in] X interpolation coordinate in 12.20 format.
+  * @param[in] Y interpolation coordinate in 12.20 format.
+  * @return out interpolated value.
+  */
+
+  static __INLINE q7_t arm_bilinear_interp_q7(
+  arm_bilinear_interp_instance_q7 * S,
+  q31_t X,
+  q31_t Y)
+  {
+    q63_t acc = 0;                               /* output */
+    q31_t out;                                   /* Temporary output */
+    q31_t xfract, yfract;                        /* X, Y fractional parts */
+    q7_t x1, x2, y1, y2;                         /* Nearest output values */
+    int32_t rI, cI;                              /* Row and column indices */
+    q7_t *pYData = S->pData;                     /* pointer to output table values */
+    uint32_t nCols = S->numCols;                 /* num of rows */
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    rI = ((X & 0xFFF00000) >> 20);
+
+    /* Input is in 12.20 format */
+    /* 12 bits for the table index */
+    /* Index value calculation */
+    cI = ((Y & 0xFFF00000) >> 20);
+
+    /* Care taken for table outside boundary */
+    /* Returns zero output when values are outside table boundary */
+    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
+    {
+      return (0);
+    }
+
+    /* 20 bits for the fractional part */
+    /* xfract should be in 12.20 format */
+    xfract = (X & 0x000FFFFF);
+
+    /* Read two nearest output values from the index */
+    x1 = pYData[(rI) + nCols * (cI)];
+    x2 = pYData[(rI) + nCols * (cI) + 1u];
+
+
+    /* 20 bits for the fractional part */
+    /* yfract should be in 12.20 format */
+    yfract = (Y & 0x000FFFFF);
+
+    /* Read two nearest output values from the index */
+    y1 = pYData[(rI) + nCols * (cI + 1)];
+    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
+
+    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 16.47 format */
+    out = ((x1 * (0xFFFFF - xfract)));
+    acc = (((q63_t) out * (0xFFFFF - yfract)));
+
+    /* x2 * (xfract) * (1-yfract)  in 2.22 and adding to acc */
+    out = ((x2 * (0xFFFFF - yfract)));
+    acc += (((q63_t) out * (xfract)));
+
+    /* y1 * (1 - xfract) * (yfract)  in 2.22 and adding to acc */
+    out = ((y1 * (0xFFFFF - xfract)));
+    acc += (((q63_t) out * (yfract)));
+
+    /* y2 * (xfract) * (yfract)  in 2.22 and adding to acc */
+    out = ((y2 * (yfract)));
+    acc += (((q63_t) out * (xfract)));
+
+    /* acc in 16.47 format and down shift by 40 to convert to 1.7 format */
+    return (acc >> 40);
+
+  }
+
+  /**
+   * @} end of BilinearInterpolate group
+   */
+
+
+#if   defined ( __CC_ARM ) //Keil
+//SMMLAR
+  #define multAcc_32x32_keep32_R(a, x, y) \
+  a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
+
+//SMMLSR
+  #define multSub_32x32_keep32_R(a, x, y) \
+  a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
+
+//SMMULR
+  #define mult_32x32_keep32_R(a, x, y) \
+  a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
+
+//Enter low optimization region - place directly above function definition
+  #define LOW_OPTIMIZATION_ENTER \
+     _Pragma ("push")         \
+     _Pragma ("O1")
+
+//Exit low optimization region - place directly after end of function definition
+  #define LOW_OPTIMIZATION_EXIT \
+     _Pragma ("pop")
+
+//Enter low optimization region - place directly above function definition
+  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
+
+//Exit low optimization region - place directly after end of function definition
+  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
+
+#elif defined(__ICCARM__) //IAR
+ //SMMLA
+  #define multAcc_32x32_keep32_R(a, x, y) \
+  a += (q31_t) (((q63_t) x * y) >> 32)
+
+ //SMMLS
+  #define multSub_32x32_keep32_R(a, x, y) \
+  a -= (q31_t) (((q63_t) x * y) >> 32)
+
+//SMMUL
+  #define mult_32x32_keep32_R(a, x, y) \
+  a = (q31_t) (((q63_t) x * y ) >> 32)
+
+//Enter low optimization region - place directly above function definition
+  #define LOW_OPTIMIZATION_ENTER \
+     _Pragma ("optimize=low")
+
+//Exit low optimization region - place directly after end of function definition
+  #define LOW_OPTIMIZATION_EXIT
+
+//Enter low optimization region - place directly above function definition
+  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER \
+     _Pragma ("optimize=low")
+
+//Exit low optimization region - place directly after end of function definition
+  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
+
+#elif defined(__GNUC__)
+ //SMMLA
+  #define multAcc_32x32_keep32_R(a, x, y) \
+  a += (q31_t) (((q63_t) x * y) >> 32)
+
+ //SMMLS
+  #define multSub_32x32_keep32_R(a, x, y) \
+  a -= (q31_t) (((q63_t) x * y) >> 32)
+
+//SMMUL
+  #define mult_32x32_keep32_R(a, x, y) \
+  a = (q31_t) (((q63_t) x * y ) >> 32)
+
+  #define LOW_OPTIMIZATION_ENTER __attribute__(( optimize("-O1") ))
+
+  #define LOW_OPTIMIZATION_EXIT
+
+  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
+
+  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
+
+#endif
+
+
+
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+
+#endif /* _ARM_MATH_H */
+
+
+/**
+ *
+ * End of file.
+ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/atimer_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/atimer_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/atimer_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/atimer_18xx_43xx.h	2018-12-01 17:15:06.637606391 -0300
@@ -0,0 +1,149 @@
+/*
+ * @brief LPC18xx/43xx Alarm Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ATIMER_18XX_43XX_H_
+#define __ATIMER_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ATIMER_18XX_43XX CHIP: LPC18xx/43xx Alarm Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Alarm Timer register block structure
+ */
+typedef struct {					/*!< ATIMER Structure       */
+	__IO uint32_t DOWNCOUNTER;		/*!< Downcounter register   */
+	__IO uint32_t PRESET;			/*!< Preset value register  */
+	__I  uint32_t RESERVED0[1012];
+	__O  uint32_t CLR_EN;			/*!< Interrupt clear enable register */
+	__O  uint32_t SET_EN;			/*!< Interrupt set enable register */
+	__I  uint32_t STATUS;			/*!< Status register        */
+	__I  uint32_t ENABLE;			/*!< Enable register        */
+	__O  uint32_t CLR_STAT;			/*!< Clear register         */
+	__O  uint32_t SET_STAT;			/*!< Set register           */
+} LPC_ATIMER_T;
+
+/**
+ * @brief	Initialize Alarm Timer
+ * @param	pATIMER		: The base of ATIMER peripheral on the chip
+ * @param	PresetValue	: Count of 1 to 1024s for Alarm
+ * @return	None
+ */
+void Chip_ATIMER_Init(LPC_ATIMER_T *pATIMER, uint32_t PresetValue);
+
+/**
+ * @brief	Close ATIMER device
+ * @param	pATIMER	: The base of ATIMER peripheral on the chip
+ * @return	None
+ */
+void Chip_ATIMER_DeInit(LPC_ATIMER_T *pATIMER);
+
+/**
+ * @brief	Enable ATIMER Interrupt
+ * @param	pATIMER	: The base of ATIMER peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_ATIMER_IntEnable(LPC_ATIMER_T *pATIMER)
+{
+	pATIMER->SET_EN = 1;
+}
+
+/**
+ * @brief	Disable ATIMER Interrupt
+ * @param	pATIMER	: The base of ATIMER peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_ATIMER_IntDisable(LPC_ATIMER_T *pATIMER)
+{
+	pATIMER->CLR_EN = 1;
+}
+
+/**
+ * @brief	Clear ATIMER Interrupt Status
+ * @param	pATIMER	: The base of ATIMER peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_ATIMER_ClearIntStatus(LPC_ATIMER_T *pATIMER)
+{
+	pATIMER->CLR_STAT = 1;
+}
+
+/**
+ * @brief	Set ATIMER Interrupt Status
+ * @param	pATIMER	: The base of ATIMER peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_ATIMER_SetIntStatus(LPC_ATIMER_T *pATIMER)
+{
+	pATIMER->SET_STAT = 1;
+}
+
+/**
+ * @brief	Update Preset value
+ * @param	pATIMER		: The base of ATIMER peripheral on the chip
+ * @param	PresetValue	: updated preset value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ATIMER_UpdatePresetValue(LPC_ATIMER_T *pATIMER, uint32_t PresetValue)
+{
+	pATIMER->PRESET = PresetValue;
+}
+
+/**
+ * @brief	Read value of preset register
+ * @param	pATIMER	: The base of ATIMER peripheral on the chip
+ * @return	Value of capture register
+ */
+STATIC INLINE uint32_t Chip_ATIMER_GetPresetValue(LPC_ATIMER_T *pATIMER)
+{
+	return pATIMER->PRESET;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ATIMER_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ccan_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/ccan_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ccan_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/ccan_18xx_43xx.h	2018-12-01 17:15:06.637606391 -0300
@@ -0,0 +1,511 @@
+/*
+ * @brief LPC18xx/43xx CCAN driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CCAN_18XX_43XX_H_
+#define __CCAN_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CCAN_18XX_43XX CHIP: LPC18xx/43xx CCAN driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief CCAN message interface register block structure
+ */
+typedef struct {	/*!< C_CAN message interface Structure       */
+	__IO uint32_t CMDREQ;			/*!< Message interface command request  */
+	__IO uint32_t CMDMSK;			/*!< Message interface command mask*/
+	__IO uint32_t MSK1;				/*!< Message interface mask 1 */
+	__IO uint32_t MSK2;				/*!< Message interface mask 2 */
+	__IO uint32_t ARB1;				/*!< Message interface arbitration 1 */
+	__IO uint32_t ARB2;				/*!< Message interface arbitration 2 */
+	__IO uint32_t MCTRL;			/*!< Message interface message control */
+	__IO uint32_t DA1;				/*!< Message interface data A1 */
+	__IO uint32_t DA2;				/*!< Message interface data A2 */
+	__IO uint32_t DB1;				/*!< Message interface data B1 */
+	__IO uint32_t DB2;				/*!< Message interface data B2 */
+	__I  uint32_t  RESERVED[13];
+} CCAN_IF_T;
+
+/**
+ * @brief CCAN Controller Area Network register block structure
+ */
+typedef struct {						/*!< C_CAN Structure       */
+	__IO uint32_t CNTL;					/*!< CAN control            */
+	__IO uint32_t STAT;					/*!< Status register        */
+	__I  uint32_t EC;					/*!< Error counter          */
+	__IO uint32_t BT;					/*!< Bit timing register    */
+	__I  uint32_t INT;					/*!< Interrupt register     */
+	__IO uint32_t TEST;					/*!< Test register          */
+	__IO uint32_t BRPE;					/*!< Baud rate prescaler extension register */
+	__I  uint32_t  RESERVED0;
+	CCAN_IF_T IF[2];
+	__I  uint32_t  RESERVED2[8];
+	__I  uint32_t TXREQ1;				/*!< Transmission request 1 */
+	__I  uint32_t TXREQ2;				/*!< Transmission request 2 */
+	__I  uint32_t  RESERVED3[6];
+	__I  uint32_t ND1;					/*!< New data 1             */
+	__I  uint32_t ND2;					/*!< New data 2             */
+	__I  uint32_t  RESERVED4[6];
+	__I  uint32_t IR1;					/*!< Interrupt pending 1    */
+	__I  uint32_t IR2;					/*!< Interrupt pending 2    */
+	__I  uint32_t  RESERVED5[6];
+	__I  uint32_t MSGV1;				/*!< Message valid 1        */
+	__I  uint32_t MSGV2;				/*!< Message valid 2        */
+	__I  uint32_t  RESERVED6[6];
+	__IO uint32_t CLKDIV;				/*!< CAN clock divider register */
+} LPC_CCAN_T;
+
+/* CCAN Control register bit definitions */
+#define CCAN_CTRL_INIT      (1 << 0)	/*!< Initialization is started. */
+#define CCAN_CTRL_IE        (1 << 1)	/*!< Module Interupt Enable. */
+#define CCAN_CTRL_SIE       (1 << 2)	/*!< Status Change Interupt Enable. */
+#define CCAN_CTRL_EIE       (1 << 3)	/*!< Error Interupt Enable. */
+#define CCAN_CTRL_DAR       (1 << 5)	/*!< Automatic retransmission disabled. */
+#define CCAN_CTRL_CCE       (1 << 6)	/*!< The CPU has write access to the CANBT register while the INIT bit is one.*/
+#define CCAN_CTRL_TEST      (1 << 7)	/*!< Test mode. */
+
+/* CCAN STAT register bit definitions */
+#define CCAN_STAT_LEC_MASK  (0x07)		/* Mask for Last Error Code */
+#define CCAN_STAT_TXOK      (1 << 3)	/* Transmitted a message successfully */
+#define CCAN_STAT_RXOK      (1 << 4)	/* Received a message successfully */
+#define CCAN_STAT_EPASS     (1 << 5)	/* The CAN controller is in the error passive state*/
+#define CCAN_STAT_EWARN     (1 << 6)	/*At least one of the error counters in the EC has reached the error warning limit of 96.*/
+#define CCAN_STAT_BOFF      (1 << 7)	/*The CAN controller is in busoff state.*/
+
+/**
+ * @brief Last Error Code definition
+ */
+typedef enum {
+	CCAN_LEC_NO_ERROR,		/*!< No error */
+	CCAN_LEC_STUFF_ERROR,	/*!< More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed. */
+	CCAN_LEC_FORM_ERROR,	/*!< A fixed format part of a received frame has the wrong format */
+	CCAN_LEC_ACK_ERROR,		/*!< The message this CAN core transmitted was not acknowledged. */
+	CCAN_LEC_BIT1_ERROR,	/*!< During the transmission of a message (with the exception of the arbitration field), the device wanted to send a HIGH/recessive level
+							    (bit of logical value "1"), but the monitored bus value was LOW/dominant. */
+	CCAN_LEC_BIT0_ERROR,	/*!< During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a
+							    LOW/dominant level (data or identifier bit logical value "0"), but the monitored Bus value was HIGH/recessive. During busoff recovery this
+							    status is set each time a sequence of 11 HIGH/recessive bits has been monitored. This enables
+							    the CPU to monitor the proceeding of the busoff recovery sequence (indicating the bus is not stuck at LOW/dominant or continuously disturbed). */
+	CCAN_LEC_CRC_ERROR,		/*!< The CRC checksum was incorrect in the message received. */
+} CCAN_LEC_T;
+
+/* CCAN INT register bit definitions */
+#define CCAN_INT_NO_PENDING       0			/*!< No interrupt pending */
+#define CCAN_INT_STATUS           0x8000	/*!< Status interrupt*/
+#define CCAN_INT_MSG_NUM(n)       (n)		/*!<Number of messages which caused interrupts */
+
+/* CCAN TEST register bit definitions */
+#define CCAN_TEST_BASIC_MODE      (1 << 2)	/*!<IF1 registers used as TX buffer, IF2 registers used as RX buffer. */
+#define CCAN_TEST_SILENT_MODE     (1 << 3)	/*!<The module is in silent mode. */
+#define CCAN_TEST_LOOPBACK_MODE   (1 << 4)	/*!<Loop back mode is enabled.*/
+#define CCAN_TEST_TD_CONTROLLED   (0)		/*!< Level at the TD pin is controlled by the CAN controller.*/
+#define CCAN_TEST_TD_MONITORED    (1 << 5)	/*!< The sample point can be monitored at the TD pin.*/
+#define CCAN_TEST_TD_DOMINANT     (2 << 5)	/*!< TD pin is driven LOW/dominant.*/
+#define CCAN_TEST_TD_RECESSIVE    (3 << 5)	/*!< TD pin is driven HIGH/recessive.*/
+#define CCAN_TEST_RD_DOMINANT     (0)		/*!< The CAN bus is dominant (RD = 0).*/
+#define CCAN_TEST_RD_RECESSIVE    (1 << 7)		/*!< The CAN bus is recessive (RD = 1).*/
+
+#define CCAN_SEG1_DEFAULT_VAL 5
+#define CCAN_SEG2_DEFAULT_VAL 4
+#define CCAN_SJW_DEFAULT_VAL  0
+
+/**
+ * @brief CCAN Transfer direction definition
+ */
+typedef enum {
+	CCAN_RX_DIR,
+	CCAN_TX_DIR,
+} CCAN_TRANSFER_DIR_T;
+
+/**
+ * @brief	Enable CCAN Interrupts
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	mask	: Interrupt mask, or-ed bit value of
+ *						- CCAN_CTRL_IE <br>
+ *						- CCAN_CTRL_SIE <br>
+ *						- CCAN_CTRL_EIE <br>
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_EnableInt(LPC_CCAN_T *pCCAN, uint32_t mask)
+{
+	pCCAN->CNTL |= mask;
+}
+
+/**
+ * @brief	Disable CCAN Interrupts
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	mask	: Interrupt mask, or-ed bit value of
+ *						- CCAN_CTRL_IE <br>
+ *						- CCAN_CTRL_SIE <br>
+ *						- CCAN_CTRL_EIE <br>
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_DisableInt(LPC_CCAN_T *pCCAN, uint32_t mask)
+{
+	pCCAN->CNTL &= ~mask;
+}
+
+/**
+ * @brief	Get the source ID of an interrupt
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @return	Interrupt source ID
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetIntID(LPC_CCAN_T *pCCAN)
+{
+	return pCCAN->INT;
+}
+
+/**
+ * @brief	Get the CCAN status register
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @return	CCAN status register (or-ed bit value of  CCAN_STAT_*)
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetStatus(LPC_CCAN_T *pCCAN)
+{
+	return pCCAN->STAT;
+}
+
+/**
+ * @brief	Set the CCAN status
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	val		: Value to be set for status register (or-ed bit value of  CCAN_STAT_*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_SetStatus(LPC_CCAN_T *pCCAN, uint32_t val)
+{
+	pCCAN->STAT = val & 0x1F;
+}
+
+/**
+ * @brief	Clear the status of CCAN bus
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	val	: Status to be cleared (or-ed bit value of  CCAN_STAT_*)
+ * @return	Nothing
+ */
+void Chip_CCAN_ClearStatus(LPC_CCAN_T *pCCAN, uint32_t val);
+
+/**
+ * @brief	Get the current value of the transmit/receive error counter
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	dir	: direction
+ * @return	Current value of the transmit/receive error counter
+ * @note	When @a dir is #CCAN_RX_DIR, then MSB (bit-7) indicates the
+ * receiver error passive level, if the bit is High(1) then the reciever
+ * counter has reached error passive level as specified in CAN2.0
+ * specification; else if the bit is Low(0) it indicates that the
+ * error counter is below the passive level. Bits from (bit6-0) has
+ * the actual error count. When @a dir is #CCAN_TX_DIR, the complete
+ * 8-bits indicates the number of tx errors.
+ */
+STATIC INLINE uint8_t Chip_CCAN_GetErrCounter(LPC_CCAN_T *pCCAN, CCAN_TRANSFER_DIR_T dir)
+{
+	return (dir == CCAN_TX_DIR) ? (pCCAN->EC & 0x0FF) : ((pCCAN->EC >> 8) & 0x0FF);
+}
+
+/**
+ * @brief	Enable test mode in CCAN
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_EnableTestMode(LPC_CCAN_T *pCCAN)
+{
+	pCCAN->CNTL |= CCAN_CTRL_TEST;
+}
+
+/**
+ * @brief	Enable test mode in CCAN
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_DisableTestMode(LPC_CCAN_T *pCCAN)
+{
+	pCCAN->CNTL &= ~CCAN_CTRL_TEST;
+}
+
+/**
+ * @brief	Enable/Disable test mode in CCAN
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	cfg	: Test function, or-ed bit values of CCAN_TEST_*
+ * @return	Nothing
+ * @note	Test Mode must be enabled before using Chip_CCAN_EnableTestMode function.
+ */
+STATIC INLINE void Chip_CCAN_ConfigTestMode(LPC_CCAN_T *pCCAN, uint32_t cfg)
+{
+	pCCAN->TEST = cfg;
+}
+
+/**
+ * @brief	Enable automatic retransmission
+ * @param	pCCAN			: The base of CCAN peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_EnableAutoRetransmit(LPC_CCAN_T *pCCAN)
+{
+	pCCAN->CNTL &= ~CCAN_CTRL_DAR;
+}
+
+/**
+ * @brief	Disable automatic retransmission
+ * @param	pCCAN			: The base of CCAN peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_DisableAutoRetransmit(LPC_CCAN_T *pCCAN)
+{
+	pCCAN->CNTL |= CCAN_CTRL_DAR;
+}
+
+/**
+ * @brief	Get the transmit repuest bit in all message objects
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @return	A 32 bits value, each bit corresponds to transmit request bit in message objects
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetTxRQST(LPC_CCAN_T *pCCAN)
+{
+	return pCCAN->TXREQ1 | (pCCAN->TXREQ2 << 16);
+}
+
+/**
+ * @brief	Initialize the CCAN peripheral, free all message object in RAM
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_CCAN_Init(LPC_CCAN_T *pCCAN);
+
+/**
+ * @brief	De-initialize the CCAN peripheral
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_CCAN_DeInit(LPC_CCAN_T *pCCAN);
+
+/**
+ * @brief	Select bit rate for CCAN bus
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	bitRate	: Bit rate to be set
+ * @return	SUCCESS/ERROR
+ */
+Status Chip_CCAN_SetBitRate(LPC_CCAN_T *pCCAN, uint32_t bitRate);
+
+/** Number of message objects in Message RAM */
+#define CCAN_MSG_MAX_NUM                              32
+
+/**
+ * @brief CAN message object structure
+ */
+typedef struct {
+	uint32_t    id;		/**< ID of message, if bit 30 is set then this is extended frame */
+	uint32_t    dlc;	/**< Message data length */
+	uint8_t     data[8];	/**< Message data */
+} CCAN_MSG_OBJ_T;
+
+typedef enum {
+	CCAN_MSG_IF1 = 0,
+	CCAN_MSG_IF2 = 1,
+} CCAN_MSG_IF_T;
+
+/* bit field of IF command request n register */
+#define CCAN_IF_CMDREQ_MSG_NUM(n)  (n)			/* Message number (1->20) */
+#define CCAN_IF_CMDREQ_BUSY          0x8000			/* 1 is writing is progress, cleared when RD/WR done */
+
+/* bit field of IF command mask register */
+#define CCAN_IF_CMDMSK_DATAB        (1 << 0)		/** 1 is transfer data byte 4-7 to message object, 0 is not */
+#define CCAN_IF_CMDMSK_DATAA        (1 << 1)		/** 1 is transfer data byte 0-3 to message object, 0 is not */
+#define CCAN_IF_CMDMSK_W_TXRQST     (1 << 2)		/** Request a transmission. Set the TXRQST bit IF1/2_MCTRL. */
+#define CCAN_IF_CMDMSK_R_NEWDAT     (1 << 2)		/** Clear NEWDAT bit in the message object */
+#define CCAN_IF_CMDMSK_R_CLRINTPND  (1 << 3)		/** Clear INTPND bit in the message object. */
+#define CCAN_IF_CMDMSK_CTRL         (1 << 4)		/** 1 is transfer the CTRL bit to the message object, 0 is not */
+#define CCAN_IF_CMDMSK_ARB          (1 << 5)		/** 1 is transfer the ARB bits to the message object, 0 is not */
+#define CCAN_IF_CMDMSK_MASK         (1 << 6)		/** 1 is transfer the MASK bit to the message object, 0 is not */
+#define CCAN_IF_CMDMSK_WR           (1 << 7)		/*  Tranfer direction: Write */
+#define CCAN_IF_CMDMSK_RD           (0)				/*  Tranfer direction: Read */
+#define CCAN_IF_CMDMSK_TRANSFER_ALL (CCAN_IF_CMDMSK_CTRL | CCAN_IF_CMDMSK_MASK | CCAN_IF_CMDMSK_ARB | \
+									 CCAN_IF_CMDMSK_DATAB | CCAN_IF_CMDMSK_DATAA)
+
+/* bit field of IF mask 2 register */
+#define CCAN_IF_MASK2_MXTD          (1 << 15)				/* 1 is extended identifier bit is used in the RX filter unit, 0 is not */
+#define CCAN_IF_MASK2_MDIR(n)       (((n) & 0x01) <<  14)	/* 1 is direction bit is used in the RX filter unit, 0 is not */
+
+/* bit field of IF arbitration 2 register */
+#define CCAN_IF_ARB2_DIR(n)         (((n) & 0x01) << 13)	/* 1: Dir = transmit, 0: Dir = receive */
+#define CCAN_IF_ARB2_XTD            (1 << 14)		/* Extended identifier bit is used*/
+#define CCAN_IF_ARB2_MSGVAL         (1 << 15)		/* Message valid bit, 1 is valid in the MO handler, 0 is ignored */
+
+/* bit field of IF message control register */
+#define CCAN_IF_MCTRL_DLC_MSK        0x000F			/* bit mask for DLC */
+#define CCAN_IF_MCTRL_EOB           (1 << 7)		/* End of buffer, always write to 1 */
+#define CCAN_IF_MCTRL_TXRQ          (1 << 8)		/* 1 is TxRqst enabled */
+#define CCAN_IF_MCTRL_RMTEN(n)      (((n) & 1UL) << 9)	/* 1 is remote frame enabled */
+#define CCAN_IF_MCTRL_RXIE          (1 << 10)		/* 1 is RX interrupt enabled */
+#define CCAN_IF_MCTRL_TXIE          (1 << 11)		/* 1 is TX interrupt enabled */
+#define CCAN_IF_MCTRL_UMSK          (1 << 12)		/* 1 is to use the mask for the receive filter mask. */
+#define CCAN_IF_MCTRL_INTP          (1 << 13)		/* 1 indicates message object is an interrupt source */
+#define CCAN_IF_MCTRL_MLST          (1 << 14)		/* 1 indicates a message loss. */
+#define CCAN_IF_MCTRL_NEWD          (1 << 15)		/* 1 indicates new data is in the message buffer.  */
+
+#define CCAN_MSG_ID_STD_MASK        0x07FF
+#define CCAN_MSG_ID_EXT_MASK        0x1FFFFFFF
+
+/**
+ * @brief	Tranfer message object between IF registers and Message RAM
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	IFSel		: The Message interface to be used
+ * @param	mask	: command mask (or-ed bit value of CCAN_IF_CMDMSK_*)
+ * @param	msgNum		: The number of message object in message RAM to be get
+ * @return	Nothing
+ */
+void Chip_CCAN_TransferMsgObject(LPC_CCAN_T *pCCAN,
+								 CCAN_MSG_IF_T IFSel,
+								 uint32_t mask,
+								 uint32_t msgNum);
+
+/**
+ * @brief	Set a message into the message object in message RAM
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	IFSel		: The Message interface to be used
+ * @param	dir	: transmit/receive
+ * @param	remoteFrame: Enable/Disable passives transmit by using remote frame
+ * @param	msgNum		: Message number
+ * @param	pMsgObj		: Pointer of message to be set
+ * @return	Nothing
+ */
+void Chip_CCAN_SetMsgObject (LPC_CCAN_T *pCCAN,
+							 CCAN_MSG_IF_T IFSel,
+							 CCAN_TRANSFER_DIR_T dir,
+							 bool remoteFrame,
+							 uint8_t msgNum,
+							 const CCAN_MSG_OBJ_T *pMsgObj);
+
+/**
+ * @brief	Get a message object in message RAM into the message buffer
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	IFSel	: The Message interface to be used
+ * @param	msgNum		: The number of message object in message RAM to be get
+ * @param	pMsgObj		: Pointer of the message buffer
+ * @return	Nothing
+ */
+void Chip_CCAN_GetMsgObject(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, CCAN_MSG_OBJ_T *pMsgObj);
+
+/**
+ * @brief	Enable/Disable the message object to valid
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	IFSel	: The Message interface to be used
+ * @param	msgNum	: Message number
+ * @param	valid	: true: valid, false: invalide
+ * @return	Nothing
+ */
+void Chip_CCAN_SetValidMsg(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, bool valid);
+
+/**
+ * @brief	Check the message objects is valid or not
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @return	A 32 bits value, each bit corresponds to a message objects form 0 to 31 (1 is valid, 0 is invalid)
+ */
+STATIC INLINE uint32_t Chip_CCAN_GetValidMsg(LPC_CCAN_T *pCCAN)
+{
+	return pCCAN->MSGV1 | (pCCAN->MSGV2 << 16);
+}
+
+/**
+ * @brief	Clear the pending message interrupt
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	IFSel	: The Message interface to be used
+ * @param	msgNum	: Message number
+ * @param	dir	: Select transmit or receive interrupt to be cleared
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_ClearMsgIntPend(LPC_CCAN_T *pCCAN,
+											 CCAN_MSG_IF_T IFSel,
+											 uint8_t msgNum,
+											 CCAN_TRANSFER_DIR_T dir)
+{
+	Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_RD | CCAN_IF_CMDMSK_R_CLRINTPND, msgNum);
+}
+
+/**
+ * @brief	Clear new data flag bit in the message object
+ * @param	pCCAN	: The base of CCAN peripheral on the chip
+ * @param	IFSel	: The Message interface to be used
+ * @param	msgNum	: Message number
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CCAN_ClearNewDataFlag(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum)
+{
+	Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_RD | CCAN_IF_CMDMSK_R_NEWDAT, msgNum);
+}
+
+/**
+ * @brief	Send a message
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	IFSel	: The Message interface to be used
+ * @param	remoteFrame: Enable/Disable passives transmit by using remote frame
+ * @param	pMsgObj		: Message to be transmitted
+ * @return	Nothing
+ */
+void Chip_CCAN_Send (LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, bool remoteFrame, CCAN_MSG_OBJ_T *pMsgObj);
+
+/**
+ * @brief	Register a message ID for receiving
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	IFSel	: The Message interface to be used
+ * @param	id		: Received message ID
+ * @return	Nothing
+ */
+void Chip_CCAN_AddReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id);
+
+/**
+ * @brief	Remove a registered message ID from receiving
+ * @param	IFSel	: The Message interface to be used
+ * @param	pCCAN		: The base of CCAN peripheral on the chip
+ * @param	id		: Received message ID to be removed
+ * @return	Nothing
+ */
+void Chip_CCAN_DeleteReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CCAN_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cguccu_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/cguccu_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cguccu_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/cguccu_18xx_43xx.h	2018-12-01 17:15:06.637606391 -0300
@@ -0,0 +1,120 @@
+/*
+ * @brief CGU/CCU registers and control functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CGUCCU_18XX_43XX_H_
+#define __CGUCCU_18XX_43XX_H_
+
+#include "chip_clocks.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup CLOCK_18XX_43XX
+ * @{
+ */
+
+/**
+ * Audio or USB PLL selection
+ */
+typedef enum CHIP_CGU_USB_AUDIO_PLL {
+	CGU_USB_PLL,
+	CGU_AUDIO_PLL
+} CHIP_CGU_USB_AUDIO_PLL_T;
+
+/**
+ * PLL register block
+ */
+typedef struct {
+	__I  uint32_t  PLL_STAT;				/*!< PLL status register */
+	__IO uint32_t  PLL_CTRL;				/*!< PLL control register */
+	__IO uint32_t  PLL_MDIV;				/*!< PLL M-divider register */
+	__IO uint32_t  PLL_NP_DIV;				/*!< PLL N/P-divider register */
+} CGU_PLL_REG_T;
+
+/**
+ * @brief LPC18XX/43XX CGU register block structure
+ */
+typedef struct {							/*!< (@ 0x40050000) CGU Structure          */
+	__I  uint32_t  RESERVED0[5];
+	__IO uint32_t  FREQ_MON;				/*!< (@ 0x40050014) Frequency monitor register */
+	__IO uint32_t  XTAL_OSC_CTRL;			/*!< (@ 0x40050018) Crystal oscillator control register */
+	CGU_PLL_REG_T  PLL[CGU_AUDIO_PLL + 1];	/*!< (@ 0x4005001C) USB and audio PLL blocks */
+	__IO uint32_t  PLL0AUDIO_FRAC;			/*!< (@ 0x4005003C) PLL0 (audio)           */
+	__I  uint32_t  PLL1_STAT;				/*!< (@ 0x40050040) PLL1 status register   */
+	__IO uint32_t  PLL1_CTRL;				/*!< (@ 0x40050044) PLL1 control register  */
+	__IO uint32_t  IDIV_CTRL[CLK_IDIV_LAST];/*!< (@ 0x40050048) Integer divider A-E control registers */
+	__IO uint32_t  BASE_CLK[CLK_BASE_LAST];	/*!< (@ 0x4005005C) Start of base clock registers */
+} LPC_CGU_T;
+
+/**
+ * @brief CCU clock config/status register pair
+ */
+typedef struct {
+	__IO uint32_t  CFG;						/*!< CCU clock configuration register */
+	__I  uint32_t  STAT;					/*!< CCU clock status register */
+} CCU_CFGSTAT_T;
+
+/**
+ * @brief CCU1 register block structure
+ */
+typedef struct {							/*!< (@ 0x40051000) CCU1 Structure         */
+	__IO uint32_t  PM;						/*!< (@ 0x40051000) CCU1 power mode register */
+	__I  uint32_t  BASE_STAT;				/*!< (@ 0x40051004) CCU1 base clocks status register */
+	__I  uint32_t  RESERVED0[62];
+	CCU_CFGSTAT_T  CLKCCU[CLK_CCU1_LAST];	/*!< (@ 0x40051100) Start of CCU1 clock registers */
+} LPC_CCU1_T;
+
+/**
+ * @brief CCU2 register block structure
+ */
+typedef struct {							/*!< (@ 0x40052000) CCU2 Structure         */
+	__IO uint32_t  PM;						/*!< (@ 0x40052000) Power mode register    */
+	__I  uint32_t  BASE_STAT;				/*!< (@ 0x40052004) CCU base clocks status register */
+	__I  uint32_t  RESERVED0[62];
+	CCU_CFGSTAT_T  CLKCCU[CLK_CCU2_LAST - CLK_CCU1_LAST];	/*!< (@ 0x40052100) Start of CCU2 clock registers */
+} LPC_CCU2_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CGUCCU_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip_clocks.h ./libs/vendor_libs/lpc_chip_43xx/inc/chip_clocks.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip_clocks.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/chip_clocks.h	2018-12-01 17:15:06.637606391 -0300
@@ -0,0 +1,258 @@
+/*
+ * @brief	LPC18xx/43xx chip clock list used by CGU and CCU drivers
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_CLOCKS_H_
+#define __CHIP_CLOCKS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup CLOCK_18XX_43XX
+ * @{
+ */
+
+/**
+ * @brief CGU clock input list
+ * These are possible input clocks for the CGU and can come
+ * from both external (crystal) and internal (PLL) sources. These
+ * clock inputs can be routed to the base clocks (@ref CHIP_CGU_BASE_CLK_T).
+ */
+typedef enum CHIP_CGU_CLKIN {
+	CLKIN_32K,		/*!< External 32KHz input */
+	CLKIN_IRC,		/*!< Internal IRC (12MHz) input */
+	CLKIN_ENET_RX,	/*!< External ENET_RX pin input */
+	CLKIN_ENET_TX,	/*!< External ENET_TX pin input */
+	CLKIN_CLKIN,	/*!< External GPCLKIN pin input */
+	CLKIN_RESERVED1,
+	CLKIN_CRYSTAL,	/*!< External (main) crystal pin input */
+	CLKIN_USBPLL,	/*!< Internal USB PLL input */
+	CLKIN_AUDIOPLL,	/*!< Internal Audio PLL input */
+	CLKIN_MAINPLL,	/*!< Internal Main PLL input */
+	CLKIN_RESERVED2,
+	CLKIN_RESERVED3,
+	CLKIN_IDIVA,	/*!< Internal divider A input */
+	CLKIN_IDIVB,	/*!< Internal divider B input */
+	CLKIN_IDIVC,	/*!< Internal divider C input */
+	CLKIN_IDIVD,	/*!< Internal divider D input */
+	CLKIN_IDIVE,	/*!< Internal divider E input */
+	CLKINPUT_PD		/*!< External 32KHz input */
+} CHIP_CGU_CLKIN_T;
+
+/**
+ * @brief CGU base clocks
+ * CGU base clocks are clocks that are associated with a single input clock
+ * and are routed out to 1 or more peripherals. For example, the CLK_BASE_PERIPH
+ * clock can be configured to use the CLKIN_MAINPLL input clock, which will in
+ * turn route that clock to the CLK_PERIPH_BUS, CLK_PERIPH_CORE, and
+ * CLK_PERIPH_SGPIO periphral clocks.
+ */
+typedef enum CHIP_CGU_BASE_CLK {
+	CLK_BASE_SAFE,		/*!< Base clock for WDT oscillator, IRC input only */
+	CLK_BASE_USB0,		/*!< Base USB clock for USB0, USB PLL input only */
+#if defined(CHIP_LPC43XX)
+	CLK_BASE_PERIPH,	/*!< Base clock for SGPIO */
+#else
+	CLK_BASE_RESERVED1,
+#endif
+	CLK_BASE_USB1,		/*!< Base USB clock for USB1 */
+	CLK_BASE_MX,		/*!< Base clock for CPU core */
+	CLK_BASE_SPIFI,		/*!< Base clock for SPIFI */
+#if defined(CHIP_LPC43XX)
+	CLK_BASE_SPI,		/*!< Base clock for SPI */
+#else
+	CLK_BASE_RESERVED2,
+#endif
+	CLK_BASE_PHY_RX,	/*!< Base clock for PHY RX */
+	CLK_BASE_PHY_TX,	/*!< Base clock for PHY TX */
+	CLK_BASE_APB1,		/*!< Base clock for APB1 group */
+	CLK_BASE_APB3,		/*!< Base clock for APB3 group */
+	CLK_BASE_LCD,		/*!< Base clock for LCD pixel clock */
+#if defined(CHIP_LPC43XX)
+	CLK_BASE_ADCHS,		/*!< Base clock for ADCHS */
+#else
+	CLK_BASE_RESERVED3,
+#endif
+	CLK_BASE_SDIO,		/*!< Base clock for SDIO */
+	CLK_BASE_SSP0,		/*!< Base clock for SSP0 */
+	CLK_BASE_SSP1,		/*!< Base clock for SSP1 */
+	CLK_BASE_UART0,		/*!< Base clock for UART0 */
+	CLK_BASE_UART1,		/*!< Base clock for UART1 */
+	CLK_BASE_UART2,		/*!< Base clock for UART2 */
+	CLK_BASE_UART3,		/*!< Base clock for UART3 */
+	CLK_BASE_OUT,		/*!< Base clock for CLKOUT pin */
+	CLK_BASE_RESERVED4,
+	CLK_BASE_RESERVED5,
+	CLK_BASE_RESERVED6,
+	CLK_BASE_RESERVED7,
+	CLK_BASE_APLL,		/*!< Base clock for audio PLL */
+	CLK_BASE_CGU_OUT0,	/*!< Base clock for CGUOUT0 pin */
+	CLK_BASE_CGU_OUT1,	/*!< Base clock for CGUOUT1 pin */
+	CLK_BASE_LAST,
+	CLK_BASE_NONE = CLK_BASE_LAST
+} CHIP_CGU_BASE_CLK_T;
+
+/**
+ * @brief CGU dividers
+ * CGU dividers provide an extra clock state where a specific clock can be
+ * divided before being routed to a peripheral group. A divider accepts an
+ * input clock and then divides it. To use the divided clock for a base clock
+ * group, use the divider as the input clock for the base clock (for example,
+ * use CLKIN_IDIVB, where CLKIN_MAINPLL might be the input into the divider).
+ */
+typedef enum CHIP_CGU_IDIV {
+	CLK_IDIV_A,		/*!< CGU clock divider A */
+	CLK_IDIV_B,		/*!< CGU clock divider B */
+	CLK_IDIV_C,		/*!< CGU clock divider A */
+	CLK_IDIV_D,		/*!< CGU clock divider D */
+	CLK_IDIV_E,		/*!< CGU clock divider E */
+	CLK_IDIV_LAST
+} CHIP_CGU_IDIV_T;
+
+#define CHIP_CGU_IDIV_MASK(x)  ("\x03\x0F\x0F\x0F\xFF"[x])
+
+/**
+ * @brief Peripheral clocks
+ * Peripheral clocks are individual clocks routed to peripherals. Although
+ * multiple peripherals may share a same base clock, each peripheral's clock
+ * can be enabled or disabled individually. Some peripheral clocks also have
+ * additional dividers associated with them.
+ */
+typedef enum CHIP_CCU_CLK {
+	/* CCU1 clocks */
+	CLK_APB3_BUS,		/*!< APB3 bus clock from base clock CLK_BASE_APB3 */
+	CLK_APB3_I2C1,		/*!< I2C1 register/perigheral clock from base clock CLK_BASE_APB3 */
+	CLK_APB3_DAC,		/*!< DAC peripheral clock from base clock CLK_BASE_APB3 */
+	CLK_APB3_ADC0,		/*!< ADC0 register/perigheral clock from base clock CLK_BASE_APB3 */
+	CLK_APB3_ADC1,		/*!< ADC1 register/perigheral clock from base clock CLK_BASE_APB3 */
+	CLK_APB3_CAN0,		/*!< CAN0 register/perigheral clock from base clock CLK_BASE_APB3 */
+	CLK_APB1_BUS = 32,	/*!< APB1 bus clock clock from base clock CLK_BASE_APB1 */
+	CLK_APB1_MOTOCON,	/*!< Motor controller register/perigheral clock from base clock CLK_BASE_APB1 */
+	CLK_APB1_I2C0,		/*!< I2C0 register/perigheral clock from base clock CLK_BASE_APB1 */
+	CLK_APB1_I2S,		/*!< I2S register/perigheral clock from base clock CLK_BASE_APB1 */
+	CLK_APB1_CAN1,		/*!< CAN1 register/perigheral clock from base clock CLK_BASE_APB1 */
+	CLK_SPIFI = 64,		/*!< SPIFI SCKI input clock from base clock CLK_BASE_SPIFI */
+	CLK_MX_BUS = 96,	/*!< M3/M4 BUS core clock from base clock CLK_BASE_MX */
+	CLK_MX_SPIFI,		/*!< SPIFI register clock from base clock CLK_BASE_MX */
+	CLK_MX_GPIO,		/*!< GPIO register clock from base clock CLK_BASE_MX */
+	CLK_MX_LCD,			/*!< LCD register clock from base clock CLK_BASE_MX */
+	CLK_MX_ETHERNET,	/*!< ETHERNET register clock from base clock CLK_BASE_MX */
+	CLK_MX_USB0,		/*!< USB0 register clock from base clock CLK_BASE_MX */
+	CLK_MX_EMC,			/*!< EMC clock from base clock CLK_BASE_MX */
+	CLK_MX_SDIO,		/*!< SDIO register clock from base clock CLK_BASE_MX */
+	CLK_MX_DMA,			/*!< DMA register clock from base clock CLK_BASE_MX */
+	CLK_MX_MXCORE,		/*!< M3/M4 CPU core clock from base clock CLK_BASE_MX */
+	RESERVED_ALIGN = CLK_MX_MXCORE + 3,
+	CLK_MX_SCT,			/*!< SCT register clock from base clock CLK_BASE_MX */
+	CLK_MX_USB1,		/*!< USB1 register clock from base clock CLK_BASE_MX */
+	CLK_MX_EMC_DIV,		/*!< ENC divider clock from base clock CLK_BASE_MX */
+	CLK_MX_FLASHA,		/*!< FLASHA bank clock from base clock CLK_BASE_MX */
+	CLK_MX_FLASHB,		/*!< FLASHB bank clock from base clock CLK_BASE_MX */
+#if defined(CHIP_LPC43XX)
+	CLK_M4_M0APP,		/*!< M0 app CPU core clock from base clock CLK_BASE_MX */
+	CLK_MX_ADCHS,		/*!< ADCHS clock from base clock CLK_BASE_ADCHS */
+#else
+	CLK_RESERVED1,
+	CLK_RESERVED2,
+#endif
+	CLK_MX_EEPROM,		/*!< EEPROM clock from base clock CLK_BASE_MX */
+	CLK_MX_WWDT = 128,	/*!< WWDT register clock from base clock CLK_BASE_MX */
+	CLK_MX_UART0,		/*!< UART0 register clock from base clock CLK_BASE_MX */
+	CLK_MX_UART1,		/*!< UART1 register clock from base clock CLK_BASE_MX */
+	CLK_MX_SSP0,		/*!< SSP0 register clock from base clock CLK_BASE_MX */
+	CLK_MX_TIMER0,		/*!< TIMER0 register/perigheral clock from base clock CLK_BASE_MX */
+	CLK_MX_TIMER1,		/*!< TIMER1 register/perigheral clock from base clock CLK_BASE_MX */
+	CLK_MX_SCU,			/*!< SCU register/perigheral clock from base clock CLK_BASE_MX */
+	CLK_MX_CREG,		/*!< CREG clock from base clock CLK_BASE_MX */
+	CLK_MX_RITIMER = 160,	/*!< RITIMER register/perigheral clock from base clock CLK_BASE_MX */
+	CLK_MX_UART2,		/*!< UART3 register clock from base clock CLK_BASE_MX */
+	CLK_MX_UART3,		/*!< UART4 register clock from base clock CLK_BASE_MX */
+	CLK_MX_TIMER2,		/*!< TIMER2 register/perigheral clock from base clock CLK_BASE_MX */
+	CLK_MX_TIMER3,		/*!< TIMER3 register/perigheral clock from base clock CLK_BASE_MX */
+	CLK_MX_SSP1,		/*!< SSP1 register clock from base clock CLK_BASE_MX */
+	CLK_MX_QEI,			/*!< QEI register/perigheral clock from base clock CLK_BASE_MX */
+#if defined(CHIP_LPC43XX)
+	CLK_PERIPH_BUS = 192,	/*!< Peripheral bus clock from base clock CLK_BASE_PERIPH */
+	CLK_RESERVED3,
+	CLK_PERIPH_CORE,	/*!< Peripheral core clock from base clock CLK_BASE_PERIPH */
+	CLK_PERIPH_SGPIO,	/*!< SGPIO clock from base clock CLK_BASE_PERIPH */
+#else
+	CLK_RESERVED3 = 192,
+	CLK_RESERVED3A,
+	CLK_RESERVED4,
+	CLK_RESERVED5,
+#endif
+	CLK_USB0 = 224,			/*!< USB0 clock from base clock CLK_BASE_USB0 */
+	CLK_USB1 = 256,			/*!< USB1 clock from base clock CLK_BASE_USB1 */
+#if defined(CHIP_LPC43XX)
+	CLK_SPI = 288,			/*!< SPI clock from base clock CLK_BASE_SPI */
+	CLK_ADCHS = 320,		/*!< ADCHS clock from base clock CLK_BASE_ADCHS */
+#else
+	CLK_RESERVED7 = 320,
+	CLK_RESERVED8,
+#endif
+	CLK_CCU1_LAST,
+
+	/* CCU2 clocks */
+	CLK_CCU2_START,
+	CLK_APLL = CLK_CCU2_START,	/*!< Audio PLL clock from base clock CLK_BASE_APLL */
+	RESERVED_ALIGNB = CLK_CCU2_START + 31,
+	CLK_APB2_UART3,			/*!< UART3 clock from base clock CLK_BASE_UART3 */
+	RESERVED_ALIGNC = CLK_CCU2_START + 63,
+	CLK_APB2_UART2,			/*!< UART2 clock from base clock CLK_BASE_UART2 */
+	RESERVED_ALIGND = CLK_CCU2_START + 95,
+	CLK_APB0_UART1,			/*!< UART1 clock from base clock CLK_BASE_UART1 */
+	RESERVED_ALIGNE = CLK_CCU2_START + 127,
+	CLK_APB0_UART0,			/*!< UART0 clock from base clock CLK_BASE_UART0 */
+	RESERVED_ALIGNF = CLK_CCU2_START + 159,
+	CLK_APB2_SSP1,			/*!< SSP1 clock from base clock CLK_BASE_SSP1 */
+	RESERVED_ALIGNG = CLK_CCU2_START + 191,
+	CLK_APB0_SSP0,			/*!< SSP0 clock from base clock CLK_BASE_SSP0 */
+	RESERVED_ALIGNH = CLK_CCU2_START + 223,
+	CLK_APB2_SDIO,			/*!< SDIO clock from base clock CLK_BASE_SDIO */
+	CLK_CCU2_LAST
+} CHIP_CCU_CLK_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_CLOCKS_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip.h ./libs/vendor_libs/lpc_chip_43xx/inc/chip.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/chip.h	2018-12-01 17:15:06.637606391 -0300
@@ -0,0 +1,169 @@
+/*
+ * @brief Chip inclusion selector file
+ *
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_H_
+#define __CHIP_H_
+
+#include "sys_config.h"
+#include "cmsis.h"
+
+#if defined(CHIP_LPC18XX)
+#include "chip_lpc18xx.h"
+
+#elif defined(CHIP_LPC43XX)
+#include "chip_lpc43xx.h"
+
+#else
+#error CHIP_LPC18XX or CHIP_LPC43XX must be defined
+#endif
+
+/* Aliasing for Chip_USB_Init */
+#define Chip_USB_Init  Chip_USB0_Init
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/** @ingroup CHIP_18XX_43XX_DRIVER_OPTIONS
+ * @{
+ */
+
+/**
+ * @brief	System oscillator rate
+ * This value is defined externally to the chip layer and contains
+ * the value in Hz for the external oscillator for the board. If using the
+ * internal oscillator, this rate can be 0.
+ */
+extern const uint32_t OscRateIn;
+
+/**
+ * @brief	Clock rate on the CLKIN pin
+ * This value is defined externally to the chip layer and contains
+ * the value in Hz for the CLKIN pin for the board. If this pin isn't used,
+ * this rate can be 0.
+ */
+extern const uint32_t ExtRateIn;
+
+/**
+ * @}
+ */
+
+/** @defgroup SUPPORT_18XX_43XX_FUNC CHIP: LPC18xx/43xx support functions
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief	Current system clock rate, mainly used for sysTick
+ */
+extern uint32_t SystemCoreClock;
+
+/**
+ * @brief	Update system core clock rate, should be called if the
+ *			system has a clock rate change
+ * @return	None
+ */
+void SystemCoreClockUpdate(void);
+
+/**
+ * @brief USB0 Pin and clock initialization
+ * Calling this function will initialize the USB0 pins and the clock
+ * @note This function will assume that the chip is clocked by an
+ * external crystal oscillator of frequency 12MHz
+ */
+void Chip_USB0_Init(void);
+
+/**
+ * @brief USB1 Pin and clock initialization
+ * Calling this function will initialize the USB0 pins and the clock
+ * @note This function will assume that the chip is clocked by an
+ * external crystal oscillator of frequency 12MHz
+ */
+void Chip_USB1_Init(void);
+
+/**
+ * @brief	Set up and initialize hardware prior to call to main()
+ * @return	None
+ * @note	Chip_SystemInit() is called prior to the application and sets up
+ * system clocking prior to the application starting.
+ */
+void Chip_SystemInit(void);
+
+/**
+ * @brief	Clock and PLL initialization based input given in @a clkin
+ * @param	clkin		: Input reference clock to PLL1 (MAINPLL) see #CHIP_CGU_CLKIN_T
+ * @param	core_freq	: Desired output frequency of the PLL1 (Base clock to CPU Core)
+ * @param	setbase		: Setup default base clock of peripherals (see notes)
+ * @return	None
+ * @note	This API will initialize the MAINPLL (PLL1) to the frequency given by
+ * 			@a core_freq, and will use this	PLL's output as the base clock for CPU
+ * 			Core. If @a clkin is #CLKIN_CRYSTAL then External Crystal Oscillator
+ * 			of frequency 12MHz will be used as the input reference clock to PLL1.<br>
+ * 			Parameter @a setbase if true will set APB[1,3], SSP[0,1], UART[0,1,2,3],
+ * 			SPI base clocks to MAINPLL's output clock. If @a setbase is false then
+ * 			the base clock settings for the peripherals will not be modified, only
+ * 			CPU Core's base clock will be updated to use clock generated by PLL1.
+ */
+void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase);
+
+/**
+ * @brief	Clock and PLL initialization based on the external oscillator
+ * @return	None
+ * @note	This API will initialize the MAINPLL (PLL1) to the maximum
+ * 			frequency (180MHz[LPC18xx] or 204MHz[LPC43xx]) and uses this
+ * 			PLL's output as the base clock for CPU Core. External Crystal Oscillator
+ * 			of frequency 12MHz will be used as the input reference clock to PLL1.
+ */
+void Chip_SetupXtalClocking(void);
+
+/**
+ * @brief	Clock and PLL initialization based on the internal oscillator
+ * @return	None
+ * @note	This API will initialize the MAINPLL (PLL1) to the maximum
+ * 			frequency (180MHz[LPC18xx] or 204MHz[LPC43xx]) and uses this
+ * 			PLL's output as the base clock for CPU Core. Internal RC Oscillator
+ * 			will be used as the input reference clock to PLL1.
+ */
+void Chip_SetupIrcClocking(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc18xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc18xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc18xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc18xx.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,218 @@
+/*
+ * @brief LPC18xx basic chip inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_LPC18XX_H_
+#define __CHIP_LPC18XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lpc_types.h"
+#include "sys_config.h"
+
+#ifndef CORE_M3
+#error CORE_M3 is not defined for the LPC18xx architecture
+#error CORE_M3 should be defined as part of your compiler define list
+#endif
+
+#ifndef CHIP_LPC18XX
+#error The LPC18XX Chip include path is used for this build, but
+#error CHIP_LPC18XX is not defined!
+#endif
+
+/** @defgroup PERIPH_18XX_BASE CHIP: LPC18xx Peripheral addresses and register set declarations
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define LPC_SCT_BASE              0x40000000
+#define LPC_GPDMA_BASE            0x40002000
+#define LPC_SPIFI_BASE            0x40003000
+#define LPC_SDMMC_BASE            0x40004000
+#define LPC_EMC_BASE              0x40005000
+#define LPC_USB0_BASE             0x40006000
+#define LPC_USB1_BASE             0x40007000
+#define LPC_LCD_BASE              0x40008000
+#define LPC_FMCA_BASE             0x4000C000
+#define LPC_FMCB_BASE             0x4000D000
+#define LPC_ETHERNET_BASE         0x40010000
+#define LPC_ATIMER_BASE           0x40040000
+#define LPC_REGFILE_BASE          0x40041000
+#define LPC_PMC_BASE              0x40042000
+#define LPC_CREG_BASE             0x40043000
+#define LPC_EVRT_BASE             0x40044000
+#define LPC_OTP_BASE              0x40045000
+#define LPC_RTC_BASE              0x40046000
+#define LPC_CGU_BASE              0x40050000
+#define LPC_CCU1_BASE             0x40051000
+#define LPC_CCU2_BASE             0x40052000
+#define LPC_RGU_BASE              0x40053000
+#define LPC_WWDT_BASE             0x40080000
+#define LPC_USART0_BASE           0x40081000
+#define LPC_USART2_BASE           0x400C1000
+#define LPC_USART3_BASE           0x400C2000
+#define LPC_UART1_BASE            0x40082000
+#define LPC_SSP0_BASE             0x40083000
+#define LPC_SSP1_BASE             0x400C5000
+#define LPC_TIMER0_BASE           0x40084000
+#define LPC_TIMER1_BASE           0x40085000
+#define LPC_TIMER2_BASE           0x400C3000
+#define LPC_TIMER3_BASE           0x400C4000
+#define LPC_SCU_BASE              0x40086000
+#define LPC_PIN_INT_BASE          0x40087000
+#define LPC_GPIO_GROUP_INT0_BASE  0x40088000
+#define LPC_GPIO_GROUP_INT1_BASE  0x40089000
+#define LPC_MCPWM_BASE            0x400A0000
+#define LPC_I2C0_BASE             0x400A1000
+#define LPC_I2C1_BASE             0x400E0000
+#define LPC_I2S0_BASE             0x400A2000
+#define LPC_I2S1_BASE             0x400A3000
+#define LPC_C_CAN1_BASE           0x400A4000
+#define LPC_RITIMER_BASE          0x400C0000
+#define LPC_QEI_BASE              0x400C6000
+#define LPC_GIMA_BASE             0x400C7000
+#define LPC_DAC_BASE              0x400E1000
+#define LPC_C_CAN0_BASE           0x400E2000
+#define LPC_ADC0_BASE             0x400E3000
+#define LPC_ADC1_BASE             0x400E4000
+#define LPC_GPIO_PORT_BASE        0x400F4000
+#define LPC_SPI_BASE              0x40100000
+#define LPC_SGPIO_BASE            0x40101000
+#define LPC_EEPROM_BASE           0x4000E000
+#define LPC_ROM_API_BASE          0x10400100
+
+#define LPC_SCT                   ((LPC_SCT_T              *) LPC_SCT_BASE)
+#define LPC_GPDMA                 ((LPC_GPDMA_T            *) LPC_GPDMA_BASE)
+#define LPC_SPIFI                 ((LPC_SPIFI_T            *) LPC_SPIFI_BASE)
+#define LPC_SDMMC                 ((LPC_SDMMC_T            *) LPC_SDMMC_BASE)
+#define LPC_EMC                   ((LPC_EMC_T              *) LPC_EMC_BASE)
+#define LPC_USB0                  ((LPC_USBHS_T            *) LPC_USB0_BASE)
+#define LPC_USB1                  ((LPC_USBHS_T            *) LPC_USB1_BASE)
+#define LPC_LCD                   ((LPC_LCD_T              *) LPC_LCD_BASE)
+#define LPC_ETHERNET              ((LPC_ENET_T             *) LPC_ETHERNET_BASE)
+#define LPC_ATIMER                ((LPC_ATIMER_T           *) LPC_ATIMER_BASE)
+#define LPC_REGFILE               ((LPC_REGFILE_T          *) LPC_REGFILE_BASE)
+#define LPC_PMC                   ((LPC_PMC_T              *) LPC_PMC_BASE)
+#define LPC_EVRT                  ((LPC_EVRT_T             *) LPC_EVRT_BASE)
+#define LPC_RTC                   ((LPC_RTC_T              *) LPC_RTC_BASE)
+#define LPC_CGU                   ((LPC_CGU_T              *) LPC_CGU_BASE)
+#define LPC_CCU1                  ((LPC_CCU1_T             *) LPC_CCU1_BASE)
+#define LPC_CCU2                  ((LPC_CCU2_T             *) LPC_CCU2_BASE)
+#define LPC_CREG                  ((LPC_CREG_T             *) LPC_CREG_BASE)
+#define LPC_RGU                   ((LPC_RGU_T              *) LPC_RGU_BASE)
+#define LPC_WWDT                  ((LPC_WWDT_T             *) LPC_WWDT_BASE)
+#define LPC_USART0                ((LPC_USART_T            *) LPC_USART0_BASE)
+#define LPC_USART2                ((LPC_USART_T            *) LPC_USART2_BASE)
+#define LPC_USART3                ((LPC_USART_T            *) LPC_USART3_BASE)
+#define LPC_UART1                 ((LPC_USART_T            *) LPC_UART1_BASE)
+#define LPC_SSP0                  ((LPC_SSP_T              *) LPC_SSP0_BASE)
+#define LPC_SSP1                  ((LPC_SSP_T              *) LPC_SSP1_BASE)
+#define LPC_TIMER0                ((LPC_TIMER_T            *) LPC_TIMER0_BASE)
+#define LPC_TIMER1                ((LPC_TIMER_T            *) LPC_TIMER1_BASE)
+#define LPC_TIMER2                ((LPC_TIMER_T            *) LPC_TIMER2_BASE)
+#define LPC_TIMER3                ((LPC_TIMER_T            *) LPC_TIMER3_BASE)
+#define LPC_SCU                   ((LPC_SCU_T              *) LPC_SCU_BASE)
+#define LPC_GPIO_PIN_INT          ((LPC_PIN_INT_T          *) LPC_PIN_INT_BASE)
+#define LPC_GPIOGROUP             ((LPC_GPIOGROUPINT_T     *) LPC_GPIO_GROUP_INT0_BASE)
+#define LPC_MCPWM                 ((LPC_MCPWM_T            *) LPC_MCPWM_BASE)
+#define LPC_I2C0                  ((LPC_I2C_T              *) LPC_I2C0_BASE)
+#define LPC_I2C1                  ((LPC_I2C_T              *) LPC_I2C1_BASE)
+#define LPC_I2S0                  ((LPC_I2S_T              *) LPC_I2S0_BASE)
+#define LPC_I2S1                  ((LPC_I2S_T              *) LPC_I2S1_BASE)
+#define LPC_C_CAN1                ((LPC_CCAN_T             *) LPC_C_CAN1_BASE)
+#define LPC_RITIMER               ((LPC_RITIMER_T          *) LPC_RITIMER_BASE)
+#define LPC_QEI                   ((LPC_QEI_T              *) LPC_QEI_BASE)
+#define LPC_GIMA                  ((LPC_GIMA_T             *) LPC_GIMA_BASE)
+#define LPC_DAC                   ((LPC_DAC_T              *) LPC_DAC_BASE)
+#define LPC_C_CAN0                ((LPC_CCAN_T             *) LPC_C_CAN0_BASE)
+#define LPC_ADC0                  ((LPC_ADC_T              *) LPC_ADC0_BASE)
+#define LPC_ADC1                  ((LPC_ADC_T              *) LPC_ADC1_BASE)
+#define LPC_GPIO_PORT             ((LPC_GPIO_T             *) LPC_GPIO_PORT_BASE)
+#define LPC_EEPROM                ((LPC_EEPROM_T           *) LPC_EEPROM_BASE)
+#define LPC_FMCA                  ((LPC_FMC_T              *) LPC_FMCA_BASE)
+#define LPC_FMCB                  ((LPC_FMC_T              *) LPC_FMCB_BASE)
+#define LPC_ROM_API               ((LPC_ROM_API_T          *) LPC_ROM_API_BASE)
+
+/**
+ * @}
+ */
+
+#include "scu_18xx_43xx.h"
+#include "clock_18xx_43xx.h"
+#include "rgu_18xx_43xx.h"
+#include "creg_18xx_43xx.h"
+#include "evrt_18xx_43xx.h"
+#include "otp_18xx_43xx.h"
+#include "sdif_18xx_43xx.h"
+#include "adc_18xx_43xx.h"
+#include "atimer_18xx_43xx.h"
+#include "aes_18xx_43xx.h"
+#include "ccan_18xx_43xx.h"
+#include "dac_18xx_43xx.h"
+#include "eeprom_18xx_43xx.h"
+#include "emc_18xx_43xx.h"
+#include "enet_18xx_43xx.h"
+#include "fmc_18xx_43xx.h"
+#include "i2c_18xx_43xx.h"
+#include "i2s_18xx_43xx.h"
+#include "gima_18xx_43xx.h"
+#include "gpdma_18xx_43xx.h"
+#include "gpio_18xx_43xx.h"
+#include "pinint_18xx_43xx.h"
+#include "gpiogroup_18xx_43xx.h"
+#include "lcd_18xx_43xx.h"
+#include "mcpwm_18xx_43xx.h"
+#include "pmc_18xx_43xx.h"
+#include "qei_18xx_43xx.h"
+#include "ritimer_18xx_43xx.h"
+#include "rtc_18xx_43xx.h"
+#include "sct_18xx_43xx.h"
+#include "sct_pwm_18xx_43xx.h"
+#include "sdmmc_18xx_43xx.h"
+#include "sdio_18xx_43xx.h"
+#include "spifi_18xx_43xx.h"
+#include "ssp_18xx_43xx.h"
+#include "timer_18xx_43xx.h"
+#include "uart_18xx_43xx.h"
+#include "usbhs_18xx_43xx.h"
+#include "wwdt_18xx_43xx.h"
+#include "romapi_18xx_43xx.h"
+#include "i2cm_18xx_43xx.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_LPC18XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/chip_lpc43xx.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,229 @@
+/*
+ * @brief LPC43xx basic chip inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_LPC43XX_H_
+#define __CHIP_LPC43XX_H_
+
+#include "lpc_types.h"
+#include "sys_config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(CORE_M4) && !defined(CORE_M0)
+#error CORE_M4 or CORE_M0 is not defined for the LPC43xx architecture
+#error CORE_M4 or CORE_M0 should be defined as part of your compiler define list
+#endif
+
+#ifndef CHIP_LPC43XX
+#error The LPC43XX Chip include path is used for this build, but
+#error CHIP_LPC43XX is not defined!
+#endif
+
+/** @defgroup PERIPH_43XX_BASE CHIP: LPC43xx Peripheral addresses and register set declarations
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define LPC_SCT_BASE              0x40000000
+#define LPC_GPDMA_BASE            0x40002000
+#define LPC_SPIFI_BASE            0x40003000
+#define LPC_SDMMC_BASE            0x40004000
+#define LPC_EMC_BASE              0x40005000
+#define LPC_USB0_BASE             0x40006000
+#define LPC_USB1_BASE             0x40007000
+#define LPC_LCD_BASE              0x40008000
+#define LPC_FMCA_BASE             0x4000C000
+#define LPC_FMCB_BASE             0x4000D000
+#define LPC_ETHERNET_BASE         0x40010000
+#define LPC_ATIMER_BASE           0x40040000
+#define LPC_REGFILE_BASE          0x40041000
+#define LPC_PMC_BASE              0x40042000
+#define LPC_CREG_BASE             0x40043000
+#define LPC_EVRT_BASE             0x40044000
+#define LPC_OTP_BASE              0x40045000
+#define LPC_RTC_BASE              0x40046000
+#define LPC_CGU_BASE              0x40050000
+#define LPC_CCU1_BASE             0x40051000
+#define LPC_CCU2_BASE             0x40052000
+#define LPC_RGU_BASE              0x40053000
+#define LPC_WWDT_BASE             0x40080000
+#define LPC_USART0_BASE           0x40081000
+#define LPC_USART2_BASE           0x400C1000
+#define LPC_USART3_BASE           0x400C2000
+#define LPC_UART1_BASE            0x40082000
+#define LPC_SSP0_BASE             0x40083000
+#define LPC_SSP1_BASE             0x400C5000
+#define LPC_TIMER0_BASE           0x40084000
+#define LPC_TIMER1_BASE           0x40085000
+#define LPC_TIMER2_BASE           0x400C3000
+#define LPC_TIMER3_BASE           0x400C4000
+#define LPC_SCU_BASE              0x40086000
+#define LPC_PIN_INT_BASE          0x40087000
+#define LPC_GPIO_GROUP_INT0_BASE  0x40088000
+#define LPC_GPIO_GROUP_INT1_BASE  0x40089000
+#define LPC_MCPWM_BASE            0x400A0000
+#define LPC_I2C0_BASE             0x400A1000
+#define LPC_I2C1_BASE             0x400E0000
+#define LPC_I2S0_BASE             0x400A2000
+#define LPC_I2S1_BASE             0x400A3000
+#define LPC_C_CAN1_BASE           0x400A4000
+#define LPC_RITIMER_BASE          0x400C0000
+#define LPC_QEI_BASE              0x400C6000
+#define LPC_GIMA_BASE             0x400C7000
+#define LPC_DAC_BASE              0x400E1000
+#define LPC_C_CAN0_BASE           0x400E2000
+#define LPC_ADC0_BASE             0x400E3000
+#define LPC_ADC1_BASE             0x400E4000
+#define LPC_ADCHS_BASE            0x400F0000
+#define LPC_GPIO_PORT_BASE        0x400F4000
+#define LPC_SPI_BASE              0x40100000
+#define LPC_SGPIO_BASE            0x40101000
+#define LPC_EEPROM_BASE           0x4000E000
+#define LPC_ROM_API_BASE          0x10400100
+
+#define LPC_SCT                   ((LPC_SCT_T              *) LPC_SCT_BASE)
+#define LPC_GPDMA                 ((LPC_GPDMA_T            *) LPC_GPDMA_BASE)
+#define LPC_SPIFI                 ((LPC_SPIFI_T            *) LPC_SPIFI_BASE)
+#define LPC_SDMMC                 ((LPC_SDMMC_T            *) LPC_SDMMC_BASE)
+#define LPC_EMC                   ((LPC_EMC_T              *) LPC_EMC_BASE)
+#define LPC_USB0                  ((LPC_USBHS_T            *) LPC_USB0_BASE)
+#define LPC_USB1                  ((LPC_USBHS_T            *) LPC_USB1_BASE)
+#define LPC_LCD                   ((LPC_LCD_T              *) LPC_LCD_BASE)
+#define LPC_ETHERNET              ((LPC_ENET_T             *) LPC_ETHERNET_BASE)
+#define LPC_ATIMER                ((LPC_ATIMER_T           *) LPC_ATIMER_BASE)
+#define LPC_REGFILE               ((LPC_REGFILE_T          *) LPC_REGFILE_BASE)
+#define LPC_PMC                   ((LPC_PMC_T              *) LPC_PMC_BASE)
+#define LPC_EVRT                  ((LPC_EVRT_T             *) LPC_EVRT_BASE)
+#define LPC_RTC                   ((LPC_RTC_T              *) LPC_RTC_BASE)
+#define LPC_CGU                   ((LPC_CGU_T              *) LPC_CGU_BASE)
+#define LPC_CCU1                  ((LPC_CCU1_T             *) LPC_CCU1_BASE)
+#define LPC_CCU2                  ((LPC_CCU2_T             *) LPC_CCU2_BASE)
+#define LPC_CREG                  ((LPC_CREG_T             *) LPC_CREG_BASE)
+#define LPC_RGU                   ((LPC_RGU_T              *) LPC_RGU_BASE)
+#define LPC_WWDT                  ((LPC_WWDT_T             *) LPC_WWDT_BASE)
+#define LPC_USART0                ((LPC_USART_T            *) LPC_USART0_BASE)
+#define LPC_USART2                ((LPC_USART_T            *) LPC_USART2_BASE)
+#define LPC_USART3                ((LPC_USART_T            *) LPC_USART3_BASE)
+#define LPC_UART1                 ((LPC_USART_T            *) LPC_UART1_BASE)
+#define LPC_SSP0                  ((LPC_SSP_T              *) LPC_SSP0_BASE)
+#define LPC_SSP1                  ((LPC_SSP_T              *) LPC_SSP1_BASE)
+#define LPC_TIMER0                ((LPC_TIMER_T            *) LPC_TIMER0_BASE)
+#define LPC_TIMER1                ((LPC_TIMER_T            *) LPC_TIMER1_BASE)
+#define LPC_TIMER2                ((LPC_TIMER_T            *) LPC_TIMER2_BASE)
+#define LPC_TIMER3                ((LPC_TIMER_T            *) LPC_TIMER3_BASE)
+#define LPC_SCU                   ((LPC_SCU_T              *) LPC_SCU_BASE)
+#define LPC_GPIO_PIN_INT          ((LPC_PIN_INT_T          *) LPC_PIN_INT_BASE)
+#define LPC_GPIOGROUP             ((LPC_GPIOGROUPINT_T     *) LPC_GPIO_GROUP_INT0_BASE)
+#define LPC_MCPWM                 ((LPC_MCPWM_T            *) LPC_MCPWM_BASE)
+#define LPC_I2C0                  ((LPC_I2C_T              *) LPC_I2C0_BASE)
+#define LPC_I2C1                  ((LPC_I2C_T              *) LPC_I2C1_BASE)
+#define LPC_I2S0                  ((LPC_I2S_T              *) LPC_I2S0_BASE)
+#define LPC_I2S1                  ((LPC_I2S_T              *) LPC_I2S1_BASE)
+#define LPC_C_CAN1                ((LPC_CCAN_T             *) LPC_C_CAN1_BASE)
+#define LPC_RITIMER               ((LPC_RITIMER_T          *) LPC_RITIMER_BASE)
+#define LPC_QEI                   ((LPC_QEI_T              *) LPC_QEI_BASE)
+#define LPC_GIMA                  ((LPC_GIMA_T             *) LPC_GIMA_BASE)
+#define LPC_DAC                   ((LPC_DAC_T              *) LPC_DAC_BASE)
+#define LPC_C_CAN0                ((LPC_CCAN_T             *) LPC_C_CAN0_BASE)
+#define LPC_ADC0                  ((LPC_ADC_T              *) LPC_ADC0_BASE)
+#define LPC_ADC1                  ((LPC_ADC_T              *) LPC_ADC1_BASE)
+#define LPC_ADCHS                 ((LPC_HSADC_T            *) LPC_ADCHS_BASE)
+#define LPC_GPIO_PORT             ((LPC_GPIO_T             *) LPC_GPIO_PORT_BASE)
+#define LPC_SPI                   ((LPC_SPI_T              *) LPC_SPI_BASE)
+#define LPC_SGPIO                 ((LPC_SGPIO_T            *) LPC_SGPIO_BASE)
+#define LPC_EEPROM                ((LPC_EEPROM_T           *) LPC_EEPROM_BASE)
+#define LPC_FMCA                  ((LPC_FMC_T              *) LPC_FMCA_BASE)
+#define LPC_FMCB                  ((LPC_FMC_T              *) LPC_FMCB_BASE)
+#define LPC_ROM_API               ((LPC_ROM_API_T          *) LPC_ROM_API_BASE)
+
+/**
+ * @}
+ */
+
+#include "scu_18xx_43xx.h"
+#include "clock_18xx_43xx.h"
+#include "rgu_18xx_43xx.h"
+#include "creg_18xx_43xx.h"
+#include "evrt_18xx_43xx.h"
+#include "otp_18xx_43xx.h"
+#include "sdif_18xx_43xx.h"
+#include "adc_18xx_43xx.h"
+#include "hsadc_18xx_43xx.h"
+#include "atimer_18xx_43xx.h"
+#include "aes_18xx_43xx.h"
+#include "ccan_18xx_43xx.h"
+#include "dac_18xx_43xx.h"
+#include "eeprom_18xx_43xx.h"
+#include "emc_18xx_43xx.h"
+#include "enet_18xx_43xx.h"
+#include "fmc_18xx_43xx.h"
+#include "i2c_18xx_43xx.h"
+#include "i2s_18xx_43xx.h"
+#include "gima_18xx_43xx.h"
+#include "gpdma_18xx_43xx.h"
+#include "gpio_18xx_43xx.h"
+#include "pinint_18xx_43xx.h"
+#include "gpiogroup_18xx_43xx.h"
+#include "lcd_18xx_43xx.h"
+#include "mcpwm_18xx_43xx.h"
+#include "pmc_18xx_43xx.h"
+#include "qei_18xx_43xx.h"
+#include "ritimer_18xx_43xx.h"
+#include "rtc_18xx_43xx.h"
+#include "sct_18xx_43xx.h"
+#include "sct_pwm_18xx_43xx.h"
+#include "sdmmc_18xx_43xx.h"
+#include "sdio_18xx_43xx.h"
+#include "sgpio_18xx_43xx.h"
+#include "spifi_18xx_43xx.h"
+#include "spi_18xx_43xx.h"
+#include "ssp_18xx_43xx.h"
+#include "timer_18xx_43xx.h"
+#include "uart_18xx_43xx.h"
+#include "usbhs_18xx_43xx.h"
+#include "wwdt_18xx_43xx.h"
+#include "romapi_18xx_43xx.h"
+#include "i2cm_18xx_43xx.h"
+
+#if defined(CORE_M4)
+#include "fpu_init.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_LPC43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/clock_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/clock_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/clock_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/clock_18xx_43xx.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,400 @@
+/*
+ * @brief LPC18xx/43xx clock driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CLOCK_18XX_43XX_H_
+#define __CLOCK_18XX_43XX_H_
+
+#include "cguccu_18xx_43xx.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CLOCK_18XX_43XX CHIP: LPC18xx/43xx Clock Driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/** @defgroup CLOCK_18XX_43XX_OPTIONS CHIP: LPC18xx/43xx Clock Driver driver options
+ * @ingroup CLOCK_18XX_43XX CHIP_18XX_43XX_DRIVER_OPTIONS
+ * The clock driver has options that configure it's operation at build-time.<br>
+ *
+ * <b>MAX_CLOCK_FREQ</b><br>
+ * This macro defines the maximum frequency supported by the Chip [204MHz for LPC43xx
+ * 180MHz for LPC18xx]. API Chip_SetupXtalClocking() and Chip_SetupIrcClocking() will
+ * use this macro to set the CPU Core frequency to the maximum supported.<br>
+ * To set a Core frequency other than the maximum frequency Chip_SetupCoreClock() API
+ * must be used. <b>Using this macro to set the Core freqency is not recommended.</b>
+ * @{
+ */
+
+/**
+ * @}
+ */
+
+/* Internal oscillator frequency */
+#define CGU_IRC_FREQ (12000000)
+
+#ifndef MAX_CLOCK_FREQ
+#if defined(CHIP_LPC43XX)
+#define MAX_CLOCK_FREQ (204000000)
+#else
+#define MAX_CLOCK_FREQ (180000000)
+#endif
+#endif
+
+#define PLL_MIN_CCO_FREQ 156000000  /**< Min CCO frequency of main PLL */
+#define PLL_MAX_CCO_FREQ 320000000  /**< Max CCO frequency of main PLL */
+
+/**
+ * @brief	PLL Parameter strucutre
+ */
+typedef struct {
+	int ctrl;       /**< Control register value */
+	CHIP_CGU_CLKIN_T srcin; /**< Input clock Source see #CHIP_CGU_CLKIN_T */
+	int nsel;       /**< Pre-Div value */
+	int psel;       /**< Post-Div Value */
+	int msel;       /**< M-Div value */
+	uint32_t fin;   /**< Input frequency */
+	uint32_t fout;  /**< Output frequency */
+	uint32_t fcco;  /**< CCO frequency */
+} PLL_PARAM_T;
+
+/**
+ * @brief	Enables the crystal oscillator
+ * @return	Nothing
+ */
+void Chip_Clock_EnableCrystal(void);
+
+/**
+ * @brief	Disables the crystal oscillator
+ * @return	Nothing
+ */
+void Chip_Clock_DisableCrystal(void);
+
+/**
+ * @brief   Configures the main PLL
+ * @param   Input		: Which clock input to use as the PLL input
+ * @param   MinHz		: Minimum allowable PLL output frequency
+ * @param   DesiredHz	: Desired PLL output frequency
+ * @param   MaxHz		: Maximum allowable PLL output frequency
+ * @return	Frequency of the PLL in Hz
+ * Returns the configured PLL frequency or zero if the PLL can not be configured between MinHz
+ * and MaxHz. This will not wait for PLL lock. Call Chip_Clock_MainPLLLocked() to determine if
+ * the PLL is locked.
+ */
+uint32_t Chip_Clock_SetupMainPLLHz(CHIP_CGU_CLKIN_T Input, uint32_t MinHz, uint32_t DesiredHz, uint32_t MaxHz);
+
+/**
+ * @brief	Directly set the PLL multipler
+ * @param   Input	: Which clock input to use as the PLL input
+ * @param	mult	: How many times to multiply the input clock
+ * @return	Frequency of the PLL in Hz
+ */
+uint32_t Chip_Clock_SetupMainPLLMult(CHIP_CGU_CLKIN_T Input, uint32_t mult);
+
+/**
+ * @brief   Returns the frequency of the main PLL
+ * @return	Frequency of the PLL in Hz
+ * Returns zero if the main PLL is not running.
+ */
+uint32_t Chip_Clock_GetMainPLLHz(void);
+
+/**
+ * @brief	Disables the main PLL
+ * @return	none
+ * Make sure the main PLL is not needed to clock the part before disabling it.
+ * Saves power if the main PLL is not needed.
+ */
+__STATIC_INLINE void Chip_Clock_DisableMainPLL(void)
+{
+	/* power down main PLL */
+	LPC_CGU->PLL1_CTRL |= 1;
+}
+
+/**
+ * @brief	Enbles the main PLL
+ * @return	none
+ * Make sure the main PLL is enabled.
+ */
+__STATIC_INLINE void Chip_Clock_EnableMainPLL(void)
+{
+	/* power up main PLL */
+	LPC_CGU->PLL1_CTRL &= ~1;
+}
+/**
+ * @brief	Sets-up the main PLL
+ * @param	ppll	: Pointer to pll param structure #PLL_PARAM_T
+ * @return	none
+ * Make sure the main PLL is enabled.
+ */
+__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
+{
+	/* power up main PLL */
+    LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8) | ( 1 << 11);	
+}
+
+/**
+ * @brief	Sets up a CGU clock divider and it's input clock
+ * @param	Divider	: CHIP_CGU_IDIV_T value indicating which divider to configure
+ * @param	Input	: CHIP_CGU_CLKIN_T value indicating which clock source to use or CLOCKINPUT_PD to power down divider
+ * @param	Divisor	: value to divide Input clock by
+ * @return	Nothing
+ * Maximum divider on A = 4, B/C/D = 16, E = 256.
+ * See the user manual for allowable combinations for input clock.
+ */
+void Chip_Clock_SetDivider(CHIP_CGU_IDIV_T Divider, CHIP_CGU_CLKIN_T Input, uint32_t Divisor);
+
+/**
+ * @brief	Gets a CGU clock divider source
+ * @param	Divider	: CHIP_CGU_IDIV_T value indicating which divider to get the source of
+ * @return	CHIP_CGU_CLKIN_T indicating which clock source is set or CLOCKINPUT_PD
+ */
+CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider);
+
+/**
+ * @brief	Gets a CGU clock divider divisor
+ * @param	Divider	: CHIP_CGU_IDIV_T value indicating which divider to get the source of
+ * @return	the divider value for the divider
+ */
+uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider);
+
+/**
+ * @brief	Returns the frequency of the specified input clock source
+ * @param	input	: Which clock input to return the frequency of
+ * @return	Frequency of input source in Hz
+ * This function returns an ideal frequency and not the actual frequency. Returns
+ * zero if the clock source is disabled.
+ */
+uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input);
+
+/**
+ * @brief	Returns the frequency of the specified base clock source
+ * @param	clock	: which base clock to return the frequency of.
+ * @return	Frequency of base source in Hz
+ * This function returns an ideal frequency and not the actual frequency. Returns
+ * zero if the clock source is disabled.
+ */
+uint32_t Chip_Clock_GetBaseClocktHz(CHIP_CGU_BASE_CLK_T clock);
+
+/**
+ * @brief	Sets a CGU Base Clock clock source
+ * @param	BaseClock	: CHIP_CGU_BASE_CLK_T value indicating which base clock to set
+ * @param	Input		: CHIP_CGU_CLKIN_T value indicating which clock source to use or CLOCKINPUT_PD to power down base clock
+ * @param	autoblocken	: Enables autoblocking during frequency change if true
+ * @param	powerdn		: The clock base is setup, but powered down if true
+ * @return	Nothing
+ */
+void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn);
+
+/**
+ * @brief	Get CGU Base Clock clock source information
+ * @param	BaseClock	: CHIP_CGU_BASE_CLK_T value indicating which base clock to get
+ * @param	Input		: Pointer to CHIP_CGU_CLKIN_T value of the base clock
+ * @param	autoblocken	: Pointer to autoblocking value of the base clock
+ * @param	powerdn		: Pointer to power down flag
+ * @return	Nothing
+ */
+void Chip_Clock_GetBaseClockOpts(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T *Input, bool *autoblocken,
+								 bool *powerdn);
+
+/**
+ * @brief	Gets a CGU Base Clock clock source
+ * @param	BaseClock	: CHIP_CGU_BASE_CLK_T value indicating which base clock to get inpuot clock for
+ * @return	CHIP_CGU_CLKIN_T indicating which clock source is set or CLOCKINPUT_PD
+ */
+CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief	Enables a base clock source
+ * @param	BaseClock	: CHIP_CGU_BASE_CLK_T value indicating which base clock to enable
+ * @return	Nothing
+ */
+void Chip_Clock_EnableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief	Disables a base clock source
+ * @param	BaseClock	: CHIP_CGU_BASE_CLK_T value indicating which base clock to disable
+ * @return	Nothing
+ */
+void Chip_Clock_DisableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief	Returns base clock enable state
+ * @param	BaseClock	: CHIP_CGU_BASE_CLK_T value indicating which base clock to check
+ * @return	true if the base clock is enabled, false if disabled
+ */
+bool Chip_Clock_IsBaseClockEnabled(CHIP_CGU_BASE_CLK_T BaseClock);
+
+/**
+ * @brief	Enables a peripheral clock and sets clock states
+ * @param	clk			: CHIP_CCU_CLK_T value indicating which clock to enable
+ * @param	autoen		: true to enable autoblocking on a clock rate change, false to disable
+ * @param	wakeupen	: true to enable wakeup mechanism, false to disable
+ * @param	div			: Divider for the clock, must be 1 for most clocks, 2 supported on others
+ * @return	Nothing
+ */
+void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div);
+
+/**
+ * @brief	Enables a peripheral clock
+ * @param	clk	: CHIP_CCU_CLK_T value indicating which clock to enable
+ * @return	Nothing
+ */
+void Chip_Clock_Enable(CHIP_CCU_CLK_T clk);
+
+/**
+ * @brief	Enables RTCclock
+ * @return	Nothing
+ */
+void Chip_Clock_RTCEnable(void);
+
+/**
+ * @brief	Disables a peripheral clock
+ * @param	clk	: CHIP_CCU_CLK_T value indicating which clock to disable
+ * @return	Nothing
+ */
+void Chip_Clock_Disable(CHIP_CCU_CLK_T clk);
+
+/**
+ * @brief	Returns a peripheral clock rate
+ * @param	clk	: CHIP_CCU_CLK_T value indicating which clock to get rate for
+ * @return	0 if the clock is disabled, or the rate of the clock
+ */
+uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk);
+
+/**
+ * @brief	Returns EMC clock rate
+ * @return	0 if the clock is disabled, or the rate of the clock
+ */
+uint32_t Chip_Clock_GetEMCRate(void);
+
+/**
+ * @brief	Start the power down sequence by disabling the branch output
+ *          clocks with wake up mechanism (Only the clocks which
+ *          wake up mechanism bit enabled will be disabled)
+ * @return	Nothing
+ */
+void Chip_Clock_StartPowerDown(void);
+
+/**
+ * @brief	Clear the power down mode bit & proceed normal operation of branch output
+ *          clocks (Only the clocks which wake up mechanism bit enabled will be
+ *          enabled after the wake up event)
+ * @return	Nothing
+ */
+void Chip_Clock_ClearPowerDown(void);
+
+/**
+ * Structure for setting up the USB or audio PLL
+ */
+typedef struct {
+	uint32_t ctrl;		/* Default control word for PLL */
+	uint32_t mdiv;		/* Default M-divider value for PLL */
+	uint32_t ndiv;		/* Default NP-divider value for PLL */
+	uint32_t fract;		/* Default fractional value for audio PLL only */
+	uint32_t freq;      /* Output frequency of the pll */
+} CGU_USBAUDIO_PLL_SETUP_T;
+
+/**
+ * @brief	Sets up the audio or USB PLL
+ * @param	Input		: Input clock
+ * @param	pllnum		: PLL identifier
+ * @param	pPLLSetup	: Pointer to PLL setup structure
+ * @return	Nothing
+ * Sets up the PLL with the passed structure values.
+ */
+void Chip_Clock_SetupPLL(CHIP_CGU_CLKIN_T Input, CHIP_CGU_USB_AUDIO_PLL_T pllnum,
+						 const CGU_USBAUDIO_PLL_SETUP_T *pPLLSetup);
+
+/**
+ * @brief	Enables the audio or USB PLL
+ * @param	pllnum	: PLL identifier
+ * @return	Nothing
+ */
+void Chip_Clock_EnablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum);
+
+/**
+ * @brief	Disables the audio or USB PLL
+ * @param	pllnum	: PLL identifier
+ * @return	Nothing
+ */
+void Chip_Clock_DisablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum);
+
+#define CGU_PLL_LOCKED (1 << 0)	/* PLL locked status */
+#define CGU_PLL_FR     (1 << 1)	/* PLL free running indicator status */
+
+/**
+ * @brief	Returns the PLL status
+ * @param	pllnum	: PLL identifier
+ * @return	An OR'ed value of CGU_PLL_LOCKED or CGU_PLL_FR
+ */
+uint32_t Chip_Clock_GetPLLStatus(CHIP_CGU_USB_AUDIO_PLL_T pllnum);
+
+/**
+ * @brief	Calculate main PLL Pre, Post and M div values
+ * @param	freq	: Expected output frequency
+ * @param	ppll	: Pointer to #PLL_PARAM_T structure
+ * @return	0 on success; < 0 on failure
+ * @note
+ * ppll->srcin[IN] should have the appropriate Input clock source selected<br>
+ * ppll->fout[OUT] will have the actual output frequency<br>
+ * ppll->fcco[OUT] will have the frequency of CCO
+ */
+int Chip_Clock_CalcMainPLLValue(uint32_t freq, PLL_PARAM_T *ppll);
+
+
+/**
+ * @brief	Wait for Main PLL to be locked
+ * @return	1 - PLL is LOCKED; 0 - PLL is not locked
+ * @note	The main PLL should be locked prior to using it as a clock input for a base clock.
+ */
+__STATIC_INLINE int Chip_Clock_MainPLLLocked(void)
+{
+	/* Return true if locked */
+	return (LPC_CGU->PLL1_STAT & 1) != 0;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CLOCK_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_18xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_18xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_18xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_18xx.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,172 @@
+/*
+ * @brief Basic CMSIS include file for LPC18XX
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_18XX_H_
+#define __CMSIS_18XX_H_
+
+#ifndef __CMSIS_H_
+#error "cmsis_18xx.h should not be included directly use cmsis.h instead"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_18XX CHIP: LPC18xx CMSIS include file
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+/** @defgroup CMSIS_18XX_COMMON CHIP: LPC18xx Cortex CMSIS definitions
+ * @{
+ */
+
+#define __CM3_REV                 0x0201
+#define __MPU_PRESENT             1			/*!< MPU present or not                    */
+#define __NVIC_PRIO_BITS          3			/*!< Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used */
+#define __FPU_PRESENT             0			/*!< FPU present or not                    */
+
+/**
+ * @}
+ */
+
+/** @defgroup CMSIS_18XX_IRQ CHIP: LPC18xx peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/* -------------------------  Cortex-M3 Processor Exceptions Numbers  ----------------------------- */
+	Reset_IRQn                        = -15,/*!<   1  Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn               = -14,/*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
+	HardFault_IRQn                    = -13,/*!<   3  Hard Fault, all classes of Fault */
+	MemoryManagement_IRQn             = -12,/*!<   4  Memory Management, MPU mismatch, including Access Violation and No Match */
+	BusFault_IRQn                     = -11,/*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault */
+	UsageFault_IRQn                   = -10,/*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition */
+	SVCall_IRQn                       = -5,	/*!<  11  System Service Call via SVC instruction */
+	DebugMonitor_IRQn                 = -4,	/*!<  12  Debug Monitor                    */
+	PendSV_IRQn                       = -2,	/*!<  14  Pendable request for system service */
+	SysTick_IRQn                      = -1,	/*!<  15  System Tick Timer                */
+
+	/* ---------------------------  LPC18xx/43xx Specific Interrupt Numbers  ------------------------------- */
+	DAC_IRQn                          =   0,/*!<   0  DAC                              */
+	RESERVED0_IRQn                    =   1,
+	DMA_IRQn                          =   2,/*!<   2  DMA                              */
+	RESERVED1_IRQn                    =   3,/*!<   3  EZH/EDM                          */
+	RESERVED2_IRQn                    =   4,
+	ETHERNET_IRQn                     =   5,/*!<   5  ETHERNET                         */
+	SDIO_IRQn                         =   6,/*!<   6  SDIO                             */
+	LCD_IRQn                          =   7,/*!<   7  LCD                              */
+	USB0_IRQn                         =   8,/*!<   8  USB0                             */
+	USB1_IRQn                         =   9,/*!<   9  USB1                             */
+	SCT_IRQn                          =  10,/*!<  10  SCT                              */
+	RITIMER_IRQn                      =  11,/*!<  11  RITIMER                          */
+	TIMER0_IRQn                       =  12,/*!<  12  TIMER0                           */
+	TIMER1_IRQn                       =  13,/*!<  13  TIMER1                           */
+	TIMER2_IRQn                       =  14,/*!<  14  TIMER2                           */
+	TIMER3_IRQn                       =  15,/*!<  15  TIMER3                           */
+	MCPWM_IRQn                        =  16,/*!<  16  MCPWM                            */
+	ADC0_IRQn                         =  17,/*!<  17  ADC0                             */
+	I2C0_IRQn                         =  18,/*!<  18  I2C0                             */
+	I2C1_IRQn                         =  19,/*!<  19  I2C1                             */
+	RESERVED3_IRQn                    =  20,
+	ADC1_IRQn                         =  21,/*!<  21  ADC1                             */
+	SSP0_IRQn                         =  22,/*!<  22  SSP0                             */
+	SSP1_IRQn                         =  23,/*!<  23  SSP1                             */
+	USART0_IRQn                       =  24,/*!<  24  USART0                           */
+	UART1_IRQn                        =  25,/*!<  25  UART1                            */
+	USART2_IRQn                       =  26,/*!<  26  USART2                           */
+	USART3_IRQn                       =  27,/*!<  27  USART3                           */
+	I2S0_IRQn                         =  28,/*!<  28  I2S0                             */
+	I2S1_IRQn                         =  29,/*!<  29  I2S1                             */
+	RESERVED4_IRQn                    =  30,
+	RESERVED5_IRQn                    =  31,
+	PIN_INT0_IRQn                     =  32,/*!<  32  PIN_INT0                         */
+	PIN_INT1_IRQn                     =  33,/*!<  33  PIN_INT1                         */
+	PIN_INT2_IRQn                     =  34,/*!<  34  PIN_INT2                         */
+	PIN_INT3_IRQn                     =  35,/*!<  35  PIN_INT3                         */
+	PIN_INT4_IRQn                     =  36,/*!<  36  PIN_INT4                         */
+	PIN_INT5_IRQn                     =  37,/*!<  37  PIN_INT5                         */
+	PIN_INT6_IRQn                     =  38,/*!<  38  PIN_INT6                         */
+	PIN_INT7_IRQn                     =  39,/*!<  39  PIN_INT7                         */
+	GINT0_IRQn                        =  40,/*!<  40  GINT0                            */
+	GINT1_IRQn                        =  41,/*!<  41  GINT1                            */
+	EVENTROUTER_IRQn                  =  42,/*!<  42  EVENTROUTER                      */
+	C_CAN1_IRQn                       =  43,/*!<  43  C_CAN1                           */
+	RESERVED6_IRQn                    =  44,
+	RESERVED7_IRQn                    =  45,/*!<                                       */
+	ATIMER_IRQn                       =  46,/*!<  46  ATIMER                           */
+	RTC_IRQn                          =  47,/*!<  47  RTC                              */
+	RESERVED8_IRQn                    =  48,
+	WWDT_IRQn                         =  49,/*!<  49  WWDT                             */
+	RESERVED9_IRQn                    =  50,
+	C_CAN0_IRQn                       =  51,/*!<  51  C_CAN0                           */
+	QEI_IRQn                          =  52,/*!<  52  QEI                              */
+} LPC18XX_IRQn_Type;
+
+/**
+ * @}
+ */
+
+typedef LPC18XX_IRQn_Type IRQn_Type;
+
+/* Cortex-M3 processor and core peripherals */
+#include "core_cm3.h"
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef __CMSIS_18XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,173 @@
+/*
+ * @brief Basic CMSIS include file for LPC43XX
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_43XX_M0_H_
+#define __CMSIS_43XX_M0_H_
+
+#ifndef __CMSIS_H_
+#error "cmsis_43xx.h should not be included directly use cmsis.h instead"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_43XX CHIP: LPC43xx CMSIS include file
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/** @defgroup CMSIS_43XX_COMMON CHIP: LPC43xx Cortex CMSIS definitions
+ * @{
+ */
+
+#define __CM4_REV              0x0001		/*!< Cortex-M4 Core Revision               */
+#define __MPU_PRESENT             1			/*!< MPU present or not                    */
+#define __NVIC_PRIO_BITS          3			/*!< Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used */
+#define __FPU_PRESENT             1			/*!< FPU present or not                    */
+
+/**
+ * @}
+ */
+
+/** @defgroup CMSIS_43XX_IRQ CHIP: LPC43xx peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/* -------------------------  Cortex-M4 Processor Exceptions Numbers  ----------------------------- */
+	Reset_IRQn                        = -15,/*!<   1  Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn               = -14,/*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
+	HardFault_IRQn                    = -13,/*!<   3  Hard Fault, all classes of Fault */
+	MemoryManagement_IRQn             = -12,/*!<   4  Memory Management, MPU mismatch, including Access Violation and No Match */
+	BusFault_IRQn                     = -11,/*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault */
+	UsageFault_IRQn                   = -10,/*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition */
+	SVCall_IRQn                       =  -5,/*!<  11  System Service Call via SVC instruction */
+	DebugMonitor_IRQn                 =  -4,/*!<  12  Debug Monitor                    */
+	PendSV_IRQn                       =  -2,/*!<  14  Pendable request for system service */
+	SysTick_IRQn                      =  -1,/*!<  15  System Tick Timer                */
+
+	/* ---------------------------  LPC18xx/43xx Specific Interrupt Numbers  ------------------------------- */
+	DAC_IRQn                          =   0,/*!<   0  DAC                              */
+	M0APP_IRQn                        =   1,/*!<   1  M0APP Core interrupt             */
+	DMA_IRQn                          =   2,/*!<   2  DMA                              */
+	RESERVED1_IRQn                    =   3,/*!<   3  EZH/EDM                          */
+	RESERVED2_IRQn                    =   4,
+	ETHERNET_IRQn                     =   5,/*!<   5  ETHERNET                         */
+	SDIO_IRQn                         =   6,/*!<   6  SDIO                             */
+	LCD_IRQn                          =   7,/*!<   7  LCD                              */
+	USB0_IRQn                         =   8,/*!<   8  USB0                             */
+	USB1_IRQn                         =   9,/*!<   9  USB1                             */
+	SCT_IRQn                          =  10,/*!<  10  SCT                              */
+	RITIMER_IRQn                      =  11,/*!<  11  RITIMER                          */
+	TIMER0_IRQn                       =  12,/*!<  12  TIMER0                           */
+	TIMER1_IRQn                       =  13,/*!<  13  TIMER1                           */
+	TIMER2_IRQn                       =  14,/*!<  14  TIMER2                           */
+	TIMER3_IRQn                       =  15,/*!<  15  TIMER3                           */
+	MCPWM_IRQn                        =  16,/*!<  16  MCPWM                            */
+	ADC0_IRQn                         =  17,/*!<  17  ADC0                             */
+	I2C0_IRQn                         =  18,/*!<  18  I2C0                             */
+	I2C1_IRQn                         =  19,/*!<  19  I2C1                             */
+	SPI_INT_IRQn                      =  20,/*!<  20  SPI_INT                          */
+	ADC1_IRQn                         =  21,/*!<  21  ADC1                             */
+	SSP0_IRQn                         =  22,/*!<  22  SSP0                             */
+	SSP1_IRQn                         =  23,/*!<  23  SSP1                             */
+	USART0_IRQn                       =  24,/*!<  24  USART0                           */
+	UART1_IRQn                        =  25,/*!<  25  UART1                            */
+	USART2_IRQn                       =  26,/*!<  26  USART2                           */
+	USART3_IRQn                       =  27,/*!<  27  USART3                           */
+	I2S0_IRQn                         =  28,/*!<  28  I2S0                             */
+	I2S1_IRQn                         =  29,/*!<  29  I2S1                             */
+	RESERVED4_IRQn                    =  30,
+	SGPIO_INT_IRQn                    =  31,/*!<  31  SGPIO_IINT                       */
+	PIN_INT0_IRQn                     =  32,/*!<  32  PIN_INT0                         */
+	PIN_INT1_IRQn                     =  33,/*!<  33  PIN_INT1                         */
+	PIN_INT2_IRQn                     =  34,/*!<  34  PIN_INT2                         */
+	PIN_INT3_IRQn                     =  35,/*!<  35  PIN_INT3                         */
+	PIN_INT4_IRQn                     =  36,/*!<  36  PIN_INT4                         */
+	PIN_INT5_IRQn                     =  37,/*!<  37  PIN_INT5                         */
+	PIN_INT6_IRQn                     =  38,/*!<  38  PIN_INT6                         */
+	PIN_INT7_IRQn                     =  39,/*!<  39  PIN_INT7                         */
+	GINT0_IRQn                        =  40,/*!<  40  GINT0                            */
+	GINT1_IRQn                        =  41,/*!<  41  GINT1                            */
+	EVENTROUTER_IRQn                  =  42,/*!<  42  EVENTROUTER                      */
+	C_CAN1_IRQn                       =  43,/*!<  43  C_CAN1                           */
+	RESERVED6_IRQn                    =  44,
+	ADCHS_IRQn                        =  45,/*!<  45  ADCHS interrupt                  */
+	ATIMER_IRQn                       =  46,/*!<  46  ATIMER                           */
+	RTC_IRQn                          =  47,/*!<  47  RTC                              */
+	RESERVED8_IRQn                    =  48,
+	WWDT_IRQn                         =  49,/*!<  49  WWDT                             */
+	M0SUB_IRQn                        =  50,/*!<  50  M0SUB core interrupt             */
+	C_CAN0_IRQn                       =  51,/*!<  51  C_CAN0                           */
+	QEI_IRQn                          =  52,/*!<  52  QEI                              */
+} LPC43XX_IRQn_Type;
+
+/**
+ * @}
+ */
+
+typedef LPC43XX_IRQn_Type IRQn_Type;
+
+/* Cortex-M4 processor and core peripherals */
+#include "core_cm4.h"
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef __CMSIS_43XX_M0_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0app.h ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0app.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0app.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0app.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,156 @@
+/*
+ * @brief Basic CMSIS include file for LPC43XX
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_43XX_H_
+#define __CMSIS_43XX_H_
+
+#ifndef __CMSIS_H_
+#error "cmsis_43xx.h should not be included directly use cmsis.h instead"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_43XX_M0 CHIP: LPC43xx CMSIS include file
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/** @defgroup CMSIS_43XX_M0_COMMON CHIP: LPC43xx (M0 Core) Cortex CMSIS definitions
+ * @{
+ */
+
+#define __MPU_PRESENT             0			/*!< MPU present or not                    */
+#define __NVIC_PRIO_BITS          2			/*!< Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used */
+#define __FPU_PRESENT             0			/*!< FPU present or not                    */
+
+/**
+ * @}
+ */
+
+/** @defgroup CMSIS_43XX_M0_IRQ CHIP: LPC43xx (M0 Core) peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/* -------------------------  Cortex-M0 Processor Exceptions Numbers  ----------------------------- */
+	Reset_IRQn                        = -15,/*!<   1  Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn               = -14,/*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
+	HardFault_IRQn                    = -13,/*!<   3  Hard Fault, all classes of Fault */
+	SVCall_IRQn                       = -5,	/*!<  11  System Service Call via SVC instruction */
+	DebugMonitor_IRQn                 = -4,	/*!<  12  Debug Monitor                    */
+	PendSV_IRQn                       = -2,	/*!<  14  Pendable request for system service */
+	SysTick_IRQn                      = -1,	/*!<  15  System Tick Timer           */
+
+	/* ---------------------------  LPC18xx/43xx Specific Interrupt Numbers  ------------------------------- */
+	RTC_IRQn                          =   0,/*!<   0  RTC                              */
+	M4_IRQn                           =   1,/*!<   1  M4 Core interrupt                */
+	DMA_IRQn                          =   2,/*!<   2  DMA                              */
+	RESERVED1_IRQn                    =   3,/*!<   3                                   */
+	FLASHEEPROM_IRQn                  =   4,/*!<   4  ORed Flash Bank A, B, EEPROM     */
+	ATIMER_IRQn                       =   4,/*!<   4  ATIMER ORed with Flash/EEPROM    */
+	ETHERNET_IRQn                     =   5,/*!<   5  ETHERNET                         */
+	SDIO_IRQn                         =   6,/*!<   6  SDIO                             */
+	LCD_IRQn                          =   7,/*!<   7  LCD                              */
+	USB0_IRQn                         =   8,/*!<   8  USB0                             */
+	USB1_IRQn                         =   9,/*!<   9  USB1                             */
+	SCT_IRQn                          =  10,/*!<  10  SCT                              */
+	RITIMER_IRQn                      =  11,/*!<  11  ORed RITIMER, WWDT               */
+	WWDT_IRQn                         =  11,/*!<  11  ORed RITIMER, WWDT               */
+	TIMER0_IRQn                       =  12,/*!<  12  TIMER0                           */
+	GINT1_IRQn                        =  13,/*!<  13  GINT1                            */
+	PIN_INT4_IRQn                     =  14,/*!<  14  GPIO 4                           */
+	TIMER3_IRQn                       =  15,/*!<  15  TIMER3                           */
+	MCPWM_IRQn                        =  16,/*!<  16  MCPWM                            */
+	ADC0_IRQn                         =  17,/*!<  17  ADC0                             */
+	I2C0_IRQn                         =  18,/*!<  18  ORed I2C0, I2C1                  */
+	I2C1_IRQn                         =  18,/*!<  18  ORed I2C0, I2C1                  */
+	SGPIO_INT_IRQn                    =  19,/*!<  19  SGPIO                            */
+	SPI_INT_IRQn                      =  20,/*!<  20  ORed SPI/DAC                     */
+	DAC_IRQn                          =  20,/*!<  20  ORed SPI/DAC                     */
+	ADC1_IRQn                         =  21,/*!<  21  ADC1                             */
+	SSP0_IRQn                         =  22,/*!<  22  ORed SSP0, SSP1                  */
+	SSP1_IRQn                         =  22,/*!<  22  ORed SSP0, SSP1                  */
+	EVENTROUTER_IRQn                  =  23,/*!<  23  EVENTROUTER                      */
+	USART0_IRQn                       =  24,/*!<  24  USART0                           */
+	UART1_IRQn                        =  25,/*!<  25  UART1                            */
+	USART2_IRQn                       =  26,/*!<  26  ORed USART2/C_CAN1               */
+	C_CAN1_IRQn                       =  26,/*!<  29  ORed USART2/C_CAN1               */
+	USART3_IRQn                       =  27,/*!<  27  USART3                           */
+	I2S0_IRQn                         =  28,/*!<  28  ORed I2S0/I2S1/QEI               */
+	I2S1_IRQn                         =  28,/*!<  29  ORed I2S0/I2S1/QEI               */
+	QEI_IRQn                          =  28,/*!<  29  ORed I2S0/I2S1/QEI               */
+	C_CAN0_IRQn                       =  29,/*!<  29  C_CAN0                           */
+	ADCHS_IRQn                        =  30,/*!<  30  ADCHS interrupt                  */
+	M0SUB_IRQn                        =  31,/*!<  31  M0SUB                            */
+} LPC43XX_M0_IRQn_Type;
+
+/**
+ * @}
+ */
+
+typedef LPC43XX_M0_IRQn_Type IRQn_Type;
+
+/* Cortex-M4 processor and core peripherals */
+#include "core_cm0.h"
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef __CMSIS_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0sub.h ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0sub.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0sub.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis_43xx_m0sub.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,151 @@
+/*
+ * @brief Basic CMSIS include file for LPC43XX
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_43XX_H_
+#define __CMSIS_43XX_H_
+
+#ifndef __CMSIS_H_
+#error "cmsis_43xx.h should not be included directly use cmsis.h instead"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_43XX_M0 CHIP: LPC43xx CMSIS include file
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/** @defgroup CMSIS_43XX_M0_COMMON CHIP: LPC43xx (M0 Core) Cortex CMSIS definitions
+ * @{
+ */
+
+#define __MPU_PRESENT             0			/*!< MPU present or not                    */
+#define __NVIC_PRIO_BITS          2			/*!< Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used */
+#define __FPU_PRESENT             0			/*!< FPU present or not                    */
+
+/**
+ * @}
+ */
+
+/** @defgroup CMSIS_43XX_M0_IRQ CHIP: LPC43xx (M0 Core) peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/* -------------------------  Cortex-M0 Processor Exceptions Numbers  ----------------------------- */
+	Reset_IRQn                        = -15,/*!<   1  Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn               = -14,/*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
+	HardFault_IRQn                    = -13,/*!<   3  Hard Fault, all classes of Fault */
+	SVCall_IRQn                       = -5,	/*!<  11  System Service Call via SVC instruction */
+	DebugMonitor_IRQn                 = -4,	/*!<  12  Debug Monitor                    */
+	PendSV_IRQn                       = -2,	/*!<  14  Pendable request for system service */
+	SysTick_IRQn                      = -1,	/*!<  15  System Tick Timer           */
+
+	/* ---------------------------  LPC18xx/43xx Specific Interrupt Numbers  ------------------------------- */
+	DAC_IRQn                          =   0,/*!<   0  DAC                              */
+	M4_IRQn                           =   1,/*!<   1  M0a                              */
+	DMA_IRQn                          =   2,/*!<   2  DMA                              */
+	RESERVED1_IRQn                    =   3,/*!<   3                                   */
+	SGPIO_INPUT_IRQn                  =   4,/*!<   4  SGPIO Input bit match            */
+	SGPIO_MATCH_IRQn                  =   5,/*!<   5  SGPIO Pattern Match              */
+	SGPIO_SHIFT_IRQn                  =   6,/*!<   6  SGPIO Shift Clock                */
+	SGPIO_POS_IRQn                    =   7,/*!<   7  SGPIO Capture Clock              */
+	USB0_IRQn                         =   8,/*!<   8  USB0                             */
+	USB1_IRQn                         =   9,/*!<   9  USB1                             */
+	SCT_IRQn                          =  10,/*!<  10  SCT                              */
+	RITIMER_IRQn                      =  11,/*!<  11  RITIMER                          */
+	GINT1_IRQn                        =  12,/*!<  12  GINT1                            */
+	TIMER1_IRQn                       =  13,/*!<  13  TIMER1                           */
+	TIMER2_IRQn                       =  14,/*!<  14  TIMER2                           */
+	PIN_INT5_IRQn                     =  15,/*!<  15  GPIO Pin interrupt 5             */
+	MCPWM_IRQn                        =  16,/*!<  16  MCPWM                            */
+	ADC0_IRQn                         =  17,/*!<  17  ADC0                             */
+	I2C0_IRQn                         =  18,/*!<  18  I2C0                             */
+	I2C1_IRQn                         =  19,/*!<  19  I2C1                             */
+	SPI_INT_IRQn                      =  20,/*!<  20  SPI_INT                          */
+	ADC1_IRQn                         =  21,/*!<  21  ADC1                             */
+	SSP0_IRQn                         =  22,/*!<  22  ORed SSP0, SSP1                  */
+	SSP1_IRQn                         =  22,/*!<  22  ORed SSP0, SSP1                  */
+	EVENTROUTER_IRQn                  =  23,/*!<  23  EVENTROUTER                      */
+	USART0_IRQn                       =  24,/*!<  24  USART0                           */
+	UART1_IRQn                        =  25,/*!<  25  UART1                            */
+	USART2_IRQn                       =  26,/*!<  26  ORed USART2/C_CAN1               */
+	C_CAN1_IRQn                       =  26,/*!<  26  ORed USART2/C_CAN1               */
+	USART3_IRQn                       =  27,/*!<  27  USART3                           */
+	I2S0_IRQn                         =  28,/*!<  28  ORed I2S0, I2S1                  */
+	I2S1_IRQn                         =  28,/*!<  28  ORed I2S0, I2S1                  */
+	C_CAN0_IRQn                       =  29,/*!<  29  C_CAN0                           */
+	ADCHS_IRQn                        =  30,/*!<  30  ADCHS interrupt                  */
+	M0APP_IRQn                        =  31,/*!<  31  M0SUB                            */
+} LPC43XX_M0_IRQn_Type;
+
+/**
+ * @}
+ */
+
+typedef LPC43XX_M0_IRQn_Type IRQn_Type;
+
+/* Cortex-M4 processor and core peripherals */
+#include "core_cm0.h"
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef __CMSIS_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis.h ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/cmsis.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/cmsis.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,69 @@
+/*
+ * @brief LPC11xx selective CMSIS inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_H_
+#define __CMSIS_H_
+
+#include "lpc_types.h"
+#include "sys_config.h"
+
+/* Select correct CMSIS include file based on CHIP_* definition */
+#if defined(CHIP_LPC43XX)
+
+#ifdef CORE_M4
+#include "cmsis_43xx.h"
+
+#elif defined(CORE_M0)
+#if defined(LPC43XX_CORE_M0APP)
+#include "cmsis_43xx_m0app.h"
+
+#elif (defined(LPC43XX_CORE_M0SUB))
+#include "cmsis_43xx_m0sub.h"
+
+#else
+#error "LPC43XX_CORE_M0APP or LPC43XX_CORE_M0SUB must be defined"
+#endif
+
+#else
+#error "CORE_M0 or CORE_M4 must be defined for CHIP_LPC43XX"
+#endif
+
+#elif defined(CHIP_LPC18XX)
+#include "cmsis_18xx.h"
+
+#else
+#error "No CHIP_* definition is defined"
+#endif
+
+#endif /* __CMSIS_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/cmsis_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/cmsis_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/cmsis_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/cmsis_43xx.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,173 @@
+/*
+ * @brief Basic CMSIS include file for LPC43XX
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_43XX_M0_H_
+#define __CMSIS_43XX_M0_H_
+
+#ifndef __CMSIS_H_
+#error "cmsis_43xx.h should not be included directly use cmsis.h instead"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_43XX CHIP: LPC43xx CMSIS include file
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/** @defgroup CMSIS_43XX_COMMON CHIP: LPC43xx Cortex CMSIS definitions
+ * @{
+ */
+
+#define __CM4_REV              0x0001		/*!< Cortex-M4 Core Revision               */
+#define __MPU_PRESENT             1			/*!< MPU present or not                    */
+#define __NVIC_PRIO_BITS          3			/*!< Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used */
+#define __FPU_PRESENT             1			/*!< FPU present or not                    */
+
+/**
+ * @}
+ */
+
+/** @defgroup CMSIS_43XX_IRQ CHIP: LPC43xx peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/* -------------------------  Cortex-M4 Processor Exceptions Numbers  ----------------------------- */
+	Reset_IRQn                        = -15,/*!<   1  Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn               = -14,/*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
+	HardFault_IRQn                    = -13,/*!<   3  Hard Fault, all classes of Fault */
+	MemoryManagement_IRQn             = -12,/*!<   4  Memory Management, MPU mismatch, including Access Violation and No Match */
+	BusFault_IRQn                     = -11,/*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault */
+	UsageFault_IRQn                   = -10,/*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition */
+	SVCall_IRQn                       =  -5,/*!<  11  System Service Call via SVC instruction */
+	DebugMonitor_IRQn                 =  -4,/*!<  12  Debug Monitor                    */
+	PendSV_IRQn                       =  -2,/*!<  14  Pendable request for system service */
+	SysTick_IRQn                      =  -1,/*!<  15  System Tick Timer                */
+
+	/* ---------------------------  LPC18xx/43xx Specific Interrupt Numbers  ------------------------------- */
+	DAC_IRQn                          =   0,/*!<   0  DAC                              */
+	M0APP_IRQn                        =   1,/*!<   1  M0APP Core interrupt             */
+	DMA_IRQn                          =   2,/*!<   2  DMA                              */
+	RESERVED1_IRQn                    =   3,/*!<   3  EZH/EDM                          */
+	RESERVED2_IRQn                    =   4,
+	ETHERNET_IRQn                     =   5,/*!<   5  ETHERNET                         */
+	SDIO_IRQn                         =   6,/*!<   6  SDIO                             */
+	LCD_IRQn                          =   7,/*!<   7  LCD                              */
+	USB0_IRQn                         =   8,/*!<   8  USB0                             */
+	USB1_IRQn                         =   9,/*!<   9  USB1                             */
+	SCT_IRQn                          =  10,/*!<  10  SCT                              */
+	RITIMER_IRQn                      =  11,/*!<  11  RITIMER                          */
+	TIMER0_IRQn                       =  12,/*!<  12  TIMER0                           */
+	TIMER1_IRQn                       =  13,/*!<  13  TIMER1                           */
+	TIMER2_IRQn                       =  14,/*!<  14  TIMER2                           */
+	TIMER3_IRQn                       =  15,/*!<  15  TIMER3                           */
+	MCPWM_IRQn                        =  16,/*!<  16  MCPWM                            */
+	ADC0_IRQn                         =  17,/*!<  17  ADC0                             */
+	I2C0_IRQn                         =  18,/*!<  18  I2C0                             */
+	I2C1_IRQn                         =  19,/*!<  19  I2C1                             */
+	SPI_INT_IRQn                      =  20,/*!<  20  SPI_INT                          */
+	ADC1_IRQn                         =  21,/*!<  21  ADC1                             */
+	SSP0_IRQn                         =  22,/*!<  22  SSP0                             */
+	SSP1_IRQn                         =  23,/*!<  23  SSP1                             */
+	USART0_IRQn                       =  24,/*!<  24  USART0                           */
+	UART1_IRQn                        =  25,/*!<  25  UART1                            */
+	USART2_IRQn                       =  26,/*!<  26  USART2                           */
+	USART3_IRQn                       =  27,/*!<  27  USART3                           */
+	I2S0_IRQn                         =  28,/*!<  28  I2S0                             */
+	I2S1_IRQn                         =  29,/*!<  29  I2S1                             */
+	RESERVED4_IRQn                    =  30,
+	SGPIO_INT_IRQn                    =  31,/*!<  31  SGPIO_IINT                       */
+	PIN_INT0_IRQn                     =  32,/*!<  32  PIN_INT0                         */
+	PIN_INT1_IRQn                     =  33,/*!<  33  PIN_INT1                         */
+	PIN_INT2_IRQn                     =  34,/*!<  34  PIN_INT2                         */
+	PIN_INT3_IRQn                     =  35,/*!<  35  PIN_INT3                         */
+	PIN_INT4_IRQn                     =  36,/*!<  36  PIN_INT4                         */
+	PIN_INT5_IRQn                     =  37,/*!<  37  PIN_INT5                         */
+	PIN_INT6_IRQn                     =  38,/*!<  38  PIN_INT6                         */
+	PIN_INT7_IRQn                     =  39,/*!<  39  PIN_INT7                         */
+	GINT0_IRQn                        =  40,/*!<  40  GINT0                            */
+	GINT1_IRQn                        =  41,/*!<  41  GINT1                            */
+	EVENTROUTER_IRQn                  =  42,/*!<  42  EVENTROUTER                      */
+	C_CAN1_IRQn                       =  43,/*!<  43  C_CAN1                           */
+	RESERVED6_IRQn                    =  44,
+	ADCHS_IRQn                        =  45,/*!<  45  ADCHS interrupt                  */
+	ATIMER_IRQn                       =  46,/*!<  46  ATIMER                           */
+	RTC_IRQn                          =  47,/*!<  47  RTC                              */
+	RESERVED8_IRQn                    =  48,
+	WWDT_IRQn                         =  49,/*!<  49  WWDT                             */
+	M0SUB_IRQn                        =  50,/*!<  50  M0SUB core interrupt             */
+	C_CAN0_IRQn                       =  51,/*!<  51  C_CAN0                           */
+	QEI_IRQn                          =  52,/*!<  52  QEI                              */
+} LPC43XX_IRQn_Type;
+
+/**
+ * @}
+ */
+
+typedef LPC43XX_IRQn_Type IRQn_Type;
+
+/* Cortex-M4 processor and core peripherals */
+#include "core_cm4.h"
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef __CMSIS_43XX_M0_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/sys_config.h ./libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/sys_config.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/sys_config.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/config_43xx/sys_config.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,42 @@
+/*
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SYS_CONFIG_H_
+#define __SYS_CONFIG_H_
+
+/* LPC43xx chip family */
+#define CHIP_LPC43XX
+
+#endif /* __SYS_CONFIG_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm0.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm0.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm0.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm0.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,688 @@
+/**************************************************************************//**
+ * @file     core_cm0.h
+ * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM0_H_GENERIC
+#define __CORE_CM0_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex_M0
+  @{
+ */
+
+/*  CMSIS CM0 definitions */
+#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
+#define __CM0_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
+                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_CM0_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM0_H_DEPENDANT
+#define __CORE_CM0_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM0_REV
+    #define __CM0_REV               0x0000
+    #warning "__CM0_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          2
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex_M0 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[31];
+  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
+       uint32_t RSERVED1[31];
+  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
+       uint32_t RESERVED2[31];
+  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
+       uint32_t RESERVED3[31];
+       uint32_t RESERVED4[64];
+  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
+}  NVIC_Type;
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+       uint32_t RESERVED0;
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+       uint32_t RESERVED1;
+  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
+                are only accessible over DAP and not via processor. Therefore
+                they are not covered by the Cortex-M0 header file.
+  @{
+ */
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M0 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
+
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
+/* The following MACROS handle generation of the register offset and byte masks */
+#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
+#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
+#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+  else {
+    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
+  else {
+    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 SCB_AIRCR_SYSRESETREQ_Msk);
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+
+#endif /* __CORE_CM0_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm0plus.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm0plus.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm0plus.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm0plus.h	2018-12-01 17:15:06.641606442 -0300
@@ -0,0 +1,799 @@
+/**************************************************************************//**
+ * @file     core_cm0plus.h
+ * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM0PLUS_H_GENERIC
+#define __CORE_CM0PLUS_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex-M0+
+  @{
+ */
+
+/*  CMSIS CM0P definitions */
+#define __CM0PLUS_CMSIS_VERSION_MAIN (0x03)                                /*!< [31:16] CMSIS HAL main version   */
+#define __CM0PLUS_CMSIS_VERSION_SUB  (0x20)                                /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16) | \
+                                       __CM0PLUS_CMSIS_VERSION_SUB)        /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_CM0PLUS_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM0PLUS_H_DEPENDANT
+#define __CORE_CM0PLUS_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM0PLUS_REV
+    #define __CM0PLUS_REV             0x0000
+    #warning "__CM0PLUS_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __VTOR_PRESENT
+    #define __VTOR_PRESENT            0
+    #warning "__VTOR_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          2
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex-M0+ */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core MPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[31];
+  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
+       uint32_t RSERVED1[31];
+  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
+       uint32_t RESERVED2[31];
+  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
+       uint32_t RESERVED3[31];
+       uint32_t RESERVED4[64];
+  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
+}  NVIC_Type;
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+#if (__VTOR_PRESENT == 1)
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+#else
+       uint32_t RESERVED0;
+#endif
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+       uint32_t RESERVED1;
+  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+#if (__VTOR_PRESENT == 1)
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 8                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
+#endif
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   8                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR)
+                are only accessible over DAP and not via processor. Therefore
+                they are not covered by the Cortex-M0 header file.
+  @{
+ */
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M0+ Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
+
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
+/* The following MACROS handle generation of the register offset and byte masks */
+#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
+#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
+#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+  else {
+    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
+  else {
+    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 SCB_AIRCR_SYSRESETREQ_Msk);
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+
+#endif /* __CORE_CM0PLUS_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm3.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm3.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm3.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm3.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,1633 @@
+/**************************************************************************//**
+ * @file     core_cm3.h
+ * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM3_H_GENERIC
+#define __CORE_CM3_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex_M3
+  @{
+ */
+
+/*  CMSIS CM3 definitions */
+#define __CM3_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
+#define __CM3_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
+                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TMS470__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TMS470__ )
+  #if defined __TI__VFP_SUPPORT____
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_CM3_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM3_H_DEPENDANT
+#define __CORE_CM3_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM3_REV
+    #define __CM3_REV               0x0200
+    #warning "__CM3_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          4
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex_M3 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core Debug Register
+  - Core MPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+
+/* Software Triggered Interrupt Register Definitions */
+#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
+#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
+  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
+  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
+  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
+  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
+  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
+       uint32_t RESERVED0[5];
+  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Vector Table Offset Register Definitions */
+#if (__CM3_REV < 0x0201)                   /* core r2p1 */
+#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
+#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
+
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
+#else
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
+#endif
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
+#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
+  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
+#else
+       uint32_t RESERVED1[1];
+#endif
+} SCnSCB_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
+#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
+
+/* Auxiliary Control Register Definitions */
+
+#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
+#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
+
+#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
+#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
+
+#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
+#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
+    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+
+/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
+  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
+  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
+  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
+#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+
+/*@}*/ /* end of group CMSIS_ITM */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
+    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
+  @{
+ */
+
+/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
+  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
+  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
+  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
+  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
+  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
+  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
+  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
+  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
+  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
+  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
+       uint32_t RESERVED0[1];
+  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
+  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
+  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
+       uint32_t RESERVED1[1];
+  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
+  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
+  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
+       uint32_t RESERVED2[1];
+  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
+  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
+  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
+} DWT_Type;
+
+/* DWT Control Register Definitions */
+#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
+#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
+
+#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
+#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
+
+#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
+#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
+
+#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
+#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
+
+#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
+#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
+
+#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
+#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
+
+#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
+#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
+
+#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
+#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
+
+#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
+#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
+
+#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
+#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
+
+#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
+#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
+
+#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
+#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
+
+#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
+#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
+
+#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
+#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
+
+#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
+#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
+
+#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
+#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
+
+#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
+#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
+
+#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
+#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
+
+/* DWT CPI Count Register Definitions */
+#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
+#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
+
+/* DWT Exception Overhead Count Register Definitions */
+#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
+#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
+
+/* DWT Sleep Count Register Definitions */
+#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
+#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
+
+/* DWT LSU Count Register Definitions */
+#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
+#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
+
+/* DWT Folded-instruction Count Register Definitions */
+#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
+#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
+
+/* DWT Comparator Mask Register Definitions */
+#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
+#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
+
+/* DWT Comparator Function Register Definitions */
+#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
+#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
+
+#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
+#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
+
+#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
+#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
+
+#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
+#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
+
+#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
+#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
+
+#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
+#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
+
+#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
+#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
+
+#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
+#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
+
+#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
+#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
+
+/*@}*/ /* end of group CMSIS_DWT */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
+    \brief      Type definitions for the Trace Port Interface (TPI)
+  @{
+ */
+
+/** \brief  Structure type to access the Trace Port Interface Register (TPI).
+ */
+typedef struct
+{
+  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
+  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
+       uint32_t RESERVED1[55];
+  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
+       uint32_t RESERVED2[131];
+  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
+  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
+  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
+       uint32_t RESERVED3[759];
+  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
+  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
+  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
+       uint32_t RESERVED4[1];
+  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
+  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
+  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
+       uint32_t RESERVED5[39];
+  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
+  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
+       uint32_t RESERVED7[8];
+  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
+  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
+} TPI_Type;
+
+/* TPI Asynchronous Clock Prescaler Register Definitions */
+#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
+#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
+
+/* TPI Selected Pin Protocol Register Definitions */
+#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
+#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
+
+/* TPI Formatter and Flush Status Register Definitions */
+#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
+#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
+
+#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
+#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
+
+#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
+#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
+
+#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
+#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
+
+/* TPI Formatter and Flush Control Register Definitions */
+#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
+#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
+
+#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
+#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
+
+/* TPI TRIGGER Register Definitions */
+#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
+#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
+
+/* TPI Integration ETM Data Register Definitions (FIFO0) */
+#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
+#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
+
+#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
+#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
+
+#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
+#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
+
+#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
+#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
+
+#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
+#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
+
+#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
+#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
+
+#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
+#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
+
+/* TPI ITATBCTR2 Register Definitions */
+#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
+#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
+
+/* TPI Integration ITM Data Register Definitions (FIFO1) */
+#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
+#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
+
+#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
+#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
+
+#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
+#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
+
+#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
+#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
+
+#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
+#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
+
+#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
+#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
+
+#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
+#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
+
+/* TPI ITATBCTR0 Register Definitions */
+#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
+#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
+
+/* TPI Integration Mode Control Register Definitions */
+#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
+#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
+
+/* TPI DEVID Register Definitions */
+#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
+#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
+
+#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
+#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
+
+#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
+#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
+
+#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
+#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
+
+#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
+#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
+
+#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
+#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
+
+/* TPI DEVTYPE Register Definitions */
+#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
+#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
+
+#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
+#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
+
+/*@}*/ /* end of group CMSIS_TPI */
+
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Type definitions for the Core Debug Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Core Debug Register (CoreDebug).
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M3 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
+#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
+#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
+#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
+#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
+#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
+#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Debug Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/** \brief  Set Priority Grouping
+
+  The function sets the priority grouping field using the required unlock sequence.
+  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
+  Only values from 0..7 are used.
+  In case of a conflict between priority grouping and available
+  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
+
+    \param [in]      PriorityGroup  Priority grouping field.
+ */
+__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                                 |
+                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+
+/** \brief  Get Priority Grouping
+
+  The function reads the priority grouping field from the NVIC Interrupt Controller.
+
+    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Get Active Interrupt
+
+    The function reads the active register in NVIC and returns the active bit.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not active.
+    \return             1  Interrupt status is active.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  Encode Priority
+
+    The function encodes the priority for an interrupt with the given priority group,
+    preemptive priority value, and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
+
+    \param [in]     PriorityGroup  Used priority group.
+    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
+    \param [in]       SubPriority  Subpriority value (starting from 0).
+    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
+ */
+__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/** \brief  Decode Priority
+
+    The function decodes an interrupt priority value with a given priority group to
+    preemptive priority value and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+
+    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
+    \param [in]     PriorityGroup  Used priority group.
+    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
+    \param [out]     pSubPriority  Subpriority value (starting from 0).
+ */
+__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_core_DebugFunctions ITM Functions
+    \brief   Functions that access the ITM debug interface.
+  @{
+ */
+
+extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
+#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
+
+
+/** \brief  ITM Send Character
+
+    The function transmits a character via the ITM channel 0, and
+    \li Just returns when no debugger is connected that has booked the output.
+    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
+
+    \param [in]     ch  Character to transmit.
+
+    \returns            Character to transmit.
+ */
+__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/** \brief  ITM Receive Character
+
+    The function inputs a character via the external variable \ref ITM_RxBuffer.
+
+    \return             Received character.
+    \return         -1  No character pending.
+ */
+__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
+  int32_t ch = -1;                           /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/** \brief  ITM Check Character
+
+    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
+
+    \return          0  No character available.
+    \return          1  Character available.
+ */
+__STATIC_INLINE int32_t ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@} end of CMSIS_core_DebugFunctions */
+
+#endif /* __CORE_CM3_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm4.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm4.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm4.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm4.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,1778 @@
+/**************************************************************************//**
+ * @file     core_cm4.h
+ * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_H_GENERIC
+#define __CORE_CM4_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex_M4
+  @{
+ */
+
+/*  CMSIS CM4 definitions */
+#define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
+#define __CM4_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
+                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TMS470__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
+*/
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TMS470__ )
+  #if defined __TI_VFP_SUPPORT__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+#include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
+
+#endif /* __CORE_CM4_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM4_H_DEPENDANT
+#define __CORE_CM4_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM4_REV
+    #define __CM4_REV               0x0000
+    #warning "__CM4_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __FPU_PRESENT
+    #define __FPU_PRESENT             0
+    #warning "__FPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          4
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex_M4 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core Debug Register
+  - Core MPU Register
+  - Core FPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+
+/* Software Triggered Interrupt Register Definitions */
+#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
+#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
+  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
+  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
+  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
+  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
+  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
+       uint32_t RESERVED0[5];
+  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Vector Table Offset Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
+  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
+} SCnSCB_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
+#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
+
+/* Auxiliary Control Register Definitions */
+#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
+#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
+
+#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
+#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
+
+#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
+#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
+
+#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
+#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
+
+#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
+#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
+    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+
+/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
+  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
+  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
+  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
+#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+
+/*@}*/ /* end of group CMSIS_ITM */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
+    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
+  @{
+ */
+
+/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
+  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
+  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
+  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
+  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
+  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
+  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
+  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
+  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
+  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
+  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
+       uint32_t RESERVED0[1];
+  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
+  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
+  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
+       uint32_t RESERVED1[1];
+  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
+  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
+  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
+       uint32_t RESERVED2[1];
+  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
+  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
+  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
+} DWT_Type;
+
+/* DWT Control Register Definitions */
+#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
+#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
+
+#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
+#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
+
+#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
+#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
+
+#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
+#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
+
+#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
+#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
+
+#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
+#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
+
+#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
+#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
+
+#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
+#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
+
+#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
+#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
+
+#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
+#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
+
+#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
+#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
+
+#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
+#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
+
+#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
+#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
+
+#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
+#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
+
+#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
+#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
+
+#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
+#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
+
+#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
+#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
+
+#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
+#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
+
+/* DWT CPI Count Register Definitions */
+#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
+#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
+
+/* DWT Exception Overhead Count Register Definitions */
+#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
+#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
+
+/* DWT Sleep Count Register Definitions */
+#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
+#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
+
+/* DWT LSU Count Register Definitions */
+#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
+#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
+
+/* DWT Folded-instruction Count Register Definitions */
+#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
+#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
+
+/* DWT Comparator Mask Register Definitions */
+#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
+#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
+
+/* DWT Comparator Function Register Definitions */
+#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
+#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
+
+#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
+#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
+
+#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
+#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
+
+#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
+#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
+
+#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
+#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
+
+#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
+#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
+
+#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
+#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
+
+#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
+#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
+
+#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
+#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
+
+/*@}*/ /* end of group CMSIS_DWT */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
+    \brief      Type definitions for the Trace Port Interface (TPI)
+  @{
+ */
+
+/** \brief  Structure type to access the Trace Port Interface Register (TPI).
+ */
+typedef struct
+{
+  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
+  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
+       uint32_t RESERVED1[55];
+  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
+       uint32_t RESERVED2[131];
+  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
+  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
+  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
+       uint32_t RESERVED3[759];
+  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
+  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
+  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
+       uint32_t RESERVED4[1];
+  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
+  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
+  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
+       uint32_t RESERVED5[39];
+  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
+  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
+       uint32_t RESERVED7[8];
+  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
+  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
+} TPI_Type;
+
+/* TPI Asynchronous Clock Prescaler Register Definitions */
+#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
+#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
+
+/* TPI Selected Pin Protocol Register Definitions */
+#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
+#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
+
+/* TPI Formatter and Flush Status Register Definitions */
+#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
+#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
+
+#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
+#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
+
+#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
+#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
+
+#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
+#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
+
+/* TPI Formatter and Flush Control Register Definitions */
+#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
+#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
+
+#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
+#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
+
+/* TPI TRIGGER Register Definitions */
+#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
+#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
+
+/* TPI Integration ETM Data Register Definitions (FIFO0) */
+#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
+#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
+
+#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
+#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
+
+#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
+#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
+
+#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
+#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
+
+#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
+#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
+
+#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
+#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
+
+#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
+#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
+
+/* TPI ITATBCTR2 Register Definitions */
+#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
+#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
+
+/* TPI Integration ITM Data Register Definitions (FIFO1) */
+#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
+#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
+
+#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
+#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
+
+#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
+#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
+
+#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
+#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
+
+#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
+#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
+
+#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
+#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
+
+#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
+#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
+
+/* TPI ITATBCTR0 Register Definitions */
+#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
+#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
+
+/* TPI Integration Mode Control Register Definitions */
+#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
+#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
+
+/* TPI DEVID Register Definitions */
+#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
+#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
+
+#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
+#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
+
+#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
+#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
+
+#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
+#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
+
+#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
+#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
+
+#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
+#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
+
+/* TPI DEVTYPE Register Definitions */
+#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
+#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
+
+#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
+#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
+
+/*@}*/ /* end of group CMSIS_TPI */
+
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+#if (__FPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
+    \brief      Type definitions for the Floating Point Unit (FPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Floating Point Unit (FPU).
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
+  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
+  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
+  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
+  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
+} FPU_Type;
+
+/* Floating-Point Context Control Register */
+#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
+#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
+
+#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
+#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
+
+#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
+#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
+
+#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
+#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
+
+#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
+#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
+
+#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
+#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
+
+#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
+#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
+
+#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
+#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
+
+#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
+#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
+
+/* Floating-Point Context Address Register */
+#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
+#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
+
+/* Floating-Point Default Status Control Register */
+#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
+#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
+
+#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
+#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
+
+#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
+#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
+
+#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
+#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
+
+/* Media and FP Feature Register 0 */
+#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
+#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
+
+#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
+#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
+
+#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
+#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
+
+#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
+#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
+
+#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
+#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
+
+#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
+#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
+
+#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
+#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
+
+#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
+#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
+
+/* Media and FP Feature Register 1 */
+#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
+#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
+
+#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
+#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
+
+#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
+#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
+
+#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
+#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
+
+/*@} end of group CMSIS_FPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Type definitions for the Core Debug Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Core Debug Register (CoreDebug).
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M4 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
+#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
+#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
+#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
+#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
+#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
+#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+#if (__FPU_PRESENT == 1)
+  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
+  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Debug Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/** \brief  Set Priority Grouping
+
+  The function sets the priority grouping field using the required unlock sequence.
+  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
+  Only values from 0..7 are used.
+  In case of a conflict between priority grouping and available
+  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
+
+    \param [in]      PriorityGroup  Priority grouping field.
+ */
+__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                                 |
+                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+
+/** \brief  Get Priority Grouping
+
+  The function reads the priority grouping field from the NVIC Interrupt Controller.
+
+    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
+  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Get Active Interrupt
+
+    The function reads the active register in NVIC and returns the active bit.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not active.
+    \return             1  Interrupt status is active.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  Encode Priority
+
+    The function encodes the priority for an interrupt with the given priority group,
+    preemptive priority value, and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
+
+    \param [in]     PriorityGroup  Used priority group.
+    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
+    \param [in]       SubPriority  Subpriority value (starting from 0).
+    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
+ */
+__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/** \brief  Decode Priority
+
+    The function decodes an interrupt priority value with a given priority group to
+    preemptive priority value and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+
+    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
+    \param [in]     PriorityGroup  Used priority group.
+    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
+    \param [out]     pSubPriority  Subpriority value (starting from 0).
+ */
+__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_core_DebugFunctions ITM Functions
+    \brief   Functions that access the ITM debug interface.
+  @{
+ */
+
+extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
+#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
+
+
+/** \brief  ITM Send Character
+
+    The function transmits a character via the ITM channel 0, and
+    \li Just returns when no debugger is connected that has booked the output.
+    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
+
+    \param [in]     ch  Character to transmit.
+
+    \returns            Character to transmit.
+ */
+__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/** \brief  ITM Receive Character
+
+    The function inputs a character via the external variable \ref ITM_RxBuffer.
+
+    \return             Received character.
+    \return         -1  No character pending.
+ */
+__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
+  int32_t ch = -1;                           /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/** \brief  ITM Check Character
+
+    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
+
+    \return          0  No character available.
+    \return          1  Character available.
+ */
+__STATIC_INLINE int32_t ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@} end of CMSIS_core_DebugFunctions */
+
+#endif /* __CORE_CM4_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm4_simd.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm4_simd.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cm4_simd.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cm4_simd.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,679 @@
+/**************************************************************************//**
+ * @file     core_cm4_simd.h
+ * @brief    CMSIS Cortex-M4 SIMD Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_SIMD_H
+#define __CORE_CM4_SIMD_H
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+ ******************************************************************************/
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
+  Access to dedicated SIMD instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#define __SADD8                           __sadd8
+#define __QADD8                           __qadd8
+#define __SHADD8                          __shadd8
+#define __UADD8                           __uadd8
+#define __UQADD8                          __uqadd8
+#define __UHADD8                          __uhadd8
+#define __SSUB8                           __ssub8
+#define __QSUB8                           __qsub8
+#define __SHSUB8                          __shsub8
+#define __USUB8                           __usub8
+#define __UQSUB8                          __uqsub8
+#define __UHSUB8                          __uhsub8
+#define __SADD16                          __sadd16
+#define __QADD16                          __qadd16
+#define __SHADD16                         __shadd16
+#define __UADD16                          __uadd16
+#define __UQADD16                         __uqadd16
+#define __UHADD16                         __uhadd16
+#define __SSUB16                          __ssub16
+#define __QSUB16                          __qsub16
+#define __SHSUB16                         __shsub16
+#define __USUB16                          __usub16
+#define __UQSUB16                         __uqsub16
+#define __UHSUB16                         __uhsub16
+#define __SASX                            __sasx
+#define __QASX                            __qasx
+#define __SHASX                           __shasx
+#define __UASX                            __uasx
+#define __UQASX                           __uqasx
+#define __UHASX                           __uhasx
+#define __SSAX                            __ssax
+#define __QSAX                            __qsax
+#define __SHSAX                           __shsax
+#define __USAX                            __usax
+#define __UQSAX                           __uqsax
+#define __UHSAX                           __uhsax
+#define __USAD8                           __usad8
+#define __USADA8                          __usada8
+#define __SSAT16                          __ssat16
+#define __USAT16                          __usat16
+#define __UXTB16                          __uxtb16
+#define __UXTAB16                         __uxtab16
+#define __SXTB16                          __sxtb16
+#define __SXTAB16                         __sxtab16
+#define __SMUAD                           __smuad
+#define __SMUADX                          __smuadx
+#define __SMLAD                           __smlad
+#define __SMLADX                          __smladx
+#define __SMLALD                          __smlald
+#define __SMLALDX                         __smlaldx
+#define __SMUSD                           __smusd
+#define __SMUSDX                          __smusdx
+#define __SMLSD                           __smlsd
+#define __SMLSDX                          __smlsdx
+#define __SMLSLD                          __smlsld
+#define __SMLSLDX                         __smlsldx
+#define __SEL                             __sel
+#define __QADD                            __qadd
+#define __QSUB                            __qsub
+
+#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
+                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
+
+#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
+                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
+
+#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
+                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_iar.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_ccs.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SSAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+#define __USAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLALD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLALDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLSLD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLSLDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+#define __PKHBT(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+#define __PKHTB(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  if (ARG3 == 0) \
+    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
+  else \
+    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
+{
+ int32_t result;
+
+ __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
+ return(result);
+}
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+/* not yet supported */
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+#endif
+
+/*@} end of group CMSIS_SIMD_intrinsics */
+
+
+#endif /* __CORE_CM4_SIMD_H */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cmFunc.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cmFunc.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cmFunc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cmFunc.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,642 @@
+/**************************************************************************//**
+ * @file     core_cmFunc.h
+ * @brief    CMSIS Cortex-M Core Function Access Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMFUNC_H
+#define __CORE_CMFUNC_H
+
+
+/* ###########################  Core Function Access  ########################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
+  @{
+ */
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM("control");
+  return(__regControl);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM("control");
+  __regControl = control;
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  register uint32_t __regIPSR          __ASM("ipsr");
+  return(__regIPSR);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__STATIC_INLINE uint32_t __get_APSR(void)
+{
+  register uint32_t __regAPSR          __ASM("apsr");
+  return(__regAPSR);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  register uint32_t __regXPSR          __ASM("xpsr");
+  return(__regXPSR);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  return(__regProcessStackPointer);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  __regProcessStackPointer = topOfProcStack;
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  return(__regMainStackPointer);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  __regMainStackPointer = topOfMainStack;
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  return(__regPriMask);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  __regPriMask = (priMask);
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __enable_fault_irq                __enable_fiq
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __disable_fault_irq               __disable_fiq
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__STATIC_INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  return(__regBasePri);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  __regBasePri = (basePri & 0xff);
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  return(__regFaultMask);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  __regFaultMask = (faultMask & (uint32_t)1);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  return(__regfpscr);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  __regfpscr = (fpscr);
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/** \brief  Enable IRQ Interrupts
+
+  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
+{
+  __ASM volatile ("cpsie i" : : : "memory");
+}
+
+
+/** \brief  Disable IRQ Interrupts
+
+  This function disables IRQ interrupts by setting the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
+{
+  __ASM volatile ("cpsid i" : : : "memory");
+}
+
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, control" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
+{
+  __ASM volatile ("cpsie f" : : : "memory");
+}
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
+{
+  __ASM volatile ("cpsid f" : : : "memory");
+}
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  uint32_t result;
+
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
+  __ASM volatile ("");
+  return(result);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
+  __ASM volatile ("");
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@} end of CMSIS_Core_RegAccFunctions */
+
+
+#endif /* __CORE_CMFUNC_H */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cmInstr.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_cmInstr.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_cmInstr.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_cmInstr.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,694 @@
+/**************************************************************************//**
+ * @file     core_cmInstr.h
+ * @brief    CMSIS Cortex-M Core Instruction Access Header File
+ * @version  V3.20
+ * @date     05. March 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMINSTR_H
+#define __CORE_CMINSTR_H
+
+
+/* ##########################  Core Instruction Access  ######################### */
+/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
+  Access to dedicated instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+#define __NOP                             __nop
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+#define __WFI                             __wfi
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+#define __WFE                             __wfe
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+#define __SEV                             __sev
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+#define __ISB()                           __isb(0xF)
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+#define __DSB()                           __dsb(0xF)
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+#define __DMB()                           __dmb(0xF)
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __REV                             __rev
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+#endif
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+#endif
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+#define __ROR                             __ror
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __breakpoint(value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __RBIT                            __rbit
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXB(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXH(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+#define __CLREX                           __clrex
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT                            __ssat
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT                            __usat
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+#define __CLZ                             __clz
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/* Define macros for porting to both thumb1 and thumb2.
+ * For thumb1, use low register (r0-r7), specified by constrant "l"
+ * Otherwise, use general registers, specified by constrant "r" */
+#if defined (__thumb__) && !defined (__thumb2__)
+#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
+#define __CMSIS_GCC_USE_REG(r) "l" (r)
+#else
+#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
+#define __CMSIS_GCC_USE_REG(r) "r" (r)
+#endif
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
+{
+  __ASM volatile ("nop");
+}
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
+{
+  __ASM volatile ("wfi");
+}
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
+{
+  __ASM volatile ("wfe");
+}
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
+{
+  __ASM volatile ("sev");
+}
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
+{
+  __ASM volatile ("isb");
+}
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
+{
+  __ASM volatile ("dsb");
+}
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
+{
+  __ASM volatile ("dmb");
+}
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+  return __builtin_bswap32(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
+{
+  uint32_t result;
+
+  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+}
+
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+  return (short)__builtin_bswap16(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
+{
+  return (op1 >> op2) | (op1 << (32 - op2)); 
+}
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result;
+
+   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
+{
+    uint32_t result;
+
+   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
+{
+  __ASM volatile ("clrex" ::: "memory");
+}
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
+{
+   uint32_t result;
+
+  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all intrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
+
+#endif /* __CORE_CMINSTR_H */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_sc000.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_sc000.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_sc000.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_sc000.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,819 @@
+/**************************************************************************//**
+ * @file     core_sc000.h
+ * @brief    CMSIS SC000 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_SC000_H_GENERIC
+#define __CORE_SC000_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup SC000
+  @{
+ */
+
+/*  CMSIS SC000 definitions */
+#define __SC000_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version */
+#define __SC000_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version  */
+#define __SC000_CMSIS_VERSION       ((__SC000_CMSIS_VERSION_MAIN << 16) | \
+                                      __SC000_CMSIS_VERSION_SUB          )   /*!< CMSIS HAL version number       */
+
+#define __CORTEX_SC                (0)                                       /*!< Cortex secure core             */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_SC000_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_SC000_H_DEPENDANT
+#define __CORE_SC000_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __SC000_REV
+    #define __SC000_REV             0x0000
+    #warning "__SC000_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          2
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group SC000 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core MPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[31];
+  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
+       uint32_t RSERVED1[31];
+  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
+       uint32_t RESERVED2[31];
+  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
+       uint32_t RESERVED3[31];
+       uint32_t RESERVED4[64];
+  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
+}  NVIC_Type;
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+       uint32_t RESERVED0[1];
+  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+       uint32_t RESERVED1[154];
+  __IO uint32_t SFCR;                    /*!< Offset: 0x290 (R/W)  Security Features Register                            */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+/* SCB Security Features Register Definitions */
+#define SCB_SFCR_UNIBRTIMING_Pos            0                                             /*!< SCB SFCR: UNIBRTIMING Position */
+#define SCB_SFCR_UNIBRTIMING_Msk           (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SFCR: UNIBRTIMING Mask */
+
+#define SCB_SFCR_SECKEY_Pos                16                                             /*!< SCB SFCR: SECKEY Position */
+#define SCB_SFCR_SECKEY_Msk               (0xFFFFUL << SCB_SHCSR_SVCALLPENDED_Pos)        /*!< SCB SFCR: SECKEY Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
+} SCnSCB_Type;
+
+/* Auxiliary Control Register Definitions */
+#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
+#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   8                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      SC000 Core Debug Registers (DCB registers, SHCSR, and DFSR)
+                are only accessible over DAP and not via processor. Therefore
+                they are not covered by the Cortex-M0 header file.
+  @{
+ */
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of SC000 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
+/* The following MACROS handle generation of the register offset and byte masks */
+#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
+#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
+#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+  else {
+    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
+  else {
+    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 SCB_AIRCR_SYSRESETREQ_Msk);
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+
+#endif /* __CORE_SC000_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_sc300.h ./libs/vendor_libs/lpc_chip_43xx/inc/core_sc300.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/core_sc300.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/core_sc300.h	2018-12-01 17:15:06.645606492 -0300
@@ -0,0 +1,1604 @@
+/**************************************************************************//**
+ * @file     core_sc300.h
+ * @brief    CMSIS SC300 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_SC300_H_GENERIC
+#define __CORE_SC300_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup SC3000
+  @{
+ */
+
+/*  CMSIS SC300 definitions */
+#define __SC300_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version */
+#define __SC300_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version  */
+#define __SC300_CMSIS_VERSION       ((__SC300_CMSIS_VERSION_MAIN << 16) | \
+                                      __SC300_CMSIS_VERSION_SUB          )   /*!< CMSIS HAL version number       */
+
+#define __CORTEX_SC                (300)                                     /*!< Cortex secure core             */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
+  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_SC300_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_SC300_H_DEPENDANT
+#define __CORE_SC300_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __SC300_REV
+    #define __SC300_REV               0x0000
+    #warning "__SC300_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          4
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group SC300 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core Debug Register
+  - Core MPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+
+/* Software Triggered Interrupt Register Definitions */
+#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
+#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
+  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
+  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
+  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
+  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
+  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
+       uint32_t RESERVED0[5];
+  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Vector Table Offset Register Definitions */
+#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
+#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
+
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
+       uint32_t RESERVED1[1];
+} SCnSCB_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
+#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
+    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+
+/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
+  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
+  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
+  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
+#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+
+/*@}*/ /* end of group CMSIS_ITM */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
+    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
+  @{
+ */
+
+/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
+  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
+  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
+  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
+  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
+  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
+  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
+  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
+  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
+  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
+  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
+       uint32_t RESERVED0[1];
+  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
+  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
+  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
+       uint32_t RESERVED1[1];
+  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
+  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
+  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
+       uint32_t RESERVED2[1];
+  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
+  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
+  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
+} DWT_Type;
+
+/* DWT Control Register Definitions */
+#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
+#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
+
+#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
+#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
+
+#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
+#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
+
+#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
+#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
+
+#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
+#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
+
+#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
+#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
+
+#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
+#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
+
+#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
+#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
+
+#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
+#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
+
+#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
+#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
+
+#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
+#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
+
+#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
+#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
+
+#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
+#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
+
+#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
+#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
+
+#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
+#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
+
+#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
+#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
+
+#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
+#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
+
+#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
+#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
+
+/* DWT CPI Count Register Definitions */
+#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
+#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
+
+/* DWT Exception Overhead Count Register Definitions */
+#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
+#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
+
+/* DWT Sleep Count Register Definitions */
+#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
+#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
+
+/* DWT LSU Count Register Definitions */
+#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
+#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
+
+/* DWT Folded-instruction Count Register Definitions */
+#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
+#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
+
+/* DWT Comparator Mask Register Definitions */
+#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
+#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
+
+/* DWT Comparator Function Register Definitions */
+#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
+#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
+
+#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
+#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
+
+#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
+#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
+
+#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
+#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
+
+#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
+#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
+
+#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
+#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
+
+#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
+#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
+
+#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
+#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
+
+#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
+#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
+
+/*@}*/ /* end of group CMSIS_DWT */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
+    \brief      Type definitions for the Trace Port Interface (TPI)
+  @{
+ */
+
+/** \brief  Structure type to access the Trace Port Interface Register (TPI).
+ */
+typedef struct
+{
+  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
+  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
+       uint32_t RESERVED1[55];
+  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
+       uint32_t RESERVED2[131];
+  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
+  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
+  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
+       uint32_t RESERVED3[759];
+  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
+  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
+  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
+       uint32_t RESERVED4[1];
+  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
+  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
+  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
+       uint32_t RESERVED5[39];
+  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
+  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
+       uint32_t RESERVED7[8];
+  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
+  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
+} TPI_Type;
+
+/* TPI Asynchronous Clock Prescaler Register Definitions */
+#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
+#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
+
+/* TPI Selected Pin Protocol Register Definitions */
+#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
+#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
+
+/* TPI Formatter and Flush Status Register Definitions */
+#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
+#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
+
+#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
+#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
+
+#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
+#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
+
+#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
+#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
+
+/* TPI Formatter and Flush Control Register Definitions */
+#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
+#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
+
+#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
+#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
+
+/* TPI TRIGGER Register Definitions */
+#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
+#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
+
+/* TPI Integration ETM Data Register Definitions (FIFO0) */
+#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
+#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
+
+#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
+#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
+
+#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
+#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
+
+#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
+#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
+
+#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
+#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
+
+#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
+#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
+
+#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
+#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
+
+/* TPI ITATBCTR2 Register Definitions */
+#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
+#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
+
+/* TPI Integration ITM Data Register Definitions (FIFO1) */
+#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
+#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
+
+#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
+#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
+
+#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
+#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
+
+#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
+#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
+
+#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
+#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
+
+#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
+#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
+
+#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
+#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
+
+/* TPI ITATBCTR0 Register Definitions */
+#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
+#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
+
+/* TPI Integration Mode Control Register Definitions */
+#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
+#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
+
+/* TPI DEVID Register Definitions */
+#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
+#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
+
+#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
+#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
+
+#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
+#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
+
+#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
+#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
+
+#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
+#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
+
+#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
+#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
+
+/* TPI DEVTYPE Register Definitions */
+#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
+#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
+
+#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
+#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
+
+/*@}*/ /* end of group CMSIS_TPI */
+
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Type definitions for the Core Debug Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Core Debug Register (CoreDebug).
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M3 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
+#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
+#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
+#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
+#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
+#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
+#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Debug Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/** \brief  Set Priority Grouping
+
+  The function sets the priority grouping field using the required unlock sequence.
+  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
+  Only values from 0..7 are used.
+  In case of a conflict between priority grouping and available
+  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
+
+    \param [in]      PriorityGroup  Priority grouping field.
+ */
+__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                                 |
+                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+
+/** \brief  Get Priority Grouping
+
+  The function reads the priority grouping field from the NVIC Interrupt Controller.
+
+    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Get Active Interrupt
+
+    The function reads the active register in NVIC and returns the active bit.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not active.
+    \return             1  Interrupt status is active.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  Encode Priority
+
+    The function encodes the priority for an interrupt with the given priority group,
+    preemptive priority value, and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
+
+    \param [in]     PriorityGroup  Used priority group.
+    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
+    \param [in]       SubPriority  Subpriority value (starting from 0).
+    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
+ */
+__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/** \brief  Decode Priority
+
+    The function decodes an interrupt priority value with a given priority group to
+    preemptive priority value and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+
+    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
+    \param [in]     PriorityGroup  Used priority group.
+    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
+    \param [out]     pSubPriority  Subpriority value (starting from 0).
+ */
+__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_core_DebugFunctions ITM Functions
+    \brief   Functions that access the ITM debug interface.
+  @{
+ */
+
+extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
+#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
+
+
+/** \brief  ITM Send Character
+
+    The function transmits a character via the ITM channel 0, and
+    \li Just returns when no debugger is connected that has booked the output.
+    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
+
+    \param [in]     ch  Character to transmit.
+
+    \returns            Character to transmit.
+ */
+__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/** \brief  ITM Receive Character
+
+    The function inputs a character via the external variable \ref ITM_RxBuffer.
+
+    \return             Received character.
+    \return         -1  No character pending.
+ */
+__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
+  int32_t ch = -1;                           /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/** \brief  ITM Check Character
+
+    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
+
+    \return          0  No character available.
+    \return          1  Character available.
+ */
+__STATIC_INLINE int32_t ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@} end of CMSIS_core_DebugFunctions */
+
+#endif /* __CORE_SC300_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/creg_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/creg_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/creg_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/creg_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,244 @@
+/*
+ * @brief LPC18XX/43XX CREG control functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CREG_18XX_43XX_H_
+#define __CREG_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CREG_18XX_43XX CHIP: LPC18xx/43xx CREG driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief CREG Register Block
+ */
+typedef struct {						/*!< CREG Structure         */
+	__I  uint32_t  RESERVED0;
+	__IO uint32_t  CREG0;				/*!< Chip configuration register 32 kHz oscillator output and BOD control register. */
+	__I  uint32_t  RESERVED1[62];
+	__IO uint32_t  MXMEMMAP;			/*!< ARM Cortex-M3/M4 memory mapping */
+#if defined(CHIP_LPC18XX)
+	__I  uint32_t  RESERVED2[5];
+#else
+	__I  uint32_t  RESERVED2;
+	__I  uint32_t  CREG1;				/*!< Configuration Register 1 */
+	__I  uint32_t  CREG2;				/*!< Configuration Register 2 */
+	__I  uint32_t  CREG3;				/*!< Configuration Register 3 */
+	__I  uint32_t  CREG4;				/*!< Configuration Register 4 */
+#endif
+	__IO uint32_t  CREG5;				/*!< Chip configuration register 5. Controls JTAG access. */
+	__IO uint32_t  DMAMUX;				/*!< DMA muxing control     */
+	__IO uint32_t  FLASHCFGA;			/*!< Flash accelerator configuration register for flash bank A */
+	__IO uint32_t  FLASHCFGB;			/*!< Flash accelerator configuration register for flash bank B */
+	__IO uint32_t  ETBCFG;				/*!< ETB RAM configuration  */
+	__IO uint32_t  CREG6;				/*!< Chip configuration register 6. */
+#if defined(CHIP_LPC18XX)
+	__I  uint32_t  RESERVED4[52];
+#else
+	__IO uint32_t  M4TXEVENT;			/*!< M4 IPC event register */
+	__I  uint32_t  RESERVED4[51];
+#endif
+	__I  uint32_t  CHIPID;				/*!< Part ID                */
+#if defined(CHIP_LPC18XX)
+	__I  uint32_t  RESERVED5[191];
+#else
+	__I  uint32_t  RESERVED5[65];
+	__IO uint32_t  M0SUBMEMMAP;         /*!< M0SUB IPC Event memory mapping */
+	__I  uint32_t  RESERVED6[2];
+	__IO uint32_t  M0SUBTXEVENT;        /*!< M0SUB IPC Event register */
+	__I  uint32_t  RESERVED7[58];
+	__IO uint32_t  M0APPTXEVENT;		/*!< M0APP IPC Event register */
+	__IO uint32_t  M0APPMEMMAP;			/*!< ARM Cortex M0APP memory mapping */
+	__I  uint32_t  RESERVED8[62];
+#endif
+	__IO uint32_t  USB0FLADJ;			/*!< USB0 frame length adjust register */
+	__I  uint32_t  RESERVED9[63];
+	__IO uint32_t  USB1FLADJ;			/*!< USB1 frame length adjust register */
+} LPC_CREG_T;
+
+/**
+ * @brief	Identifies whether on-chip flash is present
+ * @return	true if on chip flash is available, otherwise false
+ */
+STATIC INLINE uint32_t Chip_CREG_OnChipFlashIsPresent(void)
+{
+	return LPC_CREG->CHIPID != 0x3284E02B;
+}
+
+/**
+ * @brief	Configures the onboard Flash Accelerator in flash-based LPC18xx/LPC43xx parts.
+ * @param	Hz	: Current frequency in Hz of the CPU
+ * @return	Nothing
+ * This function should be called with the higher frequency before the clock frequency is
+ * increased and it should be called with the new lower value after the clock frequency is
+ * decreased.
+ */
+STATIC INLINE void Chip_CREG_SetFlashAcceleration(uint32_t Hz)
+{
+	uint32_t FAValue = Hz / 21510000;
+
+	LPC_CREG->FLASHCFGA = (LPC_CREG->FLASHCFGA & (~(0xF << 12))) | (FAValue << 12);
+	LPC_CREG->FLASHCFGB = (LPC_CREG->FLASHCFGB & (~(0xF << 12))) | (FAValue << 12);
+}
+
+/**
+ * @brief FLASH Access time definitions
+ */
+typedef enum {
+	FLASHTIM_20MHZ_CPU = 0,		/*!< Flash accesses use 1 CPU clocks. Use for up to 20 MHz CPU clock */
+	FLASHTIM_40MHZ_CPU = 1,		/*!< Flash accesses use 2 CPU clocks. Use for up to 40 MHz CPU clock */
+	FLASHTIM_60MHZ_CPU = 2,		/*!< Flash accesses use 3 CPU clocks. Use for up to 60 MHz CPU clock */
+	FLASHTIM_80MHZ_CPU = 3,		/*!< Flash accesses use 4 CPU clocks. Use for up to 80 MHz CPU clock */
+	FLASHTIM_100MHZ_CPU = 4,	/*!< Flash accesses use 5 CPU clocks. Use for up to 100 MHz CPU clock */
+	FLASHTIM_120MHZ_CPU = 5,	/*!< Flash accesses use 6 CPU clocks. Use for up to 120 MHz CPU clock */
+	FLASHTIM_150MHZ_CPU = 6,	/*!< Flash accesses use 7 CPU clocks. Use for up to 150 Mhz CPU clock */
+	FLASHTIM_170MHZ_CPU = 7,		/*!< Flash accesses use 8 CPU clocks. Use for up to 170 MHz CPU clock */
+	FLASHTIM_190MHZ_CPU = 8,		/*!< Flash accesses use 9 CPU clocks. Use for up to 190 MHz CPU clock */
+	FLASHTIM_SAFE_SETTING = 9,		/*!< Flash accesses use 10 CPU clocks. Safe setting for any allowed conditions */
+} CREG_FLASHTIM_T;
+
+/**
+ * @brief	Set FLASH memory access time in clocks
+ * @param	clks	: FLASH access speed rating
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_SetFLASHAccess(CREG_FLASHTIM_T clks)
+{
+	uint32_t tmpA, tmpB;
+
+	/* Don't alter lower bits */
+	tmpA = LPC_CREG->FLASHCFGA & ~(0xF << 12);
+	LPC_CREG->FLASHCFGA = tmpA | ((uint32_t) clks << 12);
+	tmpB = LPC_CREG->FLASHCFGB & ~(0xF << 12);
+	LPC_CREG->FLASHCFGB = tmpB | ((uint32_t) clks << 12);
+}
+
+/**
+ * @brief	Enables the USB0 high-speed PHY on LPC18xx/LPC43xx parts
+ * @return	Nothing
+ * @note	The USB0 PLL & clock should be configured before calling this function. This function
+ * should be called before the USB0 registers are accessed.
+ */
+STATIC INLINE void Chip_CREG_EnableUSB0Phy(void)
+{
+	LPC_CREG->CREG0 &= ~(1 << 5);
+}
+
+/**
+ * @brief	Disable the USB0 high-speed PHY on LPC18xx/LPC43xx parts
+ * @return	Nothing
+ * @note	The USB0 PLL & clock should be configured before calling this function. This function
+ * should be called before the USB0 registers are accessed.
+ */
+STATIC INLINE void Chip_CREG_DisableUSB0Phy(void)
+{
+	LPC_CREG->CREG0 |= (1 << 5);
+}
+
+/**
+ * @brief	Configures the BOD and Reset on LPC18xx/LPC43xx parts.
+ * @param	BODVL	: Brown-Out Detect voltage level (0-3)
+ * @param	BORVL	: Brown-Out Reset voltage level (0-3)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_ConfigureBODaR(uint32_t BODVL, uint32_t BORVL)
+{
+	LPC_CREG->CREG0 = (LPC_CREG->CREG0 & ~((3 << 8) | (3 << 10))) | (BODVL << 8) | (BORVL << 10);
+}
+
+#if (defined(CHIP_LPC43XX) && defined(LPC_CREG))
+/**
+ * @brief	Configures base address of image to be run in the Cortex M0APP Core.
+ * @param	memaddr	: Address of the image (must be aligned to 4K)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_SetM0AppMemMap(uint32_t memaddr)
+{
+	LPC_CREG->M0APPMEMMAP = memaddr & ~0xFFF;
+}
+
+/**
+ * @brief	Configures base address of image to be run in the Cortex M0SUB Core.
+ * @param	memaddr	: Address of the image (must be aligned to 4K)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_SetM0SubMemMap(uint32_t memaddr)
+{
+	LPC_CREG->M0SUBMEMMAP = memaddr & ~0xFFF;
+}
+
+/**
+ * @brief	Clear M4 IPC Event
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_ClearM4Event(void)
+{
+	LPC_CREG->M4TXEVENT = 0;
+}
+
+/**
+ * @brief	Clear M0APP IPC Event
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_ClearM0AppEvent(void)
+{
+	LPC_CREG->M0APPTXEVENT = 0;
+}
+
+/**
+ * @brief	Clear M0APP IPC Event
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_CREG_ClearM0SubEvent(void)
+{
+	LPC_CREG->M0SUBTXEVENT = 0;
+}
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CREG_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/dac_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/dac_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/dac_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/dac_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,172 @@
+/*
+ * @brief LPC18xx/43xx D/A conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __DAC_18XX_43XX_H_
+#define __DAC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup DAC_18XX_43XX CHIP: LPC18xx/43xx D/A conversion driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief DAC register block structure
+ */
+typedef struct {			/*!< DAC Structure          */
+	__IO uint32_t  CR;		/*!< DAC register. Holds the conversion data. */
+	__IO uint32_t  CTRL;	/*!< DAC control register.  */
+	__IO uint32_t  CNTVAL;	/*!< DAC counter value register. */
+} LPC_DAC_T;
+
+/** After the selected settling time after this field is written with a
+   new VALUE, the voltage on the AOUT pin (with respect to VSSA)
+   is VALUE/1024 ? VREF */
+#define DAC_VALUE(n)        ((uint32_t) ((n & 0x3FF) << 6))
+/** If this bit = 0: The settling time of the DAC is 1 microsecond max,
+ * and the maximum current is 700 microAmpere
+ * If this bit = 1: The settling time of the DAC is 2.5 microsecond
+ * and the maximum current is 350 microAmpere
+ */
+#define DAC_BIAS_EN         ((uint32_t) (1 << 16))
+/** Value to reload interrupt DMA counter */
+#define DAC_CCNT_VALUE(n)  ((uint32_t) (n & 0xffff))
+
+/** DCAR double buffering */
+#define DAC_DBLBUF_ENA      ((uint32_t) (1 << 1))
+/** DCAR Time out count enable */
+#define DAC_CNT_ENA         ((uint32_t) (1 << 2))
+/** DCAR DMA access */
+#define DAC_DMA_ENA         ((uint32_t) (1 << 3))
+/** DCAR DACCTRL mask bit */
+#define DAC_DACCTRL_MASK    ((uint32_t) (0x0F))
+
+/**
+ * @brief Current option in DAC configuration option
+ */
+typedef enum IP_DAC_CURRENT_OPT {
+	DAC_MAX_UPDATE_RATE_1MHz = 0,	/*!< Shorter settling times and higher power consumption;
+									    allows for a maximum update rate of 1 MHz */
+	DAC_MAX_UPDATE_RATE_400kHz		/*!< Longer settling times and lower power consumption;
+									    allows for a maximum update rate of 400 kHz */
+} DAC_CURRENT_OPT_T;
+
+/**
+ * @brief	Initial DAC configuration
+ *              - Maximum	current is 700 uA
+ *              - Value to AOUT is 0
+ * @param	pDAC	: pointer to LPC_DAC_T
+ * @return	Nothing
+ */
+void Chip_DAC_Init(LPC_DAC_T *pDAC);
+
+/**
+ * @brief	Shutdown DAC
+ * @param	pDAC	: pointer to LPC_DAC_T
+ * @return	Nothing
+ */
+void Chip_DAC_DeInit(LPC_DAC_T *pDAC);
+
+/**
+ * @brief	Update value to DAC buffer
+ * @param	pDAC		: pointer to LPC_DAC_T
+ * @param	dac_value	: value 10 bit to be converted to output
+ * @return	Nothing
+ */
+void Chip_DAC_UpdateValue(LPC_DAC_T *pDAC, uint32_t dac_value);
+
+/**
+ * @brief	Set maximum update rate for DAC
+ * @param	pDAC	: pointer to LPC_DAC_T
+ * @param	bias	: Using Bias value, should be:
+ *              - 0 is 1MHz
+ *              - 1 is 400kHz
+ * @return	Nothing
+ */
+void Chip_DAC_SetBias(LPC_DAC_T *pDAC, uint32_t bias);
+
+/**
+ * @brief	Enables the DMA operation and controls DMA timer
+ * @param	pDAC		: pointer to LPC_DAC_T
+ * @param	dacFlags	: An Or'ed value of the following DAC values:
+ *                  - DAC_DBLBUF_ENA :enable/disable DACR double buffering feature
+ *                  - DAC_CNT_ENA    :enable/disable timer out counter
+ *                  - DAC_DMA_ENA    :enable/disable DMA access
+ * @return	Nothing
+ * @note	Pass an Or'ed value of the DAC flags to enable those options.
+ */
+STATIC INLINE void Chip_DAC_ConfigDAConverterControl(LPC_DAC_T *pDAC, uint32_t dacFlags)
+{
+	uint32_t temp;
+
+	temp = pDAC->CTRL & ~DAC_DACCTRL_MASK;
+	pDAC->CTRL = temp | dacFlags;
+}
+
+/**
+ * @brief	Set reload value for interrupt/DMA counter
+ * @param	pDAC		: pointer to LPC_DAC_T
+ * @param	time_out	: time out to reload for interrupt/DMA counter
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_DAC_SetDMATimeOut(LPC_DAC_T *pDAC, uint32_t time_out)
+{
+	pDAC->CNTVAL = DAC_CCNT_VALUE(time_out);
+}
+
+/**
+ * @brief	Get status for interrupt/DMA time out
+ * @param	pDAC	: pointer to LPC_DAC_T
+ * @return	interrupt/DMA time out status, should be SET or RESET
+ */
+STATIC INLINE IntStatus Chip_DAC_GetIntStatus(LPC_DAC_T *pDAC)
+{
+	return (pDAC->CTRL & 0x01) ? SET : RESET;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DAC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/eeprom_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/eeprom_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/eeprom_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/eeprom_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,281 @@
+/*
+ * @brief LPC18xx/43xx EEPROM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef _EEPROM_18XX_43XX_H_
+#define _EEPROM_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup EEPROM_18XX_43XX CHIP: LPC18xx/43xx EEPROM driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/* FIX ME: Move to chip.h */
+/** EEPROM start address */
+#define EEPROM_START                    (0x20040000)
+/** EEPROM byes per page */
+#define EEPROM_PAGE_SIZE                (128)
+/**The number of EEPROM pages. The last page is not writable.*/
+#define EEPROM_PAGE_NUM                 (128)
+/** Get the eeprom address */
+#define EEPROM_ADDRESS(page, offset)     (EEPROM_START + (EEPROM_PAGE_SIZE * (page)) + offset)
+#define EEPROM_CLOCK_DIV                 1500000
+#define EEPROM_READ_WAIT_STATE_VAL       0x58
+#define EEPROM_WAIT_STATE_VAL            0x232
+
+/**
+ * @brief EEPROM register block structure
+ */
+typedef struct {				/* EEPROM Structure */
+	__IO uint32_t CMD;			/*!< EEPROM command register */
+	uint32_t RESERVED0;
+	__IO uint32_t RWSTATE;		/*!< EEPROM read wait state register */
+	__IO uint32_t AUTOPROG;		/*!< EEPROM auto programming register */
+	__IO uint32_t WSTATE;		/*!< EEPROM wait state register */
+	__IO uint32_t CLKDIV;		/*!< EEPROM clock divider register */
+	__IO uint32_t PWRDWN;		/*!< EEPROM power-down register */
+	uint32_t RESERVED2[1007];
+	__O  uint32_t INTENCLR;		/*!< EEPROM interrupt enable clear */
+	__O  uint32_t INTENSET;		/*!< EEPROM interrupt enable set */
+	__I  uint32_t INTSTAT;		/*!< EEPROM interrupt status */
+	__I  uint32_t INTEN;		/*!< EEPROM interrupt enable */
+	__O  uint32_t INTSTATCLR;	/*!< EEPROM interrupt status clear */
+	__O  uint32_t INTSTATSET;	/*!< EEPROM interrupt status set */
+} LPC_EEPROM_T;
+
+/*
+ * @brief Macro defines for EEPROM command register
+ */
+#define EEPROM_CMD_ERASE_PRG_PAGE       (6)		/*!< EEPROM erase/program command */
+
+/*
+ * @brief Macro defines for EEPROM Auto Programming register
+ */
+#define EEPROM_AUTOPROG_OFF     (0)		/*!<Auto programming off */
+#define EEPROM_AUTOPROG_AFT_1WORDWRITTEN     (1)		/*!< Erase/program cycle is triggered after 1 word is written */
+#define EEPROM_AUTOPROG_AFT_LASTWORDWRITTEN  (2)		/*!< Erase/program cycle is triggered after a write to AHB
+														   address ending with ......1111100 (last word of a page) */
+
+/*
+ * @brief Macro defines for EEPROM power down register
+ */
+#define EEPROM_PWRDWN                   (1 << 0)
+
+/*
+ * @brief Macro defines for EEPROM interrupt related registers
+ */
+#define EEPROM_INT_ENDOFPROG            (1 << 2)
+
+/**
+ * @brief	Put EEPROM device in power down mode
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_EnablePowerDown(LPC_EEPROM_T *pEEPROM)
+{
+	pEEPROM->PWRDWN = EEPROM_PWRDWN;
+}
+
+/**
+ * @brief	Bring EEPROM device out of power down mode
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_DisablePowerDown(LPC_EEPROM_T *pEEPROM)
+{
+	pEEPROM->PWRDWN = 0;
+}
+
+/**
+ * @brief	Initializes EEPROM
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	Nothing
+ */
+void Chip_EEPROM_Init(LPC_EEPROM_T *pEEPROM);
+
+/**
+ * @brief	De-initializes EEPROM
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_DeInit(LPC_EEPROM_T *pEEPROM)
+{
+	/* Enable EEPROM power down mode */
+	Chip_EEPROM_EnablePowerDown(pEEPROM);
+}
+
+/**
+ * @brief	Set Auto program mode
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	mode	: Auto Program Mode (One of EEPROM_AUTOPROG_* value)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_SetAutoProg(LPC_EEPROM_T *pEEPROM, uint32_t mode)
+{
+	pEEPROM->AUTOPROG = mode;
+}
+
+/**
+ * @brief	Set EEPROM Read Wait State
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	ws      : Wait State value
+ * @return	Nothing
+ * @note    Bits 7:0 represents wait state for Read Phase 2 and
+ *          Bits 15:8 represents wait state for Read Phase1
+ */
+STATIC INLINE void Chip_EEPROM_SetReadWaitState(LPC_EEPROM_T *pEEPROM, uint32_t ws)
+{
+	pEEPROM->RWSTATE = ws;
+}
+
+/**
+ * @brief	Set EEPROM wait state
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	ws	    : Wait State value
+ * @return	Nothing
+ * @note    Bits 7:0 represents wait state for Phase 3,
+ *          Bits 15:8 represents wait state for Phase2, and
+ *          Bits 23:16 represents wait state for Phase1
+ */
+STATIC INLINE void Chip_EEPROM_SetWaitState(LPC_EEPROM_T *pEEPROM, uint32_t ws)
+{
+	pEEPROM->WSTATE = ws;
+}
+
+/**
+ * @brief	Select an EEPROM command
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	cmd	    : EEPROM command
+ * @return	Nothing
+ * @note	The cmd is OR-ed bits value of  EEPROM_CMD_*
+ */
+STATIC INLINE void Chip_EEPROM_SetCmd(LPC_EEPROM_T *pEEPROM, uint32_t cmd)
+{
+	pEEPROM->CMD = cmd;
+}
+
+/**
+ * @brief	Erase/Program an EEPROM page
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	Nothing
+ */
+void Chip_EEPROM_EraseProgramPage(LPC_EEPROM_T *pEEPROM);
+
+/**
+ * @brief	Wait for interrupt occurs
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	mask	: Expected interrupt
+ * @return	Nothing
+ */
+void Chip_EEPROM_WaitForIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask);
+
+/**
+ * @brief	Enable EEPROM interrupt
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	mask	: Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_EnableInt(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+	pEEPROM->INTENSET =  mask;
+}
+
+/**
+ * @brief	Disable EEPROM interrupt
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	mask	: Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_DisableInt(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+	pEEPROM->INTENCLR =  mask;
+}
+
+/**
+ * @brief	Get the value of the EEPROM interrupt enable register
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	OR-ed bits value of EEPROM_INT_*
+ */
+STATIC INLINE uint32_t Chip_EEPROM_GetIntEnable(LPC_EEPROM_T *pEEPROM)
+{
+	return pEEPROM->INTEN;
+}
+
+/**
+ * @brief	Get EEPROM interrupt status
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @return	OR-ed bits value of EEPROM_INT_*
+ */
+STATIC INLINE uint32_t Chip_EEPROM_GetIntStatus(LPC_EEPROM_T *pEEPROM)
+{
+	return pEEPROM->INTSTAT;
+}
+
+/**
+ * @brief	Set EEPROM interrupt status
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	mask	: Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_SetIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+	pEEPROM->INTSTATSET =  mask;
+}
+
+/**
+ * @brief	Clear EEPROM interrupt status
+ * @param	pEEPROM	: Pointer to EEPROM peripheral block structure
+ * @param	mask	: Interrupt mask (or-ed bits value of EEPROM_INT_*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EEPROM_ClearIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+	pEEPROM->INTSTATCLR =  mask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _EEPROM_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/eeprom.h ./libs/vendor_libs/lpc_chip_43xx/inc/eeprom.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/eeprom.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/eeprom.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,76 @@
+/*
+ * @brief Common EEPROM support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __EEPROM_H_
+#define __EEPROM_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup COMMON_EEPROM CHIP: Common Chip EEPROM commands
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief	Write data to EEPROM
+ * @param	dstAdd		: EEPROM address to be written to
+ * @param	ptr			: Pointer to buffer to write from
+ * @param	byteswrt	: Number of bytes to write to EEPROM
+ * @return	An IAP response definition from iap.h
+ */
+uint8_t Chip_EEPROM_Write(uint32_t dstAdd, uint8_t *ptr, uint32_t byteswrt);
+
+/**
+ * @brief	Read data from EEPROM
+ * @param	srcAdd	: EEPROM address to be read from
+ * @param	ptr		: Pointer to buffer to read to
+ * @param	bytesrd	: Number of bytes to read from EEPROM
+ * @return	An IAP response definition from iap.h
+ */
+uint8_t Chip_EEPROM_Read(uint32_t srcAdd, uint8_t *ptr, uint32_t bytesrd);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __EEPROM_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/emc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/emc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/emc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/emc_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,360 @@
+/*
+ * @brief LPC18xx/43xx EMC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __EMC_18XX_43XX_H_
+#define __EMC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup EMC_18XX_43XX CHIP: LPC18xx/43xx External Memory Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ * The EMC interface clocks must be enabled outside this driver prior to
+ * calling any function of this driver.
+ */
+
+/**
+ * @brief External Memory Controller (EMC) register block structure
+ */
+typedef struct {							/*!< EMC Structure          */
+	__IO uint32_t  CONTROL;					/*!< Controls operation of the memory controller. */
+	__I  uint32_t  STATUS;					/*!< Provides EMC status information. */
+	__IO uint32_t  CONFIG;					/*!< Configures operation of the memory controller. */
+	__I  uint32_t  RESERVED0[5];
+	__IO uint32_t  DYNAMICCONTROL;			/*!< Controls dynamic memory operation. */
+	__IO uint32_t  DYNAMICREFRESH;			/*!< Configures dynamic memory refresh operation. */
+	__IO uint32_t  DYNAMICREADCONFIG;		/*!< Configures the dynamic memory read strategy. */
+	__I  uint32_t  RESERVED1;
+	__IO uint32_t  DYNAMICRP;				/*!< Selects the precharge command period. */
+	__IO uint32_t  DYNAMICRAS;				/*!< Selects the active to precharge command period. */
+	__IO uint32_t  DYNAMICSREX;				/*!< Selects the self-refresh exit time. */
+	__IO uint32_t  DYNAMICAPR;				/*!< Selects the last-data-out to active command time. */
+	__IO uint32_t  DYNAMICDAL;				/*!< Selects the data-in to active command time. */
+	__IO uint32_t  DYNAMICWR;				/*!< Selects the write recovery time. */
+	__IO uint32_t  DYNAMICRC;				/*!< Selects the active to active command period. */
+	__IO uint32_t  DYNAMICRFC;				/*!< Selects the auto-refresh period. */
+	__IO uint32_t  DYNAMICXSR;				/*!< Selects the exit self-refresh to active command time. */
+	__IO uint32_t  DYNAMICRRD;				/*!< Selects the active bank A to active bank B latency. */
+	__IO uint32_t  DYNAMICMRD;				/*!< Selects the load mode register to active command time. */
+	__I  uint32_t  RESERVED2[9];
+	__IO uint32_t  STATICEXTENDEDWAIT;		/*!< Selects time for long static memory read and write transfers. */
+	__I  uint32_t  RESERVED3[31];
+	__IO uint32_t  DYNAMICCONFIG0;			/*!< Selects the configuration information for dynamic memory chip select n. */
+	__IO uint32_t  DYNAMICRASCAS0;			/*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+	__I  uint32_t  RESERVED4[6];
+	__IO uint32_t  DYNAMICCONFIG1;			/*!< Selects the configuration information for dynamic memory chip select n. */
+	__IO uint32_t  DYNAMICRASCAS1;			/*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+	__I  uint32_t  RESERVED5[6];
+	__IO uint32_t  DYNAMICCONFIG2;			/*!< Selects the configuration information for dynamic memory chip select n. */
+	__IO uint32_t  DYNAMICRASCAS2;			/*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+	__I  uint32_t  RESERVED6[6];
+	__IO uint32_t  DYNAMICCONFIG3;			/*!< Selects the configuration information for dynamic memory chip select n. */
+	__IO uint32_t  DYNAMICRASCAS3;			/*!< Selects the RAS and CAS latencies for dynamic memory chip select n. */
+	__I  uint32_t  RESERVED7[38];
+	__IO uint32_t  STATICCONFIG0;			/*!< Selects the memory configuration for static chip select n. */
+	__IO uint32_t  STATICWAITWEN0;			/*!< Selects the delay from chip select n to write enable. */
+	__IO uint32_t  STATICWAITOEN0;			/*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+	__IO uint32_t  STATICWAITRD0;			/*!< Selects the delay from chip select n to a read access. */
+	__IO uint32_t  STATICWAITPAG0;			/*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+	__IO uint32_t  STATICWAITWR0;			/*!< Selects the delay from chip select n to a write access. */
+	__IO uint32_t  STATICWAITTURN0;			/*!< Selects bus turnaround cycles */
+	__I  uint32_t  RESERVED8;
+	__IO uint32_t  STATICCONFIG1;			/*!< Selects the memory configuration for static chip select n. */
+	__IO uint32_t  STATICWAITWEN1;			/*!< Selects the delay from chip select n to write enable. */
+	__IO uint32_t  STATICWAITOEN1;			/*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+	__IO uint32_t  STATICWAITRD1;			/*!< Selects the delay from chip select n to a read access. */
+	__IO uint32_t  STATICWAITPAG1;			/*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+	__IO uint32_t  STATICWAITWR1;			/*!< Selects the delay from chip select n to a write access. */
+	__IO uint32_t  STATICWAITTURN1;			/*!< Selects bus turnaround cycles */
+	__I  uint32_t  RESERVED9;
+	__IO uint32_t  STATICCONFIG2;			/*!< Selects the memory configuration for static chip select n. */
+	__IO uint32_t  STATICWAITWEN2;			/*!< Selects the delay from chip select n to write enable. */
+	__IO uint32_t  STATICWAITOEN2;			/*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+	__IO uint32_t  STATICWAITRD2;			/*!< Selects the delay from chip select n to a read access. */
+	__IO uint32_t  STATICWAITPAG2;			/*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+	__IO uint32_t  STATICWAITWR2;			/*!< Selects the delay from chip select n to a write access. */
+	__IO uint32_t  STATICWAITTURN2;			/*!< Selects bus turnaround cycles */
+	__I  uint32_t  RESERVED10;
+	__IO uint32_t  STATICCONFIG3;			/*!< Selects the memory configuration for static chip select n. */
+	__IO uint32_t  STATICWAITWEN3;			/*!< Selects the delay from chip select n to write enable. */
+	__IO uint32_t  STATICWAITOEN3;			/*!< Selects the delay from chip select n or address change, whichever is later, to output enable. */
+	__IO uint32_t  STATICWAITRD3;			/*!< Selects the delay from chip select n to a read access. */
+	__IO uint32_t  STATICWAITPAG3;			/*!< Selects the delay for asynchronous page mode sequential accesses for chip select n. */
+	__IO uint32_t  STATICWAITWR3;			/*!< Selects the delay from chip select n to a write access. */
+	__IO uint32_t  STATICWAITTURN3;			/*!< Selects bus turnaround cycles */
+} LPC_EMC_T;
+
+/**
+ * Dynamic Chip Select Address
+ */
+#define EMC_ADDRESS_DYCS0   (0x28000000)
+#define EMC_ADDRESS_DYCS1   (0x30000000)
+#define EMC_ADDRESS_DYCS2   (0x60000000)
+#define EMC_ADDRESS_DYCS3   (0x70000000)
+
+/**
+ * Static Chip Select Address
+ */
+#define EMC_ADDRESS_CS0     (0x1C000000)
+#define EMC_ADDRESS_CS1     (0x1D000000)
+#define EMC_ADDRESS_CS2     (0x1E000000)
+#define EMC_ADDRESS_CS3     (0x1F000000)
+
+/**
+ * @brief EMC register support bitfields and mask
+ */
+/* Reserve for extending support to ARM9 or nextgen LPC */
+#define EMC_SUPPORT_ONLY_PL172	/*!< Reserve for extending support to ARM9 or nextgen LPC */
+
+#define EMC_CONFIG_ENDIAN_LITTLE    (0)		/*!< Value for EMC to operate in Little Endian Mode */
+#define EMC_CONFIG_ENDIAN_BIG         (1)	/*!< Value for EMC to operate in Big Endian Mode */
+
+#define EMC_CONFIG_BUFFER_ENABLE    (1 << 19)	/*!< EMC Buffer enable bit in EMC Dynamic Configuration register */
+#define EMC_CONFIG_WRITE_PROTECT    (1 << 20)	/*!< EMC Write protect bit in EMC Dynamic Configuration register */
+
+/* Dynamic Memory Configuration Register Bit Definitions */
+#define EMC_DYN_CONFIG_MD_BIT             (3)								/*!< Memory device bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_MD_SDRAM         (0 << EMC_DYN_CONFIG_MD_BIT)		/*!< Select device as SDRAM in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_MD_LPSDRAM       (1 << EMC_DYN_CONFIG_MD_BIT)		/*!< Select device as LPSDRAM in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_LPSDRAM_BIT      (12)							/*!< LPSDRAM bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_LPSDRAM          (1 << EMC_DYN_CONFIG_LPSDRAM_BIT)	/*!< LPSDRAM value in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_DEV_SIZE_BIT     (9)									/*!< Device Size starting bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_16Mb    (0x00 << EMC_DYN_CONFIG_DEV_SIZE_BIT)	/*!< 16Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_64Mb    (0x01 << EMC_DYN_CONFIG_DEV_SIZE_BIT)	/*!< 64Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_128Mb   (0x02 << EMC_DYN_CONFIG_DEV_SIZE_BIT)	/*!< 128Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_256Mb   (0x03 << EMC_DYN_CONFIG_DEV_SIZE_BIT)	/*!< 256Mb Device Size value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_SIZE_512Mb   (0x04 << EMC_DYN_CONFIG_DEV_SIZE_BIT)	/*!< 512Mb Device Size value in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_DEV_BUS_BIT      (7)									/*!< Device bus width starting bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_BUS_8        (0x00 << EMC_DYN_CONFIG_DEV_BUS_BIT)	/*!< Device 8-bit bus width value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_BUS_16       (0x01 << EMC_DYN_CONFIG_DEV_BUS_BIT)	/*!< Device 16-bit bus width value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DEV_BUS_32       (0x02 << EMC_DYN_CONFIG_DEV_BUS_BIT)	/*!< Device 32-bit bus width value in EMC Dynamic Configuration register */
+
+#define EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT   (14)									/*!< Device data bus width starting bit in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DATA_BUS_16      (0x00 << EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT)	/*!< Device 16-bit data bus width value in EMC Dynamic Configuration register */
+#define EMC_DYN_CONFIG_DATA_BUS_32      (0x01 << EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT)	/*!< Device 32-bit bus width value in EMC Dynamic Configuration register */
+
+/*!< Memory configuration values in EMC Dynamic Configuration Register */
+#define EMC_DYN_CONFIG_2Mx8_2BANKS_11ROWS_9COLS     ((0x0 << 9) | (0x0 << 7))	/*!< Value for Memory configuration - 2Mx8 2 Banks 11 Rows 9 Columns */
+#define EMC_DYN_CONFIG_1Mx16_2BANKS_11ROWS_8COLS    ((0x0 << 9) | (0x1 << 7))	/*!< Value for Memory configuration - 1Mx16 2 Banks 11 Rows 8 Columns */
+#define EMC_DYN_CONFIG_8Mx8_4BANKS_12ROWS_9COLS     ((0x1 << 9) | (0x0 << 7))	/*!< Value for Memory configuration - 8Mx8 4 Banks 12 Rows 9 Columns */
+#define EMC_DYN_CONFIG_4Mx16_4BANKS_12ROWS_8COLS    ((0x1 << 9) | (0x1 << 7))	/*!< Value for Memory configuration - 4Mx16 4 Banks 12 Rows 8 Columns */
+#define EMC_DYN_CONFIG_2Mx32_4BANKS_11ROWS_8COLS    ((0x1 << 9) | (0x2 << 7))	/*!< Value for Memory configuration - 2Mx32 4 Banks 11 Rows 8 Columns */
+#define EMC_DYN_CONFIG_16Mx8_4BANKS_12ROWS_10COLS   ((0x2 << 9) | (0x0 << 7))	/*!< Value for Memory configuration - 16Mx8 4 Banks 12 Rows 10 Columns */
+#define EMC_DYN_CONFIG_8Mx16_4BANKS_12ROWS_9COLS    ((0x2 << 9) | (0x1 << 7))	/*!< Value for Memory configuration - 8Mx16 4 Banks 12 Rows 9 Columns */
+#define EMC_DYN_CONFIG_4Mx32_4BANKS_12ROWS_8COLS    ((0x2 << 9) | (0x2 << 7))	/*!< Value for Memory configuration - 4Mx32 4 Banks 12 Rows 8 Columns */
+#define EMC_DYN_CONFIG_32Mx8_4BANKS_13ROWS_10COLS   ((0x3 << 9) | (0x0 << 7))	/*!< Value for Memory configuration - 32Mx8 4 Banks 13 Rows 10 Columns */
+#define EMC_DYN_CONFIG_16Mx16_4BANKS_13ROWS_9COLS   ((0x3 << 9) | (0x1 << 7))	/*!< Value for Memory configuration - 16Mx16 4 Banks 13 Rows 8 Columns */
+#define EMC_DYN_CONFIG_8Mx32_4BANKS_13ROWS_8COLS    ((0x3 << 9) | (0x2 << 7))	/*!< Value for Memory configuration - 8Mx32 4 Banks 13 Rows 8 Columns */
+#define EMC_DYN_CONFIG_64Mx8_4BANKS_13ROWS_11COLS   ((0x4 << 9) | (0x0 << 7))	/*!< Value for Memory configuration - 64Mx8 4 Banks 13 Rows 11 Columns */
+#define EMC_DYN_CONFIG_32Mx16_4BANKS_13ROWS_10COLS  ((0x4 << 9) | (0x1 << 7))	/*!< Value for Memory configuration - 32Mx16 4 Banks 13 Rows 10 Columns */
+
+/*!< Dynamic Memory Mode Register Bit Definition */
+#define EMC_DYN_MODE_BURST_LEN_BIT      (0)	/*!< Starting bit No. of Burst Length in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_1        (0)	/*!< Value to set Burst Length to 1 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_2        (1)	/*!< Value to set Burst Length to 2 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_4        (2)	/*!< Value to set Burst Length to 4 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_8        (3)	/*!< Value to set Burst Length to 8 in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_LEN_FULL     (7)	/*!< Value to set Burst Length to Full in Dynamic Memory Mode Register */
+
+#define EMC_DYN_MODE_BURST_TYPE_BIT         (3)									/*!< Burst Type bit in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_TYPE_SEQUENTIAL  (0 << EMC_DYN_MODE_BURST_TYPE_BIT)	/*!< Burst Type Sequential in Dynamic Memory Mode Register */
+#define EMC_DYN_MODE_BURST_TYPE_INTERLEAVE  (1 << EMC_DYN_MODE_BURST_TYPE_BIT)	/*!< Burst Type Interleaved in Dynamic Memory Mode Register */
+
+/*!< CAS Latency in Dynamic Mode Register */
+#define EMC_DYN_MODE_CAS_BIT    (4)							/*!< CAS latency starting bit in Dynamic Memory Mode register */
+#define EMC_DYN_MODE_CAS_1      (1 << EMC_DYN_MODE_CAS_BIT)	/*!< value for CAS latency of 1 cycle */
+#define EMC_DYN_MODE_CAS_2      (2 << EMC_DYN_MODE_CAS_BIT)	/*!< value for CAS latency of 2 cycle */
+#define EMC_DYN_MODE_CAS_3      (3 << EMC_DYN_MODE_CAS_BIT)	/*!< value for CAS latency of 3 cycle */
+
+/*!< Operation Mode in Dynamic Mode register */
+#define EMC_DYN_MODE_OPMODE_BIT           (7)							/*!< Dynamic Mode Operation bit */
+#define EMC_DYN_MODE_OPMODE_STANDARD    (0 << EMC_DYN_MODE_OPMODE_BIT)	/*!< Value for Dynamic standard operation Mode */
+
+/*!< Write Burst Mode in Dynamic Mode register */
+#define EMC_DYN_MODE_WBMODE_BIT             (9)							/*!< Write Burst Mode bit */
+#define EMC_DYN_MODE_WBMODE_PROGRAMMED  (0 << EMC_DYN_MODE_WBMODE_BIT)	/*!< Write Burst Mode programmed */
+#define EMC_DYN_MODE_WBMODE_SINGLE_LOC  (1 << EMC_DYN_MODE_WBMODE_BIT)	/*!< Write Burst Mode Single LOC */
+
+/*!< Dynamic Memory Control Register Bit Definitions */
+#define EMC_DYN_CONTROL_ENABLE          (0x03)	/*!< Control Enable value */
+
+/*!< Static Memory Configuration Register Bit Definitions */
+#define EMC_STATIC_CONFIG_MEM_WIDTH_8       (0)	/*!< Static Memory Configuration - 8-bit width */
+#define EMC_STATIC_CONFIG_MEM_WIDTH_16      (1)	/*!< Static Memory Configuration - 16-bit width */
+#define EMC_STATIC_CONFIG_MEM_WIDTH_32      (2)	/*!< Static Memory Configuration - 32-bit width */
+
+#define EMC_STATIC_CONFIG_PAGE_MODE_BIT         (3)										/*!< Page Mode bit No */
+#define EMC_STATIC_CONFIG_PAGE_MODE_ENABLE      (1 << EMC_STATIC_CONFIG_PAGE_MODE_BIT)	/*!< Value to enable Page Mode */
+
+#define EMC_STATIC_CONFIG_CS_POL_BIT            (6)									/*!< Chip Select bit No */
+#define EMC_STATIC_CONFIG_CS_POL_ACTIVE_HIGH    (1 << EMC_STATIC_CONFIG_CS_POL_BIT)	/*!< Chip Select polarity - Active High */
+#define EMC_STATIC_CONFIG_CS_POL_ACTIVE_LOW     (0 << EMC_STATIC_CONFIG_CS_POL_BIT)	/*!< Chip Select polarity - Active Low */
+
+#define EMC_STATIC_CONFIG_BLS_BIT           (7)								/*!< BLS Configuration bit No */
+#define EMC_STATIC_CONFIG_BLS_HIGH          (1 << EMC_STATIC_CONFIG_BLS_BIT)	/*!< BLS High Configuration value */
+#define EMC_STATIC_CONFIG_BLS_LOW           (0 << EMC_STATIC_CONFIG_BLS_BIT)	/*!< BLS Low Configuration value */
+
+#define EMC_STATIC_CONFIG_EW_BIT            (8)								/*!< Ext Wait bit No */
+#define EMC_STATIC_CONFIG_EW_ENABLE         (1 << EMC_STATIC_CONFIG_EW_BIT)	/*!< Ext Wait Enabled value */
+#define EMC_STATIC_CONFIG_EW_DISABLE        (0 << EMC_STATIC_CONFIG_EW_BIT)	/*!< Ext Wait Diabled value */
+
+/*!< Q24.8 Fixed Point Helper */
+#define Q24_8_FP(x) ((x) * 256)
+#define EMC_NANOSECOND(x)   Q24_8_FP(x)
+#define EMC_CLOCK(x)        Q24_8_FP(-(x))
+
+/**
+ * @brief	EMC Dynamic Device Configuration structure used for IP drivers
+ */
+typedef struct {
+	uint32_t    BaseAddr;		/*!< Base Address */
+	uint8_t     RAS;			/*!< RAS value */
+	uint32_t    ModeRegister;	/*!< Mode Register value */
+	uint32_t    DynConfig;		/*!< Dynamic Configuration value */
+} IP_EMC_DYN_DEVICE_CONFIG_T;
+
+/**
+ * @brief EMC Dynamic Configure Struct
+ */
+typedef struct {
+	int32_t RefreshPeriod;							/*!< Refresh period */
+	uint32_t ReadConfig;							/*!< Clock*/
+	int32_t tRP;									/*!< Precharge Command Period */
+	int32_t tRAS;									/*!< Active to Precharge Command Period */
+	int32_t tSREX;									/*!< Self Refresh Exit Time */
+	int32_t tAPR;									/*!< Last Data Out to Active Time */
+	int32_t tDAL;									/*!< Data In to Active Command Time */
+	int32_t tWR;									/*!< Write Recovery Time */
+	int32_t tRC;									/*!< Active to Active Command Period */
+	int32_t tRFC;									/*!< Auto-refresh Period */
+	int32_t tXSR;									/*!< Exit Selt Refresh */
+	int32_t tRRD;									/*!< Active Bank A to Active Bank B Time */
+	int32_t tMRD;									/*!< Load Mode register command to Active Command */
+	IP_EMC_DYN_DEVICE_CONFIG_T DevConfig[4];		/*!< Device Configuration array */
+} IP_EMC_DYN_CONFIG_T;
+
+/**
+ * @brief EMC Static Configure Structure
+ */
+typedef struct {
+	uint8_t ChipSelect;		/*!< Chip select */
+	uint32_t Config;		/*!< Configuration value */
+	int32_t WaitWen;		/*!< Write Enable Wait */
+	int32_t WaitOen;		/*!< Output Enable Wait */
+	int32_t WaitRd;			/*!< Read Wait */
+	int32_t WaitPage;		/*!< Page Access Wait */
+	int32_t WaitWr;			/*!< Write Wait */
+	int32_t WaitTurn;		/*!< Turn around wait */
+} IP_EMC_STATIC_CONFIG_T;
+
+/**
+ * @brief	Dyanmic memory setup
+ * @param	Dynamic_Config	: Pointer to dynamic memory setup data
+ * @return	None
+ */
+void Chip_EMC_Dynamic_Init(IP_EMC_DYN_CONFIG_T *Dynamic_Config);
+
+/**
+ * @brief	Static memory setup
+ * @param	Static_Config	: Pointer to static memory setup data
+ * @return	None
+ */
+void Chip_EMC_Static_Init(IP_EMC_STATIC_CONFIG_T *Static_Config);
+
+/**
+ * @brief	Enable Dynamic Memory Controller
+ * @param	Enable	: 1 = Enable Dynamic Memory Controller, 0 = Disable
+ * @return	None
+ */
+void Chip_EMC_Dynamic_Enable(uint8_t Enable);
+
+/**
+ * @brief	Mirror CS1 to CS0 and DYCS0
+ * @param	Enable	: 1 = Mirror, 0 = Normal Memory Map
+ * @return	None
+ */
+void Chip_EMC_Mirror(uint8_t Enable);
+
+/**
+ * @brief	Enable EMC
+ * @param	Enable	: 1 = Enable, 0 = Disable
+ * @return	None
+ */
+void Chip_EMC_Enable(uint8_t Enable);
+
+/**
+ * @brief	Set EMC LowPower Mode
+ * @param	Enable	: 1 = Enable, 0 = Disable
+ * @return	None
+ * @note	This function should only be called when the memory
+ * controller is not busy (bit 0 of the status register is not set).
+ */
+void Chip_EMC_LowPowerMode(uint8_t Enable);
+
+/**
+ * @brief	Initialize EMC
+ * @param	Enable		: 1 = Enable, 0 = Disable
+ * @param	ClockRatio	: clock out ratio, 0 = 1:1, 1 = 1:2
+ * @param	EndianMode	: Endian Mode, 0 = Little, 1 = Big
+ * @return	None
+ */
+void Chip_EMC_Init(uint32_t Enable, uint32_t ClockRatio, uint32_t EndianMode);
+
+/**
+ * @brief	Set Static Memory Extended Wait in Clock
+ * @param	Wait16Clks	: Number of '16 clock' delay cycles
+ * @return	None
+ */
+STATIC INLINE void Chip_EMC_SetStaticExtendedWait(uint32_t Wait16Clks)
+{
+	LPC_EMC->STATICEXTENDEDWAIT = Wait16Clks;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __EMC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/enet_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/enet_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/enet_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/enet_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,686 @@
+/*
+ * @brief LPC18xx/43xx Ethernet driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ENET_18XX_43XX_H_
+#define __ENET_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ENET_18XX_43XX CHIP: LPC18xx/43xx Ethernet driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief 10/100 MII & RMII Ethernet with timestamping register block structure
+ */
+typedef struct {							/*!< ETHERNET Structure */
+	__IO uint32_t  MAC_CONFIG;				/*!< MAC configuration register */
+	__IO uint32_t  MAC_FRAME_FILTER;		/*!< MAC frame filter */
+	__IO uint32_t  MAC_HASHTABLE_HIGH;		/*!< Hash table high register */
+	__IO uint32_t  MAC_HASHTABLE_LOW;		/*!< Hash table low register */
+	__IO uint32_t  MAC_MII_ADDR;			/*!< MII address register */
+	__IO uint32_t  MAC_MII_DATA;			/*!< MII data register */
+	__IO uint32_t  MAC_FLOW_CTRL;			/*!< Flow control register */
+	__IO uint32_t  MAC_VLAN_TAG;			/*!< VLAN tag register */
+	__I  uint32_t  RESERVED0;
+	__I  uint32_t  MAC_DEBUG;				/*!< Debug register */
+	__IO uint32_t  MAC_RWAKE_FRFLT;			/*!< Remote wake-up frame filter */
+	__IO uint32_t  MAC_PMT_CTRL_STAT;		/*!< PMT control and status */
+	__I  uint32_t  RESERVED1[2];
+	__I  uint32_t  MAC_INTR;				/*!< Interrupt status register */
+	__IO uint32_t  MAC_INTR_MASK;			/*!< Interrupt mask register */
+	__IO uint32_t  MAC_ADDR0_HIGH;			/*!< MAC address 0 high register */
+	__IO uint32_t  MAC_ADDR0_LOW;			/*!< MAC address 0 low register */
+	__I  uint32_t  RESERVED2[430];
+	__IO uint32_t  MAC_TIMESTP_CTRL;		/*!< Time stamp control register */
+	__IO uint32_t  SUBSECOND_INCR;			/*!< Sub-second increment register */
+	__I  uint32_t  SECONDS;					/*!< System time seconds register */
+	__I  uint32_t  NANOSECONDS;				/*!< System time nanoseconds register */
+	__IO uint32_t  SECONDSUPDATE;			/*!< System time seconds update register */
+	__IO uint32_t  NANOSECONDSUPDATE;		/*!< System time nanoseconds update register */
+	__IO uint32_t  ADDEND;					/*!< Time stamp addend register */
+	__IO uint32_t  TARGETSECONDS;			/*!< Target time seconds register */
+	__IO uint32_t  TARGETNANOSECONDS;		/*!< Target time nanoseconds register */
+	__IO uint32_t  HIGHWORD;				/*!< System time higher word seconds register */
+	__I  uint32_t  TIMESTAMPSTAT;			/*!< Time stamp status register */
+	__IO uint32_t  PPSCTRL;					/*!< PPS control register */
+	__I  uint32_t  AUXNANOSECONDS;			/*!< Auxiliary time stamp nanoseconds register */
+	__I  uint32_t  AUXSECONDS;				/*!< Auxiliary time stamp seconds register */
+	__I  uint32_t  RESERVED3[562];
+	__IO uint32_t  DMA_BUS_MODE;			/*!< Bus Mode Register      */
+	__IO uint32_t  DMA_TRANS_POLL_DEMAND;	/*!< Transmit poll demand register */
+	__IO uint32_t  DMA_REC_POLL_DEMAND;		/*!< Receive poll demand register */
+	__IO uint32_t  DMA_REC_DES_ADDR;		/*!< Receive descriptor list address register */
+	__IO uint32_t  DMA_TRANS_DES_ADDR;		/*!< Transmit descriptor list address register */
+	__IO uint32_t  DMA_STAT;				/*!< Status register */
+	__IO uint32_t  DMA_OP_MODE;				/*!< Operation mode register */
+	__IO uint32_t  DMA_INT_EN;				/*!< Interrupt enable register */
+	__I  uint32_t  DMA_MFRM_BUFOF;			/*!< Missed frame and buffer overflow register */
+	__IO uint32_t  DMA_REC_INT_WDT;			/*!< Receive interrupt watchdog timer register */
+	__I  uint32_t  RESERVED4[8];
+	__I  uint32_t  DMA_CURHOST_TRANS_DES;	/*!< Current host transmit descriptor register */
+	__I  uint32_t  DMA_CURHOST_REC_DES;		/*!< Current host receive descriptor register */
+	__I  uint32_t  DMA_CURHOST_TRANS_BUF;	/*!< Current host transmit buffer address register */
+	__I  uint32_t  DMA_CURHOST_REC_BUF;		/*!< Current host receive buffer address register */
+} LPC_ENET_T;
+
+/*
+ * @brief MAC_CONFIG register bit defines
+ */
+#define MAC_CFG_RE     (1 << 2)		/*!< Receiver enable */
+#define MAC_CFG_TE     (1 << 3)		/*!< Transmitter Enable */
+#define MAC_CFG_DF     (1 << 4)		/*!< Deferral Check */
+#define MAC_CFG_BL(n)  ((n) << 5)	/*!< Back-Off Limit */
+#define MAC_CFG_ACS    (1 << 7)		/*!< Automatic Pad/CRC Stripping */
+#define MAC_CFG_LUD    (1 << 8)		/*!< Link Up/Down, 1 = up */
+#define MAC_CFG_DR     (1 << 9)		/*!< Disable Retry */
+#define MAC_CFG_IPC    (1 << 10)	/*!< Checksum Offload */
+#define MAC_CFG_DM     (1 << 11)	/*!< Duplex Mode, 1 = full, 0 = half */
+#define MAC_CFG_LM     (1 << 12)	/*!< Loopback Mode */
+#define MAC_CFG_DO     (1 << 13)	/*!< Disable Receive Own */
+#define MAC_CFG_FES    (1 << 14)	/*!< Speed, 1 = 100Mbps, 0 = 10Mbos */
+#define MAC_CFG_PS     (1 << 15)	/*!< Port select, must always be 1 */
+#define MAC_CFG_DCRS   (1 << 16)	/*!< Disable carrier sense during transmission */
+#define MAC_CFG_IFG(n) ((n) << 17)	/*!< Inter-frame gap, 40..96, n incs by 8 */
+#define MAC_CFG_JE     (1 << 20)	/*!< Jumbo Frame Enable */
+#define MAC_CFG_JD     (1 << 22)	/*!< Jabber Disable */
+#define MAC_CFG_WD     (1 << 23)	/*!< Watchdog Disable */
+
+/*
+ * @brief MAC_FRAME_FILTER register bit defines
+ */
+#define MAC_FF_PR      (1 << 0)		/*!< Promiscuous Mode */
+#define MAC_FF_DAIF    (1 << 3)		/*!< DA Inverse Filtering */
+#define MAC_FF_PM      (1 << 4)		/*!< Pass All Multicast */
+#define MAC_FF_DBF     (1 << 5)		/*!< Disable Broadcast Frames */
+#define MAC_FF_PCF(n)  ((n) << 6)	/*!< Pass Control Frames, n = see user manual */
+#define MAC_FF_SAIF    (1 << 8)		/*!< SA Inverse Filtering */
+#define MAC_FF_SAF     (1 << 9)		/*!< Source Address Filter Enable */
+#define MAC_FF_RA      (1UL << 31)	/*!< Receive all */
+
+/*
+ * @brief MAC_MII_ADDR register bit defines
+ */
+#define MAC_MIIA_GB    (1 << 0)		/*!< MII busy */
+#define MAC_MIIA_W     (1 << 1)		/*!< MII write */
+#define MAC_MIIA_CR(n) ((n) << 2)	/*!< CSR clock range, n = see manual */
+#define MAC_MIIA_GR(n) ((n) << 6)	/*!< MII register. n = 0..31 */
+#define MAC_MIIA_PA(n) ((n) << 11)	/*!< Physical layer address, n = 0..31 */
+
+/*
+ * @brief MAC_MII_DATA register bit defines
+ */
+#define MAC_MIID_GDMSK (0xFFFF)		/*!< MII data mask */
+
+/**
+ * @brief MAC_FLOW_CONTROL register bit defines
+ */
+#define MAC_FC_FCB     (1 << 0)		/*!< Flow Control Busy/Backpressure Activate */
+#define MAC_FC_TFE     (1 << 1)		/*!< Transmit Flow Control Enable */
+#define MAC_FC_RFE     (1 << 2)		/*!< Receive Flow Control Enable */
+#define MAC_FC_UP      (1 << 3)		/*!< Unicast Pause Frame Detect */
+#define MAC_FC_PLT(n)  ((n) << 4)	/*!< Pause Low Threshold, n = see manual */
+#define MAC_FC_DZPQ    (1 << 7)		/*!< Disable Zero-Quanta Pause */
+#define MAC_FC_PT(n)   ((n) << 16)	/*!< Pause time */
+
+/*
+ * @brief MAC_VLAN_TAG register bit defines
+ */
+#define MAC_VT_VL(n)   ((n) << 0)	/*!< VLAN Tag Identifier for Receive Frames */
+#define MAC_VT_ETC     (1 << 7)		/*!< Enable 12-Bit VLAN Tag Comparison */
+
+/*
+ * @brief MAC_PMT_CTRL_STAT register bit defines
+ */
+#define MAC_PMT_PD     (1 << 0)		/*!< Power-down */
+#define MAC_PMT_MPE    (1 << 1)		/*!< Magic packet enable */
+#define MAC_PMT_WFE    (1 << 2)		/*!< Wake-up frame enable */
+#define MAC_PMT_MPR    (1 << 5)		/*!< Magic Packet Received */
+#define MAC_PMT_WFR    (1 << 6)		/*!< Wake-up Frame Received */
+#define MAC_PMT_GU     (1 << 9)		/*!< Global Unicast */
+#define MAC_PMT_WFFRPR (1UL << 31)	/*!< Wake-up Frame Filter Register Pointer Reset */
+
+/*
+ * @brief MAC_INTR_MASK register bit defines
+ */
+#define MAC_IM_PMT     (1 << 3)		/*!< PMT Interrupt Mask */
+
+/*
+ * @brief MAC_ADDR0_HIGH register bit defines
+ */
+#define MAC_ADRH_MO    (1UL << 31)	/*!< Always 1 when writing register */
+
+/*
+ * @brief MAC_ADDR0_HIGH register bit defines
+ */
+#define MAC_ADRH_MO    (1UL << 31)	/*!< Always 1 when writing register */
+
+/*
+ * @brief MAC_TIMESTAMP register bit defines
+ */
+#define MAC_TS_TSENA   (1 << 0)		/*!< Time Stamp Enable */
+#define MAC_TS_TSCFUP  (1 << 1)		/*!< Time Stamp Fine or Coarse Update */
+#define MAC_TS_TSINIT  (1 << 2)		/*!< Time Stamp Initialize */
+#define MAC_TS_TSUPDT  (1 << 3)		/*!< Time Stamp Update */
+#define MAC_TS_TSTRIG  (1 << 4)		/*!< Time Stamp Interrupt Trigger Enable */
+#define MAC_TS_TSADDR  (1 << 5)		/*!< Addend Reg Update */
+#define MAC_TS_TSENAL  (1 << 8)		/*!< Enable Time Stamp for All Frames */
+#define MAC_TS_TSCTRL  (1 << 9)		/*!< Time Stamp Digital or Binary rollover control */
+#define MAC_TS_TSVER2  (1 << 10)	/*!< Enable PTP packet snooping for version 2 format */
+#define MAC_TS_TSIPENA (1 << 11)	/*!< Enable Time Stamp Snapshot for PTP over Ethernet frames */
+#define MAC_TS_TSIPV6E (1 << 12)	/*!< Enable Time Stamp Snapshot for IPv6 frames */
+#define MAC_TS_TSIPV4E (1 << 13)	/*!< Enable Time Stamp Snapshot for IPv4 frames */
+#define MAC_TS_TSEVNT  (1 << 14)	/*!< Enable Time Stamp Snapshot for Event Messages */
+#define MAC_TS_TSMSTR  (1 << 15)	/*!< Enable Snapshot for Messages Relevant to Master */
+#define MAC_TS_TSCLKT(n) ((n) << 16)	/*!< Select the type of clock node, n = see menual */
+#define MAC_TS_TSENMA  (1 << 18)	/*!< Enable MAC address for PTP frame filtering */
+
+/*
+ * @brief DMA_BUS_MODE register bit defines
+ */
+#define DMA_BM_SWR     (1 << 0)		/*!< Software reset */
+#define DMA_BM_DA      (1 << 1)		/*!< DMA arbitration scheme, 1 = TX has priority over TX */
+#define DMA_BM_DSL(n)  ((n) << 2)	/*!< Descriptor skip length, n = see manual */
+#define DMA_BM_ATDS    (1 << 7)		/*!< Alternate (Enhanced) descriptor size */
+#define DMA_BM_PBL(n)  ((n) << 8)	/*!< Programmable burst length, n = see manual */
+#define DMA_BM_PR(n)   ((n) << 14)	/*!< Rx-to-Tx priority ratio, n = see manual */
+#define DMA_BM_FB      (1 << 16)	/*!< Fixed burst */
+#define DMA_BM_RPBL(n) ((n) << 17)	/*!< RxDMA PBL, n = see manual */
+#define DMA_BM_USP     (1 << 23)	/*!< Use separate PBL */
+#define DMA_BM_PBL8X   (1 << 24)	/*!< 8 x PBL mode */
+#define DMA_BM_AAL     (1 << 25)	/*!< Address-aligned beats */
+#define DMA_BM_MB      (1 << 26)	/*!< Mixed burst */
+#define DMA_BM_TXPR    (1 << 27)	/*!< Transmit DMA has higher priority than receive DMA */
+
+/*
+ * @brief DMA_STAT register bit defines
+ */
+#define DMA_ST_TI      (1 << 0)		/*!< Transmit interrupt */
+#define DMA_ST_TPS     (1 << 1)		/*!< Transmit process stopped */
+#define DMA_ST_TU      (1 << 2)		/*!< Transmit buffer unavailable */
+#define DMA_ST_TJT     (1 << 3)		/*!< Transmit jabber timeout */
+#define DMA_ST_OVF     (1 << 4)		/*!< Receive overflow */
+#define DMA_ST_UNF     (1 << 5)		/*!< Transmit underflow */
+#define DMA_ST_RI      (1 << 6)		/*!< Receive interrupt */
+#define DMA_ST_RU      (1 << 7)		/*!< Receive buffer unavailable */
+#define DMA_ST_RPS     (1 << 8)		/*!< Received process stopped */
+#define DMA_ST_RWT     (1 << 9)		/*!< Receive watchdog timeout */
+#define DMA_ST_ETI     (1 << 10)	/*!< Early transmit interrupt */
+#define DMA_ST_FBI     (1 << 13)	/*!< Fatal bus error interrupt */
+#define DMA_ST_ERI     (1 << 14)	/*!< Early receive interrupt */
+#define DMA_ST_AIE     (1 << 15)	/*!< Abnormal interrupt summary */
+#define DMA_ST_NIS     (1 << 16)	/*!< Normal interrupt summary */
+#define DMA_ST_ALL     (0x1E7FF)	/*!< All interrupts */
+
+/*
+ * @brief DMA_OP_MODE register bit defines
+ */
+#define DMA_OM_SR      (1 << 1)		/*!< Start/stop receive */
+#define DMA_OM_OSF     (1 << 2)		/*!< Operate on second frame */
+#define DMA_OM_RTC(n)  ((n) << 3)	/*!< Receive threshold control, n = see manual */
+#define DMA_OM_FUF     (1 << 6)		/*!< Forward undersized good frames */
+#define DMA_OM_FEF     (1 << 7)		/*!< Forward error frames */
+#define DMA_OM_ST      (1 << 13)	/*!< Start/Stop Transmission Command */
+#define DMA_OM_TTC(n)  ((n) << 14)	/*!< Transmit threshold control, n = see manual */
+#define DMA_OM_FTF     (1 << 20)	/*!< Flush transmit FIFO */
+#define DMA_OM_TSF     (1 << 21)	/*!< Transmit store and forward */
+#define DMA_OM_DFF     (1 << 24)	/*!< Disable flushing of received frames */
+#define DMA_OM_RSF     (1 << 25)	/*!< Receive store and forward */
+#define DMA_OM_DT      (1 << 26)	/*!< Disable Dropping of TCP/IP Checksum Error Frames */
+
+/*
+ * @brief DMA_INT_EN register bit defines
+ */
+#define DMA_IE_TIE     (1 << 0)		/*!< Transmit interrupt enable */
+#define DMA_IE_TSE     (1 << 1)		/*!< Transmit stopped enable */
+#define DMA_IE_TUE     (1 << 2)		/*!< Transmit buffer unavailable enable */
+#define DMA_IE_TJE     (1 << 3)		/*!< Transmit jabber timeout enable */
+#define DMA_IE_OVE     (1 << 4)		/*!< Overflow interrupt enable */
+#define DMA_IE_UNE     (1 << 5)		/*!< Underflow interrupt enable */
+#define DMA_IE_RIE     (1 << 6)		/*!< Receive interrupt enable */
+#define DMA_IE_RUE     (1 << 7)		/*!< Receive buffer unavailable enable */
+#define DMA_IE_RSE     (1 << 8)		/*!< Received stopped enable */
+#define DMA_IE_RWE     (1 << 9)		/*!< Receive watchdog timeout enable */
+#define DMA_IE_ETE     (1 << 10)	/*!< Early transmit interrupt enable */
+#define DMA_IE_FBE     (1 << 13)	/*!< Fatal bus error enable */
+#define DMA_IE_ERE     (1 << 14)	/*!< Early receive interrupt enable */
+#define DMA_IE_AIE     (1 << 15)	/*!< Abnormal interrupt summary enable */
+#define DMA_IE_NIE     (1 << 16)	/*!< Normal interrupt summary enable */
+
+/*
+ * @brief DMA_MFRM_BUFOF register bit defines
+ */
+#define DMA_MFRM_FMCMSK (0xFFFF)	/*!< Number of frames missed mask */
+#define DMA_MFRM_OC    (1 << 16)	/*!< Overflow bit for missed frame counter */
+#define DMA_MFRM_FMA(n) (((n) & 0x0FFE0000) >> 17)	/*!< Number of frames missed by the application mask/shift */
+#define DMA_MFRM_OF    (1 << 28)	/*!< Overflow bit for FIFO overflow counter */
+
+/*
+ * @brief Common TRAN_DESC_T and TRAN_DESC_ENH_T CTRLSTAT field bit defines
+ */
+#define TDES_DB        (1 << 0)		/*!< Deferred Bit */
+#define TDES_UF        (1 << 1)		/*!< Underflow Error */
+#define TDES_ED        (1 << 2)		/*!< Excessive Deferral */
+#define TDES_CCMSK(n)  (((n) & 0x000000F0) >> 3)/*!< CC: Collision Count (Status field) mask and shift */
+#define TDES_VF        (1 << 7)		/*!< VLAN Frame */
+#define TDES_EC        (1 << 8)		/*!< Excessive Collision */
+#define TDES_LC        (1 << 9)		/*!< Late Collision */
+#define TDES_NC        (1 << 10)	/*!< No Carrier */
+#define TDES_LCAR      (1 << 11)	/*!< Loss of Carrier */
+#define TDES_IPE       (1 << 12)	/*!< IP Payload Error */
+#define TDES_FF        (1 << 13)	/*!< Frame Flushed */
+#define TDES_JT        (1 << 14)	/*!< Jabber Timeout */
+#define TDES_ES        (1 << 15)	/*!< Error Summary */
+#define TDES_IHE       (1 << 16)	/*!< IP Header Error */
+#define TDES_TTSS      (1 << 17)	/*!< Transmit Timestamp Status */
+#define TDES_OWN       (1UL << 31)	/*!< Own Bit */
+
+/*
+ * @brief TRAN_DESC_ENH_T only CTRLSTAT field bit defines
+ */
+#define TDES_ENH_IC   (1UL << 30)	/*!< Interrupt on Completion, enhanced descriptor */
+#define TDES_ENH_LS   (1 << 29)		/*!< Last Segment, enhanced descriptor */
+#define TDES_ENH_FS   (1 << 28)		/*!< First Segment, enhanced descriptor */
+#define TDES_ENH_DC   (1 << 27)		/*!< Disable CRC, enhanced descriptor */
+#define TDES_ENH_DP   (1 << 26)		/*!< Disable Pad, enhanced descriptor */
+#define TDES_ENH_TTSE (1 << 25)		/*!< Transmit Timestamp Enable, enhanced descriptor */
+#define TDES_ENH_CIC(n) ((n) << 22)	/*!< Checksum Insertion Control, enhanced descriptor */
+#define TDES_ENH_TER  (1 << 21)		/*!< Transmit End of Ring, enhanced descriptor */
+#define TDES_ENH_TCH  (1 << 20)		/*!< Second Address Chained, enhanced descriptor */
+
+/*
+ * @brief TRAN_DESC_T only BSIZE field bit defines
+ */
+#define TDES_NORM_IC   (1UL << 31)	/*!< Interrupt on Completion, normal descriptor */
+#define TDES_NORM_FS   (1 << 30)	/*!< First Segment, normal descriptor */
+#define TDES_NORM_LS   (1 << 29)	/*!< Last Segment, normal descriptor */
+#define TDES_NORM_CIC(n) ((n) << 27)	/*!< Checksum Insertion Control, normal descriptor */
+#define TDES_NORM_DC   (1 << 26)	/*!< Disable CRC, normal descriptor */
+#define TDES_NORM_TER  (1 << 25)	/*!< Transmit End of Ring, normal descriptor */
+#define TDES_NORM_TCH  (1 << 24)	/*!< Second Address Chained, normal descriptor */
+#define TDES_NORM_DP   (1 << 23)	/*!< Disable Pad, normal descriptor */
+#define TDES_NORM_TTSE (1 << 22)	/*!< Transmit Timestamp Enable, normal descriptor */
+#define TDES_NORM_BS2(n) (((n) & 0x3FF) << 11)	/*!< Buffer 2 size, normal descriptor */
+#define TDES_NORM_BS1(n) (((n) & 0x3FF) << 0)	/*!< Buffer 1 size, normal descriptor */
+
+/*
+ * @brief TRAN_DESC_ENH_T only BSIZE field bit defines
+ */
+#define TDES_ENH_BS2(n) (((n) & 0xFFF) << 16)	/*!< Buffer 2 size, enhanced descriptor */
+#define TDES_ENH_BS1(n) (((n) & 0xFFF) << 0)	/*!< Buffer 1 size, enhanced descriptor */
+
+/*
+ * @brief Common REC_DESC_T and REC_DESC_ENH_T STATUS field bit defines
+ */
+#define RDES_ESA      (1 << 0)		/*!< Extended Status Available/Rx MAC Address */
+#define RDES_CE       (1 << 1)		/*!< CRC Error */
+#define RDES_DRE      (1 << 2)		/*!< Dribble Bit Error */
+#define RDES_RE       (1 << 3)		/*!< Receive Error */
+#define RDES_RWT      (1 << 4)		/*!< Receive Watchdog Timeout */
+#define RDES_FT       (1 << 5)		/*!< Frame Type */
+#define RDES_LC       (1 << 6)		/*!< Late Collision */
+#define RDES_TSA      (1 << 7)		/*!< Timestamp Available/IP Checksum Error (Type1) /Giant Frame */
+#define RDES_LS       (1 << 8)		/*!< Last Descriptor */
+#define RDES_FS       (1 << 9)		/*!< First Descriptor */
+#define RDES_VLAN     (1 << 10)		/*!< VLAN Tag */
+#define RDES_OE       (1 << 11)		/*!< Overflow Error */
+#define RDES_LE       (1 << 12)		/*!< Length Error */
+#define RDES_SAF      (1 << 13)		/*!< Source Address Filter Fail */
+#define RDES_DE       (1 << 14)		/*!< Descriptor Error */
+#define RDES_ES       (1 << 15)		/*!< ES: Error Summary */
+#define RDES_FLMSK(n) (((n) & 0x3FFF0000) >> 16)/*!< Frame Length mask and shift */
+#define RDES_AFM      (1 << 30)		/*!< Destination Address Filter Fail */
+#define RDES_OWN      (1UL << 31)	/*!< Own Bit */
+
+/*
+ * @brief Common REC_DESC_T and REC_DESC_ENH_T CTRL field bit defines
+ */
+#define RDES_DINT     (1UL << 31)	/*!< Disable interrupt on completion */
+
+/*
+ * @brief REC_DESC_T pnly CTRL field bit defines
+ */
+#define RDES_NORM_RER (1 << 25)		/*!< Receive End of Ring, normal descriptor */
+#define RDES_NORM_RCH (1 << 24)		/*!< Second Address Chained, normal descriptor */
+#define RDES_NORM_BS2(n) (((n) & 0x3FF) << 11)	/*!< Buffer 2 size, normal descriptor */
+#define RDES_NORM_BS1(n) (((n) & 0x3FF) << 0)	/*!< Buffer 1 size, normal descriptor */
+
+/**
+ * @brief REC_DESC_ENH_T only CTRL field bit defines
+ */
+#define RDES_ENH_RER  (1 << 15)		/*!< Receive End of Ring, enhanced descriptor */
+#define RDES_ENH_RCH  (1 << 14)		/*!< Second Address Chained, enhanced descriptor */
+#define RDES_ENH_BS2(n) (((n) & 0xFFF) << 16)	/*!< Buffer 2 size, enhanced descriptor */
+#define RDES_ENH_BS1(n) (((n) & 0xFFF) << 0)	/*!< Buffer 1 size, enhanced descriptor */
+
+/*
+ * @brief REC_DESC_ENH_T only EXTSTAT field bit defines
+ */
+#define RDES_ENH_IPPL(n)  (((n) & 0x7) >> 2)	/*!< IP Payload Type mask and shift, enhanced descripto */
+#define RDES_ENH_IPHE     (1 << 3)	/*!< IP Header Error, enhanced descripto */
+#define RDES_ENH_IPPLE    (1 << 4)	/*!< IP Payload Error, enhanced descripto */
+#define RDES_ENH_IPCSB    (1 << 5)	/*!< IP Checksum Bypassed, enhanced descripto */
+#define RDES_ENH_IPV4     (1 << 6)	/*!< IPv4 Packet Received, enhanced descripto */
+#define RDES_ENH_IPV6     (1 << 7)	/*!< IPv6 Packet Received, enhanced descripto */
+#define RDES_ENH_MTMSK(n) (((n) & 0xF) >> 8)	/*!< Message Type mask and shift, enhanced descripto */
+
+/*
+ * @brief Maximum size of an ethernet buffer
+ */
+#define EMAC_ETH_MAX_FLEN (1536)
+
+/**
+ * @brief Structure of a transmit descriptor (without timestamp)
+ */
+typedef struct {
+	__IO uint32_t CTRLSTAT;		/*!< TDES control and status word */
+	__IO uint32_t BSIZE;		/*!< Buffer 1/2 byte counts */
+	__IO uint32_t B1ADD;		/*!< Buffer 1 address */
+	__IO uint32_t B2ADD;		/*!< Buffer 2 or next descriptor address */
+} ENET_TXDESC_T;
+
+/**
+ * @brief Structure of a enhanced transmit descriptor (with timestamp)
+ */
+typedef struct {
+	__IO uint32_t CTRLSTAT;		/*!< TDES control and status word */
+	__IO uint32_t BSIZE;		/*!< Buffer 1/2 byte counts */
+	__IO uint32_t B1ADD;		/*!< Buffer 1 address */
+	__IO uint32_t B2ADD;		/*!< Buffer 2 or next descriptor address */
+	__IO uint32_t TDES4;		/*!< Reserved */
+	__IO uint32_t TDES5;		/*!< Reserved */
+	__IO uint32_t TTSL;			/*!< Timestamp value low */
+	__IO uint32_t TTSH;			/*!< Timestamp value high */
+} ENET_ENHTXDESC_T;
+
+/**
+ * @brief Structure of a receive descriptor (without timestamp)
+ */
+typedef struct {
+	__IO uint32_t STATUS;		/*!< RDES status word */
+	__IO uint32_t CTRL;			/*!< Buffer 1/2 byte counts and control */
+	__IO uint32_t B1ADD;		/*!< Buffer 1 address */
+	__IO uint32_t B2ADD;		/*!< Buffer 2 or next descriptor address */
+} ENET_RXDESC_T;
+
+/**
+ * @brief Structure of a enhanced receive descriptor (with timestamp)
+ */
+typedef struct {
+	__IO uint32_t STATUS;		/*!< RDES status word */
+	__IO uint32_t CTRL;			/*!< Buffer 1/2 byte counts */
+	__IO uint32_t B1ADD;		/*!< Buffer 1 address */
+	__IO uint32_t B2ADD;		/*!< Buffer 2 or next descriptor address */
+	__IO uint32_t EXTSTAT;		/*!< Extended Status */
+	__IO uint32_t RDES5;		/*!< Reserved */
+	__IO uint32_t RTSL;			/*!< Timestamp value low */
+	__IO uint32_t RTSH;			/*!< Timestamp value high */
+} ENET_ENHRXDESC_T;
+
+/**
+ * @brief	Resets the ethernet interface
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ * @note	Resets the ethernet interface. This should be called prior to
+ * Chip_ENET_Init with a small delay after this call.
+ */
+STATIC INLINE void Chip_ENET_Reset(LPC_ENET_T *pENET)
+{
+	/* This should be called prior to IP_ENET_Init. The MAC controller may
+	   not be ready for a call to init right away so a small delay should
+	   occur after this call. */
+	pENET->DMA_BUS_MODE |= DMA_BM_SWR;
+}
+
+/**
+ * @brief	Sets the address of the interface
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @param	macAddr	: Pointer to the 6 bytes used for the MAC address
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_SetADDR(LPC_ENET_T *pENET, const uint8_t *macAddr)
+{
+	/* Save MAC address */
+	pENET->MAC_ADDR0_LOW = ((uint32_t) macAddr[3] << 24) |
+						   ((uint32_t) macAddr[2] << 16) | ((uint32_t) macAddr[1] << 8) |
+						   ((uint32_t) macAddr[0]);
+	pENET->MAC_ADDR0_HIGH = ((uint32_t) macAddr[5] << 8) |
+							((uint32_t) macAddr[4]);
+}
+
+/**
+ * @brief	Sets up the PHY link clock divider and PHY address
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @param	div		: Divider index, not a divider value, see user manual
+ * @param	addr	: PHY address, used with MII read and write
+ * @return	Nothing
+ */
+void Chip_ENET_SetupMII(LPC_ENET_T *pENET, uint32_t div, uint8_t addr);
+
+/**
+ * @brief	Starts a PHY write via the MII
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @param	reg		: PHY register to write
+ * @param	data	: Data to write to PHY register
+ * @return	Nothing
+ * @note	Start a PHY write operation. Does not block, requires calling
+ * IP_ENET_IsMIIBusy to determine when write is complete.
+ */
+void Chip_ENET_StartMIIWrite(LPC_ENET_T *pENET, uint8_t reg, uint16_t data);
+
+/**
+ * @brief	Starts a PHY read via the MII
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @param	reg		: PHY register to read
+ * @return	Nothing
+ * @note	Start a PHY read operation. Does not block, requires calling
+ * IP_ENET_IsMIIBusy to determine when read is complete and calling
+ * IP_ENET_ReadMIIData to get the data.
+ */
+void Chip_ENET_StartMIIRead(LPC_ENET_T *pENET, uint8_t reg);
+
+/**
+ * @brief	Returns MII link (PHY) busy status
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Returns true if busy, otherwise false
+ */
+STATIC INLINE bool Chip_ENET_IsMIIBusy(LPC_ENET_T *pENET)
+{
+	return (pENET->MAC_MII_ADDR & MAC_MIIA_GB) ? true : false;
+}
+
+/**
+ * @brief	Returns the value read from the PHY
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Read value from PHY
+ */
+STATIC INLINE uint16_t Chip_ENET_ReadMIIData(LPC_ENET_T *pENET)
+{
+	return pENET->MAC_MII_DATA;
+}
+
+/**
+ * @brief	Enables ethernet transmit
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_TXEnable(LPC_ENET_T *pENET)
+{
+	pENET->MAC_CONFIG |= MAC_CFG_TE;
+	pENET->DMA_OP_MODE |= DMA_OM_ST;
+}
+
+/**
+ * @brief Disables ethernet transmit
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_TXDisable(LPC_ENET_T *pENET)
+{
+	pENET->MAC_CONFIG &= ~MAC_CFG_TE;
+}
+
+/**
+ * @brief	Enables ethernet packet reception
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_RXEnable(LPC_ENET_T *pENET)
+{
+	pENET->MAC_CONFIG |= MAC_CFG_RE;
+	pENET->DMA_OP_MODE |= DMA_OM_SR;
+}
+
+/**
+ * @brief	Disables ethernet packet reception
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_RXDisable(LPC_ENET_T *pENET)
+{
+	pENET->MAC_CONFIG &= ~MAC_CFG_RE;
+}
+
+/**
+ * @brief	Enable RMII ethernet operation
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ * @note	This function must be called to enable the internal
+ * RMII PHY, and must be called before calling any Ethernet
+ * functions.
+ */
+STATIC INLINE void Chip_ENET_RMIIEnable(LPC_ENET_T *pENET)
+{
+	LPC_CREG->CREG6 |= 0x4;
+}
+
+/**
+ * @brief	Enable MII ethernet operation
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ * @note	This function must be called to enable the
+ * MII PHY, and must be called before calling any Ethernet
+ * functions.
+ */
+STATIC INLINE void Chip_ENET_MIIEnable(LPC_ENET_T *pENET)
+{
+	LPC_CREG->CREG6 &= ~0x7;
+}
+
+/**
+ * @brief	Sets full or half duplex for the interface
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @param	full	: true to selected full duplex, false for half
+ * @return	Nothing
+ */
+void Chip_ENET_SetDuplex(LPC_ENET_T *pENET, bool full);
+
+/**
+ * @brief	Sets speed for the interface
+ * @param	pENET		: The base of ENET peripheral on the chip
+ * @param	speed100	: true to select 100Mbps mode, false for 10Mbps
+ * @return	Nothing
+ */
+void Chip_ENET_SetSpeed(LPC_ENET_T *pENET, bool speed100);
+
+/**
+ * @brief	Configures the initial ethernet descriptors
+ * @param	pENET		: The base of ENET peripheral on the chip
+ * @param	pTXDescs	: Pointer to TX descriptor list
+ * @param	pRXDescs	: Pointer to RX descriptor list
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_InitDescriptors(LPC_ENET_T *pENET,
+											 ENET_ENHTXDESC_T *pTXDescs, ENET_ENHRXDESC_T *pRXDescs)
+{
+	/* Setup descriptor list base addresses */
+	pENET->DMA_TRANS_DES_ADDR = (uint32_t) pTXDescs;
+	pENET->DMA_REC_DES_ADDR = (uint32_t) pRXDescs;
+}
+
+/**
+ * @brief	Starts receive polling of RX descriptors
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_RXStart(LPC_ENET_T *pENET)
+{
+	/* Start receive polling */
+	pENET->DMA_REC_POLL_DEMAND = 1;
+}
+
+/**
+ * @brief	Starts transmit polling of TX descriptors
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_ENET_TXStart(LPC_ENET_T *pENET)
+{
+	/* Start transmit polling */
+	pENET->DMA_TRANS_POLL_DEMAND = 1;
+}
+
+/**
+ * @brief	Initialize ethernet interface
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @param	phyAddr : Address of the Phy [valid range 0 to 31]
+ * @return	Nothing
+ * @note	Performs basic initialization of the ethernet interface in a default
+ * state. This is enough to place the interface in a usable state, but
+ * may require more setup outside this function.
+ */
+void Chip_ENET_Init(LPC_ENET_T *pENET, uint32_t phyAddr);
+
+/**
+ * @brief	De-initialize the ethernet interface
+ * @param	pENET	: The base of ENET peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_ENET_DeInit(LPC_ENET_T *pENET);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ENET_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/error.h ./libs/vendor_libs/lpc_chip_43xx/inc/error.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/error.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/error.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,278 @@
+/*
+ * @brief Error code returned by Boot ROM drivers/library functions
+ *
+ *  This file contains unified error codes to be used across driver,
+ *  middleware, applications, hal and demo software.
+ *
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LPC_ERROR_H__
+#define __LPC_ERROR_H__
+
+/** Error code returned by Boot ROM drivers/library functions
+ *
+ *  Error codes are a 32-bit value with :
+ *      - The 16 MSB contains the peripheral code number
+ *      - The 16 LSB contains an error code number associated to that peripheral
+ *
+ */
+typedef enum
+{
+  /**\b 0x00000000*/ LPC_OK=0, /**< enum value returned on Success */
+  /**\b 0xFFFFFFFF*/ ERR_FAILED = -1, /**< enum value returned on general failure */
+  /**\b 0xFFFFFFFE*/ ERR_TIME_OUT = -2, /**< enum value returned on general timeout */
+  /**\b 0xFFFFFFFD*/ ERR_BUSY = -3,	/**< enum value returned when resource is busy */
+
+  /* ISP related errors */
+  ERR_ISP_BASE = 0x00000000,
+  /*0x00000001*/ ERR_ISP_INVALID_COMMAND = ERR_ISP_BASE + 1,
+  /*0x00000002*/ ERR_ISP_SRC_ADDR_ERROR, /* Source address not on word boundary */
+  /*0x00000003*/ ERR_ISP_DST_ADDR_ERROR, /* Destination address not on word or 256 byte boundary */
+  /*0x00000004*/ ERR_ISP_SRC_ADDR_NOT_MAPPED,
+  /*0x00000005*/ ERR_ISP_DST_ADDR_NOT_MAPPED,
+  /*0x00000006*/ ERR_ISP_COUNT_ERROR, /* Byte count is not multiple of 4 or is not a permitted value */
+  /*0x00000007*/ ERR_ISP_INVALID_SECTOR,
+  /*0x00000008*/ ERR_ISP_SECTOR_NOT_BLANK,
+  /*0x00000009*/ ERR_ISP_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION,
+  /*0x0000000A*/ ERR_ISP_COMPARE_ERROR,
+  /*0x0000000B*/ ERR_ISP_BUSY, /* Flash programming hardware interface is busy */
+  /*0x0000000C*/ ERR_ISP_PARAM_ERROR, /* Insufficient number of parameters */
+  /*0x0000000D*/ ERR_ISP_ADDR_ERROR, /* Address not on word boundary */
+  /*0x0000000E*/ ERR_ISP_ADDR_NOT_MAPPED,
+  /*0x0000000F*/ ERR_ISP_CMD_LOCKED, /* Command is locked */
+  /*0x00000010*/ ERR_ISP_INVALID_CODE, /* Unlock code is invalid */
+  /*0x00000011*/ ERR_ISP_INVALID_BAUD_RATE,
+  /*0x00000012*/ ERR_ISP_INVALID_STOP_BIT,
+  /*0x00000013*/ ERR_ISP_CODE_READ_PROTECTION_ENABLED,
+  /*0x00000014*/ ERR_ISP_INVALID_FLASH_UNIT,
+  /*0x00000015*/ ERR_ISP_USER_CODE_CHECKSUM,
+  /*0x00000016*/ ERR_ISP_SETTING_ACTIVE_PARTITION,
+  /*0x00000017*/ ERR_ISP_IRC_NO_POWER,
+  /*0x00000018*/ ERR_ISP_FLASH_NO_POWER,
+  /*0x00000019*/ ERR_ISP_EEPROM_NO_POWER,
+  /*0x0000001A*/ ERR_ISP_EEPROM_NO_CLOCK,
+  /*0x0000001B*/ ERR_ISP_FLASH_NO_CLOCK,
+  /*0x0000001C*/ ERR_ISP_REINVOKE_ISP_CONFIG,
+  
+  /* ROM API related errors */
+  ERR_API_BASE = 0x00010000,
+  /**\b 0x00010001*/ ERR_API_INVALID_PARAMS = ERR_API_BASE + 1, /**< Invalid parameters*/
+  /**\b 0x00010002*/ ERR_API_INVALID_PARAM1, /**< PARAM1 is invalid */
+  /**\b 0x00010003*/ ERR_API_INVALID_PARAM2, /**< PARAM2 is invalid */
+  /**\b 0x00010004*/ ERR_API_INVALID_PARAM3, /**< PARAM3 is invalid */
+  /**\b 0x00010005*/ ERR_API_MOD_INIT, /**< API is called before module init */
+
+  /* SPIFI API related errors */
+  ERR_SPIFI_BASE = 0x00020000,
+  /*0x00020001*/ ERR_SPIFI_DEVICE_ERROR =ERR_SPIFI_BASE+1,  
+  /*0x00020002*/ ERR_SPIFI_INTERNAL_ERROR,		    
+  /*0x00020003*/ ERR_SPIFI_TIMEOUT,			    
+  /*0x00020004*/ ERR_SPIFI_OPERAND_ERROR,		    
+  /*0x00020005*/ ERR_SPIFI_STATUS_PROBLEM,		    
+  /*0x00020006*/ ERR_SPIFI_UNKNOWN_EXT, 		    
+  /*0x00020007*/ ERR_SPIFI_UNKNOWN_ID,  		    
+  /*0x00020008*/ ERR_SPIFI_UNKNOWN_TYPE,		    
+  /*0x00020009*/ ERR_SPIFI_UNKNOWN_MFG, 		    
+  /*0x0002000A*/ ERR_SPIFI_NO_DEVICE,
+  /*0x0002000B*/ ERR_SPIFI_ERASE_NEEDED, 		    
+
+  SEC_AES_NO_ERROR=0,
+  /* Security API related errors */
+  ERR_SEC_AES_BASE = 0x00030000,
+  /*0x00030001*/ ERR_SEC_AES_WRONG_CMD=ERR_SEC_AES_BASE+1,
+  /*0x00030002*/ ERR_SEC_AES_NOT_SUPPORTED,
+  /*0x00030003*/ ERR_SEC_AES_KEY_ALREADY_PROGRAMMED,
+  /*0x00030004*/ ERR_SEC_AES_DMA_CHANNEL_CFG,
+  /*0x00030005*/ ERR_SEC_AES_DMA_MUX_CFG,
+  /*0x00030006*/ SEC_AES_DMA_BUSY,      
+
+  /* USB device stack related errors */
+  ERR_USBD_BASE = 0x00040000,
+  /**\b 0x00040001*/ ERR_USBD_INVALID_REQ = ERR_USBD_BASE + 1, /**< invalid request */
+  /**\b 0x00040002*/ ERR_USBD_UNHANDLED, /**< Callback did not process the event */
+  /**\b 0x00040003*/ ERR_USBD_STALL,     /**< Stall the endpoint on which the call back is called */
+  /**\b 0x00040004*/ ERR_USBD_SEND_ZLP,  /**< Send ZLP packet on the endpoint on which the call back is called */
+  /**\b 0x00040005*/ ERR_USBD_SEND_DATA, /**< Send data packet on the endpoint on which the call back is called */
+  /**\b 0x00040006*/ ERR_USBD_BAD_DESC,  /**< Bad descriptor*/
+  /**\b 0x00040007*/ ERR_USBD_BAD_CFG_DESC,/**< Bad config descriptor*/
+  /**\b 0x00040008*/ ERR_USBD_BAD_INTF_DESC,/**< Bad interface descriptor*/
+  /**\b 0x00040009*/ ERR_USBD_BAD_EP_DESC,/**< Bad endpoint descriptor*/
+  /**\b 0x0004000a*/ ERR_USBD_BAD_MEM_BUF, /**< Bad alignment of buffer passed. */
+  /**\b 0x0004000b*/ ERR_USBD_TOO_MANY_CLASS_HDLR, /**< Too many class handlers. */
+
+  /* CGU  related errors */
+  ERR_CGU_BASE = 0x00050000,
+  /*0x00050001*/ ERR_CGU_NOT_IMPL=ERR_CGU_BASE+1,
+  /*0x00050002*/ ERR_CGU_INVALID_PARAM,
+  /*0x00050003*/ ERR_CGU_INVALID_SLICE,
+  /*0x00050004*/ ERR_CGU_OUTPUT_GEN,
+  /*0x00050005*/ ERR_CGU_DIV_SRC,
+  /*0x00050006*/ ERR_CGU_DIV_VAL,
+  /*0x00050007*/ ERR_CGU_SRC, 
+
+  /*  I2C related errors   */
+  ERR_I2C_BASE = 0x00060000,
+  /*0x00060000*/ ERR_I2C_BUSY = ERR_I2C_BASE,
+  /*0x00060001*/ ERR_I2C_NAK,
+  /*0x00060002*/ ERR_I2C_BUFFER_OVERFLOW,    
+  /*0x00060003*/ ERR_I2C_BYTE_COUNT_ERR,     
+  /*0x00060004*/ ERR_I2C_LOSS_OF_ARBRITRATION,    
+  /*0x00060005*/ ERR_I2C_SLAVE_NOT_ADDRESSED,     
+  /*0x00060006*/ ERR_I2C_LOSS_OF_ARBRITRATION_NAK_BIT,   
+  /*0x00060007*/ ERR_I2C_GENERAL_FAILURE,         
+  /*0x00060008*/ ERR_I2C_REGS_SET_TO_DEFAULT,
+  /*0x00060009*/ ERR_I2C_TIMEOUT,
+  /*0x0006000A*/ ERR_I2C_BUFFER_UNDERFLOW,
+  /*0x0006000B*/ ERR_I2C_PARAM,
+  
+   /* OTP  related errors */
+  ERR_OTP_BASE = 0x00070000,
+  /*0x00070001*/ ERR_OTP_WR_ENABLE_INVALID = ERR_OTP_BASE+1,
+  /*0x00070002*/ ERR_OTP_SOME_BITS_ALREADY_PROGRAMMED,
+  /*0x00070003*/ ERR_OTP_ALL_DATA_OR_MASK_ZERO,
+  /*0x00070004*/ ERR_OTP_WRITE_ACCESS_LOCKED,
+  /*0x00070005*/ ERR_OTP_READ_DATA_MISMATCH,
+  /*0x00070006*/ ERR_OTP_USB_ID_ENABLED,
+  /*0x00070007*/ ERR_OTP_ETH_MAC_ENABLED,
+  /*0x00070008*/ ERR_OTP_AES_KEYS_ENABLED,
+  /*0x00070009*/ ERR_OTP_ILLEGAL_BANK,
+
+  /*  UART related errors   */
+  ERR_UART_BASE = 0x00080000,
+  /*0x00080001*/ ERR_UART_RXD_BUSY = ERR_UART_BASE+1,   //UART rxd is busy
+  /*0x00080002*/ ERR_UART_TXD_BUSY,   //UART txd is busy
+  /*0x00080003*/ ERR_UART_OVERRUN_FRAME_PARITY_NOISE, //overrun err, frame err, parity err, RxNoise err
+  /*0x00080004*/ ERR_UART_UNDERRUN,    //underrun err    
+  /*0x00080005*/ ERR_UART_PARAM,       //parameter is error
+  /*0x00080006*/ ERR_UART_BAUDRATE,    //baudrate setting is error
+
+  /*  CAN related errors   */
+  ERR_CAN_BASE = 0x00090000,
+  /*0x00090001*/ ERR_CAN_BAD_MEM_BUF = ERR_CAN_BASE+1,
+  /*0x00090002*/ ERR_CAN_INIT_FAIL,
+  /*0x00090003*/ ERR_CANOPEN_INIT_FAIL,
+
+  /* SPIFI Lite API related errors */
+  ERR_SPIFI_LITE_BASE = 0x000A0000,
+  /*0x000A0001*/ ERR_SPIFI_LITE_INVALID_ARGUMENTS = ERR_SPIFI_LITE_BASE+1,  
+  /*0x000A0002*/ ERR_SPIFI_LITE_BUSY,		    
+  /*0x000A0003*/ ERR_SPIFI_LITE_MEMORY_MODE_ON,			    
+  /*0x000A0004*/ ERR_SPIFI_LITE_MEMORY_MODE_OFF,
+  /*0x000A0005*/ ERR_SPIFI_LITE_IN_DMA,
+  /*0x000A0006*/ ERR_SPIFI_LITE_NOT_IN_DMA,
+  /*0x000A0100*/ PENDING_SPIFI_LITE,
+
+  /* CLK related errors */
+  ERR_CLK_BASE = 0x000B0000,
+  /*0x000B0001*/ ERR_CLK_NOT_IMPL=ERR_CLK_BASE+1,
+  /*0x000B0002*/ ERR_CLK_INVALID_PARAM,
+  /*0x000B0003*/ ERR_CLK_INVALID_SLICE,
+  /*0x000B0004*/ ERR_CLK_OUTPUT_GEN,
+  /*0x000B0005*/ ERR_CLK_DIV_SRC,
+  /*0x000B0006*/ ERR_CLK_DIV_VAL,
+  /*0x000B0007*/ ERR_CLK_SRC,
+  /*0x000B0008*/ ERR_CLK_PLL_FIN_TOO_SMALL,
+  /*0x000B0009*/ ERR_CLK_PLL_FIN_TOO_LARGE,
+  /*0x000B000A*/ ERR_CLK_PLL_FOUT_TOO_SMALL,
+  /*0x000B000B*/ ERR_CLK_PLL_FOUT_TOO_LARGE,
+  /*0x000B000C*/ ERR_CLK_PLL_NO_SOLUTION,
+  /*0x000B000D*/ ERR_CLK_PLL_MIN_PCT,
+  /*0x000B000E*/ ERR_CLK_PLL_MAX_PCT,
+  /*0x000B000F*/ ERR_CLK_OSC_FREQ,
+  /*0x000B0010*/ ERR_CLK_CFG,
+  /*0x000B0011*/ ERR_CLK_TIMEOUT,
+  /*0x000B0012*/ ERR_CLK_BASE_OFF,
+  /*0x000B0013*/ ERR_CLK_OFF_DEADLOCK,
+    
+  /*Power API*/
+  ERR_PWR_BASE = 0x000C0000,
+  /*0x000C0001*/  PWR_ERROR_ILLEGAL_MODE=ERR_PWR_BASE+1,
+  /*0x000C0002*/  PWR_ERROR_CLOCK_FREQ_TOO_HIGH,
+  /*0x000C0003*/  PWR_ERROR_INVALID_STATE,
+  /*0x000C0004*/  PWR_ERROR_INVALID_CFG,
+  /*0x000C0005*/  PWR_ERROR_PVT_DETECT,
+
+  /* DMA related errors */
+  ERR_DMA_BASE = 0x000D0000,
+  /*0x000D0001*/	 ERR_DMA_ERROR_INT=ERR_DMA_BASE+1,
+  /*0x000D0002*/	 ERR_DMA_CHANNEL_NUMBER,
+  /*0x000D0003*/	 ERR_DMA_CHANNEL_DISABLED,
+  /*0x000D0004*/	 ERR_DMA_BUSY,
+  /*0x000D0005*/	 ERR_DMA_NOT_ALIGNMENT,
+  /*0x000D0006*/	 ERR_DMA_PING_PONG_EN,
+  /*0x000D0007*/	 ERR_DMA_CHANNEL_VALID_PENDING,
+  /*0x000D0008*/	 ERR_DMA_PARAM,
+  /*0x000D0009*/	 ERR_DMA_QUEUE_EMPTY,
+  /*0x000D000A*/	 ERR_DMA_GENERAL,
+
+  /* SPI related errors */
+  ERR_SPI_BASE = 0x000E0000,
+  /*0x000E0000*/	 ERR_SPI_BUSY=ERR_SPI_BASE,
+  /*0x000E0001*/	 ERR_SPI_RXOVERRUN,
+  /*0x000E0002*/	 ERR_SPI_TXUNDERRUN,
+  /*0x000E0003*/	 ERR_SPI_SELNASSERT,
+  /*0x000E0004*/	 ERR_SPI_SELNDEASSERT,
+  /*0x000E0005*/	 ERR_SPI_CLKSTALL,
+  /*0x000E0006*/	 ERR_SPI_PARAM,
+  /*0x000E0007*/	 ERR_SPI_INVALID_LENGTH,
+
+  /* ADC related errors */
+  ERR_ADC_BASE = 0x000F0000,
+  /*0x000F0001*/	 ERR_ADC_OVERRUN=ERR_ADC_BASE+1,
+  /*0x000F0002*/	 ERR_ADC_INVALID_CHANNEL,
+  /*0x000F0003*/	 ERR_ADC_INVALID_SEQUENCE,
+  /*0x000F0004*/	 ERR_ADC_INVALID_SETUP,
+  /*0x000F0005*/	 ERR_ADC_PARAM,
+  /*0x000F0006*/	 ERR_ADC_INVALID_LENGTH,
+  /*0x000F0007*/	 ERR_ADC_NO_POWER,
+
+  /* Debugger Mailbox related errors */
+  ERR_DM_BASE = 0x00100000,
+  /*0x00100001*/	 ERR_DM_NOT_ENTERED=ERR_DM_BASE+1,
+  /*0x00100002*/	 ERR_DM_UNKNOWN_CMD,
+  /*0x00100003*/	 ERR_DM_COMM_FAIL
+  
+} ErrorCode_t;
+
+#ifndef offsetof
+#define offsetof(s, m)   (int) &(((s *) 0)->m)
+#endif
+
+#define COMPILE_TIME_ASSERT(pred)    switch (0) { \
+	case 0:	\
+	case pred:; }
+
+#endif /* __LPC_ERROR_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/evrt_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/evrt_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/evrt_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/evrt_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,179 @@
+/*
+ * @brief LPC18xx/43xx event router driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __EVRT_18XX_43XX_H_
+#define __EVRT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup EVRT_18XX_43XX CHIP: LPC18xx/43xx Event router driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Event Router register structure
+ */
+typedef struct {						/*!< EVENTROUTER Structure  */
+	__IO uint32_t HILO;					/*!< Level configuration register */
+	__IO uint32_t EDGE;					/*!< Edge configuration     */
+	__I  uint32_t RESERVED0[1012];
+	__O  uint32_t CLR_EN;				/*!< Event clear enable register */
+	__O  uint32_t SET_EN;				/*!< Event set enable register */
+	__I  uint32_t STATUS;				/*!< Status register        */
+	__I  uint32_t ENABLE;				/*!< Enable register        */
+	__O  uint32_t CLR_STAT;				/*!< Clear register         */
+	__O  uint32_t SET_STAT;				/*!< Set register           */
+} LPC_EVRT_T;
+
+/**
+ * @brief EVRT input sources
+ */
+typedef enum CHIP_EVRT_SRC {
+	EVRT_SRC_WAKEUP0,			/*!< WAKEUP0 event router source		*/
+	EVRT_SRC_WAKEUP1,			/*!< WAKEUP1 event router source		*/
+	EVRT_SRC_WAKEUP2,			/*!< WAKEUP2 event router source		*/
+	EVRT_SRC_WAKEUP3,			/*!< WAKEUP3 event router source		*/
+	EVRT_SRC_ATIMER,			/*!< Alarm timer event router source	*/
+	EVRT_SRC_RTC,				/*!< RTC event router source			*/
+	EVRT_SRC_BOD1,				/*!< BOD event router source			*/
+	EVRT_SRC_WWDT,				/*!< WWDT event router source			*/
+	EVRT_SRC_ETHERNET,			/*!< Ethernet event router source		*/
+	EVRT_SRC_USB0,				/*!< USB0 event router source			*/
+	EVRT_SRC_USB1,				/*!< USB1 event router source			*/
+	EVRT_SRC_SDIO,				/*!< Reserved							*/
+	EVRT_SRC_CCAN,				/*!< C_CAN event router source			*/
+	EVRT_SRC_COMBINE_TIMER2,	/*!< Combined timer 2 event router source	*/
+	EVRT_SRC_COMBINE_TIMER6,	/*!< Combined timer 6 event router source	*/
+	EVRT_SRC_QEI,				/*!< QEI event router source			*/
+	EVRT_SRC_COMBINE_TIMER14,	/*!< Combined timer 14 event router source	*/
+	EVRT_SRC_RESERVED1,			/*!< Reserved                           */
+	EVRT_SRC_RESERVED2,			/*!< Reserved							*/
+	EVRT_SRC_RESET,				/*!< Reset event router source			*/
+    EVRT_SRC_BOD_RESET,			/*!< Reset event router source			*/
+    EVRT_SRC_DEEP_POWER_DOWN    /*!< Reset event router source			*/
+} CHIP_EVRT_SRC_T;
+
+/**
+ * @brief Macro for checking for a valid EVRT source
+ */
+#define PARAM_EVRT_SOURCE(n)    ((n == EVRT_SRC_WAKEUP0) || (n == EVRT_SRC_WAKEUP1)	\
+								 || (n == EVRT_SRC_WAKEUP2) || (n == EVRT_SRC_WAKEUP3) \
+								 || (n == EVRT_SRC_ATIMER) || (n == EVRT_SRC_RTC) \
+								 || (n == EVRT_SRC_BOD1) || (n == EVRT_SRC_WWDT) \
+								 || (n == EVRT_SRC_ETHERNET) || (n == EVRT_SRC_USB0) \
+								 || (n == EVRT_SRC_USB1) || (n == EVRT_SRC_CCAN) || (n == EVRT_SRC_SDIO) \
+								 || (n == EVRT_SRC_COMBINE_TIMER2) || (n == EVRT_SRC_COMBINE_TIMER6) \
+								 || (n == EVRT_SRC_QEI) || (n == EVRT_SRC_COMBINE_TIMER14) \
+								 || (n == EVRT_SRC_RESET) || (n == EVRT_SRC_BOD_RESET) || (n == EVRT_SRC_DEEP_POWER_DOWN)) \
+
+/**
+ * @brief EVRT input state detecting type
+ */
+typedef enum CHIP_EVRT_SRC_ACTIVE {
+	EVRT_SRC_ACTIVE_LOW_LEVEL,		/*!< Active low level       */
+	EVRT_SRC_ACTIVE_HIGH_LEVEL,		/*!< Active high level		*/
+	EVRT_SRC_ACTIVE_FALLING_EDGE,	/*!< Active falling edge	*/
+	EVRT_SRC_ACTIVE_RISING_EDGE		/*!< Active rising edge		*/
+} CHIP_EVRT_SRC_ACTIVE_T;
+
+/**
+ * @brief Macro for checking for a valid EVRT state type
+ */
+#define PARAM_EVRT_SOURCE_ACTIVE_TYPE(n) ((n == EVRT_SRC_ACTIVE_LOW_LEVEL) || (n == EVRT_SRC_ACTIVE_HIGH_LEVEL)	\
+										  || (n == EVRT_SRC_ACTIVE_FALLING_EDGE) || (n == EVRT_SRC_ACTIVE_RISING_EDGE))
+
+/**
+ * @brief	Initialize the EVRT
+ * @return	Nothing
+ */
+void Chip_EVRT_Init (void);
+
+/**
+ * @brief	Set up the type of interrupt type for a source to EVRT
+ * @param	EVRT_Src	: EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @param	type		: EVRT type, should be one of CHIP_EVRT_SRC_ACTIVE_T type
+ * @return	Nothing
+ */
+void Chip_EVRT_ConfigIntSrcActiveType(CHIP_EVRT_SRC_T EVRT_Src, CHIP_EVRT_SRC_ACTIVE_T type);
+
+/**
+ * @brief	Check if a source is sending interrupt to EVRT
+ * @param	EVRT_Src	: EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @return	true if the interrupt from the source is pending, otherwise false
+ */
+IntStatus Chip_EVRT_IsSourceInterrupting(CHIP_EVRT_SRC_T EVRT_Src);
+
+/**
+ * @brief	Enable or disable interrupt sources to EVRT
+ * @param	EVRT_Src	: EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @param	state		: ENABLE or DISABLE to enable or disable event router source
+ * @return	Nothing
+ */
+void Chip_EVRT_SetUpIntSrc(CHIP_EVRT_SRC_T EVRT_Src, FunctionalState state);
+
+/**
+ * @brief	De-initializes the EVRT peripheral
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EVRT_DeInit(void)
+{
+	LPC_EVRT->CLR_EN    = 0xFFFF;
+	LPC_EVRT->CLR_STAT  = 0xFFFF;
+}
+
+/**
+ * @brief	Clear pending interrupt EVRT source
+ * @param	EVRT_Src	: EVRT source, should be one of CHIP_EVRT_SRC_T type
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_EVRT_ClrPendIntSrc(CHIP_EVRT_SRC_T EVRT_Src)
+{
+	LPC_EVRT->CLR_STAT = (1 << (uint8_t) EVRT_Src);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __EVRT_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/fmc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/fmc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/fmc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/fmc_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,160 @@
+/*
+ * @brief LPC18xx/43xx FLASH Memory Controller (FMC) driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __FMC_18XX_43XX_H_
+#define __FMC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup FMC_18XX_43XX CHIP: LPC18xx/43xx FLASH Memory Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief FLASH Memory Controller Unit register block structure
+ */
+typedef struct {		/*!< FMC Structure */
+	__I  uint32_t  RESERVED1[8];
+	__IO uint32_t  FMSSTART;
+	__IO uint32_t  FMSSTOP;
+	__I  uint32_t  RESERVED2;
+	__I  uint32_t  FMSW[4];
+	__I  uint32_t  RESERVED3[1001];
+	__I  uint32_t  FMSTAT;
+	__I  uint32_t  RESERVED5;
+	__O  uint32_t  FMSTATCLR;
+	__I  uint32_t  RESERVED4[5];
+} LPC_FMC_T;
+
+/* Flash signature start and busy status bit */
+#define FMC_FLASHSIG_BUSY       (1UL << 17)
+
+/* Flash signature clear status bit */
+#define FMC_FLASHSIG_STAT       (1 << 2)
+
+/**
+ * @brief	Gets the base address of given bank
+ * @param	0 - Bank 0; 1 - Bank 1
+ * @return	Base address corresponding to given bank
+ */
+__STATIC_INLINE LPC_FMC_T * Chip_FMC_BaseAddr(uint8_t bank)
+{
+	if (!bank) {
+		return LPC_FMCA;
+	} else {
+		return LPC_FMCB;
+	}
+}
+
+/**
+ * @brief	Start computation of a signature for a FLASH memory range
+ * @param	bank	: FLASH bank, A = 0, B = 1
+ * @param	start	: Starting FLASH address for computation, must be aligned on 16 byte boundary
+ * @param	stop	: Ending FLASH address for computation, must be aligned on 16 byte boundary
+ * @return	Nothing
+ * @note	Only bits 20..4 are used for the FLASH signature computation.
+ *			Use the Chip_FMC_IsSignatureBusy() function to determine when the
+ *			signature computation operation is complete and use the
+ *			Chip_FMC_GetSignature() function to get the computed signature.
+ */
+STATIC INLINE void Chip_FMC_ComputeSignature(uint8_t bank, uint32_t start, uint32_t stop)
+{
+	LPC_FMC_T *LPC_FMC = Chip_FMC_BaseAddr(bank);
+	LPC_FMC->FMSSTART = (start >> 4);
+	LPC_FMC->FMSTATCLR = FMC_FLASHSIG_STAT;
+	LPC_FMC->FMSSTOP = (stop >> 4) | FMC_FLASHSIG_BUSY;
+}
+
+/**
+ * @brief	Start computation of a signature for a FLASH memory address and block count
+ * @param	bank	: FLASH bank, A = 0, B = 1
+ * @param	start	: Starting FLASH address for computation, must be aligned on 16 byte boundary
+ * @param	blocks	: Number of 16 byte blocks used for computation
+ * @return	Nothing
+ * @note	Only bits 20..4 are used for the FLASH signature computation.
+ *			Use the Chip_FMC_IsSignatureBusy() function to determine when the
+ *			signature computation operation is complete and the
+ *			Chip_FMC_GetSignature() function to get the computed signature.
+ */
+STATIC INLINE void Chip_FMC_ComputeSignatureBlocks(uint8_t bank, uint32_t start, uint32_t blocks)
+{
+	Chip_FMC_ComputeSignature(bank, start, (start + (blocks * 16)));
+}
+
+/**
+ * @brief	Clear signature generation completion flag
+ * @param	bank	: FLASH bank, A = 0, B = 1
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_FMC_ClearSignatureBusy(uint8_t bank)
+{
+	Chip_FMC_BaseAddr(bank)->FMSTATCLR = FMC_FLASHSIG_STAT;
+}
+
+/**
+ * @brief	Check for signature generation completion
+ * @param	bank	: FLASH bank, A = 0, B = 1
+ * @return	true if the signature computation is running, false if finished
+ */
+STATIC INLINE bool Chip_FMC_IsSignatureBusy(uint8_t bank)
+{
+	return (bool) ((Chip_FMC_BaseAddr(bank)->FMSTAT & FMC_FLASHSIG_STAT) == 0);
+}
+
+/**
+ * @brief	Returns the generated FLASH signature value
+ * @param	bank	: FLASH bank, A = 0, B = 1
+ * @param	index	: Signature index to get - use 0 to FMSW0, 1 to FMSW1, etc.
+ * @return	the generated FLASH signature value
+ */
+STATIC INLINE uint32_t Chip_FMC_GetSignature(uint8_t bank, int index)
+{
+	return Chip_FMC_BaseAddr(bank)->FMSW[index];
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __FMC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/fpu_init.h ./libs/vendor_libs/lpc_chip_43xx/inc/fpu_init.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/fpu_init.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/fpu_init.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,58 @@
+/*
+ * @brief FPU init code
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __FPU_INIT_H_
+#define __FPU_INIT_H_
+
+/**
+ * @defgroup CHIP_FPU_CMX CHIP: FPU initialization
+ * @ingroup CHIP_Common
+ * Cortex FPU initialization
+ * @{
+ */
+
+/**
+ * @brief	Early initialization of the FPU
+ * @return	Nothing
+ */
+void fpuInit(void);
+
+/**
+ * @}
+ */
+
+#endif /* __FPU_INIT_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gima_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/gima_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gima_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/gima_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,72 @@
+/*
+ * @brief LPC18xx/43xx GIMA driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GIMA_18XX_43XX_H_
+#define __GIMA_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GIMA_18XX_43XX CHIP: LPC18xx/43xx GIMA driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Global Input Multiplexer Array (GIMA) register block structure
+ */
+typedef struct {						/*!< GIMA Structure */
+	__IO uint32_t  CAP0_IN[4][4];		/*!< Timer x CAP0_y capture input multiplexer (GIMA output ((x*4)+y)) */
+	__IO uint32_t  CTIN_IN[8];			/*!< SCT CTIN_x capture input multiplexer (GIMA output (16+x)) */
+	__IO uint32_t  ADCHS_TRIGGER_IN;	/*!< ADCHS trigger input multiplexer (GIMA output 24) */
+	__IO uint32_t  EVENTROUTER_13_IN;	/*!< Event router input 13 multiplexer (GIMA output 25) */
+	__IO uint32_t  EVENTROUTER_14_IN;	/*!< Event router input 14 multiplexer (GIMA output 26) */
+	__IO uint32_t  EVENTROUTER_16_IN;	/*!< Event router input 16 multiplexer (GIMA output 27) */
+	__IO uint32_t  ADCSTART0_IN;		/*!< ADC start0 input multiplexer (GIMA output 28) */
+	__IO uint32_t  ADCSTART1_IN;		/*!< ADC start1 input multiplexer (GIMA output 29) */
+} LPC_GIMA_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GIMA_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gpdma_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/gpdma_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gpdma_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/gpdma_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,424 @@
+/*
+ * @brief LPC18xx/43xx General Purpose DMA driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights. NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPDMA_18XX_43XX_H_
+#define __GPDMA_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPDMA_18XX_43XX CHIP: LPC18xx/43xx General Purpose DMA driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Number of channels on GPDMA
+ */
+#define GPDMA_NUMBER_CHANNELS 8
+
+/**
+ * @brief GPDMA Channel register block structure
+ */
+typedef struct {
+	__IO uint32_t  SRCADDR;				/*!< DMA Channel Source Address Register */
+	__IO uint32_t  DESTADDR;			/*!< DMA Channel Destination Address Register */
+	__IO uint32_t  LLI;					/*!< DMA Channel Linked List Item Register */
+	__IO uint32_t  CONTROL;				/*!< DMA Channel Control Register */
+	__IO uint32_t  CONFIG;				/*!< DMA Channel Configuration Register */
+	__I  uint32_t  RESERVED1[3];
+} GPDMA_CH_T;
+
+/**
+ * @brief GPDMA register block
+ */
+typedef struct {						/*!< GPDMA Structure */
+	__I  uint32_t  INTSTAT;				/*!< DMA Interrupt Status Register */
+	__I  uint32_t  INTTCSTAT;			/*!< DMA Interrupt Terminal Count Request Status Register */
+	__O  uint32_t  INTTCCLEAR;			/*!< DMA Interrupt Terminal Count Request Clear Register */
+	__I  uint32_t  INTERRSTAT;			/*!< DMA Interrupt Error Status Register */
+	__O  uint32_t  INTERRCLR;			/*!< DMA Interrupt Error Clear Register */
+	__I  uint32_t  RAWINTTCSTAT;		/*!< DMA Raw Interrupt Terminal Count Status Register */
+	__I  uint32_t  RAWINTERRSTAT;		/*!< DMA Raw Error Interrupt Status Register */
+	__I  uint32_t  ENBLDCHNS;			/*!< DMA Enabled Channel Register */
+	__IO uint32_t  SOFTBREQ;			/*!< DMA Software Burst Request Register */
+	__IO uint32_t  SOFTSREQ;			/*!< DMA Software Single Request Register */
+	__IO uint32_t  SOFTLBREQ;			/*!< DMA Software Last Burst Request Register */
+	__IO uint32_t  SOFTLSREQ;			/*!< DMA Software Last Single Request Register */
+	__IO uint32_t  CONFIG;				/*!< DMA Configuration Register */
+	__IO uint32_t  SYNC;				/*!< DMA Synchronization Register */
+	__I  uint32_t  RESERVED0[50];
+	GPDMA_CH_T     CH[GPDMA_NUMBER_CHANNELS];
+} LPC_GPDMA_T;
+
+/**
+ * @brief Macro defines for DMA channel control registers
+ */
+#define GPDMA_DMACCxControl_TransferSize(n) (((n & 0xFFF) << 0))	/*!< Transfer size*/
+#define GPDMA_DMACCxControl_SBSize(n)       (((n & 0x07) << 12))	/*!< Source burst size*/
+#define GPDMA_DMACCxControl_DBSize(n)       (((n & 0x07) << 15))	/*!< Destination burst size*/
+#define GPDMA_DMACCxControl_SWidth(n)       (((n & 0x07) << 18))	/*!< Source transfer width*/
+#define GPDMA_DMACCxControl_DWidth(n)       (((n & 0x07) << 21))	/*!< Destination transfer width*/
+#define GPDMA_DMACCxControl_SI              ((1UL << 26))			/*!< Source increment*/
+#define GPDMA_DMACCxControl_DI              ((1UL << 27))			/*!< Destination increment*/
+#define GPDMA_DMACCxControl_SrcTransUseAHBMaster1   ((1UL << 24))	/*!< Source AHB master select in 18xx43xx*/
+#define GPDMA_DMACCxControl_DestTransUseAHBMaster1  ((1UL << 25))	/*!< Destination AHB master select in 18xx43xx*/
+#define GPDMA_DMACCxControl_Prot1           ((1UL << 28))			/*!< Indicates that the access is in user mode or privileged mode*/
+#define GPDMA_DMACCxControl_Prot2           ((1UL << 29))			/*!< Indicates that the access is bufferable or not bufferable*/
+#define GPDMA_DMACCxControl_Prot3           ((1UL << 30))			/*!< Indicates that the access is cacheable or not cacheable*/
+#define GPDMA_DMACCxControl_I               ((1UL << 31))			/*!< Terminal count interrupt enable bit */
+
+/**
+ * @brief Macro defines for DMA Configuration register
+ */
+#define GPDMA_DMACConfig_E              ((0x01))	/*!< DMA Controller enable*/
+#define GPDMA_DMACConfig_M              ((0x02))	/*!< AHB Master endianness configuration*/
+#define GPDMA_DMACConfig_BITMASK        ((0x03))
+
+/**
+ * @brief Macro defines for DMA Channel Configuration registers
+ */
+#define GPDMA_DMACCxConfig_E                    ((1UL << 0))			/*!< DMA control enable*/
+#define GPDMA_DMACCxConfig_SrcPeripheral(n)     (((n & 0x1F) << 1))		/*!< Source peripheral*/
+#define GPDMA_DMACCxConfig_DestPeripheral(n)    (((n & 0x1F) << 6))		/*!< Destination peripheral*/
+#define GPDMA_DMACCxConfig_TransferType(n)      (((n & 0x7) << 11))		/*!< This value indicates the type of transfer*/
+#define GPDMA_DMACCxConfig_IE                   ((1UL << 14))			/*!< Interrupt error mask*/
+#define GPDMA_DMACCxConfig_ITC                  ((1UL << 15))			/*!< Terminal count interrupt mask*/
+#define GPDMA_DMACCxConfig_L                    ((1UL << 16))			/*!< Lock*/
+#define GPDMA_DMACCxConfig_A                    ((1UL << 17))			/*!< Active*/
+#define GPDMA_DMACCxConfig_H                    ((1UL << 18))			/*!< Halt*/
+
+/**
+ * @brief GPDMA Interrupt Clear Status
+ */
+typedef enum {
+	GPDMA_STATCLR_INTTC,	/*!< GPDMA Interrupt Terminal Count Request Clear */
+	GPDMA_STATCLR_INTERR	/*!< GPDMA Interrupt Error Clear */
+} GPDMA_STATECLEAR_T;
+
+/**
+ * @brief GPDMA Type of Interrupt Status
+ */
+typedef enum {
+	GPDMA_STAT_INT,			/*!< GPDMA Interrupt Status */
+	GPDMA_STAT_INTTC,		/*!< GPDMA Interrupt Terminal Count Request Status */
+	GPDMA_STAT_INTERR,		/*!< GPDMA Interrupt Error Status */
+	GPDMA_STAT_RAWINTTC,	/*!< GPDMA Raw Interrupt Terminal Count Status */
+	GPDMA_STAT_RAWINTERR,	/*!< GPDMA Raw Error Interrupt Status */
+	GPDMA_STAT_ENABLED_CH	/*!< GPDMA Enabled Channel Status */
+} GPDMA_STATUS_T;
+
+/**
+ * @brief GPDMA Type of DMA controller
+ */
+typedef enum {
+	GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA              = ((0UL)),	/*!< Memory to memory - DMA control */
+	GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA              = ((1UL)),	/*!< Memory to peripheral - DMA control */
+	GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA              = ((2UL)),	/*!< Peripheral to memory - DMA control */
+	GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA              = ((3UL)),	/*!< Source peripheral to destination peripheral - DMA control */
+	GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL   = ((4UL)),	/*!< Source peripheral to destination peripheral - destination peripheral control */
+	GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL       = ((5UL)),	/*!< Memory to peripheral - peripheral control */
+	GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL       = ((6UL)),	/*!< Peripheral to memory - peripheral control */
+	GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL    = ((7UL))	/*!< Source peripheral to destination peripheral - source peripheral control */
+} GPDMA_FLOW_CONTROL_T;
+
+/**
+ * @brief GPDMA structure using for DMA configuration
+ */
+typedef struct {
+	uint32_t ChannelNum;	/*!< DMA channel number, should be in
+							 *  range from 0 to 7.
+							 *  Note: DMA channel 0 has the highest priority
+							 *  and DMA channel 7 the lowest priority.
+							 */
+	uint32_t TransferSize;	/*!< Length/Size of transfer */
+	uint32_t TransferWidth;	/*!< Transfer width - used for TransferType is GPDMA_TRANSFERTYPE_M2M only */
+	uint32_t SrcAddr;		/*!< Physical Source Address, used in case TransferType is chosen as
+							 *   GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_M2P */
+	uint32_t DstAddr;		/*!< Physical Destination Address, used in case TransferType is chosen as
+							 *   GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_P2M */
+	uint32_t TransferType;	/*!< Transfer Type, should be one of the following:
+							 * - GPDMA_TRANSFERTYPE_M2M: Memory to memory - DMA control
+							 * - GPDMA_TRANSFERTYPE_M2P: Memory to peripheral - DMA control
+							 * - GPDMA_TRANSFERTYPE_P2M: Peripheral to memory - DMA control
+							 * - GPDMA_TRANSFERTYPE_P2P: Source peripheral to destination peripheral - DMA control
+							 */
+} GPDMA_CH_CFG_T;
+
+/**
+ * @brief GPDMA request connections
+ */
+#define GPDMA_CONN_MEMORY           ((0UL))			/**< MEMORY             */
+#define GPDMA_CONN_MAT0_0           ((1UL))			/**< MAT0.0             */
+#define GPDMA_CONN_UART0_Tx         ((2UL))			/**< UART0 Tx           */
+#define GPDMA_CONN_MAT0_1           ((3UL))			/**< MAT0.1             */
+#define GPDMA_CONN_UART0_Rx         ((4UL))			/**< UART0 Rx           */
+#define GPDMA_CONN_MAT1_0           ((5UL))			/**< MAT1.0             */
+#define GPDMA_CONN_UART1_Tx         ((6UL))			/**< UART1 Tx           */
+#define GPDMA_CONN_MAT1_1           ((7UL))			/**< MAT1.1             */
+#define GPDMA_CONN_UART1_Rx         ((8UL))			/**< UART1 Rx           */
+#define GPDMA_CONN_MAT2_0           ((9UL))			/**< MAT2.0             */
+#define GPDMA_CONN_UART2_Tx         ((10UL))		/**< UART2 Tx           */
+#define GPDMA_CONN_MAT2_1           ((11UL))		/**< MAT2.1             */
+#define GPDMA_CONN_UART2_Rx         ((12UL))		/**< UART2 Rx           */
+#define GPDMA_CONN_MAT3_0           ((13UL))		/**< MAT3.0             */
+#define GPDMA_CONN_UART3_Tx         ((14UL))		/**< UART3 Tx           */
+#define GPDMA_CONN_SCT_0            ((15UL))		/**< SCT timer channel 0*/
+#define GPDMA_CONN_MAT3_1           ((16UL))		/**< MAT3.1             */
+#define GPDMA_CONN_UART3_Rx         ((17UL))		/**< UART3 Rx           */
+#define GPDMA_CONN_SCT_1            ((18UL))		/**< SCT timer channel 1*/
+#define GPDMA_CONN_SSP0_Rx          ((19UL))		/**< SSP0 Rx            */
+#define GPDMA_CONN_I2S_Tx_Channel_0 ((20UL))		/**< I2S0 Tx on channel 0 */
+#define GPDMA_CONN_SSP0_Tx          ((21UL))		/**< SSP0 Tx            */
+#define GPDMA_CONN_I2S_Rx_Channel_1 ((22UL))		/**< I2S0 Rx on channel 0 */
+#define GPDMA_CONN_SSP1_Rx          ((23UL))		/**< SSP1 Rx            */
+#define GPDMA_CONN_SSP1_Tx          ((24UL))		/**< SSP1 Tx            */
+#define GPDMA_CONN_ADC_0            ((25UL))		/**< ADC 0              */
+#define GPDMA_CONN_ADC_1            ((26UL))		/**< ADC 1              */
+#define GPDMA_CONN_DAC              ((27UL))		/**< DAC                */
+#define GPDMA_CONN_I2S1_Tx_Channel_0 ((28UL))		/**< I2S1 Tx on channel 0 */
+#define GPDMA_CONN_I2S1_Rx_Channel_1 ((29UL))		/**< I2S1 Rx on channel 0 */
+
+/**
+ * @brief GPDMA Burst size in Source and Destination definitions
+ */
+#define GPDMA_BSIZE_1   ((0UL))	/*!< Burst size = 1 */
+#define GPDMA_BSIZE_4   ((1UL))	/*!< Burst size = 4 */
+#define GPDMA_BSIZE_8   ((2UL))	/*!< Burst size = 8 */
+#define GPDMA_BSIZE_16  ((3UL))	/*!< Burst size = 16 */
+#define GPDMA_BSIZE_32  ((4UL))	/*!< Burst size = 32 */
+#define GPDMA_BSIZE_64  ((5UL))	/*!< Burst size = 64 */
+#define GPDMA_BSIZE_128 ((6UL))	/*!< Burst size = 128 */
+#define GPDMA_BSIZE_256 ((7UL))	/*!< Burst size = 256 */
+
+/**
+ * @brief Width in Source transfer width and Destination transfer width definitions
+ */
+#define GPDMA_WIDTH_BYTE        ((0UL))	/*!< Width = 1 byte */
+#define GPDMA_WIDTH_HALFWORD    ((1UL))	/*!< Width = 2 bytes */
+#define GPDMA_WIDTH_WORD        ((2UL))	/*!< Width = 4 bytes */
+
+/**
+ * @brief Flow control definitions
+ */
+#define DMA_CONTROLLER 0		/*!< Flow control is DMA controller*/
+#define SRC_PER_CONTROLLER 1	/*!< Flow control is Source peripheral controller*/
+#define DST_PER_CONTROLLER 2	/*!< Flow control is Destination peripheral controller*/
+
+/**
+ * @brief DMA channel handle structure
+ */
+typedef struct {
+	FunctionalState ChannelStatus;	/*!< DMA channel status */
+} DMA_ChannelHandle_t;
+
+/**
+ * @brief Transfer Descriptor structure typedef
+ */
+typedef struct DMA_TransferDescriptor {
+	uint32_t src;	/*!< Source address */
+	uint32_t dst;	/*!< Destination address */
+	uint32_t lli;	/*!< Pointer to next descriptor structure */
+	uint32_t ctrl;	/*!< Control word that has transfer size, type etc. */
+} DMA_TransferDescriptor_t;
+
+/**
+ * @brief	Initialize the GPDMA
+ * @param	pGPDMA	: The base of GPDMA on the chip
+ * @return	Nothing
+ */
+void Chip_GPDMA_Init(LPC_GPDMA_T *pGPDMA);
+
+/**
+ * @brief	Shutdown the GPDMA
+ * @param	pGPDMA	: The base of GPDMA on the chip
+ * @return	Nothing
+ */
+void Chip_GPDMA_DeInit(LPC_GPDMA_T *pGPDMA);
+
+/**
+ * @brief	Initialize channel configuration strucutre
+ * @param	pGPDMA			: The base of GPDMA on the chip
+ * @param	GPDMACfg		: Pointer to configuration structure to be initialized
+ * @param	ChannelNum		: Channel used for transfer *must be obtained using Chip_GPDMA_GetFreeChannel()*
+ * @param	src				: Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the source
+ * @param	dst				: Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the destination
+ * @param	Size			: The number of DMA transfers
+ * @param	TransferType	: Select the transfer controller and the type of transfer. (See, #GPDMA_FLOW_CONTROL_T)
+ * @return	ERROR on error, SUCCESS on success
+ */
+int Chip_GPDMA_InitChannelCfg(LPC_GPDMA_T *pGPDMA,
+							  GPDMA_CH_CFG_T *GPDMACfg,
+							  uint8_t  ChannelNum,
+							  uint32_t src,
+							  uint32_t dst,
+							  uint32_t Size,
+							  GPDMA_FLOW_CONTROL_T TransferType);
+
+/**
+ * @brief	Enable or Disable the GPDMA Channel
+ * @param	pGPDMA		: The base of GPDMA on the chip
+ * @param	channelNum	: The GPDMA channel : 0 - 7
+ * @param	NewState	: ENABLE to enable GPDMA or DISABLE to disable GPDMA
+ * @return	Nothing
+ */
+void Chip_GPDMA_ChannelCmd(LPC_GPDMA_T *pGPDMA, uint8_t channelNum, FunctionalState NewState);
+
+/**
+ * @brief	Stop a stream DMA transfer
+ * @param	pGPDMA		: The base of GPDMA on the chip
+ * @param	ChannelNum	: Channel Number to be closed
+ * @return	Nothing
+ */
+void Chip_GPDMA_Stop(LPC_GPDMA_T *pGPDMA, uint8_t ChannelNum);
+
+/**
+ * @brief	The GPDMA stream interrupt status checking
+ * @param	pGPDMA		: The base of GPDMA on the chip
+ * @param	ChannelNum	: Channel Number to be checked on interruption
+ * @return	Status:
+ *              - SUCCESS	: DMA transfer success
+ *              - ERROR		: DMA transfer failed
+ */
+Status Chip_GPDMA_Interrupt(LPC_GPDMA_T *pGPDMA, uint8_t ChannelNum);
+
+/**
+ * @brief	Read the status from different registers according to the type
+ * @param	pGPDMA	: The base of GPDMA on the chip
+ * @param	type	: Status mode, should be:
+ *						- GPDMA_STAT_INT		: GPDMA Interrupt Status
+ *						- GPDMA_STAT_INTTC		: GPDMA Interrupt Terminal Count Request Status
+ *						- GPDMA_STAT_INTERR		: GPDMA Interrupt Error Status
+ *						- GPDMA_STAT_RAWINTTC	: GPDMA Raw Interrupt Terminal Count Status
+ *						- GPDMA_STAT_RAWINTERR	: GPDMA Raw Error Interrupt Status
+ *						- GPDMA_STAT_ENABLED_CH	: GPDMA Enabled Channel Status
+ * @param	channel	: The GPDMA channel : 0 - 7
+ * @return	SET is interrupt is pending or RESET if not pending
+ */
+IntStatus Chip_GPDMA_IntGetStatus(LPC_GPDMA_T *pGPDMA, GPDMA_STATUS_T type, uint8_t channel);
+
+/**
+ * @brief	Clear the Interrupt Flag from different registers according to the type
+ * @param	pGPDMA	: The base of GPDMA on the chip
+ * @param	type	: Flag mode, should be:
+ *						- GPDMA_STATCLR_INTTC	: GPDMA Interrupt Terminal Count Request
+ *						- GPDMA_STATCLR_INTERR	: GPDMA Interrupt Error
+ * @param	channel	: The GPDMA channel : 0 - 7
+ * @return	Nothing
+ */
+void Chip_GPDMA_ClearIntPending(LPC_GPDMA_T *pGPDMA, GPDMA_STATECLEAR_T type, uint8_t channel);
+
+/**
+ * @brief	Get a free GPDMA channel for one DMA connection
+ * @param	pGPDMA					: The base of GPDMA on the chip
+ * @param	PeripheralConnection_ID	: Some chip fix each peripheral DMA connection on a specified channel ( have not used in 17xx/40xx )
+ * @return	The channel number which is selected
+ */
+uint8_t Chip_GPDMA_GetFreeChannel(LPC_GPDMA_T *pGPDMA,
+								  uint32_t PeripheralConnection_ID);
+
+/**
+ * @brief	Do a DMA transfer M2M, M2P,P2M or P2P
+ * @param	pGPDMA		: The base of GPDMA on the chip
+ * @param	ChannelNum	: Channel used for transfer
+ * @param	src			: Address of Memory or PeripheralConnection_ID which is the source
+ * @param	dst			: Address of Memory or PeripheralConnection_ID which is the destination
+ * @param	TransferType: Select the transfer controller and the type of transfer. Should be:
+ *                               - GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA
+ *                               - GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL
+ *                               - GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL
+ *                               - GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL
+ *                               - GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL
+ * @param	Size		: The number of DMA transfers
+ * @return	ERROR on error, SUCCESS on success
+ */
+Status Chip_GPDMA_Transfer(LPC_GPDMA_T *pGPDMA,
+						   uint8_t ChannelNum,
+						   uint32_t src,
+						   uint32_t dst,
+						   GPDMA_FLOW_CONTROL_T TransferType,
+						   uint32_t Size);
+
+/**
+ * @brief	Do a DMA transfer using linked list of descriptors
+ * @param	pGPDMA			: The base of GPDMA on the chip
+ * @param	ChannelNum		: Channel used for transfer *must be obtained using Chip_GPDMA_GetFreeChannel()*
+ * @param	DMADescriptor	: First node in the linked list of descriptors
+ * @param	TransferType	: Select the transfer controller and the type of transfer. (See, #GPDMA_FLOW_CONTROL_T)
+ * @return	ERROR on error, SUCCESS on success
+ */
+Status Chip_GPDMA_SGTransfer(LPC_GPDMA_T *pGPDMA,
+							 uint8_t ChannelNum,
+							 const DMA_TransferDescriptor_t *DMADescriptor,
+							 GPDMA_FLOW_CONTROL_T TransferType);
+
+/**
+ * @brief	Prepare a single DMA descriptor
+ * @param	pGPDMA			: The base of GPDMA on the chip
+ * @param	DMADescriptor	: DMA Descriptor to be initialized
+ * @param	src				: Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the source
+ * @param	dst				: Address of Memory or one of @link #GPDMA_CONN_MEMORY
+ *                              PeripheralConnection_ID @endlink, which is the destination
+ * @param	Size			: The number of DMA transfers
+ * @param	TransferType	: Select the transfer controller and the type of transfer. (See, #GPDMA_FLOW_CONTROL_T)
+ * @param	NextDescriptor	: Pointer to next descriptor (0 if no more descriptors available)
+ * @return	ERROR on error, SUCCESS on success
+ */
+Status Chip_GPDMA_PrepareDescriptor(LPC_GPDMA_T *pGPDMA,
+									DMA_TransferDescriptor_t *DMADescriptor,
+									uint32_t src,
+									uint32_t dst,
+									uint32_t Size,
+									GPDMA_FLOW_CONTROL_T TransferType,
+									const DMA_TransferDescriptor_t *NextDescriptor);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPDMA_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gpio_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/gpio_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gpio_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/gpio_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,509 @@
+/*
+ * @brief LPC18xx/43xx GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPIO_18XX_43XX_H_
+#define __GPIO_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPIO_18XX_43XX CHIP: LPC18xx/43xx GPIO driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief  GPIO port register block structure
+ */
+typedef struct {				/*!< GPIO_PORT Structure */
+	__IO uint8_t B[128][32];	/*!< Offset 0x0000: Byte pin registers ports 0 to n; pins PIOn_0 to PIOn_31 */
+	__IO uint32_t W[32][32];	/*!< Offset 0x1000: Word pin registers port 0 to n */
+	__IO uint32_t DIR[32];		/*!< Offset 0x2000: Direction registers port n */
+	__IO uint32_t MASK[32];		/*!< Offset 0x2080: Mask register port n */
+	__IO uint32_t PIN[32];		/*!< Offset 0x2100: Portpin register port n */
+	__IO uint32_t MPIN[32];		/*!< Offset 0x2180: Masked port register port n */
+	__IO uint32_t SET[32];		/*!< Offset 0x2200: Write: Set register for port n Read: output bits for port n */
+	__O  uint32_t CLR[32];		/*!< Offset 0x2280: Clear port n */
+	__O  uint32_t NOT[32];		/*!< Offset 0x2300: Toggle port n */
+} LPC_GPIO_T;
+
+/**
+ * @brief	Initialize GPIO block
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_GPIO_Init(LPC_GPIO_T *pGPIO);
+
+/**
+ * @brief	De-Initialize GPIO block
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO);
+
+/**
+ * @brief	Set a GPIO port/bit state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set
+ * @param	setting	: true for high, false for low
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
+{
+	pGPIO->B[port][pin] = setting;
+}
+
+/**
+ * @brief	Set a GPIO pin state via the GPIO byte register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param 	port	: GPIO Port number where @a pin is located
+ * @param	pin		: GPIO pin to set
+ * @param	setting	: true for high, false for low
+ * @return	Nothing
+ * @note	This function replaces Chip_GPIO_WritePortBit()
+ */
+STATIC INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
+{
+	pGPIO->B[port][pin] = setting;
+}
+
+/**
+ * @brief	Read a GPIO state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to read
+ * @param	pin		: GPIO pin to read
+ * @return	true of the GPIO is high, false if low
+ * @note	It is recommended to use the Chip_GPIO_GetPinState() function instead.
+ */
+STATIC INLINE bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
+{
+	return (bool) pGPIO->B[port][pin];
+}
+
+/**
+ * @brief	Get a GPIO pin state via the GPIO byte register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: GPIO pin to get state for
+ * @return	true if the GPIO is high, false if low
+ * @note	This function replaces Chip_GPIO_ReadPortBit()
+ */
+STATIC INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	return (bool) pGPIO->B[port][pin];
+}
+
+/**
+ * @brief	Set a GPIO direction
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	bit		: GPIO bit to set
+ * @param	setting	: true for output, false for input
+ * @return	Nothing
+ * @note	It is recommended to use the Chip_GPIO_SetPinDIROutput(),
+ * Chip_GPIO_SetPinDIRInput() or Chip_GPIO_SetPinDIR() functions instead
+ * of this function.
+ */
+STATIC INLINE void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit, bool setting)
+{
+	if (setting) {
+		pGPIO->DIR[port] |= 1UL << bit;
+	}
+	else {
+		pGPIO->DIR[port] &= ~(1UL << bit);
+	}
+}
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin to an output
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: GPIO pin to set direction on as output
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->DIR[port] |= 1UL << pin;
+}
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin to an input
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: GPIO pin to set direction on as input
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->DIR[port] &= ~(1UL << pin);
+}
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: GPIO pin to set direction for
+ * @param	output	: true for output, false for input
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output)
+{
+	if (output) {
+		Chip_GPIO_SetPinDIROutput(pGPIO, port, pin);
+	}
+	else {
+		Chip_GPIO_SetPinDIRInput(pGPIO, port, pin);
+	}
+}
+
+/**
+ * @brief	Read a GPIO direction (out or in)
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to read
+ * @param	bit		: GPIO bit to read
+ * @return	true of the GPIO is an output, false if input
+ * @note	It is recommended to use the Chip_GPIO_GetPinDIR() function instead.
+ */
+STATIC INLINE bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
+{
+	return (bool) (((pGPIO->DIR[port]) >> bit) & 1);
+}
+
+/**
+ * @brief	Get GPIO direction for a single GPIO pin
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: GPIO pin to get direction for
+ * @return	true if the GPIO is an output, false if input
+ */
+STATIC INLINE bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	return (bool) (((pGPIO->DIR[port]) >> pin) & 1);
+}
+
+/**
+ * @brief	Set Direction for a GPIO port
+ * @param	pGPIO		: The base of GPIO peripheral on the chip
+ * @param	portNum		: port Number
+ * @param	bitValue	: GPIO bit to set
+ * @param	out			: Direction value, 0 = input, !0 = output
+ * @return	None
+ * @note	Bits set to '0' are not altered. It is recommended to use the
+ * Chip_GPIO_SetPortDIR() function instead.
+ */
+STATIC INLINE void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
+{
+	if (out) {
+		pGPIO->DIR[portNum] |= bitValue;
+	}
+	else {
+		pGPIO->DIR[portNum] &= ~bitValue;
+	}
+}
+
+/**
+ * @brief	Set GPIO direction for a all selected GPIO pins to an output
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pinMask	: GPIO pin mask to set direction on as output (bits 0..b for pins 0..n)
+ * @return	Nothing
+ * @note	Sets multiple GPIO pins to the output direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
+{
+	pGPIO->DIR[port] |= pinMask;
+}
+
+/**
+ * @brief	Set GPIO direction for a all selected GPIO pins to an input
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pinMask	: GPIO pin mask to set direction on as input (bits 0..b for pins 0..n)
+ * @return	Nothing
+ * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an input.
+ */
+STATIC INLINE void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
+{
+	pGPIO->DIR[port] &= ~pinMask;
+}
+
+/**
+ * @brief	Set GPIO direction for a all selected GPIO pins to an input or output
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pinMask	: GPIO pin mask to set direction on (bits 0..b for pins 0..n)
+ * @param	outSet	: Direction value, false = set as inputs, true = set as outputs
+ * @return	Nothing
+ * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an input.
+ */
+STATIC INLINE void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask, bool outSet)
+{
+	if (outSet) {
+		Chip_GPIO_SetPortDIROutput(pGPIO, port, pinMask);
+	}
+	else {
+		Chip_GPIO_SetPortDIRInput(pGPIO, port, pinMask);
+	}
+}
+
+/**
+ * @brief	Get GPIO direction for a all GPIO pins
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @return	a bitfield containing the input and output states for each pin
+ * @note	For pins 0..n, a high state in a bit corresponds to an output state for the
+ * same pin, while a low  state corresponds to an input state.
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->DIR[port];
+}
+
+/**
+ * @brief	Set GPIO port mask value for GPIO masked read and write
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number
+ * @param	mask	: Mask value for read and write (only low bits are enabled)
+ * @return	Nothing
+ * @note	Controls which bits are set or unset when using the masked
+ * GPIO read and write functions. A low state indicates the pin is settable
+ * and readable via the masked write and read functions.
+ */
+STATIC INLINE void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
+{
+	pGPIO->MASK[port] = mask;
+}
+
+/**
+ * @brief	Get GPIO port mask value used for GPIO masked read and write
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number
+ * @return	Returns value set with the Chip_GPIO_SetPortMask() function.
+ * @note	A high bit in the return value indicates that that GPIO pin for the
+ * port cannot be set using the masked write function.
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->MASK[port];
+}
+
+/**
+ * @brief	Set all GPIO raw pin states (regardless of masking)
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	value	: Value to set all GPIO pin states (0..n) to
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
+{
+	pGPIO->PIN[port] = value;
+}
+
+/**
+ * @brief	Get all GPIO raw pin states (regardless of masking)
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @return	Current (raw) state of all GPIO pins
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->PIN[port];
+}
+
+/**
+ * @brief	Set all GPIO pin states, but mask via the MASKP0 register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	value	: Value to set all GPIO pin states (0..n) to
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
+{
+	pGPIO->MPIN[port] = value;
+}
+
+/**
+ * @brief	Get all GPIO pin statesm but mask via the MASKP0 register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @return	Current (masked) state of all GPIO pins
+ */
+STATIC INLINE uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->MPIN[port];
+}
+
+/**
+ * @brief	Set a GPIO port/bit to the high state
+ * @param	pGPIO		: The base of GPIO peripheral on the chip
+ * @param	portNum		: port number
+ * @param	bitValue	: bit(s) in the port to set high
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output. It is recommended to use the
+ * Chip_GPIO_SetPortOutHigh() function instead.
+ */
+STATIC INLINE void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
+{
+	pGPIO->SET[portNum] = bitValue;
+}
+
+/**
+ * @brief	Set selected GPIO output pins to the high state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pins	: pins (0..n) to set high
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+	pGPIO->SET[port] = pins;
+}
+
+/**
+ * @brief	Set an individual GPIO output pin to the high state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip'
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: pin number (0..n) to set high
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->SET[port] = (1 << pin);
+}
+
+/**
+ * @brief	Set a GPIO port/bit to the low state
+ * @param	pGPIO		: The base of GPIO peripheral on the chip
+ * @param	portNum		: port number
+ * @param	bitValue	: bit(s) in the port to set low
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
+{
+	pGPIO->CLR[portNum] = bitValue;
+}
+
+/**
+ * @brief	Set selected GPIO output pins to the low state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pins	: pins (0..n) to set low
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+	pGPIO->CLR[port] = pins;
+}
+
+/**
+ * @brief	Set an individual GPIO output pin to the low state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: pin number (0..n) to set low
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->CLR[port] = (1 << pin);
+}
+
+/**
+ * @brief	Toggle selected GPIO output pins to the opposite state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pins	: pins (0..n) to toggle
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+	pGPIO->NOT[port] = pins;
+}
+
+/**
+ * @brief	Toggle an individual GPIO output pin to the opposite state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO Port number where @a pin is located
+ * @param	pin		: pin number (0..n) to toggle
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+STATIC INLINE void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->NOT[port] = (1 << pin);
+}
+
+/**
+ * @brief	Read current bit states for the selected port
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	portNum	: port number to read
+ * @return	Current value of GPIO port
+ * @note	The current states of the bits for the port are read, regardless of
+ * whether the GPIO port bits are input or output.
+ */
+STATIC INLINE uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
+{
+	return pGPIO->PIN[portNum];
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPIO_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/gpiogroup_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,211 @@
+/*
+ * @brief LPC18xx/43xx GPIO group driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPIOGROUP_18XX_43XX_H_
+#define __GPIOGROUP_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPIOGP_18XX_43XX CHIP: LPC18xx/43xx GPIO group driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief GPIO grouped interrupt register block structure
+ */
+typedef struct {					/*!< GPIO_GROUP_INTn Structure */
+	__IO uint32_t  CTRL;			/*!< GPIO grouped interrupt control register */
+	__I  uint32_t  RESERVED0[7];
+	__IO uint32_t  PORT_POL[8];		/*!< GPIO grouped interrupt port polarity register */
+	__IO uint32_t  PORT_ENA[8];		/*!< GPIO grouped interrupt port m enable register */
+	uint32_t       RESERVED1[1000];
+} LPC_GPIOGROUPINT_T;
+
+/**
+ * LPC18xx/43xx GPIO group bit definitions
+ */
+#define GPIOGR_INT      (1 << 0)	/*!< GPIO interrupt pending/clear bit */
+#define GPIOGR_COMB     (1 << 1)	/*!< GPIO interrupt OR(0)/AND(1) mode bit */
+#define GPIOGR_TRIG     (1 << 2)	/*!< GPIO interrupt edge(0)/level(1) mode bit */
+
+/**
+ * @brief	Clear interrupt pending status for the selected group
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_ClearIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	uint32_t temp;
+
+	temp = pGPIOGPINT[group].CTRL;
+	pGPIOGPINT[group].CTRL = temp | GPIOGR_INT;
+}
+
+/**
+ * @brief	Returns current GPIO group inetrrupt pending status
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	true if the group interrupt is pending, otherwise false.
+ */
+STATIC INLINE bool Chip_GPIOGP_GetIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	return (bool) ((pGPIOGPINT[group].CTRL & GPIOGR_INT) != 0);
+}
+
+/**
+ * @brief	Selected GPIO group functionality for trigger on any pin in group (OR mode)
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectOrMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL &= ~GPIOGR_COMB;
+}
+
+/**
+ * @brief	Selected GPIO group functionality for trigger on all matching pins in group (AND mode)
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectAndMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL |= GPIOGR_COMB;
+}
+
+/**
+ * @brief	Selected GPIO group functionality edge trigger mode
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectEdgeMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL &= ~GPIOGR_TRIG;
+}
+
+/**
+ * @brief	Selected GPIO group functionality level trigger mode
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectLevelMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL |= GPIOGR_TRIG;
+}
+
+/**
+ * @brief	Set selected pins for the group and port to low level trigger
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to select for low level (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectLowLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+											  uint8_t group,
+											  uint8_t port,
+											  uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_POL[port] &= ~pinMask;
+}
+
+/**
+ * @brief	Set selected pins for the group and port to high level trigger
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to select for high level (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ */
+STATIC INLINE void Chip_GPIOGP_SelectHighLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+											   uint8_t group,
+											   uint8_t port,
+											   uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_POL[port] |= pinMask;
+}
+
+/**
+ * @brief	Disabled selected pins for the group interrupt
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to disable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ * @note	Disabled pins do not contrinute to the group interrupt.
+ */
+STATIC INLINE void Chip_GPIOGP_DisableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+												uint8_t group,
+												uint8_t port,
+												uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_ENA[port] &= ~pinMask;
+}
+
+/**
+ * @brief	Enable selected pins for the group interrupt
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to enable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ * @note	Enabled pins contribute to the group interrupt.
+ */
+STATIC INLINE void Chip_GPIOGP_EnableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+											   uint8_t group,
+											   uint8_t port,
+											   uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_ENA[port] |= pinMask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPIOGROUP_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/hsadc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/hsadc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/hsadc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/hsadc_18xx_43xx.h	2018-12-01 17:15:06.649606542 -0300
@@ -0,0 +1,581 @@
+/*
+ * @brief  LPC18xx/43xx High speed ADC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __HSADC_18XX_43XX_H_
+#define __HSADC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup HSADC_18XX_43XX CHIP:  LPC18xx/43xx High speed ADC driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief High speed ADC interrupt control structure
+ */
+typedef struct {
+	__O  uint32_t CLR_EN;			/*!< Interrupt clear mask */
+	__O  uint32_t SET_EN;			/*!< Interrupt set mask */
+	__I  uint32_t MASK;				/*!< Interrupt mask */
+	__I  uint32_t STATUS;			/*!< Interrupt status */
+	__O  uint32_t CLR_STAT;			/*!< Interrupt clear status */
+	__O  uint32_t SET_STAT;			/*!< Interrupt set status */
+	uint32_t RESERVED[2];
+} HSADCINTCTRL_T;
+
+/**
+ * @brief HSADC register block structure
+ */
+typedef struct {					/*!< HSADC Structure */
+	__O  uint32_t FLUSH;			/*!< Flushes FIFO */
+	__IO uint32_t DMA_REQ;			/*!< Set or clear DMA write request */
+	__I  uint32_t FIFO_STS;			/*!< Indicates FIFO fill level status */
+	__IO uint32_t FIFO_CFG;			/*!< Configures FIFO fill level */
+	__O  uint32_t TRIGGER;			/*!< Enable software trigger to start descriptor processing */
+	__IO uint32_t DSCR_STS;			/*!< Indicates active descriptor table and descriptor entry */
+	__IO uint32_t POWER_DOWN;		/*!< Set or clear power down mode */
+	__IO uint32_t CONFIG;			/*!< Configures external trigger mode, store channel ID in FIFO and walk-up recovery time from power down */
+	__IO uint32_t THR[2];			/*!< Configures window comparator A or B levels */
+	__I  uint32_t LAST_SAMPLE[6];	/*!< Contains last converted sample of input M [M=0..5) and result of window comparator */
+	uint32_t RESERVED0[49];
+	__IO uint32_t ADC_SPEED;		/*!< ADC speed control */
+	__IO uint32_t POWER_CONTROL;	/*!< Configures ADC power vs. speed, DC-in biasing, output format and power gating */
+	uint32_t RESERVED1[61];
+	__I  uint32_t FIFO_OUTPUT[16];	/*!< FIFO output mapped to 16 consecutive address locations */
+	uint32_t RESERVED2[48];
+	__IO uint32_t DESCRIPTOR[2][8];	/*!< Table 0 and 1 descriptors */
+	uint32_t RESERVED3[752];
+	HSADCINTCTRL_T INTS[2];			/*!< Interrupt 0 and 1 control and status registers */
+} LPC_HSADC_T;
+
+#define HSADC_MAX_SAMPLEVAL 0xFFF
+
+/**
+ * @brief	Initialize the High speed ADC
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_HSADC_Init(LPC_HSADC_T *pHSADC);
+
+/**
+ * @brief	Shutdown HSADC
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_HSADC_DeInit(LPC_HSADC_T *pHSADC);
+
+/**
+ * @brief	Flush High speed ADC FIFO
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_FlushFIFO(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->FLUSH = 1;
+}
+
+/**
+ * @brief	Load a descriptor table from memory by requesting a DMA write
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ * @note	WHat is this used for?
+ */
+STATIC INLINE void Chip_HSADC_LoadDMADesc(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->DMA_REQ = 1;
+}
+
+/**
+ * @brief	Returns current HSADC FIFO fill level
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	FIFO level, 0 for empty, 1 to 15, or 16 for full
+ * @note	WHat is this used for?
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetFIFOLevel(LPC_HSADC_T *pHSADC)
+{
+	return pHSADC->FIFO_STS;
+}
+
+/**
+ * @brief	Sets up HSADC FIFO trip level and packing
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @param	trip	: HSADC FIFO trip point (1 to 15 samples)
+ * @param	packed	: true to pack samples, false for no packing
+ * @return	Nothing
+ * @note	The FIFO trip point is used for the DMA or interrupt level.
+ *			Sample packging allows packing 2 samples into a single 32-bit
+ *			word.
+ */
+void Chip_HSADC_SetupFIFO(LPC_HSADC_T *pHSADC, uint8_t trip, bool packed);
+
+/**
+ * @brief	Starts a manual (software) trigger of HSADC descriptors
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_SWTrigger(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->TRIGGER = 1;
+}
+
+/**
+ * @brief	Set active table descriptor index and number
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @param	table	: Table index, 0 or 1
+ * @param	desc	: Descriptor index, 0 to 7
+ * @return	Nothing
+ * @note	This function can be used to set active descriptor table and
+ *			active descriptor entry values. The new values will be updated
+ *			immediately. This should only be updated when descriptors are
+ *			not running (halted).
+ */
+STATIC INLINE void Chip_HSADC_SetActiveDescriptor(LPC_HSADC_T *pHSADC, uint8_t table, uint8_t desc)
+{
+	pHSADC->DSCR_STS = (uint32_t) ((desc << 1) | table);
+}
+
+/**
+ * @brief	Returns currently active descriptor index being processed
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	the current active descriptor index, 0 to 7
+ */
+STATIC INLINE uint8_t Chip_HSADC_GetActiveDescriptorIndex(LPC_HSADC_T *pHSADC)
+{
+	return (uint8_t) ((pHSADC->DSCR_STS >> 1) & 0x7);
+}
+
+/**
+ * @brief	Returns currently active descriptor table being processed
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	the current active descriptor table, 0 or 1
+ */
+STATIC INLINE uint8_t Chip_HSADC_GetActiveDescriptorTable(LPC_HSADC_T *pHSADC)
+{
+	return (uint8_t) (pHSADC->DSCR_STS & 1);
+}
+
+/**
+ * @brief	Enables ADC power down mode
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ * @note	In most cases, this function doesn't need to be used as
+ * the descriptors control power as needed.
+ */
+STATIC INLINE void Chip_HSADC_EnablePowerDownMode(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->POWER_DOWN = 1;
+}
+
+/**
+ * @brief	Disables ADC power down mode
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	Nothing
+ * @note	In most cases, this function doesn't need to be used as
+ * the descriptors control power as needed.
+ */
+STATIC INLINE void Chip_HSADC_DisablePowerDownMode(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->POWER_DOWN = 0;
+}
+
+/* HSADC trigger configuration mask types */
+typedef enum {
+	HSADC_CONFIG_TRIGGER_OFF = 0,				/*!< ADCHS triggers off */
+	HSADC_CONFIG_TRIGGER_SW = 1,				/*!< ADCHS software trigger only */
+	HSADC_CONFIG_TRIGGER_EXT = 2,				/*!< ADCHS external trigger only */
+	HSADC_CONFIG_TRIGGER_BOTH = 3				/*!< ADCHS both software and external triggers allowed */
+} HSADC_TRIGGER_MASK_T;
+
+/* HSADC trigger configuration mode types */
+typedef enum {
+	HSADC_CONFIG_TRIGGER_RISEEXT = (0 << 2),	/*!< ADCHS rising external trigger */
+	HSADC_CONFIG_TRIGGER_FALLEXT = (1 << 2),	/*!< ADCHS falling external trigger */
+	HSADC_CONFIG_TRIGGER_LOWEXT = (2 << 2),		/*!< ADCHS low external trigger */
+	HSADC_CONFIG_TRIGGER_HIGHEXT = (3 << 2)		/*!< ADCHS high external trigger */
+} HSADC_TRIGGER_MODE_T;
+
+/* HSADC trigger configuration sync types */
+typedef enum {
+	HSADC_CONFIG_TRIGGER_NOEXTSYNC = (0 << 4),	/*!< do not synchronize external trigger input */
+	HSADC_CONFIG_TRIGGER_EXTSYNC = (1 << 4),	/*!< synchronize external trigger input */
+} HSADC_TRIGGER_SYNC_T;
+
+/* HSADC trigger configuration channel ID */
+typedef enum {
+	HSADC_CHANNEL_ID_EN_NONE = (0 << 5),	/*!< do not add channel ID to FIFO output data */
+	HSADC_CHANNEL_ID_EN_ADD = (1 << 5),		/*!< add channel ID to FIFO output data */
+} HSADC_CHANNEL_ID_EN_T;
+
+/**
+ * @brief	Configure HSADC trigger source and recovery time
+ * @param	pHSADC			: The base of HSADC peripheral on the chip
+ * @param	mask			: HSADC trigger configuration mask type
+ * @param	mode			: HSADC trigger configuration mode type
+ * @param	sync			: HSADC trigger configuration sync type
+ * @param	chID			: HSADC trigger configuration channel ID enable
+ * @param	recoveryTime	: ADC recovery time (in HSADC clocks) from powerdown (255 max)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_ConfigureTrigger(LPC_HSADC_T *pHSADC,
+											   HSADC_TRIGGER_MASK_T mask,
+											   HSADC_TRIGGER_MODE_T mode,
+											   HSADC_TRIGGER_SYNC_T sync,
+											   HSADC_CHANNEL_ID_EN_T chID, uint16_t recoveryTime)
+{
+	pHSADC->CONFIG = (uint32_t) mask | (uint32_t) mode | (uint32_t) sync |
+					 (uint32_t) chID | (uint32_t) (recoveryTime << 6);
+}
+
+/**
+ * @brief	Set HSADC Threshold low value
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @param   thrnum	: Threshold register value (0 for threshold register A, 1 for threshold register B)
+ * @param   value	: Threshold low data value (should be 12-bit value)
+ * @return	None
+ */
+void Chip_HSADC_SetThrLowValue(LPC_HSADC_T *pHSADC, uint8_t thrnum, uint16_t value);
+
+/**
+ * @brief	Set HSADC Threshold high value
+ * @param	pHSADC		: The base of HSADC peripheral on the chip
+ * @param   thrnum      : Threshold register value (0 for threshold register A, 1 for threshold register B)
+ * @param   value       : Threshold high data value (should be 12-bit value)
+ * @return	None
+ */
+void Chip_HSADC_SetThrHighValue(LPC_HSADC_T *pHSADC, uint8_t thrnum, uint16_t value);
+
+/** HSADC last sample registers bit fields */
+#define HSADC_LS_DONE                    (1 << 0)		/*!< Sample conversion complete bit */
+#define HSADC_LS_OVERRUN                 (1 << 1)		/*!< Sample overrun bit */
+#define HSADC_LS_RANGE_IN                (0 << 2)		/*!< Threshold range comparison is in range */
+#define HSADC_LS_RANGE_BELOW             (1 << 2)		/*!< Threshold range comparison is below range */
+#define HSADC_LS_RANGE_ABOVE             (2 << 2)		/*!< Threshold range comparison is above range */
+#define HSADC_LS_RANGE(val)              ((val) & 0xC)	/*!< Mask for threshold crossing comparison result */
+#define HSADC_LS_CROSSING_NONE           (0 << 4)		/*!< No threshold crossing detected */
+#define HSADC_LS_CROSSING_DOWN           (1 << 4)		/*!< Downward threshold crossing detected */
+#define HSADC_LS_CROSSING_UP             (2 << 4)		/*!< Upward threshold crossing detected */
+#define HSADC_LS_CROSSING(val)           ((val) & 0x30)	/*!< Mask for threshold crossing comparison result */
+#define HSADC_LS_DATA(val)               ((val) >> 6)	/*!< Mask data value out of sample */
+
+/**
+ * @brief	Read a ADC last sample register
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	channel	: Last sample register to read, 0-5
+ * @return	Current raw value of the indexed last sample register
+ * @note	This function returns the raw value of the indexed last sample register
+ * and clears the sample's DONE and OVERRUN statuses if set. You can determine
+ * the overrun and datavalid status for the sample by masking the return value
+ * with HSADC_LS_DONE or HSADC_LS_OVERRUN. To get the data value for the sample,
+ * use the HSADC_LS_DATA(sample) macro. The threshold range and crossing results
+ * can be determined by using the HSADC_LS_RANGE(sample) and
+ * HSADC_LS_CROSSING(sample) macros and comparing the result against the
+ * HSADC_LS_RANGE_* or HSADC_LS_CROSSING_* definitions.<br>
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetLastSample(LPC_HSADC_T *pHSADC, uint8_t channel)
+{
+	return pHSADC->LAST_SAMPLE[channel];
+}
+
+/**
+ * @brief	Setup speed for a input channel
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	channel	: Input to set, 0-5
+ * @param	speed	: Speed value to set (0xF, 0xE, or 0x0), see user manual
+ * @return	Nothing
+ * @note	It is recommended not to use this function, as the values needed
+ * for this register will be setup with the Chip_HSADC_SetPowerSpeed() function.
+ */
+void Chip_HSADC_SetSpeed(LPC_HSADC_T *pHSADC, uint8_t channel, uint8_t speed);
+
+/**
+ * @brief	Setup (common) HSADC power and speed settings
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	comp2	: True sets up for 2's complement, false sets up for offset binary data format
+ * @return	Nothing
+ * @note	This function sets up the HSADC current/power/speed settings that
+ * apply to all HSADC channels (inputs). Based on the HSADC clock rate, it will
+ * automatically setup the best current setting (CRS) and speed settings (DGEC)
+ * for all channels. (See user manual).<br>
+ * This function is also used to set the data format of the sampled data. It is
+ * recommended to call this function if the HSADC sample rate changes.
+ */
+void Chip_HSADC_SetPowerSpeed(LPC_HSADC_T *pHSADC, bool comp2);
+
+/* AC-DC coupling selection for vin_neg and vin_pos sides */
+typedef enum {
+	HSADC_CHANNEL_NODCBIAS = 0,		/*!< No DC bias */
+	HSADC_CHANNEL_DCBIAS = 1,		/*!< DC bias on vin_neg side */
+} HSADC_DCBIAS_T;
+
+/**
+ * @brief	Setup AC-DC coupling selection for a channel
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	channel	: Input to set, 0-5
+ * @param	dcInNeg	: AC-DC coupling selection on vin_neg side
+ * @param	dcInPos	: AC-DC coupling selection on vin_pos side
+ * @return	Nothing
+ * @note	This function sets up the HSADC current/power/speed settings that
+ * apply to all HSADC channels (inputs). Based on the HSADC clock rate, it will
+ * automatically setup the best current setting (CRS) and speed settings (DGEC)
+ * for all channels. (See user manual).<br>
+ * This function is also used to set the data format of the sampled data. It is
+ * recommended to call this function if the HSADC sample rate changes.
+ */
+void Chip_HSADC_SetACDCBias(LPC_HSADC_T *pHSADC, uint8_t channel,
+							HSADC_DCBIAS_T dcInNeg, HSADC_DCBIAS_T dcInPos);
+
+/**
+ * @brief	Enable HSADC power control and band gap reference
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @return	Nothing
+ * @note	This function enables both the HSADC power and band gap
+ * reference.
+ */
+STATIC INLINE void Chip_HSADC_EnablePower(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->POWER_CONTROL |= (1 << 17) | (1 << 18);
+}
+
+/**
+ * @brief	Disable HSADC power control and band gap reference
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @return	Nothing
+ * @note	This function disables both the HSADC power and band gap
+ * reference.
+ */
+STATIC INLINE void Chip_HSADC_DisablePower(LPC_HSADC_T *pHSADC)
+{
+	pHSADC->POWER_CONTROL &= ~((1 << 17) | (1 << 18));
+}
+
+/** HSADC FIFO registers bit fields for unpacked sample in lower 16 bits */
+#define HSADC_FIFO_SAMPLE_MASK      (0xFFF)					/*!< 12-bit sample mask (unpacked) */
+#define HSADC_FIFO_SAMPLE(val)      ((val) & 0xFFF)			/*!< Macro for stripping out unpacked sample data */
+#define HSADC_FIFO_CHAN_ID_MASK     (0x7000)				/*!< Channel ID mask */
+#define HSADC_FIFO_CHAN_ID(val)     (((val) >> 12) & 0x7)	/*!< Macro for stripping out sample data */
+#define HSADC_FIFO_EMPTY            (0x1 << 15)				/*!< FIFO empty (invalid sample) */
+#define HSADC_FIFO_SHIFTPACKED(val) ((val) >> 16)			/*!< Shifts the packed FIFO sample into the lower 16-bits of a word */
+#define HSADC_FIFO_PACKEDMASK       (1UL << 31)				/*!< Packed sample check mask */
+
+/**
+ * @brief	Reads the HSADC FIFO
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @return	HSADC FIFO value
+ * @note	This function reads and pops the HSADC FIFO. The FIFO
+ * contents can be determined by using the HSADC_FIFO_* macros. If
+ * FIFO packing is enabled, this may contain 2 samples. Use the
+ * HSADC_FIFO_SHIFTPACKED macro to shift packed sample data into a
+ * variable that can be used with the HSADC_FIFO_* macros. Note that
+ * even if packing is enabled, the packed sample may not be valid.
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetFIFO(LPC_HSADC_T *pHSADC)
+{
+	return pHSADC->FIFO_OUTPUT[0];
+}
+
+/** HSADC descriptor registers bit fields and support macros */
+#define HSADC_DESC_CH(ch)           (ch)				/*!< Converter input channel */
+#define HSADC_DESC_HALT             (1 << 3)			/*!< Descriptor halt after conversion bit */
+#define HSADC_DESC_INT              (1 << 4)			/*!< Raise interrupt when ADC result is available bit */
+#define HSADC_DESC_POWERDOWN        (1 << 5)			/*!< Power down after this conversion bit */
+#define HSADC_DESC_BRANCH_NEXT      (0 << 6)			/*!< Continue with next descriptor */
+#define HSADC_DESC_BRANCH_FIRST     (1 << 6)			/*!< Branch to the first descriptor */
+#define HSADC_DESC_BRANCH_SWAP      (2 << 6)			/*!< Swap tables and branch to the first descriptor of the new table */
+#define HSADC_DESC_MATCH(val)       ((val) << 8)		/*!< Match value used to trigger a descriptor */
+#define HSADC_DESC_THRESH_NONE      (0 << 22)			/*!< No threshold detection performed */
+#define HSADC_DESC_THRESH_A         (1 << 22)			/*!< Use A threshold detection */
+#define HSADC_DESC_THRESH_B         (2 << 22)			/*!< Use B threshold detection */
+#define HSADC_DESC_RESET_TIMER      (1 << 24)			/*!< Reset descriptor timer */
+#define HSADC_DESC_UPDATE_TABLE     (1UL << 31)			/*!< Update table with all 8 descriptors of this table */
+
+/**
+ * @brief	Sets up a raw HSADC descriptor entry
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	table	: Descriptor table number, 0 or 1
+ * @param	descNo	: Descriptor number to setup, 0 to 7
+ * @param	desc	: Raw descriptor value (see notes)
+ * @return	Nothing
+ * @note	This function sets up a descriptor table entry. To setup
+ * a descriptor entry, select a OR'ed combination of the HSADC_DESC_CH,
+ * HSADC_DESC_HALT, HSADC_DESC_INT, HSADC_DESC_POWERDOWN, one of
+ * HSADC_DESC_BRANCH_*, HSADC_DESC_MATCH, one of HSADC_DESC_THRESH_*, and
+ * HSADC_DESC_RESET_TIMER definitions.<br>
+ * Example for setting up a table 0, descriptor number 4 entry for input 0:<br>
+ * Chip_HSADC_SetupDescEntry(LPC_HSADC, 0, 4, (HSADC_DESC_CH(0) | HSADC_DESC_HALT |
+ *    HSADC_DESC_INT));
+ */
+STATIC INLINE void Chip_HSADC_SetupDescEntry(LPC_HSADC_T *pHSADC, uint8_t table,
+											 uint8_t descNo, uint32_t desc)
+{
+	pHSADC->DESCRIPTOR[table][descNo] = desc;
+}
+
+/**
+ * @brief	Update all descriptors of a table
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	table	: Descriptor table number, 0 or 1
+ * @return	Nothing
+ * @note	Updates descriptor table with all 8 descriptors. This
+ * function should be used after all descriptors are setup with
+ * the Chip_HSADC_SetupDescEntry() function.
+ */
+STATIC INLINE void Chip_HSADC_UpdateDescTable(LPC_HSADC_T *pHSADC, uint8_t table)
+{
+	pHSADC->DESCRIPTOR[table][0] |= HSADC_DESC_UPDATE_TABLE;
+}
+
+/* Interrupt selection for interrupt 0 set - these interrupts and statuses
+   should only be used with the interrupt 0 register set */
+#define HSADC_INT0_FIFO_FULL         (1 << 0)		/*!< number of samples in FIFO is more than FIFO_LEVEL */
+#define HSADC_INT0_FIFO_EMPTY        (1 << 1)		/*!< FIFO is empty */
+#define HSADC_INT0_FIFO_OVERFLOW     (1 << 2)		/*!< FIFO was full; conversion sample is not stored and lost */
+#define HSADC_INT0_DSCR_DONE         (1 << 3)		/*!< The descriptor INTERRUPT field was enabled and its sample is converted */
+#define HSADC_INT0_DSCR_ERROR        (1 << 4)		/*!< The ADC was not fully woken up when a sample was converted and the conversion results is unreliable */
+#define HSADC_INT0_ADC_OVF           (1 << 5)		/*!< Converted sample value was over range of the 12 bit output code */
+#define HSADC_INT0_ADC_UNF           (1 << 6)		/*!< Converted sample value was under range of the 12 bit output code */
+
+/* Interrupt selection for interrupt 1 set - these interrupts and statuses
+   should only be used with the interrupt 1 register set */
+#define HSADC_INT1_THCMP_BRANGE(ch)  (1 << ((ch * 5) + 0))	/*!< Input channel result below range */
+#define HSADC_INT1_THCMP_ARANGE(ch)  (1 << ((ch * 5) + 1))	/*!< Input channel result above range */
+#define HSADC_INT1_THCMP_DCROSS(ch)  (1 << ((ch * 5) + 2))	/*!< Input channel result downward threshold crossing detected */
+#define HSADC_INT1_THCMP_UCROSS(ch)  (1 << ((ch * 5) + 3))	/*!< Input channel result upward threshold crossing detected */
+#define HSADC_INT1_OVERRUN(ch)       (1 << ((ch * 5) + 4))	/*!< New conversion on channel completed and has overwritten the previous contents of register LAST_SAMPLE [0] before it has been read */
+
+/**
+ * @brief	Enable an interrupt for HSADC interrupt group 0 or 1
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	intGrp	: Interrupt group 0 or 1
+ * @param	intMask	: Interrupts to enable, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_EnableInts(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t intMask)
+{
+	pHSADC->INTS[intGrp].SET_EN = intMask;
+}
+
+/**
+ * @brief	Disables an interrupt for HSADC interrupt group 0 or 1
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	intGrp	: Interrupt group 0 or 1
+ * @param	intMask	: Interrupts to disable, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_DisableInts(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t intMask)
+{
+	pHSADC->INTS[intGrp].CLR_EN = intMask;
+}
+
+/**
+ * @brief	Returns enabled interrupt for HSADC interrupt group 0 or 1
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	intGrp	: Interrupt group 0 or 1
+ * @return	enabled interrupts for the selected group
+ * @note	Mask the return value with a HSADC_INT0_* macro for group 0
+ * or HSADC_INT1_* values for group 1 to determine which interrupts are enabled.
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetEnabledInts(LPC_HSADC_T *pHSADC, uint8_t intGrp)
+{
+	return pHSADC->INTS[intGrp].MASK;
+}
+
+/**
+ * @brief	Returns status for HSADC interrupt group 0 or 1
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	intGrp	: Interrupt group 0 or 1
+ * @return	interrupt (pending) status for the selected group
+ * @note	Mask the return value with a HSADC_INT0_* macro for group 0
+ * or HSADC_INT1_* values for group 1 to determine which statuses are active.
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetIntStatus(LPC_HSADC_T *pHSADC, uint8_t intGrp)
+{
+	return pHSADC->INTS[intGrp].STATUS;
+}
+
+/**
+ * @brief	Clear a status for HSADC interrupt group 0 or 1
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	intGrp	: Interrupt group 0 or 1
+ * @param	stsMask	: Statuses to clear, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_ClearIntStatus(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t stsMask)
+{
+	pHSADC->INTS[intGrp].CLR_STAT = stsMask;
+}
+
+/**
+ * @brief	Sets a status for HSADC interrupt group 0 or 1
+ * @param	pHSADC	: The base of ADC peripheral on the chip
+ * @param	intGrp	: Interrupt group 0 or 1
+ * @param	stsMask	: Statuses to set, use HSADC_INT0_* for group 0
+ *                    and HSADC_INT1_* values for group 1
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_HSADC_SetIntStatus(LPC_HSADC_T *pHSADC, uint8_t intGrp, uint32_t stsMask)
+{
+	pHSADC->INTS[intGrp].SET_STAT = stsMask;
+}
+
+/**
+ * @brief	Returns the clock rate in Hz for the HSADC
+ * @param	pHSADC	: The base of HSADC peripheral on the chip
+ * @return	clock rate in Hz for the HSADC
+ */
+STATIC INLINE uint32_t Chip_HSADC_GetBaseClockRate(LPC_HSADC_T *pHSADC)
+{
+	(void) pHSADC;
+
+	/* Return computed sample rate for the high speed ADC peripheral */
+	return Chip_Clock_GetRate(CLK_ADCHS);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HSADC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2c_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/i2c_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2c_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/i2c_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,406 @@
+/*
+ * @brief LPC18xx/43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2C_18XX_43XX_H_
+#define __I2C_18XX_43XX_H_
+#include "i2c_common_18xx_43xx.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup I2C_18XX_43XX
+ * @{
+ */
+
+/**
+ * @brief	Return values for SLAVE handler
+ * @note
+ * Chip drivers will usally be designed to match their events with this value
+ */
+#define RET_SLAVE_TX    6	/**< Return value, when 1 byte TX'd successfully */
+#define RET_SLAVE_RX    5	/**< Return value, when 1 byte RX'd successfully */
+#define RET_SLAVE_IDLE  2	/**< Return value, when slave enter idle mode */
+#define RET_SLAVE_BUSY  0	/**< Return value, when slave is busy */
+
+/**
+ * @brief I2C state handle return values
+ */
+#define I2C_STA_STO_RECV            0x20
+
+/*
+ * @brief I2C return status code definitions
+ */
+#define I2C_I2STAT_NO_INF                       ((0xF8))/*!< No relevant information */
+#define I2C_I2STAT_BUS_ERROR                    ((0x00))/*!< Bus Error */
+
+/*
+ * @brief I2C status values
+ */
+#define I2C_SETUP_STATUS_ARBF   (1 << 8)	/**< Arbitration false */
+#define I2C_SETUP_STATUS_NOACKF (1 << 9)	/**< No ACK returned */
+#define I2C_SETUP_STATUS_DONE   (1 << 10)	/**< Status DONE */
+
+/*
+ * @brief I2C state handle return values
+ */
+#define I2C_OK                      0x00
+#define I2C_BYTE_SENT               0x01
+#define I2C_BYTE_RECV               0x02
+#define I2C_LAST_BYTE_RECV          0x04
+#define I2C_SEND_END                0x08
+#define I2C_RECV_END                0x10
+#define I2C_STA_STO_RECV            0x20
+
+#define I2C_ERR                     (0x10000000)
+#define I2C_NAK_RECV                (0x10000000 | 0x01)
+
+#define I2C_CheckError(ErrorCode)   (ErrorCode & 0x10000000)
+
+/*
+ * @brief I2C monitor control configuration defines
+ */
+#define I2C_MONITOR_CFG_SCL_OUTPUT  I2C_I2MMCTRL_ENA_SCL		/**< SCL output enable */
+#define I2C_MONITOR_CFG_MATCHALL    I2C_I2MMCTRL_MATCH_ALL		/**< Select interrupt register match */
+
+/**
+ * @brief	I2C Slave Identifiers
+ */
+typedef enum {
+	I2C_SLAVE_GENERAL,	/**< Slave ID for general calls */
+	I2C_SLAVE_0,		/**< Slave ID fo Slave Address 0 */
+	I2C_SLAVE_1,		/**< Slave ID fo Slave Address 1 */
+	I2C_SLAVE_2,		/**< Slave ID fo Slave Address 2 */
+	I2C_SLAVE_3,		/**< Slave ID fo Slave Address 3 */
+	I2C_SLAVE_NUM_INTERFACE	/**< Number of slave interfaces */
+} I2C_SLAVE_ID;
+
+/**
+ * @brief	I2C transfer status
+ */
+typedef enum {
+	I2C_STATUS_DONE,	/**< Transfer done successfully */
+	I2C_STATUS_NAK,		/**< NAK received during transfer */
+	I2C_STATUS_ARBLOST,	/**< Aribitration lost during transfer */
+	I2C_STATUS_BUSERR,	/**< Bus error in I2C transfer */
+	I2C_STATUS_BUSY,	/**< I2C is busy doing transfer */
+	I2C_STATUS_SLAVENAK,/**< NAK received after SLA+W or SLA+R */
+} I2C_STATUS_T;
+
+/**
+ * @brief Master transfer data structure definitions
+ */
+typedef struct {
+	uint8_t slaveAddr;		/**< 7-bit I2C Slave address */
+	const uint8_t *txBuff;	/**< Pointer to array of bytes to be transmitted */
+	int     txSz;			/**< Number of bytes in transmit array,
+							   if 0 only receive transfer will be carried on */
+	uint8_t *rxBuff;		/**< Pointer memory where bytes received from I2C be stored */
+	int     rxSz;			/**< Number of bytes to received,
+							   if 0 only transmission we be carried on */
+	I2C_STATUS_T status;	/**< Status of the current I2C transfer */
+} I2C_XFER_T;
+
+/**
+ * @brief	I2C interface IDs
+ * @note
+ * All Chip functions will take this as the first parameter,
+ * I2C_NUM_INTERFACE must never be used for calling any Chip
+ * functions, it is only used to find the number of interfaces
+ * available in the Chip.
+ */
+typedef enum I2C_ID {
+	I2C0,				/**< ID I2C0 */
+	I2C1,				/**< ID I2C1 */
+	I2C_NUM_INTERFACE	/**< Number of I2C interfaces in the chip */
+} I2C_ID_T;
+
+/**
+ * @brief	I2C master events
+ */
+typedef enum {
+	I2C_EVENT_WAIT = 1,	/**< I2C Wait event */
+	I2C_EVENT_DONE,		/**< Done event that wakes up Wait event */
+	I2C_EVENT_LOCK,		/**< Re-entrency lock event for I2C transfer */
+	I2C_EVENT_UNLOCK,	/**< Re-entrency unlock event for I2C transfer */
+	I2C_EVENT_SLAVE_RX,	/**< Slave receive event */
+	I2C_EVENT_SLAVE_TX,	/**< Slave transmit event */
+} I2C_EVENT_T;
+
+/**
+ * @brief	Event handler function type
+ */
+typedef void (*I2C_EVENTHANDLER_T)(I2C_ID_T, I2C_EVENT_T);
+
+/**
+ * @brief	Initializes the LPC_I2C peripheral with specified parameter.
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	Nothing
+ */
+void Chip_I2C_Init(I2C_ID_T id);
+
+/**
+ * @brief	De-initializes the I2C peripheral registers to their default reset values
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	Nothing
+ */
+void Chip_I2C_DeInit(I2C_ID_T id);
+
+/**
+ * @brief	Set up clock rate for LPC_I2C peripheral.
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	clockrate	: Target clock rate value to initialized I2C peripheral (Hz)
+ * @return	Nothing
+ * @note
+ * Parameter @a clockrate for I2C0 should be from 1000 up to 1000000
+ * (1 KHz to 1 MHz), as I2C0 support Fast Mode Plus. If the @a clockrate
+ * is more than 400 KHz (Fast Plus Mode) Board_I2C_EnableFastPlus()
+ * must be called prior to calling this function.
+ */
+void Chip_I2C_SetClockRate(I2C_ID_T id, uint32_t clockrate);
+
+/**
+ * @brief	Get current clock rate for LPC_I2C peripheral.
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	The current I2C peripheral clock rate
+ */
+uint32_t Chip_I2C_GetClockRate(I2C_ID_T id);
+
+/**
+ * @brief	Transmit and Receive data in master mode
+ * @param	id		: I2C peripheral selected (I2C0, I2C1 etc)
+ * @param	xfer	: Pointer to a I2C_XFER_T structure see notes below
+ * @return
+ * Any of #I2C_STATUS_T values, xfer->txSz will have number of bytes
+ * not sent due to error, xfer->rxSz will have the number of bytes yet
+ * to be received.
+ * @note
+ * The parameter @a xfer should have its member @a slaveAddr initialized
+ * to the 7-Bit slave address to which the master will do the xfer, Bit0
+ * to bit6 should have the address and Bit8 is ignored. During the transfer
+ * no code (like event handler) must change the content of the memory
+ * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
+ * initialized to the memory from which the I2C must pick the data to be
+ * transfered to slave and the number of bytes to send respectively, similarly
+ * @a rxBuff and @a rxSz must have pointer to memroy where data received
+ * from slave be stored and the number of data to get from slave respectilvely.
+ */
+int Chip_I2C_MasterTransfer(I2C_ID_T id, I2C_XFER_T *xfer);
+
+/**
+ * @brief	Transmit data to I2C slave using I2C Master mode
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 .. etc)
+ * @param	slaveAddr	: Slave address to which the data be written
+ * @param	buff		: Pointer to buffer having the array of data
+ * @param	len			: Number of bytes to be transfered from @a buff
+ * @return	Number of bytes successfully transfered
+ */
+int Chip_I2C_MasterSend(I2C_ID_T id, uint8_t slaveAddr, const uint8_t *buff, uint8_t len);
+
+/**
+ * @brief	Transfer a command to slave and receive data from slave after a repeated start
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	slaveAddr	: Slave address of the I2C device
+ * @param	cmd			: Command (Address/Register) to be written
+ * @param	buff		: Pointer to memory that will hold the data received
+ * @param	len			: Number of bytes to receive
+ * @return	Number of bytes successfully received
+ */
+int Chip_I2C_MasterCmdRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t cmd, uint8_t *buff, int len);
+
+/**
+ * @brief	Get pointer to current function handling the events
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	Pointer to function handing events of I2C
+ */
+I2C_EVENTHANDLER_T Chip_I2C_GetMasterEventHandler(I2C_ID_T id);
+
+/**
+ * @brief	Set function that must handle I2C events
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	event		: Pointer to function that will handle the event (Should not be NULL)
+ * @return	1 when successful, 0 when a transfer is on going with its own event handler
+ */
+int Chip_I2C_SetMasterEventHandler(I2C_ID_T id, I2C_EVENTHANDLER_T event);
+
+/**
+ * @brief	Set function that must handle I2C events
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	slaveAddr	: Slave address from which data be read
+ * @param	buff		: Pointer to memory where data read be stored
+ * @param	len			: Number of bytes to read from slave
+ * @return	Number of bytes read successfully
+ */
+int Chip_I2C_MasterRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t *buff, int len);
+
+/**
+ * @brief	Default event handler for polling operation
+ * @param	id		: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	event	: Event ID of the event that called the function
+ * @return	Nothing
+ */
+void Chip_I2C_EventHandlerPolling(I2C_ID_T id, I2C_EVENT_T event);
+
+/**
+ * @brief	Default event handler for interrupt base operation
+ * @param	id		: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	event	: Event ID of the event that called the function
+ * @return	Nothing
+ */
+void Chip_I2C_EventHandler(I2C_ID_T id, I2C_EVENT_T event);
+
+/**
+ * @brief	I2C Master transfer state change handler
+ * @param	id		: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	Nothing
+ * @note	Usually called from the appropriate Interrupt handler
+ */
+void Chip_I2C_MasterStateHandler(I2C_ID_T id);
+
+/**
+ * @brief	Disable I2C peripheral's operation
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	Nothing
+ */
+void Chip_I2C_Disable(I2C_ID_T id);
+
+/**
+ * @brief	Checks if master xfer in progress
+ * @param	id		: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	1 if master xfer in progress 0 otherwise
+ * @note
+ * This API is generally used in interrupt handler
+ * of the application to decide whether to call
+ * master state handler or to call slave state handler
+ */
+int Chip_I2C_IsMasterActive(I2C_ID_T id);
+
+/**
+ * @brief	Setup a slave I2C device
+ * @param	id			: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @param	sid			: I2C Slave peripheral ID (I2C_SLAVE_0, I2C_SLAVE_1 etc)
+ * @param	xfer		: Pointer to transfer structure (see note below for more info)
+ * @param	event		: Event handler for slave transfers
+ * @param	addrMask	: Address mask to use along with slave address (see notes below for more info)
+ * @return	Nothing
+ * @note
+ * Parameter @a xfer should point to a valid I2C_XFER_T structure object
+ * and must have @a slaveAddr initialized with 7bit Slave address (From Bit1 to Bit7),
+ * Bit0 when set enables general call handling, @a slaveAddr along with @a addrMask will
+ * be used to match the slave address. @a rxBuff and @a txBuff must point to valid buffers
+ * where slave can receive or send the data from, size of which will be provided by
+ * @a rxSz and @a txSz respectively. Function pointed to by @a event will be called
+ * for the following events #I2C_EVENT_SLAVE_RX (One byte of data received successfully
+ * from the master and stored inside memory pointed by xfer->rxBuff, incremented
+ * the pointer and decremented the @a xfer->rxSz), #I2C_EVENT_SLAVE_TX (One byte of
+ * data from xfer->txBuff was sent to master successfully, incremented the pointer
+ * and decremented xfer->txSz), #I2C_EVENT_DONE (Master is done doing its transfers
+ * with the slave).<br>
+ * <br>Bit-0 of the parameter @a addrMask is reserved and should always be 0. Any bit (BIT1
+ * to BIT7) set in @a addrMask will make the corresponding bit in *xfer->slaveAddr* as
+ * don't care. Thit is, if *xfer->slaveAddr* is (0x10 << 1) and @a addrMask is (0x03 << 1) then
+ * 0x10, 0x11, 0x12, 0x13 will all be considered as valid slave addresses for the registered
+ * slave. Upon receving any event *xfer->slaveAddr* (BIT1 to BIT7) will hold the actual
+ * address which was received from master.<br>
+ * <br><b>General Call Handling</b><br>
+ * Slave can receive data from master using general call address (0x00). General call
+ * handling must be setup as given below
+ *      - Call Chip_I2C_SlaveSetup() with argument @a sid as I2C_SLAVE_GENERAL
+ *          - xfer->slaveAddr ignored, argument @a addrMask ignored
+ *          - function provided by @a event will registered to be called when slave received data using addr 0x00
+ *          - xfer->rxBuff and xfer->rxSz should be valid in argument @a xfer
+ *      - To handle General Call only (No other slaves are configured)
+ *          - Call Chip_I2C_SlaveSetup() with sid as I2C_SLAVE_X (X=0,1,2,3)
+ *          - setup @a xfer with slaveAddr member set to 0, @a event is ignored hence can be NULL
+ *          - provide @a addrMask (typically 0, if not you better be knowing what you are doing)
+ *      - To handler General Call when other slave is active
+ *          - Call Chip_I2C_SlaveSetup() with sid as I2C_SLAVE_X (X=0,1,2,3)
+ *          - setup @a xfer with slaveAddr member set to 7-Bit Slave address [from Bit1 to 7]
+ *          - Set Bit0 of @a xfer->slaveAddr as 1
+ *          - Provide appropriate @a addrMask
+ *          - Argument @a event must point to function, that handles events from actual slaveAddress and not the GC
+ * @warning
+ * If the slave has only one byte in its txBuff, once that byte is transfered to master the event handler
+ * will be called for event #I2C_EVENT_DONE. If the master attempts to read more bytes in the same transfer
+ * then the slave hardware will send 0xFF to master till the end of transfer, event handler will not be
+ * called to notify this. For more info see section below<br>
+ * <br><b> Last data handling in slave </b><br>
+ * If the user wants to implement a slave which will read a byte from a specific location over and over
+ * again whenever master reads the slave. If the user initializes the xfer->txBuff as the location to read
+ * the byte from and xfer->txSz as 1, then say, if master reads one byte; slave will send the byte read from
+ * xfer->txBuff and will call the event handler with #I2C_EVENT_DONE. If the master attempts to read another
+ * byte instead of sending the byte read from xfer->txBuff the slave hardware will send 0xFF and no event will
+ * occur. To handle this issue, slave should set xfer->txSz to 2, in which case when master reads the byte
+ * event handler will be called with #I2C_EVENT_SLAVE_TX, in which the slave implementation can reset the buffer
+ * and size back to original location (i.e, xfer->txBuff--, xfer->txSz++), if the master reads another byte
+ * in the same transfer, byte read from xfer->txBuff will be sent and #I2C_EVENT_SLAVE_TX will be called again, and
+ * the process repeats.
+ */
+void Chip_I2C_SlaveSetup(I2C_ID_T id,
+						 I2C_SLAVE_ID sid,
+						 I2C_XFER_T *xfer,
+						 I2C_EVENTHANDLER_T event,
+						 uint8_t addrMask);
+
+/**
+ * @brief	I2C Slave event handler
+ * @param	id		: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	Nothing
+ */
+void Chip_I2C_SlaveStateHandler(I2C_ID_T id);
+
+/**
+ * @brief	I2C peripheral state change checking
+ * @param	id		: I2C peripheral ID (I2C0, I2C1 ... etc)
+ * @return	1 if I2C peripheral @a id has changed its state,
+ *          0 if there is no state change
+ * @note
+ * This function must be used by the application when
+ * the polling has to be done based on state change.
+ */
+int Chip_I2C_IsStateChanged(I2C_ID_T id);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2c_common_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/i2c_common_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2c_common_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/i2c_common_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,206 @@
+/*
+ * @brief LPC18xx_43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2C_COMMON_18XX_43XX_H_
+#define __I2C_COMMON_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2C_18XX_43XX CHIP: LPC18xx_43xx I2C driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief I2C register block structure
+ */
+typedef struct {				/* I2C0 Structure         */
+	__IO uint32_t CONSET;		/*!< I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register. */
+	__I  uint32_t STAT;			/*!< I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed. */
+	__IO uint32_t DAT;			/*!< I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register. */
+	__IO uint32_t ADR0;			/*!< I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+	__IO uint32_t SCLH;			/*!< SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock. */
+	__IO uint32_t SCLL;			/*!< SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode. */
+	__O  uint32_t CONCLR;		/*!< I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register. */
+	__IO uint32_t MMCTRL;		/*!< Monitor mode control register. */
+	__IO uint32_t ADR1;			/*!< I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+	__IO uint32_t ADR2;			/*!< I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+	__IO uint32_t ADR3;			/*!< I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. */
+	__I  uint32_t DATA_BUFFER;	/*!< Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus. */
+	__IO uint32_t MASK[4];		/*!< I2C Slave address mask register */
+} LPC_I2C_T;
+
+/*
+ * @brief I2C Control Set register description
+ */
+#define I2C_I2CONSET_AA             ((0x04))/*!< Assert acknowledge flag */
+#define I2C_I2CONSET_SI             ((0x08))/*!< I2C interrupt flag */
+#define I2C_I2CONSET_STO            ((0x10))/*!< STOP flag */
+#define I2C_I2CONSET_STA            ((0x20))/*!< START flag */
+#define I2C_I2CONSET_I2EN           ((0x40))/*!< I2C interface enable */
+
+/*
+ * @brief I2C Control Clear register description
+ */
+#define I2C_I2CONCLR_AAC            ((1 << 2))	/*!< Assert acknowledge Clear bit */
+#define I2C_I2CONCLR_SIC            ((1 << 3))	/*!< I2C interrupt Clear bit */
+#define I2C_I2CONCLR_STOC           ((1 << 4))	/*!< I2C STOP Clear bit */
+#define I2C_I2CONCLR_STAC           ((1 << 5))	/*!< START flag Clear bit */
+#define I2C_I2CONCLR_I2ENC          ((1 << 6))	/*!< I2C interface Disable bit */
+
+/*
+ * @brief	I2C Common Control register description
+ */
+#define I2C_CON_AA            (1UL << 2)	/*!< Assert acknowledge bit */
+#define I2C_CON_SI            (1UL << 3)	/*!< I2C interrupt bit */
+#define I2C_CON_STO           (1UL << 4)	/*!< I2C STOP bit */
+#define I2C_CON_STA           (1UL << 5)	/*!< START flag bit */
+#define I2C_CON_I2EN          (1UL << 6)	/*!< I2C interface bit */
+
+/*
+ * @brief I2C Status Code definition (I2C Status register)
+ */
+#define I2C_STAT_CODE_BITMASK       ((0xF8))/*!< Return Code mask in I2C status register */
+#define I2C_STAT_CODE_ERROR         ((0xFF))/*!< Return Code error mask in I2C status register */
+
+/*
+ * @brief I2C Master transmit mode
+ */
+#define I2C_I2STAT_M_TX_START                   ((0x08))/*!< A start condition has been transmitted */
+#define I2C_I2STAT_M_TX_RESTART                 ((0x10))/*!< A repeat start condition has been transmitted */
+#define I2C_I2STAT_M_TX_SLAW_ACK                ((0x18))/*!< SLA+W has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_TX_SLAW_NACK               ((0x20))/*!< SLA+W has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_TX_DAT_ACK                 ((0x28))/*!< Data has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_TX_DAT_NACK                ((0x30))/*!< Data has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_TX_ARB_LOST                ((0x38))/*!< Arbitration lost in SLA+R/W or Data bytes */
+
+/*
+ * @brief I2C Master receive mode
+ */
+#define I2C_I2STAT_M_RX_START                   ((0x08))/*!< A start condition has been transmitted */
+#define I2C_I2STAT_M_RX_RESTART                 ((0x10))/*!< A repeat start condition has been transmitted */
+#define I2C_I2STAT_M_RX_ARB_LOST                ((0x38))/*!< Arbitration lost */
+#define I2C_I2STAT_M_RX_SLAR_ACK                ((0x40))/*!< SLA+R has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_RX_SLAR_NACK               ((0x48))/*!< SLA+R has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_RX_DAT_ACK                 ((0x50))/*!< Data has been received, ACK has been returned */
+#define I2C_I2STAT_M_RX_DAT_NACK                ((0x58))/*!< Data has been received, NACK has been returned */
+
+/*
+ * @brief I2C Slave receive mode
+ */
+#define I2C_I2STAT_S_RX_SLAW_ACK                ((0x60))/*!< Own slave address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_ARB_LOST_M_SLA          ((0x68))/*!< Arbitration lost in SLA+R/W as master */
+// #define I2C_I2STAT_S_RX_SLAW_ACK				((0x68)) /*!< Own SLA+W has been received, ACK returned */
+#define I2C_I2STAT_S_RX_GENCALL_ACK             ((0x70))/*!< General call address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL      ((0x78))/*!< Arbitration lost in SLA+R/W (GENERAL CALL) as master */
+// #define I2C_I2STAT_S_RX_GENCALL_ACK				((0x78)) /*!< General call address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK         ((0x80))/*!< Previously addressed with own SLA; Data has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK        ((0x88))/*!< Previously addressed with own SLA;Data has been received and NOT ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK     ((0x90))/*!< Previously addressed with General Call; Data has been received and ACK has been returned */
+#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK    ((0x98))/*!< Previously addressed with General Call; Data has been received and NOT ACK has been returned */
+#define I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX   ((0xA0))/*!< A STOP condition or repeated START condition has been received while still addressed as SLV/REC (Slave Receive) or
+														   SLV/TRX (Slave Transmit) */
+
+/*
+ * @brief I2C Slave transmit mode
+ */
+#define I2C_I2STAT_S_TX_SLAR_ACK                ((0xA8))/*!< Own SLA+R has been received, ACK has been returned */
+#define I2C_I2STAT_S_TX_ARB_LOST_M_SLA          ((0xB0))/*!< Arbitration lost in SLA+R/W as master */
+// #define I2C_I2STAT_S_TX_SLAR_ACK				((0xB0)) /*!< Own SLA+R has been received, ACK has been returned */
+#define I2C_I2STAT_S_TX_DAT_ACK                 ((0xB8))/*!< Data has been transmitted, ACK has been received */
+#define I2C_I2STAT_S_TX_DAT_NACK                ((0xC0))/*!< Data has been transmitted, NACK has been received */
+#define I2C_I2STAT_S_TX_LAST_DAT_ACK            ((0xC8))/*!< Last data byte in I2DAT has been transmitted (AA = 0); ACK has been received */
+#define I2C_SLAVE_TIME_OUT                      0x10000000UL/*!< Time out in case of using I2C slave mode */
+
+/*
+ * @brief I2C Data register definition
+ */
+#define I2C_I2DAT_BITMASK           ((0xFF))/*!< Mask for I2DAT register */
+#define I2C_I2DAT_IDLE_CHAR         (0xFF)	/*!< Idle data value will be send out in slave mode in case of the actual expecting data requested from the master is greater than
+											     its sending data length that can be supported */
+
+/*
+ * @brief I2C Monitor mode control register description
+ */
+#define I2C_I2MMCTRL_MM_ENA         ((1 << 0))			/**< Monitor mode enable */
+#define I2C_I2MMCTRL_ENA_SCL        ((1 << 1))			/**< SCL output enable */
+#define I2C_I2MMCTRL_MATCH_ALL      ((1 << 2))			/**< Select interrupt register match */
+#define I2C_I2MMCTRL_BITMASK        ((0x07))		/**< Mask for I2MMCTRL register */
+
+/*
+ * @brief I2C Data buffer register description
+ */
+#define I2DATA_BUFFER_BITMASK       ((0xFF))/*!< I2C Data buffer register bit mask */
+
+/*
+ * @brief I2C Slave Address registers definition
+ */
+#define I2C_I2ADR_GC                ((1 << 0))	/*!< General Call enable bit */
+#define I2C_I2ADR_BITMASK           ((0xFF))/*!< I2C Slave Address registers bit mask */
+
+/*
+ * @brief I2C Mask Register definition
+ */
+#define I2C_I2MASK_MASK(n)          ((n & 0xFE))/*!< I2C Mask Register mask field */
+
+/*
+ * @brief I2C SCL HIGH duty cycle Register definition
+ */
+#define I2C_I2SCLH_BITMASK          ((0xFFFF))	/*!< I2C SCL HIGH duty cycle Register bit mask */
+
+/*
+ * @brief I2C SCL LOW duty cycle Register definition
+ */
+#define I2C_I2SCLL_BITMASK          ((0xFFFF))	/*!< I2C SCL LOW duty cycle Register bit mask */
+
+/*
+ * @brief I2C monitor control configuration defines
+ */
+#define I2C_MONITOR_CFG_SCL_OUTPUT  I2C_I2MMCTRL_ENA_SCL		/**< SCL output enable */
+#define I2C_MONITOR_CFG_MATCHALL    I2C_I2MMCTRL_MATCH_ALL		/**< Select interrupt register match */
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_COMMON_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2cm_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/i2cm_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2cm_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/i2cm_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,425 @@
+/*
+ * @brief LPC18xx/43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2CM_18XX_43XX_H_
+#define __I2CM_18XX_43XX_H_
+
+#include "i2c_common_18xx_43xx.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2CM_18XX_43XX CHIP: LPC18xx/43xx I2C master-only driver
+ * @ingroup I2C_18XX_43XX
+ * This driver only works in master mode. To describe the I2C transactions
+ * following symbols are used in driver documentation.
+ *
+ * Key to symbols
+ * ==============
+ * S     (1 bit) : Start bit
+ * P     (1 bit) : Stop bit
+ * Rd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.
+ * A, NA (1 bit) : Acknowledge and Not-Acknowledge bit.
+ * Addr  (7 bits): I2C 7 bit address. Note that this can be expanded as usual to
+ *                 get a 10 bit I2C address.
+ * Data  (8 bits): A plain data byte. Sometimes, I write DataLow, DataHigh
+ *                 for 16 bit data.
+ * [..]: Data sent by I2C device, as opposed to data sent by the host adapter.
+ * @{
+ */
+
+/** I2CM_18XX_43XX_OPTIONS_TYPES I2C master transfer options
+ * @{
+ */
+
+/** Ignore NACK during data transfer. By default transfer is aborted. */
+#define I2CM_XFER_OPTION_IGNORE_NACK     0x01
+/** ACK last byte received. By default we NACK last byte we receive per I2C spec. */
+#define I2CM_XFER_OPTION_LAST_RX_ACK     0x02
+
+/**
+ * @}
+ */
+
+/** I2CM_18XX_43XX_STATUS_TYPES I2C master transfer status types
+ * @{
+ */
+
+#define I2CM_STATUS_OK              0x00		/*!< Requested Request was executed successfully. */
+#define I2CM_STATUS_ERROR           0x01		/*!< Unknown error condition. */
+#define I2CM_STATUS_NAK             0x02		/*!< No acknowledgement received from slave. */
+#define I2CM_STATUS_BUS_ERROR       0x03		/*!< I2C bus error */
+#define I2CM_STATUS_SLAVE_NAK       0x04		/*!< No device responded for given slave address during SLA+W or SLA+R */
+#define I2CM_STATUS_ARBLOST         0x05		/*!< Arbitration lost. */
+#define I2CM_STATUS_BUSY            0xFF		/*!< I2C transmitter is busy. */
+
+/**
+ * @}
+ */
+
+/**
+ * @brief Master transfer data structure definitions
+ */
+typedef struct {
+	uint8_t slaveAddr;		/*!< 7-bit I2C Slave address */
+	uint8_t options;		/*!< Options for transfer*/
+	uint16_t status;		/*!< Status of the current I2C transfer */
+	uint16_t txSz;			/*!< Number of bytes in transmit array,
+							   if 0 only receive transfer will be carried on */
+	uint16_t rxSz;			/*!< Number of bytes to received,
+							   if 0 only transmission we be carried on */
+	const uint8_t *txBuff;	/*!< Pointer to array of bytes to be transmitted */
+	uint8_t *rxBuff;		/*!< Pointer memory where bytes received from I2C be stored */
+} I2CM_XFER_T;
+
+/**
+ * @brief	Initialize I2C Interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function enables the I2C clock.
+ */
+void Chip_I2CM_Init(LPC_I2C_T *pI2C);
+
+/**
+ * @brief	Shutdown I2C Interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function disables the I2C clock.
+ */
+void Chip_I2CM_DeInit(LPC_I2C_T *pI2C);
+
+/**
+ * @brief	Sets HIGH and LOW duty cycle registers
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	sclH	: Number of I2C_PCLK cycles for the SCL HIGH time.
+ * @param	sclL	: Number of I2C_PCLK cycles for the SCL LOW time.
+ * @return	Nothing
+ * @note	The frequency is determined by the following formula (I2C_PCLK
+ *          is the frequency of the peripheral I2C clock): <br>
+ *              I2C_bitFrequency = (I2C_PCLK)/(sclH + sclL);
+ */
+static INLINE void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL)
+{
+	pI2C->SCLH = (uint32_t) sclH;
+	pI2C->SCLL = (uint32_t) sclL;
+}
+
+/**
+ * @brief	Set up bus speed for LPC_I2C controller
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	busSpeed	: I2C bus clock rate
+ * @return	Nothing
+ * @note	Per I2C specification the busSpeed should be
+ *          @li 100000 for Standard mode
+ *          @li 400000 for Fast mode
+ *          @li 1000000 for Fast mode plus
+ *          IOCON registers corresponding to I2C pads should be updated
+ *          according to the bus mode.
+ */
+void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed);
+
+/**
+ * @brief	Transmit START or Repeat-START signal on I2C bus
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the controller to transmit START condition when
+ *          the bus becomes free.
+ */
+static INLINE void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
+{
+	pI2C->CONSET = I2C_CON_I2EN | I2C_CON_STA;
+}
+
+/**
+ * @brief	Reset I2C controller state
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function clears all control/status flags.
+ */
+static INLINE void Chip_I2CM_ResetControl(LPC_I2C_T *pI2C)
+{
+	/* Reset STA, AA and SI. Stop flag should not be cleared as it is a reserved bit */
+	pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA | I2C_CON_AA;
+
+}
+
+/**
+ * @brief	Transmit a single data byte through the I2C peripheral
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	data	: Byte to transmit
+ * @return	Nothing
+ * @note	This function attempts to place a byte into the UART transmit
+ *			FIFO or transmit hold register regard regardless of UART state
+ *
+ */
+static INLINE void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
+{
+	pI2C->DAT = (uint32_t) data;
+}
+
+/**
+ * @brief	Read a single byte data from the I2C peripheral
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	A single byte of data read
+ * @note	This function reads a byte from the I2C receive hold register
+ *			regardless of I2C state. The I2C status should be read first prior
+ *			to using this function.
+ */
+static INLINE uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
+{
+	return (uint8_t) (pI2C->DAT & I2C_I2DAT_BITMASK);
+}
+
+/**
+ * @brief	Generate NACK after receiving next byte
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the controller to NACK after receiving next
+ *          byte from slave transmitter. Used before receiving last byte.
+ */
+static INLINE void Chip_I2CM_NackNextByte(LPC_I2C_T *pI2C)
+{
+	pI2C->CONCLR = I2C_CON_AA;
+}
+
+/**
+ * @brief	Transmit STOP signal on I2C bus
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the controller to transmit STOP condition.
+ */
+static INLINE void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
+{
+	pI2C->CONSET = I2C_CON_STO;
+}
+
+/**
+ * @brief	Force start I2C transmit
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function forces I2C state machine to start transmitting.
+ *			If an uncontrolled source generates a superfluous START or masks
+ *          a STOP condition, then the I2C-bus stays busy indefinitely. If
+ *          the STA flag is set and bus access is not obtained within a
+ *          reasonable amount of time, then a forced access to the I2C-bus is
+ *          possible. This is achieved by setting the STO flag while the STA
+ *          flag is still set. No STOP condition is transmitted.
+ */
+static INLINE void Chip_I2CM_ForceStart(LPC_I2C_T *pI2C)
+{
+	/* check if we are pending on start */
+	if (pI2C->CONSET & I2C_CON_STA) {
+		pI2C->CONSET = I2C_CON_STO;
+	}
+	else {
+		Chip_I2CM_SendStart(pI2C);
+	}
+}
+
+/**
+ * @brief	Transmit STOP+START signal on I2C bus
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the controller to transmit STOP condition
+ *          followed by a START condition.
+ */
+static INLINE void Chip_I2CM_SendStartAfterStop(LPC_I2C_T *pI2C)
+{
+	pI2C->CONSET = I2C_CON_STO | I2C_CON_STA;
+}
+
+/**
+ * @brief	Check if I2C controller state changed
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns 0 if state didn't change
+ * @note
+ */
+static INLINE uint32_t Chip_I2CM_StateChanged(LPC_I2C_T *pI2C)
+{
+	return pI2C->CONSET & I2C_CON_SI;
+}
+
+/**
+ * @brief	Clear state change interrupt flag
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note
+ */
+static INLINE void Chip_I2CM_ClearSI(LPC_I2C_T *pI2C)
+{
+	/* Stop flag should not be cleared as it is a reserved bit */
+	pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA;
+}
+
+/**
+ * @brief	Check if I2C bus is free per our controller
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns 0 if busy else a non-zero value.
+ * @note	I2C controller clears STO bit when it sees STOP
+ *          condition after a START condition on the bus.
+ */
+static INLINE uint32_t Chip_I2CM_BusFree(LPC_I2C_T *pI2C)
+{
+	return !(pI2C->CONSET & I2C_CON_STO);
+}
+
+/**
+ * @brief	Get current state of the I2C controller
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns 0 if busy else a non-zero value.
+ * @note	I2C controller clears STO bit when it sees STOP
+ *          condition after a START condition on the bus.
+ */
+static INLINE uint32_t Chip_I2CM_GetCurState(LPC_I2C_T *pI2C)
+{
+	return pI2C->STAT & I2C_STAT_CODE_BITMASK;
+}
+
+/**
+ * @brief	Disable I2C interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note
+ */
+static INLINE void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
+{
+	pI2C->CONCLR = I2C_CON_I2EN;
+}
+
+/**
+ * @brief	Transfer state change handler handler
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
+ * @return Returns non-zero value on completion of transfer. The @a status
+ *         member of @a xfer structure contains the current status of the
+ *         transfer at the end of the call.
+ * @note
+ * The parameter @a xfer should be same as the one passed to Chip_I2CM_Xfer()
+ * routine.
+ */
+uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief	Transmit and Receive data in master mode
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
+ * @return Nothing.
+ * @note
+ * The parameter @a xfer should have its member @a slaveAddr initialized
+ * to the 7-Bit slave address to which the master will do the xfer, Bit0
+ * to bit6 should have the address and Bit8 is ignored. During the transfer
+ * no code (like event handler) must change the content of the memory
+ * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
+ * initialized to the memory from which the I2C must pick the data to be
+ * transferred to slave and the number of bytes to send respectively, similarly
+ * @a rxBuff and @a rxSz must have pointer to memory where data received
+ * from slave be stored and the number of data to get from slave respectively.
+ * Following types of transfers are possible:
+ * - Write-only transfer: When @a rxSz member of @a xfer is set to 0.
+ *
+ *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A] P
+ *
+ *      - If I2CM_XFER_OPTION_IGNORE_NACK is set in @a options member
+ *
+ *          S Addr Wr [A] txBuff0 [A or NA] ... txBuffN [A or NA] P
+ *
+ * - Read-only transfer: When @a txSz member of @a xfer is set to 0.
+ *
+ *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
+ *
+ *      - If I2CM_XFER_OPTION_LAST_RX_ACK is set in @a options member
+ *
+ *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] A P
+ *
+ * - Read-Write transfer: When @a rxSz and @ txSz members of @a xfer are non-zero.
+ *
+ *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A]
+ *              S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
+ *
+ */
+void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief	Transmit and Receive data in master mode
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
+ * @return Returns non-zero value on successful completion of transfer.
+ * @note
+ * This function operates same as Chip_I2CM_Xfer(), but is a blocking call.
+ */
+uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief	Write given buffer of data to I2C interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	buff	: Pointer to buffer to be transmitted
+ * @param	len     : Length of the buffer
+ * @return	Returns number of bytes written.
+ * @note	This function is a blocking call. The function generates
+ *          START/repeat-START condition on bus and starts transmitting
+ *          data until transfer finishes or a NACK is received. No
+ *          STOP condition is transmitted on the bus.
+ *
+ *          S Data0 [A] Data1 [A] ... DataN [A]
+ */
+uint32_t Chip_I2CM_Write(LPC_I2C_T *pI2C, const uint8_t *buff, uint32_t len);
+
+/**
+ * @brief	Read data from I2C slave to given buffer
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	buff	:   Pointer to buffer for data received from I2C slave
+ * @param	len     : Length of the buffer
+ * @return	Returns number of bytes read.
+ * @note	This function is a blocking call. The function generates
+ *          START/repeat-START condition on bus and starts reading
+ *          data until requested number of bytes are read. No
+ *          STOP condition is transmitted on the bus.
+ *
+ *          S [Data0] A [Data1] A ... [DataN] A
+ */
+uint32_t Chip_I2CM_Read(LPC_I2C_T *pI2C, uint8_t *buff, uint32_t len);
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2s_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/i2s_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/i2s_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/i2s_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,566 @@
+/*
+ * @brief LPC18xx/43xx I2S driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2S_18XX_43XX_H_
+#define __I2S_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2S_18XX_43XX CHIP: LPC18xx/43xx I2S driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief I2S DMA request channel define
+ */
+typedef enum {
+	I2S_DMA_REQUEST_CHANNEL_1,	/*!< DMA request channel 1 */
+	I2S_DMA_REQUEST_CHANNEL_2,	/*!< DMA request channel 2 */
+	I2S_DMA_REQUEST_CHANNEL_NUM,/*!< The number of DMA request channels */
+} I2S_DMA_CHANNEL_T;
+
+/**
+ * @brief I2S register block structure
+ */
+typedef struct {				/*!< I2S Structure */
+	__IO uint32_t DAO;			/*!< I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel */
+	__IO uint32_t DAI;			/*!< I2S Digital Audio Input Register. Contains control bits for the I2S receive channel */
+	__O uint32_t TXFIFO;		/*!< I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO */
+	__I uint32_t RXFIFO;		/*!< I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO */
+	__I uint32_t STATE;			/*!< I2S Status Feedback Register. Contains status information about the I2S interface */
+	__IO uint32_t DMA[I2S_DMA_REQUEST_CHANNEL_NUM];	/*!< I2S DMA Configuration Registers. Contains control information for DMA request channels */
+	__IO uint32_t IRQ;			/*!< I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated */
+	__IO uint32_t TXRATE;		/*!< I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK */
+	__IO uint32_t RXRATE;		/*!< I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK */
+	__IO uint32_t TXBITRATE;	/*!< I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock */
+	__IO uint32_t RXBITRATE;	/*!< I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock */
+	__IO uint32_t TXMODE;		/*!< I2S Transmit mode control */
+	__IO uint32_t RXMODE;		/*!< I2S Receive mode control */
+} LPC_I2S_T;
+
+/*
+ * @brief I2S configuration parameter defines
+ */
+/* I2S Wordwidth bit */
+#define I2S_WORDWIDTH_8     (0UL << 0)	/*!< 8 bit Word */
+#define I2S_WORDWIDTH_16    (1UL << 0)	/*!< 16 bit word */
+#define I2S_WORDWIDTH_32    (3UL << 0)	/*!< 32 bit word */
+
+/* I2S Channel bit */
+#define I2S_STEREO          (0UL << 2)	/*!< Stereo audio */
+#define I2S_MONO            (1UL << 2)	/*!< Mono audio */
+
+/* I2S Master/Slave mode bit */
+#define I2S_MASTER_MODE     (0UL << 5)	/*!< I2S in master mode */
+#define I2S_SLAVE_MODE      (1UL << 5)	/*!< I2S in slave mode */
+
+/* I2S Stop bit */
+#define I2S_STOP_ENABLE     (0UL << 3)	/*!< I2S stop enable mask */
+#define I2S_STOP_DISABLE    (1UL << 3)	/*!< I2S stop disable mask */
+
+/* I2S Reset bit */
+#define I2S_RESET_ENABLE    (1UL << 4)	/*!< I2S reset enable mask */
+#define I2S_RESET_DISABLE   (0UL << 4)	/*!< I2S reset disable mask */
+
+/* I2S Mute bit */
+#define I2S_MUTE_ENABLE     (1UL << 15)	/*!< I2S mute enable mask */
+#define I2S_MUTE_DISABLE    (0UL << 15)	/*!< I2S mute disbale mask */
+
+/*
+ * @brief Macro defines for DAO-Digital Audio Output register
+ */
+/* I2S wordwide - the number of bytes in data*/
+#define I2S_DAO_WORDWIDTH_8     ((uint32_t) (0))	/*!< DAO 8 bit	*/
+#define I2S_DAO_WORDWIDTH_16    ((uint32_t) (1))	/*!< DAO 16 bit	*/
+#define I2S_DAO_WORDWIDTH_32    ((uint32_t) (3))	/*!< DAO 32 bit	*/
+#define I2S_DAO_WORDWIDTH_MASK  ((uint32_t) (3))
+
+/* I2S control mono or stereo format */
+#define I2S_DAO_MONO            ((uint32_t) (1 << 2))	/*!< DAO mono audio mask */
+
+/* I2S control stop mode */
+#define I2S_DAO_STOP            ((uint32_t) (1 << 3))	/*!< DAO stop mask */
+
+/* I2S control reset mode */
+#define I2S_DAO_RESET           ((uint32_t) (1 << 4))	/*!< DAO reset mask */
+
+/* I2S control master/slave mode */
+#define I2S_DAO_SLAVE           ((uint32_t) (1 << 5))	/*!< DAO slave mode mask */
+
+/* I2S word select half period minus one */
+#define I2S_DAO_WS_HALFPERIOD(n)    ((uint32_t) (((n) & 0x1FF) << 6))	/*!< DAO Word select set macro */
+#define I2S_DAO_WS_HALFPERIOD_MASK  ((uint32_t) ((0x1FF) << 6))		/*!< DAO Word select mask */
+
+/* I2S control mute mode */
+#define I2S_DAO_MUTE            ((uint32_t) (1 << 15))	/*!< DAO mute mask */
+
+/*
+ * @brief Macro defines for DAI-Digital Audio Input register
+ */
+/* I2S wordwide - the number of bytes in data*/
+#define I2S_DAI_WORDWIDTH_8     ((uint32_t) (0))	/*!< DAI 8 bit	*/
+#define I2S_DAI_WORDWIDTH_16    ((uint32_t) (1))	/*!< DAI 16 bit	*/
+#define I2S_DAI_WORDWIDTH_32    ((uint32_t) (3))	/*!< DAI 32 bit	*/
+#define I2S_DAI_WORDWIDTH_MASK  ((uint32_t) (3))	/*!< DAI word wide mask */
+
+/* I2S control mono or stereo format */
+#define I2S_DAI_MONO            ((uint32_t) (1 << 2))	/*!< DAI mono mode mask */
+
+/* I2S control stop mode */
+#define I2S_DAI_STOP            ((uint32_t) (1 << 3))	/*!< DAI stop bit mask */
+
+/* I2S control reset mode */
+#define I2S_DAI_RESET           ((uint32_t) (1 << 4))	/*!< DAI reset bit mask */
+
+/* I2S control master/slave mode */
+#define I2S_DAI_SLAVE           ((uint32_t) (1 << 5))	/*!< DAI slave mode mask */
+
+/* I2S word select half period minus one (9 bits)*/
+#define I2S_DAI_WS_HALFPERIOD(n)    ((uint32_t) (((n) & 0x1FF) << 6))	/*!< DAI Word select set macro */
+#define I2S_DAI_WS_HALFPERIOD_MASK  ((uint32_t) ((0x1FF) << 6))		/*!< DAI Word select mask */
+
+/*
+ * @brief Macro defines for STAT register (Status Feedback register)
+ */
+#define I2S_STATE_IRQ       ((uint32_t) (1))/*!< I2S Status Receive or Transmit Interrupt */
+#define I2S_STATE_DMA1      ((uint32_t) (1 << 1))	/*!< I2S Status Receive or Transmit DMA1 */
+#define I2S_STATE_DMA2      ((uint32_t) (1 << 2))	/*!< I2S Status Receive or Transmit DMA2 */
+#define I2S_STATE_RX_LEVEL(n)   ((uint32_t) ((n & 1F) << 8))/*!< I2S Status Current level of the Receive FIFO (5 bits)*/
+#define I2S_STATE_TX_LEVEL(n)   ((uint32_t) ((n & 1F) << 16))	/*!< I2S Status Current level of the Transmit FIFO (5 bits)*/
+
+/*
+ * @brief Macro defines for DMA1 register (DMA1 Configuration register)
+ */
+#define I2S_DMA1_RX_ENABLE      ((uint32_t) (1))/*!< I2S control DMA1 for I2S receive */
+#define I2S_DMA1_TX_ENABLE      ((uint32_t) (1 << 1))	/*!< I2S control DMA1 for I2S transmit */
+#define I2S_DMA1_RX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 8))	/*!< I2S set FIFO level that trigger a receive DMA request on DMA1 */
+#define I2S_DMA1_TX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 16))	/*!< I2S set FIFO level that trigger a transmit DMA request on DMA1 */
+
+/*
+ * @brief Macro defines for DMA2 register (DMA2 Configuration register)
+ */
+#define I2S_DMA2_RX_ENABLE      ((uint32_t) (1))/*!< I2S control DMA2 for I2S receive */
+#define I2S_DMA2_TX_ENABLE      ((uint32_t) (1 << 1))	/*!< I2S control DMA1 for I2S transmit */
+#define I2S_DMA2_RX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 8))	/*!< I2S set FIFO level that trigger a receive DMA request on DMA1 */
+#define I2S_DMA2_TX_DEPTH(n)    ((uint32_t) ((n & 0x1F) << 16))	/*!< I2S set FIFO level that trigger a transmit DMA request on DMA1 */
+
+/*
+ * @brief Macro defines for IRQ register (Interrupt Request Control register)
+ */
+
+#define I2S_IRQ_RX_ENABLE       ((uint32_t) (1))/*!< I2S control I2S receive interrupt */
+#define I2S_IRQ_TX_ENABLE       ((uint32_t) (1 << 1))	/*!< I2S control I2S transmit interrupt */
+#define I2S_IRQ_RX_DEPTH(n)     ((uint32_t) ((n & 0x0F) << 8))	/*!< I2S set the FIFO level on which to create an irq request */
+#define I2S_IRQ_RX_DEPTH_MASK   ((uint32_t) ((0x0F) << 8))
+#define I2S_IRQ_TX_DEPTH(n)     ((uint32_t) ((n & 0x0F) << 16))	/*!< I2S set the FIFO level on which to create an irq request */
+#define I2S_IRQ_TX_DEPTH_MASK   ((uint32_t) ((0x0F) << 16))
+
+/*
+ * @brief Macro defines for TXRATE/RXRATE register (Transmit/Receive Clock Rate register)
+ */
+#define I2S_TXRATE_Y_DIVIDER(n) ((uint32_t) (n & 0xFF))	/*!< I2S Transmit MCLK rate denominator */
+#define I2S_TXRATE_X_DIVIDER(n) ((uint32_t) ((n & 0xFF) << 8))	/*!< I2S Transmit MCLK rate denominator */
+#define I2S_RXRATE_Y_DIVIDER(n) ((uint32_t) (n & 0xFF))	/*!< I2S Receive MCLK rate denominator */
+#define I2S_RXRATE_X_DIVIDER(n) ((uint32_t) ((n & 0xFF) << 8))	/*!< I2S Receive MCLK rate denominator */
+
+/*
+ * @brief Macro defines for TXBITRATE & RXBITRATE register (Transmit/Receive Bit Rate register)
+ */
+#define I2S_TXBITRATE(n)    ((uint32_t) (n & 0x3F))
+#define I2S_RXBITRATE(n)    ((uint32_t) (n & 0x3F))
+
+/*
+ * @brief Macro defines for TXMODE/RXMODE register (Transmit/Receive Mode Control register)
+ */
+#define I2S_TXMODE_CLKSEL(n)    ((uint32_t) (n & 0x03))	/*!< I2S Transmit select clock source (2 bits)*/
+#define I2S_TXMODE_4PIN_ENABLE  ((uint32_t) (1 << 2))	/*!< I2S Transmit control 4-pin mode */
+#define I2S_TXMODE_MCENA        ((uint32_t) (1 << 3))	/*!< I2S Transmit control the TX_MCLK output */
+#define I2S_RXMODE_CLKSEL(n)    ((uint32_t) (n & 0x03))	/*!< I2S Receive select clock source */
+#define I2S_RXMODE_4PIN_ENABLE  ((uint32_t) (1 << 2))	/*!< I2S Receive control 4-pin mode */
+#define I2S_RXMODE_MCENA        ((uint32_t) (1 << 3))	/*!< I2S Receive control the TX_MCLK output */
+
+/**
+ * @brief I2S Audio Format Structure
+ */
+typedef struct {
+	uint32_t SampleRate;	/*!< Sample Rate */
+	uint8_t ChannelNumber;	/*!< Channel Number - 1 is mono, 2 is stereo */
+	uint8_t WordWidth;		/*!< Word Width - 8, 16 or 32 bits */
+} I2S_AUDIO_FORMAT_T;
+
+/**
+ * @brief	Initialize for I2S
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_I2S_Init(LPC_I2S_T *pI2S);
+
+/**
+ * @brief	Shutdown I2S
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ * @note	Reset all relative registers (DMA, transmit/receive control, interrupt) to default value
+ */
+void Chip_I2S_DeInit(LPC_I2S_T *pI2S);
+
+/**
+ * @brief	Send a 32-bit data to TXFIFO for transmition
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @param	data	: Data to be transmited
+ * @return	Nothing
+ * @note	The function writes to TXFIFO without checking any condition.
+ */
+STATIC INLINE void Chip_I2S_Send(LPC_I2S_T *pI2S, uint32_t data)
+{
+	pI2S->TXFIFO = data;
+}
+
+/**
+ * @brief	Get received data from RXFIFO
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Data received in RXFIFO
+ * @note	The function reads from RXFIFO without checking any condition.
+ */
+STATIC INLINE uint32_t Chip_I2S_Receive(LPC_I2S_T *pI2S)
+{
+	return pI2S->RXFIFO;
+}
+
+/**
+ * @brief	Start transmit data
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_I2S_TxStart(LPC_I2S_T *pI2S)
+{
+	pI2S->DAO &= ~(I2S_DAO_RESET | I2S_DAO_STOP | I2S_DAO_MUTE);
+}
+
+/**
+ * @brief	Start receive data
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_I2S_RxStart(LPC_I2S_T *pI2S)
+{
+	pI2S->DAI &= ~(I2S_DAI_RESET | I2S_DAI_STOP);
+}
+
+/**
+ * @brief	Disables accesses on FIFOs, places the transmit channel in mute mode
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_I2S_TxPause(LPC_I2S_T *pI2S)
+{
+	pI2S->DAO |= I2S_DAO_STOP;
+}
+
+/**
+ * @brief	Disables accesses on FIFOs, places the transmit channel in mute mode
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_I2S_RxPause(LPC_I2S_T *pI2S)
+{
+	pI2S->DAI |= I2S_DAI_STOP;
+}
+
+/**
+ * @brief	Mute the Transmit channel
+ * @param	pI2S		: The base of I2S peripheral on the chip
+ * @return	Nothing
+ * @note	The data output from I2S transmit channel is always zeroes
+ */
+STATIC INLINE void Chip_I2S_EnableMute(LPC_I2S_T *pI2S)
+{
+	pI2S->DAO |= I2S_DAO_MUTE;
+}
+
+/**
+ * @brief	Un-Mute the I2S channel
+ * @param	pI2S		: The base of I2S peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_I2S_DisableMute(LPC_I2S_T *pI2S)
+{
+	pI2S->DAO &= ~I2S_DAO_MUTE;
+}
+
+/**
+ * @brief	Stop I2S asynchronously
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ * @note	Pause, resets the transmit channel and FIFO asynchronously
+ */
+STATIC INLINE void Chip_I2S_TxStop(LPC_I2S_T *pI2S)
+{
+	pI2S->DAO &= ~I2S_DAO_MUTE;
+	pI2S->DAO |= I2S_DAO_STOP | I2S_DAO_RESET;
+}
+
+/**
+ * @brief	Stop I2S asynchronously
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ * @note	Pause, resets the transmit channel and FIFO asynchronously
+ */
+STATIC INLINE void Chip_I2S_RxStop(LPC_I2S_T *pI2S)
+{
+	pI2S->DAI |= I2S_DAI_STOP | I2S_DAI_RESET;
+}
+
+/**
+ * @brief	Sets the I2S receive channel in slave mode
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ * @note	4 pin mode must be enabled on appropriate channel.
+ * Must be called after each Chip_I2S_TxModeConfig call if
+ * slave mode is needed.
+ */
+STATIC INLINE void Chip_I2S_RxSlave(LPC_I2S_T *pI2S)
+{
+	pI2S->DAI |= I2S_SLAVE_MODE;
+}
+
+/**
+ * @brief	Sets the I2S transmit channel in slave mode
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Nothing
+ * @note	4 pin mode must be enabled on appropriate channel.
+ * Must be called after each Chip_I2S_TxModeConfig call if
+ * slave mode is needed.
+ */
+STATIC INLINE void Chip_I2S_TxSlave(LPC_I2S_T *pI2S)
+{
+	pI2S->DAO |= I2S_SLAVE_MODE;
+}
+
+/**
+ * @brief	Set the I2S transmit mode
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @param	clksel	: Clock source selection for the receive bit clock divider
+ * @param	fpin	: Receive 4-pin mode selection
+ * @param	mcena	: Enable for the RX_MCLK output
+ * @return	Nothing
+ * @note	In addition to master and slave modes, which are independently configurable for
+ * the transmitter and the receiver, several different clock sources are possible,
+ * including variations that share the clock and/or WS between the transmitter and
+ * receiver. It also allows using I2S with fewer pins, typically four.
+ */
+STATIC INLINE void Chip_I2S_TxModeConfig(LPC_I2S_T *pI2S,
+										 uint32_t clksel,
+										 uint32_t fpin,
+										 uint32_t mcena)
+{
+	pI2S->TXMODE = clksel | fpin | mcena;
+}
+
+/**
+ * @brief	Set the I2S receive mode
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @param	clksel	: Clock source selection for the receive bit clock divider
+ * @param	fpin	: Receive 4-pin mode selection
+ * @param	mcena	: Enable for the RX_MCLK output
+ * @return	Nothing
+ * @note	In addition to master and slave modes, which are independently configurable for
+ * the transmitter and the receiver, several different clock sources are possible,
+ * including variations that share the clock and/or WS between the transmitter and
+ * receiver. It also allows using I2S with fewer pins, typically four.
+ */
+STATIC INLINE void Chip_I2S_RxModeConfig(LPC_I2S_T *pI2S,
+										 uint32_t clksel,
+										 uint32_t fpin,
+										 uint32_t mcena)
+{
+	pI2S->RXMODE = clksel | fpin | mcena;
+}
+
+/**
+ * @brief	Get the current level of the Transmit FIFO
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Current level of the Transmit FIFO
+ */
+STATIC INLINE uint8_t Chip_I2S_GetTxLevel(LPC_I2S_T *pI2S)
+{
+	return (pI2S->STATE >> 16) & 0xF;
+}
+
+/**
+ * @brief	Get the current level of the Receive FIFO
+ * @param	pI2S	: The base of I2S peripheral on the chip
+ * @return	Current level of the Receive FIFO
+ */
+STATIC INLINE uint8_t Chip_I2S_GetRxLevel(LPC_I2S_T *pI2S)
+{
+	return (pI2S->STATE >> 8) & 0xF;
+}
+
+/**
+ * @brief	Set the clock frequency for I2S interface
+ * @param	pI2S			: The base of I2S peripheral on the chip
+ * @param	div	: Clock divider. This value plus one is used to divide MCLK to produce the clock frequency for I2S interface
+ * @return	Nothing
+ * @note	The value depends on the audio sample rate desired and the data size and format(stereo/mono) used.
+ * For example, a 48 kHz sample rate for 16-bit stereo data requires a bit rate of 48 000 x 16 x 2 = 1.536 MHz. So the mclk_divider should be MCLK/1.536 MHz
+ */
+STATIC INLINE void Chip_I2S_SetTxBitRate(LPC_I2S_T *pI2S, uint32_t div)
+{
+	pI2S->TXBITRATE = div;
+}
+
+/**
+ * @brief	Set the clock frequency for I2S interface
+ * @param	pI2S			: The base of I2S peripheral on the chip
+ * @param	div	: Clock divider. This value plus one is used to divide MCLK to produce the clock frequency for I2S interface
+ * @return	Nothing
+ * @note	The value depends on the audio sample rate desired and the data size and format(stereo/mono) used.
+ * For example, a 48 kHz sample rate for 16-bit stereo data requires a bit rate of 48 000 x 16 x 2 = 1.536 MHz. So the mclk_divider should be MCLK/1.536 MHz
+ */
+STATIC INLINE void Chip_I2S_SetRxBitRate(LPC_I2S_T *pI2S, uint32_t div)
+{
+	pI2S->RXBITRATE = div;
+}
+
+/**
+ * @brief	Set the MCLK rate by using a fractional rate generator, dividing down the frequency of PCLK
+ * @param	pI2S		: The base of I2S peripheral on the chip
+ * @param	xDiv	: I2S transmit MCLK rate numerator
+ * @param	yDiv	: I2S transmit MCLK rate denominator
+ * @return	Nothing
+ * @note	Values of the numerator (X) and the denominator (Y) must be chosen to
+ * produce a frequency twice that desired for the transmitter MCLK, which
+ * must be an integer multiple of the transmitter bit clock rate.
+ * The equation for the fractional rate generator is:
+ * MCLK = PCLK * (X/Y) /2
+ * Note: If the value of X or Y is 0, then no clock is generated. Also, the value of Y must be
+ * greater than or equal to X.
+ */
+STATIC INLINE void Chip_I2S_SetTxXYDivider(LPC_I2S_T *pI2S, uint8_t xDiv, uint8_t yDiv)
+{
+	pI2S->TXRATE = yDiv | (xDiv << 8);
+}
+
+/**
+ * @brief	Set the MCLK rate by using a fractional rate generator, dividing down the frequency of PCLK
+ * @param	pI2S		: The base of I2S peripheral on the chip
+ * @param	xDiv	: I2S transmit MCLK rate numerator
+ * @param	yDiv	: I2S transmit MCLK rate denominator
+ * @return	Nothing
+ * @note	Values of the numerator (X) and the denominator (Y) must be chosen to
+ * produce a frequency twice that desired for the transmitter MCLK, which
+ * must be an integer multiple of the transmitter bit clock rate.
+ * The equation for the fractional rate generator is:
+ * MCLK = PCLK * (X/Y) /2
+ * Note: If the value of X or Y is 0, then no clock is generated. Also, the value of Y must be
+ * greater than or equal to X.
+ */
+STATIC INLINE void Chip_I2S_SetRxXYDivider(LPC_I2S_T *pI2S, uint8_t xDiv, uint8_t yDiv)
+{
+	pI2S->RXRATE = yDiv | (xDiv << 8);
+}
+
+/**
+ * @brief   Configure I2S for Audio Format input
+ * @param	pI2S			: The base I2S peripheral on the chip
+ * @param	format	: Audio Format
+ * @return	SUCCESS or ERROR
+ */
+Status Chip_I2S_TxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format);
+
+/**
+ * @brief   Configure I2S for Audio Format input
+ * @param	pI2S			: The base I2S peripheral on the chip
+ * @param	format	: Audio Format
+ * @return	SUCCESS or ERROR
+ */
+Status Chip_I2S_RxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format);
+
+/**
+ * @brief   Enable/Disable Interrupt with a specific FIFO depth
+ * @param	pI2S			: The base I2S peripheral on the chip
+ * @param	newState		: ENABLE or DISABLE interrupt
+ * @param	depth		: FIFO level creating an irq request
+ * @return	Nothing
+ */
+void Chip_I2S_Int_TxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth);
+
+/**
+ * @brief   Enable/Disable Interrupt with a specific FIFO depth
+ * @param	pI2S			: The base I2S peripheral on the chip
+ * @param	newState		: ENABLE or DISABLE interrupt
+ * @param	depth		: FIFO level creating an irq request
+ * @return	Nothing
+ */
+void Chip_I2S_Int_RxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth);
+
+/**
+ * @brief   Enable/Disable DMA with a specific FIFO depth
+ * @param	pI2S			: The base I2S peripheral on the chip
+ * @param	dmaNum			: Should be
+ *								- I2S_DMA_REQUEST_CHANNEL_1 : Using DMA1
+ *								- I2S_DMA_REQUEST_CHANNEL_2 : Using DMA2
+ * @param	newState		: ENABLE or DISABLE interrupt
+ * @param	depth		: FIFO level creating an irq request
+ * @return	Nothing
+ */
+void Chip_I2S_DMA_TxCmd(LPC_I2S_T *pI2S, I2S_DMA_CHANNEL_T dmaNum, FunctionalState newState, uint8_t depth);
+
+/**
+ * @brief   Enable/Disable DMA with a specific FIFO depth
+ * @param	pI2S			: The base I2S peripheral on the chip
+ * @param	dmaNum			: Should be
+ *								- I2S_DMA_REQUEST_CHANNEL_1 : Using DMA1
+ *								- I2S_DMA_REQUEST_CHANNEL_2 : Using DMA2
+ * @param	newState		: ENABLE or DISABLE interrupt
+ * @param	depth		: FIFO level creating an irq request
+ * @return	Nothing
+ */
+void Chip_I2S_DMA_RxCmd(LPC_I2S_T *pI2S, I2S_DMA_CHANNEL_T dmaNum, FunctionalState newState, uint8_t depth);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2S_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/iap_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/iap_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/iap_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/iap_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,217 @@
+/*
+ * @brief Common IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __IAP_H_
+#define __IAP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup IAP_18XX_43XX CHIP: LPC18xx/43xx Flash IAP driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/* IAP command definitions */
+#define IAP_PREWRRITE_CMD           50	/*!< Prepare sector for write operation command */
+#define IAP_WRISECTOR_CMD           51	/*!< Write Sector command */
+#define IAP_ERSSECTOR_CMD           52	/*!< Erase Sector command */
+#define IAP_BLANK_CHECK_SECTOR_CMD  53	/*!< Blank check sector */
+#define IAP_REPID_CMD               54	/*!< Read PartID command */
+#define IAP_READ_BOOT_CODE_CMD      55	/*!< Read Boot code version */
+#define IAP_COMPARE_CMD             56	/*!< Compare two RAM address locations */
+#define IAP_REINVOKE_ISP_CMD        57	/*!< Reinvoke ISP */
+#define IAP_READ_UID_CMD            58	/*!< Read UID */
+#define IAP_ERASE_PAGE_CMD          59	/*!< Erase page */
+#define IAP_SET_BOOT_FLASH          60	/*!< Set active boot flash bank */
+#define IAP_EEPROM_WRITE            61	/*!< EEPROM Write command */
+#define IAP_EEPROM_READ             62	/*!< EEPROM READ command */
+
+/* IAP response definitions */
+#define IAP_CMD_SUCCESS             0	/*!< Command is executed successfully */
+#define IAP_INVALID_COMMAND         1	/*!< Invalid command */
+#define IAP_SRC_ADDR_ERROR          2	/*!< Source address is not on word boundary */
+#define IAP_DST_ADDR_ERROR          3	/*!< Destination address is not on a correct boundary */
+#define IAP_SRC_ADDR_NOT_MAPPED     4	/*!< Source address is not mapped in the memory map */
+#define IAP_DST_ADDR_NOT_MAPPED     5	/*!< Destination address is not mapped in the memory map */
+#define IAP_COUNT_ERROR             6	/*!< Byte count is not multiple of 4 or is not a permitted value */
+#define IAP_INVALID_SECTOR          7	/*!< Sector number is invalid or end sector number is greater than start sector number */
+#define IAP_SECTOR_NOT_BLANK        8	/*!< Sector is not blank */
+#define IAP_SECTOR_NOT_PREPARED     9	/*!< Command to prepare sector for write operation was not executed */
+#define IAP_COMPARE_ERROR           10	/*!< Source and destination data not equal */
+#define IAP_BUSY                    11	/*!< Flash programming hardware interface is busy */
+#define IAP_PARAM_ERROR             12	/*!< nsufficient number of parameters or invalid parameter */
+#define IAP_ADDR_ERROR              13	/*!< Address is not on word boundary */
+#define IAP_ADDR_NOT_MAPPED         14	/*!< Address is not mapped in the memory map */
+#define IAP_CMD_LOCKED              15	/*!< Command is locked */
+#define IAP_INVALID_CODE            16	/*!< Unlock code is invalid */
+#define IAP_INVALID_BAUD_RATE       17	/*!< Invalid baud rate setting */
+#define IAP_INVALID_STOP_BIT        18	/*!< Invalid stop bit setting */
+#define IAP_CRP_ENABLED             19	/*!< Code read protection enabled */
+
+/* IAP_ENTRY API function type */
+typedef void (*IAP_ENTRY_T)(unsigned int[5], unsigned int[4]);
+
+/**
+ * @brief	Initialize IAP
+ * @return	Status code to indicate the command is executed successfully or not
+ */
+uint8_t Chip_IAP_Init(void);
+
+/**
+ * @brief	Prepare sector for write operation
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @param	bankNum		: Flash Bank number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	This command must be executed before executing "Copy RAM to flash"
+ *			or "Erase Sector" command.
+ *			The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector, uint8_t bankNum);
+
+/**
+ * @brief	Copy RAM to flash
+ * @param	dstAdd		: Destination flash address where data bytes are to be written
+ * @param	srcAdd		: Source flash address where data bytes are to be read
+ * @param	byteswrt	: Number of bytes to be written
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The addresses should be a 256 byte boundary and the number of bytes
+ *			should be 256 | 512 | 1024 | 4096
+ */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
+
+/**
+ * @brief	Erase sector
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @param	bankNum		: Flash Bank number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector, uint8_t bankNum);
+
+/**
+ * @brief Blank check a sector or multiples sector of on-chip flash memory
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @param	bankNum		: Flash Bank number
+ * @return	Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
+ * @note	The end sector must be greater than or equal to start sector number
+ */
+// FIXME - There are two return value (result[0] & result[1]
+// Result0:Offset of the first non blank word location if the Status Code is
+// SECTOR_NOT_BLANK.
+// Result1:Contents of non blank word location.
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector, uint8_t bankNum);
+
+/**
+ * @brief	Read part identification number
+ * @return	Part identification number
+ */
+uint32_t Chip_IAP_ReadPID(void);
+
+/**
+ * @brief	Read boot code version number
+ * @return	Boot code version number
+ */
+uint8_t Chip_IAP_ReadBootCode(void);
+
+/**
+ * @brief	Compare the memory contents at two locations
+ * @param	dstAdd		: Destination of the RAM address of data bytes to be compared
+ * @param	srcAdd		: Source of the RAM address of data bytes to be compared
+ * @param	bytescmp	: Number of bytes to be compared
+ * @return	Offset of the first mismatch of the status code is COMPARE_ERROR
+ * @note	The addresses should be a word boundary and number of bytes should be
+ *			a multiply of 4
+ */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
+
+/**
+ * @brief	IAP reinvoke ISP to invoke the bootloader in ISP mode
+ * @return	none
+ */
+uint8_t Chip_IAP_ReinvokeISP(void);
+
+/**
+ * @brief	Read the unique ID
+ * @param   uid[]    : Array of uint32_t with 4 elements to return the UID 
+ * @return	Status code to indicate the command is executed successfully or not
+ */
+uint32_t Chip_IAP_ReadUID(uint32_t uid[]);
+
+/**
+ * @brief	Erase a page or multiple papers of on-chip flash memory
+ * @param	strPage	: Start page number
+ * @param	endPage	: End page number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The page number must be greater than or equal to start page number
+ */
+// FIXME - There are four return value
+// Result0:The first 32-bit word (at the lowest address)
+// Result1:The second 32-bit word.
+// Result2:The third 32-bit word.
+// Result3:The fourth 32-bit word.
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
+
+/**
+ * @brief	Set active boot flash bank
+ * @param	bankNum	: Flash bank number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	Enable booting from the indicated flash unit by inserting a valid
+ *					signature and invalidating the other flash unit
+ */
+uint8_t Chip_IAP_SetBootFlashBank(uint8_t bankNum);
+
+/**
+ * @brief	Initialize the IAP command interface
+ * @return	IAP_CMD_SUCCESS on success
+ * @note	On parts with flash this API must be called before using IAP interface
+ */
+uint8_t Chip_IAP_init(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __IAP_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/iap.h ./libs/vendor_libs/lpc_chip_43xx/inc/iap.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/iap.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/iap.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,190 @@
+/*
+ * @brief Common IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __IAP_H_
+#define __IAP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup COMMON_IAP CHIP: Common Chip ISP/IAP commands and return codes
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/* IAP command definitions */
+#define IAP_PREWRRITE_CMD           50	/*!< Prepare sector for write operation command */
+#define IAP_WRISECTOR_CMD           51	/*!< Write Sector command */
+#define IAP_ERSSECTOR_CMD           52	/*!< Erase Sector command */
+#define IAP_BLANK_CHECK_SECTOR_CMD  53	/*!< Blank check sector */
+#define IAP_REPID_CMD               54	/*!< Read PartID command */
+#define IAP_READ_BOOT_CODE_CMD      55	/*!< Read Boot code version */
+#define IAP_COMPARE_CMD             56	/*!< Compare two RAM address locations */
+#define IAP_REINVOKE_ISP_CMD        57	/*!< Reinvoke ISP */
+#define IAP_READ_UID_CMD            58	/*!< Read UID */
+#define IAP_ERASE_PAGE_CMD          59	/*!< Erase page */
+#define IAP_EEPROM_WRITE            61	/*!< EEPROM Write command */
+#define IAP_EEPROM_READ             62	/*!< EEPROM READ command */
+
+/* IAP response definitions */
+#define IAP_CMD_SUCCESS             0	/*!< Command is executed successfully */
+#define IAP_INVALID_COMMAND         1	/*!< Invalid command */
+#define IAP_SRC_ADDR_ERROR          2	/*!< Source address is not on word boundary */
+#define IAP_DST_ADDR_ERROR          3	/*!< Destination address is not on a correct boundary */
+#define IAP_SRC_ADDR_NOT_MAPPED     4	/*!< Source address is not mapped in the memory map */
+#define IAP_DST_ADDR_NOT_MAPPED     5	/*!< Destination address is not mapped in the memory map */
+#define IAP_COUNT_ERROR             6	/*!< Byte count is not multiple of 4 or is not a permitted value */
+#define IAP_INVALID_SECTOR          7	/*!< Sector number is invalid or end sector number is greater than start sector number */
+#define IAP_SECTOR_NOT_BLANK        8	/*!< Sector is not blank */
+#define IAP_SECTOR_NOT_PREPARED     9	/*!< Command to prepare sector for write operation was not executed */
+#define IAP_COMPARE_ERROR           10	/*!< Source and destination data not equal */
+#define IAP_BUSY                    11	/*!< Flash programming hardware interface is busy */
+#define IAP_PARAM_ERROR             12	/*!< nsufficient number of parameters or invalid parameter */
+#define IAP_ADDR_ERROR              13	/*!< Address is not on word boundary */
+#define IAP_ADDR_NOT_MAPPED         14	/*!< Address is not mapped in the memory map */
+#define IAP_CMD_LOCKED              15	/*!< Command is locked */
+#define IAP_INVALID_CODE            16	/*!< Unlock code is invalid */
+#define IAP_INVALID_BAUD_RATE       17	/*!< Invalid baud rate setting */
+#define IAP_INVALID_STOP_BIT        18	/*!< Invalid stop bit setting */
+#define IAP_CRP_ENABLED             19	/*!< Code read protection enabled */
+
+/* IAP_ENTRY API function type */
+typedef void (*IAP_ENTRY_T)(unsigned int[], unsigned int[]);
+
+/**
+ * @brief	Prepare sector for write operation
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	This command must be executed before executing "Copy RAM to flash"
+ *			or "Erase Sector" command.
+ *			The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief	Copy RAM to flash
+ * @param	dstAdd		: Destination FLASH address where data bytes are to be written
+ * @param	srcAdd		: Source RAM address where data bytes are to be read
+ * @param	byteswrt	: Number of bytes to be written
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The addresses should be a 256 byte boundary and the number of bytes
+ *			should be 256 | 512 | 1024 | 4096
+ */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
+
+/**
+ * @brief	Erase sector
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief Blank check a sector or multiples sector of on-chip flash memory
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @return	Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
+ * @note	The end sector must be greater than or equal to start sector number
+ */
+// FIXME - There are two return value (result[0] & result[1]
+// Result0:Offset of the first non blank word location if the Status Code is
+// SECTOR_NOT_BLANK.
+// Result1:Contents of non blank word location.
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief	Read part identification number
+ * @return	Part identification number
+ */
+uint32_t Chip_IAP_ReadPID(void);
+
+/**
+ * @brief	Read boot code version number
+ * @return	Boot code version number
+ */
+uint32_t Chip_IAP_ReadBootCode(void);
+
+/**
+ * @brief	Compare the memory contents at two locations
+ * @param	dstAdd		: Destination of the RAM address of data bytes to be compared
+ * @param	srcAdd		: Source of the RAM address of data bytes to be compared
+ * @param	bytescmp	: Number of bytes to be compared
+ * @return	Offset of the first mismatch of the status code is COMPARE_ERROR
+ * @note	The addresses should be a word boundary and number of bytes should be
+ *			a multiply of 4
+ */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
+
+/**
+ * @brief	IAP reinvoke ISP to invoke the bootloader in ISP mode
+ * @return	none
+ */
+uint8_t Chip_IAP_ReinvokeISP(void);
+
+/**
+ * @brief	Read the unique ID
+ * @return	Status code to indicate the command is executed successfully or not
+ */
+uint32_t Chip_IAP_ReadUID(uint32_t* uid);
+
+/**
+ * @brief	Erase a page or multiple papers of on-chip flash memory
+ * @param	strPage	: Start page number
+ * @param	endPage	: End page number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The page number must be greater than or equal to start page number
+ */
+// FIXME - There are four return value
+// Result0:The first 32-bit word (at the lowest address)
+// Result1:The second 32-bit word.
+// Result2:The third 32-bit word.
+// Result3:The fourth 32-bit word.
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __IAP_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/lcd_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/lcd_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/lcd_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/lcd_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,389 @@
+/*
+ * @brief LPC18xx/43xx LCD chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LCD_18XX_43XX_H_
+#define __LCD_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup LCD_18XX_43XX CHIP: LPC18xx/43xx LCD driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief LCD Controller register block structure
+ */
+typedef struct {				/*!< LCD Structure          */
+	__IO uint32_t  TIMH;		/*!< Horizontal Timing Control register */
+	__IO uint32_t  TIMV;		/*!< Vertical Timing Control register */
+	__IO uint32_t  POL;			/*!< Clock and Signal Polarity Control register */
+	__IO uint32_t  LE;			/*!< Line End Control register */
+	__IO uint32_t  UPBASE;		/*!< Upper Panel Frame Base Address register */
+	__IO uint32_t  LPBASE;		/*!< Lower Panel Frame Base Address register */
+	__IO uint32_t  CTRL;		/*!< LCD Control register   */
+	__IO uint32_t  INTMSK;		/*!< Interrupt Mask register */
+	__I  uint32_t  INTRAW;		/*!< Raw Interrupt Status register */
+	__I  uint32_t  INTSTAT;		/*!< Masked Interrupt Status register */
+	__O  uint32_t  INTCLR;		/*!< Interrupt Clear register */
+	__I  uint32_t  UPCURR;		/*!< Upper Panel Current Address Value register */
+	__I  uint32_t  LPCURR;		/*!< Lower Panel Current Address Value register */
+	__I  uint32_t  RESERVED0[115];
+	__IO uint16_t PAL[256];		/*!< 256x16-bit Color Palette registers */
+	__I  uint32_t  RESERVED1[256];
+	__IO uint32_t CRSR_IMG[256];/*!< Cursor Image registers */
+	__IO uint32_t  CRSR_CTRL;	/*!< Cursor Control register */
+	__IO uint32_t  CRSR_CFG;	/*!< Cursor Configuration register */
+	__IO uint32_t  CRSR_PAL0;	/*!< Cursor Palette register 0 */
+	__IO uint32_t  CRSR_PAL1;	/*!< Cursor Palette register 1 */
+	__IO uint32_t  CRSR_XY;		/*!< Cursor XY Position register */
+	__IO uint32_t  CRSR_CLIP;	/*!< Cursor Clip Position register */
+	__I  uint32_t  RESERVED2[2];
+	__IO uint32_t  CRSR_INTMSK;	/*!< Cursor Interrupt Mask register */
+	__O  uint32_t  CRSR_INTCLR;	/*!< Cursor Interrupt Clear register */
+	__I  uint32_t  CRSR_INTRAW;	/*!< Cursor Raw Interrupt Status register */
+	__I  uint32_t  CRSR_INTSTAT;/*!< Cursor Masked Interrupt Status register */
+} LPC_LCD_T;
+
+/**
+ * @brief LCD Palette entry format
+ */
+typedef struct {
+	uint32_t Rl : 5;
+	uint32_t Gl : 5;
+	uint32_t Bl : 5;
+	uint32_t Il : 1;
+	uint32_t Ru : 5;
+	uint32_t Gu : 5;
+	uint32_t Bu : 5;
+	uint32_t Iu : 1;
+} LCD_PALETTE_ENTRY_T;
+
+/**
+ * @brief LCD Panel type
+ */
+typedef enum {
+	LCD_TFT = 0x02,		/*!< standard TFT */
+	LCD_MONO_4 = 0x01,	/*!< 4-bit STN mono */
+	LCD_MONO_8 = 0x05,	/*!< 8-bit STN mono */
+	LCD_CSTN = 0x00		/*!< color STN */
+} LCD_PANEL_OPT_T;
+
+/**
+ * @brief LCD Color Format
+ */
+typedef enum {
+	LCD_COLOR_FORMAT_RGB = 0,
+	LCD_COLOR_FORMAT_BGR
+} LCD_COLOR_FORMAT_OPT_T;
+
+/** LCD Interrupt control mask register bits */
+#define LCD_INTMSK_FUFIM   0x2	/*!< FIFO underflow interrupt enable */
+#define LCD_INTMSK_LNBUIM  0x4	/*!< LCD next base address update interrupt enable */
+#define LCD_INTMSK_VCOMPIM 0x8	/*!< Vertical compare interrupt enable */
+#define LCD_INTMSK_BERIM   0x10	/*!< AHB master error interrupt enable */
+
+#define CLCDC_LCDCTRL_ENABLE    _BIT(0)		/*!< LCD control enable bit */
+#define CLCDC_LCDCTRL_PWR       _BIT(11)	/*!< LCD control power enable bit */
+
+/**
+ * @brief A structure for LCD Configuration
+ */
+typedef struct {
+	uint8_t  HBP;	/*!< Horizontal back porch in clocks */
+	uint8_t  HFP;	/*!< Horizontal front porch in clocks */
+	uint8_t  HSW;	/*!< HSYNC pulse width in clocks */
+	uint16_t PPL;	/*!< Pixels per line */
+	uint8_t  VBP;	/*!< Vertical back porch in clocks */
+	uint8_t  VFP;	/*!< Vertical front porch in clocks */
+	uint8_t  VSW;	/*!< VSYNC pulse width in clocks */
+	uint16_t LPP;	/*!< Lines per panel */
+	uint8_t  IOE;	/*!< Invert output enable, 1 = invert */
+	uint8_t  IPC;	/*!< Invert panel clock, 1 = invert */
+	uint8_t  IHS;	/*!< Invert HSYNC, 1 = invert */
+	uint8_t  IVS;	/*!< Invert VSYNC, 1 = invert */
+	uint8_t  ACB;	/*!< AC bias frequency in clocks (not used) */
+	uint8_t  BPP;	/*!< Maximum bits per pixel the display supports */
+	LCD_PANEL_OPT_T  LCD;	/*!< LCD panel type */
+	LCD_COLOR_FORMAT_OPT_T  color_format;	/*!<BGR or RGB */
+	uint8_t  Dual;	/*!< Dual panel, 1 = dual panel display */
+} LCD_CONFIG_T;
+
+/**
+ * @brief LCD Cursor Size
+ */
+typedef enum {
+	LCD_CURSOR_32x32 = 0,
+	LCD_CURSOR_64x64
+} LCD_CURSOR_SIZE_OPT_T;
+
+/**
+ * @brief	Initialize the LCD controller
+ * @param	pLCD				: The base of LCD peripheral on the chip
+ * @param	LCD_ConfigStruct	: Pointer to LCD configuration
+ * @return  LCD_FUNC_OK is executed successfully or LCD_FUNC_ERR on error
+ */
+void Chip_LCD_Init(LPC_LCD_T *pLCD, LCD_CONFIG_T *LCD_ConfigStruct);
+
+/**
+ * @brief	Shutdown the LCD controller
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @return  Nothing
+ */
+void Chip_LCD_DeInit(LPC_LCD_T *pLCD);
+
+/**
+ * @brief	Power-on the LCD Panel (power pin)
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_PowerOn(LPC_LCD_T *pLCD)
+{
+	volatile int i;
+	pLCD->CTRL |= CLCDC_LCDCTRL_PWR;
+	for (i = 0; i < 1000000; i++) {}
+	pLCD->CTRL |= CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief	Power-off the LCD Panel (power pin)
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_PowerOff(LPC_LCD_T *pLCD)
+{
+	volatile int i;
+	pLCD->CTRL &= ~CLCDC_LCDCTRL_PWR;
+	for (i = 0; i < 1000000; i++) {}
+	pLCD->CTRL &= ~CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief	Enable/Disable the LCD Controller
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Enable(LPC_LCD_T *pLCD)
+{
+	pLCD->CTRL |= CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief	Enable/Disable the LCD Controller
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Disable(LPC_LCD_T *pLCD)
+{
+	pLCD->CTRL &= ~CLCDC_LCDCTRL_ENABLE;
+}
+
+/**
+ * @brief	Set LCD Upper Panel Frame Buffer for Single Panel or Upper Panel Frame
+ *			Buffer for Dual Panel
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	buffer	: address of buffer
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_SetUPFrameBuffer(LPC_LCD_T *pLCD, void *buffer)
+{
+	pLCD->UPBASE = (uint32_t) buffer;
+}
+
+/**
+ * @brief	Set LCD Lower Panel Frame Buffer for Dual Panel
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	buffer	: address of buffer
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_SetLPFrameBuffer(LPC_LCD_T *pLCD, void *buffer)
+{
+	pLCD->LPBASE = (uint32_t) buffer;
+}
+
+/**
+ * @brief	Configure Cursor
+ * @param	pLCD		: The base of LCD peripheral on the chip
+ * @param	cursor_size	: specify size of cursor
+ *                  - LCD_CURSOR_32x32	:cursor size is 32x32 pixels
+ *                  - LCD_CURSOR_64x64	:cursor size is 64x64 pixels
+ * @param	sync		: cursor sync mode
+ *                  - TRUE	:cursor sync to the frame sync pulse
+ *                  - FALSE	:cursor async mode
+ * @return	None
+ */
+void Chip_LCD_Cursor_Config(LPC_LCD_T *pLCD, LCD_CURSOR_SIZE_OPT_T cursor_size, bool sync);
+
+/**
+ * @brief	Enable Cursor
+ * @param	pLCD		: The base of LCD peripheral on the chip
+ * @param	cursor_num	: specify number of cursor is going to be written
+ *							this param must < 4
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Cursor_Enable(LPC_LCD_T *pLCD, uint8_t cursor_num)
+{
+	pLCD->CRSR_CTRL = (cursor_num << 4) | 1;
+}
+
+/**
+ * @brief	Disable Cursor
+ * @param	pLCD		: The base of LCD peripheral on the chip
+ * @param	cursor_num	: specify number of cursor is going to be written
+ *							this param must < 4
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Cursor_Disable(LPC_LCD_T *pLCD, uint8_t cursor_num)
+{
+	pLCD->CRSR_CTRL = (cursor_num << 4);
+}
+
+/**
+ * @brief	Load Cursor Palette
+ * @param	pLCD			: The base of LCD peripheral on the chip
+ * @param	palette_color	: cursor palette 0 value
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Cursor_LoadPalette0(LPC_LCD_T *pLCD, uint32_t palette_color)
+{
+	/* 7:0 - Red
+	   15:8 - Green
+	   23:16 - Blue
+	   31:24 - Not used*/
+	pLCD->CRSR_PAL0 = (uint32_t) palette_color;
+}
+
+/**
+ * @brief	Load Cursor Palette
+ * @param	pLCD			: The base of LCD peripheral on the chip
+ * @param	palette_color	: cursor palette 1 value
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Cursor_LoadPalette1(LPC_LCD_T *pLCD, uint32_t palette_color)
+{
+	/* 7:0 - Red
+	       15:8 - Green
+	       23:16 - Blue
+	       31:24 - Not used*/
+	pLCD->CRSR_PAL1 = (uint32_t) palette_color;
+}
+
+/**
+ * @brief	Set Cursor Position
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	x		: horizontal position
+ * @param	y		: vertical position
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Cursor_SetPos(LPC_LCD_T *pLCD, uint16_t x, uint16_t y)
+{
+	pLCD->CRSR_XY = (x & 0x3FF) | ((y & 0x3FF) << 16);
+}
+
+/**
+ * @brief	Set Cursor Clipping Position
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	x		: horizontal position, should be in range: 0..63
+ * @param	y		: vertical position, should be in range: 0..63
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_Cursor_SetClip(LPC_LCD_T *pLCD, uint16_t x, uint16_t y)
+{
+	pLCD->CRSR_CLIP = (x & 0x3F) | ((y & 0x3F) << 8);
+}
+
+/**
+ * @brief	Enable Controller Interrupt
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	ints	: OR'ed interrupt bits to enable
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_EnableInts(LPC_LCD_T *pLCD, uint32_t ints)
+{
+	pLCD->INTMSK = ints;
+}
+
+/**
+ * @brief	Disable Controller Interrupt
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	ints	: OR'ed interrupt bits to disable
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_DisableInts(LPC_LCD_T *pLCD, uint32_t ints)
+{
+	pLCD->INTMSK = pLCD->INTMSK & ~(ints);
+}
+
+/**
+ * @brief	Clear Controller Interrupt
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	ints	: OR'ed interrupt bits to clear
+ * @return	None
+ */
+STATIC INLINE void Chip_LCD_ClearInts(LPC_LCD_T *pLCD, uint32_t ints)
+{
+	pLCD->INTCLR = pLCD->INTMSK & (ints);
+}
+
+/**
+ * @brief	Write Cursor Image into Internal Cursor Image Buffer
+ * @param	pLCD		: The base of LCD peripheral on the chip
+ * @param	cursor_num	: Cursor index
+ * @param	Image		: Pointer to image data
+ * @return	None
+ */
+void Chip_LCD_Cursor_WriteImage(LPC_LCD_T *pLCD, uint8_t cursor_num, void *Image);
+
+/**
+ * @brief	Load LCD Palette
+ * @param	pLCD	: The base of LCD peripheral on the chip
+ * @param	palette	: Address of palette table to load
+ * @return	None
+ */
+void Chip_LCD_LoadPalette(LPC_LCD_T *pLCD, void *palette);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* __LCD_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/lpc_types.h ./libs/vendor_libs/lpc_chip_43xx/inc/lpc_types.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/lpc_types.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/lpc_types.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,228 @@
+/*
+ * @brief Common types used in LPC functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LPC_TYPES_H_
+#define __LPC_TYPES_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/** @defgroup LPC_Types CHIP: LPC Common Types
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/** @defgroup LPC_Types_Public_Types LPC Public Types
+ * @{
+ */
+
+/**
+ * @brief Boolean Type definition
+ */
+//typedef enum {FALSE = 0, TRUE = !FALSE} Bool;		// in earlier versions
+#ifndef TRUE
+#define TRUE (1)
+#endif
+#ifndef FALSE
+#define FALSE (0)
+#endif
+
+/**
+ * @brief Boolean Type definition
+ */
+#if !defined(__cplusplus)
+// typedef enum {false = 0, true = !false} bool;
+#endif
+
+/**
+ * @brief Flag Status and Interrupt Flag Status type definition
+ */
+typedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
+#define PARAM_SETSTATE(State) ((State == RESET) || (State == SET))
+
+/**
+ * @brief Functional State Definition
+ */
+typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+#define PARAM_FUNCTIONALSTATE(State) ((State == DISABLE) || (State == ENABLE))
+
+/**
+ * @ Status type definition
+ */
+typedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
+
+/**
+ * Read/Write transfer type mode (Block or non-block)
+ */
+typedef enum {
+	NONE_BLOCKING = 0,		/**< None Blocking type */
+	BLOCKING,				/**< Blocking type */
+} TRANSFER_BLOCK_T;
+
+/** Pointer to Function returning Void (any number of parameters) */
+typedef void (*PFV)();
+
+/** Pointer to Function returning int32_t (any number of parameters) */
+typedef int32_t (*PFI)();
+
+/**
+ * @}
+ */
+
+/** @defgroup LPC_Types_Public_Macros  LPC Public Macros
+ * @{
+ */
+
+/* _BIT(n) sets the bit at position "n"
+ * _BIT(n) is intended to be used in "OR" and "AND" expressions:
+ * e.g., "(_BIT(3) | _BIT(7))".
+ */
+#undef _BIT
+/* Set bit macro */
+#define _BIT(n) (1 << (n))
+
+/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
+ * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
+ * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
+ */
+#undef _SBF
+/* Set bit field macro */
+#define _SBF(f, v) ((v) << (f))
+
+/* _BITMASK constructs a symbol with 'field_width' least significant
+ * bits set.
+ * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
+ * The symbol is intended to be used to limit the bit field width
+ * thusly:
+ * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
+ * If "any_expression" results in a value that is larger than can be
+ * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
+ * used with the _SBF example above, the example would be written:
+ * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
+ * This ensures that the value written to a_reg is no wider than
+ * 16 bits, and makes the code easier to read and understand.
+ */
+#undef _BITMASK
+/* Bitmask creation macro */
+#define _BITMASK(field_width) ( _BIT(field_width) - 1)
+
+/* NULL pointer */
+#ifndef NULL
+#define NULL ((void *) 0)
+#endif
+
+/* Number of elements in an array */
+#define NELEMENTS(array)  (sizeof(array) / sizeof(array[0]))
+
+/* Static data/function define */
+#define STATIC static
+/* External data/function define */
+#define EXTERN extern
+
+#if !defined(MAX)
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+#if !defined(MIN)
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+/**
+ * @}
+ */
+
+/* Old Type Definition compatibility */
+/** @addtogroup LPC_Types_Public_Types
+ * @{
+ */
+
+/** LPC type for character type */
+typedef char CHAR;
+
+/** LPC type for 8 bit unsigned value */
+typedef uint8_t UNS_8;
+
+/** LPC type for 8 bit signed value */
+typedef int8_t INT_8;
+
+/** LPC type for 16 bit unsigned value */
+typedef uint16_t UNS_16;
+
+/** LPC type for 16 bit signed value */
+typedef int16_t INT_16;
+
+/** LPC type for 32 bit unsigned value */
+typedef uint32_t UNS_32;
+
+/** LPC type for 32 bit signed value */
+typedef int32_t INT_32;
+
+/** LPC type for 64 bit signed value */
+typedef int64_t INT_64;
+
+/** LPC type for 64 bit unsigned value */
+typedef uint64_t UNS_64;
+
+#ifdef __CODE_RED
+#define BOOL_32 bool
+#define BOOL_16 bool
+#define BOOL_8  bool
+#else
+/** 32 bit boolean type */
+typedef bool BOOL_32;
+
+/** 16 bit boolean type */
+typedef bool BOOL_16;
+
+/** 8 bit boolean type */
+typedef bool BOOL_8;
+#endif
+
+#ifdef __CC_ARM
+#define INLINE  __inline
+#else
+#define INLINE inline
+#endif
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#endif /* __LPC_TYPES_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/mcpwm_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/mcpwm_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/mcpwm_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/mcpwm_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,86 @@
+/*
+ * @brief LPC18xx/43xx Motor Control PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __MCPWM_18XX_43XX_H_
+#define __MCPWM_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup MCPWM_18XX_43XX CHIP: LPC18xx/43xx Motor Control PWM driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Motor Control PWM register block structure
+ */
+typedef struct {					/*!< MCPWM Structure        */
+	__I  uint32_t  CON;				/*!< PWM Control read address */
+	__O  uint32_t  CON_SET;			/*!< PWM Control set address */
+	__O  uint32_t  CON_CLR;			/*!< PWM Control clear address */
+	__I  uint32_t  CAPCON;			/*!< Capture Control read address */
+	__O  uint32_t  CAPCON_SET;		/*!< Capture Control set address */
+	__O  uint32_t  CAPCON_CLR;		/*!< Event Control clear address */
+	__IO uint32_t TC[3];			/*!< Timer Counter register */
+	__IO uint32_t LIM[3];			/*!< Limit register         */
+	__IO uint32_t MAT[3];			/*!< Match register         */
+	__IO uint32_t  DT;				/*!< Dead time register     */
+	__IO uint32_t  CCP;				/*!< Communication Pattern register */
+	__I  uint32_t CAP[3];			/*!< Capture register       */
+	__I  uint32_t  INTEN;			/*!< Interrupt Enable read address */
+	__O  uint32_t  INTEN_SET;		/*!< Interrupt Enable set address */
+	__O  uint32_t  INTEN_CLR;		/*!< Interrupt Enable clear address */
+	__I  uint32_t  CNTCON;			/*!< Count Control read address */
+	__O  uint32_t  CNTCON_SET;		/*!< Count Control set address */
+	__O  uint32_t  CNTCON_CLR;		/*!< Count Control clear address */
+	__I  uint32_t  INTF;			/*!< Interrupt flags read address */
+	__O  uint32_t  INTF_SET;		/*!< Interrupt flags set address */
+	__O  uint32_t  INTF_CLR;		/*!< Interrupt flags clear address */
+	__O  uint32_t  CAP_CLR;			/*!< Capture clear address  */
+} LPC_MCPWM_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MCPWM_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/otp_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/otp_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/otp_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/otp_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,150 @@
+/*
+ * @brief LPC18xx/43xx OTP Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __OTP_18XX_43XX_H_
+#define __OTP_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup OTP_18XX_43XX CHIP: LPC18xx/43xx OTP Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief	OTP Register block
+ */
+typedef struct {
+	__IO uint32_t OTP0_0;				/*!< (@ 0x40045000) OTP content */
+	__IO uint32_t OTP0_1;				/*!< (@ 0x40045004) OTP content */
+	__IO uint32_t OTP0_2;				/*!< (@ 0x40045008) OTP content */
+	__IO uint32_t OTP0_3;				/*!< (@ 0x4004500C) OTP content */
+	__IO uint32_t OTP1_0;				/*!< (@ 0x40045010) OTP content */
+	__IO uint32_t OTP1_1;				/*!< (@ 0x40045014) OTP content */
+	__IO uint32_t OTP1_2;				/*!< (@ 0x40045018) OTP content */
+	__IO uint32_t OTP1_3;				/*!< (@ 0x4004501C) OTP content */
+	__IO uint32_t OTP2_0;				/*!< (@ 0x40045020) OTP content */
+	__IO uint32_t OTP2_1;				/*!< (@ 0x40045024) OTP content */
+	__IO uint32_t OTP2_2;				/*!< (@ 0x40045028) OTP content */
+	__IO uint32_t OTP2_3;				/*!< (@ 0x4004502C) OTP content */
+	__IO uint32_t OTP3_0;				/*!< (@ 0x40045030) OTP content */
+	__IO uint32_t OTP3_1;				/*!< (@ 0x40045034) OTP content */
+	__IO uint32_t OTP3_2;				/*!< (@ 0x40045038) OTP content */
+	__IO uint32_t OTP3_3;				/*!< (@ 0x4004503C) OTP content */
+} LPC_OTP_T;
+
+/**
+ * @brief	OTP Boot Source selection used in Chip driver
+ */
+typedef enum CHIP_OTP_BOOT_SRC {
+	CHIP_OTP_BOOTSRC_PINS,		/*!< Boot source - External pins */
+	CHIP_OTP_BOOTSRC_UART0,		/*!< Boot source - UART0 */
+	CHIP_OTP_BOOTSRC_SPIFI,		/*!< Boot source - EMC 8-bit memory */
+	CHIP_OTP_BOOTSRC_EMC8,		/*!< Boot source - EMC 16-bit memory */
+	CHIP_OTP_BOOTSRC_EMC16,		/*!< Boot source - EMC 32-bit memory */
+	CHIP_OTP_BOOTSRC_EMC32,		/*!< Boot source - EMC 32-bit memory */
+	CHIP_OTP_BOOTSRC_USB0,		/*!< Boot source - DFU USB0 boot */
+	CHIP_OTP_BOOTSRC_USB1,		/*!< Boot source - DFU USB1 boot */
+	CHIP_OTP_BOOTSRC_SPI,		/*!< Boot source - SPI boot */
+	CHIP_OTP_BOOTSRC_UART3		/*!< Boot source - UART3 */
+} CHIP_OTP_BOOT_SRC_T;
+
+/**
+ * @brief	Initialize for OTP Controller functions
+ * @return	 Status of Otp_Init function
+ * This function will initialise all the OTP driver function pointers
+ * and call the ROM OTP Initialisation function.
+ */
+uint32_t Chip_OTP_Init(void);
+
+/**
+ * @brief	Program boot source in OTP Controller
+ * @param	BootSrc	: Boot Source enum value
+ * @return	Status
+ */
+uint32_t Chip_OTP_ProgBootSrc(CHIP_OTP_BOOT_SRC_T BootSrc);
+
+/**
+ * @brief	Program the JTAG bit in OTP Controller
+ * @return	Status
+ */
+uint32_t Chip_OTP_ProgJTAGDis(void);
+
+/**
+ * @brief	Program USB ID in OTP Controller
+ * @param	ProductID	: USB Product ID
+ * @param	VendorID	: USB Vendor ID
+ * @return	Status
+ */
+uint32_t Chip_OTP_ProgUSBID(uint32_t ProductID, uint32_t VendorID);
+
+/**
+ * @brief	Program OTP GP Word memory
+ * @param   WordNum     : Word Number (Select word 0 or word 1 or word 2)
+ * @param	Data	    : Data value
+ * @param	Mask        : Mask value
+ * @return	Status
+ * This function available in devices which are not AES capable
+ */
+uint32_t Chip_OTP_ProgGPWord(uint32_t WordNum, uint32_t Data, uint32_t Mask);
+
+/**
+ * @brief	Program AES Key
+ * @param   KeyNum      : Key Number (Select 0 or 1)
+ * @param	key         : Pointer to AES Key (16 bytes required)
+ * @return	Status
+ * This function available in devices which are AES capable
+ */
+uint32_t Chip_OTP_ProgKey(uint32_t KeyNum, uint8_t *key);
+
+/**
+ * @brief	Generate Random Number using HW Random Number Generator
+ * @return	Error code of the random number generation. To load the random number into AES, call Chip_AES_LoadKeyRNG
+ */
+uint32_t Chip_OTP_GenRand(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __OTP_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/packing.h ./libs/vendor_libs/lpc_chip_43xx/inc/packing.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/packing.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/packing.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,45 @@
+/*
+ * @brief Packing macros
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PACKING_H_
+#define __PACKING_H_
+
+#define PRE_PACK   /* Nothing */
+#define POST_PACK  /* Nothing */
+#define ALIGNED(n) /* Nothing */
+
+#endif /* __PACKING_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/pinint_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/pinint_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/pinint_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/pinint_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,258 @@
+/*
+ * @brief LPC18xx/43xx Pin Interrupt and Pattern Match Registers and driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PININT_18XX_43XX_H_
+#define __PININT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PININT_18XX_43XX CHIP: LPC18xx/43xx Pin Interrupt and Pattern Match driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief LPC18xx/43xx Pin Interrupt and Pattern Match register block structure
+ */
+typedef struct {			/*!< PIN_INT Structure */
+	__IO uint32_t ISEL;		/*!< Pin Interrupt Mode register */
+	__IO uint32_t IENR;		/*!< Pin Interrupt Enable (Rising) register */
+	__IO uint32_t SIENR;	/*!< Set Pin Interrupt Enable (Rising) register */
+	__IO uint32_t CIENR;	/*!< Clear Pin Interrupt Enable (Rising) register */
+	__IO uint32_t IENF;		/*!< Pin Interrupt Enable Falling Edge / Active Level register */
+	__IO uint32_t SIENF;	/*!< Set Pin Interrupt Enable Falling Edge / Active Level register */
+	__IO uint32_t CIENF;	/*!< Clear Pin Interrupt Enable Falling Edge / Active Level address */
+	__IO uint32_t RISE;		/*!< Pin Interrupt Rising Edge register */
+	__IO uint32_t FALL;		/*!< Pin Interrupt Falling Edge register */
+	__IO uint32_t IST;		/*!< Pin Interrupt Status register */
+} LPC_PIN_INT_T;
+
+
+/**
+ * LPC18xx/43xx Pin Interrupt channel values
+ */
+#define PININTCH0         (1 << 0)
+#define PININTCH1         (1 << 1)
+#define PININTCH2         (1 << 2)
+#define PININTCH3         (1 << 3)
+#define PININTCH4         (1 << 4)
+#define PININTCH5         (1 << 5)
+#define PININTCH6         (1 << 6)
+#define PININTCH7         (1 << 7)
+#define PININTCH(ch)      (1 << (ch))
+
+/**
+ * @brief	Initialize Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ * @note	This function should be used after the Chip_GPIO_Init() function.
+ */
+STATIC INLINE void Chip_PININT_Init(LPC_PIN_INT_T *pPININT) {}
+
+/**
+ * @brief	De-Initialize Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT) {}
+
+/**
+ * @brief	Configure the pins as edge sensitive in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->ISEL &= ~pins;
+}
+
+/**
+ * @brief	Configure the pins as level sensitive in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->ISEL |= pins;
+}
+
+/**
+ * @brief	Return current PININT rising edge or high level interrupt enable state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	A bifield containing the high edge/level interrupt enables for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the high edge/level interrupt is disabled, while a 1
+ * means it's enabled.
+ */
+STATIC INLINE uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->IENR;
+}
+
+/**
+ * @brief	Enable high edge/level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to enable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->SIENR = pins;
+}
+
+/**
+ * @brief	Disable high edge/level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to disable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->CIENR = pins;
+}
+
+/**
+ * @brief	Return current PININT falling edge or low level interrupt enable state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	A bifield containing the low edge/level interrupt enables for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the low edge/level interrupt is disabled, while a 1
+ * means it's enabled.
+ */
+STATIC INLINE uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->IENF;
+}
+
+/**
+ * @brief	Enable low edge/level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to enable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->SIENF = pins;
+}
+
+/**
+ * @brief	Disable low edge/level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to disable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->CIENF = pins;
+}
+
+/**
+ * @brief	Return pin states that have a detected latched high edge (RISE) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	PININT states (bit n = high) with a latched rise state detected
+ */
+STATIC INLINE uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->RISE;
+}
+
+/**
+ * @brief	Clears pin states that had a latched high edge (RISE) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins with latched states to clear
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->RISE = pins;
+}
+
+/**
+ * @brief	Return pin states that have a detected latched falling edge (FALL) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	PININT states (bit n = high) with a latched rise state detected
+ */
+STATIC INLINE uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->FALL;
+}
+
+/**
+ * @brief	Clears pin states that had a latched falling edge (FALL) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins with latched states to clear
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->FALL = pins;
+}
+
+/**
+ * @brief	Get interrupt status from Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Interrupt status (bit n for PININTn = high means interrupt ie pending)
+ */
+STATIC INLINE uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->IST;
+}
+
+/**
+ * @brief	Clear interrupt status in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->IST = pins;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PININT_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/pmc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/pmc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/pmc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/pmc_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,105 @@
+/*
+ * @brief LPC18xx/43xx Power Management Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PMC_18XX_43XX_H_
+#define __PMC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PMC_18XX_43XX CHIP: LPC18xx/43xx Power Management Controller driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Power Management Controller register block structure
+ */
+typedef struct {						/*!< PMC Structure          */
+	__IO uint32_t  PD0_SLEEP0_HW_ENA;	/*!< Hardware sleep event enable register */
+	__I  uint32_t  RESERVED0[6];
+	__IO uint32_t  PD0_SLEEP0_MODE;		/*!< Sleep power mode register */
+} LPC_PMC_T;
+
+/**
+ * @brief Power Management Controller power modes
+ * Setting this mode will not make IO loose the state
+ */
+#define PMC_PWR_DEEP_SLEEP_MODE         0x3000AA
+#define PMC_PWR_POWER_DOWN_MODE         0x30FCBA
+#define PMC_PWR_DEEP_POWER_DOWN_MODE    0x30FF7F
+
+/**
+ * @brief Power Management Controller power modes (IO powerdown)
+ * Setting this mode will make the IO loose the state
+ */
+#define PMC_PWR_DEEP_SLEEP_MODE_NO_IO         0x3F00AA
+#define PMC_PWR_POWER_DOWN_MODE_NO_IO         0x3FFCBA
+#define PMC_PWR_DEEP_POWER_DOWN_MODE_NO_IO    0x3FFF7F
+
+/*
+ * @brief PMC power states
+ */
+typedef enum {
+	PMC_DeepSleep = PMC_PWR_DEEP_SLEEP_MODE,			/*!< Deep sleep state */
+	PMC_PowerDown = PMC_PWR_POWER_DOWN_MODE,			/*!< Power Down state */
+	PMC_DeepPowerDown = PMC_PWR_DEEP_POWER_DOWN_MODE,	/*!< Power Down state */
+} CHIP_PMC_PWR_STATE_T;
+
+/**
+ * @brief	Set to sleep power state
+ * @return	Nothing
+ */
+void Chip_PMC_Sleep(void);
+
+/**
+ * @brief	Set to sleep power mode
+ * @param	PwrState	: Power State as specified in /a CHIP_PMC_PWR_STATE_T enum
+ * @return	Nothing
+ */
+void Chip_PMC_Set_PwrState(CHIP_PMC_PWR_STATE_T PwrState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PMC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/qei_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/qei_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/qei_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/qei_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,92 @@
+/*
+ * @brief LPC18xx/43xx Quadrature Encoder Interface driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __QEI_18XX_43XX_H_
+#define __QEI_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup QEI_18XX_43XX CHIP: LPC18xx/43xx Quadrature Encoder Interface driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Quadrature Encoder Interface register block structure
+ */
+typedef struct {				/*!< QEI Structure          */
+	__O  uint32_t  CON;			/*!< Control register       */
+	__I  uint32_t  STAT;		/*!< Encoder status register */
+	__IO uint32_t  CONF;		/*!< Configuration register */
+	__I  uint32_t  POS;			/*!< Position register      */
+	__IO uint32_t  MAXPOS;		/*!< Maximum position register */
+	__IO uint32_t  CMPOS0;		/*!< position compare register 0 */
+	__IO uint32_t  CMPOS1;		/*!< position compare register 1 */
+	__IO uint32_t  CMPOS2;		/*!< position compare register 2 */
+	__I  uint32_t  INXCNT;		/*!< Index count register   */
+	__IO uint32_t  INXCMP0;		/*!< Index compare register 0 */
+	__IO uint32_t  LOAD;		/*!< Velocity timer reload register */
+	__I  uint32_t  TIME;		/*!< Velocity timer register */
+	__I  uint32_t  VEL;			/*!< Velocity counter register */
+	__I  uint32_t  CAP;			/*!< Velocity capture register */
+	__IO uint32_t  VELCOMP;		/*!< Velocity compare register */
+	__IO uint32_t  FILTERPHA;	/*!< Digital filter register on input phase A (QEI_A) */
+	__IO uint32_t  FILTERPHB;	/*!< Digital filter register on input phase B (QEI_B) */
+	__IO uint32_t  FILTERINX;	/*!< Digital filter register on input index (QEI_IDX) */
+	__IO uint32_t  WINDOW;		/*!< Index acceptance window register */
+	__IO uint32_t  INXCMP1;		/*!< Index compare register 1 */
+	__IO uint32_t  INXCMP2;		/*!< Index compare register 2 */
+	__I  uint32_t  RESERVED0[993];
+	__O  uint32_t  IEC;			/*!< Interrupt enable clear register */
+	__O  uint32_t  IES;			/*!< Interrupt enable set register */
+	__I  uint32_t  INTSTAT;		/*!< Interrupt status register */
+	__I  uint32_t  IE;			/*!< Interrupt enable register */
+	__O  uint32_t  CLR;			/*!< Interrupt status clear register */
+	__O  uint32_t  SET;			/*!< Interrupt status set register */
+} LPC_QEI_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __QEI_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/rgu_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/rgu_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/rgu_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/rgu_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,164 @@
+/*
+ * @brief LPC18xx/43xx Reset Generator Unit driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RGU_18XX_43XX_H_
+#define __RGU_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RGU_18XX_43XX CHIP: LPC18xx/43xx Reset Generator Unit (RGU) driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief RGU reset enumerations
+ */
+typedef enum CHIP_RGU_RST {
+	RGU_CORE_RST,
+	RGU_PERIPH_RST,
+	RGU_MASTER_RST,
+	RGU_WWDT_RST = 4,
+	RGU_CREG_RST,
+	RGU_BUS_RST = 8,
+	RGU_SCU_RST,
+	RGU_M0SUB_RST = 12,
+	RGU_M3_RST,
+	RGU_LCD_RST = 16,
+	RGU_USB0_RST,
+	RGU_USB1_RST,
+	RGU_DMA_RST,
+	RGU_SDIO_RST,
+	RGU_EMC_RST,
+	RGU_ETHERNET_RST,
+	RGU_FLASHA_RST = 25,
+	RGU_EEPROM_RST = 27,
+	RGU_GPIO_RST,
+	RGU_FLASHB_RST,
+	RGU_TIMER0_RST = 32,
+	RGU_TIMER1_RST,
+	RGU_TIMER2_RST,
+	RGU_TIMER3_RST,
+	RGU_RITIMER_RST,
+	RGU_SCT_RST,
+	RGU_MOTOCONPWM_RST,
+	RGU_QEI_RST,
+	RGU_ADC0_RST,
+	RGU_ADC1_RST,
+	RGU_DAC_RST,
+	RGU_UART0_RST = 44,
+	RGU_UART1_RST,
+	RGU_UART2_RST,
+	RGU_UART3_RST,
+	RGU_I2C0_RST,
+	RGU_I2C1_RST,
+	RGU_SSP0_RST,
+	RGU_SSP1_RST,
+	RGU_I2S_RST,
+	RGU_SPIFI_RST,
+	RGU_CAN1_RST,
+	RGU_CAN0_RST,
+#ifdef CHIP_LPC43XX
+	RGU_M0APP_RST,
+	RGU_SGPIO_RST,
+	RGU_SPI_RST,
+	RGU_ADCHS_RST = 60,
+#endif
+	RGU_LAST_RST = 63,
+} CHIP_RGU_RST_T;
+
+/**
+ * @brief RGU register structure
+ */
+typedef struct {							/*!< RGU Structure          */
+	__I  uint32_t  RESERVED0[64];
+	__O  uint32_t  RESET_CTRL[2];			/*!< Reset control register 0,1 */
+	__I  uint32_t  RESERVED1[2];
+	__IO uint32_t  RESET_STATUS[4];			/*!< Reset status register 0 to 3 */
+	__I  uint32_t  RESERVED2[12];
+	__I  uint32_t  RESET_ACTIVE_STATUS[2];	/*!< Reset active status register 0, 1 */
+	__I  uint32_t  RESERVED3[170];
+	__IO uint32_t  RESET_EXT_STAT[RGU_LAST_RST + 1];/*!< Reset external status registers */
+} LPC_RGU_T;
+
+/**
+ * @brief	Trigger a peripheral reset for the selected peripheral
+ * @param	ResetNumber	: Peripheral reset number to trigger
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_RGU_TriggerReset(CHIP_RGU_RST_T ResetNumber)
+{
+	LPC_RGU->RESET_CTRL[ResetNumber >> 5] = 1 << (ResetNumber & 31);
+	/* Reset will auto clear after 1 clock cycle */
+}
+
+/**
+ * @brief	Checks the reset status of a peripheral
+ * @param	ResetNumber	: Peripheral reset number to trigger
+ * @return	true if the periperal is still being reset
+ */
+STATIC INLINE bool Chip_RGU_InReset(CHIP_RGU_RST_T ResetNumber)
+{
+	return !(LPC_RGU->RESET_ACTIVE_STATUS[ResetNumber >> 5] & (1 << (ResetNumber & 31)));
+}
+
+/**
+ * @brief	Clears reset for the selected peripheral
+ * @param	ResetNumber	: Peripheral reset number to trigger (RGU_M0SUB_RST or RGU_M0APP_RST)
+ * @return	Nothing
+ * @note
+ * Almost all peripherals will auto clear the reset bit. Only a few peripherals
+ * like the Cortex M0 Core in LPC43xx will not auto clear the reset and require
+ * this function to clear the reset bit. This function clears all reset bits in
+ * a reset register.
+ */
+STATIC INLINE void Chip_RGU_ClearReset(CHIP_RGU_RST_T ResetNumber)
+{
+	LPC_RGU->RESET_CTRL[ResetNumber >> 5] = 0;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RGU_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ring_buffer.h ./libs/vendor_libs/lpc_chip_43xx/inc/ring_buffer.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ring_buffer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/ring_buffer.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,194 @@
+/*
+ * @brief Common ring buffer support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RING_BUFFER_H_
+#define __RING_BUFFER_H_
+
+#include "lpc_types.h"
+
+/** @defgroup Ring_Buffer CHIP: Simple ring buffer implementation
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief Ring buffer structure
+ */
+typedef struct {
+	void *data;
+	int count;
+	int itemSz;
+	uint32_t head;
+	uint32_t tail;
+} RINGBUFF_T;
+
+/**
+ * @def		RB_VHEAD(rb)
+ * volatile typecasted head index
+ */
+#define RB_VHEAD(rb)              (*(volatile uint32_t *) &(rb)->head)
+
+/**
+ * @def		RB_VTAIL(rb)
+ * volatile typecasted tail index
+ */
+#define RB_VTAIL(rb)              (*(volatile uint32_t *) &(rb)->tail)
+
+/**
+ * @brief	Initialize ring buffer
+ * @param	RingBuff	: Pointer to ring buffer to initialize
+ * @param	buffer		: Pointer to buffer to associate with RingBuff
+ * @param	itemSize	: Size of each buffer item size
+ * @param	count		: Size of ring buffer
+ * @note	Memory pointed by @a buffer must have correct alignment of
+ * 			@a itemSize, and @a count must be a power of 2 and must at
+ * 			least be 2 or greater.
+ * @return	Nothing
+ */
+int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count);
+
+/**
+ * @brief	Resets the ring buffer to empty
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Nothing
+ */
+STATIC INLINE void RingBuffer_Flush(RINGBUFF_T *RingBuff)
+{
+	RingBuff->head = RingBuff->tail = 0;
+}
+
+/**
+ * @brief	Return size the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Size of the ring buffer in bytes
+ */
+STATIC INLINE int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
+{
+	return RingBuff->count;
+}
+
+/**
+ * @brief	Return number of items in the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Number of items in the ring buffer
+ */
+STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
+{
+	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
+}
+
+/**
+ * @brief	Return number of free items in the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Number of free items in the ring buffer
+ */
+STATIC INLINE int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
+{
+	return RingBuff->count - RingBuffer_GetCount(RingBuff);
+}
+
+/**
+ * @brief	Return number of items in the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	1 if the ring buffer is full, otherwise 0
+ */
+STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
+{
+	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
+}
+
+/**
+ * @brief	Return empty status of ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	1 if the ring buffer is empty, otherwise 0
+ */
+STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
+{
+	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
+}
+
+/**
+ * @brief	Insert a single item into ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: pointer to item
+ * @return	1 when successfully inserted,
+ *			0 on error (Buffer not initialized using
+ *			RingBuffer_Init() or attempted to insert
+ *			when buffer is full)
+ */
+int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data);
+
+/**
+ * @brief	Insert an array of items into ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: Pointer to first element of the item array
+ * @param	num			: Number of items in the array
+ * @return	number of items successfully inserted,
+ *			0 on error (Buffer not initialized using
+ *			RingBuffer_Init() or attempted to insert
+ *			when buffer is full)
+ */
+int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num);
+
+/**
+ * @brief	Pop an item from the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: Pointer to memory where popped item be stored
+ * @return	1 when item popped successfuly onto @a data,
+ * 			0 When error (Buffer not initialized using
+ * 			RingBuffer_Init() or attempted to pop item when
+ * 			the buffer is empty)
+ */
+int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data);
+
+/**
+ * @brief	Pop an array of items from the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: Pointer to memory where popped items be stored
+ * @param	num			: Max number of items array @a data can hold
+ * @return	Number of items popped onto @a data,
+ * 			0 on error (Buffer not initialized using RingBuffer_Init()
+ * 			or attempted to pop when the buffer is empty)
+ */
+int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num);
+
+
+/**
+ * @}
+ */
+
+#endif /* __RING_BUFFER_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ritimer_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/ritimer_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ritimer_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/ritimer_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,195 @@
+/*
+ * @brief LPC18xx/43xx RITimer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RITIMER_18XX_43XX_H_
+#define __RITIMER_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RITIMER_18XX_43XX CHIP: LPC18xx/43xx Repetitive Interrupt Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief Repetitive Interrupt Timer register block structure
+ */
+typedef struct {				/*!< RITIMER Structure      */
+	__IO uint32_t  COMPVAL;		/*!< Compare register       */
+	__IO uint32_t  MASK;		/*!< Mask register. This register holds the 32-bit mask value. A 1 written to any bit will force a compare on the corresponding bit of the counter and compare register. */
+	__IO uint32_t  CTRL;		/*!< Control register.      */
+	__IO uint32_t  COUNTER;		/*!< 32-bit counter         */
+} LPC_RITIMER_T;
+
+/*
+ * @brief RITIMER register support bitfields and mask
+ */
+
+/*
+ * RIT control register
+ */
+/**	Set by H/W when the counter value equals the masked compare value */
+#define RIT_CTRL_INT    ((uint32_t) (1))
+/** Set timer enable clear to 0 when the counter value equals the masked compare value  */
+#define RIT_CTRL_ENCLR  ((uint32_t) _BIT(1))
+/** Set timer enable on debug */
+#define RIT_CTRL_ENBR   ((uint32_t) _BIT(2))
+/** Set timer enable */
+#define RIT_CTRL_TEN    ((uint32_t) _BIT(3))
+
+/**
+ * @brief	Initialize the RIT
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+void Chip_RIT_Init(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief	Shutdown the RIT
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+void Chip_RIT_DeInit(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief	Enable Timer
+ * @param	pRITimer		: RITimer peripheral selected
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_Enable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_TEN;
+}
+
+/**
+ * @brief	Disable Timer
+ * @param	pRITimer		: RITimer peripheral selected
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_Disable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL &= ~RIT_CTRL_TEN;
+}
+
+/**
+ * @brief	Enable timer debug
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_TimerDebugEnable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_ENBR;
+}
+
+/**
+ * @brief	Disable timer debug
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_TimerDebugDisable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL &= ~RIT_CTRL_ENBR;
+}
+
+/**
+ * @brief	Check whether interrupt flag is set or not
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	Current interrupt status, either ET or UNSET
+ */
+IntStatus Chip_RIT_GetIntStatus(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief	Set a tick value for the interrupt to time out
+ * @param	pRITimer	: RITimer peripheral selected
+ * @param	val			: value (in ticks) of the interrupt to be set
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_SetCOMPVAL(LPC_RITIMER_T *pRITimer, uint32_t val)
+{
+	pRITimer->COMPVAL = val;
+}
+
+/**
+ * @brief	Enables or clears the RIT or interrupt
+ * @param	pRITimer	: RITimer peripheral selected
+ * @param	val			: RIT to be set, one or more RIT_CTRL_* values
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_EnableCTRL(LPC_RITIMER_T *pRITimer, uint32_t val)
+{
+	pRITimer->CTRL |= val;
+}
+
+/**
+ * @brief	Clears the RIT interrupt
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+STATIC INLINE void Chip_RIT_ClearInt(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_INT;
+}
+
+/**
+ * @brief	Returns the current RIT Counter value
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	the current timer counter value
+ */
+STATIC INLINE uint32_t Chip_RIT_GetCounter(LPC_RITIMER_T *pRITimer)
+{
+	return pRITimer->COUNTER;
+}
+
+/**
+ * @brief	Set timer interval value
+ * @param	pRITimer		: RITimer peripheral selected
+ * @param	time_interval	: timer interval value (ms)
+ * @return	None
+ */
+void Chip_RIT_SetTimerInterval(LPC_RITIMER_T *pRITimer, uint32_t time_interval);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RITIMER_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/romapi_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/romapi_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/romapi_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/romapi_18xx_43xx.h	2018-12-01 17:15:06.653606592 -0300
@@ -0,0 +1,134 @@
+/*
+ * @brief LPC18xx_43xx ROM API declarations and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ROMAPI_18XX_43XX_H_
+#define __ROMAPI_18XX_43XX_H_
+
+#include "iap_18xx_43xx.h"
+#include "error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ROMAPI_18XX_43XX CHIP: LPC18xx_43xx ROM API declarations and functions
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief LPC18XX_43XX OTP API structure
+ */
+typedef struct {
+	uint32_t (*Init)(void);					/*!< Initializes OTP controller. */
+	uint32_t (*ProgBootSrc)(CHIP_OTP_BOOT_SRC_T BootSrc);
+	uint32_t (*ProgJTAGDis)(void);
+	uint32_t (*ProgUSBID)(uint32_t ProductID, uint32_t VendorID);
+	uint32_t reserved01;
+	uint32_t reserved02;
+	uint32_t reserved03;
+	uint32_t reserved04;
+	uint32_t (*ProgGP0)(uint32_t data, uint32_t mask);
+	uint32_t (*ProgGP1)(uint32_t data, uint32_t mask);
+	uint32_t (*ProgGP2)(uint32_t data, uint32_t mask);
+	uint32_t (*ProgKey1)(uint8_t *key);
+	uint32_t (*ProgKey2)(uint8_t *key);
+	uint32_t (*GenRand)(void);
+} OTP_API_T;
+
+/**
+ * @brief LPC18XX_43XX AES API structure
+ */
+typedef struct {
+	uint32_t (*Init)(void);
+	uint32_t (*SetMode)(uint32_t mode);
+	uint32_t (*LoadKey1)(void);
+	uint32_t (*LoadKey2)(void);
+	uint32_t (*LoadKeyRNG)(void);
+	uint32_t (*LoadKeySW)(uint8_t *pKey);
+	uint32_t (*LoadIV_SW)(uint8_t *pVector);
+	uint32_t (*LoadIV_IC)(void);
+	uint32_t (*Operate)(uint8_t *pOutput, uint8_t *pInput, uint32_t size);
+	uint32_t (*ProgramKey1)(uint8_t *pKey);
+	uint32_t (*ProgramKey2)(uint8_t *pKey);
+} AES_API_T;
+
+/**
+ * @brief LPC18XX High level ROM API structure
+ */
+typedef struct {
+	void(*const iap_entry) (uint32_t *, uint32_t *);	/*!< IAP API entry function available on Flash parts only*/
+	const OTP_API_T *pOtp;
+	const AES_API_T *pAes;
+	uint32_t reserved[3];
+	const uint32_t spifiApiBase;			/*!< SPIFI API function table base address*/
+	const uint32_t usbdApiBase;				/*!< USBD API function table base address*/
+	const uint32_t endMarker;				/*!< API table end marker = 0x87654321 */
+
+} LPC_ROM_API_T;
+
+/* Pointer to ROM API function address */
+#define LPC_ROM_API_BASE_LOC    0x10400100
+#define LPC_ROM_API ((LPC_ROM_API_T *) LPC_ROM_API_BASE)
+
+/* Pointer to ROM IAP entry functions */
+#define IAP_ENTRY_LOCATION        (*((uint32_t *) 0x10400100))
+
+/**
+ * @brief IAP flash bank definitions
+ */
+#define IAP_FLASH_BANK_A                        0
+#define IAP_FLASH_BANK_B                        1
+
+/**
+ * @}
+ */
+
+static INLINE void iap_entry(uint32_t cmd_param[], uint32_t status_result[])
+{
+	LPC_ROM_API->iap_entry(cmd_param, status_result);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ROMAPI_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/rtc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/rtc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/rtc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/rtc_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,644 @@
+/*
+ * @brief LPC18xx/43xx RTC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RTC_18XX_43XX_H_
+#define __RTC_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RTC_18XX_43XX CHIP: LPC18xx/43xx Real Time Clock driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define RTC_EV_SUPPORT      1				/* Event Monitor/Recorder support */
+
+/**
+ * @brief RTC time type option
+ */
+typedef enum {
+	RTC_TIMETYPE_SECOND,		/*!< Second */
+	RTC_TIMETYPE_MINUTE,		/*!< Month */
+	RTC_TIMETYPE_HOUR,			/*!< Hour */
+	RTC_TIMETYPE_DAYOFMONTH,	/*!< Day of month */
+	RTC_TIMETYPE_DAYOFWEEK,		/*!< Day of week */
+	RTC_TIMETYPE_DAYOFYEAR,		/*!< Day of year */
+	RTC_TIMETYPE_MONTH,			/*!< Month */
+	RTC_TIMETYPE_YEAR,			/*!< Year */
+	RTC_TIMETYPE_LAST
+} RTC_TIMEINDEX_T;
+
+#if RTC_EV_SUPPORT
+/**
+ * @brief Event Channel Identifier definitions
+ */
+typedef enum {
+	RTC_EV_CHANNEL_1 = 0,
+	RTC_EV_CHANNEL_2,
+	RTC_EV_CHANNEL_3,
+	RTC_EV_CHANNEL_NUM,
+} RTC_EV_CHANNEL_T;
+#endif /*RTC_EV_SUPPORT*/
+
+/**
+ * @brief Real Time Clock register block structure
+ */
+typedef struct {							/*!< RTC Structure          */
+	__IO uint32_t  ILR;						/*!< Interrupt Location Register */
+	__I  uint32_t  RESERVED0;
+	__IO uint32_t  CCR;						/*!< Clock Control Register */
+	__IO uint32_t  CIIR;					/*!< Counter Increment Interrupt Register */
+	__IO uint32_t  AMR;						/*!< Alarm Mask Register    */
+	__I  uint32_t  CTIME[3];				/*!< Consolidated Time Register 0,1,2 */
+	__IO uint32_t  TIME[RTC_TIMETYPE_LAST];	/*!< Timer field registers */
+	__IO uint32_t  CALIBRATION;				/*!< Calibration Value Register */
+	__I  uint32_t  RESERVED1[7];
+	__IO uint32_t  ALRM[RTC_TIMETYPE_LAST];	/*!< Alarm field registers */
+#if RTC_EV_SUPPORT
+	__IO uint32_t ERSTATUS;					/*!< Event Monitor/Recorder Status register*/
+	__IO uint32_t ERCONTROL;				/*!< Event Monitor/Recorder Control register*/
+	__I  uint32_t ERCOUNTERS;				/*!< Event Monitor/Recorder Counters register*/
+	__I  uint32_t RESERVED2;
+	__I  uint32_t ERFIRSTSTAMP[RTC_EV_CHANNEL_NUM];			/*!<Event Monitor/Recorder First Stamp registers*/
+	__I  uint32_t RESERVED3;
+	__I  uint32_t ERLASTSTAMP[RTC_EV_CHANNEL_NUM];			/*!<Event Monitor/Recorder Last Stamp registers*/
+#endif /*RTC_EV_SUPPORT*/
+} LPC_RTC_T;
+
+/**
+ * @brief Register File register block structure
+ */
+typedef struct {
+	__IO uint32_t REGFILE[64];	/*!< General purpose storage register */
+} LPC_REGFILE_T;
+
+/*
+ * @brief ILR register definitions
+ */
+/** ILR register mask */
+#define RTC_ILR_BITMASK         ((0x00000003))
+/** Bit inform the source interrupt is counter increment*/
+#define RTC_IRL_RTCCIF          ((1 << 0))
+/** Bit inform the source interrupt is alarm match*/
+#define RTC_IRL_RTCALF          ((1 << 1))
+
+/*
+ * @brief CCR register definitions
+ */
+/** CCR register mask */
+#define RTC_CCR_BITMASK         ((0x00000013))
+/** Clock enable */
+#define RTC_CCR_CLKEN           ((1 << 0))
+/** Clock reset */
+#define RTC_CCR_CTCRST          ((1 << 1))
+/** Calibration counter enable */
+#define RTC_CCR_CCALEN          ((1 << 4))
+
+/*
+ * @brief CIIR and AMR register definitions
+ */
+/** Counter Increment Interrupt bit for second */
+#define RTC_AMR_CIIR_IMSEC          ((1 << 0))
+/** Counter Increment Interrupt bit for minute */
+#define RTC_AMR_CIIR_IMMIN          ((1 << 1))
+/** Counter Increment Interrupt bit for hour */
+#define RTC_AMR_CIIR_IMHOUR         ((1 << 2))
+/** Counter Increment Interrupt bit for day of month */
+#define RTC_AMR_CIIR_IMDOM          ((1 << 3))
+/** Counter Increment Interrupt bit for day of week */
+#define RTC_AMR_CIIR_IMDOW          ((1 << 4))
+/** Counter Increment Interrupt bit for day of year */
+#define RTC_AMR_CIIR_IMDOY          ((1 << 5))
+/** Counter Increment Interrupt bit for month */
+#define RTC_AMR_CIIR_IMMON          ((1 << 6))
+/** Counter Increment Interrupt bit for year */
+#define RTC_AMR_CIIR_IMYEAR         ((1 << 7))
+/** CIIR bit mask */
+#define RTC_AMR_CIIR_BITMASK        ((0xFF))
+
+/*
+ * @brief RTC_AUX register definitions
+ */
+/** RTC Oscillator Fail detect flag */
+#define RTC_AUX_RTC_OSCF        ((1 << 4))
+
+/*
+ * @brief RTC_AUXEN register definitions
+ */
+/** Oscillator Fail Detect interrupt enable*/
+#define RTC_AUXEN_RTC_OSCFEN    ((1 << 4))
+
+/*
+ * @brief Consolidated Time Register 0 definitions
+ */
+#define RTC_CTIME0_SECONDS_MASK     ((0x3F))
+#define RTC_CTIME0_MINUTES_MASK     ((0x3F00))
+#define RTC_CTIME0_HOURS_MASK       ((0x1F0000))
+#define RTC_CTIME0_DOW_MASK         ((0x7000000))
+
+/*
+ * @brief Consolidated Time Register 1 definitions
+ */
+#define RTC_CTIME1_DOM_MASK         ((0x1F))
+#define RTC_CTIME1_MONTH_MASK       ((0xF00))
+#define RTC_CTIME1_YEAR_MASK        ((0xFFF0000))
+
+/*
+ * @brief Consolidated Time Register 2 definitions
+ */
+#define RTC_CTIME2_DOY_MASK         ((0xFFF))
+
+/*
+ * @brief Time Counter Group and Alarm register group
+ */
+/** SEC register mask */
+#define RTC_SEC_MASK            (0x0000003F)
+/** MIN register mask */
+#define RTC_MIN_MASK            (0x0000003F)
+/** HOUR register mask */
+#define RTC_HOUR_MASK           (0x0000001F)
+/** DOM register mask */
+#define RTC_DOM_MASK            (0x0000001F)
+/** DOW register mask */
+#define RTC_DOW_MASK            (0x00000007)
+/** DOY register mask */
+#define RTC_DOY_MASK            (0x000001FF)
+/** MONTH register mask */
+#define RTC_MONTH_MASK          (0x0000000F)
+/** YEAR register mask */
+#define RTC_YEAR_MASK           (0x00000FFF)
+
+#define RTC_SECOND_MAX      59	/*!< Maximum value of second */
+#define RTC_MINUTE_MAX      59	/*!< Maximum value of minute*/
+#define RTC_HOUR_MAX        23	/*!< Maximum value of hour*/
+#define RTC_MONTH_MIN       1	/*!< Minimum value of month*/
+#define RTC_MONTH_MAX       12	/*!< Maximum value of month*/
+#define RTC_DAYOFMONTH_MIN  1	/*!< Minimum value of day of month*/
+#define RTC_DAYOFMONTH_MAX  31	/*!< Maximum value of day of month*/
+#define RTC_DAYOFWEEK_MAX   6	/*!< Maximum value of day of week*/
+#define RTC_DAYOFYEAR_MIN   1	/*!< Minimum value of day of year*/
+#define RTC_DAYOFYEAR_MAX   366	/*!< Maximum value of day of year*/
+#define RTC_YEAR_MAX        4095/*!< Maximum value of year*/
+
+/*
+ * @brief Calibration register
+ */
+/** Calibration value */
+#define RTC_CALIBRATION_CALVAL_MASK     ((0x1FFFF))
+/** Calibration direction */
+#define RTC_CALIBRATION_LIBDIR          ((1 << 17))
+/** Calibration max value */
+#define RTC_CALIBRATION_MAX             ((0x20000))
+/** Calibration definitions */
+#define RTC_CALIB_DIR_FORWARD           ((uint8_t) (0))
+#define RTC_CALIB_DIR_BACKWARD          ((uint8_t) (1))
+
+#if RTC_EV_SUPPORT
+/*
+ * @brief Event Monitor/Recorder Control register
+ */
+/**  Event Monitor/Recorder Control register mask */
+#define RTC_ERCTRL_BITMASK          ((uint32_t) 0xC0F03C0F)
+/** Enable event interrupt and wakeup */
+#define RTC_ERCTRL_INTWAKE_EN       ((uint32_t) (1 << 0))
+/** Enables automatically clearing the RTC general purpose registers when an event occurs*/
+#define RTC_ERCTRL_GPCLEAR_EN       ((uint32_t) (1 << 1))
+/** Select polarity for a channel event on the input pin.*/
+#define RTC_ERCTRL_POL_NEGATIVE     (0)		/* Event as positive edge */
+#define RTC_ERCTRL_POL_POSITIVE     ((uint32_t) (1 << 2))	/* Event as negative edge */
+/** Enable event input.*/
+#define RTC_ERCTRL_INPUT_EN         ((uint32_t) (1 << 3))
+/** Configure a specific channel */
+#define RTC_ERCTRL_CHANNEL_CONFIG_BITMASK(ch)   ((uint32_t) (0x0F << (10 * ch)))
+#define RTC_ERCTRL_CHANNEL_CONFIG(ch, flag) ((uint32_t) (flag << (10 * ch)))
+
+/** Enable Event Monitor/Recorder and select its operating frequency.*/
+#define RTC_ERCTRL_MODE_MASK                (((uint32_t) 3) << 30)
+#define RTC_ERCTRL_MODE_CLK_DISABLE         (((uint32_t) 0) << 30)
+#define RTC_ERCTRL_MODE_16HZ                (((uint32_t) 1) << 30)
+#define RTC_ERCTRL_MODE_64HZ                (((uint32_t) 2) << 30)
+#define RTC_ERCTRL_MODE_1KHZ                (((uint32_t) 3) << 30)
+#define RTC_ERCTRL_MODE(n)                  (((uint32_t) n) << 30)
+
+/*
+ * @brief Event Monitor/Recorder Status register
+ */
+/** Event Flag for a specific channel */
+#define RTC_ERSTATUS_CHANNEL_EV(ch)               ((uint32_t) (1 << ch))		/* At least 1 event has occurred on a specific channel */
+/** General purpose registers have been asynchronous cleared. */
+#define RTC_ERSTATUS_GPCLEARED            ((uint32_t) (1 << 3))
+/** An interrupt/wakeup request is pending.*/
+#define RTC_ERSTATUS_WAKEUP            ((uint32_t) (((uint32_t) 1) << 31))
+
+/*
+ * @brief Event Monitor/Recorder Counter register
+ */
+/** Value of the counter for Events occurred on a specific channel */
+#define RTC_ER_COUNTER(ch, n)            ((uint32_t) ((n >> (8 * ch)) & 0x07))
+
+/*
+ * @brief Event Monitor/Recorder TimeStamp register
+ */
+#define RTC_ER_TIMESTAMP_SEC(n)             ((uint32_t) (n & 0x3F))
+#define RTC_ER_TIMESTAMP_MIN(n)             ((uint32_t) ((n >> 6) & 0x3F))
+#define RTC_ER_TIMESTAMP_HOUR(n)            ((uint32_t) ((n >> 12) & 0x1F))
+#define RTC_ER_TIMESTAMP_DOY(n)             ((uint32_t) ((n >> 17) & 0x1FF))
+
+/**
+ * @brief Event Monitor/Recorder Mode definition
+ */
+typedef enum IP_RTC_EV_MODE {
+	RTC_EV_MODE_DISABLE = 0,		/*!< Event Monitor/Recoder is disabled */
+	RTC_EV_MODE_ENABLE_16HZ =  1,	/*!< Event Monitor/Recoder is enabled and use 16Hz sample clock for event input */
+	RTC_EV_MODE_ENABLE_64HZ = 2,	/*!< Event Monitor/Recoder is enabled and use 64Hz sample clock for event input */
+	RTC_EV_MODE_ENABLE_1KHZ = 3,	/*!< Event Monitor/Recoder is enabled and use 1kHz sample clock for event input */
+	RTC_EV_MODE_LAST,
+} RTC_EV_MODE_T;
+
+/**
+ * @brief Event Monitor/Recorder Timestamp structure
+ */
+typedef struct {
+	uint8_t     sec;		/*!<   Second */
+	uint8_t     min;		/*!<   Minute */
+	uint8_t     hour;		/*!<   Hour */
+	uint16_t    dayofyear;	/*!<   Day of year */
+} RTC_EV_TIMESTAMP_T;
+
+#endif /*RTC_EV_SUPPORT*/
+
+/**
+ * @brief RTC enumeration
+ */
+
+/** @brief RTC interrupt source */
+typedef enum {
+	RTC_INT_COUNTER_INCREASE = RTC_IRL_RTCCIF,	/*!<  Counter Increment Interrupt */
+	RTC_INT_ALARM = RTC_IRL_RTCALF				/*!< The alarm interrupt */
+} RTC_INT_OPT_T;
+
+typedef struct {
+	uint32_t time[RTC_TIMETYPE_LAST];
+} RTC_TIME_T;
+
+/**
+ * @brief	Reset clock tick counter in the RTC peripheral
+ * @param	pRTC	: RTC peripheral selected
+ * @return	None
+ */
+void Chip_RTC_ResetClockTickCounter(LPC_RTC_T *pRTC);
+
+/**
+ * @brief	Start/Stop RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	NewState	: New State of this function, should be:
+ *							- ENABLE	:The time counters are enabled
+ *							- DISABLE	:The time counters are disabled
+ * @return	None
+ */
+void Chip_RTC_Enable(LPC_RTC_T *pRTC, FunctionalState NewState);
+
+/**
+ * @brief	Enable/Disable Counter increment interrupt for a time type in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	cntrMask	: Or'ed bit values for time types (RTC_AMR_CIIR_IM*)
+ * @param	NewState	: ENABLE or DISABLE
+ * @return	None
+ */
+void Chip_RTC_CntIncrIntConfig(LPC_RTC_T *pRTC, uint32_t cntrMask, FunctionalState NewState);
+
+/**
+ * @brief	Enable/Disable Alarm interrupt for a time type in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	alarmMask	: Or'ed bit values for ALARM types (RTC_AMR_CIIR_IM*)
+ * @param	NewState	: ENABLE or DISABLE
+ * @return	None
+ */
+void Chip_RTC_AlarmIntConfig(LPC_RTC_T *pRTC, uint32_t alarmMask, FunctionalState NewState);
+
+/**
+ * @brief	Set current time value for a time type in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	Timetype	: time field index type to set
+ * @param	TimeValue	: Value to palce in time field
+ * @return	None
+ */
+STATIC INLINE void Chip_RTC_SetTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype, uint32_t TimeValue)
+{
+	pRTC->TIME[Timetype] = TimeValue;
+}
+
+/**
+ * @brief	Get current time value for a type time type
+ * @param	pRTC		: RTC peripheral selected
+ * @param	Timetype	: Time field index type to get
+ * @return	Value of time field according to specified time type
+ */
+STATIC INLINE uint32_t Chip_RTC_GetTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype)
+{
+	return pRTC->TIME[Timetype];
+}
+
+/**
+ * @brief	Set full time in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	pFullTime	: Pointer to full time data
+ * @return	None
+ */
+void Chip_RTC_SetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief	Get full time from the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	pFullTime	: Pointer to full time record to fill
+ * @return	None
+ */
+void Chip_RTC_GetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief	Set alarm time value for a time type
+ * @param	pRTC		: RTC peripheral selected
+ * @param	Timetype	: Time index field to set
+ * @param	ALValue		: Alarm time value to set
+ * @return	None
+ */
+STATIC INLINE void Chip_RTC_SetAlarmTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype, uint32_t ALValue)
+{
+	pRTC->ALRM[Timetype] = ALValue;
+}
+
+/**
+ * @brief	Get alarm time value for a time type
+ * @param	pRTC		: RTC peripheral selected
+ * @param	Timetype	: Time index field to get
+ * @return	Value of Alarm time according to specified time type
+ */
+STATIC INLINE uint32_t Chip_RTC_GetAlarmTime(LPC_RTC_T *pRTC, RTC_TIMEINDEX_T Timetype)
+{
+	return pRTC->ALRM[Timetype];
+}
+
+/**
+ * @brief	Set full alarm time in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	pFullTime	: Pointer to full time record to set alarm
+ * @return	None
+ */
+void Chip_RTC_SetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief	Get full alarm time in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	pFullTime	: Pointer to full time record to fill
+ * @return	None
+ */
+void Chip_RTC_GetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime);
+
+/**
+ * @brief	Write value to General purpose registers
+ * @param	pRegFile	: RegFile peripheral selected
+ * @param	index		: General purpose register index
+ * @param	value		: Value to write
+ * @return	None
+ * @note	These General purpose registers can be used to store important
+ * information when the main power supply is off. The value in these
+ * registers is not affected by chip reset. These registers are
+ * powered in the RTC power domain.
+ */
+STATIC INLINE void Chip_REGFILE_Write(LPC_REGFILE_T *pRegFile, uint8_t index, uint32_t value)
+{
+	pRegFile->REGFILE[index] = value;
+}
+
+/**
+ * @brief	Read value from General purpose registers
+ * @param	pRegFile	: RegFile peripheral selected
+ * @param	index		: General purpose register index
+ * @return	Read Value
+ * @note	These General purpose registers can be used to store important
+ * information when the main power supply is off. The value in these
+ * registers is not affected by chip reset. These registers are
+ * powered in the RTC power domain.
+ */
+STATIC INLINE uint32_t Chip_REGFILE_Read(LPC_REGFILE_T *pRegFile, uint8_t index)
+{
+	return pRegFile->REGFILE[index];
+}
+
+/**
+ * @brief	Enable/Disable calibration counter in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	NewState	: New State of this function, should be:
+ *							- ENABLE	:The calibration counter is enabled and counting
+ *							- DISABLE	:The calibration counter is disabled and reset to zero
+ * @return	None
+ */
+void Chip_RTC_CalibCounterCmd(LPC_RTC_T *pRTC, FunctionalState NewState);
+
+/**
+ * @brief	Configures Calibration in the RTC peripheral
+ * @param	pRTC		: RTC peripheral selected
+ * @param	CalibValue	: Calibration value, should be in range from 0 to 131,072
+ * @param	CalibDir	: Calibration Direction, should be:
+ *							- RTC_CALIB_DIR_FORWARD		:Forward calibration
+ *							- RTC_CALIB_DIR_BACKWARD	:Backward calibration
+ * @return	None
+ */
+STATIC INLINE void Chip_RTC_CalibConfig(LPC_RTC_T *pRTC, uint32_t CalibValue, uint8_t CalibDir)
+{
+	pRTC->CALIBRATION = ((CalibValue - 1) & RTC_CALIBRATION_CALVAL_MASK)
+						| ((CalibDir == RTC_CALIB_DIR_BACKWARD) ? RTC_CALIBRATION_LIBDIR : 0);
+}
+
+/**
+ * @brief	Clear specified Location interrupt pending in the RTC peripheral
+ * @param	pRTC	: RTC peripheral selected
+ * @param	IntType	: Interrupt location type, should be:
+ *						- RTC_INT_COUNTER_INCREASE	:Clear Counter Increment Interrupt pending.
+ *						- RTC_INT_ALARM				:Clear alarm interrupt pending
+ * @return	None
+ */
+STATIC INLINE void Chip_RTC_ClearIntPending(LPC_RTC_T *pRTC, uint32_t IntType)
+{
+	pRTC->ILR = IntType;
+}
+
+/**
+ * @brief	Check whether if specified location interrupt in the RTC peripheral is set or not
+ * @param	pRTC	: RTC peripheral selected
+ * @param	IntType	: Interrupt location type, should be:
+ *						- RTC_INT_COUNTER_INCREASE: Counter Increment Interrupt block generated an interrupt.
+ *						- RTC_INT_ALARM: Alarm generated an interrupt.
+ * @return	New state of specified Location interrupt in RTC peripheral, SET OR RESET
+ */
+STATIC INLINE IntStatus Chip_RTC_GetIntPending(LPC_RTC_T *pRTC, uint32_t IntType)
+{
+	return (pRTC->ILR & IntType) ? SET : RESET;
+}
+
+#if RTC_EV_SUPPORT
+
+/**
+ * @brief	Configure a specific event channel
+ * @param	pRTC	: RTC peripheral selected
+ * @param	ch		: Channel number
+ * @param	flag	: Configuration flag
+ * @return	None
+ * @note	flag is or-ed bit value of RTC_ERCTRL_INTWAKE_EN,RTC_ERCTRL_GPCLEAR_EN,
+ *       RTC_ERCTRL_POL_POSITIVE and RTC_ERCTRL_INPUT_EN.
+ */
+STATIC INLINE void Chip_RTC_EV_Config(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, uint32_t flag)
+{
+	uint32_t temp;
+
+	temp = pRTC->ERCONTROL & (~(RTC_ERCTRL_CHANNEL_CONFIG_BITMASK(ch))) & RTC_ERCTRL_BITMASK;
+	pRTC->ERCONTROL = temp | (RTC_ERCTRL_CHANNEL_CONFIG(ch, flag) & RTC_ERCTRL_BITMASK);
+}
+
+/**
+ * @brief	Enable/Disable and select clock frequency for Event Monitor/Recorder
+ * @param	pRTC	: RTC peripheral selected
+ * @param	mode	: selected mode
+ * @return	None
+ */
+STATIC INLINE void Chip_RTC_EV_SetMode(LPC_RTC_T *pRTC, RTC_EV_MODE_T mode)
+{
+	uint32_t temp;
+
+	temp = pRTC->ERCONTROL & (~RTC_ERCTRL_MODE_MASK) & RTC_ERCTRL_BITMASK;
+	pRTC->ERCONTROL = temp | RTC_ERCTRL_MODE(mode);
+}
+
+/**
+ * @brief	Get Event Monitor/Recorder Status
+ * @param	pRTC	: RTC peripheral selected
+ * @return	Or-ed bit value of RTC_ERSTATUS_GPCLEARED and RTC_ERSTATUS_WAKEUP
+ */
+STATIC INLINE uint8_t Chip_RTC_EV_GetStatus(LPC_RTC_T *pRTC)
+{
+	return pRTC->ERSTATUS & (RTC_ERSTATUS_GPCLEARED | RTC_ERSTATUS_WAKEUP);
+}
+
+/**
+ * @brief	Clear Event Monitor/Recorder Status
+ * @param	pRTC	: RTC peripheral selected
+ * @param	flag	: Or-ed bit value of RTC_ERSTATUS_GPCLEARED and RTC_ERSTATUS_WAKEUP
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_RTC_EV_ClearStatus(LPC_RTC_T *pRTC, uint32_t flag)
+{
+	pRTC->ERSTATUS = flag & (RTC_ERSTATUS_GPCLEARED | RTC_ERSTATUS_WAKEUP);
+}
+
+/**
+ * @brief	Get status of a specific event channel
+ * @param	pRTC	: RTC peripheral selected
+ * @param	ch		: Channel number
+ * @return	SET (At least 1 event occurred on the channel), RESET: no event occured.
+ */
+STATIC INLINE FlagStatus Chip_RTC_EV_GetChannelStatus(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch)
+{
+	return (pRTC->ERSTATUS & RTC_ERSTATUS_CHANNEL_EV(ch)) ? SET : RESET;
+}
+
+/**
+ * @brief	Clear status of a specific event channel
+ * @param	pRTC	: RTC peripheral selected
+ * @param	ch		: Channel number
+ * @return	Nothing.
+ */
+STATIC INLINE void Chip_RTC_EV_ClearChannelStatus(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch)
+{
+	pRTC->ERSTATUS = RTC_ERSTATUS_CHANNEL_EV(ch);
+}
+
+/**
+ * @brief	Get counter value of a specific event channel
+ * @param	pRTC	: RTC peripheral selected
+ * @param	ch		: Channel number
+ * @return	counter value
+ */
+STATIC INLINE uint8_t Chip_RTC_EV_GetCounter(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch)
+{
+	return RTC_ER_COUNTER(ch, pRTC->ERCOUNTERS);
+}
+
+/**
+ * @brief	Get first time stamp of a specific event channel
+ * @param	pRTC		: RTC peripheral selected
+ * @param	ch			: Channel number
+ * @param	pTimeStamp	: pointer to Timestamp buffer
+ * @return	Nothing.
+ */
+void Chip_RTC_EV_GetFirstTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp);
+
+/**
+ * @brief	Get last time stamp of a specific event channel
+ * @param	pRTC		: RTC peripheral selected
+ * @param	ch			: Channel number
+ * @param	pTimeStamp	: pointer to Timestamp buffer
+ * @return	Nothing.
+ */
+void Chip_RTC_EV_GetLastTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp);
+
+#endif /*RTC_EV_SUPPORT*/
+
+/**
+ * @brief	Initialize the RTC peripheral
+ * @param	pRTC	: RTC peripheral selected
+ * @return	None
+ */
+void Chip_RTC_Init(LPC_RTC_T *pRTC);
+
+/**
+ * @brief	De-initialize the RTC peripheral
+ * @param	pRTC	: RTC peripheral selected
+ * @return	None
+ */
+void Chip_RTC_DeInit(LPC_RTC_T *pRTC);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RTC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/rtc_ut.h ./libs/vendor_libs/lpc_chip_43xx/inc/rtc_ut.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/rtc_ut.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/rtc_ut.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,90 @@
+/*
+ * @brief RTC tick to (a more) Universal Time
+ * Adds conversion functions to use an RTC that only provides a
+ * seconds capability to provide "struct tm" support.
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RTC_UT_H_
+#define __RTC_UT_H_
+
+#include "chip.h"
+#include <stdlib.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RTC_UT CHIP: RTC tick to (a more) Universal Time conversion functions
+ * @ingroup CHIP_Common
+ * This driver converts between a RTC 1-second tick value and
+ * a Universal time format in a structure of type 'struct tm'.
+ * @{
+ */
+
+/* Starting year and starting day of week for the driver */
+#define TM_YEAR_BASE    (1900)
+#define TM_DAYOFWEEK    (1)
+
+/**
+ * @brief	Converts a RTC tick time to Universal time
+ * @param	rtcTick	: Current RTC time value
+ * @param	pTime	: Pointer to time structure to fill
+ * @return	Nothing
+ * @note	When setting time, the 'tm_wday', 'tm_yday', and 'tm_isdst'
+ * fields are not used.
+ */
+void ConvertRtcTime(uint32_t rtcTick, struct tm *pTime);
+
+/**
+ * @brief	Converts a Universal time to RTC tick time
+ * @param	pTime	: Pointer to time structure to use
+ * @param	rtcTick	: Pointer to RTC time value to fill
+ * @return	Nothing
+ * @note	When converting time, the 'tm_isdst' field is not
+ * populated by the conversion function.
+ */
+void ConvertTimeRtc(struct tm *pTime, uint32_t *rtcTick);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RTC_UT_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sct_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/sct_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sct_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sct_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,429 @@
+/*
+ * @brief LPC18xx/43xx State Configurable Timer (SCT) driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCT_18XX_43XX_H_
+#define __SCT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCT_18XX_43XX CHIP: LPC18xx/43xx State Configurable Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/*
+ * @brief SCT Module configuration
+ */
+#define CONFIG_SCT_nEV   (16)			/*!< Number of events */
+#define CONFIG_SCT_nRG   (16)			/*!< Number of match/compare registers */
+#define CONFIG_SCT_nOU   (16)			/*!< Number of outputs */
+
+/**
+ * @brief State Configurable Timer register block structure
+ */
+typedef struct {
+	__IO  uint32_t CONFIG;				/*!< Configuration Register */
+	union {
+		__IO uint32_t CTRL_U;			/*!< Control Register */
+		struct {
+			__IO uint16_t CTRL_L;		/*!< Low control register */
+			__IO uint16_t CTRL_H;		/*!< High control register */
+		};
+
+	};
+
+	__IO uint16_t LIMIT_L;				/*!< limit register for counter L */
+	__IO uint16_t LIMIT_H;				/*!< limit register for counter H */
+	__IO uint16_t HALT_L;				/*!< halt register for counter L */
+	__IO uint16_t HALT_H;				/*!< halt register for counter H */
+	__IO uint16_t STOP_L;				/*!< stop register for counter L */
+	__IO uint16_t STOP_H;				/*!< stop register for counter H */
+	__IO uint16_t START_L;				/*!< start register for counter L */
+	__IO uint16_t START_H;				/*!< start register for counter H */
+	uint32_t RESERVED1[10];				/*!< 0x03C reserved */
+	union {
+		__IO uint32_t COUNT_U;			/*!< counter register */
+		struct {
+			__IO uint16_t COUNT_L;		/*!< counter register for counter L */
+			__IO uint16_t COUNT_H;		/*!< counter register for counter H */
+		};
+
+	};
+
+	__IO uint16_t STATE_L;				/*!< state register for counter L */
+	__IO uint16_t STATE_H;				/*!< state register for counter H */
+	__I  uint32_t INPUT;				/*!< input register */
+	__IO uint16_t REGMODE_L;			/*!< match - capture registers mode register L */
+	__IO uint16_t REGMODE_H;			/*!< match - capture registers mode register H */
+	__IO uint32_t OUTPUT;				/*!< output register */
+	__IO uint32_t OUTPUTDIRCTRL;		/*!< output counter direction Control Register */
+	__IO uint32_t RES;					/*!< conflict resolution register */
+	__IO uint32_t DMA0REQUEST;			/*!< DMA0 Request Register */
+	__IO uint32_t DMA1REQUEST;			/*!< DMA1 Request Register */
+	uint32_t RESERVED2[35];
+	__IO uint32_t EVEN;					/*!< event enable register */
+	__IO uint32_t EVFLAG;				/*!< event flag register */
+	__IO uint32_t CONEN;				/*!< conflict enable register */
+	__IO uint32_t CONFLAG;				/*!< conflict flag register */
+	union {
+		__IO union {					/*!< ... Match / Capture value */
+			uint32_t U;					/*!<       SCTMATCH[i].U  Unified 32-bit register */
+			struct {
+				uint16_t L;				/*!<       SCTMATCH[i].L  Access to L value */
+				uint16_t H;				/*!<       SCTMATCH[i].H  Access to H value */
+			};
+
+		} MATCH[CONFIG_SCT_nRG];
+
+		__I union {
+			uint32_t U;					/*!<       SCTCAP[i].U  Unified 32-bit register */
+			struct {
+				uint16_t L;				/*!<       SCTCAP[i].L  Access to L value */
+				uint16_t H;				/*!<       SCTCAP[i].H  Access to H value */
+			};
+
+		} CAP[CONFIG_SCT_nRG];
+
+	};
+
+	uint32_t RESERVED3[32 - CONFIG_SCT_nRG];		/*!< ...-0x17C reserved */
+	union {
+		__IO uint16_t MATCH_L[CONFIG_SCT_nRG];		/*!< 0x180-... Match Value L counter */
+		__I  uint16_t CAP_L[CONFIG_SCT_nRG];		/*!< 0x180-... Capture Value L counter */
+	};
+
+	uint16_t RESERVED4[32 - CONFIG_SCT_nRG];		/*!< ...-0x1BE reserved */
+	union {
+		__IO uint16_t MATCH_H[CONFIG_SCT_nRG];		/*!< 0x1C0-... Match Value H counter */
+		__I  uint16_t CAP_H[CONFIG_SCT_nRG];		/*!< 0x1C0-... Capture Value H counter */
+	};
+
+	uint16_t RESERVED5[32 - CONFIG_SCT_nRG];		/*!< ...-0x1FE reserved */
+	union {
+		__IO union {					/*!< 0x200-... Match Reload / Capture Control value */
+			uint32_t U;					/*!<       SCTMATCHREL[i].U  Unified 32-bit register */
+			struct {
+				uint16_t L;				/*!<       SCTMATCHREL[i].L  Access to L value */
+				uint16_t H;				/*!<       SCTMATCHREL[i].H  Access to H value */
+			};
+
+		} MATCHREL[CONFIG_SCT_nRG];
+
+		__IO union {
+			uint32_t U;					/*!<       SCTCAPCTRL[i].U  Unified 32-bit register */
+			struct {
+				uint16_t L;				/*!<       SCTCAPCTRL[i].L  Access to L value */
+				uint16_t H;				/*!<       SCTCAPCTRL[i].H  Access to H value */
+			};
+
+		} CAPCTRL[CONFIG_SCT_nRG];
+
+	};
+
+	uint32_t RESERVED6[32 - CONFIG_SCT_nRG];		/*!< ...-0x27C reserved */
+	union {
+		__IO uint16_t MATCHREL_L[CONFIG_SCT_nRG];	/*!< 0x280-... Match Reload value L counter */
+		__IO uint16_t CAPCTRL_L[CONFIG_SCT_nRG];	/*!< 0x280-... Capture Control value L counter */
+	};
+
+	uint16_t RESERVED7[32 - CONFIG_SCT_nRG];		/*!< ...-0x2BE reserved */
+	union {
+		__IO uint16_t MATCHREL_H[CONFIG_SCT_nRG];	/*!< 0x2C0-... Match Reload value H counter */
+		__IO uint16_t CAPCTRL_H[CONFIG_SCT_nRG];	/*!< 0x2C0-... Capture Control value H counter */
+	};
+
+	uint16_t RESERVED8[32 - CONFIG_SCT_nRG];		/*!< ...-0x2FE reserved */
+	__IO struct {						/*!< 0x300-0x3FC  SCTEVENT[i].STATE / SCTEVENT[i].CTRL*/
+		uint32_t STATE;					/*!< Event State Register */
+		uint32_t CTRL;					/*!< Event Control Register */
+	} EVENT[CONFIG_SCT_nEV];
+
+	uint32_t RESERVED9[128 - 2 * CONFIG_SCT_nEV];	/*!< ...-0x4FC reserved */
+	__IO struct {						/*!< 0x500-0x57C  SCTOUT[i].SET / SCTOUT[i].CLR */
+		uint32_t SET;					/*!< Output n Set Register */
+		uint32_t CLR;					/*!< Output n Clear Register */
+	} OUT[CONFIG_SCT_nOU];
+
+	uint32_t RESERVED10[191 - 2 * CONFIG_SCT_nOU];	/*!< ...-0x7F8 reserved */
+	__I  uint32_t MODULECONTENT;		/*!< 0x7FC Module Content */
+} LPC_SCT_T;
+
+/*
+ * @brief Macro defines for SCT configuration register
+ */
+#define SCT_CONFIG_16BIT_COUNTER        0x00000000	/*!< Operate as 2 16-bit counters */
+#define SCT_CONFIG_32BIT_COUNTER        0x00000001	/*!< Operate as 1 32-bit counter */
+
+#define SCT_CONFIG_CLKMODE_BUSCLK       (0x0 << 1)	/*!< Bus clock */
+#define SCT_CONFIG_CLKMODE_SCTCLK       (0x1 << 1)	/*!< SCT clock */
+#define SCT_CONFIG_CLKMODE_INCLK        (0x2 << 1)	/*!< Input clock selected in CLKSEL field */
+#define SCT_CONFIG_CLKMODE_INEDGECLK    (0x3 << 1)	/*!< Input clock edge selected in CLKSEL field */
+
+#define SCT_CONFIG_NORELOADL_U          (0x1 << 7)	/*!< Operate as 1 32-bit counter */
+#define SCT_CONFIG_NORELOADH            (0x1 << 8)	/*!< Operate as 1 32-bit counter */
+#define SCT_CONFIG_AUTOLIMIT_L          (0x1 << 17) /*!< Limits counter(L) based on MATCH0 */
+#define SCT_CONFIG_AUTOLIMIT_H          (0x1 << 18) /*!< Limits counter(L) based on MATCH0 */
+
+/*
+ * @brief Macro defines for SCT control register
+ */
+#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0			/*!< Direction for low or unified counter */
+#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
+
+#define SCT_CTRL_STOP_L                 (1 << 1)				/*!< Stop low counter */
+#define SCT_CTRL_HALT_L                 (1 << 2)				/*!< Halt low counter */
+#define SCT_CTRL_CLRCTR_L               (1 << 3)				/*!< Clear low or unified counter */
+#define SCT_CTRL_BIDIR_L(x)             (((x) & 0x01) << 4)		/*!< Bidirectional bit */
+#define SCT_CTRL_PRE_L(x)               (((x) & 0xFF) << 5)		/*!< Prescale clock for low or unified counter */
+
+#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0			/*!< Direction for high counter */
+#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
+#define SCT_CTRL_STOP_H                 (1 << 17)				/*!< Stop high counter */
+#define SCT_CTRL_HALT_H                 (1 << 18)				/*!< Halt high counter */
+#define SCT_CTRL_CLRCTR_H               (1 << 19)				/*!< Clear high counter */
+#define SCT_CTRL_BIDIR_H(x)             (((x) & 0x01) << 20)
+#define SCT_CTRL_PRE_H(x)               (((x) & 0xFF) << 21)	/*!< Prescale clock for high counter */
+
+/*
+ * @brief Macro defines for SCT Conflict resolution register
+ */
+#define SCT_RES_NOCHANGE                (0)
+#define SCT_RES_SET_OUTPUT              (1)
+#define SCT_RES_CLEAR_OUTPUT            (2)
+#define SCT_RES_TOGGLE_OUTPUT           (3)
+
+/**
+ * SCT Match register values enum
+ */
+typedef enum CHIP_SCT_MATCH_REG {
+	SCT_MATCH_0 = 0,	/*!< SCT Match register 0 */
+	SCT_MATCH_1 = 1,	/*!< SCT Match register 1 */
+	SCT_MATCH_2 = 2,	/*!< SCT Match register 2 */
+	SCT_MATCH_3 = 3,	/*!< SCT Match register 3 */
+	SCT_MATCH_4 = 4		/*!< SCT Match register 4 */
+} CHIP_SCT_MATCH_REG_T;
+
+/**
+ * SCT Event values enum
+ */
+typedef enum CHIP_SCT_EVENT {
+	SCT_EVT_0  = (1 << 0),	/*!< Event 0 */
+	SCT_EVT_1  = (1 << 1),	/*!< Event 1 */
+	SCT_EVT_2  = (1 << 2),	/*!< Event 2 */
+	SCT_EVT_3  = (1 << 3),	/*!< Event 3 */
+	SCT_EVT_4  = (1 << 4)	/*!< Event 4 */
+} CHIP_SCT_EVENT_T;
+
+/**
+ * @brief	Configures the State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	value	: The 32-bit CONFIG register value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t value)
+{
+	pSCT->CONFIG = value;
+}
+
+/**
+ * @brief	Set or Clear the Control register
+ * @param	pSCT			: Pointer to SCT register block
+ * @param	value			: SCT Control register value
+ * @param	ena             : ENABLE - To set the fields specified by value
+ *                          : DISABLE - To clear the field specified by value
+ * @return	Nothing
+ * Set or clear the control register bits as specified by the \a value
+ * parameter. If \a ena is set to ENABLE, the mentioned register fields
+ * will be set. If \a ena is set to DISABLE, the mentioned register
+ * fields will be cleared
+ */
+void Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena);
+
+/**
+ * @brief	Set the conflict resolution
+ * @param	pSCT			: Pointer to SCT register block
+ * @param	outnum			: Output number
+ * @param	value           : Output value
+ *                          - SCT_RES_NOCHANGE		:No change
+ *					        - SCT_RES_SET_OUTPUT	:Set output
+ *					        - SCT_RES_CLEAR_OUTPUT	:Clear output
+ *					        - SCT_RES_TOGGLE_OUTPUT :Toggle output
+ *                          : SCT_RES_NOCHANGE
+ *                          : DISABLE - To clear the field specified by value
+ * @return	Nothing
+ * Set conflict resolution for the output \a outnum
+ */
+void Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value);
+
+/**
+ * @brief	Set unified count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	count	: The 32-bit count value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count)
+{
+	pSCT->COUNT_U = count;
+}
+
+/**
+ * @brief	Set lower count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	count	: The 16-bit count value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count)
+{
+	pSCT->COUNT_L = count;
+}
+
+/**
+ * @brief	Set higher count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	count	: The 16-bit count value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count)
+{
+	pSCT->COUNT_H = count;
+}
+
+/**
+ * @brief	Set unified match count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	n		: Match register value
+ * @param	value	: The 32-bit match count value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
+{
+	pSCT->MATCH[n].U = value;
+}
+
+/**
+ * @brief	Set control register in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	value	: Value (ORed value of SCT_CTRL_* bits)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value)
+{
+	pSCT->CTRL_U |= value;
+}
+
+/**
+ * @brief	Clear control register in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	value	: Value (ORed value of SCT_CTRL_* bits)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value)
+{
+	pSCT->CTRL_U &= ~(value);
+}
+
+/**
+ * @brief	Set unified match reload count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	n		: Match register value
+ * @param	value	: The 32-bit match count reload value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
+{
+	pSCT->MATCHREL[n].U = value;
+}
+
+/**
+ * @brief	Enable the interrupt for the specified event in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	evt		: Event value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
+{
+	pSCT->EVEN |= evt;
+}
+
+/**
+ * @brief	Disable the interrupt for the specified event in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	evt		: Event value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
+{
+	pSCT->EVEN &= ~(evt);
+}
+
+/**
+ * @brief	Clear the specified event flag in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	evt		: Event value
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
+{
+	pSCT->EVFLAG |= evt;
+}
+
+/**
+ * @brief	Initializes the State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SCT_Init(LPC_SCT_T *pSCT);
+
+/**
+ * @brief	Deinitializes the State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SCT_DeInit(LPC_SCT_T *pSCT);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#endif /* __SCT_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sct_pwm_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,184 @@
+/*
+ * @brief LPC18xx_43xx State Configurable Timer (SCT/PWM) Chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCT_PWM_18XX_43XX_H_
+#define __SCT_PWM_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCT_PWM_18XX_43XX CHIP: LPC18XX_43XX State Configurable Timer PWM driver
+ *
+ * For more information on how to use the driver please visit the FAQ page at
+ * <a href="http://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen">
+ * www.lpcware.com</a>
+ *
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief	Get number of ticks per PWM cycle
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	Number ot ticks that will be counted per cycle
+ * @note	Return value of this function will be vaild only
+ *          after calling Chip_SCTPWM_SetRate()
+ */
+STATIC INLINE uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
+{
+	return pSCT->MATCHREL[0].U;
+}
+
+/**
+ * @brief	Converts a percentage to ticks
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	percent	: Percentage to convert (0 - 100)
+ * @return	Number ot ticks corresponding to given percentage
+ * @note	Do not use this function when using very low
+ *          pwm rate (like 100Hz or less), on a chip that has
+ *          very high frequency as the calculation might
+ *          cause integer overflow
+ */
+STATIC INLINE uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
+{
+	return (Chip_SCTPWM_GetTicksPerCycle(pSCT) * percent) / 100;
+}
+
+/**
+ * @brief	Get number of ticks on per PWM cycle
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	index	: Index of the PWM 1 to N (see notes)
+ * @return	Number ot ticks for which the output will be ON per cycle
+ * @note	@a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum.
+ */
+STATIC INLINE uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
+{
+	return pSCT->MATCHREL[index].U;
+}
+
+/**
+ * @brief	Get number of ticks on per PWM cycle
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	index	: Index of the PWM 1 to N (see notes)
+ * @param	ticks	: Number of ticks the output should say ON
+ * @return	None
+ * @note	@a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum. The new duty cycle will be effective only
+ *          after completion of current PWM cycle.
+ */
+STATIC INLINE void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
+{
+	Chip_SCT_SetMatchReload(pSCT, (CHIP_SCT_MATCH_REG_T)index, ticks);
+}
+
+/**
+ * @brief	Initialize the SCT/PWM clock and reset
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
+{
+	Chip_SCT_Init(pSCT);
+}
+
+/**
+ * @brief	Start the SCT PWM
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	None
+ * @note	This function must be called after all the
+ * 			configuration is completed. Do not call Chip_SCTPWM_SetRate()
+ * 			or Chip_SCTPWM_SetOutPin() after the SCT/PWM is started. Use
+ * 			Chip_SCTPWM_Stop() to stop the SCT/PWM before reconfiguring,
+ * 			Chip_SCTPWM_SetDutyCycle() can be called when the SCT/PWM is
+ * 			running to change the DutyCycle.
+ */
+STATIC INLINE void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
+{
+	Chip_SCT_ClearControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
+}
+
+/**
+ * @brief	Stop the SCT PWM
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
+{
+	/* Stop SCT */
+	Chip_SCT_SetControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
+
+	/* Clear the counter */
+	Chip_SCT_SetControl(pSCT, SCT_CTRL_CLRCTR_L | SCT_CTRL_CLRCTR_H);
+}
+
+/**
+ * @brief	Sets the frequency of the generated PWM wave
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	freq	: Frequency in Hz
+ * @return	None
+ */
+void Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq);
+
+/**
+ * @brief	Setup the OUTPUT pin and associate it with an index
+ * @param	pSCT	: The base of the SCT peripheral on the chip
+ * @param	index	: Index of PWM 1 to N (see notes)
+ * @param	pin		: COUT pin to be associated with the index
+ * @return	None
+ * @note	@a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum.
+ */
+void Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#endif /* __SCT_PWM_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/scu_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/scu_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/scu_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/scu_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,253 @@
+/*
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCU_18XX_43XX_H_
+#define __SCU_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCU_18XX_43XX CHIP: LPC18xx/43xx SCU Driver (configures pin functions)
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+
+/**
+ * @brief Array of pin definitions passed to Chip_SCU_SetPinMuxing() must be in this format
+ */
+typedef struct {
+	uint8_t pingrp;		/* Pin group */
+	uint8_t pinnum;		/* Pin number */
+	uint16_t modefunc;	/* Pin mode and function for SCU */
+} PINMUX_GRP_T;
+
+/**
+ * @brief System Control Unit register block
+ */
+typedef struct {
+	__IO uint32_t  SFSP[16][32];
+	__I  uint32_t  RESERVED0[256];
+	__IO uint32_t  SFSCLK[4];			/*!< Pin configuration register for pins CLK0-3 */
+	__I  uint32_t  RESERVED16[28];
+	__IO uint32_t  SFSUSB;				/*!< Pin configuration register for USB */
+	__IO uint32_t  SFSI2C0;				/*!< Pin configuration register for I2C0-bus pins */
+	__IO uint32_t  ENAIO[3];			/*!< Analog function select registerS */
+	__I  uint32_t  RESERVED17[27];
+	__IO uint32_t  EMCDELAYCLK;			/*!< EMC clock delay register */
+	__I  uint32_t  RESERVED18[63];
+	__IO uint32_t  PINTSEL[2];			/*!< Pin interrupt select register for pin int 0 to 3 index 0, 4 to 7 index 1. */
+} LPC_SCU_T;
+
+/**
+ * SCU function and mode selection definitions
+ * See the User Manual for specific modes and functions supoprted by the
+ * various LPC18xx/43xx devices. Functionality can vary per device.
+ */
+#define SCU_MODE_PULLUP            (0x0 << 3)		/*!< Enable pull-up resistor at pad */
+#define SCU_MODE_REPEATER          (0x1 << 3)		/*!< Enable pull-down and pull-up resistor at resistor at pad (repeater mode) */
+#define SCU_MODE_INACT             (0x2 << 3)		/*!< Disable pull-down and pull-up resistor at resistor at pad */
+#define SCU_MODE_PULLDOWN          (0x3 << 3)		/*!< Enable pull-down resistor at pad */
+#define SCU_MODE_HIGHSPEEDSLEW_EN  (0x1 << 5)		/*!< Enable high-speed slew */
+#define SCU_MODE_INBUFF_EN         (0x1 << 6)		/*!< Enable Input buffer */
+#define SCU_MODE_ZIF_DIS           (0x1 << 7)		/*!< Disable input glitch filter */
+#define SCU_MODE_4MA_DRIVESTR      (0x0 << 8)		/*!< Normal drive: 4mA drive strength */
+#define SCU_MODE_8MA_DRIVESTR      (0x1 << 8)		/*!< Medium drive: 8mA drive strength */
+#define SCU_MODE_14MA_DRIVESTR     (0x2 << 8)		/*!< High drive: 14mA drive strength */
+#define SCU_MODE_20MA_DRIVESTR     (0x3 << 8)		/*!< Ultra high- drive: 20mA drive strength */
+#define SCU_MODE_FUNC0             0x0				/*!< Selects pin function 0 */
+#define SCU_MODE_FUNC1             0x1				/*!< Selects pin function 1 */
+#define SCU_MODE_FUNC2             0x2				/*!< Selects pin function 2 */
+#define SCU_MODE_FUNC3             0x3				/*!< Selects pin function 3 */
+#define SCU_MODE_FUNC4             0x4				/*!< Selects pin function 4 */
+#define SCU_MODE_FUNC5             0x5				/*!< Selects pin function 5 */
+#define SCU_MODE_FUNC6             0x6				/*!< Selects pin function 6 */
+#define SCU_MODE_FUNC7             0x7				/*!< Selects pin function 7 */
+#define SCU_PINIO_FAST             (SCU_MODE_INACT | SCU_MODE_HIGHSPEEDSLEW_EN | SCU_MODE_INBUFF_EN | SCU_MODE_ZIF_DIS)
+
+/**
+ * SCU function and mode selection definitions (old)
+ * For backwards compatibility.
+ */
+#define MD_PUP						(0x0 << 3)		/** Enable pull-up resistor at pad */
+#define MD_BUK						(0x1 << 3)		/** Enable pull-down and pull-up resistor at resistor at pad (repeater mode) */
+#define MD_PLN						(0x2 << 3)		/** Disable pull-down and pull-up resistor at resistor at pad */
+#define MD_PDN						(0x3 << 3)		/** Enable pull-down resistor at pad */
+#define MD_EHS						(0x1 << 5)		/** Enable fast slew rate */
+#define MD_EZI						(0x1 << 6)		/** Input buffer enable */
+#define MD_ZI						(0x1 << 7)		/** Disable input glitch filter */
+#define MD_EHD0						(0x1 << 8)		/** EHD driver strength low bit */
+#define MD_EHD1						(0x1 << 8)		/** EHD driver strength high bit */
+#define MD_PLN_FAST					(MD_PLN | MD_EZI | MD_ZI | MD_EHS)
+#define I2C0_STANDARD_FAST_MODE		(1 << 3 | 1 << 11)	/** Pin configuration for STANDARD/FAST mode I2C */
+#define I2C0_FAST_MODE_PLUS			(2 << 1 | 1 << 3 | 1 << 7 | 1 << 10 | 1 << 11)	/** Pin configuration for Fast-mode Plus I2C */
+#define FUNC0						0x0				/** Pin function 0 */
+#define FUNC1						0x1				/** Pin function 1 */
+#define FUNC2						0x2				/** Pin function 2 */
+#define FUNC3						0x3				/** Pin function 3 */
+#define FUNC4						0x4				/** Pin function 4 */
+#define FUNC5						0x5				/** Pin function 5 */
+#define FUNC6						0x6				/** Pin function 6 */
+#define FUNC7						0x7				/** Pin function 7 */
+
+#define PORT_OFFSET					0x80			/** Port offset definition */
+#define PIN_OFFSET					0x04			/** Pin offset definition */
+
+/** Returns the SFSP register address in the SCU for a pin and port, recommend using (*(volatile int *) &LPC_SCU->SFSP[po][pi];) */
+#define LPC_SCU_PIN(LPC_SCU_BASE, po, pi) (*(volatile int *) ((LPC_SCU_BASE) + ((po) * 0x80) + ((pi) * 0x4))
+
+/** Returns the address in the SCU for a SFSCLK clock register, recommend using (*(volatile int *) &LPC_SCU->SFSCLK[c];) */
+#define LPC_SCU_CLK(LPC_SCU_BASE, c) (*(volatile int *) ((LPC_SCU_BASE) +0xC00 + ((c) * 0x4)))
+
+/**
+ * @brief	Sets I/O Control pin mux
+ * @param	port		: Port number, should be: 0..15
+ * @param	pin			: Pin number, should be: 0..31
+ * @param	modefunc	: OR'ed values or type SCU_MODE_*
+ * @return	Nothing
+ * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
+ * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
+ */
+STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
+{
+	LPC_SCU->SFSP[port][pin] = modefunc;
+}
+
+/**
+ * @brief	Configure pin function
+ * @param	port	: Port number, should be: 0..15
+ * @param	pin		: Pin number, should be: 0..31
+ * @param	mode	: OR'ed values or type SCU_MODE_*
+ * @param	func	: Pin function, value of type SCU_MODE_FUNC0 to SCU_MODE_FUNC7
+ * @return	Nothing
+ * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
+ * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
+ */
+STATIC INLINE void Chip_SCU_PinMux(uint8_t port, uint8_t pin, uint16_t mode, uint8_t func)
+{
+	Chip_SCU_PinMuxSet(port, pin, (mode | (uint16_t) func));
+}
+
+/**
+ * @brief	Configure clock pin function (pins SFSCLKx)
+ * @param	clknum	: Clock pin number, should be: 0..3
+ * @param	modefunc	: OR'ed values or type SCU_MODE_*
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_ClockPinMuxSet(uint8_t clknum, uint16_t modefunc)
+{
+	LPC_SCU->SFSCLK[clknum] = (uint32_t) modefunc;
+}
+
+/**
+ * @brief	Configure clock pin function (pins SFSCLKx)
+ * @param	clknum	: Clock pin number, should be: 0..3
+ * @param	mode	: OR'ed values or type SCU_MODE_*
+ * @param	func	: Pin function, value of type SCU_MODE_FUNC0 to SCU_MODE_FUNC7
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_ClockPinMux(uint8_t clknum, uint16_t mode, uint8_t func)
+{
+	LPC_SCU->SFSCLK[clknum] = ((uint32_t) mode | (uint32_t) func);
+}
+
+/**
+ * @brief	GPIO Interrupt Pin Select
+ * @param	PortSel	: GPIO PINTSEL interrupt, should be: 0 to 7
+ * @param	PortNum	: GPIO port number interrupt, should be: 0 to 7
+ * @param	PinNum	: GPIO pin number Interrupt , should be: 0 to 31
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_GPIOIntPinSel(uint8_t PortSel, uint8_t PortNum, uint8_t PinNum)
+{
+	int32_t of = (PortSel & 3) << 3;
+	uint32_t val = (((PortNum & 0x7) << 5) | (PinNum & 0x1F)) << of;
+	LPC_SCU->PINTSEL[PortSel >> 2] = (LPC_SCU->PINTSEL[PortSel >> 2] & ~(0xFF << of)) | val;
+}
+
+/**
+ * @brief	I2C Pin Configuration
+ * @param	I2C0Mode	: I2C0 mode, should be:
+ *                  - I2C0_STANDARD_FAST_MODE: Standard/Fast mode transmit
+ *                  - I2C0_FAST_MODE_PLUS: Fast-mode Plus transmit
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_I2C0PinConfig(uint32_t I2C0Mode)
+{
+	LPC_SCU->SFSI2C0 = I2C0Mode;
+}
+
+/**
+ * @brief	ADC Pin Configuration
+ * @param	ADC_ID	: ADC number
+ * @param	channel	: ADC channel
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_ADC_Channel_Config(uint32_t ADC_ID, uint8_t channel)
+{
+	LPC_SCU->ENAIO[ADC_ID] |= 1UL << channel;
+}
+
+/**
+ * @brief	DAC Pin Configuration
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_DAC_Analog_Config(void)
+{
+	/*Enable analog function DAC on pin P4_4*/
+	LPC_SCU->ENAIO[2] |= 1;
+}
+
+/**
+ * @brief	Set all I/O Control pin muxing
+ * @param	pinArray    : Pointer to array of pin mux selections
+ * @param	arrayLength : Number of entries in pinArray
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
+{
+	uint32_t ix;
+	for (ix = 0; ix < arrayLength; ix++ ) {
+		Chip_SCU_PinMuxSet(pinArray[ix].pingrp, pinArray[ix].pinnum, pinArray[ix].modefunc);
+	}
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SCU_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdif_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/sdif_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdif_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sdif_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,485 @@
+/*
+ * @brief LPC18xx/43xx SD/SDIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDIF_18XX_43XX_H_
+#define __SDIF_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SDIF_18XX_43XX CHIP: LPC18xx/43xx SD/SDIO driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief SD/MMC & SDIO register block structure
+ */
+typedef struct {				/*!< SDMMC Structure        */
+	__IO uint32_t  CTRL;		/*!< Control Register       */
+	__IO uint32_t  PWREN;		/*!< Power Enable Register  */
+	__IO uint32_t  CLKDIV;		/*!< Clock Divider Register */
+	__IO uint32_t  CLKSRC;		/*!< SD Clock Source Register */
+	__IO uint32_t  CLKENA;		/*!< Clock Enable Register  */
+	__IO uint32_t  TMOUT;		/*!< Timeout Register       */
+	__IO uint32_t  CTYPE;		/*!< Card Type Register     */
+	__IO uint32_t  BLKSIZ;		/*!< Block Size Register    */
+	__IO uint32_t  BYTCNT;		/*!< Byte Count Register    */
+	__IO uint32_t  INTMASK;		/*!< Interrupt Mask Register */
+	__IO uint32_t  CMDARG;		/*!< Command Argument Register */
+	__IO uint32_t  CMD;			/*!< Command Register       */
+	__I  uint32_t  RESP0;		/*!< Response Register 0    */
+	__I  uint32_t  RESP1;		/*!< Response Register 1    */
+	__I  uint32_t  RESP2;		/*!< Response Register 2    */
+	__I  uint32_t  RESP3;		/*!< Response Register 3    */
+	__I  uint32_t  MINTSTS;		/*!< Masked Interrupt Status Register */
+	__IO uint32_t  RINTSTS;		/*!< Raw Interrupt Status Register */
+	__I  uint32_t  STATUS;		/*!< Status Register        */
+	__IO uint32_t  FIFOTH;		/*!< FIFO Threshold Watermark Register */
+	__I  uint32_t  CDETECT;		/*!< Card Detect Register   */
+	__I  uint32_t  WRTPRT;		/*!< Write Protect Register */
+	__IO uint32_t  GPIO;		/*!< General Purpose Input/Output Register */
+	__I  uint32_t  TCBCNT;		/*!< Transferred CIU Card Byte Count Register */
+	__I  uint32_t  TBBCNT;		/*!< Transferred Host to BIU-FIFO Byte Count Register */
+	__IO uint32_t  DEBNCE;		/*!< Debounce Count Register */
+	__IO uint32_t  USRID;		/*!< User ID Register       */
+	__I  uint32_t  VERID;		/*!< Version ID Register    */
+	__I  uint32_t  RESERVED0;
+	__IO uint32_t  UHS_REG;		/*!< UHS-1 Register         */
+	__IO uint32_t  RST_N;		/*!< Hardware Reset         */
+	__I  uint32_t  RESERVED1;
+	__IO uint32_t  BMOD;		/*!< Bus Mode Register      */
+	__O  uint32_t  PLDMND;		/*!< Poll Demand Register   */
+	__IO uint32_t  DBADDR;		/*!< Descriptor List Base Address Register */
+	__IO uint32_t  IDSTS;		/*!< Internal DMAC Status Register */
+	__IO uint32_t  IDINTEN;		/*!< Internal DMAC Interrupt Enable Register */
+	__I  uint32_t  DSCADDR;		/*!< Current Host Descriptor Address Register */
+	__I  uint32_t  BUFADDR;		/*!< Current Buffer Descriptor Address Register */
+} LPC_SDMMC_T;
+
+/** @brief  SDIO DMA descriptor control (des0) register defines
+ */
+#define MCI_DMADES0_OWN         (1UL << 31)		/*!< DMA owns descriptor bit */
+#define MCI_DMADES0_CES         (1 << 30)		/*!< Card Error Summary bit */
+#define MCI_DMADES0_ER          (1 << 5)		/*!< End of descriptopr ring bit */
+#define MCI_DMADES0_CH          (1 << 4)		/*!< Second address chained bit */
+#define MCI_DMADES0_FS          (1 << 3)		/*!< First descriptor bit */
+#define MCI_DMADES0_LD          (1 << 2)		/*!< Last descriptor bit */
+#define MCI_DMADES0_DIC         (1 << 1)		/*!< Disable interrupt on completion bit */
+
+/** @brief  SDIO DMA descriptor size (des1) register defines
+ */
+#define MCI_DMADES1_BS1(x)      (x)				/*!< Size of buffer 1 */
+#define MCI_DMADES1_BS2(x)      ((x) << 13)		/*!< Size of buffer 2 */
+#define MCI_DMADES1_MAXTR       4096			/*!< Max transfer size per buffer */
+
+/** @brief  SDIO control register defines
+ */
+#define MCI_CTRL_USE_INT_DMAC   (1 << 25)		/*!< Use internal DMA */
+#define MCI_CTRL_CARDV_MASK     (0x7 << 16)		/*!< SD_VOLT[2:0} pins output state mask */
+#define MCI_CTRL_CEATA_INT_EN   (1 << 11)		/*!< Enable CE-ATA interrupts */
+#define MCI_CTRL_SEND_AS_CCSD   (1 << 10)		/*!< Send auto-stop */
+#define MCI_CTRL_SEND_CCSD      (1 << 9)		/*!< Send CCSD */
+#define MCI_CTRL_ABRT_READ_DATA (1 << 8)		/*!< Abort read data */
+#define MCI_CTRL_SEND_IRQ_RESP  (1 << 7)		/*!< Send auto-IRQ response */
+#define MCI_CTRL_READ_WAIT      (1 << 6)		/*!< Assert read-wait for SDIO */
+#define MCI_CTRL_INT_ENABLE     (1 << 4)		/*!< Global interrupt enable */
+#define MCI_CTRL_DMA_RESET      (1 << 2)		/*!< Reset internal DMA */
+#define MCI_CTRL_FIFO_RESET     (1 << 1)		/*!< Reset data FIFO pointers */
+#define MCI_CTRL_RESET          (1 << 0)		/*!< Reset controller */
+
+/** @brief SDIO Power Enable register defines
+ */
+#define MCI_POWER_ENABLE        0x1				/*!< Enable slot power signal (SD_POW) */
+
+/** @brief SDIO Clock divider register defines
+ */
+#define MCI_CLOCK_DIVIDER(dn, d2) ((d2) << ((dn) * 8))	/*!< Set cklock divider */
+
+/** @brief SDIO Clock source register defines
+ */
+#define MCI_CLKSRC_CLKDIV0      0
+#define MCI_CLKSRC_CLKDIV1      1
+#define MCI_CLKSRC_CLKDIV2      2
+#define MCI_CLKSRC_CLKDIV3      3
+#define MCI_CLK_SOURCE(clksrc)  (clksrc)		/*!< Set cklock divider source */
+
+/** @brief SDIO Clock Enable register defines
+ */
+#define MCI_CLKEN_LOW_PWR       (1 << 16)		/*!< Enable clock idle for slot */
+#define MCI_CLKEN_ENABLE        (1 << 0)		/*!< Enable slot clock */
+
+/** @brief SDIO time-out register defines
+ */
+#define MCI_TMOUT_DATA(clks)    ((clks) << 8)	/*!< Data timeout clocks */
+#define MCI_TMOUT_DATA_MSK      0xFFFFFF00
+#define MCI_TMOUT_RESP(clks)    ((clks) & 0xFF)	/*!< Response timeout clocks */
+#define MCI_TMOUT_RESP_MSK      0xFF
+
+/** @brief SDIO card-type register defines
+ */
+#define MCI_CTYPE_8BIT          (1 << 16)		/*!< Enable 4-bit mode */
+#define MCI_CTYPE_4BIT          (1 << 0)		/*!< Enable 8-bit mode */
+
+/** @brief SDIO Interrupt status & mask register defines
+ */
+#define MCI_INT_SDIO            (1 << 16)		/*!< SDIO interrupt */
+#define MCI_INT_EBE             (1 << 15)		/*!< End-bit error */
+#define MCI_INT_ACD             (1 << 14)		/*!< Auto command done */
+#define MCI_INT_SBE             (1 << 13)		/*!< Start bit error */
+#define MCI_INT_HLE             (1 << 12)		/*!< Hardware locked error */
+#define MCI_INT_FRUN            (1 << 11)		/*!< FIFO overrun/underrun error */
+#define MCI_INT_HTO             (1 << 10)		/*!< Host data starvation error */
+#define MCI_INT_DTO             (1 << 9)		/*!< Data timeout error */
+#define MCI_INT_RTO             (1 << 8)		/*!< Response timeout error */
+#define MCI_INT_DCRC            (1 << 7)		/*!< Data CRC error */
+#define MCI_INT_RCRC            (1 << 6)		/*!< Response CRC error */
+#define MCI_INT_RXDR            (1 << 5)		/*!< RX data ready */
+#define MCI_INT_TXDR            (1 << 4)		/*!< TX data needed */
+#define MCI_INT_DATA_OVER       (1 << 3)		/*!< Data transfer over */
+#define MCI_INT_CMD_DONE        (1 << 2)		/*!< Command done */
+#define MCI_INT_RESP_ERR        (1 << 1)		/*!< Command response error */
+#define MCI_INT_CD              (1 << 0)		/*!< Card detect */
+
+/** @brief SDIO Command register defines
+ */
+#define MCI_CMD_START           (1UL << 31)		/*!< Start command */
+#define MCI_CMD_VOLT_SWITCH     (1 << 28)		/*!< Voltage switch bit */
+#define MCI_CMD_BOOT_MODE       (1 << 27)		/*!< Boot mode */
+#define MCI_CMD_DISABLE_BOOT    (1 << 26)		/*!< Disable boot */
+#define MCI_CMD_EXPECT_BOOT_ACK (1 << 25)		/*!< Expect boot ack */
+#define MCI_CMD_ENABLE_BOOT     (1 << 24)		/*!< Enable boot */
+#define MCI_CMD_CCS_EXP         (1 << 23)		/*!< CCS expected */
+#define MCI_CMD_CEATA_RD        (1 << 22)		/*!< CE-ATA read in progress */
+#define MCI_CMD_UPD_CLK         (1 << 21)		/*!< Update clock register only */
+#define MCI_CMD_INIT            (1 << 15)		/*!< Send init sequence */
+#define MCI_CMD_STOP            (1 << 14)		/*!< Stop/abort command */
+#define MCI_CMD_PRV_DAT_WAIT    (1 << 13)		/*!< Wait before send */
+#define MCI_CMD_SEND_STOP       (1 << 12)		/*!< Send auto-stop */
+#define MCI_CMD_STRM_MODE       (1 << 11)		/*!< Stream transfer mode */
+#define MCI_CMD_DAT_WR          (1 << 10)		/*!< Read(0)/Write(1) selection */
+#define MCI_CMD_DAT_EXP         (1 << 9)		/*!< Data expected */
+#define MCI_CMD_RESP_CRC        (1 << 8)		/*!< Check response CRC */
+#define MCI_CMD_RESP_LONG       (1 << 7)		/*!< Response length */
+#define MCI_CMD_RESP_EXP        (1 << 6)		/*!< Response expected */
+#define MCI_CMD_INDX(n)         ((n) & 0x1F)
+
+/** @brief SDIO status register definess
+ */
+#define MCI_STS_GET_FCNT(x)     (((x) >> 17) & 0x1FF)
+
+/** @brief SDIO FIFO threshold defines
+ */
+#define MCI_FIFOTH_TX_WM(x)     ((x) & 0xFFF)
+#define MCI_FIFOTH_RX_WM(x)     (((x) & 0xFFF) << 16)
+#define MCI_FIFOTH_DMA_MTS_1    (0UL << 28)
+#define MCI_FIFOTH_DMA_MTS_4    (1UL << 28)
+#define MCI_FIFOTH_DMA_MTS_8    (2UL << 28)
+#define MCI_FIFOTH_DMA_MTS_16   (3UL << 28)
+#define MCI_FIFOTH_DMA_MTS_32   (4UL << 28)
+#define MCI_FIFOTH_DMA_MTS_64   (5UL << 28)
+#define MCI_FIFOTH_DMA_MTS_128  (6UL << 28)
+#define MCI_FIFOTH_DMA_MTS_256  (7UL << 28)
+
+/** @brief Bus mode register defines
+ */
+#define MCI_BMOD_PBL1           (0 << 8)		/*!< Burst length = 1 */
+#define MCI_BMOD_PBL4           (1 << 8)		/*!< Burst length = 4 */
+#define MCI_BMOD_PBL8           (2 << 8)		/*!< Burst length = 8 */
+#define MCI_BMOD_PBL16          (3 << 8)		/*!< Burst length = 16 */
+#define MCI_BMOD_PBL32          (4 << 8)		/*!< Burst length = 32 */
+#define MCI_BMOD_PBL64          (5 << 8)		/*!< Burst length = 64 */
+#define MCI_BMOD_PBL128         (6 << 8)		/*!< Burst length = 128 */
+#define MCI_BMOD_PBL256         (7 << 8)		/*!< Burst length = 256 */
+#define MCI_BMOD_DE             (1 << 7)		/*!< Enable internal DMAC */
+#define MCI_BMOD_DSL(len)       ((len) << 2)	/*!< Descriptor skip length */
+#define MCI_BMOD_FB             (1 << 1)		/*!< Fixed bursts */
+#define MCI_BMOD_SWR            (1 << 0)		/*!< Software reset of internal registers */
+
+/** @brief Commonly used definitions
+ */
+#define SD_FIFO_SZ              32				/*!< Size of SDIO FIFOs (32-bit wide) */
+
+/** Function prototype for SD interface IRQ callback */
+typedef uint32_t (*MCI_IRQ_CB_FUNC_T)(uint32_t);
+
+/** Function prototype for SD detect and write protect status check */
+typedef int32_t (*PSCHECK_FUNC_T)(void);
+
+/** Function prototype for SD slot power enable or slot reset */
+typedef void (*PS_POWER_FUNC_T)(int32_t enable);
+
+/** @brief  SDIO chained DMA descriptor
+ */
+typedef struct {
+	volatile uint32_t des0;						/*!< Control and status */
+	volatile uint32_t des1;						/*!< Buffer size(s) */
+	volatile uint32_t des2;						/*!< Buffer address pointer 1 */
+	volatile uint32_t des3;						/*!< Buffer address pointer 2 */
+} pSDMMC_DMA_T;
+
+/** @brief  SDIO device type
+ */
+typedef struct _sdif_device {
+	/* MCI_IRQ_CB_FUNC_T irq_cb; */
+	pSDMMC_DMA_T mci_dma_dd[1 + (0x10000 / MCI_DMADES1_MAXTR)];
+	/* uint32_t sdio_clk_rate; */
+	/* uint32_t sdif_slot_clk_rate; */
+	/* int32_t clock_enabled; */
+} sdif_device;
+
+/** @brief Setup options for the SDIO driver
+ */
+#define US_TIMEOUT            1000000		/*!< give 1 atleast 1 sec for the card to respond */
+#define MS_ACQUIRE_DELAY      (10)			/*!< inter-command acquire oper condition delay in msec*/
+#define INIT_OP_RETRIES       50			/*!< initial OP_COND retries */
+#define SET_OP_RETRIES        1000			/*!< set OP_COND retries */
+#define SDIO_BUS_WIDTH        4				/*!< Max bus width supported */
+#define SD_MMC_ENUM_CLOCK       400000		/*!< Typical enumeration clock rate */
+#define MMC_MAX_CLOCK           20000000	/*!< Max MMC clock rate */
+#define MMC_LOW_BUS_MAX_CLOCK   26000000	/*!< Type 0 MMC card max clock rate */
+#define MMC_HIGH_BUS_MAX_CLOCK  52000000	/*!< Type 1 MMC card max clock rate */
+#define SD_MAX_CLOCK            25000000	/*!< Max SD clock rate */
+
+/**
+ * @brief	Set block size for the transfer
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	bytes	: block size in bytes
+ * @return	None
+ */
+STATIC INLINE void Chip_SDIF_SetBlkSize(LPC_SDMMC_T *pSDMMC, uint32_t bytes)
+{
+	pSDMMC->BLKSIZ = bytes;
+}
+
+/**
+ * @brief	Reset card in slot
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	reset	: Sets SD_RST to passed state
+ * @return	None
+ * @note	Reset card in slot, must manually de-assert reset after assertion
+ * (Uses SD_RST pin, set per reset parameter state)
+ */
+STATIC INLINE void Chip_SDIF_Reset(LPC_SDMMC_T *pSDMMC, int32_t reset)
+{
+	if (reset) {
+		pSDMMC->RST_N = 1;
+	}
+	else {
+		pSDMMC->RST_N = 0;
+	}
+}
+
+/**
+ * @brief	Detect if an SD card is inserted
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	Returns 0 if a card is detected, otherwise 1
+ * @note	Detect if an SD card is inserted
+ * (uses SD_CD pin, returns 0 on card detect)
+ */
+STATIC INLINE int32_t Chip_SDIF_CardNDetect(LPC_SDMMC_T *pSDMMC)
+{
+	return (pSDMMC->CDETECT & 1);
+}
+
+/**
+ * @brief	Detect if write protect is enabled
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	Returns 1 if card is write protected, otherwise 0
+ * @note	Detect if write protect is enabled
+ * (uses SD_WP pin, returns 1 if card is write protected)
+ */
+STATIC INLINE int32_t Chip_SDIF_CardWpOn(LPC_SDMMC_T *pSDMMC)
+{
+	return (pSDMMC->WRTPRT & 1);
+}
+
+/**
+ * @brief	Disable slot power
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	None
+ * @note	Uses SD_POW pin, set to low.
+ */
+STATIC INLINE void Chip_SDIF_PowerOff(LPC_SDMMC_T *pSDMMC)
+{
+	pSDMMC->PWREN = 0;
+}
+
+/**
+ * @brief	Enable slot power
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	None
+ * @note	Uses SD_POW pin, set to high.
+ */
+STATIC INLINE void Chip_SDIF_PowerOn(LPC_SDMMC_T *pSDMMC)
+{
+	pSDMMC->PWREN = 1;
+}
+
+/**
+ * @brief	Function to set card type
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	ctype	: card type
+ * @return	None
+ */
+STATIC INLINE void Chip_SDIF_SetCardType(LPC_SDMMC_T *pSDMMC, uint32_t ctype)
+{
+	pSDMMC->CTYPE = ctype;
+}
+
+/**
+ * @brief	Returns the raw SD interface interrupt status
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	Current pending interrupt status of Or'ed values MCI_INT_*
+ */
+STATIC INLINE uint32_t Chip_SDIF_GetIntStatus(LPC_SDMMC_T *pSDMMC)
+{
+	return pSDMMC->RINTSTS;
+}
+
+/**
+ * @brief	Clears the raw SD interface interrupt status
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	iVal	: Interrupts to be cleared, Or'ed values MCI_INT_*
+ * @return	None
+ */
+STATIC INLINE void Chip_SDIF_ClrIntStatus(LPC_SDMMC_T *pSDMMC, uint32_t iVal)
+{
+	pSDMMC->RINTSTS = iVal;
+}
+
+/**
+ * @brief	Sets the SD interface interrupt mask
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	iVal	: Interrupts to enable, Or'ed values MCI_INT_*
+ * @return	None
+ */
+STATIC INLINE void Chip_SDIF_SetIntMask(LPC_SDMMC_T *pSDMMC, uint32_t iVal)
+{
+	pSDMMC->INTMASK = iVal;
+}
+
+/**
+ * @brief	Set block size and byte count for transfer
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	blk_size: block size and byte count in bytes
+ * @return	None
+ */
+STATIC INLINE void Chip_SDIF_SetBlkSizeByteCnt(LPC_SDMMC_T *pSDMMC, uint32_t blk_size)
+{
+	pSDMMC->BLKSIZ = blk_size;
+	pSDMMC->BYTCNT = blk_size;
+}
+
+/**
+ * @brief	Set byte count for transfer
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	bytes	: block size and byte count in bytes
+ * @return	None
+ */
+STATIC INLINE void Chip_SDIF_SetByteCnt(LPC_SDMMC_T *pSDMMC, uint32_t bytes)
+{
+	pSDMMC->BYTCNT = bytes;
+}
+
+/**
+ * @brief	Initializes the SD/MMC card controller
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	None
+ */
+void Chip_SDIF_Init(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Shutdown the SD/MMC card controller
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	None
+ */
+void Chip_SDIF_DeInit(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Function to send command to Card interface unit (CIU)
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	cmd		: Command with all flags set
+ * @param	arg		: Argument for the command
+ * @return	TRUE on times-out, otherwise FALSE
+ */
+int32_t Chip_SDIF_SendCmd(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg);
+
+/**
+ * @brief	Read the response from the last command
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	resp	: Pointer to response array to fill
+ * @return	None
+ */
+void Chip_SDIF_GetResponse(LPC_SDMMC_T *pSDMMC, uint32_t *resp);
+
+/**
+ * @brief	Sets the SD bus clock speed
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	clk_rate	: Input clock rate into the IP block
+ * @param	speed		: Desired clock speed to the card
+ * @return	None
+ */
+void Chip_SDIF_SetClock(LPC_SDMMC_T *pSDMMC, uint32_t clk_rate, uint32_t speed);
+
+/**
+ * @brief	Function to clear interrupt & FIFOs
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	None
+ */
+void Chip_SDIF_SetClearIntFifo(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Setup DMA descriptors
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @param	psdif_dev	: SD interface device
+ * @param	addr		: Address of buffer (source or destination)
+ * @param	size		: size of buffer in bytes (64K max)
+ * @return	None
+ */
+void Chip_SDIF_DmaSetup(LPC_SDMMC_T *pSDMMC, sdif_device *psdif_dev, uint32_t addr, uint32_t size);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDIF_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdio_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/sdio_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdio_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sdio_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,284 @@
+/*
+ * @brief LPC18xx/43xx SD/MMC card driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDIO_18XX_43XX_H_
+#define __SDIO_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SDIO_18XX_43XX CHIP: LPC18xx/43xx SDIO Card driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/** @brief	SDIO Driver events */
+enum SDIO_EVENT
+{
+	SDIO_START_COMMAND,  /**! SDIO driver is about to start a command transfer */
+	SDIO_START_DATA,     /**! SDIO driver is about to start a data transfer */
+	SDIO_WAIT_DELAY,     /**! SDIO driver needs to wait for given milli seconds */
+	SDIO_WAIT_COMMAND,   /**! SDIO driver is waiting for a command to complete */
+	SDIO_WAIT_DATA,      /**! SDIO driver is waiting for data transfer to complete */
+
+	SDIO_CARD_DETECT,    /**! SDIO driver has detected a card */
+	SDIO_CMD_ERR,        /**! Error in command transfer */
+	SDIO_CMD_DONE,       /**! Command transfer successful */
+	SDIO_DATA_ERR,       /**! Data transfer error */
+	SDIO_DATA_DONE,      /**! Data transfer successful */
+	SDIO_CARD_INT,       /**! SDIO Card interrupt (from a function) */
+};
+
+/** @brief	SDIO Command Responses */
+#define SDIO_CMD_RESP_R1     (1UL << 6)
+#define SDIO_CMD_RESP_R2     (3UL << 6)
+#define SDIO_CMD_RESP_R3     (1UL << 6)
+#define SDIO_CMD_RESP_R4     (1UL << 6)
+#define SDIO_CMD_RESP_R5     (1UL << 6)
+#define SDIO_CMD_RESP_R6     (1UL << 6)
+
+/** @brief	SDIO Command misc options */
+#define SDIO_CMD_CRC         (1UL << 8)  /**! Response must have a valid CRC */
+#define SDIO_CMD_DATA        (1UL << 9)  /**! Command is a data transfer command */
+
+/** @brief	List of commands */
+#define CMD0            (0 | (1 << 15))
+#define CMD5            (5 | SDIO_CMD_RESP_R4)
+#define CMD3            (3 | SDIO_CMD_RESP_R6)
+#define CMD7            (7 | SDIO_CMD_RESP_R1)
+#define CMD52           (52 | SDIO_CMD_RESP_R5 | SDIO_CMD_CRC)
+#define CMD53           (53 | SDIO_CMD_RESP_R5 | SDIO_CMD_DATA | SDIO_CMD_CRC)
+
+/** @brief SDIO Error numbers */
+#define SDIO_ERROR           -1 /**! General SDIO Error */
+#define SDIO_ERR_FNUM        -2 /**! Error getting Number of functions supported */
+#define SDIO_ERR_READWRITE   -3 /**! Error when performing Read/write of data */
+#define SDIO_ERR_VOLT        -4 /**! Error Reading or setting up the voltage to 3v3 */
+#define SDIO_ERR_RCA         -5 /**! Error during RCA phase */
+#define SDIO_ERR_INVFUNC     -6 /**! Invalid function argument */
+#define SDIO_ERR_INVARG      -7 /**! Invalid argument supplied to function */
+
+#define SDIO_VOLT_3_3    0x00100000UL  /* for CMD5 */
+
+/* SDIO Data transfer modes */
+/** @brief  Block mode transfer flag
+ * 
+ * When this flag is specified in a transfer the data will be transfered in blocks if not
+ * it will be transfered in bytes. See SDIO_Card_DataRead(), SDIO_Card_DataWrite()
+ * for more information.
+ */
+#define SDIO_MODE_BLOCK       (1UL << 27)
+
+/** @brief Buffer mode transfer flag
+ *
+ * Default mode for SDIO_Card_ReadData() and SDIO_Card_WriteData() is FIFO mode
+ * in FIFO mode all the given data will be written to or read from the same
+ * register address in the function. This flag will set the transfers to BUFFER
+ * mode; in BUFFER mode read first byte will be read from the given source address
+ * and the next byte will be read from the next source address (i.e src_addr + 1),
+ * and so on, in BUFFER mode write first byte will be written to dest_addr, next
+ * byte will be written to dest_addr + 1 and so on.
+ */
+#define SDIO_MODE_BUFFER      (1UL << 26)
+
+/* ---- SDIO Internal map ---- */
+#define SDIO_AREA_CIA			0			/* function 0 */
+
+/* ---- Card Capability(0x08) register ---- */
+#define SDIO_CCCR_LSC			0x40u		/* card is low-speed cards */
+#define SDIO_CCCR_4BLS			0x80u		/* 4-bit support for low-speed cards */
+
+#define SDIO_POWER_INIT  1
+
+#define SDIO_CLK_HISPEED            33000000UL    /* High-Speed Clock	*/
+#define SDIO_CLK_FULLSPEED          16000000UL    /* Full-Speed Clock	*/
+#define SDIO_CLK_LOWSPEED           400000        /* Low-Speed Clock	*/
+
+/**
+ * @brief	Initialize the SDIO card
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	freq		: Initial frequency to use during the enumeration
+ * @return	0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ */
+int SDIO_Card_Init(LPC_SDMMC_T *pSDMMC, uint32_t freq);
+
+/**
+ * @brief	Write 8-Bit register from SDIO register space
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @param	addr		: Address of the register to read
+ * @param	data		: 8-bit data be written
+ * @return	0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ * @note SDIO_Setup_Callback() function must be called to setup the call backs before
+ * calling  this API.
+ */
+int SDIO_Write_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t data);
+
+/**
+ * @brief	Write 8-Bit register from SDIO register space and read the register back
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @param	addr		: Address of the register to read
+ * @param	data		: Pointer to memory where the 8-bit data be stored
+ * @return	0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ * @note	@a data must have the value to be written stored in it when the function is called
+ */
+int SDIO_WriteRead_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data);
+
+/**
+ * @brief	Read an 8-Bit register from SDIO register space
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @param	addr		: Address of the register to read
+ * @param	data		: Pointer to memory where the 8-bit data be stored
+ * @return	0 on Success; > 0 on response error [like CRC error] < 0 on BUS error
+ */
+int SDIO_Read_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data);
+
+/**
+ * @brief	Setup SDIO wait and wakeup callbacks
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	wake_evt	: Wakeup event call-back handler
+ * @param	wait_evt	: Wait event call-back handler
+ * @return	Nothing
+ * @note	@a wake_evt and @a wait_evt should always be non-null function pointers
+ * This function must be called before calling SDIO_Card_Init() function
+ */
+void SDIO_Setup_Callback(LPC_SDMMC_T *pSDMMC,
+	void (*wake_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg),
+	uint32_t (*wait_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg));
+
+/**
+ * @brief	SDIO Event handler [Should be called from SDIO interrupt handler]
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @return	Nothing
+ */
+void SDIO_Handler(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Sends a command to the SDIO Card [Example CMD52]
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	cmd			: Command to be sent along with any flags
+ * @param	arg			: Argument for the command
+ * @return	0 on Success; Non-Zero on failure
+ */
+uint32_t SDIO_Send_Command(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg);
+
+/**
+ * @brief	Gets the block size of a given function
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @return	Block size of the given function
+ * @sa		SDIO_Card_SetBlockSize()
+ * @note	If the return value is 0 then bock size is not set using
+ * SDIO_Card_SetBlockSize(), or given @a func is not valid or the
+ * card does not support block data transfers.
+ */
+uint32_t SDIO_Card_GetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func);
+
+/**
+ * @brief	Sets the block size of a given function
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @param	blkSize		: Block size to set
+ * @return	0 on success; Non-Zero on failure
+ * @sa		SDIO_Card_GetBlockSize()
+ * @note	After setting block size using this API, if
+ * SDIO_Card_GetBlockSize() returns 0 for a valid function then the card
+ * does not support block transfers.
+ */
+int SDIO_Card_SetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t blkSize);
+
+/**
+ * @brief	Writes stream or block of data to the SDIO card [Using CMD53]
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @param	dest_addr	: Address where the data to be written (inside @a func register space)
+ * @param	src_addr	: Buffer from which data to be taken
+ * @param	size		: Number of Bytes/Blocks to be transfered [Must be in the range 1 to 512]
+ * @param	flags		: Or-ed value of #SDIO_MODE_BLOCK, #SDIO_MODE_BUFFER
+ * @return	0 on success; Non-Zero on failure
+ * @note	When #SDIO_MODE_BLOCK is set in @a flags the size is number of blocks, so
+ * the number of bytes transferd will be @a size * "block size" [See SDIO_Card_GetBlockSize() and
+ * SDIO_Card_SetBlockSize() for more information]
+ */
+int SDIO_Card_WriteData(LPC_SDMMC_T *pSDMMC, uint32_t func,
+	uint32_t dest_addr, const uint8_t *src_addr,
+	uint32_t size, uint32_t flags);
+
+/**
+ * @brief	Reads stream or block of data from the SDIO card [Using CMD53]
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @param	dest_addr	: memory where the data to be read into
+ * @param	src_addr	: Register address from which data to be read  (inside @a func register space)
+ * @param	size		: Number of Bytes/Blocks to be transfered [Must be in the range 1 to 512]
+ * @param	flags		: Or-ed value of #SDIO_MODE_BLOCK, #SDIO_MODE_BUFFER
+ * @return	0 on success; Non-Zero on failure
+ * @note	When #SDIO_MODE_BLOCK is set in @a flags the size is number of blocks, so
+ * the number of bytes transferd will be @a size * "block size" [See SDIO_Card_GetBlockSize() and
+ * SDIO_Card_SetBlockSize() for more information]
+ */
+int SDIO_Card_ReadData(LPC_SDMMC_T *pSDMMC, uint32_t func,
+	uint8_t *dest_addr, uint32_t src_addr,
+	uint32_t size, uint32_t flags);
+
+/**
+ * @brief	Disable SDIO interrupt for a given function
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @return	0 - on success; Non zero on failure
+ */
+int SDIO_Card_DisableInt(LPC_SDMMC_T *pSDMMC, uint32_t func);
+
+/**
+ * @brief	Enable SDIO interrupt for a given function
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	func		: function number [0 to 7] [0 = CIA function]
+ * @return	0 - on success; Non zero on failure
+ */
+int SDIO_Card_EnableInt(LPC_SDMMC_T *pSDMMC, uint32_t func);
+
+/**
+ * @}
+ */
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDIO_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdmmc_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/sdmmc_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdmmc_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sdmmc_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,157 @@
+/*
+ * @brief LPC18xx/43xx SD/MMC card driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDMMC_18XX_43XX_H_
+#define __SDMMC_18XX_43XX_H_
+
+#include "sdmmc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SDMMC_18XX_43XX CHIP: LPC18xx/43xx SD/MMC driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define CMD_MASK_RESP       (0x3UL << 28)
+#define CMD_RESP(r)         (((r) & 0x3) << 28)
+#define CMD_RESP_R0         (0 << 28)
+#define CMD_RESP_R1         (1 << 28)
+#define CMD_RESP_R2         (2 << 28)
+#define CMD_RESP_R3         (3 << 28)
+#define CMD_BIT_AUTO_STOP   (1 << 24)
+#define CMD_BIT_APP         (1 << 23)
+#define CMD_BIT_INIT        (1 << 22)
+#define CMD_BIT_BUSY        (1 << 21)
+#define CMD_BIT_LS          (1 << 20)	/* Low speed, used during acquire */
+#define CMD_BIT_DATA        (1 << 19)
+#define CMD_BIT_WRITE       (1 << 18)
+#define CMD_BIT_STREAM      (1 << 17)
+#define CMD_MASK_CMD        (0xff)
+#define CMD_SHIFT_CMD       (0)
+
+#define CMD(c, r)        ( ((c) &  CMD_MASK_CMD) | CMD_RESP((r)) )
+
+#define CMD_IDLE            CMD(MMC_GO_IDLE_STATE, 0) | CMD_BIT_LS    | CMD_BIT_INIT
+#define CMD_SD_OP_COND      CMD(SD_APP_OP_COND, 1)      | CMD_BIT_LS | CMD_BIT_APP
+#define CMD_SD_SEND_IF_COND CMD(SD_CMD8, 1)      | CMD_BIT_LS
+#define CMD_MMC_OP_COND     CMD(MMC_SEND_OP_COND, 3)    | CMD_BIT_LS | CMD_BIT_INIT
+#define CMD_ALL_SEND_CID    CMD(MMC_ALL_SEND_CID, 2)    | CMD_BIT_LS
+#define CMD_MMC_SET_RCA     CMD(MMC_SET_RELATIVE_ADDR, 1) | CMD_BIT_LS
+#define CMD_SD_SEND_RCA     CMD(SD_SEND_RELATIVE_ADDR, 1) | CMD_BIT_LS
+#define CMD_SEND_CSD        CMD(MMC_SEND_CSD, 2) | CMD_BIT_LS
+#define CMD_SEND_EXT_CSD    CMD(MMC_SEND_EXT_CSD, 1) | CMD_BIT_LS | CMD_BIT_DATA
+#define CMD_DESELECT_CARD   CMD(MMC_SELECT_CARD, 0)
+#define CMD_SELECT_CARD     CMD(MMC_SELECT_CARD, 1)
+#define CMD_SET_BLOCKLEN    CMD(MMC_SET_BLOCKLEN, 1)
+#define CMD_SEND_STATUS     CMD(MMC_SEND_STATUS, 1)
+#define CMD_READ_SINGLE     CMD(MMC_READ_SINGLE_BLOCK, 1) | CMD_BIT_DATA
+#define CMD_READ_MULTIPLE   CMD(MMC_READ_MULTIPLE_BLOCK, 1) | CMD_BIT_DATA | CMD_BIT_AUTO_STOP
+#define CMD_SD_SET_WIDTH    CMD(SD_APP_SET_BUS_WIDTH, 1) | CMD_BIT_APP
+#define CMD_STOP            CMD(MMC_STOP_TRANSMISSION, 1) | CMD_BIT_BUSY
+#define CMD_WRITE_SINGLE    CMD(MMC_WRITE_BLOCK, 1) | CMD_BIT_DATA | CMD_BIT_WRITE
+#define CMD_WRITE_MULTIPLE  CMD(MMC_WRITE_MULTIPLE_BLOCK, 1) | CMD_BIT_DATA | CMD_BIT_WRITE | CMD_BIT_AUTO_STOP
+
+/* Card specific setup data */
+typedef struct _mci_card_struct {
+	sdif_device sdif_dev;
+	SDMMC_CARD_T card_info;
+} mci_card_struct;
+
+/**
+ * @brief	Get card's current state (idle, transfer, program, etc.)
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	Current SD card transfer state
+ */
+int32_t Chip_SDMMC_GetState(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Function to enumerate the SD/MMC/SDHC/MMC+ cards
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	pcardinfo	: Pointer to pre-allocated card info structure
+ * @return	1 if a card is acquired, otherwise 0
+ */
+uint32_t Chip_SDMMC_Acquire(LPC_SDMMC_T *pSDMMC, mci_card_struct *pcardinfo);
+
+/**
+ * @brief	Get the device size of SD/MMC card (after enumeration)
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	Card size in number of bytes (capacity)
+ */
+uint64_t Chip_SDMMC_GetDeviceSize(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Get the number of device blocks of SD/MMC card (after enumeration)
+ * Since Chip_SDMMC_GetDeviceSize is limited to 32 bits cards with greater than
+ * 2 GBytes of data will not be correct, in such cases users can use this function
+ * to get the size of the card in blocks.
+ * @param	pSDMMC	: SDMMC peripheral selected
+ * @return	Number of 512 bytes blocks in the card
+ */
+int32_t Chip_SDMMC_GetDeviceBlocks(LPC_SDMMC_T *pSDMMC);
+
+/**
+ * @brief	Performs the read of data from the SD/MMC card
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	buffer		: Pointer to data buffer to copy to
+ * @param	start_block	: Start block number
+ * @param	num_blocks	: Number of block to read
+ * @return	Bytes read, or 0 on error
+ */
+int32_t Chip_SDMMC_ReadBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks);
+
+/**
+ * @brief	Performs write of data to the SD/MMC card
+ * @param	pSDMMC		: SDMMC peripheral selected
+ * @param	buffer		: Pointer to data buffer to copy to
+ * @param	start_block	: Start block number
+ * @param	num_blocks	: Number of block to write
+ * @return	Number of bytes actually written, or 0 on error
+ */
+int32_t Chip_SDMMC_WriteBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDMMC_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdmmc.h ./libs/vendor_libs/lpc_chip_43xx/inc/sdmmc.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sdmmc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sdmmc.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,456 @@
+/*
+ * @brief    Common definitions used in SD/MMC cards
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SDMMC_H
+#define __SDMMC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CHIP_SDMMC_Definitions CHIP: Common SD/MMC definitions
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief OCR Register definitions
+ */
+/** Support voltage range 2.0-2.1 (this bit is reserved in SDC)*/
+#define SDC_OCR_20_21               (((uint32_t) 1) << 8)
+/** Support voltage range 2.1-2.2 (this bit is reserved in SDC)*/
+#define SDC_OCR_21_22               (((uint32_t) 1) << 9)
+/** Support voltage range 2.2-2.3 (this bit is reserved in SDC)*/
+#define SDC_OCR_22_23               (((uint32_t) 1) << 10)
+/** Support voltage range 2.3-2.4 (this bit is reserved in SDC)*/
+#define SDC_OCR_23_24               (((uint32_t) 1) << 11)
+/** Support voltage range 2.4-2.5 (this bit is reserved in SDC)*/
+#define SDC_OCR_24_25               (((uint32_t) 1) << 12)
+/** Support voltage range 2.5-2.6 (this bit is reserved in SDC)*/
+#define SDC_OCR_25_26               (((uint32_t) 1) << 13)
+/** Support voltage range 2.6-2.7 (this bit is reserved in SDC)*/
+#define SDC_OCR_26_27               (((uint32_t) 1) << 14)
+/** Support voltage range 2.7-2.8 */
+#define SDC_OCR_27_28               (((uint32_t) 1) << 15)
+/** Support voltage range 2.8-2.9*/
+#define SDC_OCR_28_29               (((uint32_t) 1) << 16)
+/** Support voltage range 2.9-3.0 */
+#define SDC_OCR_29_30               (((uint32_t) 1) << 17)
+/** Support voltage range 3.0-3.1 */
+#define SDC_OCR_30_31               (((uint32_t) 1) << 18)
+/** Support voltage range 3.1-3.2 */
+#define SDC_OCR_31_32               (((uint32_t) 1) << 19)
+/** Support voltage range 3.2-3.3 */
+#define SDC_OCR_32_33               (((uint32_t) 1) << 20)
+/** Support voltage range 3.3-3.4 */
+#define SDC_OCR_33_34               (((uint32_t) 1) << 21)
+/** Support voltage range 3.4-3.5 */
+#define SDC_OCR_34_35               (((uint32_t) 1) << 22)
+/** Support voltage range 3.5-3.6 */
+#define SDC_OCR_35_36               (((uint32_t) 1) << 23)
+/** Support voltage range 2.7-3.6 */
+#define SDC_OCR_27_36               ((uint32_t) 0x00FF8000)
+/** Card Capacity Status (CCS). (this bit is reserved in MMC) */
+#define SDC_OCR_HC_CCS              (((uint32_t) 1) << 30)
+/** Card power up status bit */
+#define SDC_OCR_IDLE                (((uint32_t) 1) << 31)
+#define SDC_OCR_BUSY                (((uint32_t) 0) << 31)
+
+/* SD/MMC commands - this matrix shows the command, response types, and
+   supported card type for that command.
+   Command                 Number Resp  SD  MMC
+   ----------------------- ------ ----- --- ---
+   Reset (go idle)         CMD0   NA    x   x
+   Send op condition       CMD1   R3        x
+   All send CID            CMD2   R2    x   x
+   Send relative address   CMD3   R1        x
+   Send relative address   CMD3   R6    x
+   Program DSR             CMD4   NA        x
+   Select/deselect card    CMD7   R1b       x
+   Select/deselect card    CMD7   R1    x
+   Send CSD                CMD9   R2    x   x
+   Send CID                CMD10  R2    x   x
+   Read data until stop    CMD11  R1    x   x
+   Stop transmission       CMD12  R1/b  x   x
+   Send status             CMD13  R1    x   x
+   Go inactive state       CMD15  NA    x   x
+   Set block length        CMD16  R1    x   x
+   Read single block       CMD17  R1    x   x
+   Read multiple blocks    CMD18  R1    x   x
+   Write data until stop   CMD20  R1        x
+   Setblock count          CMD23  R1        x
+   Write single block      CMD24  R1    x   x
+   Write multiple blocks   CMD25  R1    x   x
+   Program CID             CMD26  R1        x
+   Program CSD             CMD27  R1    x   x
+   Set write protection    CMD28  R1b   x   x
+   Clear write protection  CMD29  R1b   x   x
+   Send write protection   CMD30  R1    x   x
+   Erase block start       CMD32  R1    x
+   Erase block end         CMD33  R1    x
+   Erase block start       CMD35  R1        x
+   Erase block end         CMD36  R1        x
+   Erase blocks            CMD38  R1b       x
+   Fast IO                 CMD39  R4        x
+   Go IRQ state            CMD40  R5        x
+   Lock/unlock             CMD42  R1b       x
+   Application command     CMD55  R1        x
+   General command         CMD56  R1b       x
+
+ *** SD card application commands - these must be preceded with ***
+ *** MMC CMD55 application specific command first               ***
+   Set bus width           ACMD6  R1    x
+   Send SD status          ACMD13 R1    x
+   Send number WR blocks   ACMD22 R1    x
+   Set WR block erase cnt  ACMD23 R1    x
+   Send op condition       ACMD41 R3    x
+   Set clear card detect   ACMD42 R1    x
+   Send CSR                ACMD51 R1    x */
+
+/**
+ * @brief  SD/MMC application specific commands for SD cards only - these
+ * must be preceded by the SDMMC CMD55 to work correctly
+ */
+typedef enum {
+	SD_SET_BUS_WIDTH,		/*!< Set the SD bus width */
+	SD_SEND_STATUS,			/*!< Send the SD card status */
+	SD_SEND_WR_BLOCKS,		/*!< Send the number of written clocks */
+	SD_SET_ERASE_COUNT,		/*!< Set the number of blocks to pre-erase */
+	SD_SENDOP_COND,			/*!< Send the OCR register (init) */
+	SD_CLEAR_CARD_DET,		/*!< Set or clear the 50K detect pullup */
+	SD_SEND_SCR,			/*!< Send the SD configuration register */
+	SD_INVALID_APP_CMD		/*!< Invalid SD application command */
+} SD_APP_CMD_T;
+
+/**
+ * @brief  Possible SDMMC response types
+ */
+typedef enum {
+	SDMMC_RESPONSE_R1,		/*!< Typical status */
+	SDMMC_RESPONSE_R1B,		/*!< Typical status with busy */
+	SDMMC_RESPONSE_R2,		/*!< CID/CSD registers (CMD2 and CMD10) */
+	SDMMC_RESPONSE_R3,		/*!< OCR register (CMD1, ACMD41) */
+	SDMMC_RESPONSE_R4,		/*!< Fast IO response word */
+	SDMMC_RESPONSE_R5,		/*!< Go IRQ state response word */
+	SDMMC_RESPONSE_R6,		/*!< Published RCA response */
+	SDMMC_RESPONSE_NONE		/*!< No response expected */
+} SDMMC_RESPONSE_T;
+
+/**
+ * @brief  Possible SDMMC card state types
+ */
+typedef enum {
+	SDMMC_IDLE_ST = 0,	/*!< Idle state */
+	SDMMC_READY_ST,		/*!< Ready state */
+	SDMMC_IDENT_ST,		/*!< Identification State */
+	SDMMC_STBY_ST,		/*!< standby state */
+	SDMMC_TRAN_ST,		/*!< transfer state */
+	SDMMC_DATA_ST,		/*!< Sending-data State */
+	SDMMC_RCV_ST,		/*!< Receive-data State */
+	SDMMC_PRG_ST,		/*!< Programming State */
+	SDMMC_DIS_ST		/*!< Disconnect State */
+} SDMMC_STATE_T;
+
+/* Function prototype for event setup function */
+typedef void (*SDMMC_EVSETUP_FUNC_T)(void *);
+
+/* Function prototype for wait for event function */
+typedef uint32_t (*SDMMC_EVWAIT_FUNC_T)(void);
+
+/* Function prototype for milliSecond delay function */
+typedef void (*SDMMC_MSDELAY_FUNC_T)(uint32_t);
+
+/**
+ * @brief SD/MMC Card specific setup data structure
+ */
+typedef struct {
+	uint32_t response[4];						/*!< Most recent response */
+	uint32_t cid[4];							/*!< CID of acquired card  */
+	uint32_t csd[4];							/*!< CSD of acquired card */
+	uint32_t ext_csd[512 / 4];					/*!< Ext CSD */
+	uint32_t card_type;							/*!< Card Type */
+	uint16_t rca;								/*!< Relative address assigned to card */
+	uint32_t speed;								/*!< Speed */
+	uint32_t block_len;							/*!< Card sector size */
+	uint64_t device_size;						/*!< Device Size */
+	uint32_t blocknr;							/*!< Block Number */
+	uint32_t clk_rate;							/*! Clock rate */
+	SDMMC_EVSETUP_FUNC_T evsetup_cb;			/*!< Function to setup event information */
+	SDMMC_EVWAIT_FUNC_T waitfunc_cb;			/*!< Function to wait for event */
+	SDMMC_MSDELAY_FUNC_T msdelay_func;			/*!< Function to sleep in ms */
+} SDMMC_CARD_T;
+
+/**
+ * @brief SD/MMC commands, arguments and responses
+ * Standard SD/MMC commands (3.1)       type  argument     response
+ */
+/* class 1 */
+#define MMC_GO_IDLE_STATE         0		/* bc                          */
+#define MMC_SEND_OP_COND          1		/* bcr  [31:0]  OCR        R3  */
+#define MMC_ALL_SEND_CID          2		/* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3		/* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4		/* bc   [31:16] RCA            */
+#define MMC_SELECT_CARD           7		/* ac   [31:16] RCA        R1  */
+#define MMC_SEND_EXT_CSD          8		/* bc                      R1  */
+#define MMC_SEND_CSD              9		/* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10		/* ac   [31:16] RCA        R2  */
+#define MMC_STOP_TRANSMISSION    12		/* ac                      R1b */
+#define MMC_SEND_STATUS          13		/* ac   [31:16] RCA        R1  */
+#define MMC_GO_INACTIVE_STATE    15		/* ac   [31:16] RCA            */
+
+/* class 2 */
+#define MMC_SET_BLOCKLEN         16		/* ac   [31:0]  block len  R1  */
+#define MMC_READ_SINGLE_BLOCK    17		/* adtc [31:0]  data addr  R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18		/* adtc [31:0]  data addr  R1  */
+
+/* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20		/* adtc [31:0]  data addr  R1  */
+
+/* class 4 */
+#define MMC_SET_BLOCK_COUNT      23		/* adtc [31:0]  data addr  R1  */
+#define MMC_WRITE_BLOCK          24		/* adtc [31:0]  data addr  R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25		/* adtc                    R1  */
+#define MMC_PROGRAM_CID          26		/* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27		/* adtc                    R1  */
+
+/* class 6 */
+#define MMC_SET_WRITE_PROT       28		/* ac   [31:0]  data addr  R1b */
+#define MMC_CLR_WRITE_PROT       29		/* ac   [31:0]  data addr  R1b */
+#define MMC_SEND_WRITE_PROT      30		/* adtc [31:0]  wpdata addr R1  */
+
+/* class 5 */
+#define MMC_ERASE_GROUP_START    35		/* ac   [31:0]  data addr  R1  */
+#define MMC_ERASE_GROUP_END      36		/* ac   [31:0]  data addr  R1  */
+#define MMC_ERASE                37		/* ac                      R1b */
+#define SD_ERASE_WR_BLK_START    32		/* ac   [31:0]  data addr  R1  */
+#define SD_ERASE_WR_BLK_END      33		/* ac   [31:0]  data addr  R1  */
+#define SD_ERASE                 38		/* ac                      R1b */
+
+/* class 9 */
+#define MMC_FAST_IO              39		/* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40		/* bcr                     R5  */
+
+/* class 7 */
+#define MMC_LOCK_UNLOCK          42		/* adtc                    R1b */
+
+/* class 8 */
+#define MMC_APP_CMD              55		/* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56		/* adtc [0]     RD/WR      R1b */
+
+/* SD commands                           type  argument     response */
+/* class 8 */
+/* This is basically the same command as for MMC with some quirks. */
+#define SD_SEND_RELATIVE_ADDR     3		/* ac                      R6  */
+#define SD_CMD8                   8		/* bcr  [31:0]  OCR        R3  */
+
+/* Application commands */
+#define SD_APP_SET_BUS_WIDTH      6		/* ac   [1:0]   bus width  R1   */
+#define SD_APP_OP_COND           41		/* bcr  [31:0]  OCR        R1 (R4)  */
+#define SD_APP_SEND_SCR          51		/* adtc                    R1   */
+
+/**
+ * @brief MMC status in R1<br>
+ * Type<br>
+ *   e : error bit<br>
+ *   s : status bit<br>
+ *   r : detected and set for the actual command response<br>
+ *   x : detected and set during command execution. the host must poll
+ *       the card by sending status command in order to read these bits.
+ * Clear condition<br>
+ *   a : according to the card state<br>
+ *   b : always related to the previous command. Reception of
+ *       a valid command will clear it (with a delay of one command)<br>
+ *   c : clear by read<br>
+ */
+
+#define R1_OUT_OF_RANGE         (1UL << 31)	/* er, c */
+#define R1_ADDRESS_ERROR        (1 << 30)	/* erx, c */
+#define R1_BLOCK_LEN_ERROR      (1 << 29)	/* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
+#define R1_ERASE_PARAM          (1 << 27)	/* ex, c */
+#define R1_WP_VIOLATION         (1 << 26)	/* erx, c */
+#define R1_CARD_IS_LOCKED       (1 << 25)	/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED   (1 << 24)	/* erx, c */
+#define R1_COM_CRC_ERROR        (1 << 23)	/* er, b */
+#define R1_ILLEGAL_COMMAND      (1 << 22)	/* er, b */
+#define R1_CARD_ECC_FAILED      (1 << 21)	/* ex, c */
+#define R1_CC_ERROR             (1 << 20)	/* erx, c */
+#define R1_ERROR                (1 << 19)	/* erx, c */
+#define R1_UNDERRUN             (1 << 18)	/* ex, c */
+#define R1_OVERRUN              (1 << 17)	/* ex, c */
+#define R1_CID_CSD_OVERWRITE    (1 << 16)	/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP        (1 << 15)	/* sx, c */
+#define R1_CARD_ECC_DISABLED    (1 << 14)	/* sx, a */
+#define R1_ERASE_RESET          (1 << 13)	/* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)     ((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
+#define R1_READY_FOR_DATA       (1 << 8)	/* sx, a */
+#define R1_APP_CMD              (1 << 5)	/* sr, c */
+
+/**
+ * @brief SD/MMC card OCR register bits
+ */
+#define OCR_ALL_READY           (1UL << 31)	/* Card Power up status bit */
+#define OCR_HC_CCS              (1 << 30)	/* High capacity card */
+#define OCR_VOLTAGE_RANGE_MSK   (0x00FF8000)
+
+#define SD_SEND_IF_ARG          0x000001AA
+#define SD_SEND_IF_ECHO_MSK     0x000000FF
+#define SD_SEND_IF_RESP         0x000000AA
+
+/**
+ * @brief R3 response definitions
+ */
+#define CMDRESP_R3_OCR_VAL(n)           (((uint32_t) n) & 0xFFFFFF)
+#define CMDRESP_R3_S18A                 (((uint32_t) 1 ) << 24)
+#define CMDRESP_R3_HC_CCS               (((uint32_t) 1 ) << 30)
+#define CMDRESP_R3_INIT_COMPLETE        (((uint32_t) 1 ) << 31)
+
+/**
+ * @brief R6 response definitions
+ */
+#define CMDRESP_R6_RCA_VAL(n)           (((uint32_t) (n >> 16)) & 0xFFFF)
+#define CMDRESP_R6_CARD_STATUS(n)       (((uint32_t) (n & 0x1FFF)) | \
+										 ((n & (1 << 13)) ? (1 << 19) : 0) | \
+										 ((n & (1 << 14)) ? (1 << 22) : 0) | \
+										 ((n & (1 << 15)) ? (1 << 23) : 0))
+
+/**
+ * @brief R7 response definitions
+ */
+/** Echo-back of check-pattern */
+#define CMDRESP_R7_CHECK_PATTERN(n)     (((uint32_t) n ) & 0xFF)
+/** Voltage accepted */
+#define CMDRESP_R7_VOLTAGE_ACCEPTED     (((uint32_t) 1 ) << 8)
+
+/**
+ * @brief CMD3 command definitions
+ */
+/** Card Address */
+#define CMD3_RCA(n)         (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief CMD7 command definitions
+ */
+/** Card Address */
+#define CMD7_RCA(n)         (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief CMD8 command definitions
+ */
+/** Check pattern */
+#define CMD8_CHECKPATTERN(n)            (((uint32_t) (n & 0xFF) ) << 0)
+/** Recommended pattern */
+#define CMD8_DEF_PATTERN                    (0xAA)
+/** Voltage supplied.*/
+#define CMD8_VOLTAGESUPPLIED_27_36     (((uint32_t) 1 ) << 8)
+
+/**
+ * @brief CMD9 command definitions
+ */
+#define CMD9_RCA(n)         (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief CMD13 command definitions
+ */
+#define CMD13_RCA(n)            (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief APP_CMD command definitions
+ */
+#define CMD55_RCA(n)            (((uint32_t) (n & 0xFFFF) ) << 16)
+
+/**
+ * @brief ACMD41 command definitions
+ */
+#define ACMD41_OCR(n)                   (((uint32_t) n) & 0xFFFFFF)
+#define ACMD41_S18R                     (((uint32_t) 1 ) << 24)
+#define ACMD41_XPC                      (((uint32_t) 1 ) << 28)
+#define ACMD41_HCS                      (((uint32_t) 1 ) << 30)
+
+/**
+ * @brief ACMD6 command definitions
+ */
+#define ACMD6_BUS_WIDTH(n)              ((uint32_t) n & 0x03)
+#define ACMD6_BUS_WIDTH_1               (0)
+#define ACMD6_BUS_WIDTH_4               (2)
+
+/** @brief Card type defines
+ */
+#define CARD_TYPE_SD    (1 << 0)
+#define CARD_TYPE_4BIT  (1 << 1)
+#define CARD_TYPE_8BIT  (1 << 2)
+#define CARD_TYPE_HC    (OCR_HC_CCS)/*!< high capacity card > 2GB */
+
+/**
+ * @brief SD/MMC sector size in bytes
+ */
+#define MMC_SECTOR_SIZE     512
+
+/**
+ * @brief Typical enumeration clock rate
+ */
+#define SD_MMC_ENUM_CLOCK       400000
+
+/**
+ * @brief Max MMC clock rate
+ */
+#define MMC_MAX_CLOCK           20000000
+
+/**
+ * @brief Type 0 MMC card max clock rate
+ */
+#define MMC_LOW_BUS_MAX_CLOCK   26000000
+
+/**
+ * @brief Type 1 MMC card max clock rate
+ */
+#define MMC_HIGH_BUS_MAX_CLOCK  52000000
+
+/**
+ * @brief Max SD clock rate
+ */
+#define SD_MAX_CLOCK            25000000
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* __SDMMC_H */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sgpio_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/sgpio_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/sgpio_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/sgpio_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,114 @@
+/*
+ * @brief LPC43xx Serial GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SGPIO_43XX_H_
+#define __SGPIO_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SGPIO_43XX CHIP: LPC43xx Serial GPIO driver
+ * @ingroup LPC_CHIP_18XX_43XX_Drivers
+ * This module is present in LPC43xx MCUs only.
+ * @{
+ */
+
+#if defined(CHIP_LPC43XX)
+
+/**
+ * @brief Serial GPIO register block structure
+ */
+typedef struct {						/*!< SGPIO Structure        */
+	__IO uint32_t  OUT_MUX_CFG[16];		/*!< Pin multiplexer configurationregisters. */
+	__IO uint32_t  SGPIO_MUX_CFG[16];	/*!< SGPIO multiplexer configuration registers. */
+	__IO uint32_t  SLICE_MUX_CFG[16];	/*!< Slice multiplexer configuration registers. */
+	__IO uint32_t  REG[16];				/*!< Slice data registers. Eachtime COUNT0 reaches 0x0 the register shifts loading bit 31 withdata captured from DIN(n). DOUT(n) is set to REG(0) */
+	__IO uint32_t  REG_SS[16];			/*!< Slice data shadow registers. Each time POSreaches 0x0 the contents of REG_SS is exchanged with the contentof REG */
+	__IO uint32_t  PRESET[16];			/*!< Reload valueof COUNT0, loaded when COUNT0 reaches 0x0 */
+	__IO uint32_t  COUNT[16];			/*!< Down counter, counts down each clock cycle. */
+	__IO uint32_t  POS[16];				/*!< Each time COUNT0 reaches 0x0 */
+	__IO uint32_t  MASK_A;				/*!< Mask for pattern match function of slice A */
+	__IO uint32_t  MASK_H;				/*!< Mask for pattern match function of slice H */
+	__IO uint32_t  MASK_I;				/*!< Mask for pattern match function of slice I */
+	__IO uint32_t  MASK_P;				/*!< Mask for pattern match function of slice P */
+	__I  uint32_t  GPIO_INREG;			/*!< GPIO input status register */
+	__IO uint32_t  GPIO_OUTREG;			/*!< GPIO output control register */
+	__IO uint32_t  GPIO_OENREG;			/*!< GPIO OE control register */
+	__IO uint32_t  CTRL_ENABLED;		/*!< Enables the slice COUNT counter */
+	__IO uint32_t  CTRL_DISABLED;		/*!< Disables the slice COUNT counter */
+	__I  uint32_t  RESERVED0[823];
+	__O  uint32_t  CLR_EN_0;			/*!< Shift clock interrupt clear mask */
+	__O  uint32_t  SET_EN_0;			/*!< Shift clock interrupt set mask */
+	__I  uint32_t  ENABLE_0;			/*!< Shift clock interrupt enable */
+	__I  uint32_t  STATUS_0;			/*!< Shift clock interrupt status */
+	__O  uint32_t  CTR_STATUS_0;		/*!< Shift clock interrupt clear status */
+	__O  uint32_t  SET_STATUS_0;		/*!< Shift clock interrupt set status */
+	__I  uint32_t  RESERVED1[2];
+	__O  uint32_t  CLR_EN_1;			/*!< Capture clock interrupt clear mask */
+	__O  uint32_t  SET_EN_1;			/*!< Capture clock interrupt set mask */
+	__I  uint32_t  ENABLE_1;			/*!< Capture clock interrupt enable */
+	__I  uint32_t  STATUS_1;			/*!< Capture clock interrupt status */
+	__O  uint32_t  CTR_STATUS_1;		/*!< Capture clock interrupt clear status */
+	__O  uint32_t  SET_STATUS_1;		/*!< Capture clock interrupt set status */
+	__I  uint32_t  RESERVED2[2];
+	__O  uint32_t  CLR_EN_2;			/*!< Pattern match interrupt clear mask */
+	__O  uint32_t  SET_EN_2;			/*!< Pattern match interrupt set mask */
+	__I  uint32_t  ENABLE_2;			/*!< Pattern match interrupt enable */
+	__I  uint32_t  STATUS_2;			/*!< Pattern match interrupt status */
+	__O  uint32_t  CTR_STATUS_2;		/*!< Pattern match interrupt clear status */
+	__O  uint32_t  SET_STATUS_2;		/*!< Pattern match interrupt set status */
+	__I  uint32_t  RESERVED3[2];
+	__O  uint32_t  CLR_EN_3;			/*!< Input interrupt clear mask */
+	__O  uint32_t  SET_EN_3;			/*!< Input bit match interrupt set mask */
+	__I  uint32_t  ENABLE_3;			/*!< Input bit match interrupt enable */
+	__I  uint32_t  STATUS_3;			/*!< Input bit match interrupt status */
+	__O  uint32_t  CTR_STATUS_3;		/*!< Input bit match interrupt clear status */
+	__O  uint32_t  SET_STATUS_3;		/*!< Shift clock interrupt set status */
+} LPC_SGPIO_T;
+
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SGPIO_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/spi_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/spi_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/spi_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/spi_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,422 @@
+/*
+ * @brief LPC43xx SPI driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SPI_43XX_H_
+#define __SPI_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SPI_43XX CHIP: LPC43xx SPI driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * This module is present in LPC43xx MCUs only.
+ * @{
+ */
+#if defined(CHIP_LPC43XX)
+
+/**
+ * @brief SPI register block structure
+ */
+typedef struct {					/*!< SPI Structure          */
+	__IO uint32_t  CR;				/*!< SPI Control Register. This register controls the operation of the SPI. */
+	__I  uint32_t  SR;				/*!< SPI Status Register. This register shows the status of the SPI. */
+	__IO uint32_t  DR;				/*!< SPI Data Register. This bi-directional register provides the transmit and receive data for the SPI. Transmit data is provided to the SPI0 by writing to this register. Data received by the SPI0 can be read from this register. */
+	__IO uint32_t  CCR;				/*!< SPI Clock Counter Register. This register controls the frequency of a master's SCK0. */
+	__I  uint32_t  RESERVED0[3];
+	__IO uint32_t  INT;				/*!< SPI Interrupt Flag. This register contains the interrupt flag for the SPI interface. */
+} LPC_SPI_T;
+
+/*
+ * Macro defines for SPI Control register
+ */
+/* SPI CFG Register BitMask */
+#define SPI_CR_BITMASK       ((uint32_t) 0xFFC)
+/** Enable of controlling the number of bits per transfer  */
+#define SPI_CR_BIT_EN         ((uint32_t) (1 << 2))
+/** Mask of field of bit controlling */
+#define SPI_CR_BITS_MASK      ((uint32_t) 0xF00)
+/** Set the number of bits per a transfer */
+#define SPI_CR_BITS(n)        ((uint32_t) ((n << 8) & 0xF00))	/* n is in range 8-16 */
+/** SPI Clock Phase Select*/
+#define SPI_CR_CPHA_FIRST     ((uint32_t) (0))	/*Capture data on the first edge, Change data on the following edge*/
+#define SPI_CR_CPHA_SECOND    ((uint32_t) (1 << 3))	/*Change data on the first edge, Capture data on the following edge*/
+/** SPI Clock Polarity Select*/
+#define SPI_CR_CPOL_LO        ((uint32_t) (0))	/* The rest state of the clock (between frames) is low.*/
+#define SPI_CR_CPOL_HI        ((uint32_t) (1 << 4))	/* The rest state of the clock (between frames) is high.*/
+/** SPI Slave Mode Select */
+#define SPI_CR_SLAVE_EN       ((uint32_t) 0)
+/** SPI Master Mode Select */
+#define SPI_CR_MASTER_EN      ((uint32_t) (1 << 5))
+/** SPI MSB First mode enable */
+#define SPI_CR_MSB_FIRST_EN   ((uint32_t) 0)	/*Data will be transmitted and received in standard order (MSB first).*/
+/** SPI LSB First mode enable */
+#define SPI_CR_LSB_FIRST_EN   ((uint32_t) (1 << 6))	/*Data will be transmitted and received in reverse order (LSB first).*/
+/** SPI interrupt enable */
+#define SPI_CR_INT_EN         ((uint32_t) (1 << 7))
+
+/*
+ * Macro defines for SPI Status register
+ */
+/** SPI STAT Register BitMask */
+#define SPI_SR_BITMASK        ((uint32_t) 0xF8)
+/** Slave abort Flag */
+#define SPI_SR_ABRT           ((uint32_t) (1 << 3))	/* When 1, this bit indicates that a slave abort has occurred. */
+/* Mode fault Flag */
+#define SPI_SR_MODF           ((uint32_t) (1 << 4))	/* when 1, this bit indicates that a Mode fault error has occurred. */
+/** Read overrun flag*/
+#define SPI_SR_ROVR           ((uint32_t) (1 << 5))	/* When 1, this bit indicates that a read overrun has occurred. */
+/** Write collision flag. */
+#define SPI_SR_WCOL           ((uint32_t) (1 << 6))	/* When 1, this bit indicates that a write collision has occurred.. */
+/** SPI transfer complete flag. */
+#define SPI_SR_SPIF           ((uint32_t) (1 << 7))		/* When 1, this bit indicates when a SPI data transfer is complete.. */
+/** SPI error flag */
+#define SPI_SR_ERROR          (SPI_SR_ABRT | SPI_SR_MODF | SPI_SR_ROVR | SPI_SR_WCOL)
+/*
+ * Macro defines for SPI Test Control Register register
+ */
+/*Enable SPI Test Mode */
+#define SPI_TCR_TEST(n)       ((uint32_t) ((n & 0x3F) << 1))
+
+/*
+ * Macro defines for SPI Interrupt register
+ */
+/** SPI interrupt flag */
+#define SPI_INT_SPIF          ((uint32_t) (1 << 0))
+
+/**
+ * Macro defines for SPI Data register
+ */
+/** Receiver Data  */
+#define SPI_DR_DATA(n)        ((uint32_t) ((n) & 0xFFFF))
+
+/** @brief SPI Mode*/
+typedef enum {
+	SPI_MODE_MASTER = SPI_CR_MASTER_EN,			/* Master Mode */
+	SPI_MODE_SLAVE = SPI_CR_SLAVE_EN,			/* Slave Mode */
+} SPI_MODE_T;
+
+/** @brief SPI Clock Mode*/
+typedef enum {
+	SPI_CLOCK_CPHA0_CPOL0 = SPI_CR_CPOL_LO | SPI_CR_CPHA_FIRST,		/**< CPHA = 0, CPOL = 0 */
+	SPI_CLOCK_CPHA0_CPOL1 = SPI_CR_CPOL_HI | SPI_CR_CPHA_FIRST,		/**< CPHA = 0, CPOL = 1 */
+	SPI_CLOCK_CPHA1_CPOL0 = SPI_CR_CPOL_LO | SPI_CR_CPHA_SECOND,	/**< CPHA = 1, CPOL = 0 */
+	SPI_CLOCK_CPHA1_CPOL1 = SPI_CR_CPOL_HI | SPI_CR_CPHA_SECOND,	/**< CPHA = 1, CPOL = 1 */
+	SPI_CLOCK_MODE0 = SPI_CLOCK_CPHA0_CPOL0,/**< alias */
+	SPI_CLOCK_MODE1 = SPI_CLOCK_CPHA1_CPOL0,/**< alias */
+	SPI_CLOCK_MODE2 = SPI_CLOCK_CPHA0_CPOL1,/**< alias */
+	SPI_CLOCK_MODE3 = SPI_CLOCK_CPHA1_CPOL1,/**< alias */
+} SPI_CLOCK_MODE_T;
+
+/** @brief SPI Data Order Mode*/
+typedef enum {
+	SPI_DATA_MSB_FIRST = SPI_CR_MSB_FIRST_EN,			/* Standard Order */
+	SPI_DATA_LSB_FIRST = SPI_CR_LSB_FIRST_EN,			/* Reverse Order */
+} SPI_DATA_ORDER_T;
+
+/*
+ * @brief Number of bits per frame
+ */
+typedef enum {
+	SPI_BITS_8 = SPI_CR_BITS(8),		/**< 8 bits/frame */
+	SPI_BITS_9 = SPI_CR_BITS(9),		/**< 9 bits/frame */
+	SPI_BITS_10 = SPI_CR_BITS(10),		/**< 10 bits/frame */
+	SPI_BITS_11 = SPI_CR_BITS(11),		/**< 11 bits/frame */
+	SPI_BITS_12 = SPI_CR_BITS(12),		/**< 12 bits/frame */
+	SPI_BITS_13 = SPI_CR_BITS(13),		/**< 13 bits/frame */
+	SPI_BITS_14 = SPI_CR_BITS(14),		/**< 14 bits/frame */
+	SPI_BITS_15 = SPI_CR_BITS(15),		/**< 15 bits/frame */
+	SPI_BITS_16 = SPI_CR_BITS(16),		/**< 16 bits/frame */
+} SPI_BITS_T;
+
+/** SPI callback function type*/
+typedef void (*SPI_CALLBACK_T)(void);
+/*
+ * @brief SPI config format
+ */
+typedef struct {
+	SPI_BITS_T bits;						/*!< bits/frame */
+	SPI_CLOCK_MODE_T clockMode;	/*!< Format config: clock phase/polarity */
+	SPI_DATA_ORDER_T dataOrder;	/*!< Data order (MSB first/LSB first) */
+} SPI_CONFIG_FORMAT_T;
+
+/*
+ * @brief SPI data setup structure
+ */
+typedef struct {
+	uint8_t      *pTxData;					/*!< Pointer to transmit data */
+	uint8_t      *pRxData;					/*!< Pointer to receive data */
+	uint32_t  cnt;							/*!< Transfer counter */
+	uint32_t  length;						/*!< Length of transfer data */
+	SPI_CALLBACK_T    fnBefFrame;				/*!< Function to call before sending frame */
+	SPI_CALLBACK_T    fnAftFrame;				/*!< Function to call after sending frame */
+	SPI_CALLBACK_T    fnBefTransfer;			/*!< Function to call before starting a transfer */
+	SPI_CALLBACK_T    fnAftTransfer;			/*!< Function to call after a transfer complete */
+} SPI_DATA_SETUP_T;
+
+/**
+ * @brief	Get the current status of SPI controller
+ * @return	SPI controller status (Or-ed value of SPI_SR_*)
+ */
+STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
+{
+	return pSPI->SR;
+}
+
+/**
+ * @brief	Send SPI 16-bit data
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	data	: Transmit Data
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SPI_SendFrame(LPC_SPI_T *pSPI, uint16_t data)
+{
+	pSPI->DR = SPI_DR_DATA(data);
+}
+
+/**
+ * @brief	Get received SPI data
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	receive data
+ */
+STATIC INLINE uint16_t Chip_SPI_ReceiveFrame(LPC_SPI_T *pSPI)
+{
+	return SPI_DR_DATA(pSPI->DR);
+}
+
+/**
+ * @brief	Set up output clocks per bit for SPI bus
+ * @param	pSPI		: The base of SPI peripheral on the chip
+ * @param	counter	: the number of SPI peripheral clock cycles that make up an SPI clock
+ * @return	 Nothing
+ * @note	The counter must be an even number greater than or equal to 8. <br>
+ *		The SPI SCK rate = PCLK_SPI / counter.
+ */
+STATIC INLINE void Chip_SPI_SetClockCounter(LPC_SPI_T *pSPI, uint32_t counter)
+{
+	pSPI->CCR = counter;
+}
+
+/**
+ * @brief   Set up the SPI frame format
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	format			: Pointer to Frame format structure
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SPI_SetFormat(LPC_SPI_T *pSPI, SPI_CONFIG_FORMAT_T *format)
+{
+	pSPI->CR = (pSPI->CR & (~0xF1C)) | SPI_CR_BIT_EN | format->bits | format->clockMode | format->dataOrder;
+}
+
+/**
+ * @brief	Get the number of bits transferred in each frame
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	 the number of bits transferred in each frame
+ */
+STATIC INLINE SPI_BITS_T Chip_SPI_GetDataSize(LPC_SPI_T *pSPI)
+{
+	return (pSPI->CR & SPI_CR_BIT_EN) ? ((SPI_BITS_T) (pSPI->CR & SPI_CR_BITS_MASK)) : SPI_BITS_8;
+}
+
+/**
+ * @brief	Get the current CPHA & CPOL setting
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	CPHA & CPOL setting
+ */
+STATIC INLINE SPI_CLOCK_MODE_T Chip_SPI_GetClockMode(LPC_SPI_T *pSPI)
+{
+	return (SPI_CLOCK_MODE_T) (pSPI->CR & (3 << 3));
+}
+
+/**
+ * @brief	Set the SPI working as master or slave mode
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	 Operating mode
+ */
+STATIC INLINE SPI_MODE_T Chip_SPI_GetMode(LPC_SPI_T *pSPI)
+{
+	return (SPI_MODE_T) (pSPI->CR & (1 << 5));
+}
+
+/**
+ * @brief   Set the SPI operating modes, master or slave
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	mode		: master mode/slave mode
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SPI_SetMode(LPC_SPI_T *pSPI, SPI_MODE_T mode)
+{
+	pSPI->CR = (pSPI->CR & (~(1 << 5))) | mode;
+}
+
+/**
+ * @brief   Set the clock frequency for SPI interface
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	bitRate		: The SPI bit rate
+ * @return	Nothing
+ */
+void Chip_SPI_SetBitRate(LPC_SPI_T *pSPI, uint32_t bitRate);
+
+/**
+ * @brief   Enable SPI interrupt
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SPI_Int_Enable(LPC_SPI_T *pSPI)
+{
+	pSPI->CR |= SPI_CR_INT_EN;
+}
+
+/**
+ * @brief   Disable SPI interrupt
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SPI_Int_Disable(LPC_SPI_T *pSPI)
+{
+	pSPI->CR &= ~SPI_CR_INT_EN;
+}
+
+/**
+ * @brief	Get the interrupt status
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	SPI interrupt Status (Or-ed bit value of SPI_INT_*)
+ */
+STATIC INLINE uint32_t Chip_SPI_Int_GetStatus(LPC_SPI_T *pSPI)
+{
+	return pSPI->INT;
+}
+
+/**
+ * @brief	Clear the interrupt status
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	mask	: SPI interrupt mask (Or-ed bit value of SPI_INT_*)
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_SPI_Int_ClearStatus(LPC_SPI_T *pSPI, uint32_t mask)
+{
+	pSPI->INT = mask;
+}
+
+/**
+ * @brief   Initialize the SPI
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SPI_Init(LPC_SPI_T *pSPI);
+
+/**
+ * @brief	Deinitialise the SPI
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ * @note	The SPI controller is disabled
+ */
+void Chip_SPI_DeInit(LPC_SPI_T *pSPI);
+
+/**
+ * @brief   Clean all data in RX FIFO of SPI
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SPI_Int_FlushData(LPC_SPI_T *pSPI);
+
+/**
+ * @brief   SPI Interrupt Read/Write with 8-bit frame width
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	xf_setup		: Pointer to a SPI_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data	configuration
+ * @return	SUCCESS or ERROR
+ */
+Status Chip_SPI_Int_RWFrames8Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SPI Interrupt Read/Write with 16-bit frame width
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	xf_setup		: Pointer to a SPI_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data	configuration
+ * @return	SUCCESS or ERROR
+ */
+Status Chip_SPI_Int_RWFrames16Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SPI Polling Read/Write in blocking mode
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	pXfSetup		: Pointer to a SPI_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data	configuration
+ * @return	Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. It starts with writing phase and after that,
+ * a reading phase is generated to read any data available in RX_FIFO. All needed information is prepared
+ * through xf_setup param.
+ */
+uint32_t Chip_SPI_RWFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup);
+
+/**
+ * @brief   SPI Polling Write in blocking mode
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	buffer			: Buffer address
+ * @param	buffer_len		: Buffer length
+ * @return	Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a writing operation will send
+ * the needed data. After that, a dummy reading operation is generated to clear data buffer
+ */
+uint32_t Chip_SPI_WriteFrames_Blocking(LPC_SPI_T *pSPI, uint8_t *buffer, uint32_t buffer_len);
+
+/**
+ * @brief   SPI Polling Read in blocking mode
+ * @param	pSPI			: The base SPI peripheral on the chip
+ * @param	buffer			: Buffer address
+ * @param	buffer_len		: The length of buffer
+ * @return	Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a dummy writing operation is generated
+ * to clear data buffer. After that, a reading operation will receive the needed data
+ */
+uint32_t Chip_SPI_ReadFrames_Blocking(LPC_SPI_T *pSPI, uint8_t *buffer, uint32_t buffer_len);
+
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SPI_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/spifi_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/spifi_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/spifi_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/spifi_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,355 @@
+/*
+ * @brief LPCSPIFILIB hardware definitions and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SPIFILIB_CHIPHW_H_
+#define __SPIFILIB_CHIPHW_H_
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Define for inline */
+#ifndef INLINE
+#ifdef __CC_ARM
+#define INLINE  __inline
+#else
+#define INLINE inline
+#endif /* __CC_ARM */
+#endif /* !INLINE */
+
+#ifdef __CC_ARM
+#pragma anon_unions
+#endif
+/** @defgroup LPCSPIFILIB_HW_API LPCSPIFILIB hardware definitions and API functions
+ * @ingroup LPCSPIFILIB
+ * @{
+ */
+
+/**
+ * @brief	SPIFI controller hardware register structure
+ */
+
+typedef struct LPC_SPIFI_CHIPHW {
+	volatile    uint32_t CTRL;				/**< SPIFI control register */
+	volatile    uint32_t CMD;					/**< SPIFI command register */
+	volatile    uint32_t ADDR;				/**< SPIFI address register */
+	volatile    uint32_t DATINTM;			/**< SPIFI intermediate data register */
+	volatile    uint32_t CACHELIMIT;	/**< SPIFI cache limit register */
+	union {
+		volatile    uint8_t DAT8;				/**< SPIFI 8 bit data */
+		volatile    uint16_t DAT16;			/**< SPIFI 16 bit data */
+		volatile    uint32_t DAT32;			/**< SPIFI 32 bit data */
+	};
+
+	volatile    uint32_t MEMCMD;			/**< SPIFI memory command register */
+	volatile    uint32_t STAT;				/**< SPIFI status register */
+} LPC_SPIFI_T;
+
+/** @defgroup LPCSPIFILIB_HW_PRIM LPCSPIFILIB primative API functions
+ * @{
+ */
+
+/**
+ * @brief SPIFI controller control register bit definitions
+ */
+#define SPIFI_CTRL_TO(t)        ((t) << 0)		/**< SPIFI timeout */
+#define SPIFI_CTRL_CSHI(c)      ((c) << 16)		/**< SPIFI chip select minimum high time */
+#define SPIFI_CTRL_DATA_PREFETCH_DISABLE(d) ((d) << 21)	/**< SPIFI memMode prefetch enable*/
+#define SPIFI_CTRL_INTEN(i)     ((i) << 22)		/**< SPIFI cmdComplete irq enable */
+#define SPIFI_CTRL_MODE3(m)     ((m) << 23)		/**< SPIFI mode3 config */
+#define SPIFI_CTRL_PREFETCH_DISABLE(d) ((d) << 27)	/**< SPIFI cache prefetch enable */
+#define SPIFI_CTRL_DUAL(d)      ((d) << 28)		/**< SPIFI enable dual */
+#define SPIFI_CTRL_RFCLK(m)     ((m) << 29)		/**< SPIFI clock edge config */
+#define SPIFI_CTRL_FBCLK(m)     ((m) << 30)		/**< SPIFI feedback clock select */
+#define SPIFI_CTRL_DMAEN(m)     ((m) << 31)		/**< SPIFI dma enable */
+
+/**
+ * @brief	Write SPIFI controller control register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	ctrl	: Control value to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetCtrl(LPC_SPIFI_T *pSpifi, uint32_t ctrl)
+{
+	pSpifi->CTRL = ctrl;
+}
+
+/**
+ * @brief	Read SPIFI controller control register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	Current CTRL register values
+ */
+static INLINE uint32_t spifi_HW_GetCtrl(LPC_SPIFI_T *pSpifi)
+{
+	return pSpifi->CTRL;
+}
+
+/**
+ * @brief SPIFI controller status register bit definitions
+ */
+#define SPIFI_STAT_RESET        (1 << 4)		/**< SPIFI reset */
+#define SPIFI_STAT_INTRQ        (1 << 5)		/**< SPIFI interrupt request */
+#define SPIFI_STAT_CMD          (1 << 1)		/**< SPIFI command in progress */
+#define SPIFI_STAT_MCINIT               (1)					/**< SPIFI MCINIT */
+
+/**
+ * @brief	Write SPIFI controller status register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	stat	: Status bits to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetStat(LPC_SPIFI_T *pSpifi, uint32_t stat)
+{
+	pSpifi->STAT = stat;
+}
+
+/**
+ * @brief	Read SPIFI controller status register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	Current STAT register values
+ */
+static INLINE uint32_t spifi_HW_GetStat(LPC_SPIFI_T *pSpifi)
+{
+	return pSpifi->STAT;
+}
+
+/**
+ * @brief SPIFI controller command register bit definitions
+ */
+#define SPIFI_CMD_DATALEN(l)    ((l) << 0)		/**< SPIFI bytes to send or receive */
+#define SPIFI_CMD_POLLRS(p)     ((p) << 14)		/**< SPIFI enable poll */
+#define SPIFI_CMD_DOUT(d)       ((d) << 15)		/**< SPIFI data direction is out */
+#define SPIFI_CMD_INTER(i)      ((i) << 16)		/**< SPIFI intermediate bit length */
+#define SPIFI_CMD_FIELDFORM(p)  ((p) << 19)		/**< SPIFI 2 bit data/cmd mode control */
+#define SPIFI_CMD_FRAMEFORM(f)  ((f) << 21)		/**< SPIFI op and adr field config */
+#define SPIFI_CMD_OPCODE(o)     ((uint32_t) (o) << 24)	/**< SPIFI 8-bit command code */
+
+/**
+ * @brief frame form definitions
+ */
+typedef enum {
+	SPIFI_FRAMEFORM_OP              = 1,
+	SPIFI_FRAMEFORM_OP_1ADDRESS     = 2,
+	SPIFI_FRAMEFORM_OP_2ADDRESS     = 3,
+	SPIFI_FRAMEFORM_OP_3ADDRESS     = 4,
+	SPIFI_FRAMEFORM_OP_4ADDRESS     = 5,
+	SPIFI_FRAMEFORM_NOOP_3ADDRESS   = 6,
+	SPIFI_FRAMEFORM_NOOP_4ADDRESS   = 7
+} SPIFI_FRAMEFORM_T;
+
+/**
+ * @brief serial type definitions
+ */
+typedef enum {
+	SPIFI_FIELDFORM_ALL_SERIAL             = 0,
+	SPIFI_FIELDFORM_SERIAL_OPCODE_ADDRESS  = 1,
+	SPIFI_FIELDFORM_SERIAL_OPCODE          = 2,
+	SPIFI_FIELDFORM_NO_SERIAL              = 3
+} SPIFI_FIELDFORM_T;
+
+/**
+ * @brief	Read SPIFI controller command register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	32-bit value read from the command register
+ */
+static INLINE uint32_t spifi_HW_GetCmd(LPC_SPIFI_T *pSpifi)
+{
+	return pSpifi->CMD;
+}
+
+/**
+ * @brief	Write SPIFI controller command register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	cmd		: Command to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetCmd(LPC_SPIFI_T *pSpifi, uint32_t cmd)
+{
+	pSpifi->CMD = cmd;
+}
+
+/**
+ * @brief	Write SPIFI controller address register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	addr	: address (offset) to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetAddr(LPC_SPIFI_T *pSpifi, uint32_t addr)
+{
+	pSpifi->ADDR = addr;
+}
+
+/**
+ * @brief	Read an 8-bit value from the controller data register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	8-bit value read from the data register
+ */
+static INLINE uint8_t spifi_HW_GetData8(LPC_SPIFI_T *pSpifi)
+{
+	return pSpifi->DAT8;
+}
+
+/**
+ * @brief	Read an 16-bit value from the controller data register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	16-bit value read from the data register
+ */
+static INLINE uint16_t spifi_HW_GetData16(LPC_SPIFI_T *pSpifi)
+{
+	return pSpifi->DAT16;
+}
+
+/**
+ * @brief	Read an 32-bit value from the controller data register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	32-bit value read from the data register
+ */
+static INLINE uint32_t spifi_HW_GetData32(LPC_SPIFI_T *pSpifi)
+{
+	return pSpifi->DAT32;
+}
+
+/**
+ * @brief	Write an 8-bit value from the controller data register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	data	: 8-bit data value to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetData8(LPC_SPIFI_T *pSpifi, uint8_t data)
+{
+	pSpifi->DAT8 = data;
+}
+
+/**
+ * @brief	Write an 16-bit value from the controller data register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	data	: 16-bit data value to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetData16(LPC_SPIFI_T *pSpifi, uint16_t data)
+{
+	pSpifi->DAT16 = data;
+}
+
+/**
+ * @brief	Write an 32-bit value from the controller data register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	data	: 32-bit data value to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetData32(LPC_SPIFI_T *pSpifi, uint32_t data)
+{
+	pSpifi->DAT32 = data;
+}
+
+/**
+ * @brief	Write IDATA register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	mode	: value to write. Used to specify value used for intermediate
+                                    data value when enabled.
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetIDATA(LPC_SPIFI_T *pSpifi, uint32_t mode)
+{
+	pSpifi->DATINTM = mode;
+}
+
+/**
+ * @brief	Write MEMCMD register
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @param	cmd		: Command value to write
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_SetMEMCMD(LPC_SPIFI_T *pSpifi, uint32_t cmd)
+{
+	pSpifi->MEMCMD = cmd;
+}
+
+/**
+ * @}
+ */
+
+/** @defgroup LPCSPIFILIB_HW_L2 LPCSPIFILIB hardware support API functions
+ * @{
+ */
+
+/**
+ * @brief	Reset SPIFI controller
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_ResetController(LPC_SPIFI_T *pSpifi)
+{
+	pSpifi->STAT = SPIFI_STAT_RESET;
+	while ((pSpifi->STAT & SPIFI_STAT_RESET) != 0) {}
+}
+
+/**
+ * @brief	Wait for a command to complete
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_WaitCMD(LPC_SPIFI_T *pSpifi)
+{
+	while ((spifi_HW_GetStat(pSpifi) & SPIFI_STAT_CMD) != 0) {}
+}
+
+/**
+ * @brief	Wait for a RESET bit to clear
+ * @param	pSpifi	: Base address of SPIFI controller
+ * @return	Nothing
+ */
+static INLINE void spifi_HW_WaitRESET(LPC_SPIFI_T *pSpifi)
+{
+	while ((spifi_HW_GetStat(pSpifi) & SPIFI_STAT_RESET) != 0) {}
+}
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SPIFILIB_CHIPHW_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ssp_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/ssp_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/ssp_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/ssp_18xx_43xx.h	2018-12-01 17:15:06.657606643 -0300
@@ -0,0 +1,604 @@
+/*
+ * @brief LPC18xx/43xx SSP driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SSP_18XX_43XX_H_
+#define __SSP_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SSP_18XX_43XX CHIP: LPC18xx/43xx SSP driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief SSP register block structure
+ */
+typedef struct {			/*!< SSPn Structure         */
+	__IO uint32_t CR0;		/*!< Control Register 0. Selects the serial clock rate, bus type, and data size. */
+	__IO uint32_t CR1;		/*!< Control Register 1. Selects master/slave and other modes. */
+	__IO uint32_t DR;		/*!< Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO. */
+	__I  uint32_t SR;		/*!< Status Register        */
+	__IO uint32_t CPSR;		/*!< Clock Prescale Register */
+	__IO uint32_t IMSC;		/*!< Interrupt Mask Set and Clear Register */
+	__I  uint32_t RIS;		/*!< Raw Interrupt Status Register */
+	__I  uint32_t MIS;		/*!< Masked Interrupt Status Register */
+	__O  uint32_t ICR;		/*!< SSPICR Interrupt Clear Register */
+	__IO uint32_t DMACR;	/*!< SSPn DMA control register */
+} LPC_SSP_T;
+
+/**
+ * Macro defines for CR0 register
+ */
+
+/** SSP data size select, must be 4 bits to 16 bits */
+#define SSP_CR0_DSS(n)          ((uint32_t) ((n) & 0xF))
+/** SSP control 0 Motorola SPI mode */
+#define SSP_CR0_FRF_SPI         ((uint32_t) (0 << 4))
+/** SSP control 0 TI synchronous serial mode */
+#define SSP_CR0_FRF_TI          ((uint32_t) (1 << 4))
+/** SSP control 0 National Micro-wire mode */
+#define SSP_CR0_FRF_MICROWIRE   ((uint32_t) (2 << 4))
+/** SPI clock polarity bit (used in SPI mode only), (1) = maintains the
+   bus clock high between frames, (0) = low */
+#define SSP_CR0_CPOL_LO     ((uint32_t) (0))
+#define SSP_CR0_CPOL_HI     ((uint32_t) (1 << 6))
+/** SPI clock out phase bit (used in SPI mode only), (1) = captures data
+   on the second clock transition of the frame, (0) = first */
+#define SSP_CR0_CPHA_FIRST  ((uint32_t) (0))
+#define SSP_CR0_CPHA_SECOND ((uint32_t) (1 << 7))
+/** SSP serial clock rate value load macro, divider rate is
+   PERIPH_CLK / (cpsr * (SCR + 1)) */
+#define SSP_CR0_SCR(n)      ((uint32_t) ((n & 0xFF) << 8))
+/** SSP CR0 bit mask */
+#define SSP_CR0_BITMASK     ((uint32_t) (0xFFFF))
+/** SSP CR0 bit mask */
+#define SSP_CR0_BITMASK     ((uint32_t) (0xFFFF))
+/** SSP serial clock rate value load macro, divider rate is
+   PERIPH_CLK / (cpsr * (SCR + 1)) */
+#define SSP_CR0_SCR(n)      ((uint32_t) ((n & 0xFF) << 8))
+
+/**
+ * Macro defines for CR1 register
+ */
+
+/** SSP control 1 loopback mode enable bit */
+#define SSP_CR1_LBM_EN      ((uint32_t) (1 << 0))
+/** SSP control 1 enable bit */
+#define SSP_CR1_SSP_EN      ((uint32_t) (1 << 1))
+/** SSP control 1 slave enable */
+#define SSP_CR1_SLAVE_EN    ((uint32_t) (1 << 2))
+#define SSP_CR1_MASTER_EN   ((uint32_t) (0))
+/** SSP control 1 slave out disable bit, disables transmit line in slave
+   mode */
+#define SSP_CR1_SO_DISABLE  ((uint32_t) (1 << 3))
+/** SSP CR1 bit mask */
+#define SSP_CR1_BITMASK     ((uint32_t) (0x0F))
+
+/** SSP CPSR bit mask */
+#define SSP_CPSR_BITMASK    ((uint32_t) (0xFF))
+/**
+ * Macro defines for DR register
+ */
+
+/** SSP data bit mask */
+#define SSP_DR_BITMASK(n)   ((n) & 0xFFFF)
+
+/**
+ * Macro defines for SR register
+ */
+
+/** SSP SR bit mask */
+#define SSP_SR_BITMASK  ((uint32_t) (0x1F))
+
+/** ICR bit mask */
+#define SSP_ICR_BITMASK ((uint32_t) (0x03))
+
+/**
+ * @brief SSP Type of Status
+ */
+typedef enum _SSP_STATUS {
+	SSP_STAT_TFE = ((uint32_t)(1 << 0)),/**< TX FIFO Empty */
+	SSP_STAT_TNF = ((uint32_t)(1 << 1)),/**< TX FIFO not full */
+	SSP_STAT_RNE = ((uint32_t)(1 << 2)),/**< RX FIFO not empty */
+	SSP_STAT_RFF = ((uint32_t)(1 << 3)),/**< RX FIFO full */
+	SSP_STAT_BSY = ((uint32_t)(1 << 4)),/**< SSP Busy */
+} SSP_STATUS_T;
+
+/**
+ * @brief SSP Type of Interrupt Mask
+ */
+typedef enum _SSP_INTMASK {
+	SSP_RORIM = ((uint32_t)(1 << 0)),	/**< Overun */
+	SSP_RTIM = ((uint32_t)(1 << 1)),/**< TimeOut */
+	SSP_RXIM = ((uint32_t)(1 << 2)),/**< Rx FIFO is at least half full */
+	SSP_TXIM = ((uint32_t)(1 << 3)),/**< Tx FIFO is at least half empty */
+	SSP_INT_MASK_BITMASK = ((uint32_t)(0xF)),
+} SSP_INTMASK_T;
+
+/**
+ * @brief SSP Type of Mask Interrupt Status
+ */
+typedef enum _SSP_MASKINTSTATUS {
+	SSP_RORMIS = ((uint32_t)(1 << 0)),	/**< Overun */
+	SSP_RTMIS = ((uint32_t)(1 << 1)),	/**< TimeOut */
+	SSP_RXMIS = ((uint32_t)(1 << 2)),	/**< Rx FIFO is at least half full */
+	SSP_TXMIS = ((uint32_t)(1 << 3)),	/**< Tx FIFO is at least half empty */
+	SSP_MASK_INT_STAT_BITMASK = ((uint32_t)(0xF)),
+} SSP_MASKINTSTATUS_T;
+
+/**
+ * @brief SSP Type of Raw Interrupt Status
+ */
+typedef enum _SSP_RAWINTSTATUS {
+	SSP_RORRIS = ((uint32_t)(1 << 0)),	/**< Overun */
+	SSP_RTRIS = ((uint32_t)(1 << 1)),	/**< TimeOut */
+	SSP_RXRIS = ((uint32_t)(1 << 2)),	/**< Rx FIFO is at least half full */
+	SSP_TXRIS = ((uint32_t)(1 << 3)),	/**< Tx FIFO is at least half empty */
+	SSP_RAW_INT_STAT_BITMASK = ((uint32_t)(0xF)),
+} SSP_RAWINTSTATUS_T;
+
+typedef enum _SSP_INTCLEAR {
+	SSP_RORIC = 0x0,
+	SSP_RTIC = 0x1,
+	SSP_INT_CLEAR_BITMASK = 0x3,
+} SSP_INTCLEAR_T;
+
+typedef enum _SSP_DMA {
+	SSP_DMA_RX = (1u),	/**< DMA RX Enable */
+	SSP_DMA_TX = (1u << 1),	/**< DMA TX Enable */
+	SSP_DMA_BITMASK = ((uint32_t)(0x3)),
+} SSP_DMA_T;
+
+/*
+ * @brief SSP clock format
+ */
+typedef enum CHIP_SSP_CLOCK_FORMAT {
+	SSP_CLOCK_CPHA0_CPOL0 = (0 << 6),		/**< CPHA = 0, CPOL = 0 */
+	SSP_CLOCK_CPHA0_CPOL1 = (1u << 6),		/**< CPHA = 0, CPOL = 1 */
+	SSP_CLOCK_CPHA1_CPOL0 = (2u << 6),		/**< CPHA = 1, CPOL = 0 */
+	SSP_CLOCK_CPHA1_CPOL1 = (3u << 6),		/**< CPHA = 1, CPOL = 1 */
+	SSP_CLOCK_MODE0 = SSP_CLOCK_CPHA0_CPOL0,/**< alias */
+	SSP_CLOCK_MODE1 = SSP_CLOCK_CPHA1_CPOL0,/**< alias */
+	SSP_CLOCK_MODE2 = SSP_CLOCK_CPHA0_CPOL1,/**< alias */
+	SSP_CLOCK_MODE3 = SSP_CLOCK_CPHA1_CPOL1,/**< alias */
+} CHIP_SSP_CLOCK_MODE_T;
+
+/*
+ * @brief SSP frame format
+ */
+typedef enum CHIP_SSP_FRAME_FORMAT {
+	SSP_FRAMEFORMAT_SPI = (0 << 4),			/**< Frame format: SPI */
+	CHIP_SSP_FRAME_FORMAT_TI = (1u << 4),			/**< Frame format: TI SSI */
+	SSP_FRAMEFORMAT_MICROWIRE = (2u << 4),	/**< Frame format: Microwire */
+} CHIP_SSP_FRAME_FORMAT_T;
+
+/*
+ * @brief Number of bits per frame
+ */
+typedef enum CHIP_SSP_BITS {
+	SSP_BITS_4 = (3u << 0),		/*!< 4 bits/frame */
+	SSP_BITS_5 = (4u << 0),		/*!< 5 bits/frame */
+	SSP_BITS_6 = (5u << 0),		/*!< 6 bits/frame */
+	SSP_BITS_7 = (6u << 0),		/*!< 7 bits/frame */
+	SSP_BITS_8 = (7u << 0),		/*!< 8 bits/frame */
+	SSP_BITS_9 = (8u << 0),		/*!< 9 bits/frame */
+	SSP_BITS_10 = (9u << 0),	/*!< 10 bits/frame */
+	SSP_BITS_11 = (10u << 0),	/*!< 11 bits/frame */
+	SSP_BITS_12 = (11u << 0),	/*!< 12 bits/frame */
+	SSP_BITS_13 = (12u << 0),	/*!< 13 bits/frame */
+	SSP_BITS_14 = (13u << 0),	/*!< 14 bits/frame */
+	SSP_BITS_15 = (14u << 0),	/*!< 15 bits/frame */
+	SSP_BITS_16 = (15u << 0),	/*!< 16 bits/frame */
+} CHIP_SSP_BITS_T;
+
+/*
+ * @brief SSP config format
+ */
+typedef struct SSP_ConfigFormat {
+	CHIP_SSP_BITS_T bits;					/*!< Format config: bits/frame */
+	CHIP_SSP_CLOCK_MODE_T clockMode;	/*!< Format config: clock phase/polarity */
+	CHIP_SSP_FRAME_FORMAT_T frameFormat;	/*!< Format config: SPI/TI/Microwire */
+} SSP_ConfigFormat;
+
+/**
+ * @brief	Enable SSP operation
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_Enable(LPC_SSP_T *pSSP)
+{
+	pSSP->CR1 |= SSP_CR1_SSP_EN;
+}
+
+/**
+ * @brief	Disable SSP operation
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_Disable(LPC_SSP_T *pSSP)
+{
+	pSSP->CR1 &= (~SSP_CR1_SSP_EN) & SSP_CR1_BITMASK;
+}
+
+/**
+ * @brief	Enable loopback mode
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ * @note	Serial input is taken from the serial output (MOSI or MISO) rather
+ * than the serial input pin
+ */
+STATIC INLINE void Chip_SSP_EnableLoopBack(LPC_SSP_T *pSSP)
+{
+	pSSP->CR1 |= SSP_CR1_LBM_EN;
+}
+
+/**
+ * @brief	Disable loopback mode
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ * @note	Serial input is taken from the serial output (MOSI or MISO) rather
+ * than the serial input pin
+ */
+STATIC INLINE void Chip_SSP_DisableLoopBack(LPC_SSP_T *pSSP)
+{
+	pSSP->CR1 &= (~SSP_CR1_LBM_EN) & SSP_CR1_BITMASK;
+}
+
+/**
+ * @brief	Get the current status of SSP controller
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @param	Stat	: Type of status, should be :
+ *						- SSP_STAT_TFE
+ *						- SSP_STAT_TNF
+ *						- SSP_STAT_RNE
+ *						- SSP_STAT_RFF
+ *						- SSP_STAT_BSY
+ * @return	 SSP controller status, SET or RESET
+ */
+STATIC INLINE FlagStatus Chip_SSP_GetStatus(LPC_SSP_T *pSSP, SSP_STATUS_T Stat)
+{
+	return (pSSP->SR & Stat) ? SET : RESET;
+}
+
+/**
+ * @brief	Get the masked interrupt status
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @return	 SSP Masked Interrupt Status Register value
+ * @note	The return value contains a 1 for each interrupt condition that is asserted and enabled (masked)
+ */
+STATIC INLINE uint32_t Chip_SSP_GetIntStatus(LPC_SSP_T *pSSP)
+{
+	return pSSP->MIS;
+}
+
+/**
+ * @brief	Get the raw interrupt status
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @param	RawInt	: Interrupt condition to be get status, shoud be :
+ *						- SSP_RORRIS
+ *						- SSP_RTRIS
+ *						- SSP_RXRIS
+ *						- SSP_TXRIS
+ * @return	 Raw interrupt status corresponding to interrupt condition , SET or RESET
+ * @note	Get the status of each interrupt condition ,regardless of whether or not the interrupt is enabled
+ */
+STATIC INLINE IntStatus Chip_SSP_GetRawIntStatus(LPC_SSP_T *pSSP, SSP_RAWINTSTATUS_T RawInt)
+{
+	return (pSSP->RIS & RawInt) ? SET : RESET;
+}
+
+/**
+ * @brief	Get the number of bits transferred in each frame
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @return	 the number of bits transferred in each frame minus one
+ * @note	The return value is 0x03 -> 0xF corresponding to 4bit -> 16bit transfer
+ */
+STATIC INLINE uint8_t Chip_SSP_GetDataSize(LPC_SSP_T *pSSP)
+{
+	return SSP_CR0_DSS(pSSP->CR0);
+}
+
+/**
+ * @brief	Clear the corresponding interrupt condition(s) in the SSP controller
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @param	IntClear: Type of cleared interrupt, should be :
+ *						- SSP_RORIC
+ *						- SSP_RTIC
+ * @return	 Nothing
+ * @note	Software can clear one or more interrupt condition(s) in the SSP controller
+ */
+STATIC INLINE void Chip_SSP_ClearIntPending(LPC_SSP_T *pSSP, SSP_INTCLEAR_T IntClear)
+{
+	pSSP->ICR = IntClear;
+}
+
+/**
+ * @brief	Enable interrupt for the SSP
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_Int_Enable(LPC_SSP_T *pSSP)
+{
+	pSSP->IMSC |= SSP_TXIM;
+}
+
+/**
+ * @brief	Disable interrupt for the SSP
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_Int_Disable(LPC_SSP_T *pSSP)
+{
+	pSSP->IMSC &= (~SSP_TXIM);
+}
+
+/**
+ * @brief	Get received SSP data
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @return	 SSP 16-bit data received
+ */
+STATIC INLINE uint16_t Chip_SSP_ReceiveFrame(LPC_SSP_T *pSSP)
+{
+	return (uint16_t) (SSP_DR_BITMASK(pSSP->DR));
+}
+
+/**
+ * @brief	Send SSP 16-bit data
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @param	tx_data	: SSP 16-bit data to be transmited
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_SendFrame(LPC_SSP_T *pSSP, uint16_t tx_data)
+{
+	pSSP->DR = SSP_DR_BITMASK(tx_data);
+}
+
+/**
+ * @brief	Set up output clocks per bit for SSP bus
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @param	clk_rate	fs: The number of prescaler-output clocks per bit on the bus, minus one
+ * @param	prescale	: The factor by which the Prescaler divides the SSP peripheral clock PCLK
+ * @return	 Nothing
+ * @note	The bit frequency is PCLK / (prescale x[clk_rate+1])
+ */
+void Chip_SSP_SetClockRate(LPC_SSP_T *pSSP, uint32_t clk_rate, uint32_t prescale);
+
+/**
+ * @brief	Set up the SSP frame format
+ * @param	pSSP		: The base of SSP peripheral on the chip
+ * @param	bits		: The number of bits transferred in each frame, should be SSP_BITS_4 to SSP_BITS_16
+ * @param	frameFormat	: Frame format, should be :
+ *							- SSP_FRAMEFORMAT_SPI
+ *							- SSP_FRAME_FORMAT_TI
+ *							- SSP_FRAMEFORMAT_MICROWIRE
+ * @param	clockMode	: Select Clock polarity and Clock phase, should be :
+ *							- SSP_CLOCK_CPHA0_CPOL0
+ *							- SSP_CLOCK_CPHA0_CPOL1
+ *							- SSP_CLOCK_CPHA1_CPOL0
+ *							- SSP_CLOCK_CPHA1_CPOL1
+ * @return	 Nothing
+ * @note	Note: The clockFormat is only used in SPI mode
+ */
+STATIC INLINE void Chip_SSP_SetFormat(LPC_SSP_T *pSSP, uint32_t bits, uint32_t frameFormat, uint32_t clockMode)
+{
+	pSSP->CR0 = (pSSP->CR0 & ~0xFF) | bits | frameFormat | clockMode;
+}
+
+/**
+ * @brief	Set the SSP working as master or slave mode
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @param	mode	: Operating mode, should be
+ *						- SSP_MODE_MASTER
+ *						- SSP_MODE_SLAVE
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_Set_Mode(LPC_SSP_T *pSSP, uint32_t mode)
+{
+	pSSP->CR1 = (pSSP->CR1 & ~(1 << 2)) | mode;
+}
+
+/**
+ * @brief	Enable DMA for SSP
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_DMA_Enable(LPC_SSP_T *pSSP)
+{
+	pSSP->DMACR |= SSP_DMA_BITMASK;
+}
+
+/**
+ * @brief	Disable DMA for SSP
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @return	 Nothing
+ */
+STATIC INLINE void Chip_SSP_DMA_Disable(LPC_SSP_T *pSSP)
+{
+	pSSP->DMACR &= ~SSP_DMA_BITMASK;
+}
+
+/*
+ * @brief SSP mode
+ */
+typedef enum CHIP_SSP_MODE {
+	SSP_MODE_MASTER = (0 << 2),	/**< Master mode */
+	SSP_MODE_SLAVE = (1u << 2),	/**< Slave mode */
+} CHIP_SSP_MODE_T;
+
+/*
+ * @brief SPI address
+ */
+typedef struct {
+	uint8_t port;	/*!< Port Number */
+	uint8_t pin;	/*!< Pin number */
+} SPI_Address_t;
+
+/*
+ * @brief SSP data setup structure
+ */
+typedef struct {
+	void      *tx_data;	/*!< Pointer to transmit data */
+	uint32_t  tx_cnt;	/*!< Transmit counter */
+	void      *rx_data;	/*!< Pointer to transmit data */
+	uint32_t  rx_cnt;	/*!< Receive counter */
+	uint32_t  length;	/*!< Length of transfer data */
+} Chip_SSP_DATA_SETUP_T;
+
+/** SSP configuration parameter defines */
+/** Clock phase control bit */
+#define SSP_CPHA_FIRST          SSP_CR0_CPHA_FIRST
+#define SSP_CPHA_SECOND         SSP_CR0_CPHA_SECOND
+
+/** Clock polarity control bit */
+/* There's no bug here!!!
+ * - If bit[6] in SSPnCR0 is 0: SSP controller maintains the bus clock low between frames.
+ * That means the active clock is in HI state.
+ * - If bit[6] in SSPnCR0 is 1 (SSP_CR0_CPOL_HI): SSP controller maintains the bus clock
+ * high between frames. That means the active clock is in LO state.
+ */
+#define SSP_CPOL_HI             SSP_CR0_CPOL_LO
+#define SSP_CPOL_LO             SSP_CR0_CPOL_HI
+
+/** SSP master mode enable */
+#define SSP_SLAVE_MODE          SSP_CR1_SLAVE_EN
+#define SSP_MASTER_MODE         SSP_CR1_MASTER_EN
+
+/**
+ * @brief   Clean all data in RX FIFO of SSP
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SSP_Int_FlushData(LPC_SSP_T *pSSP);
+
+/**
+ * @brief   SSP Interrupt Read/Write with 8-bit frame width
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	xf_setup		: Pointer to a SSP_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data	configuration
+ * @return	SUCCESS or ERROR
+ */
+Status Chip_SSP_Int_RWFrames8Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SSP Interrupt Read/Write with 16-bit frame width
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	xf_setup		: Pointer to a SSP_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data	configuration
+ * @return	SUCCESS or ERROR
+ */
+Status Chip_SSP_Int_RWFrames16Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SSP Polling Read/Write in blocking mode
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	xf_setup		: Pointer to a SSP_DATA_SETUP_T structure that contains specified
+ *                          information about transmit/receive data	configuration
+ * @return	Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. It starts with writing phase and after that,
+ * a reading phase is generated to read any data available in RX_FIFO. All needed information is prepared
+ * through xf_setup param.
+ */
+uint32_t Chip_SSP_RWFrames_Blocking(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup);
+
+/**
+ * @brief   SSP Polling Write in blocking mode
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	buffer			: Buffer address
+ * @param	buffer_len		: Buffer length
+ * @return	Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a writing operation will send
+ * the needed data. After that, a dummy reading operation is generated to clear data buffer
+ */
+uint32_t Chip_SSP_WriteFrames_Blocking(LPC_SSP_T *pSSP, const uint8_t *buffer, uint32_t buffer_len);
+
+/**
+ * @brief   SSP Polling Read in blocking mode
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	buffer			: Buffer address
+ * @param	buffer_len		: The length of buffer
+ * @return	Actual data length has been transferred
+ * @note
+ * This function can be used in both master and slave mode. First, a dummy writing operation is generated
+ * to clear data buffer. After that, a reading operation will receive the needed data
+ */
+uint32_t Chip_SSP_ReadFrames_Blocking(LPC_SSP_T *pSSP, uint8_t *buffer, uint32_t buffer_len);
+
+/**
+ * @brief   Initialize the SSP
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SSP_Init(LPC_SSP_T *pSSP);
+
+/**
+ * @brief	Deinitialise the SSP
+ * @param	pSSP	: The base of SSP peripheral on the chip
+ * @return	Nothing
+ * @note	The SSP controller is disabled
+ */
+void Chip_SSP_DeInit(LPC_SSP_T *pSSP);
+
+/**
+ * @brief   Set the SSP operating modes, master or slave
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	master			: 1 to set master, 0 to set slave
+ * @return	Nothing
+ */
+void Chip_SSP_SetMaster(LPC_SSP_T *pSSP, bool master);
+
+/**
+ * @brief   Set the clock frequency for SSP interface
+ * @param	pSSP			: The base SSP peripheral on the chip
+ * @param	bitRate		: The SSP bit rate
+ * @return	Nothing
+ */
+void Chip_SSP_SetBitRate(LPC_SSP_T *pSSP, uint32_t bitRate);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SSP_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/stopwatch.h ./libs/vendor_libs/lpc_chip_43xx/inc/stopwatch.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/stopwatch.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/stopwatch.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,143 @@
+/*
+ * @brief Common stopwatch support
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __STOPWATCH_H_
+#define __STOPWATCH_H_
+
+#include "cmsis.h"
+
+/** @defgroup Stop_Watch CHIP: Stopwatch primitives.
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief	Initialize stopwatch
+ * @return	Nothing
+ */
+void StopWatch_Init(void);
+
+/**
+ * @brief	Start a stopwatch
+ * @return	Current cycle count
+ */
+uint32_t StopWatch_Start(void);
+
+/**
+ * @brief      Returns number of ticks elapsed since stopwatch was started
+ * @param      startTime	: Time returned by StopWatch_Start().
+ * @return     Number of ticks elapsed since stopwatch was started
+ */
+STATIC INLINE uint32_t StopWatch_Elapsed(uint32_t startTime)
+{
+	return StopWatch_Start() - startTime;
+}
+
+/**
+ * @brief	Returns number of ticks per second of the stopwatch timer
+ * @return	Number of ticks per second of the stopwatch timer
+ */
+uint32_t StopWatch_TicksPerSecond(void);
+
+/**
+ * @brief	Converts from stopwatch ticks to mS.
+ * @param	ticks	: Duration in ticks to convert to mS.
+ * @return	Number of mS in given number of ticks
+ */
+uint32_t StopWatch_TicksToMs(uint32_t ticks);
+
+/**
+ * @brief	Converts from stopwatch ticks to uS.
+ * @param	ticks	: Duration in ticks to convert to uS.
+ * @return	Number of uS in given number of ticks
+ */
+uint32_t StopWatch_TicksToUs(uint32_t ticks);
+
+/**
+ * @brief	Converts from mS to stopwatch ticks.
+ * @param	mS	: Duration in mS to convert to ticks.
+ * @return	Number of ticks in given number of mS
+ */
+uint32_t StopWatch_MsToTicks(uint32_t mS);
+
+/**
+ * @brief	Converts from uS to stopwatch ticks.
+ * @param	uS	: Duration in uS to convert to ticks.
+ * @return	Number of ticks in given number of uS
+ */
+uint32_t StopWatch_UsToTicks(uint32_t uS);
+
+/**
+ * @brief	Delays the given number of ticks using stopwatch primitives
+ * @param	ticks	: Number of ticks to delay
+ * @return	Nothing
+ */
+STATIC INLINE void StopWatch_DelayTicks(uint32_t ticks)
+{
+	uint32_t startTime = StopWatch_Start();
+	while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @brief	Delays the given number of mS using stopwatch primitives
+ * @param	mS	: Number of mS to delay
+ * @return	Nothing
+ */
+STATIC INLINE void StopWatch_DelayMs(uint32_t mS)
+{
+	uint32_t ticks = StopWatch_MsToTicks(mS);
+	uint32_t startTime = StopWatch_Start();
+	while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @brief	Delays the given number of uS using stopwatch primitives
+ * @param	uS	: Number of uS to delay
+ * @return	Nothing
+ */
+STATIC INLINE void StopWatch_DelayUs(uint32_t uS)
+{
+	uint32_t ticks = StopWatch_UsToTicks(uS);
+	uint32_t startTime = StopWatch_Start();
+	while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @}
+ */
+
+#endif /* __STOPWATCH_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/timer_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/timer_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/timer_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/timer_18xx_43xx.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,451 @@
+/*
+ * @brief LPC18xx/43xx 16/32-bit Timer/PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __TIMER_18XX_43XX_H_
+#define __TIMER_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup TIMER_18XX_43XX CHIP: LPC18xx/43xx 16/32-bit Timer driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief 32-bit Standard timer register block structure
+ */
+typedef struct {					/*!< TIMERn Structure       */
+	__IO uint32_t IR;				/*!< Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending. */
+	__IO uint32_t TCR;				/*!< Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR. */
+	__IO uint32_t TC;				/*!< Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR. */
+	__IO uint32_t PR;				/*!< Prescale Register. The Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC. */
+	__IO uint32_t PC;				/*!< Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface. */
+	__IO uint32_t MCR;				/*!< Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs. */
+	__IO uint32_t MR[4];			/*!< Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC. */
+	__IO uint32_t CCR;				/*!< Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place. */
+	__IO uint32_t CR[4];			/*!< Capture Register. CR is loaded with the value of TC when there is an event on the CAPn.0 input. */
+	__IO uint32_t EMR;				/*!< External Match Register. The EMR controls the external match pins MATn.0-3 (MAT0.0-3 and MAT1.0-3 respectively). */
+	__I  uint32_t RESERVED0[12];
+	__IO uint32_t CTCR;				/*!< Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting. */
+} LPC_TIMER_T;
+
+/** Macro to clear interrupt pending */
+#define TIMER_IR_CLR(n)         _BIT(n)
+
+/** Macro for getting a timer match interrupt bit */
+#define TIMER_MATCH_INT(n)      (_BIT((n) & 0x0F))
+/** Macro for getting a capture event interrupt bit */
+#define TIMER_CAP_INT(n)        (_BIT((((n) & 0x0F) + 4)))
+
+/** Timer/counter enable bit */
+#define TIMER_ENABLE            ((uint32_t) (1 << 0))
+/** Timer/counter reset bit */
+#define TIMER_RESET             ((uint32_t) (1 << 1))
+
+/** Bit location for interrupt on MRx match, n = 0 to 3 */
+#define TIMER_INT_ON_MATCH(n)   (_BIT(((n) * 3)))
+/** Bit location for reset on MRx match, n = 0 to 3 */
+#define TIMER_RESET_ON_MATCH(n) (_BIT((((n) * 3) + 1)))
+/** Bit location for stop on MRx match, n = 0 to 3 */
+#define TIMER_STOP_ON_MATCH(n)  (_BIT((((n) * 3) + 2)))
+
+/** Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
+#define TIMER_CAP_RISING(n)     (_BIT(((n) * 3)))
+/** Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
+#define TIMER_CAP_FALLING(n)    (_BIT((((n) * 3) + 1)))
+/** Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
+#define TIMER_INT_ON_CAP(n)     (_BIT((((n) * 3) + 2)))
+
+/**
+ * @brief	Initialize a timer
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ */
+void Chip_TIMER_Init(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief	Shutdown a timer
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ */
+void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief	Determine if a match interrupt is pending
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match interrupt number to check
+ * @return	false if the interrupt is not pending, otherwise true
+ * @note	Determine if the match interrupt for the passed timer and match
+ * counter is pending.
+ */
+STATIC INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
+}
+
+/**
+ * @brief	Determine if a capture interrupt is pending
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture interrupt number to check
+ * @return	false if the interrupt is not pending, otherwise true
+ * @note	Determine if the capture interrupt for the passed capture pin is
+ * pending.
+ */
+STATIC INLINE bool Chip_TIMER_CapturePending(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	return (bool) ((pTMR->IR & TIMER_CAP_INT(capnum)) != 0);
+}
+
+/**
+ * @brief	Clears a (pending) match interrupt
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match interrupt number to clear
+ * @return	Nothing
+ * @note	Clears a pending timer match interrupt.
+ */
+STATIC INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->IR = TIMER_IR_CLR(matchnum);
+}
+
+/**
+ * @brief	Clears a (pending) capture interrupt
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture interrupt number to clear
+ * @return	Nothing
+ * @note	Clears a pending timer capture interrupt.
+ */
+STATIC INLINE void Chip_TIMER_ClearCapture(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->IR = (0x10 << capnum);
+}
+
+/**
+ * @brief	Enables the timer (starts count)
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ * @note	Enables the timer to start counting.
+ */
+STATIC INLINE void Chip_TIMER_Enable(LPC_TIMER_T *pTMR)
+{
+	pTMR->TCR |= TIMER_ENABLE;
+}
+
+/**
+ * @brief	Disables the timer (stops count)
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ * @note	Disables the timer to stop counting.
+ */
+STATIC INLINE void Chip_TIMER_Disable(LPC_TIMER_T *pTMR)
+{
+	pTMR->TCR &= ~TIMER_ENABLE;
+}
+
+/**
+ * @brief	Returns the current timer count
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Current timer terminal count value
+ * @note	Returns the current timer terminal count.
+ */
+STATIC INLINE uint32_t Chip_TIMER_ReadCount(LPC_TIMER_T *pTMR)
+{
+	return pTMR->TC;
+}
+
+/**
+ * @brief	Returns the current prescale count
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Current timer prescale count value
+ * @note	Returns the current prescale count.
+ */
+STATIC INLINE uint32_t Chip_TIMER_ReadPrescale(LPC_TIMER_T *pTMR)
+{
+	return pTMR->PC;
+}
+
+/**
+ * @brief	Sets the prescaler value
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	prescale	: Prescale value to set the prescale register to
+ * @return	Nothing
+ * @note	Sets the prescale count value.
+ */
+STATIC INLINE void Chip_TIMER_PrescaleSet(LPC_TIMER_T *pTMR, uint32_t prescale)
+{
+	pTMR->PR = prescale;
+}
+
+/**
+ * @brief	Sets a timer match value
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer to set match count for
+ * @param	matchval	: Match value for the selected match count
+ * @return	Nothing
+ * @note	Sets one of the timer match values.
+ */
+STATIC INLINE void Chip_TIMER_SetMatch(LPC_TIMER_T *pTMR, int8_t matchnum, uint32_t matchval)
+{
+	pTMR->MR[matchnum] = matchval;
+}
+
+/**
+ * @brief	Reads a capture register
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture register to read
+ * @return	The selected capture register value
+ * @note	Returns the selected capture register value.
+ */
+STATIC INLINE uint32_t Chip_TIMER_ReadCapture(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	return pTMR->CR[capnum];
+}
+
+/**
+ * @brief	Resets the timer terminal and prescale counts to 0
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ */
+void Chip_TIMER_Reset(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief	Enables a match interrupt that fires when the terminal count
+ *			matches the match counter value.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_MatchEnableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR |= TIMER_INT_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Disables a match interrupt for a match counter.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_MatchDisableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR &= ~TIMER_INT_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	For the specific match counter, enables reset of the terminal count register when a match occurs
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_ResetOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR |= TIMER_RESET_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	For the specific match counter, disables reset of the terminal count register when a match occurs
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_ResetOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR &= ~TIMER_RESET_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Enable a match timer to stop the terminal count when a
+ *			match count equals the terminal count.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_StopOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR |= TIMER_STOP_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Disable stop on match for a match timer. Disables a match timer
+ *			to stop the terminal count when a match count equals the terminal count.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_StopOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR &= ~TIMER_STOP_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Enables capture on on rising edge of selected CAP signal for the
+ *			selected capture register, enables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a rising edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureRisingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR |= TIMER_CAP_RISING(capnum);
+}
+
+/**
+ * @brief	Disables capture on on rising edge of selected CAP signal. For the
+ *			selected capture register, disables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a rising edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureRisingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR &= ~TIMER_CAP_RISING(capnum);
+}
+
+/**
+ * @brief	Enables capture on on falling edge of selected CAP signal. For the
+ *			selected capture register, enables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a falling edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureFallingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR |= TIMER_CAP_FALLING(capnum);
+}
+
+/**
+ * @brief	Disables capture on on falling edge of selected CAP signal. For the
+ *			selected capture register, disables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a falling edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureFallingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR &= ~TIMER_CAP_FALLING(capnum);
+}
+
+/**
+ * @brief	Enables interrupt on capture of selected CAP signal. For the
+ *			selected capture register, an interrupt will be generated when the enabled
+ *			rising or falling edge on CAPn.capnum is detected.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureEnableInt(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR |= TIMER_INT_ON_CAP(capnum);
+}
+
+/**
+ * @brief	Disables interrupt on capture of selected CAP signal
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_TIMER_CaptureDisableInt(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR &= ~TIMER_INT_ON_CAP(capnum);
+}
+
+/**
+ * @brief Standard timer initial match pin state and change state
+ */
+typedef enum IP_TIMER_PIN_MATCH_STATE {
+	TIMER_EXTMATCH_DO_NOTHING = 0,	/*!< Timer match state does nothing on match pin */
+	TIMER_EXTMATCH_CLEAR      = 1,	/*!< Timer match state sets match pin low */
+	TIMER_EXTMATCH_SET        = 2,	/*!< Timer match state sets match pin high */
+	TIMER_EXTMATCH_TOGGLE     = 3	/*!< Timer match state toggles match pin */
+} TIMER_PIN_MATCH_STATE_T;
+
+/**
+ * @brief	Sets external match control (MATn.matchnum) pin control. For the pin
+ *          selected with matchnum, sets the function of the pin that occurs on
+ *          a terminal count match for the match count.
+ * @param	pTMR			: Pointer to timer IP register address
+ * @param	initial_state	: Initial state of the pin, high(1) or low(0)
+ * @param	matchState		: Selects the match state for the pin
+ * @param	matchnum		: MATn.matchnum signal to use
+ * @return	Nothing
+ * @note	For the pin selected with matchnum, sets the function of the pin that occurs on
+ * a terminal count match for the match count.
+ */
+void Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
+												 TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum);
+
+/**
+ * @brief Standard timer clock and edge for count source
+ */
+typedef enum IP_TIMER_CAP_SRC_STATE {
+	TIMER_CAPSRC_RISING_PCLK  = 0,	/*!< Timer ticks on PCLK rising edge */
+	TIMER_CAPSRC_RISING_CAPN  = 1,	/*!< Timer ticks on CAPn.x rising edge */
+	TIMER_CAPSRC_FALLING_CAPN = 2,	/*!< Timer ticks on CAPn.x falling edge */
+	TIMER_CAPSRC_BOTH_CAPN    = 3	/*!< Timer ticks on CAPn.x both edges */
+} TIMER_CAP_SRC_STATE_T;
+
+/**
+ * @brief	Sets timer count source and edge with the selected passed from CapSrc.
+ *          If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capSrc	: timer clock source and edge
+ * @param	capnum	: CAPn.capnum pin to use (if used)
+ * @return	Nothing
+ * @note	If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
+ */
+STATIC INLINE void Chip_TIMER_TIMER_SetCountClockSrc(LPC_TIMER_T *pTMR,
+													 TIMER_CAP_SRC_STATE_T capSrc,
+													 int8_t capnum)
+{
+	pTMR->CTCR = (uint32_t) capSrc | ((uint32_t) capnum) << 2;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TIMER_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/uart_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/uart_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/uart_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/uart_18xx_43xx.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,832 @@
+/*
+ * @brief LPC18xx/43xx UART chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __UART_18XX_43XX_H_
+#define __UART_18XX_43XX_H_
+
+#include "ring_buffer.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup UART_18XX_43XX CHIP: LPC18xx/43xx UART driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief USART register block structure
+ */
+typedef struct {					/*!< USARTn Structure       */
+
+	union {
+		__IO uint32_t  DLL;			/*!< Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1). */
+		__O  uint32_t  THR;			/*!< Transmit Holding Register. The next character to be transmitted is written here (DLAB = 0). */
+		__I  uint32_t  RBR;			/*!< Receiver Buffer Register. Contains the next received character to be read (DLAB = 0). */
+	};
+
+	union {
+		__IO uint32_t IER;			/*!< Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB = 0). */
+		__IO uint32_t DLM;			/*!< Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1). */
+	};
+
+	union {
+		__O  uint32_t FCR;			/*!< FIFO Control Register. Controls UART FIFO usage and modes. */
+		__I  uint32_t IIR;			/*!< Interrupt ID Register. Identifies which interrupt(s) are pending. */
+	};
+
+	__IO uint32_t LCR;				/*!< Line Control Register. Contains controls for frame formatting and break generation. */
+	__IO uint32_t MCR;				/*!< Modem Control Register. Only present on USART ports with full modem support. */
+	__I  uint32_t LSR;				/*!< Line Status Register. Contains flags for transmit and receive status, including line errors. */
+	__I  uint32_t MSR;				/*!< Modem Status Register. Only present on USART ports with full modem support. */
+	__IO uint32_t SCR;				/*!< Scratch Pad Register. Eight-bit temporary storage for software. */
+	__IO uint32_t ACR;				/*!< Auto-baud Control Register. Contains controls for the auto-baud feature. */
+	__IO uint32_t ICR;				/*!< IrDA control register (not all UARTS) */
+	__IO uint32_t FDR;				/*!< Fractional Divider Register. Generates a clock input for the baud rate divider. */
+	__IO uint32_t OSR;				/*!< Oversampling Register. Controls the degree of oversampling during each bit time. Only on some UARTS. */
+	__IO uint32_t TER1;				/*!< Transmit Enable Register. Turns off USART transmitter for use with software flow control. */
+	uint32_t  RESERVED0[3];
+    __IO uint32_t HDEN;				/*!< Half-duplex enable Register- only on some UARTs */
+	__I  uint32_t RESERVED1[1];
+	__IO uint32_t SCICTRL;			/*!< Smart card interface control register- only on some UARTs */
+
+	__IO uint32_t RS485CTRL;		/*!< RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes. */
+	__IO uint32_t RS485ADRMATCH;	/*!< RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode. */
+	__IO uint32_t RS485DLY;			/*!< RS-485/EIA-485 direction control delay. */
+
+	union {
+		__IO uint32_t SYNCCTRL;		/*!< Synchronous mode control register. Only on USARTs. */
+		__I  uint32_t FIFOLVL;		/*!< FIFO Level register. Provides the current fill levels of the transmit and receive FIFOs. */
+	};
+
+	__IO uint32_t TER2;				/*!< Transmit Enable Register. Only on LPC177X_8X UART4 and LPC18XX/43XX USART0/2/3. */
+} LPC_USART_T;
+
+
+/**
+ * @brief Macro defines for UART Receive Buffer register
+ */
+#define UART_RBR_MASKBIT    (0xFF)		        /*!< UART Received Buffer mask bit (8 bits) */
+
+/**
+ * @brief Macro defines for UART Divisor Latch LSB register
+ */
+#define UART_LOAD_DLL(div)  ((div) & 0xFF)		/*!< Macro for loading LSB of divisor */
+#define UART_DLL_MASKBIT    (0xFF)	            /*!< Divisor latch LSB bit mask */
+
+/**
+ * @brief Macro defines for UART Divisor Latch MSB register
+ */
+#define UART_LOAD_DLM(div)  (((div) >> 8) & 0xFF)	/*!< Macro for loading MSB of divisors */
+#define UART_DLM_MASKBIT    (0xFF)		            /*!< Divisor latch MSB bit mask */
+
+/**
+ * @brief Macro defines for UART Interrupt Enable Register
+ */
+#define UART_IER_RBRINT      (1 << 0)	/*!< RBR Interrupt enable */
+#define UART_IER_THREINT     (1 << 1)	/*!< THR Interrupt enable */
+#define UART_IER_RLSINT      (1 << 2)	/*!< RX line status interrupt enable */
+#define UART_IER_MSINT       (1 << 3)	/*!< Modem status interrupt enable - valid for 11xx, 17xx/40xx UART1, 18xx/43xx UART1  only */
+#define UART_IER_CTSINT      (1 << 7)	/*!< CTS signal transition interrupt enable - valid for 17xx/40xx UART1, 18xx/43xx UART1 only */
+#define UART_IER_ABEOINT     (1 << 8)	/*!< Enables the end of auto-baud interrupt */
+#define UART_IER_ABTOINT     (1 << 9)	/*!< Enables the auto-baud time-out interrupt */
+#define UART_IER_BITMASK     (0x307)	/*!< UART interrupt enable register bit mask  - valid for 13xx, 17xx/40xx UART0/2/3, 18xx/43xx UART0/2/3 only*/
+#define UART1_IER_BITMASK    (0x30F)	/*!< UART1 interrupt enable register bit mask - valid for 11xx only */
+#define UART2_IER_BITMASK    (0x38F)	/*!< UART2 interrupt enable register bit mask - valid for 17xx/40xx UART1, 18xx/43xx UART1 only */
+
+/**
+ * @brief Macro defines for UART Interrupt Identification Register
+ */
+#define UART_IIR_INTSTAT_PEND   (1 << 0)	/*!< Interrupt pending status - Active low */
+#define UART_IIR_FIFO_EN        (3 << 6)	/*!< These bits are equivalent to FCR[0] */
+#define UART_IIR_ABEO_INT       (1 << 8)	/*!< End of auto-baud interrupt */
+#define UART_IIR_ABTO_INT       (1 << 9)	/*!< Auto-baud time-out interrupt */
+#define UART_IIR_BITMASK        (0x3CF)		/*!< UART interrupt identification register bit mask */
+
+/* Interrupt ID bit definitions */
+#define UART_IIR_INTID_MASK     (7 << 1)	/*!< Interrupt identification: Interrupt ID mask */
+#define UART_IIR_INTID_RLS      (3 << 1)	/*!< Interrupt identification: Receive line interrupt */
+#define UART_IIR_INTID_RDA      (2 << 1)	/*!< Interrupt identification: Receive data available interrupt */
+#define UART_IIR_INTID_CTI      (6 << 1)	/*!< Interrupt identification: Character time-out indicator interrupt */
+#define UART_IIR_INTID_THRE     (1 << 1)	/*!< Interrupt identification: THRE interrupt */
+#define UART_IIR_INTID_MODEM    (0 << 1)	/*!< Interrupt identification: Modem interrupt */
+
+/**
+ * @brief Macro defines for UART FIFO Control Register
+ */
+#define UART_FCR_FIFO_EN        (1 << 0)	/*!< UART FIFO enable */
+#define UART_FCR_RX_RS          (1 << 1)	/*!< UART RX FIFO reset */
+#define UART_FCR_TX_RS          (1 << 2)	/*!< UART TX FIFO reset */
+#define UART_FCR_DMAMODE_SEL    (1 << 3)	/*!< UART DMA mode selection - valid for 17xx/40xx, 18xx/43xx only */
+#define UART_FCR_BITMASK        (0xCF)		/*!< UART FIFO control bit mask */
+
+#define UART_TX_FIFO_SIZE       (16)
+
+/* FIFO trigger level bit definitions */
+#define UART_FCR_TRG_LEV0       (0)			/*!< UART FIFO trigger level 0: 1 character */
+#define UART_FCR_TRG_LEV1       (1 << 6)	/*!< UART FIFO trigger level 1: 4 character */
+#define UART_FCR_TRG_LEV2       (2 << 6)	/*!< UART FIFO trigger level 2: 8 character */
+#define UART_FCR_TRG_LEV3       (3 << 6)	/*!< UART FIFO trigger level 3: 14 character */
+
+/**
+ * @brief Macro defines for UART Line Control Register
+ */
+/* UART word length select bit definitions */
+#define UART_LCR_WLEN_MASK      (3 << 0)		/*!< UART word length select bit mask */
+#define UART_LCR_WLEN5          (0 << 0)		/*!< UART word length select: 5 bit data mode */
+#define UART_LCR_WLEN6          (1 << 0)		/*!< UART word length select: 6 bit data mode */
+#define UART_LCR_WLEN7          (2 << 0)		/*!< UART word length select: 7 bit data mode */
+#define UART_LCR_WLEN8          (3 << 0)		/*!< UART word length select: 8 bit data mode */
+
+/* UART Stop bit select bit definitions */
+#define UART_LCR_SBS_MASK       (1 << 2)		/*!< UART stop bit select: bit mask */
+#define UART_LCR_SBS_1BIT       (0 << 2)		/*!< UART stop bit select: 1 stop bit */
+#define UART_LCR_SBS_2BIT       (1 << 2)		/*!< UART stop bit select: 2 stop bits (in 5 bit data mode, 1.5 stop bits) */
+
+/* UART Parity enable bit definitions */
+#define UART_LCR_PARITY_EN      (1 << 3)		/*!< UART Parity Enable */
+#define UART_LCR_PARITY_DIS     (0 << 3)		/*!< UART Parity Disable */
+#define UART_LCR_PARITY_ODD     (0 << 4)		/*!< UART Parity select: Odd parity */
+#define UART_LCR_PARITY_EVEN    (1 << 4)		/*!< UART Parity select: Even parity */
+#define UART_LCR_PARITY_F_1     (2 << 4)		/*!< UART Parity select: Forced 1 stick parity */
+#define UART_LCR_PARITY_F_0     (3 << 4)		/*!< UART Parity select: Forced 0 stick parity */
+#define UART_LCR_BREAK_EN       (1 << 6)		/*!< UART Break transmission enable */
+#define UART_LCR_DLAB_EN        (1 << 7)		/*!< UART Divisor Latches Access bit enable */
+#define UART_LCR_BITMASK        (0xFF)			/*!< UART line control bit mask */
+
+/**
+ * @brief Macro defines for UART Modem Control Register
+ */
+#define UART_MCR_DTR_CTRL       (1 << 0)		/*!< Source for modem output pin DTR */
+#define UART_MCR_RTS_CTRL       (1 << 1)		/*!< Source for modem output pin RTS */
+#define UART_MCR_LOOPB_EN       (1 << 4)		/*!< Loop back mode select */
+#define UART_MCR_AUTO_RTS_EN    (1 << 6)		/*!< Enable Auto RTS flow-control */
+#define UART_MCR_AUTO_CTS_EN    (1 << 7)		/*!< Enable Auto CTS flow-control */
+#define UART_MCR_BITMASK        (0xD3)			/*!< UART bit mask value */
+
+/**
+ * @brief Macro defines for UART Line Status Register
+ */
+#define UART_LSR_RDR        (1 << 0)	/*!< Line status: Receive data ready */
+#define UART_LSR_OE         (1 << 1)	/*!< Line status: Overrun error */
+#define UART_LSR_PE         (1 << 2)	/*!< Line status: Parity error */
+#define UART_LSR_FE         (1 << 3)	/*!< Line status: Framing error */
+#define UART_LSR_BI         (1 << 4)	/*!< Line status: Break interrupt */
+#define UART_LSR_THRE       (1 << 5)	/*!< Line status: Transmit holding register empty */
+#define UART_LSR_TEMT       (1 << 6)	/*!< Line status: Transmitter empty */
+#define UART_LSR_RXFE       (1 << 7)	/*!< Line status: Error in RX FIFO */
+#define UART_LSR_TXFE       (1 << 8)	/*!< Line status: Error in RX FIFO */
+#define UART_LSR_BITMASK    (0xFF)		/*!< UART Line status bit mask */
+#define UART1_LSR_BITMASK   (0x1FF)		/*!< UART1 Line status bit mask - valid for 11xx, 18xx/43xx UART0/2/3 only */
+
+/**
+ * @brief Macro defines for UART Modem Status Register
+ */
+#define UART_MSR_DELTA_CTS      (1 << 0)	/*!< Modem status: State change of input CTS */
+#define UART_MSR_DELTA_DSR      (1 << 1)	/*!< Modem status: State change of input DSR */
+#define UART_MSR_LO2HI_RI       (1 << 2)	/*!< Modem status: Low to high transition of input RI */
+#define UART_MSR_DELTA_DCD      (1 << 3)	/*!< Modem status: State change of input DCD */
+#define UART_MSR_CTS            (1 << 4)	/*!< Modem status: Clear To Send State */
+#define UART_MSR_DSR            (1 << 5)	/*!< Modem status: Data Set Ready State */
+#define UART_MSR_RI             (1 << 6)	/*!< Modem status: Ring Indicator State */
+#define UART_MSR_DCD            (1 << 7)	/*!< Modem status: Data Carrier Detect State */
+#define UART_MSR_BITMASK        (0xFF)		/*!< Modem status: MSR register bit-mask value */
+
+/**
+ * @brief Macro defines for UART Auto baudrate control register
+ */
+#define UART_ACR_START              (1 << 0)	/*!< UART Auto-baud start */
+#define UART_ACR_MODE               (1 << 1)	/*!< UART Auto baudrate Mode 1 */
+#define UART_ACR_AUTO_RESTART       (1 << 2)	/*!< UART Auto baudrate restart */
+#define UART_ACR_ABEOINT_CLR        (1 << 8)	/*!< UART End of auto-baud interrupt clear */
+#define UART_ACR_ABTOINT_CLR        (1 << 9)	/*!< UART Auto-baud time-out interrupt clear */
+#define UART_ACR_BITMASK            (0x307)		/*!< UART Auto Baudrate register bit mask */
+
+/**
+ * Autobaud modes
+ */
+#define UART_ACR_MODE0              (0)	/*!< Auto baudrate Mode 0 */
+#define UART_ACR_MODE1              (1)	/*!< Auto baudrate Mode 1 */
+
+/**
+ * @brief Macro defines for UART RS485 Control register
+ */
+#define UART_RS485CTRL_NMM_EN       (1 << 0)	/*!< RS-485/EIA-485 Normal Multi-drop Mode (NMM) is disabled */
+#define UART_RS485CTRL_RX_DIS       (1 << 1)	/*!< The receiver is disabled */
+#define UART_RS485CTRL_AADEN        (1 << 2)	/*!< Auto Address Detect (AAD) is enabled */
+#define UART_RS485CTRL_SEL_DTR      (1 << 3)	/*!< If direction control is enabled (bit DCTRL = 1), pin DTR is
+												        used for direction control */
+#define UART_RS485CTRL_DCTRL_EN     (1 << 4)	/*!< Enable Auto Direction Control */
+#define UART_RS485CTRL_OINV_1       (1 << 5)	/*!< This bit reverses the polarity of the direction
+												       control signal on the RTS (or DTR) pin. The direction control pin
+												       will be driven to logic "1" when the transmitter has data to be sent */
+#define UART_RS485CTRL_BITMASK      (0x3F)		/*!< RS485 control bit-mask value */
+
+/**
+ * @brief Macro defines for UART IrDA Control Register - valid for 11xx, 17xx/40xx UART0/2/3, 18xx/43xx UART3 only
+ */
+#define UART_ICR_IRDAEN         (1 << 0)			/*!< IrDA mode enable */
+#define UART_ICR_IRDAINV        (1 << 1)			/*!< IrDA serial input inverted */
+#define UART_ICR_FIXPULSE_EN    (1 << 2)			/*!< IrDA fixed pulse width mode */
+#define UART_ICR_PULSEDIV(n)    ((n & 0x07) << 3)	/*!< PulseDiv - Configures the pulse when FixPulseEn = 1 */
+#define UART_ICR_BITMASK        (0x3F)				/*!< UART IRDA bit mask */
+
+/**
+ * @brief Macro defines for UART half duplex register - ????
+ */
+#define UART_HDEN_HDEN          ((1 << 0))			/*!< enable half-duplex mode*/
+
+/**
+ * @brief Macro defines for UART Smart card interface Control Register - valid for 11xx, 18xx/43xx UART0/2/3 only
+ */
+#define UART_SCICTRL_SCIEN        (1 << 0)			/*!< enable asynchronous half-duplex smart card interface*/
+#define UART_SCICTRL_NACKDIS      (1 << 1)			/*!< NACK response is inhibited*/
+#define UART_SCICTRL_PROTSEL_T1   (1 << 2)			/*!< ISO7816-3 protocol T1 is selected*/
+#define UART_SCICTRL_TXRETRY(n)   ((n & 0x07) << 5)	/*!< number of retransmission*/
+#define UART_SCICTRL_GUARDTIME(n) ((n & 0xFF) << 8)	/*!< Extra guard time*/
+
+/**
+ * @brief Macro defines for UART Fractional Divider Register
+ */
+#define UART_FDR_DIVADDVAL(n)   (n & 0x0F)			/*!< Baud-rate generation pre-scaler divisor */
+#define UART_FDR_MULVAL(n)      ((n << 4) & 0xF0)	/*!< Baud-rate pre-scaler multiplier value */
+#define UART_FDR_BITMASK        (0xFF)				/*!< UART Fractional Divider register bit mask */
+
+/**
+ * @brief Macro defines for UART Tx Enable Register
+ */
+#define UART_TER1_TXEN      (1 << 7)		/*!< Transmit enable bit  - valid for 11xx, 13xx, 17xx/40xx only */
+#define UART_TER2_TXEN      (1 << 0)		/*!< Transmit enable bit  - valid for 18xx/43xx only */
+
+/**
+ * @brief Macro defines for UART Synchronous Control Register - 11xx, 18xx/43xx UART0/2/3 only
+ */
+#define UART_SYNCCTRL_SYNC             (1 << 0)			/*!< enable synchronous mode*/
+#define UART_SYNCCTRL_CSRC_MASTER      (1 << 1)  		/*!< synchronous master mode*/
+#define UART_SYNCCTRL_FES              (1 << 2)			/*!< sample on falling edge*/
+#define UART_SYNCCTRL_TSBYPASS         (1 << 3)			/*!< to be defined*/
+#define UART_SYNCCTRL_CSCEN            (1 << 4)			/*!< Continuous running clock enable (master mode only)*/
+#define UART_SYNCCTRL_STARTSTOPDISABLE (1 << 5)	        /*!< Do not send start/stop bit*/
+#define UART_SYNCCTRL_CCCLR            (1 << 6)			/*!< stop continuous clock*/
+
+/**
+ * @brief	Enable transmission on UART TxD pin
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
+{
+    pUART->TER2 = UART_TER2_TXEN;
+}
+
+/**
+ * @brief	Disable transmission on UART TxD pin
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+STATIC INLINE void Chip_UART_TXDisable(LPC_USART_T *pUART)
+{
+    pUART->TER2 = 0;
+}
+
+/**
+ * @brief	Transmit a single data byte through the UART peripheral
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	data	: Byte to transmit
+ * @return	Nothing
+ * @note	This function attempts to place a byte into the UART transmit
+ *			FIFO or transmit hold register regard regardless of UART state
+ */
+STATIC INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
+{
+	pUART->THR = (uint32_t) data;
+}
+
+/**
+ * @brief	Read a single byte data from the UART peripheral
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	A single byte of data read
+ * @note	This function reads a byte from the UART receive FIFO or
+ *			receive hold register regard regardless of UART state. The
+ *			FIFO status should be read first prior to using this function
+ */
+STATIC INLINE uint8_t Chip_UART_ReadByte(LPC_USART_T *pUART)
+{
+	return (uint8_t) (pUART->RBR & UART_RBR_MASKBIT);
+}
+
+/**
+ * @brief	Enable UART interrupts
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	intMask	: OR'ed Interrupts to enable in the Interrupt Enable Register (IER)
+ * @return	Nothing
+ * @note	Use an OR'ed value of UART_IER_* definitions with this function
+ *			to enable specific UART interrupts. The Divisor Latch Access Bit
+ *			(DLAB) in LCR must be cleared in order to access the IER register.
+ *			This function doesn't alter the DLAB state
+ */
+STATIC INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
+{
+	pUART->IER |= intMask;
+}
+
+/**
+ * @brief	Disable UART interrupts
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	intMask	: OR'ed Interrupts to disable in the Interrupt Enable Register (IER)
+ * @return	Nothing
+ * @note	Use an OR'ed value of UART_IER_* definitions with this function
+ *			to disable specific UART interrupts. The Divisor Latch Access Bit
+ *			(DLAB) in LCR must be cleared in order to access the IER register.
+ *			This function doesn't alter the DLAB state
+ */
+STATIC INLINE void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
+{
+	pUART->IER &= ~intMask;
+}
+
+/**
+ * @brief	Returns UART interrupts that are enabled
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Returns the enabled UART interrupts
+ * @note	Use an OR'ed value of UART_IER_* definitions with this function
+ *			to determine which interrupts are enabled. You can check
+ *			for multiple enabled bits if needed.
+ */
+STATIC INLINE uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
+{
+	return pUART->IER;
+}
+
+/**
+ * @brief	Read the Interrupt Identification Register (IIR)
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Current pending interrupt status per the IIR register
+ */
+STATIC INLINE uint32_t Chip_UART_ReadIntIDReg(LPC_USART_T *pUART)
+{
+	return pUART->IIR;
+}
+
+/**
+ * @brief	Setup the UART FIFOs
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	fcr		: FIFO control register setup OR'ed flags
+ * @return	Nothing
+ * @note	Use OR'ed value of UART_FCR_* definitions with this function
+ *			to select specific options. For example, to enable the FIFOs
+ *			with a RX trip level of 8 characters, use something like
+ *			(UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
+ */
+STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
+{
+	pUART->FCR = fcr;
+}
+
+/**
+ * @brief	Configure data width, parity and stop bits
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @param	config	: UART configuration, OR'ed values of UART_LCR_* defines
+ * @return	Nothing
+ * @note	Select OR'ed config options for the UART from the UART_LCR_*
+ *			definitions. For example, a configuration of 8 data bits, 1
+ *			stop bit, and even (enabled) parity would be
+ *			(UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
+ */
+STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
+{
+	pUART->LCR = config;
+}
+
+/**
+ * @brief	Enable access to Divisor Latches
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
+{
+	pUART->LCR |= UART_LCR_DLAB_EN;
+}
+
+/**
+ * @brief	Disable access to Divisor Latches
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_UART_DisableDivisorAccess(LPC_USART_T *pUART)
+{
+	pUART->LCR &= ~UART_LCR_DLAB_EN;
+}
+
+/**
+ * @brief	Set LSB and MSB divisor latch registers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	dll		: Divisor Latch LSB value
+ * @param	dlm		: Divisor Latch MSB value
+ * @return	Nothing
+ * @note	The Divisor Latch Access Bit (DLAB) in LCR must be set in
+ *			order to access the USART Divisor Latches. This function
+ *			doesn't alter the DLAB state.
+ */
+STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
+{
+	pUART->DLL = (uint32_t) dll;
+	pUART->DLM = (uint32_t) dlm;
+}
+
+
+/**
+ * @brief	Return modem control register/status
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Modem control register (status)
+ * @note	Mask bits of the returned status value with UART_MCR_*
+ *			definitions for specific statuses.
+ */
+STATIC INLINE uint32_t Chip_UART_ReadModemControl(LPC_USART_T *pUART)
+{
+	return pUART->MCR;
+}
+
+/**
+ * @brief	Set modem control register/status
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	mcr		: Modem control register flags to set
+ * @return	Nothing
+ * @note	Use an Or'ed value of UART_MCR_* definitions with this
+ *			call to set specific options.
+ */
+STATIC INLINE void Chip_UART_SetModemControl(LPC_USART_T *pUART, uint32_t mcr)
+{
+	pUART->MCR |= mcr;
+}
+
+/**
+ * @brief	Clear modem control register/status
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	mcr		: Modem control register flags to clear
+ * @return	Nothing
+ * @note	Use an Or'ed value of UART_MCR_* definitions with this
+ *			call to clear specific options.
+ */
+STATIC INLINE void Chip_UART_ClearModemControl(LPC_USART_T *pUART, uint32_t mcr)
+{
+	pUART->MCR &= ~mcr;
+}
+
+/**
+ * @brief	Return Line Status register/status (LSR)
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Line Status register (status)
+ * @note	Mask bits of the returned status value with UART_LSR_*
+ *			definitions for specific statuses.
+ */
+STATIC INLINE uint32_t Chip_UART_ReadLineStatus(LPC_USART_T *pUART)
+{
+	return pUART->LSR;
+}
+
+/**
+ * @brief	Return Modem Status register/status (MSR)
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Modem Status register (status)
+ * @note	Mask bits of the returned status value with UART_MSR_*
+ *			definitions for specific statuses.
+ */
+STATIC INLINE uint32_t Chip_UART_ReadModemStatus(LPC_USART_T *pUART)
+{
+	return pUART->MSR;
+}
+
+/**
+ * @brief	Write a byte to the scratchpad register
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	data	: Byte value to write
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_UART_SetScratch(LPC_USART_T *pUART, uint8_t data)
+{
+	pUART->SCR = (uint32_t) data;
+}
+
+/**
+ * @brief	Returns current byte value in the scratchpad register
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Byte value read from scratchpad register
+ */
+STATIC INLINE uint8_t Chip_UART_ReadScratch(LPC_USART_T *pUART)
+{
+	return (uint8_t) (pUART->SCR & 0xFF);
+}
+
+/**
+ * @brief	Set autobaud register options
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	acr		: Or'ed values to set for ACR register
+ * @return	Nothing
+ * @note	Use an Or'ed value of UART_ACR_* definitions with this
+ *			call to set specific options.
+ */
+STATIC INLINE void Chip_UART_SetAutoBaudReg(LPC_USART_T *pUART, uint32_t acr)
+{
+	pUART->ACR |= acr;
+}
+
+/**
+ * @brief	Clear autobaud register options
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	acr		: Or'ed values to clear for ACR register
+ * @return	Nothing
+ * @note	Use an Or'ed value of UART_ACR_* definitions with this
+ *			call to clear specific options.
+ */
+STATIC INLINE void Chip_UART_ClearAutoBaudReg(LPC_USART_T *pUART, uint32_t acr)
+{
+	pUART->ACR &= ~acr;
+}
+
+/**
+ * @brief	Set RS485 control register options
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	ctrl	: Or'ed values to set for RS485 control register
+ * @return	Nothing
+ * @note	Use an Or'ed value of UART_RS485CTRL_* definitions with this
+ *			call to set specific options.
+ */
+STATIC INLINE void Chip_UART_SetRS485Flags(LPC_USART_T *pUART, uint32_t ctrl)
+{
+	pUART->RS485CTRL |= ctrl;
+}
+
+/**
+ * @brief	Clear RS485 control register options
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	ctrl	: Or'ed values to clear for RS485 control register
+ * @return	Nothing
+ * @note	Use an Or'ed value of UART_RS485CTRL_* definitions with this
+ *			call to clear specific options.
+ */
+STATIC INLINE void Chip_UART_ClearRS485Flags(LPC_USART_T *pUART, uint32_t ctrl)
+{
+	pUART->RS485CTRL &= ~ctrl;
+}
+
+/**
+ * @brief	Set RS485 address match value
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	addr	: Address match value for RS-485/EIA-485 mode
+ * @return	Nothing
+ */
+STATIC INLINE void Chip_UART_SetRS485Addr(LPC_USART_T *pUART, uint8_t addr)
+{
+	pUART->RS485ADRMATCH = (uint32_t) addr;
+}
+
+/**
+ * @brief	Read RS485 address match value
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Address match value for RS-485/EIA-485 mode
+ */
+STATIC INLINE uint8_t Chip_UART_GetRS485Addr(LPC_USART_T *pUART)
+{
+	return (uint8_t) (pUART->RS485ADRMATCH & 0xFF);
+}
+
+/**
+ * @brief	Set RS485 direction control (RTS or DTR) delay value
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	dly		: direction control (RTS or DTR) delay value
+ * @return	Nothing
+ * @note	This delay time is in periods of the baud clock. Any delay
+ *			time from 0 to 255 bit times may be programmed.
+ */
+STATIC INLINE void Chip_UART_SetRS485Delay(LPC_USART_T *pUART, uint8_t dly)
+{
+	pUART->RS485DLY = (uint32_t) dly;
+}
+
+/**
+ * @brief	Read RS485 direction control (RTS or DTR) delay value
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	direction control (RTS or DTR) delay value
+ * @note	This delay time is in periods of the baud clock. Any delay
+ *			time from 0 to 255 bit times may be programmed.
+ */
+STATIC INLINE uint8_t Chip_UART_GetRS485Delay(LPC_USART_T *pUART)
+{
+	return (uint8_t) (pUART->RS485DLY & 0xFF);
+}
+
+/**
+ * @brief	Initializes the pUART peripheral
+ * @param	pUART		: Pointer to selected pUART peripheral
+ * @return	Nothing
+ */
+void Chip_UART_Init(LPC_USART_T *pUART);
+
+/**
+ * @brief	De-initializes the pUART peripheral.
+ * @param	pUART		: Pointer to selected pUART peripheral
+ * @return	Nothing
+ */
+void Chip_UART_DeInit(LPC_USART_T *pUART);
+
+
+/**
+ * @brief	Check whether if UART is busy or not
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @return	RESET if UART is not busy, otherwise return SET
+ */
+FlagStatus Chip_UART_CheckBusy(LPC_USART_T *pUART);
+
+/**
+ * @brief	Transmit a byte array through the UART peripheral (non-blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to bytes to transmit
+ * @param	numBytes	: Number of bytes to transmit
+ * @return	The actual number of bytes placed into the FIFO
+ * @note	This function places data into the transmit FIFO until either
+ *			all the data is in the FIFO or the FIFO is full. This function
+ *			will not block in the FIFO is full. The actual number of bytes
+ *			placed into the FIFO is returned. This function ignores errors.
+ */
+int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes);
+
+/**
+ * @brief	Read data through the UART peripheral (non-blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to bytes array to fill
+ * @param	numBytes	: Size of the passed data array
+ * @return	The actual number of bytes read
+ * @note	This function reads data from the receive FIFO until either
+ *			all the data has been read or the passed buffer is completely full.
+ *			This function will not block. This function ignores errors.
+ */
+int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes);
+
+/**
+ * @brief	Sets best dividers to get a target bit rate (without fractional divider)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	baudrate	: Target baud rate (baud rate = bit rate)
+ * @return	The actual baud rate, or 0 if no rate can be found
+ */
+uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate);
+
+/**
+ * @brief	Sets best dividers to get a target bit rate (with fractional divider)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	baud		: Target baud rate (baud rate = bit rate)
+ * @return	The actual baud rate, or 0 if no rate can be found
+ * @note	The maximum bit rate possible is (clk / 16), the next possible bit
+ * 			rate is (clk / 32), the next possible bit rate is (clk / 48), no
+ * 			rates in-between any of the above three maximum rates could be set
+ * 			using this API. Fractional dividers can only be used for rates
+ * 			lower than (clk / 48) where @a clk is the base clock of the UART.
+ */
+uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud);
+
+/**
+ * @brief	Transmit a byte array through the UART peripheral (blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to data to transmit
+ * @param	numBytes	: Number of bytes to transmit
+ * @return	The number of bytes transmitted
+ * @note	This function will send or place all bytes into the transmit
+ *			FIFO. This function will block until the last bytes are in the FIFO.
+ */
+int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes);
+
+/**
+ * @brief	Read data through the UART peripheral (blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to data array to fill
+ * @param	numBytes	: Size of the passed data array
+ * @return	The size of the dat array
+ * @note	This function reads data from the receive FIFO until the passed
+ *			buffer is completely full. The function will block until full.
+ *			This function ignores errors.
+ */
+int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes);
+
+/**
+ * @brief	UART receive-only interrupt handler for ring buffers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @return	Nothing
+ * @note	If ring buffer support is desired for the receive side
+ *			of data transfer, the UART interrupt should call this
+ *			function for a receive based interrupt status.
+ */
+void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
+
+/**
+ * @brief	UART transmit-only interrupt handler for ring buffers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @return	Nothing
+ * @note	If ring buffer support is desired for the transmit side
+ *			of data transfer, the UART interrupt should call this
+ *			function for a transmit based interrupt status.
+ */
+void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
+
+/**
+ * @brief	Populate a transmit ring buffer and start UART transmit
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @param	data	: Pointer to buffer to move to ring buffer
+ * @param	bytes	: Number of bytes to move
+ * @return	The number of bytes placed into the ring buffer
+ * @note	Will move the data into the TX ring buffer and start the
+ *			transfer. If the number of bytes returned is less than the
+ *			number of bytes to send, the ring buffer is considered full.
+ */
+uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int bytes);
+
+/**
+ * @brief	Copy data from a receive ring buffer
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @param	data	: Pointer to buffer to fill from ring buffer
+ * @param	bytes	: Size of the passed buffer in bytes
+ * @return	The number of bytes placed into the ring buffer
+ * @note	Will move the data from the RX ring buffer up to the
+ *			the maximum passed buffer size. Returns 0 if there is
+ *			no data in the ring buffer.
+ */
+int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes);
+
+/**
+ * @brief	UART receive/transmit interrupt handler for ring buffers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRXRB	: Pointer to transmit ring buffer
+ * @param	pTXRB	: Pointer to receive ring buffer
+ * @return	Nothing
+ * @note	This provides a basic implementation of the UART IRQ
+ *			handler for support of a ring buffer implementation for
+ *			transmit and receive.
+ */
+void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB);
+
+/**
+ * @brief	Returns the Auto Baud status
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	RESET if autobaud not completed, SET if autobaud completed
+ */
+FlagStatus Chip_UART_GetABEOStatus(LPC_USART_T *pUART);
+
+/**
+ * @brief	Start/stop autobaud operation
+ * @param	pUART	    : Pointer to selected UART peripheral
+ * @param	mode	    : Autobaud mode (UART_ACR_MODE0 or UART_ACR_MODE1)
+ * @param	autorestart	: Enable autorestart (true to enable or false to disable)
+ * @param	NewState	: ENABLE to start autobaud operation, DISABLE to
+ *                          stop autobaud operation
+ * @return	Nothing
+ */
+void Chip_UART_ABCmd(LPC_USART_T *pUART, uint32_t mode, bool autorestart,
+        FunctionalState NewState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UART_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_adc.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_adc.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_adc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_adc.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,383 @@
+/***********************************************************************
+* $Id:: mw_usbd_audio.h 165 2011-04-14 17:41:11Z usb10131                     $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Audio Device Class Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __AUDIO_H__
+#define __AUDIO_H__
+
+
+/* Audio Interface Subclass Codes */
+#define AUDIO_SUBCLASS_UNDEFINED                0x00
+#define AUDIO_SUBCLASS_AUDIOCONTROL             0x01
+#define AUDIO_SUBCLASS_AUDIOSTREAMING           0x02
+#define AUDIO_SUBCLASS_MIDISTREAMING            0x03
+
+/* Audio Interface Protocol Codes */
+#define AUDIO_PROTOCOL_UNDEFINED                0x00
+
+
+/* Audio Descriptor Types */
+#define AUDIO_UNDEFINED_DESCRIPTOR_TYPE         0x20
+#define AUDIO_DEVICE_DESCRIPTOR_TYPE            0x21
+#define AUDIO_CONFIGURATION_DESCRIPTOR_TYPE     0x22
+#define AUDIO_STRING_DESCRIPTOR_TYPE            0x23
+#define AUDIO_INTERFACE_DESCRIPTOR_TYPE         0x24
+#define AUDIO_ENDPOINT_DESCRIPTOR_TYPE          0x25
+
+
+/* Audio Control Interface Descriptor Subtypes */
+#define AUDIO_CONTROL_UNDEFINED                 0x00
+#define AUDIO_CONTROL_HEADER                    0x01
+#define AUDIO_CONTROL_INPUT_TERMINAL            0x02
+#define AUDIO_CONTROL_OUTPUT_TERMINAL           0x03
+#define AUDIO_CONTROL_MIXER_UNIT                0x04
+#define AUDIO_CONTROL_SELECTOR_UNIT             0x05
+#define AUDIO_CONTROL_FEATURE_UNIT              0x06
+#define AUDIO_CONTROL_PROCESSING_UNIT           0x07
+#define AUDIO_CONTROL_EXTENSION_UNIT            0x08
+
+/* Audio Streaming Interface Descriptor Subtypes */
+#define AUDIO_STREAMING_UNDEFINED               0x00
+#define AUDIO_STREAMING_GENERAL                 0x01
+#define AUDIO_STREAMING_FORMAT_TYPE             0x02
+#define AUDIO_STREAMING_FORMAT_SPECIFIC         0x03
+
+/* Audio Endpoint Descriptor Subtypes */
+#define AUDIO_ENDPOINT_UNDEFINED                0x00
+#define AUDIO_ENDPOINT_GENERAL                  0x01
+
+
+/* Audio Descriptor Sizes */
+#define AUDIO_CONTROL_INTERFACE_DESC_SZ(n)      0x08+n
+#define AUDIO_STREAMING_INTERFACE_DESC_SIZE     0x07
+#define AUDIO_INPUT_TERMINAL_DESC_SIZE          0x0C
+#define AUDIO_OUTPUT_TERMINAL_DESC_SIZE         0x09
+#define AUDIO_MIXER_UNIT_DESC_SZ(p,n)           0x0A+p+n
+#define AUDIO_SELECTOR_UNIT_DESC_SZ(p)          0x06+p
+#define AUDIO_FEATURE_UNIT_DESC_SZ(ch,n)        0x07+(ch+1)*n
+#define AUDIO_PROCESSING_UNIT_DESC_SZ(p,n,x)    0x0D+p+n+x
+#define AUDIO_EXTENSION_UNIT_DESC_SZ(p,n)       0x0D+p+n
+#define AUDIO_STANDARD_ENDPOINT_DESC_SIZE       0x09
+#define AUDIO_STREAMING_ENDPOINT_DESC_SIZE      0x07
+
+
+/* Audio Processing Unit Process Types */
+#define AUDIO_UNDEFINED_PROCESS                 0x00
+#define AUDIO_UP_DOWN_MIX_PROCESS               0x01
+#define AUDIO_DOLBY_PROLOGIC_PROCESS            0x02
+#define AUDIO_3D_STEREO_PROCESS                 0x03
+#define AUDIO_REVERBERATION_PROCESS             0x04
+#define AUDIO_CHORUS_PROCESS                    0x05
+#define AUDIO_DYN_RANGE_COMP_PROCESS            0x06
+
+
+/* Audio Request Codes */
+#define AUDIO_REQUEST_UNDEFINED                 0x00
+#define AUDIO_REQUEST_SET_CUR                   0x01
+#define AUDIO_REQUEST_GET_CUR                   0x81
+#define AUDIO_REQUEST_SET_MIN                   0x02
+#define AUDIO_REQUEST_GET_MIN                   0x82
+#define AUDIO_REQUEST_SET_MAX                   0x03
+#define AUDIO_REQUEST_GET_MAX                   0x83
+#define AUDIO_REQUEST_SET_RES                   0x04
+#define AUDIO_REQUEST_GET_RES                   0x84
+#define AUDIO_REQUEST_SET_MEM                   0x05
+#define AUDIO_REQUEST_GET_MEM                   0x85
+#define AUDIO_REQUEST_GET_STAT                  0xFF
+
+
+/* Audio Control Selector Codes */
+#define AUDIO_CONTROL_UNDEFINED                 0x00    /* Common Selector */
+
+/*  Terminal Control Selectors */
+#define AUDIO_COPY_PROTECT_CONTROL              0x01
+
+/*  Feature Unit Control Selectors */
+#define AUDIO_MUTE_CONTROL                      0x01
+#define AUDIO_VOLUME_CONTROL                    0x02
+#define AUDIO_BASS_CONTROL                      0x03
+#define AUDIO_MID_CONTROL                       0x04
+#define AUDIO_TREBLE_CONTROL                    0x05
+#define AUDIO_GRAPHIC_EQUALIZER_CONTROL         0x06
+#define AUDIO_AUTOMATIC_GAIN_CONTROL            0x07
+#define AUDIO_DELAY_CONTROL                     0x08
+#define AUDIO_BASS_BOOST_CONTROL                0x09
+#define AUDIO_LOUDNESS_CONTROL                  0x0A
+
+/*  Processing Unit Control Selectors: */
+#define AUDIO_ENABLE_CONTROL                    0x01    /* Common Selector */
+#define AUDIO_MODE_SELECT_CONTROL               0x02    /* Common Selector */
+
+/*  - Up/Down-mix Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+/*      AUDIO_MODE_SELECT_CONTROL               0x02       Common Selector */
+
+/*  - Dolby Prologic Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+/*      AUDIO_MODE_SELECT_CONTROL               0x02       Common Selector */
+
+/*  - 3D Stereo Extender Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_SPACIOUSNESS_CONTROL              0x02
+
+/*  - Reverberation Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_REVERB_LEVEL_CONTROL              0x02
+#define AUDIO_REVERB_TIME_CONTROL               0x03
+#define AUDIO_REVERB_FEEDBACK_CONTROL           0x04
+
+/*  - Chorus Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_CHORUS_LEVEL_CONTROL              0x02
+#define AUDIO_SHORUS_RATE_CONTROL               0x03
+#define AUDIO_CHORUS_DEPTH_CONTROL              0x04
+
+/*  - Dynamic Range Compressor Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+#define AUDIO_COMPRESSION_RATE_CONTROL          0x02
+#define AUDIO_MAX_AMPL_CONTROL                  0x03
+#define AUDIO_THRESHOLD_CONTROL                 0x04
+#define AUDIO_ATTACK_TIME_CONTROL               0x05
+#define AUDIO_RELEASE_TIME_CONTROL              0x06
+
+/*  Extension Unit Control Selectors */
+/*      AUDIO_ENABLE_CONTROL                    0x01       Common Selector */
+
+/*  Endpoint Control Selectors */
+#define AUDIO_SAMPLING_FREQ_CONTROL             0x01
+#define AUDIO_PITCH_CONTROL                     0x02
+
+
+/* Audio Format Specific Control Selectors */
+
+/*  MPEG Control Selectors */
+#define AUDIO_MPEG_CONTROL_UNDEFINED            0x00
+#define AUDIO_MPEG_DUAL_CHANNEL_CONTROL         0x01
+#define AUDIO_MPEG_SECOND_STEREO_CONTROL        0x02
+#define AUDIO_MPEG_MULTILINGUAL_CONTROL         0x03
+#define AUDIO_MPEG_DYN_RANGE_CONTROL            0x04
+#define AUDIO_MPEG_SCALING_CONTROL              0x05
+#define AUDIO_MPEG_HILO_SCALING_CONTROL         0x06
+
+/*  AC-3 Control Selectors */
+#define AUDIO_AC3_CONTROL_UNDEFINED             0x00
+#define AUDIO_AC3_MODE_CONTROL                  0x01
+#define AUDIO_AC3_DYN_RANGE_CONTROL             0x02
+#define AUDIO_AC3_SCALING_CONTROL               0x03
+#define AUDIO_AC3_HILO_SCALING_CONTROL          0x04
+
+
+/* Audio Format Types */
+#define AUDIO_FORMAT_TYPE_UNDEFINED             0x00
+#define AUDIO_FORMAT_TYPE_I                     0x01
+#define AUDIO_FORMAT_TYPE_II                    0x02
+#define AUDIO_FORMAT_TYPE_III                   0x03
+
+
+/* Audio Format Type Descriptor Sizes */
+#define AUDIO_FORMAT_TYPE_I_DESC_SZ(n)          0x08+(n*3)
+#define AUDIO_FORMAT_TYPE_II_DESC_SZ(n)         0x09+(n*3)
+#define AUDIO_FORMAT_TYPE_III_DESC_SZ(n)        0x08+(n*3)
+#define AUDIO_FORMAT_MPEG_DESC_SIZE             0x09
+#define AUDIO_FORMAT_AC3_DESC_SIZE              0x0A
+
+
+/* Audio Data Format Codes */
+
+/*  Audio Data Format Type I Codes */
+#define AUDIO_FORMAT_TYPE_I_UNDEFINED           0x0000
+#define AUDIO_FORMAT_PCM                        0x0001
+#define AUDIO_FORMAT_PCM8                       0x0002
+#define AUDIO_FORMAT_IEEE_FLOAT                 0x0003
+#define AUDIO_FORMAT_ALAW                       0x0004
+#define AUDIO_FORMAT_MULAW                      0x0005
+
+/*  Audio Data Format Type II Codes */
+#define AUDIO_FORMAT_TYPE_II_UNDEFINED          0x1000
+#define AUDIO_FORMAT_MPEG                       0x1001
+#define AUDIO_FORMAT_AC3                        0x1002
+
+/*  Audio Data Format Type III Codes */
+#define AUDIO_FORMAT_TYPE_III_UNDEFINED         0x2000
+#define AUDIO_FORMAT_IEC1937_AC3                0x2001
+#define AUDIO_FORMAT_IEC1937_MPEG1_L1           0x2002
+#define AUDIO_FORMAT_IEC1937_MPEG1_L2_3         0x2003
+#define AUDIO_FORMAT_IEC1937_MPEG2_NOEXT        0x2003
+#define AUDIO_FORMAT_IEC1937_MPEG2_EXT          0x2004
+#define AUDIO_FORMAT_IEC1937_MPEG2_L1_LS        0x2005
+#define AUDIO_FORMAT_IEC1937_MPEG2_L2_3         0x2006
+
+
+/* Predefined Audio Channel Configuration Bits */
+#define AUDIO_CHANNEL_M                         0x0000  /* Mono */
+#define AUDIO_CHANNEL_L                         0x0001  /* Left Front */
+#define AUDIO_CHANNEL_R                         0x0002  /* Right Front */
+#define AUDIO_CHANNEL_C                         0x0004  /* Center Front */
+#define AUDIO_CHANNEL_LFE                       0x0008  /* Low Freq. Enhance. */
+#define AUDIO_CHANNEL_LS                        0x0010  /* Left Surround */
+#define AUDIO_CHANNEL_RS                        0x0020  /* Right Surround */
+#define AUDIO_CHANNEL_LC                        0x0040  /* Left of Center */
+#define AUDIO_CHANNEL_RC                        0x0080  /* Right of Center */
+#define AUDIO_CHANNEL_S                         0x0100  /* Surround */
+#define AUDIO_CHANNEL_SL                        0x0200  /* Side Left */
+#define AUDIO_CHANNEL_SR                        0x0400  /* Side Right */
+#define AUDIO_CHANNEL_T                         0x0800  /* Top */
+
+
+/* Feature Unit Control Bits */
+#define AUDIO_CONTROL_MUTE                      0x0001
+#define AUDIO_CONTROL_VOLUME                    0x0002
+#define AUDIO_CONTROL_BASS                      0x0004
+#define AUDIO_CONTROL_MID                       0x0008
+#define AUDIO_CONTROL_TREBLE                    0x0010
+#define AUDIO_CONTROL_GRAPHIC_EQUALIZER         0x0020
+#define AUDIO_CONTROL_AUTOMATIC_GAIN            0x0040
+#define AUDIO_CONTROL_DEALY                     0x0080
+#define AUDIO_CONTROL_BASS_BOOST                0x0100
+#define AUDIO_CONTROL_LOUDNESS                  0x0200
+
+/* Processing Unit Control Bits: */
+#define AUDIO_CONTROL_ENABLE                    0x0001  /* Common Bit */
+#define AUDIO_CONTROL_MODE_SELECT               0x0002  /* Common Bit */
+
+/* - Up/Down-mix Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+/*      AUDIO_CONTROL_MODE_SELECT               0x0002     Common Bit */
+
+/* - Dolby Prologic Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+/*      AUDIO_CONTROL_MODE_SELECT               0x0002     Common Bit */
+
+/* - 3D Stereo Extender Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_SPACIOUSNESS              0x0002
+
+/* - Reverberation Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_REVERB_TYPE               0x0002
+#define AUDIO_CONTROL_REVERB_LEVEL              0x0004
+#define AUDIO_CONTROL_REVERB_TIME               0x0008
+#define AUDIO_CONTROL_REVERB_FEEDBACK           0x0010
+
+/* - Chorus Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_CHORUS_LEVEL              0x0002
+#define AUDIO_CONTROL_SHORUS_RATE               0x0004
+#define AUDIO_CONTROL_CHORUS_DEPTH              0x0008
+
+/* - Dynamic Range Compressor Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+#define AUDIO_CONTROL_COMPRESSION_RATE          0x0002
+#define AUDIO_CONTROL_MAX_AMPL                  0x0004
+#define AUDIO_CONTROL_THRESHOLD                 0x0008
+#define AUDIO_CONTROL_ATTACK_TIME               0x0010
+#define AUDIO_CONTROL_RELEASE_TIME              0x0020
+
+/* Extension Unit Control Bits */
+/*      AUDIO_CONTROL_ENABLE                    0x0001     Common Bit */
+
+/* Endpoint Control Bits */
+#define AUDIO_CONTROL_SAMPLING_FREQ             0x01
+#define AUDIO_CONTROL_PITCH                     0x02
+#define AUDIO_MAX_PACKETS_ONLY                  0x80
+
+
+/* Audio Terminal Types */
+
+/*  USB Terminal Types */
+#define AUDIO_TERMINAL_USB_UNDEFINED            0x0100
+#define AUDIO_TERMINAL_USB_STREAMING            0x0101
+#define AUDIO_TERMINAL_USB_VENDOR_SPECIFIC      0x01FF
+
+/*  Input Terminal Types */
+#define AUDIO_TERMINAL_INPUT_UNDEFINED          0x0200
+#define AUDIO_TERMINAL_MICROPHONE               0x0201
+#define AUDIO_TERMINAL_DESKTOP_MICROPHONE       0x0202
+#define AUDIO_TERMINAL_PERSONAL_MICROPHONE      0x0203
+#define AUDIO_TERMINAL_OMNI_DIR_MICROPHONE      0x0204
+#define AUDIO_TERMINAL_MICROPHONE_ARRAY         0x0205
+#define AUDIO_TERMINAL_PROCESSING_MIC_ARRAY     0x0206
+
+/*  Output Terminal Types */
+#define AUDIO_TERMINAL_OUTPUT_UNDEFINED         0x0300
+#define AUDIO_TERMINAL_SPEAKER                  0x0301
+#define AUDIO_TERMINAL_HEADPHONES               0x0302
+#define AUDIO_TERMINAL_HEAD_MOUNTED_AUDIO       0x0303
+#define AUDIO_TERMINAL_DESKTOP_SPEAKER          0x0304
+#define AUDIO_TERMINAL_ROOM_SPEAKER             0x0305
+#define AUDIO_TERMINAL_COMMUNICATION_SPEAKER    0x0306
+#define AUDIO_TERMINAL_LOW_FREQ_SPEAKER         0x0307
+
+/*  Bi-directional Terminal Types */
+#define AUDIO_TERMINAL_BIDIRECTIONAL_UNDEFINED  0x0400
+#define AUDIO_TERMINAL_HANDSET                  0x0401
+#define AUDIO_TERMINAL_HEAD_MOUNTED_HANDSET     0x0402
+#define AUDIO_TERMINAL_SPEAKERPHONE             0x0403
+#define AUDIO_TERMINAL_SPEAKERPHONE_ECHOSUPRESS 0x0404
+#define AUDIO_TERMINAL_SPEAKERPHONE_ECHOCANCEL  0x0405
+
+/*  Telephony Terminal Types */
+#define AUDIO_TERMINAL_TELEPHONY_UNDEFINED      0x0500
+#define AUDIO_TERMINAL_PHONE_LINE               0x0501
+#define AUDIO_TERMINAL_TELEPHONE                0x0502
+#define AUDIO_TERMINAL_DOWN_LINE_PHONE          0x0503
+
+/*  External Terminal Types */
+#define AUDIO_TERMINAL_EXTERNAL_UNDEFINED       0x0600
+#define AUDIO_TERMINAL_ANALOG_CONNECTOR         0x0601
+#define AUDIO_TERMINAL_DIGITAL_AUDIO_INTERFACE  0x0602
+#define AUDIO_TERMINAL_LINE_CONNECTOR           0x0603
+#define AUDIO_TERMINAL_LEGACY_AUDIO_CONNECTOR   0x0604
+#define AUDIO_TERMINAL_SPDIF_INTERFACE          0x0605
+#define AUDIO_TERMINAL_1394_DA_STREAM           0x0606
+#define AUDIO_TERMINAL_1394_DA_STREAM_TRACK     0x0607
+
+/*  Embedded Function Terminal Types */
+#define AUDIO_TERMINAL_EMBEDDED_UNDEFINED       0x0700
+#define AUDIO_TERMINAL_CALIBRATION_NOISE        0x0701
+#define AUDIO_TERMINAL_EQUALIZATION_NOISE       0x0702
+#define AUDIO_TERMINAL_CD_PLAYER                0x0703
+#define AUDIO_TERMINAL_DAT                      0x0704
+#define AUDIO_TERMINAL_DCC                      0x0705
+#define AUDIO_TERMINAL_MINI_DISK                0x0706
+#define AUDIO_TERMINAL_ANALOG_TAPE              0x0707
+#define AUDIO_TERMINAL_PHONOGRAPH               0x0708
+#define AUDIO_TERMINAL_VCR_AUDIO                0x0709
+#define AUDIO_TERMINAL_VIDEO_DISC_AUDIO         0x070A
+#define AUDIO_TERMINAL_DVD_AUDIO                0x070B
+#define AUDIO_TERMINAL_TV_TUNER_AUDIO           0x070C
+#define AUDIO_TERMINAL_SATELLITE_RECEIVER_AUDIO 0x070D
+#define AUDIO_TERMINAL_CABLE_TUNER_AUDIO        0x070E
+#define AUDIO_TERMINAL_DSS_AUDIO                0x070F
+#define AUDIO_TERMINAL_RADIO_RECEIVER           0x0710
+#define AUDIO_TERMINAL_RADIO_TRANSMITTER        0x0711
+#define AUDIO_TERMINAL_MULTI_TRACK_RECORDER     0x0712
+#define AUDIO_TERMINAL_SYNTHESIZER              0x0713
+
+
+#endif  /* __AUDIO_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdc.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdc.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdc.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,255 @@
+/***********************************************************************
+* $Id:: mw_usbd_cdc.h 165 2011-04-14 17:41:11Z usb10131                       $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Communication Device Class User module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __CDC_H
+#define __CDC_H
+
+#include "usbd.h"
+
+/*----------------------------------------------------------------------------
+ *      Definitions  based on usbcdc11.pdf (www.usb.org)
+ *---------------------------------------------------------------------------*/
+/* Communication device class specification version 1.10 */
+#define CDC_V1_10                               0x0110
+
+/* Communication interface class code */
+/* (usbcdc11.pdf, 4.2, Table 15) */
+#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
+
+/* Communication interface class subclass codes */
+/* (usbcdc11.pdf, 4.3, Table 16) */
+#define CDC_DIRECT_LINE_CONTROL_MODEL           0x01
+#define CDC_ABSTRACT_CONTROL_MODEL              0x02
+#define CDC_TELEPHONE_CONTROL_MODEL             0x03
+#define CDC_MULTI_CHANNEL_CONTROL_MODEL         0x04
+#define CDC_CAPI_CONTROL_MODEL                  0x05
+#define CDC_ETHERNET_NETWORKING_CONTROL_MODEL   0x06
+#define CDC_ATM_NETWORKING_CONTROL_MODEL        0x07
+
+/* Communication interface class control protocol codes */
+/* (usbcdc11.pdf, 4.4, Table 17) */
+#define CDC_PROTOCOL_COMMON_AT_COMMANDS         0x01
+
+/* Data interface class code */
+/* (usbcdc11.pdf, 4.5, Table 18) */
+#define CDC_DATA_INTERFACE_CLASS                0x0A
+
+/* Data interface class protocol codes */
+/* (usbcdc11.pdf, 4.7, Table 19) */
+#define CDC_PROTOCOL_ISDN_BRI                   0x30
+#define CDC_PROTOCOL_HDLC                       0x31
+#define CDC_PROTOCOL_TRANSPARENT                0x32
+#define CDC_PROTOCOL_Q921_MANAGEMENT            0x50
+#define CDC_PROTOCOL_Q921_DATA_LINK             0x51
+#define CDC_PROTOCOL_Q921_MULTIPLEXOR           0x52
+#define CDC_PROTOCOL_V42                        0x90
+#define CDC_PROTOCOL_EURO_ISDN                  0x91
+#define CDC_PROTOCOL_V24_RATE_ADAPTATION        0x92
+#define CDC_PROTOCOL_CAPI                       0x93
+#define CDC_PROTOCOL_HOST_BASED_DRIVER          0xFD
+#define CDC_PROTOCOL_DESCRIBED_IN_PUFD          0xFE
+
+/* Type values for bDescriptorType field of functional descriptors */
+/* (usbcdc11.pdf, 5.2.3, Table 24) */
+#define CDC_CS_INTERFACE                        0x24
+#define CDC_CS_ENDPOINT                         0x25
+
+/* Type values for bDescriptorSubtype field of functional descriptors */
+/* (usbcdc11.pdf, 5.2.3, Table 25) */
+#define CDC_HEADER                              0x00
+#define CDC_CALL_MANAGEMENT                     0x01
+#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
+#define CDC_DIRECT_LINE_MANAGEMENT              0x03
+#define CDC_TELEPHONE_RINGER                    0x04
+#define CDC_REPORTING_CAPABILITIES              0x05
+#define CDC_UNION                               0x06
+#define CDC_COUNTRY_SELECTION                   0x07
+#define CDC_TELEPHONE_OPERATIONAL_MODES         0x08
+#define CDC_USB_TERMINAL                        0x09
+#define CDC_NETWORK_CHANNEL                     0x0A
+#define CDC_PROTOCOL_UNIT                       0x0B
+#define CDC_EXTENSION_UNIT                      0x0C
+#define CDC_MULTI_CHANNEL_MANAGEMENT            0x0D
+#define CDC_CAPI_CONTROL_MANAGEMENT             0x0E
+#define CDC_ETHERNET_NETWORKING                 0x0F
+#define CDC_ATM_NETWORKING                      0x10
+
+/* CDC class-specific request codes */
+/* (usbcdc11.pdf, 6.2, Table 46) */
+/* see Table 45 for info about the specific requests. */
+#define CDC_SEND_ENCAPSULATED_COMMAND           0x00
+#define CDC_GET_ENCAPSULATED_RESPONSE           0x01
+#define CDC_SET_COMM_FEATURE                    0x02
+#define CDC_GET_COMM_FEATURE                    0x03
+#define CDC_CLEAR_COMM_FEATURE                  0x04
+#define CDC_SET_AUX_LINE_STATE                  0x10
+#define CDC_SET_HOOK_STATE                      0x11
+#define CDC_PULSE_SETUP                         0x12
+#define CDC_SEND_PULSE                          0x13
+#define CDC_SET_PULSE_TIME                      0x14
+#define CDC_RING_AUX_JACK                       0x15
+#define CDC_SET_LINE_CODING                     0x20
+#define CDC_GET_LINE_CODING                     0x21
+#define CDC_SET_CONTROL_LINE_STATE              0x22
+#define CDC_SEND_BREAK                          0x23
+#define CDC_SET_RINGER_PARMS                    0x30
+#define CDC_GET_RINGER_PARMS                    0x31
+#define CDC_SET_OPERATION_PARMS                 0x32
+#define CDC_GET_OPERATION_PARMS                 0x33
+#define CDC_SET_LINE_PARMS                      0x34
+#define CDC_GET_LINE_PARMS                      0x35
+#define CDC_DIAL_DIGITS                         0x36
+#define CDC_SET_UNIT_PARAMETER                  0x37
+#define CDC_GET_UNIT_PARAMETER                  0x38
+#define CDC_CLEAR_UNIT_PARAMETER                0x39
+#define CDC_GET_PROFILE                         0x3A
+#define CDC_SET_ETHERNET_MULTICAST_FILTERS      0x40
+#define CDC_SET_ETHERNET_PMP_FILTER             0x41
+#define CDC_GET_ETHERNET_PMP_FILTER             0x42
+#define CDC_SET_ETHERNET_PACKET_FILTER          0x43
+#define CDC_GET_ETHERNET_STATISTIC              0x44
+#define CDC_SET_ATM_DATA_FORMAT                 0x50
+#define CDC_GET_ATM_DEVICE_STATISTICS           0x51
+#define CDC_SET_ATM_DEFAULT_VC                  0x52
+#define CDC_GET_ATM_VC_STATISTICS               0x53
+
+/* Communication feature selector codes */
+/* (usbcdc11.pdf, 6.2.2..6.2.4, Table 47) */
+#define CDC_ABSTRACT_STATE                      0x01
+#define CDC_COUNTRY_SETTING                     0x02
+
+/* Feature Status returned for ABSTRACT_STATE Selector */
+/* (usbcdc11.pdf, 6.2.3, Table 48) */
+#define CDC_IDLE_SETTING                        (1 << 0)
+#define CDC_DATA_MULTPLEXED_STATE               (1 << 1)
+
+
+/* Control signal bitmap values for the SetControlLineState request */
+/* (usbcdc11.pdf, 6.2.14, Table 51) */
+#define CDC_DTE_PRESENT                         (1 << 0)
+#define CDC_ACTIVATE_CARRIER                    (1 << 1)
+
+/* CDC class-specific notification codes */
+/* (usbcdc11.pdf, 6.3, Table 68) */
+/* see Table 67 for Info about class-specific notifications */
+#define CDC_NOTIFICATION_NETWORK_CONNECTION     0x00
+#define CDC_RESPONSE_AVAILABLE                  0x01
+#define CDC_AUX_JACK_HOOK_STATE                 0x08
+#define CDC_RING_DETECT                         0x09
+#define CDC_NOTIFICATION_SERIAL_STATE           0x20
+#define CDC_CALL_STATE_CHANGE                   0x28
+#define CDC_LINE_STATE_CHANGE                   0x29
+#define CDC_CONNECTION_SPEED_CHANGE             0x2A
+
+/* UART state bitmap values (Serial state notification). */
+/* (usbcdc11.pdf, 6.3.5, Table 69) */
+#define CDC_SERIAL_STATE_OVERRUN                (1 << 6)  /* receive data overrun error has occurred */
+#define CDC_SERIAL_STATE_PARITY                 (1 << 5)  /* parity error has occurred */
+#define CDC_SERIAL_STATE_FRAMING                (1 << 4)  /* framing error has occurred */
+#define CDC_SERIAL_STATE_RING                   (1 << 3)  /* state of ring signal detection */
+#define CDC_SERIAL_STATE_BREAK                  (1 << 2)  /* state of break detection */
+#define CDC_SERIAL_STATE_TX_CARRIER             (1 << 1)  /* state of transmission carrier */
+#define CDC_SERIAL_STATE_RX_CARRIER             (1 << 0)  /* state of receiver carrier */
+
+
+/*----------------------------------------------------------------------------
+ *      Structures  based on usbcdc11.pdf (www.usb.org)
+ *---------------------------------------------------------------------------*/
+
+/* Header functional descriptor */
+/* (usbcdc11.pdf, 5.2.3.1) */
+/* This header must precede any list of class-specific descriptors. */
+PRE_PACK struct POST_PACK _CDC_HEADER_DESCRIPTOR{
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* Header functional descriptor subtype */
+  uint16_t bcdCDC;                               /* USB CDC specification release version */
+};
+typedef struct _CDC_HEADER_DESCRIPTOR CDC_HEADER_DESCRIPTOR;
+
+/* Call management functional descriptor */
+/* (usbcdc11.pdf, 5.2.3.2) */
+/* Describes the processing of calls for the communication class interface. */
+PRE_PACK struct POST_PACK _CDC_CALL_MANAGEMENT_DESCRIPTOR {
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* call management functional descriptor subtype */
+  uint8_t  bmCapabilities;                       /* capabilities that this configuration supports */
+  uint8_t  bDataInterface;                       /* interface number of the data class interface used for call management (optional) */
+};
+typedef struct _CDC_CALL_MANAGEMENT_DESCRIPTOR CDC_CALL_MANAGEMENT_DESCRIPTOR;
+
+/* Abstract control management functional descriptor */
+/* (usbcdc11.pdf, 5.2.3.3) */
+/* Describes the command supported by the communication interface class with the Abstract Control Model subclass code. */
+PRE_PACK struct POST_PACK _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR {
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* abstract control management functional descriptor subtype */
+  uint8_t  bmCapabilities;                       /* capabilities supported by this configuration */
+};
+typedef struct _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR;
+
+/* Union functional descriptors */
+/* (usbcdc11.pdf, 5.2.3.8) */
+/* Describes the relationship between a group of interfaces that can be considered to form a functional unit. */
+PRE_PACK struct POST_PACK _CDC_UNION_DESCRIPTOR {
+  uint8_t  bFunctionLength;                      /* size of this descriptor in bytes */
+  uint8_t  bDescriptorType;                      /* CS_INTERFACE descriptor type */
+  uint8_t  bDescriptorSubtype;                   /* union functional descriptor subtype */
+  uint8_t  bMasterInterface;                     /* interface number designated as master */
+};
+typedef struct _CDC_UNION_DESCRIPTOR CDC_UNION_DESCRIPTOR;
+
+/* Union functional descriptors with one slave interface */
+/* (usbcdc11.pdf, 5.2.3.8) */
+PRE_PACK struct POST_PACK _CDC_UNION_1SLAVE_DESCRIPTOR {
+  CDC_UNION_DESCRIPTOR sUnion;              /* Union functional descriptor */
+  uint8_t              bSlaveInterfaces[1]; /* Slave interface 0 */
+};
+typedef struct _CDC_UNION_1SLAVE_DESCRIPTOR CDC_UNION_1SLAVE_DESCRIPTOR;
+
+/* Line coding structure */
+/* Format of the data returned when a GetLineCoding request is received */
+/* (usbcdc11.pdf, 6.2.13) */
+PRE_PACK struct POST_PACK _CDC_LINE_CODING {
+  uint32_t dwDTERate;                            /* Data terminal rate in bits per second */
+  uint8_t  bCharFormat;                          /* Number of stop bits */
+  uint8_t  bParityType;                          /* Parity bit type */
+  uint8_t  bDataBits;                            /* Number of data bits */
+};
+typedef struct _CDC_LINE_CODING CDC_LINE_CODING;
+
+/* Notification header */
+/* Data sent on the notification endpoint must follow this header. */
+/* see  USB_SETUP_PACKET in file usb.h */
+typedef USB_SETUP_PACKET CDC_NOTIFICATION_HEADER;
+
+#endif /* __CDC_H */
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdcuser.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdcuser.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdcuser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_cdcuser.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,535 @@
+/***********************************************************************
+* $Id:: mw_usbd_cdcuser.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Communication Device Class User module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __CDCUSER_H__
+#define __CDCUSER_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_cdc.h"
+
+/** \file
+ *  \brief Communication Device Class (CDC) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based CDC function driver.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_CDC Communication Device Class (CDC) Function Driver
+ *  \section Sec_CDCModDescription Module Description
+ *  CDC Class Function Driver module. This module contains an internal implementation of the USB CDC Class.
+ *
+ *  User applications can use this class driver instead of implementing the CDC-ACM class manually
+ *  via the low-level USBD_HW and USBD_Core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB CDC-ACM Class.
+ */
+
+/*----------------------------------------------------------------------------
+  We need a buffer for incoming data on USB port because USB receives
+  much faster than  UART transmits
+ *---------------------------------------------------------------------------*/
+/* Buffer masks */
+#define CDC_BUF_SIZE               (128)               /* Output buffer in bytes (power 2) */
+                                                       /* large enough for file transfer */
+#define CDC_BUF_MASK               (CDC_BUF_SIZE-1ul)
+
+/** \brief Communication Device Class function driver initialization parameter data structure.
+ *  \ingroup USBD_CDC
+ *
+ *  \details  This data structure is used to pass initialization parameters to the 
+ *  Communication Device Class function driver's init function.
+ *
+ */
+typedef struct USBD_CDC_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use. 
+                      \note The \em mem_size should be greater than the size 
+                      returned by USBD_CDC_API::GetMemSize() routine.*/
+  /** Pointer to the control interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T 
+  * structure. The stack assumes both HS and FS use same BULK endpoints. 
+  */
+  uint8_t* cif_intf_desc;
+  /** Pointer to the data interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T 
+  * structure. The stack assumes both HS and FS use same BULK endpoints. 
+  */
+  uint8_t* dif_intf_desc;
+
+  /* user defined functions */
+
+  /* required functions */
+  /** 
+  *  Communication Interface Class specific get request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends CIC management element get requests.
+  *  \note Applications implementing Abstract Control Model subclass can set this
+  *  param to NULL. As the default driver parses ACM requests and calls the
+  *  individual ACM call-back routines defined in this structure. For all other subclasses
+  *  this routine should be provided by the application.
+  *  \n
+  *  The setup packet data (\em pSetup) is passed to the call-back so that application
+  *  can extract the CIC request type and other associated data. By default the stack
+  *  will assign \em pBuffer pointer to \em EP0Buff allocated at init. The application
+  *  code can directly write data into this buffer as long as data is less than 64 byte.
+  *  If more data has to be sent then application code should update \em pBuffer pointer
+  *  and length accordingly.
+  *   
+  *  
+  *  \param[in] hCdc Handle to CDC function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing request data. 
+  *                       Pointer-to-pointer is used to implement zero-copy buffers. 
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in, out] length  Amount of data to be sent back to host.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*CIC_GetRequest)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length); 
+  
+  /** 
+  *  Communication Interface Class specific set request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a CIC management element requests.
+  *  \note Applications implementing Abstract Control Model subclass can set this
+  *  param to NULL. As the default driver parses ACM requests and calls the
+  *  individual ACM call-back routines defined in this structure. For all other subclasses
+  *  this routine should be provided by the application.
+  *  \n
+  *  The setup packet data (\em pSetup) is passed to the call-back so that application can
+  *  extract the CIC request type and other associated data. If a set request has data associated,
+  *  then this call-back is called twice.
+  *  -# First when setup request is received, at this time application code could update
+  *  \em pBuffer pointer to point to the intended destination. The length param is set to 0
+  *  so that application code knows this is first time. By default the stack will
+  *  assign \em pBuffer pointer to \em EP0Buff allocated at init. Note, if data length is 
+  *  greater than 64 bytes and application code doesn't update \em pBuffer pointer the 
+  *  stack will send STALL condition to host.
+  *  -# Second when the data is received from the host. This time the length param is set
+  *  with number of data bytes received.
+  *  
+  *  \param[in] hCdc Handle to CDC function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing request data. 
+  *                       Pointer-to-pointer is used to implement zero-copy buffers. 
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*CIC_SetRequest)( USBD_HANDLE_T hCdc, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+
+  /** 
+  *  Communication Device Class specific BULK IN endpoint handler.
+  *
+  *  The application software should provide the BULK IN endpoint handler.
+  *  Applications should transfer data depending on the communication protocol type set in descriptors. 
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*CDC_BulkIN_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /** 
+  *  Communication Device Class specific BULK OUT endpoint handler.
+  *
+  *  The application software should provide the BULK OUT endpoint handler.
+  *  Applications should transfer data depending on the communication protocol type set in descriptors. 
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*CDC_BulkOUT_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SEND_ENCAPSULATED_COMMAND request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SEND_ENCAPSULATED_COMMAND set request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] buffer Pointer to the command buffer.
+  *  \param[in] len  Length of the command buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SendEncpsCmd) (USBD_HANDLE_T hCDC, uint8_t* buffer, uint16_t len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific GET_ENCAPSULATED_RESPONSE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a GET_ENCAPSULATED_RESPONSE request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in, out] buffer Pointer to a pointer of data buffer containing response data.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in, out] len  Amount of data to be sent back to host.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*GetEncpsResp) (USBD_HANDLE_T hCDC, uint8_t** buffer, uint16_t* len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SET_COMM_FEATURE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SET_COMM_FEATURE set request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.
+  *  \param[in] buffer Pointer to the settings buffer for the specified communication feature.
+  *  \param[in] len  Length of the request buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t* buffer, uint16_t len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific GET_COMM_FEATURE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a GET_ENCAPSULATED_RESPONSE request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.
+  *  \param[in, out] buffer Pointer to a pointer of data buffer containing current settings
+  *                         for the communication feature.
+  *                       Pointer-to-pointer is used to implement zero-copy buffers.
+  *  \param[in, out] len  Amount of data to be sent back to host.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*GetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t** pBuffer, uint16_t* len);
+
+  /**
+  *  Abstract control model(ACM) subclass specific CLEAR_COMM_FEATURE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a CLEAR_COMM_FEATURE request. In the call-back the application
+  *  should Clears the settings for a particular communication feature.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*ClrCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SET_CONTROL_LINE_STATE request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SET_CONTROL_LINE_STATE request. RS-232 signal used to tell the DCE
+  *  device the DTE device is now present
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] state The state value uses bitmap values defined in usbcdc11.pdf,
+  *        section 6.2.14, Table 51.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SetCtrlLineState) (USBD_HANDLE_T hCDC, uint16_t state);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SEND_BREAK request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SEND_BREAK request.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] mstime Duration of Break signal in milliseconds. If mstime is FFFFh, then
+  *        the application should send break until another SendBreak request is received
+  *        with the wValue of 0000h.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SendBreak) (USBD_HANDLE_T hCDC, uint16_t mstime);
+
+  /**
+  *  Abstract control model(ACM) subclass specific SET_LINE_CODING request call-back function.
+  *
+  *  This function is provided by the application software. This function gets called
+  *  when host sends a SET_LINE_CODING request. The application should configure the device
+  *  per DTE rate, stop-bits, parity, and number-of-character bits settings provided in
+  *  command buffer. See usbcdc11.pdf, section 6.2.13, table 50 for detail of the command buffer.
+  *
+  *  \param[in] hCdc Handle to CDC function driver.
+  *  \param[in] line_coding Pointer to the CDC_LINE_CODING command buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.
+  *          \retval ERR_USBD_xxx  For other error conditions.
+  *
+  */
+  ErrorCode_t (*SetLineCode) (USBD_HANDLE_T hCDC, CDC_LINE_CODING* line_coding);
+
+  /** 
+  *  Optional Communication Device Class specific INTERRUPT IN endpoint handler.
+  *
+  *  The application software should provide the INT IN endpoint handler.
+  *  Applications should transfer data depending on the communication protocol type set in descriptors. 
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*CDC_InterruptEP_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /** 
+  *  Optional user override-able function to replace the default CDC class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_CDC_API::Init().
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*CDC_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+} USBD_CDC_INIT_PARAM_T;
+
+/** \brief CDC class API functions structure.
+ *  \ingroup USBD_CDC
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_CDC_API
+{
+  /** \fn uint32_t GetMemSize(USBD_CDC_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the CDC function driver module.
+   * 
+   *  This function is called by application layer before calling pUsbApi->CDC->Init(), to allocate memory used 
+   *  by CDC function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller. 
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing CDC function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_CDC_INIT_PARAM_T* param);
+  
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param)
+   *  Function to initialize CDC function driver module.
+   * 
+   *  This function is called by application layer to initialize CDC function driver module.
+   *
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in, out] param Structure containing CDC function driver module initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte 
+   *              aligned or smaller than required. 
+   *          \retval ERR_API_INVALID_PARAM2 Either CDC_Write() or CDC_Read() or
+   *              CDC_Verify() callbacks are not defined. 
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
+   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param, USBD_HANDLE_T* phCDC);
+
+  /** \fn ErrorCode_t SendNotification(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data)
+   *  Function to send CDC class notifications to host. 
+   * 
+   *  This function is called by application layer to send CDC class notifications to host. 
+   *  See usbcdc11.pdf, section 6.3, Table 67 for various notification types the CDC device can send.
+   *  \note The current version of the driver only supports following notifications allowed by ACM subclass:
+   *  CDC_NOTIFICATION_NETWORK_CONNECTION, CDC_RESPONSE_AVAILABLE, CDC_NOTIFICATION_SERIAL_STATE.
+   *  \n 
+   *  For all other notifications application should construct the notification buffer appropriately
+   *  and call hw->USB_WriteEP() for interrupt endpoint associated with the interface.
+   *
+   *  \param[in] hCdc Handle to CDC function driver.  
+   *  \param[in] bNotification Notification type allowed by ACM subclass. Should be CDC_NOTIFICATION_NETWORK_CONNECTION,
+   *        CDC_RESPONSE_AVAILABLE or CDC_NOTIFICATION_SERIAL_STATE. For all other types ERR_API_INVALID_PARAM2
+   *        is returned. See usbcdc11.pdf, section 3.6.2.1, table 5.
+   *  \param[in] data Data associated with notification.  
+   *        \n For CDC_NOTIFICATION_NETWORK_CONNECTION a non-zero data value is interpreted as connected state.
+   *        \n For CDC_RESPONSE_AVAILABLE this parameter is ignored.
+   *        \n For CDC_NOTIFICATION_SERIAL_STATE the data should use bitmap values defined in usbcdc11.pdf, 
+   *        section 6.3.5, Table 69.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_API_INVALID_PARAM2  If unsupported notification type is passed. 
+   *              
+   */
+  ErrorCode_t (*SendNotification)(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data);
+
+} USBD_CDC_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _CDC_CTRL_T
+{
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  /* notification buffer */
+  uint8_t notice_buf[12];
+  CDC_LINE_CODING line_coding;
+  uint8_t pad0;
+
+  uint8_t cif_num;                 /* control interface number */
+  uint8_t dif_num;                 /* data interface number */
+  uint8_t epin_num;                /* BULK IN endpoint number */
+  uint8_t epout_num;               /* BULK OUT endpoint number */
+  uint8_t epint_num;               /* Interrupt IN endpoint number */
+  uint8_t pad[3];
+  /* user defined functions */
+  ErrorCode_t (*SendEncpsCmd) (USBD_HANDLE_T hCDC, uint8_t* buffer, uint16_t len);
+  ErrorCode_t (*GetEncpsResp) (USBD_HANDLE_T hCDC, uint8_t** buffer, uint16_t* len);
+  ErrorCode_t (*SetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t* buffer, uint16_t len);
+  ErrorCode_t (*GetCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature, uint8_t** pBuffer, uint16_t* len);
+  ErrorCode_t (*ClrCommFeature) (USBD_HANDLE_T hCDC, uint16_t feature);
+  ErrorCode_t (*SetCtrlLineState) (USBD_HANDLE_T hCDC, uint16_t state);
+  ErrorCode_t (*SendBreak) (USBD_HANDLE_T hCDC, uint16_t state);
+  ErrorCode_t (*SetLineCode) (USBD_HANDLE_T hCDC, CDC_LINE_CODING* line_coding);
+
+  /* virtual functions */
+  ErrorCode_t (*CIC_GetRequest)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length); 
+  ErrorCode_t (*CIC_SetRequest)( USBD_HANDLE_T hCdc, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+
+} USB_CDC_CTRL_T;
+
+/* structure used by old ROM drivers, needed for workaround */
+typedef struct _CDC0_CTRL_T {
+	USB_CORE_CTRL_T *pUsbCtrl;
+	/* notification buffer */
+	uint8_t notice_buf[12];
+	CDC_LINE_CODING line_coding;
+
+	uint8_t cif_num;				/* control interface number */
+	uint8_t dif_num;				/* data interface number */
+	uint8_t epin_num;				/* BULK IN endpoint number */
+	uint8_t epout_num;				/* BULK OUT endpoint number */
+	uint8_t epint_num;				/* Interrupt IN endpoint number */
+	/* user defined functions */
+	ErrorCode_t (*SendEncpsCmd)(USBD_HANDLE_T hCDC, uint8_t *buffer, uint16_t len);
+	ErrorCode_t (*GetEncpsResp)(USBD_HANDLE_T hCDC, uint8_t * *buffer, uint16_t *len);
+	ErrorCode_t (*SetCommFeature)(USBD_HANDLE_T hCDC, uint16_t feature, uint8_t *buffer, uint16_t len);
+	ErrorCode_t (*GetCommFeature)(USBD_HANDLE_T hCDC, uint16_t feature, uint8_t * *pBuffer, uint16_t *len);
+	ErrorCode_t (*ClrCommFeature)(USBD_HANDLE_T hCDC, uint16_t feature);
+	ErrorCode_t (*SetCtrlLineState)(USBD_HANDLE_T hCDC, uint16_t state);
+	ErrorCode_t (*SendBreak)(USBD_HANDLE_T hCDC, uint16_t state);
+	ErrorCode_t (*SetLineCode)(USBD_HANDLE_T hCDC, CDC_LINE_CODING *line_coding);
+
+	/* virtual functions */
+	ErrorCode_t (*CIC_GetRequest)(USBD_HANDLE_T hHid, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t *length);
+	ErrorCode_t (*CIC_SetRequest)(USBD_HANDLE_T hCdc, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length);
+
+} USB_CDC0_CTRL_T;
+
+typedef ErrorCode_t (*CIC_SetRequest_t)(USBD_HANDLE_T hCdc, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length);
+
+/** @cond  DIRECT_API */
+extern uint32_t mwCDC_GetMemSize(USBD_CDC_INIT_PARAM_T* param);
+extern ErrorCode_t mwCDC_init(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param, USBD_HANDLE_T* phCDC);
+extern ErrorCode_t mwCDC_SendNotification (USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data); 
+/** @endcond */
+
+/** @endcond */
+
+
+
+
+
+#endif  /* __CDCUSER_H__ */ 
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_core.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_core.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_core.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_core.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,591 @@
+/***********************************************************************
+* $Id:: mw_usbd_core.h 331 2012-08-09 18:54:34Z usb10131                      $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB core controller structure definitions and function prototypes.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MW_USBD_CORE_H__
+#define __MW_USBD_CORE_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "app_usbd_cfg.h"
+
+/** \file
+ *  \brief ROM API for USB device stack.
+ *
+ *  Definition of functions exported by core layer of ROM based USB device stack.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_Core USB Core Layer
+ *  \section Sec_CoreModDescription Module Description
+ *  The USB Core Layer implements the device abstraction defined in the <em> Universal Serial Bus Specification, </em>
+ *  for applications to interact with the USB device interface on the device. The software in this layer responds to 
+ *  standard requests and returns standard descriptors. In current stack the Init() routine part of 
+ *  \ref USBD_HW_API_T structure initializes both hardware layer and core layer.
+ */
+
+
+/* function pointer types */
+
+/** \ingroup USBD_Core 
+ *  \typedef USB_CB_T
+ *  \brief USB device stack's event callback function type.
+ *
+ *  The USB device stack exposes several event triggers through callback to application layer. The
+ *  application layer can register methods to be called when such USB event happens.
+ *  
+ *  \param[in] hUsb Handle to the USB device stack. 
+ *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+ *          \retval LPC_OK On success
+ *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+ *          \retval ERR_USBD_xxx  Other error conditions. 
+ *                                             
+ */
+typedef ErrorCode_t (*USB_CB_T) (USBD_HANDLE_T hUsb);
+
+/** \ingroup USBD_Core 
+ *  \typedef USB_PARAM_CB_T
+ *  \brief USB device stack's event callback function type.
+ *
+ *  The USB device stack exposes several event triggers through callback to application layer. The
+ *  application layer can register methods to be called when such USB event happens.
+ *  
+ *  \param[in] hUsb Handle to the USB device stack. 
+ *  \param[in] param1 Extra information related to the event. 
+ *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+ *          \retval LPC_OK On success
+ *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+ *          \retval ERR_USBD_xxx  For other error conditions. 
+ *                                             
+ */
+typedef ErrorCode_t (*USB_PARAM_CB_T) (USBD_HANDLE_T hUsb, uint32_t param1);
+
+/** \ingroup USBD_Core
+ *  \typedef USB_EP_HANDLER_T
+ *  \brief USBD setup request and endpoint event handler type.
+ *
+ *  The application layer should define the custom class's EP0 handler with function signature. 
+ *  The stack calls all the registered class handlers on any EP0 event before going through default 
+ *  handling of the event. This gives the class handlers to implement class specific request handlers
+ *  and also to override the default stack handling for a particular event targeted to the interface.
+ *  If an event is not handled by the callback the function should return ERR_USBD_UNHANDLED. For all
+ *  other return codes the stack assumes that callback has taken care of the event and hence will not
+ *  process the event any further and issues a STALL condition on EP0 indicating error to the host.
+ *  \n
+ *  For endpoint interrupt handler the return value is ignored by the stack.
+ *  \n
+ *  \param[in] hUsb Handle to the USB device stack. 
+ *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+ *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+ *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+ *          \retval LPC_OK On success.
+ *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+ *          \retval ERR_USBD_xxx  For other error conditions. 
+ *                                             
+ */
+typedef ErrorCode_t (*USB_EP_HANDLER_T)(USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+
+/** \ingroup USBD_Core 
+ *  \brief USB descriptors data structure.
+ *  \ingroup USBD_Core
+ *
+ *  \details  This structure is used as part of USB device stack initialization
+ *  parameter structure \ref USBD_API_INIT_PARAM_T. This structure contains
+ *  pointers to various descriptor arrays needed by the stack. These descriptors
+ *  are reported to USB host as part of enumerations process.
+ *
+ *  \note All descriptor pointers assigned in this structure should be on 4 byte
+ *  aligned address boundary.
+ */
+typedef struct _USB_CORE_DESCS_T
+{
+  uint8_t *device_desc; /**< Pointer to USB device descriptor */
+  uint8_t *string_desc; /**< Pointer to array of USB string descriptors */
+  uint8_t *full_speed_desc; /**< Pointer to USB device configuration descriptor
+                            * when device is operating in full speed mode.
+                            */
+  uint8_t *high_speed_desc; /**< Pointer to USB device configuration descriptor
+                            * when device is operating in high speed mode. For
+                            * full-speed only implementation this pointer should
+                            * be same as full_speed_desc.
+                            */
+  uint8_t *device_qualifier; /**< Pointer to USB device qualifier descriptor. For
+                             * full-speed only implementation this pointer should
+                             * be set to null (0).
+                             */
+} USB_CORE_DESCS_T;
+
+/** \brief USB device stack initialization parameter data structure.
+ *  \ingroup USBD_Core
+ *
+ *  \details  This data structure is used to pass initialization parameters to the 
+ *  USB device stack's init function.
+ *
+ */
+typedef struct USBD_API_INIT_PARAM
+{
+  uint32_t usb_reg_base; /**< USB device controller's base register address. */ 
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 2048 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use. 
+                      \note The \em mem_size should be greater than the size 
+                      returned by USBD_HW_API::GetMemSize() routine.*/
+  uint8_t max_num_ep; /**< max number of endpoints supported by the USB device 
+                      controller instance (specified by \em usb_reg_base field)
+                      to which this instance of stack is attached. 
+                      */
+  uint8_t pad0[3];
+  /* USB Device Events Callback Functions */
+	/** Event for USB interface reset. This event fires when the USB host requests that the device 
+	 *  reset its interface. This event fires after the control endpoint has been automatically
+	 *  configured by the library.
+	 *  \n
+	 *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+	 *  callback will prevent the device from enumerating correctly or operate properly.
+	 *
+	 */
+  USB_CB_T USB_Reset_Event;
+
+	/** Event for USB suspend. This event fires when the USB host suspends the device by halting its
+	 *  transmission of Start Of Frame pulses to the device. This is generally hooked in order to move
+	 *  the device over to a low power state until the host wakes up the device. 
+	 *  \n
+	 *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+	 *  callback will cause other system issues.
+	 */
+  USB_CB_T USB_Suspend_Event;
+
+	/** Event for USB wake up or resume. This event fires when a the USB device interface is suspended 
+	 *  and the host wakes up the device by supplying Start Of Frame pulses. This is generally
+	 *  hooked to pull the user application out of a low power state and back into normal operating
+	 *  mode. 
+	 *  \n
+	 *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+	 *  callback will cause other system issues.
+	 *
+	 */
+  USB_CB_T USB_Resume_Event;
+
+  /** Reserved parameter should be set to zero. */
+  USB_CB_T reserved_sbz;
+
+  /** Event for USB Start Of Frame detection, when enabled. This event fires at the start of each USB
+	 *  frame, once per millisecond in full-speed mode or once per 125 microseconds in high-speed mode,
+   *  and is synchronized to the USB bus. 
+	 *
+	 *  This event is time-critical; it is run once per millisecond (full-speed mode) and thus long handlers 
+	 *  will significantly degrade device performance. This event should only be enabled when needed to 
+   *  reduce device wake-ups.
+	 *
+	 *  \note This event is not normally active - it must be manually enabled and disabled via the USB interrupt
+	 *        register.
+	 *        \n\n
+	 */  
+  USB_CB_T USB_SOF_Event;
+
+  /** Event for remote wake-up configuration, when enabled. This event fires when the USB host
+	 *  request the device to configure itself for remote wake-up capability. The USB host sends
+   *  this request to device which report remote wake-up capable in their device descriptors,
+   *  before going to low-power state. The application layer should implement this callback if
+   *  they have any special on board circuit to trigger remote wake up event. Also application
+   *  can use this callback to differentiate the following SUSPEND event is caused by cable plug-out
+   *  or host SUSPEND request. The device can wake-up host only after receiving this callback and
+   *  remote wake-up feature is enabled by host. To signal remote wake-up the device has to generate
+   *  resume signaling on bus by calling usapi.hw->WakeUp() routine.
+	 *
+	 *  \n\n
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] param1 When 0 - Clear the wake-up configuration, 1 - Enable the wake-up configuration.
+   *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+	 */  
+  USB_PARAM_CB_T USB_WakeUpCfg;
+
+  /** Reserved parameter should be set to zero. */
+  USB_PARAM_CB_T USB_Power_Event;
+
+  /** Event for error condition. This event fires when USB device controller detect 
+	 *  an error condition in the system.  
+	 *
+	 *  \n\n
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] param1 USB device interrupt status register. 
+   *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+   */  
+  USB_PARAM_CB_T USB_Error_Event;
+
+  /* USB Core Events Callback Functions */
+  /** Event for USB configuration number changed. This event fires when a the USB host changes the
+   *  selected configuration number. On receiving configuration change request from host, the stack
+   *  enables/configures the endpoints needed by the new configuration before calling this callback
+   *  function.
+	 *  \n
+	 *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+	 *  callback will prevent the device from enumerating correctly or operate properly.
+   *
+   */
+  USB_CB_T USB_Configure_Event;
+
+  /** Event for USB interface setting changed. This event fires when a the USB host changes the
+   *  interface setting to one of alternate interface settings. On receiving interface change 
+   *  request from host, the stack enables/configures the endpoints needed by the new alternate 
+   *  interface setting before calling this callback function.
+	 *  \n
+	 *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+	 *  callback will prevent the device from enumerating correctly or operate properly.
+   *
+   */
+  USB_CB_T USB_Interface_Event;
+
+  /** Event for USB feature changed. This event fires when a the USB host send set/clear feature
+   *  request. The stack handles this request for USB_FEATURE_REMOTE_WAKEUP, USB_FEATURE_TEST_MODE
+   *  and USB_FEATURE_ENDPOINT_STALL features only. On receiving feature request from host, the  
+   *  stack handle the request appropriately and then calls this callback function.
+	 *  \n
+	 *  \note This event is called from USB_ISR context and hence is time-critical. Having delays in this
+	 *  callback will prevent the device from enumerating correctly or operate properly.
+   *
+   */
+ USB_CB_T USB_Feature_Event;
+
+  /* cache and MMU translation functions */
+  /** Reserved parameter for future use. should be set to zero. */
+  uint32_t (* virt_to_phys)(void* vaddr);
+  /** Reserved parameter for future use. should be set to zero. */
+  void (* cache_flush)(uint32_t* start_adr, uint32_t* end_adr);
+
+} USBD_API_INIT_PARAM_T;
+
+
+/** \brief USBD stack Core API functions structure.
+ *  \ingroup USBD_Core
+ *
+ *  \details  This module exposes functions which interact directly with USB device stack's core layer.
+ *  The application layer uses this component when it has to implement custom class function driver or 
+ *  standard class function driver which is not part of the current USB device stack.
+ *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
+ *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
+ *  function to register custom endpoint interrupt handler.
+ *
+ */
+typedef struct USBD_CORE_API 
+{
+ /** \fn ErrorCode_t RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data)
+  *  Function to register class specific EP0 event handler with USB device stack.
+  *
+  *  The application layer uses this function when it has to register the custom class's EP0 handler. 
+  *  The stack calls all the registered class handlers on any EP0 event before going through default 
+  *  handling of the event. This gives the class handlers to implement class specific request handlers
+  *  and also to override the default stack handling for a particular event targeted to the interface.
+  *  Check \ref USB_EP_HANDLER_T for more details on how the callback function should be implemented. Also
+  *  application layer could use this function to register EP0 handler which responds to vendor specific 
+  *  requests.
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] pfn  Class specific EP0 handler function.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success
+  *          \retval ERR_USBD_TOO_MANY_CLASS_HDLR(0x0004000c)  The number of class handlers registered is 
+                        greater than the number of handlers allowed by the stack.
+  *                                             
+  */
+  ErrorCode_t (*RegisterClassHandler)(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
+
+ /** \fn ErrorCode_t RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data)
+  *  Function to register interrupt/event handler for the requested endpoint with USB device stack.
+  *
+  *  The application layer uses this function to register the endpoint event handler. 
+  *  The stack calls all the registered endpoint handlers when 
+  *  - USB_EVT_OUT or USB_EVT_OUT_NAK events happen for OUT endpoint.  
+  *  - USB_EVT_IN or USB_EVT_IN_NAK events happen for IN endpoint.
+  *  Check USB_EP_HANDLER_T for more details on how the callback function should be implemented.
+  *  \note By default endpoint _NAK events are not enabled. Application should call \ref USBD_HW_API_T::EnableEvent
+  *  for the corresponding endpoint.
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] ep_index  Endpoint index. Computed as 
+  *                       - For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.
+  *                       - For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5.
+  *  \param[in] pfn  Endpoint event handler function.
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success
+  *          \retval ERR_API_INVALID_PARAM2  ep_index is outside the boundary ( < 2 * USBD_API_INIT_PARAM_T::max_num_ep). 
+  *                                             
+  */
+  ErrorCode_t (*RegisterEpHandler)(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);
+  
+  /** \fn void SetupStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in setup state.
+   *
+   *  This function is called by USB stack and the application layer to 
+   *  set the EP0 state machine in setup state. This function will read
+   *  the setup packet received from USB host into stack's buffer. 
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other 
+   *  scenarios which are not handle by current stack. In most user applications 
+   *  this function is not called directly.Also this function can be used by  
+   *  users who are selectively modifying the USB device stack's standard handlers 
+   *  through callback interface exposed by the stack.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*SetupStage )(USBD_HANDLE_T hUsb); 
+  
+  /** \fn void DataInStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in data_in state.
+   *
+   *  This function is called by USB stack and the application layer to 
+   *  set the EP0 state machine in data_in state. This function will write
+   *  the data present in EP0Data buffer to EP0 FIFO for transmission to host.
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other 
+   *  scenarios which are not handle by current stack. In most user applications 
+   *  this function is not called directly.Also this function can be used by  
+   *  users who are selectively modifying the USB device stack's standard handlers 
+   *  through callback interface exposed by the stack.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*DataInStage)(USBD_HANDLE_T hUsb);
+
+  /** \fn void DataOutStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in data_out state.
+   *
+   *  This function is called by USB stack and the application layer to 
+   *  set the EP0 state machine in data_out state. This function will read
+   *  the control data (EP0 out packets) received from USB host into EP0Data buffer. 
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other 
+   *  scenarios which are not handle by current stack. In most user applications 
+   *  this function is not called directly.Also this function can be used by  
+   *  users who are selectively modifying the USB device stack's standard handlers 
+   *  through callback interface exposed by the stack.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*DataOutStage)(USBD_HANDLE_T hUsb); 
+
+  /** \fn void StatusInStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in status_in state.
+   *
+   *  This function is called by USB stack and the application layer to 
+   *  set the EP0 state machine in status_in state. This function will send
+   *  zero length IN packet on EP0 to host, indicating positive status. 
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other 
+   *  scenarios which are not handle by current stack. In most user applications 
+   *  this function is not called directly.Also this function can be used by  
+   *  users who are selectively modifying the USB device stack's standard handlers 
+   *  through callback interface exposed by the stack.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*StatusInStage)(USBD_HANDLE_T hUsb); 
+  /** \fn void StatusOutStage(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in status_out state.
+   *
+   *  This function is called by USB stack and the application layer to 
+   *  set the EP0 state machine in status_out state. This function will read
+   *  the zero length OUT packet received from USB host on EP0. 
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other 
+   *  scenarios which are not handle by current stack. In most user applications 
+   *  this function is not called directly.Also this function can be used by  
+   *  users who are selectively modifying the USB device stack's standard handlers 
+   *  through callback interface exposed by the stack.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*StatusOutStage)(USBD_HANDLE_T hUsb);
+
+  /** \fn void StallEp0(USBD_HANDLE_T hUsb)
+   *  Function to set EP0 state machine in stall state.
+   *
+   *  This function is called by USB stack and the application layer to 
+   *  generate STALL signaling on EP0 endpoint. This function will also
+   *  reset the EP0Data buffer. 
+   *  \n
+   *  \note This interface is provided to users to invoke this function in other 
+   *  scenarios which are not handle by current stack. In most user applications 
+   *  this function is not called directly.Also this function can be used by  
+   *  users who are selectively modifying the USB device stack's standard handlers 
+   *  through callback interface exposed by the stack.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*StallEp0)(USBD_HANDLE_T hUsb);
+
+} USBD_CORE_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+
+ /** @cond  ADVANCED_API */
+
+/* forward declaration */
+struct _USB_CORE_CTRL_T;
+typedef struct _USB_CORE_CTRL_T  USB_CORE_CTRL_T;
+
+/* USB device Speed status defines */
+#define USB_FULL_SPEED    0
+#define USB_HIGH_SPEED    1
+
+/* USB Endpoint Data Structure */
+typedef struct _USB_EP_DATA
+{
+  uint8_t  *pData;
+  uint16_t   Count;
+  uint16_t pad0;
+} USB_EP_DATA;
+
+
+/* USB core controller data structure */
+struct _USB_CORE_CTRL_T
+{
+  /* override-able function pointers ~ c++ style virtual functions*/
+  USB_CB_T USB_EvtSetupHandler;
+  USB_CB_T USB_EvtOutHandler;
+  USB_PARAM_CB_T USB_ReqVendor;
+  USB_CB_T USB_ReqGetStatus;
+  USB_CB_T USB_ReqGetDescriptor;
+  USB_CB_T USB_ReqGetConfiguration;
+  USB_CB_T USB_ReqSetConfiguration;
+  USB_CB_T USB_ReqGetInterface;
+  USB_CB_T USB_ReqSetInterface;
+  USB_PARAM_CB_T USB_ReqSetClrFeature;
+
+  /* USB Device Events Callback Functions */
+  USB_CB_T USB_Reset_Event;
+  USB_CB_T USB_Suspend_Event;
+  USB_CB_T USB_Resume_Event;
+  USB_CB_T USB_SOF_Event;
+  USB_PARAM_CB_T USB_Power_Event;
+  USB_PARAM_CB_T USB_Error_Event;
+  USB_PARAM_CB_T USB_WakeUpCfg;
+
+  /* USB Core Events Callback Functions */
+  USB_CB_T USB_Configure_Event;
+  USB_CB_T USB_Interface_Event;
+  USB_CB_T USB_Feature_Event;
+
+  /* cache and MMU translation functions */
+  uint32_t (* virt_to_phys)(void* vaddr);
+  void (* cache_flush)(uint32_t* start_adr, uint32_t* end_adr);
+
+  /* event handlers for endpoints. */
+  USB_EP_HANDLER_T  ep_event_hdlr[2 * USB_MAX_EP_NUM];
+  void*  ep_hdlr_data[2 * USB_MAX_EP_NUM];
+
+  /* USB class handlers */
+  USB_EP_HANDLER_T  ep0_hdlr_cb[USB_MAX_IF_NUM];
+  void*  ep0_cb_data[USB_MAX_IF_NUM];
+  uint8_t num_ep0_hdlrs;
+  /* USB Core data Variables */
+  uint8_t max_num_ep; /* max number of endpoints supported by the HW */
+  uint8_t device_speed;
+  uint8_t  num_interfaces;
+  uint8_t  device_addr;
+  uint8_t  config_value;
+  uint16_t device_status;
+  uint8_t *device_desc;
+  uint8_t *string_desc;
+  uint8_t *full_speed_desc;
+  uint8_t *high_speed_desc;
+  uint8_t *device_qualifier;
+  uint32_t ep_mask;
+  uint32_t ep_halt;
+  uint32_t ep_stall;
+  uint8_t  alt_setting[USB_MAX_IF_NUM];
+  /* HW driver data pointer */
+  void* hw_data;
+
+  /* USB Endpoint 0 Data Info */
+  USB_EP_DATA EP0Data;
+
+  /* USB Endpoint 0 Buffer */
+  //ALIGNED(4)
+  uint8_t  EP0Buf[64];
+
+  /* USB Setup Packet */
+  //ALIGNED(4)
+  USB_SETUP_PACKET SetupPacket;
+
+};
+
+/* USB Core Functions */
+extern void mwUSB_InitCore(USB_CORE_CTRL_T* pCtrl, USB_CORE_DESCS_T* pdescr, USBD_API_INIT_PARAM_T* param);
+extern void mwUSB_ResetCore(USBD_HANDLE_T hUsb);
+
+/* inline functions */
+static INLINE void USB_SetSpeedMode(USB_CORE_CTRL_T* pCtrl, uint8_t mode)
+{
+    pCtrl->device_speed = mode;   
+}
+
+static INLINE bool USB_IsConfigured(USBD_HANDLE_T hUsb)
+{
+    USB_CORE_CTRL_T* pCtrl = (USB_CORE_CTRL_T*) hUsb;
+    return (bool) (pCtrl->config_value != 0);   
+}
+
+/** @cond  DIRECT_API */
+/* midleware API */
+extern ErrorCode_t mwUSB_RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
+extern ErrorCode_t mwUSB_RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);
+extern void mwUSB_SetupStage (USBD_HANDLE_T hUsb); 
+extern void mwUSB_DataInStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_DataOutStage(USBD_HANDLE_T hUsb); 
+extern void mwUSB_StatusInStage(USBD_HANDLE_T hUsb); 
+extern void mwUSB_StatusOutStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StallEp0(USBD_HANDLE_T hUsb);
+extern ErrorCode_t mwUSB_RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
+extern ErrorCode_t mwUSB_RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);
+extern void mwUSB_SetupStage (USBD_HANDLE_T hUsb); 
+extern void mwUSB_DataInStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_DataOutStage(USBD_HANDLE_T hUsb); 
+extern void mwUSB_StatusInStage(USBD_HANDLE_T hUsb); 
+extern void mwUSB_StatusOutStage(USBD_HANDLE_T hUsb);
+extern void mwUSB_StallEp0(USBD_HANDLE_T hUsb);
+/** @endcond */
+
+/** @endcond */
+
+#endif  /* __MW_USBD_CORE_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_desc.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_desc.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_desc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_desc.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,54 @@
+/***********************************************************************
+* $Id:: mw_usbd_desc.h 165 2011-04-14 17:41:11Z usb10131                      $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Descriptors Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __USBDESC_H__
+#define __USBDESC_H__
+
+#include "usbd.h"
+
+#define WBVAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+#define B3VAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF),(((x) >> 16) & 0xFF)
+
+#define USB_DEVICE_DESC_SIZE        (sizeof(USB_DEVICE_DESCRIPTOR))
+#define USB_CONFIGUARTION_DESC_SIZE (sizeof(USB_CONFIGURATION_DESCRIPTOR))
+#define USB_INTERFACE_DESC_SIZE     (sizeof(USB_INTERFACE_DESCRIPTOR))
+#define USB_ENDPOINT_DESC_SIZE      (sizeof(USB_ENDPOINT_DESCRIPTOR))
+#define USB_DEVICE_QUALI_SIZE       (sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR))
+#define USB_OTHER_SPEED_CONF_SIZE   (sizeof(USB_OTHER_SPEED_CONFIGURATION))
+
+//#define HID_DESC_SIZE               (sizeof(HID_DESCRIPTOR))
+//#define HID_REPORT_DESC_SIZE        (sizeof(HID_ReportDescriptor))
+
+extern const uint8_t  HID_ReportDescriptor[];
+extern const uint16_t HID_ReportDescSize;
+extern const uint16_t HID_DescOffset;
+
+
+#endif  /* __USBDESC_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfu.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfu.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfu.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfu.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,126 @@
+/***********************************************************************
+* $Id:: mw_usbd_dfu.h 331 2012-08-09 18:54:34Z usb10131                       $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Device Firmware Upgrade (DFU) module.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MW_USBD_DFU_H__
+#define __MW_USBD_DFU_H__
+
+#include "usbd.h"
+
+/** \file
+ *  \brief Device Firmware Upgrade (DFU) class descriptors.
+ *
+ *  Definition of DFU class descriptors and their bit defines.
+ *
+ */
+
+/**
+ * If USB device is only DFU capable, DFU Interface number is always 0.
+ * if USB device is (DFU + Other Class (Audio/Mass Storage/HID), DFU 
+ * Interface number should also be 0 in this implementation.
+ */ 
+#define USB_DFU_IF_NUM	0x0
+
+#define USB_DFU_DESCRIPTOR_TYPE     0x21
+#define USB_DFU_DESCRIPTOR_SIZE     9
+#define USB_DFU_SUBCLASS            0x01
+
+/* DFU class-specific requests (Section 3, DFU Rev 1.1) */
+#define USB_REQ_DFU_DETACH          0x00
+#define USB_REQ_DFU_DNLOAD          0x01
+#define USB_REQ_DFU_UPLOAD          0x02
+#define USB_REQ_DFU_GETSTATUS       0x03
+#define USB_REQ_DFU_CLRSTATUS       0x04
+#define USB_REQ_DFU_GETSTATE        0x05
+#define USB_REQ_DFU_ABORT           0x06
+
+#define DFU_STATUS_OK               0x00
+#define DFU_STATUS_errTARGET        0x01
+#define DFU_STATUS_errFILE          0x02
+#define DFU_STATUS_errWRITE         0x03
+#define DFU_STATUS_errERASE         0x04
+#define DFU_STATUS_errCHECK_ERASED  0x05
+#define DFU_STATUS_errPROG          0x06
+#define DFU_STATUS_errVERIFY        0x07
+#define DFU_STATUS_errADDRESS       0x08
+#define DFU_STATUS_errNOTDONE       0x09
+#define DFU_STATUS_errFIRMWARE      0x0a
+#define DFU_STATUS_errVENDOR        0x0b
+#define DFU_STATUS_errUSBR          0x0c
+#define DFU_STATUS_errPOR           0x0d
+#define DFU_STATUS_errUNKNOWN       0x0e
+#define DFU_STATUS_errSTALLEDPKT    0x0f
+
+enum dfu_state {
+  DFU_STATE_appIDLE             = 0,
+  DFU_STATE_appDETACH           = 1,
+  DFU_STATE_dfuIDLE             = 2,
+  DFU_STATE_dfuDNLOAD_SYNC      = 3,
+  DFU_STATE_dfuDNBUSY           = 4,
+  DFU_STATE_dfuDNLOAD_IDLE      = 5,
+  DFU_STATE_dfuMANIFEST_SYNC    = 6,
+  DFU_STATE_dfuMANIFEST         = 7,
+  DFU_STATE_dfuMANIFEST_WAIT_RST= 8,
+  DFU_STATE_dfuUPLOAD_IDLE      = 9,
+  DFU_STATE_dfuERROR            = 10
+};
+
+#define DFU_EP0_NONE            0
+#define DFU_EP0_UNHANDLED       1
+#define DFU_EP0_STALL           2
+#define DFU_EP0_ZLP             3
+#define DFU_EP0_DATA            4
+
+#define USB_DFU_CAN_DOWNLOAD    (1 << 0)
+#define USB_DFU_CAN_UPLOAD      (1 << 1)
+#define USB_DFU_MANIFEST_TOL    (1 << 2)
+#define USB_DFU_WILL_DETACH     (1 << 3)
+
+PRE_PACK struct POST_PACK _USB_DFU_FUNC_DESCRIPTOR {
+  uint8_t   bLength;
+  uint8_t   bDescriptorType;
+  uint8_t   bmAttributes;
+  uint16_t  wDetachTimeOut;
+  uint16_t  wTransferSize;
+  uint16_t  bcdDFUVersion;
+};
+typedef struct _USB_DFU_FUNC_DESCRIPTOR USB_DFU_FUNC_DESCRIPTOR;
+
+PRE_PACK struct POST_PACK _DFU_STATUS {
+  uint8_t bStatus;
+  uint8_t bwPollTimeout[3];
+  uint8_t bState;
+  uint8_t iString;
+};
+typedef struct _DFU_STATUS DFU_STATUS_T;
+
+#define DFU_FUNC_DESC_SIZE    sizeof(USB_DFU_FUNC_DESCRIPTOR)
+#define DFU_GET_STATUS_SIZE   0x6 
+
+
+#endif  /* __MW_USBD_DFU_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfuuser.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfuuser.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfuuser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_dfuuser.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,276 @@
+/***********************************************************************
+* $Id:: mw_usbd_dfuuser.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Device Firmware Upgrade Class Custom User Module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __DFUUSER_H__
+#define __DFUUSER_H__
+
+#include "usbd.h"
+#include "usbd_dfu.h"
+#include "usbd_core.h"
+
+/** \file
+ *  \brief Device Firmware Upgrade (DFU) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based DFU function driver.
+ *
+ */
+
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_DFU Device Firmware Upgrade (DFU) Class Function Driver
+ *  \section Sec_MSCModDescription Module Description
+ *  DFU Class Function Driver module. This module contains an internal implementation of the USB DFU Class.
+ *  User applications can use this class driver instead of implementing the DFU class manually
+ *  via the low-level USBD_HW and USBD_Core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB DFU Class.
+ */
+
+/** \brief USB descriptors data structure.
+ *  \ingroup USBD_DFU
+ *
+ *  \details  This module exposes functions which interact directly with USB device stack's core layer.
+ *  The application layer uses this component when it has to implement custom class function driver or 
+ *  standard class function driver which is not part of the current USB device stack.
+ *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
+ *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
+ *  function to register custom endpoint interrupt handler.
+ *
+ */
+typedef struct USBD_DFU_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use. 
+                      \note The \em mem_size should be greater than the size 
+                      returned by USBD_DFU_API::GetMemSize() routine.*/
+  /* DFU paramas */
+  uint16_t wTransferSize; /**< DFU transfer block size in number of bytes.
+                          This value should match the value set in DFU descriptor
+                          provided as part of the descriptor array 
+                          (\em high_speed_desc) passed to Init() through 
+                          \ref USB_CORE_DESCS_T structure.  */
+
+  uint16_t pad;
+  /** Pointer to the DFU interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T 
+  * structure.  
+  */
+  uint8_t* intf_desc;
+  /* user defined functions */
+  /** 
+  *  DFU Write callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a write command. For application using zero-copy buffer scheme
+  *  this function is called for the first time with \em length parameter set to 0.
+  *  The application code should update the buffer pointer.
+  *  
+  *  \param[in] block_num Destination start address. 
+  *  \param[in, out] src  Pointer to a pointer to the source of data. Pointer-to-pointer
+  *                     is used to implement zero-copy buffers. See \ref USBD_ZeroCopy
+  *                     for more details on zero-copy concept.
+  *  \param[out] bwPollTimeout  Pointer to a 3 byte buffer which the callback implementer
+  *                     should fill with the amount of minimum time, in milliseconds, 
+  *                     that the host should wait before sending a subsequent
+  *                     DFU_GETSTATUS request. 
+  *  \param[in] length  Number of bytes to be written.
+  *  \return Returns DFU_STATUS_ values defined in mw_usbd_dfu.h. 
+  *                                             
+  */
+  uint8_t (*DFU_Write)( uint32_t block_num, uint8_t** src, uint32_t length, uint8_t* bwPollTimeout);
+
+  /** 
+  *  DFU Read callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a read command.
+  *  
+  *  \param[in] block_num Destination start address. 
+  *  \param[in, out] dst  Pointer to a pointer to the source of data. Pointer-to-pointer
+  *                       is used to implement zero-copy buffers. See \ref USBD_ZeroCopy
+  *                       for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return Returns 
+  *                 - DFU_STATUS_ values defined in mw_usbd_dfu.h to return error conditions. 
+  *                 - 0 if there is no more data to be read. Stack will send EOF frame and set 
+  *                     DFU state-machine to dfuIdle state.
+  *                 - length of the data copied, should be greater than or equal to 16. If the data copied
+  *                   is less than DFU \em wTransferSize the stack will send EOF frame and 
+  *                   goes to dfuIdle state.
+  *                                             
+  */
+  uint32_t (*DFU_Read)( uint32_t block_num, uint8_t** dst, uint32_t length);
+
+  /** 
+  *  DFU done callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  after firmware download completes.
+  *  
+  *  \return Nothing. 
+  *                                             
+  */
+  void (*DFU_Done)(void);
+
+  /** 
+  *  DFU detach callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  after USB_REQ_DFU_DETACH is received. Applications which set USB_DFU_WILL_DETACH
+  *  bit in DFU descriptor should define this function. As part of this function
+  *  application can call Connect() routine to disconnect and then connect back with 
+  *  host. For application which rely on WinUSB based host application should use this
+  *  feature since USB reset can be invoked only by kernel drivers on Windows host. 
+  *  By implementing this feature host doen't have to issue reset instead the device
+  *  has to do it automatically by disconnect and connect procedure.
+  *  
+  *  \param[in] hUsb Handle DFU control structure. 
+  *  \return Nothing. 
+  *                                             
+  */
+  void (*DFU_Detach)(USBD_HANDLE_T hUsb);
+
+  /** 
+  *  Optional user override-able function to replace the default DFU class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_DFU_API::Init().
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*DFU_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+} USBD_DFU_INIT_PARAM_T;
+
+
+/** \brief DFU class API functions structure.
+ *  \ingroup USBD_DFU
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_DFU_API
+{
+  /** \fn uint32_t GetMemSize(USBD_DFU_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the DFU function driver module.
+   * 
+   *  This function is called by application layer before calling pUsbApi->dfu->Init(), to allocate memory used 
+   *  by DFU function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller. 
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing DFU function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_DFU_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param)
+   *  Function to initialize DFU function driver module.
+   * 
+   *  This function is called by application layer to initialize DFU function driver module. 
+   *
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in, out] param Structure containing DFU function driver module initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte aligned or smaller than required. 
+   *          \retval ERR_API_INVALID_PARAM2 Either DFU_Write() or DFU_Done() or DFU_Read() call-backs are not defined.
+   *          \retval ERR_USBD_BAD_DESC  
+   *            - USB_DFU_DESCRIPTOR_TYPE is not defined immediately after 
+   *              interface descriptor.
+   *            - wTransferSize in descriptor doesn't match the value passed 
+   *              in param->wTransferSize.
+   *            - DFU_Detach() is not defined while USB_DFU_WILL_DETACH is set 
+   *              in DFU descriptor.
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param, uint32_t init_state);
+
+} USBD_DFU_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _USBD_DFU_CTRL_T
+{
+  /*ALIGNED(4)*/ DFU_STATUS_T dfu_req_get_status;
+  uint16_t pad;
+  uint8_t dfu_state;
+  uint8_t dfu_status;
+  uint8_t download_done;
+  uint8_t if_num;                  /* interface number */
+
+  uint8_t* xfr_buf;
+  USB_DFU_FUNC_DESCRIPTOR* dfu_desc;
+
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  /* user defined functions */
+  /* return DFU_STATUS_ values defined in mw_usbd_dfu.h */
+  uint8_t (*DFU_Write)( uint32_t block_num, uint8_t** src, uint32_t length, uint8_t* bwPollTimeout);
+  /* return 
+  * DFU_STATUS_ : values defined in mw_usbd_dfu.h in case of errors
+  * 0 : If end of memory reached
+  * length : Amount of data copied to destination buffer
+  */
+  uint32_t (*DFU_Read)( uint32_t block_num, uint8_t** dst, uint32_t length);
+  /* callback called after download is finished */
+  void (*DFU_Done)(void);
+  /* callback called after USB_REQ_DFU_DETACH is recived */
+  void (*DFU_Detach)(USBD_HANDLE_T hUsb);
+
+} USBD_DFU_CTRL_T;
+
+/** @cond  DIRECT_API */
+uint32_t mwDFU_GetMemSize(USBD_DFU_INIT_PARAM_T* param);
+extern ErrorCode_t mwDFU_init(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param, uint32_t init_state);
+/** @endcond */
+
+/** @endcond */
+
+#endif  /* __DFUUSER_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,711 @@
+/***********************************************************************
+* $Id:: mw_usbd.h 575 2012-11-20 01:35:56Z usb10131                           $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __USBD_H__
+#define __USBD_H__
+
+/** \file
+ *  \brief Common definitions and declarations for the USB stack.
+ *
+ *  Common definitions and declarations for the USB stack.
+ *  \addtogroup USBD_Core 
+ *  @{
+ */
+
+#include "lpc_types.h"
+
+#if defined(__GNUC__)
+/* As per http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax,
+6.29 Attributes Syntax
+"An attribute specifier list may appear as part of a struct, union or
+enum specifier. It may go either immediately after the struct, union
+or enum keyword, or after the closing brace. The former syntax is
+preferred. Where attribute specifiers follow the closing brace, they
+are considered to relate to the structure, union or enumerated type
+defined, not to any enclosing declaration the type specifier appears
+in, and the type defined is not complete until after the attribute
+specifiers."
+So use POST_PACK immediately after struct keyword
+*/
+#define PRE_PACK
+#define POST_PACK	__attribute__((__packed__))
+#define ALIGNED(n)      __attribute__((aligned (n)))
+
+#elif defined(__arm)
+#define PRE_PACK	__packed
+#define POST_PACK
+#define ALIGNED(n)      __align(n)
+
+#elif defined(__ICCARM__)
+#define PRE_PACK                __packed
+#define POST_PACK
+#define PRAGMA_ALIGN_4096       _Pragma("data_alignment=4096")
+#define PRAGMA_ALIGN_2048       _Pragma("data_alignment=2048")
+#define PRAGMA_ALIGN_512        _Pragma("data_alignment=512")
+#define PRAGMA_ALIGN_256        _Pragma("data_alignment=256")
+#define PRAGMA_ALIGN_128        _Pragma("data_alignment=128")
+#define PRAGMA_ALIGN_64         _Pragma("data_alignment=64")
+#define PRAGMA_ALIGN_48         _Pragma("data_alignment=48")
+#define PRAGMA_ALIGN_32         _Pragma("data_alignment=32")
+#define PRAGMA_ALIGN_4          _Pragma("data_alignment=4")
+#define ALIGNED(n)              PRAGMA_ALIGN_##n
+
+#pragma diag_suppress=Pe021
+#endif
+
+/** Structure to pack lower and upper byte to form 16 bit word. */
+PRE_PACK struct POST_PACK _WB_T
+{
+  uint8_t L; /**< lower byte */
+  uint8_t H; /**< upper byte */
+};
+/** Structure to pack lower and upper byte to form 16 bit word.*/
+typedef struct _WB_T WB_T;
+
+/** Union of \ref _WB_T struct and 16 bit word.*/
+PRE_PACK union POST_PACK __WORD_BYTE
+{
+  uint16_t W; /**< data member to do 16 bit access */
+  WB_T WB; /**< data member to do 8 bit access */
+} ;
+/** Union of \ref _WB_T struct and 16 bit word.*/
+typedef union __WORD_BYTE WORD_BYTE;
+
+/** bmRequestType.Dir defines 
+ * @{ 
+ */
+/** Request from host to device */
+#define REQUEST_HOST_TO_DEVICE     0
+/** Request from device to host */
+#define REQUEST_DEVICE_TO_HOST     1
+/** @} */
+
+/** bmRequestType.Type defines  
+ * @{ 
+ */
+/** Standard Request */
+#define REQUEST_STANDARD           0
+/** Class Request */
+#define REQUEST_CLASS              1
+/** Vendor Request */
+#define REQUEST_VENDOR             2
+/** Reserved Request */
+#define REQUEST_RESERVED           3
+/** @} */
+
+/** bmRequestType.Recipient defines  
+ * @{ 
+ */
+/** Request to device */
+#define REQUEST_TO_DEVICE          0
+/** Request to interface */
+#define REQUEST_TO_INTERFACE       1
+/** Request to endpoint */
+#define REQUEST_TO_ENDPOINT        2
+/** Request to other */
+#define REQUEST_TO_OTHER           3
+/** @} */
+
+/** Structure to define 8 bit USB request.*/
+PRE_PACK struct POST_PACK _BM_T
+{
+  uint8_t Recipient :  5; /**< Recipient type. */
+  uint8_t Type      :  2; /**< Request type.  */
+  uint8_t Dir       :  1; /**< Direction type. */
+};
+/** Structure to define 8 bit USB request.*/
+typedef struct _BM_T BM_T;
+
+/** Union of \ref _BM_T struct and 8 bit byte.*/
+PRE_PACK union POST_PACK _REQUEST_TYPE
+{
+  uint8_t B; /**< byte wide access memeber */
+  BM_T BM;   /**< bitfield structure access memeber */
+} ;
+/** Union of \ref _BM_T struct and 8 bit byte.*/
+typedef union _REQUEST_TYPE REQUEST_TYPE;
+
+/** USB Standard Request Codes 
+ * @{ 
+ */
+/** GET_STATUS request */
+#define USB_REQUEST_GET_STATUS                 0
+/** CLEAR_FEATURE request */
+#define USB_REQUEST_CLEAR_FEATURE              1
+/** SET_FEATURE request */
+#define USB_REQUEST_SET_FEATURE                3
+/** SET_ADDRESS request */
+#define USB_REQUEST_SET_ADDRESS                5
+/** GET_DESCRIPTOR request */
+#define USB_REQUEST_GET_DESCRIPTOR             6
+/** SET_DESCRIPTOR request */
+#define USB_REQUEST_SET_DESCRIPTOR             7
+/** GET_CONFIGURATION request */
+#define USB_REQUEST_GET_CONFIGURATION          8
+/** SET_CONFIGURATION request */
+#define USB_REQUEST_SET_CONFIGURATION          9
+/** GET_INTERFACE request */
+#define USB_REQUEST_GET_INTERFACE              10
+/** SET_INTERFACE request */
+#define USB_REQUEST_SET_INTERFACE              11
+/** SYNC_FRAME request */
+#define USB_REQUEST_SYNC_FRAME                 12
+/** @} */
+
+/** USB GET_STATUS Bit Values 
+ * @{ 
+ */
+/** SELF_POWERED status*/
+#define USB_GETSTATUS_SELF_POWERED             0x01
+/** REMOTE_WAKEUP capable status*/
+#define USB_GETSTATUS_REMOTE_WAKEUP            0x02
+/** ENDPOINT_STALL status*/
+#define USB_GETSTATUS_ENDPOINT_STALL           0x01
+/** @} */
+
+/** USB Standard Feature selectors 
+ * @{ 
+ */
+/** ENDPOINT_STALL feature*/
+#define USB_FEATURE_ENDPOINT_STALL             0
+/** REMOTE_WAKEUP feature*/
+#define USB_FEATURE_REMOTE_WAKEUP              1
+/** TEST_MODE feature*/
+#define USB_FEATURE_TEST_MODE                  2
+/** @} */
+
+/** USB Default Control Pipe Setup Packet*/
+PRE_PACK struct POST_PACK _USB_SETUP_PACKET
+{
+  REQUEST_TYPE bmRequestType; /**< This bitmapped field identifies the characteristics
+                              of the specific request. \sa _BM_T.
+                              */
+  uint8_t      bRequest; /**< This field specifies the particular request. The 
+                         Type bits in the bmRequestType field modify the meaning 
+                         of this field. \sa USBD_REQUEST.
+                         */
+  WORD_BYTE    wValue; /**< Used to pass a parameter to the device, specific
+                        to the request.
+                        */
+  WORD_BYTE    wIndex; /**< Used to pass a parameter to the device, specific
+                        to the request. The wIndex field is often used in 
+                        requests to specify an endpoint or an interface.
+                        */
+  uint16_t     wLength; /**< This field specifies the length of the data 
+                        transferred during the second phase of the control 
+                        transfer.
+                        */
+} ;
+/** USB Default Control Pipe Setup Packet*/
+typedef struct _USB_SETUP_PACKET USB_SETUP_PACKET;
+
+
+/** USB Descriptor Types 
+ * @{ 
+ */
+/** Device descriptor type  */
+#define USB_DEVICE_DESCRIPTOR_TYPE             1
+/** Configuration descriptor type  */
+#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
+/** String descriptor type  */
+#define USB_STRING_DESCRIPTOR_TYPE             3
+/** Interface descriptor type  */
+#define USB_INTERFACE_DESCRIPTOR_TYPE          4
+/** Endpoint descriptor type  */
+#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
+/** Device qualifier descriptor type  */
+#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE   6
+/** Other speed configuration descriptor type  */
+#define USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE 7
+/** Interface power descriptor type  */
+#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE    8
+/** OTG descriptor type  */
+#define USB_OTG_DESCRIPTOR_TYPE                     9
+/** Debug descriptor type  */
+#define USB_DEBUG_DESCRIPTOR_TYPE                  10
+/** Interface association descriptor type  */
+#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE  11
+/** @} */
+
+/** USB Device Classes 
+ * @{ 
+ */
+/** Reserved device class  */
+#define USB_DEVICE_CLASS_RESERVED              0x00
+/** Audio device class  */
+#define USB_DEVICE_CLASS_AUDIO                 0x01
+/** Communications device class  */
+#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
+/** Human interface device class  */
+#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
+/** monitor device class  */
+#define USB_DEVICE_CLASS_MONITOR               0x04
+/** physical interface device class  */
+#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE    0x05
+/** power device class  */
+#define USB_DEVICE_CLASS_POWER                 0x06
+/** Printer device class  */
+#define USB_DEVICE_CLASS_PRINTER               0x07
+/** Storage device class  */
+#define USB_DEVICE_CLASS_STORAGE               0x08
+/** Hub device class  */
+#define USB_DEVICE_CLASS_HUB                   0x09
+/** miscellaneous device class  */
+#define USB_DEVICE_CLASS_MISCELLANEOUS         0xEF
+/** Application device class  */
+#define USB_DEVICE_CLASS_APP                   0xFE
+/** Vendor specific device class  */
+#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
+/** @} */
+
+/** bmAttributes in Configuration Descriptor 
+ * @{ 
+ */
+/** Power field mask */
+#define USB_CONFIG_POWERED_MASK                0x40
+/** Bus powered */
+#define USB_CONFIG_BUS_POWERED                 0x80
+/** Self powered */
+#define USB_CONFIG_SELF_POWERED                0xC0
+/** remote wakeup */
+#define USB_CONFIG_REMOTE_WAKEUP               0x20
+/** @} */
+
+/** bMaxPower in Configuration Descriptor */
+#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
+
+/** bEndpointAddress in Endpoint Descriptor 
+ * @{ 
+ */
+/** Endopint address mask */
+#define USB_ENDPOINT_DIRECTION_MASK            0x80
+/** Macro to convert OUT endopint number to endpoint address value. */
+#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
+/** Macro to convert IN endopint number to endpoint address value. */
+#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
+/** @} */
+
+/** bmAttributes in Endpoint Descriptor 
+ * @{ 
+ */
+/** Endopint type mask */
+#define USB_ENDPOINT_TYPE_MASK                 0x03
+/** Control Endopint type */
+#define USB_ENDPOINT_TYPE_CONTROL              0x00
+/** isochronous Endopint type */
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
+/** bulk Endopint type */
+#define USB_ENDPOINT_TYPE_BULK                 0x02
+/** interrupt Endopint type */
+#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
+/** Endopint sync type mask */
+#define USB_ENDPOINT_SYNC_MASK                 0x0C
+/** no synchronization Endopint */
+#define USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION   0x00
+/** Asynchronous sync Endopint */
+#define USB_ENDPOINT_SYNC_ASYNCHRONOUS         0x04
+/** Adaptive sync Endopint */
+#define USB_ENDPOINT_SYNC_ADAPTIVE             0x08
+/** Synchronous sync Endopint */
+#define USB_ENDPOINT_SYNC_SYNCHRONOUS          0x0C
+/** Endopint usage type mask */
+#define USB_ENDPOINT_USAGE_MASK                0x30
+/** Endopint data usage type  */
+#define USB_ENDPOINT_USAGE_DATA                0x00
+/** Endopint feedback usage type  */
+#define USB_ENDPOINT_USAGE_FEEDBACK            0x10
+/** Endopint implicit feedback usage type  */
+#define USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK   0x20
+/** Endopint reserved usage type  */
+#define USB_ENDPOINT_USAGE_RESERVED            0x30
+/** @} */
+
+/** Control endopint EP0's maximum packet size in high-speed mode.*/
+#define USB_ENDPOINT_0_HS_MAXP                 64
+/** Control endopint EP0's maximum packet size in low-speed mode.*/
+#define USB_ENDPOINT_0_LS_MAXP                 8
+/** Bulk endopint's maximum packet size in high-speed mode.*/
+#define USB_ENDPOINT_BULK_HS_MAXP              512
+
+/** USB Standard Device Descriptor */
+PRE_PACK struct POST_PACK _USB_DEVICE_DESCRIPTOR
+{
+  uint8_t  bLength;     /**< Size of this descriptor in bytes. */
+  uint8_t  bDescriptorType; /**< DEVICE Descriptor Type. */
+  uint16_t bcdUSB; /**< BUSB Specification Release Number in
+                    Binary-Coded Decimal (i.e., 2.10 is 210H).
+                    This field identifies the release of the USB
+                    Specification with which the device and its
+                    descriptors are compliant.
+                   */
+  uint8_t  bDeviceClass; /**< Class code (assigned by the USB-IF).
+                          If this field is reset to zero, each interface
+                          within a configuration specifies its own
+                          class information and the various
+                          interfaces operate independently.\n
+                          If this field is set to a value between 1 and
+                          FEH, the device supports different class
+                          specifications on different interfaces and
+                          the interfaces may not operate
+                          independently. This value identifies the
+                          class definition used for the aggregate
+                          interfaces. \n
+                          If this field is set to FFH, the device class
+                          is vendor-specific.
+                          */
+  uint8_t  bDeviceSubClass; /**< Subclass code (assigned by the USB-IF).
+                            These codes are qualified by the value of
+                            the bDeviceClass field. \n
+                            If the bDeviceClass field is reset to zero,
+                            this field must also be reset to zero. \n
+                            If the bDeviceClass field is not set to FFH,
+                            all values are reserved for assignment by
+                            the USB-IF. 
+                            */
+  uint8_t  bDeviceProtocol; /**< Protocol code (assigned by the USB-IF).
+                            These codes are qualified by the value of
+                            the bDeviceClass and the
+                            bDeviceSubClass fields. If a device
+                            supports class-specific protocols on a
+                            device basis as opposed to an interface
+                            basis, this code identifies the protocols
+                            that the device uses as defined by the
+                            specification of the device class. \n
+                            If this field is reset to zero, the device
+                            does not use class-specific protocols on a
+                            device basis. However, it may use classspecific
+                            protocols on an interface basis. \n
+                            If this field is set to FFH, the device uses a
+                            vendor-specific protocol on a device basis. 
+                            */
+  uint8_t  bMaxPacketSize0; /**< Maximum packet size for endpoint zero
+                            (only 8, 16, 32, or 64 are valid). For HS devices
+                            is fixed to 64.
+                            */
+
+  uint16_t idVendor; /**< Vendor ID (assigned by the USB-IF). */
+  uint16_t idProduct; /**< Product ID (assigned by the manufacturer). */
+  uint16_t bcdDevice; /**< Device release number in binary-coded decimal. */
+  uint8_t  iManufacturer; /**< Index of string descriptor describing manufacturer. */
+  uint8_t  iProduct; /**< Index of string descriptor describing product. */
+  uint8_t  iSerialNumber; /**< Index of string descriptor describing the device�s 
+                          serial number.
+                          */
+  uint8_t  bNumConfigurations; /**< Number of possible configurations. */
+} ;
+/** USB Standard Device Descriptor */
+typedef struct _USB_DEVICE_DESCRIPTOR USB_DEVICE_DESCRIPTOR;
+
+/** USB 2.0 Device Qualifier Descriptor */
+PRE_PACK struct POST_PACK _USB_DEVICE_QUALIFIER_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of descriptor */
+  uint8_t  bDescriptorType; /**< Device Qualifier Type */
+  uint16_t bcdUSB; /**< USB specification version number (e.g., 0200H for V2.00) */
+  uint8_t  bDeviceClass; /**< Class Code */
+  uint8_t  bDeviceSubClass; /**< SubClass Code */
+  uint8_t  bDeviceProtocol; /**< Protocol Code */
+  uint8_t  bMaxPacketSize0; /**< Maximum packet size for other speed */
+  uint8_t  bNumConfigurations; /**< Number of Other-speed Configurations */
+  uint8_t  bReserved; /**< Reserved for future use, must be zero */
+} ;
+/** USB 2.0 Device Qualifier Descriptor */
+typedef struct _USB_DEVICE_QUALIFIER_DESCRIPTOR USB_DEVICE_QUALIFIER_DESCRIPTOR;
+
+/** USB Standard Configuration Descriptor */
+PRE_PACK struct POST_PACK _USB_CONFIGURATION_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes */
+  uint8_t  bDescriptorType; /**< CONFIGURATION Descriptor Type*/
+  uint16_t wTotalLength; /**< Total length of data returned for this
+                          configuration. Includes the combined length
+                          of all descriptors (configuration, interface,
+                          endpoint, and class- or vendor-specific)
+                          returned for this configuration.*/
+  uint8_t  bNumInterfaces; /**< Number of interfaces supported by this configuration*/
+  uint8_t  bConfigurationValue; /**< Value to use as an argument to the
+                                SetConfiguration() request to select this 
+                                configuration. */
+  uint8_t  iConfiguration; /**< Index of string descriptor describing this
+                            configuration*/
+  uint8_t  bmAttributes; /**< Configuration characteristics \n
+                          D7: Reserved (set to one)\n
+                          D6: Self-powered \n
+                          D5: Remote Wakeup \n
+                          D4...0: Reserved (reset to zero) \n
+                          D7 is reserved and must be set to one for
+                          historical reasons. \n
+                          A device configuration that uses power from
+                          the bus and a local source reports a non-zero
+                          value in bMaxPower to indicate the amount of
+                          bus power required and sets D6. The actual
+                          power source at runtime may be determined
+                          using the GetStatus(DEVICE) request (see
+                          USB 2.0 spec Section 9.4.5). \n
+                          If a device configuration supports remote
+                          wakeup, D5 is set to one.*/
+  uint8_t  bMaxPower; /**< Maximum power consumption of the USB
+                      device from the bus in this specific
+                      configuration when the device is fully
+                      operational. Expressed in 2 mA units
+                      (i.e., 50 = 100 mA). \n
+                      Note: A device configuration reports whether
+                      the configuration is bus-powered or selfpowered.
+                      Device status reports whether the
+                      device is currently self-powered. If a device is
+                      disconnected from its external power source, it
+                      updates device status to indicate that it is no
+                      longer self-powered. \n
+                      A device may not increase its power draw
+                      from the bus, when it loses its external power
+                      source, beyond the amount reported by its
+                      configuration. \n
+                      If a device can continue to operate when
+                      disconnected from its external power source, it
+                      continues to do so. If the device cannot
+                      continue to operate, it fails operations it can
+                      no longer support. The USB System Software
+                      may determine the cause of the failure by
+                      checking the status and noting the loss of the
+                      device�s power source.*/
+} ;
+/** USB Standard Configuration Descriptor */
+typedef struct _USB_CONFIGURATION_DESCRIPTOR USB_CONFIGURATION_DESCRIPTOR;
+
+/** USB Standard Interface Association Descriptor */
+PRE_PACK struct POST_PACK _USB_IAD_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< INTERFACE ASSOCIATION Descriptor Type*/
+  uint8_t  bFirstInterface; /**< Interface number of the first interface that is
+                            associated with this function.*/
+  uint8_t  bInterfaceCount; /**< Number of contiguous interfaces that are
+                            associated with this function. */
+  uint8_t  bFunctionClass; /**< Class code (assigned by USB-IF). \n
+                            A value of zero is not allowed in this descriptor.
+                            If this field is FFH, the function class is vendorspecific.
+                            All other values are reserved for assignment by
+                            the USB-IF.*/
+  uint8_t  bFunctionSubClass; /**< Subclass code (assigned by USB-IF). \n
+                            If the bFunctionClass field is not set to FFH all
+                            values are reserved for assignment by the USBIF.*/
+  uint8_t  bFunctionProtocol; /**< Protocol code (assigned by the USB). \n
+                                These codes are qualified by the values of the
+                                bFunctionClass and bFunctionSubClass fields.*/
+  uint8_t  iFunction; /**< Index of string descriptor describing this function.*/
+} ;
+/** USB Standard Interface Association Descriptor */
+typedef struct _USB_IAD_DESCRIPTOR USB_IAD_DESCRIPTOR;
+
+/** USB Standard Interface Descriptor */
+PRE_PACK struct POST_PACK _USB_INTERFACE_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< INTERFACE Descriptor Type*/
+  uint8_t  bInterfaceNumber; /**< Number of this interface. Zero-based
+                              value identifying the index in the array of
+                              concurrent interfaces supported by this
+                              configuration.*/
+  uint8_t  bAlternateSetting; /**< Value used to select this alternate setting
+                              for the interface identified in the prior field*/
+  uint8_t  bNumEndpoints; /**< Number of endpoints used by this
+                          interface (excluding endpoint zero). If this
+                          value is zero, this interface only uses the
+                          Default Control Pipe.*/
+  uint8_t  bInterfaceClass; /**< Class code (assigned by the USB-IF). \n
+                            A value of zero is reserved for future
+                            standardization. \n
+                            If this field is set to FFH, the interface
+                            class is vendor-specific. \n
+                            All other values are reserved for
+                            assignment by the USB-IF.*/
+  uint8_t  bInterfaceSubClass; /**< Subclass code (assigned by the USB-IF). \n
+                              These codes are qualified by the value of
+                              the bInterfaceClass field. \n
+                              If the bInterfaceClass field is reset to zero,
+                              this field must also be reset to zero. \n
+                              If the bInterfaceClass field is not set to
+                              FFH, all values are reserved for
+                              assignment by the USB-IF.*/
+  uint8_t  bInterfaceProtocol; /**< Protocol code (assigned by the USB). \n
+                                These codes are qualified by the value of
+                                the bInterfaceClass and the
+                                bInterfaceSubClass fields. If an interface
+                                supports class-specific requests, this code
+                                identifies the protocols that the device
+                                uses as defined by the specification of the
+                                device class. \n
+                                If this field is reset to zero, the device
+                                does not use a class-specific protocol on
+                                this interface. \n
+                                If this field is set to FFH, the device uses
+                                a vendor-specific protocol for this
+                                interface.*/
+  uint8_t  iInterface; /**< Index of string descriptor describing this interface*/
+} ;
+/** USB Standard Interface Descriptor */
+typedef struct _USB_INTERFACE_DESCRIPTOR USB_INTERFACE_DESCRIPTOR;
+
+/** USB Standard Endpoint Descriptor */
+PRE_PACK struct POST_PACK _USB_ENDPOINT_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< ENDPOINT Descriptor Type*/
+  uint8_t  bEndpointAddress; /**< The address of the endpoint on the USB device
+                            described by this descriptor. The address is
+                            encoded as follows: \n
+                            Bit 3...0: The endpoint number \n
+                            Bit 6...4: Reserved, reset to zero \n
+                            Bit 7: Direction, ignored for control endpoints
+                            0 = OUT endpoint
+                            1 = IN endpoint.  \n \sa USBD_ENDPOINT_ADR_Type*/
+  uint8_t  bmAttributes; /**< This field describes the endpoint�s attributes when it is
+                          configured using the bConfigurationValue. \n
+                          Bits 1..0: Transfer Type
+                          \li 00 = Control
+                          \li 01 = Isochronous
+                          \li 10 = Bulk
+                          \li 11 = Interrupt  \n
+                          If not an isochronous endpoint, bits 5..2 are reserved
+                          and must be set to zero. If isochronous, they are
+                          defined as follows: \n
+                          Bits 3..2: Synchronization Type
+                          \li 00 = No Synchronization
+                          \li 01 = Asynchronous
+                          \li 10 = Adaptive
+                          \li 11 = Synchronous \n
+                          Bits 5..4: Usage Type
+                          \li 00 = Data endpoint
+                          \li 01 = Feedback endpoint
+                          \li 10 = Implicit feedback Data endpoint
+                          \li 11 = Reserved \n
+                          Refer to Chapter 5 of USB 2.0 specification for more information. \n
+                          All other bits are reserved and must be reset to zero.
+                          Reserved bits must be ignored by the host.
+                         \n \sa USBD_EP_ATTR_Type*/
+  uint16_t wMaxPacketSize; /**< Maximum packet size this endpoint is capable of
+                          sending or receiving when this configuration is
+                          selected. \n
+                          For isochronous endpoints, this value is used to
+                          reserve the bus time in the schedule, required for the
+                          per-(micro)frame data payloads. The pipe may, on an
+                          ongoing basis, actually use less bandwidth than that
+                          reserved. The device reports, if necessary, the actual
+                          bandwidth used via its normal, non-USB defined
+                          mechanisms. \n
+                          For all endpoints, bits 10..0 specify the maximum
+                          packet size (in bytes). \n
+                          For high-speed isochronous and interrupt endpoints: \n
+                          Bits 12..11 specify the number of additional transaction
+                          opportunities per microframe: \n
+                          \li 00 = None (1 transaction per microframe)
+                          \li 01 = 1 additional (2 per microframe)
+                          \li 10 = 2 additional (3 per microframe)
+                          \li 11 = Reserved \n
+                          Bits 15..13 are reserved and must be set to zero.*/
+  uint8_t  bInterval; /**< Interval for polling endpoint for data transfers.
+                      Expressed in frames or microframes depending on the
+                      device operating speed (i.e., either 1 millisecond or
+                      125 �s units). 
+                      \li For full-/high-speed isochronous endpoints, this value
+                      must be in the range from 1 to 16. The bInterval value
+                      is used as the exponent for a \f$ 2^(bInterval-1) \f$ value; e.g., a
+                      bInterval of 4 means a period of 8 (\f$ 2^(4-1) \f$). 
+                      \li For full-/low-speed interrupt endpoints, the value of
+                      this field may be from 1 to 255.
+                      \li For high-speed interrupt endpoints, the bInterval value
+                      is used as the exponent for a \f$ 2^(bInterval-1) \f$ value; e.g., a
+                      bInterval of 4 means a period of 8 (\f$ 2^(4-1) \f$) . This value
+                      must be from 1 to 16.
+                      \li For high-speed bulk/control OUT endpoints, the
+                      bInterval must specify the maximum NAK rate of the
+                      endpoint. A value of 0 indicates the endpoint never
+                      NAKs. Other values indicate at most 1 NAK each
+                      bInterval number of microframes. This value must be
+                      in the range from 0 to 255. \n
+                      Refer to Chapter 5 of USB 2.0 specification for more information.
+                      */
+} ;
+/** USB Standard Endpoint Descriptor */
+typedef struct _USB_ENDPOINT_DESCRIPTOR USB_ENDPOINT_DESCRIPTOR;
+
+/** USB String Descriptor */
+PRE_PACK struct POST_PACK _USB_STRING_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< STRING Descriptor Type*/
+  uint16_t bString/*[]*/; /**< UNICODE encoded string */
+}  ;
+/** USB String Descriptor */
+typedef struct _USB_STRING_DESCRIPTOR USB_STRING_DESCRIPTOR;
+
+/** USB Common Descriptor */
+PRE_PACK struct POST_PACK _USB_COMMON_DESCRIPTOR
+{
+  uint8_t  bLength; /**< Size of this descriptor in bytes*/
+  uint8_t  bDescriptorType; /**< Descriptor Type*/
+} ;
+/** USB Common Descriptor */
+typedef struct _USB_COMMON_DESCRIPTOR USB_COMMON_DESCRIPTOR;
+
+/** USB Other Speed Configuration */
+PRE_PACK struct POST_PACK _USB_OTHER_SPEED_CONFIGURATION
+{
+  uint8_t  bLength; /**< Size of descriptor*/
+  uint8_t  bDescriptorType; /**< Other_speed_Configuration Type*/
+  uint16_t wTotalLength; /**< Total length of data returned*/
+  uint8_t  bNumInterfaces; /**< Number of interfaces supported by this speed configuration*/
+  uint8_t  bConfigurationValue; /**< Value to use to select configuration*/
+  uint8_t  IConfiguration; /**< Index of string descriptor*/
+  uint8_t  bmAttributes; /**< Same as Configuration descriptor*/
+  uint8_t  bMaxPower; /**< Same as Configuration descriptor*/
+} ;
+/** USB Other Speed Configuration */
+typedef struct _USB_OTHER_SPEED_CONFIGURATION USB_OTHER_SPEED_CONFIGURATION;
+
+/** \ingroup USBD_Core 
+ * USB device stack/module handle. 
+ */
+typedef void* USBD_HANDLE_T;
+
+#define WBVAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+#define B3VAL(x) ((x) & 0xFF),(((x) >> 8) & 0xFF),(((x) >> 16) & 0xFF)
+
+#define USB_DEVICE_DESC_SIZE        (sizeof(USB_DEVICE_DESCRIPTOR))
+#define USB_CONFIGURATION_DESC_SIZE (sizeof(USB_CONFIGURATION_DESCRIPTOR))
+#define USB_INTERFACE_DESC_SIZE     (sizeof(USB_INTERFACE_DESCRIPTOR))
+#define USB_INTERFACE_ASSOC_DESC_SIZE   (sizeof(USB_IAD_DESCRIPTOR))
+#define USB_ENDPOINT_DESC_SIZE      (sizeof(USB_ENDPOINT_DESCRIPTOR))
+#define USB_DEVICE_QUALI_SIZE       (sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR))
+#define USB_OTHER_SPEED_CONF_SIZE   (sizeof(USB_OTHER_SPEED_CONFIGURATION))
+
+/** @}*/
+
+#endif  /* __USBD_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hid.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hid.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hid.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hid.h	2018-12-01 17:15:06.661606693 -0300
@@ -0,0 +1,437 @@
+/***********************************************************************
+* $Id: mw_usbd_hid.h.rca 1.2 Tue Nov  1 11:45:07 2011 nlv09221 Experimental $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     HID Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __HID_H__
+#define __HID_H__
+
+#include "usbd.h"
+
+/** \file
+ *  \brief Common definitions and declarations for the library USB HID Class driver.
+ *
+ *  Common definitions and declarations for the library USB HID Class driver.
+ *  \addtogroup USBD_HID 
+ *  @{
+ */
+
+
+/** HID Subclass Codes  
+ * @{ 
+ */
+/** Descriptor Subclass value indicating that the device or interface does not implement a HID boot protocol. */
+#define HID_SUBCLASS_NONE               0x00
+/** Descriptor Subclass value indicating that the device or interface implements a HID boot protocol. */
+#define HID_SUBCLASS_BOOT               0x01
+/** @} */
+
+/** HID Protocol Codes 
+ * @{ 
+ */
+/** Descriptor Protocol value indicating that the device or interface does not belong to a HID boot protocol. */
+#define HID_PROTOCOL_NONE               0x00
+/** Descriptor Protocol value indicating that the device or interface belongs to the Keyboard HID boot protocol. */
+#define HID_PROTOCOL_KEYBOARD           0x01
+/** Descriptor Protocol value indicating that the device or interface belongs to the Mouse HID boot protocol. */
+#define HID_PROTOCOL_MOUSE              0x02
+/** @} */
+
+
+
+/** Descriptor Types  
+ * @{ 
+ */
+/** Descriptor header type value, to indicate a HID class HID descriptor. */
+#define HID_HID_DESCRIPTOR_TYPE         0x21
+/** Descriptor header type value, to indicate a HID class HID report descriptor. */
+#define HID_REPORT_DESCRIPTOR_TYPE      0x22
+/** Descriptor header type value, to indicate a HID class HID Physical descriptor. */
+#define HID_PHYSICAL_DESCRIPTOR_TYPE    0x23
+/** @} */
+
+
+/** \brief HID class-specific HID Descriptor.
+ *
+ *  Type define for the HID class-specific HID descriptor, to describe the HID device's specifications. Refer to the HID
+ *  specification for details on the structure elements.
+ *
+ */
+PRE_PACK struct POST_PACK _HID_DESCRIPTOR {
+  uint8_t  bLength;	/**< Size of the descriptor, in bytes. */
+  uint8_t  bDescriptorType;	/**< Type of HID descriptor. */
+  uint16_t bcdHID; /**< BCD encoded version that the HID descriptor and device complies to. */
+  uint8_t  bCountryCode; /**< Country code of the localized device, or zero if universal. */
+  uint8_t  bNumDescriptors; /**< Total number of HID report descriptors for the interface. */
+  
+  PRE_PACK struct POST_PACK _HID_DESCRIPTOR_LIST {
+    uint8_t  bDescriptorType; /**< Type of HID report. */
+    uint16_t wDescriptorLength; /**< Length of the associated HID report descriptor, in bytes. */
+  } DescriptorList[1]; /**< Array of one or more descriptors */
+} ;
+/** HID class-specific HID Descriptor. */
+typedef struct _HID_DESCRIPTOR HID_DESCRIPTOR;
+
+#define HID_DESC_SIZE   sizeof(HID_DESCRIPTOR)
+
+/** HID Request Codes  
+ * @{ 
+ */
+#define HID_REQUEST_GET_REPORT          0x01
+#define HID_REQUEST_GET_IDLE            0x02
+#define HID_REQUEST_GET_PROTOCOL        0x03
+#define HID_REQUEST_SET_REPORT          0x09
+#define HID_REQUEST_SET_IDLE            0x0A
+#define HID_REQUEST_SET_PROTOCOL        0x0B
+/** @} */
+
+/** HID Report Types  
+ * @{ 
+ */
+#define HID_REPORT_INPUT                0x01
+#define HID_REPORT_OUTPUT               0x02
+#define HID_REPORT_FEATURE              0x03
+/** @} */
+
+
+/** Usage Pages  
+ * @{ 
+ */
+#define HID_USAGE_PAGE_UNDEFINED        0x00
+#define HID_USAGE_PAGE_GENERIC          0x01
+#define HID_USAGE_PAGE_SIMULATION       0x02
+#define HID_USAGE_PAGE_VR               0x03
+#define HID_USAGE_PAGE_SPORT            0x04
+#define HID_USAGE_PAGE_GAME             0x05
+#define HID_USAGE_PAGE_DEV_CONTROLS     0x06
+#define HID_USAGE_PAGE_KEYBOARD         0x07
+#define HID_USAGE_PAGE_LED              0x08
+#define HID_USAGE_PAGE_BUTTON           0x09
+#define HID_USAGE_PAGE_ORDINAL          0x0A
+#define HID_USAGE_PAGE_TELEPHONY        0x0B
+#define HID_USAGE_PAGE_CONSUMER         0x0C
+#define HID_USAGE_PAGE_DIGITIZER        0x0D
+#define HID_USAGE_PAGE_UNICODE          0x10
+#define HID_USAGE_PAGE_ALPHANUMERIC     0x14
+/** @} */
+
+
+/** Generic Desktop Page (0x01)  
+ * @{ 
+ */
+#define HID_USAGE_GENERIC_POINTER               0x01
+#define HID_USAGE_GENERIC_MOUSE                 0x02
+#define HID_USAGE_GENERIC_JOYSTICK              0x04
+#define HID_USAGE_GENERIC_GAMEPAD               0x05
+#define HID_USAGE_GENERIC_KEYBOARD              0x06
+#define HID_USAGE_GENERIC_KEYPAD                0x07
+#define HID_USAGE_GENERIC_X                     0x30
+#define HID_USAGE_GENERIC_Y                     0x31
+#define HID_USAGE_GENERIC_Z                     0x32
+#define HID_USAGE_GENERIC_RX                    0x33
+#define HID_USAGE_GENERIC_RY                    0x34
+#define HID_USAGE_GENERIC_RZ                    0x35
+#define HID_USAGE_GENERIC_SLIDER                0x36
+#define HID_USAGE_GENERIC_DIAL                  0x37
+#define HID_USAGE_GENERIC_WHEEL                 0x38
+#define HID_USAGE_GENERIC_HATSWITCH             0x39
+#define HID_USAGE_GENERIC_COUNTED_BUFFER        0x3A
+#define HID_USAGE_GENERIC_BYTE_COUNT            0x3B
+#define HID_USAGE_GENERIC_MOTION_WAKEUP         0x3C
+#define HID_USAGE_GENERIC_VX                    0x40
+#define HID_USAGE_GENERIC_VY                    0x41
+#define HID_USAGE_GENERIC_VZ                    0x42
+#define HID_USAGE_GENERIC_VBRX                  0x43
+#define HID_USAGE_GENERIC_VBRY                  0x44
+#define HID_USAGE_GENERIC_VBRZ                  0x45
+#define HID_USAGE_GENERIC_VNO                   0x46
+#define HID_USAGE_GENERIC_SYSTEM_CTL            0x80
+#define HID_USAGE_GENERIC_SYSCTL_POWER          0x81
+#define HID_USAGE_GENERIC_SYSCTL_SLEEP          0x82
+#define HID_USAGE_GENERIC_SYSCTL_WAKE           0x83
+#define HID_USAGE_GENERIC_SYSCTL_CONTEXT_MENU   0x84
+#define HID_USAGE_GENERIC_SYSCTL_MAIN_MENU      0x85
+#define HID_USAGE_GENERIC_SYSCTL_APP_MENU       0x86
+#define HID_USAGE_GENERIC_SYSCTL_HELP_MENU      0x87
+#define HID_USAGE_GENERIC_SYSCTL_MENU_EXIT      0x88
+#define HID_USAGE_GENERIC_SYSCTL_MENU_SELECT    0x89
+#define HID_USAGE_GENERIC_SYSCTL_MENU_RIGHT     0x8A
+#define HID_USAGE_GENERIC_SYSCTL_MENU_LEFT      0x8B
+#define HID_USAGE_GENERIC_SYSCTL_MENU_UP        0x8C
+#define HID_USAGE_GENERIC_SYSCTL_MENU_DOWN      0x8D
+/** @} */
+
+/** Simulation Controls Page (0x02)  
+ * @{ 
+ */
+#define HID_USAGE_SIMULATION_RUDDER             0xBA
+#define HID_USAGE_SIMULATION_THROTTLE           0xBB
+/** @} */
+
+/* Virtual Reality Controls Page (0x03) */
+/* ... */
+
+/* Sport Controls Page (0x04) */
+/* ... */
+
+/* Game Controls Page (0x05) */
+/* ... */
+
+/* Generic Device Controls Page (0x06) */
+/* ... */
+
+/** Keyboard/Keypad Page (0x07)  
+ * @{ 
+ */
+/** Error "keys" */
+#define HID_USAGE_KEYBOARD_NOEVENT              0x00
+#define HID_USAGE_KEYBOARD_ROLLOVER             0x01
+#define HID_USAGE_KEYBOARD_POSTFAIL             0x02
+#define HID_USAGE_KEYBOARD_UNDEFINED            0x03
+
+/** Letters */
+#define HID_USAGE_KEYBOARD_aA                   0x04
+#define HID_USAGE_KEYBOARD_zZ                   0x1D
+
+/** Numbers */
+#define HID_USAGE_KEYBOARD_ONE                  0x1E
+#define HID_USAGE_KEYBOARD_ZERO                 0x27
+
+#define HID_USAGE_KEYBOARD_RETURN               0x28
+#define HID_USAGE_KEYBOARD_ESCAPE               0x29
+#define HID_USAGE_KEYBOARD_DELETE               0x2A
+
+/** Funtion keys */
+#define HID_USAGE_KEYBOARD_F1                   0x3A
+#define HID_USAGE_KEYBOARD_F12                  0x45
+
+#define HID_USAGE_KEYBOARD_PRINT_SCREEN         0x46
+
+/** Modifier Keys */
+#define HID_USAGE_KEYBOARD_LCTRL                0xE0
+#define HID_USAGE_KEYBOARD_LSHFT                0xE1
+#define HID_USAGE_KEYBOARD_LALT                 0xE2
+#define HID_USAGE_KEYBOARD_LGUI                 0xE3
+#define HID_USAGE_KEYBOARD_RCTRL                0xE4
+#define HID_USAGE_KEYBOARD_RSHFT                0xE5
+#define HID_USAGE_KEYBOARD_RALT                 0xE6
+#define HID_USAGE_KEYBOARD_RGUI                 0xE7
+#define HID_USAGE_KEYBOARD_SCROLL_LOCK          0x47
+#define HID_USAGE_KEYBOARD_NUM_LOCK             0x53
+#define HID_USAGE_KEYBOARD_CAPS_LOCK            0x39
+/** @} */
+
+/* ... */
+
+/** LED Page (0x08)  
+ * @{ 
+ */
+#define HID_USAGE_LED_NUM_LOCK                  0x01
+#define HID_USAGE_LED_CAPS_LOCK                 0x02
+#define HID_USAGE_LED_SCROLL_LOCK               0x03
+#define HID_USAGE_LED_COMPOSE                   0x04
+#define HID_USAGE_LED_KANA                      0x05
+#define HID_USAGE_LED_POWER                     0x06
+#define HID_USAGE_LED_SHIFT                     0x07
+#define HID_USAGE_LED_DO_NOT_DISTURB            0x08
+#define HID_USAGE_LED_MUTE                      0x09
+#define HID_USAGE_LED_TONE_ENABLE               0x0A
+#define HID_USAGE_LED_HIGH_CUT_FILTER           0x0B
+#define HID_USAGE_LED_LOW_CUT_FILTER            0x0C
+#define HID_USAGE_LED_EQUALIZER_ENABLE          0x0D
+#define HID_USAGE_LED_SOUND_FIELD_ON            0x0E
+#define HID_USAGE_LED_SURROUND_FIELD_ON         0x0F
+#define HID_USAGE_LED_REPEAT                    0x10
+#define HID_USAGE_LED_STEREO                    0x11
+#define HID_USAGE_LED_SAMPLING_RATE_DETECT      0x12
+#define HID_USAGE_LED_SPINNING                  0x13
+#define HID_USAGE_LED_CAV                       0x14
+#define HID_USAGE_LED_CLV                       0x15
+#define HID_USAGE_LED_RECORDING_FORMAT_DET      0x16
+#define HID_USAGE_LED_OFF_HOOK                  0x17
+#define HID_USAGE_LED_RING                      0x18
+#define HID_USAGE_LED_MESSAGE_WAITING           0x19
+#define HID_USAGE_LED_DATA_MODE                 0x1A
+#define HID_USAGE_LED_BATTERY_OPERATION         0x1B
+#define HID_USAGE_LED_BATTERY_OK                0x1C
+#define HID_USAGE_LED_BATTERY_LOW               0x1D
+#define HID_USAGE_LED_SPEAKER                   0x1E
+#define HID_USAGE_LED_HEAD_SET                  0x1F
+#define HID_USAGE_LED_HOLD                      0x20
+#define HID_USAGE_LED_MICROPHONE                0x21
+#define HID_USAGE_LED_COVERAGE                  0x22
+#define HID_USAGE_LED_NIGHT_MODE                0x23
+#define HID_USAGE_LED_SEND_CALLS                0x24
+#define HID_USAGE_LED_CALL_PICKUP               0x25
+#define HID_USAGE_LED_CONFERENCE                0x26
+#define HID_USAGE_LED_STAND_BY                  0x27
+#define HID_USAGE_LED_CAMERA_ON                 0x28
+#define HID_USAGE_LED_CAMERA_OFF                0x29
+#define HID_USAGE_LED_ON_LINE                   0x2A
+#define HID_USAGE_LED_OFF_LINE                  0x2B
+#define HID_USAGE_LED_BUSY                      0x2C
+#define HID_USAGE_LED_READY                     0x2D
+#define HID_USAGE_LED_PAPER_OUT                 0x2E
+#define HID_USAGE_LED_PAPER_JAM                 0x2F
+#define HID_USAGE_LED_REMOTE                    0x30
+#define HID_USAGE_LED_FORWARD                   0x31
+#define HID_USAGE_LED_REVERSE                   0x32
+#define HID_USAGE_LED_STOP                      0x33
+#define HID_USAGE_LED_REWIND                    0x34
+#define HID_USAGE_LED_FAST_FORWARD              0x35
+#define HID_USAGE_LED_PLAY                      0x36
+#define HID_USAGE_LED_PAUSE                     0x37
+#define HID_USAGE_LED_RECORD                    0x38
+#define HID_USAGE_LED_ERROR                     0x39
+#define HID_USAGE_LED_SELECTED_INDICATOR        0x3A
+#define HID_USAGE_LED_IN_USE_INDICATOR          0x3B
+#define HID_USAGE_LED_MULTI_MODE_INDICATOR      0x3C
+#define HID_USAGE_LED_INDICATOR_ON              0x3D
+#define HID_USAGE_LED_INDICATOR_FLASH           0x3E
+#define HID_USAGE_LED_INDICATOR_SLOW_BLINK      0x3F
+#define HID_USAGE_LED_INDICATOR_FAST_BLINK      0x40
+#define HID_USAGE_LED_INDICATOR_OFF             0x41
+#define HID_USAGE_LED_FLASH_ON_TIME             0x42
+#define HID_USAGE_LED_SLOW_BLINK_ON_TIME        0x43
+#define HID_USAGE_LED_SLOW_BLINK_OFF_TIME       0x44
+#define HID_USAGE_LED_FAST_BLINK_ON_TIME        0x45
+#define HID_USAGE_LED_FAST_BLINK_OFF_TIME       0x46
+#define HID_USAGE_LED_INDICATOR_COLOR           0x47
+#define HID_USAGE_LED_RED                       0x48
+#define HID_USAGE_LED_GREEN                     0x49
+#define HID_USAGE_LED_AMBER                     0x4A
+#define HID_USAGE_LED_GENERIC_INDICATOR         0x4B
+/** @} */
+
+/*  Button Page (0x09)  
+ */
+/*   There is no need to label these usages. */
+
+/*  Ordinal Page (0x0A)  
+ */
+/*   There is no need to label these usages. */
+
+/** Telephony Device Page (0x0B)  
+ * @{ 
+ */
+#define HID_USAGE_TELEPHONY_PHONE               0x01
+#define HID_USAGE_TELEPHONY_ANSWERING_MACHINE   0x02
+#define HID_USAGE_TELEPHONY_MESSAGE_CONTROLS    0x03
+#define HID_USAGE_TELEPHONY_HANDSET             0x04
+#define HID_USAGE_TELEPHONY_HEADSET             0x05
+#define HID_USAGE_TELEPHONY_KEYPAD              0x06
+#define HID_USAGE_TELEPHONY_PROGRAMMABLE_BUTTON 0x07
+/** @} */
+/* ... */
+
+/** Consumer Page (0x0C)  
+ * @{ 
+ */
+#define HID_USAGE_CONSUMER_CONTROL              0x01
+#define HID_USAGE_CONSUMER_FAST_FORWARD       0xB3
+#define HID_USAGE_CONSUMER_REWIND             0xB4
+#define HID_USAGE_CONSUMER_PLAY_PAUSE			    0xCD
+#define HID_USAGE_CONSUMER_VOLUME_INCREMENT		0xE9
+#define HID_USAGE_CONSUMER_VOLUME_DECREMENT		0xEA
+/** @} */
+/* ... */
+
+/* and others ... */
+
+
+/** HID Report Item Macros  
+ * @{ 
+ */
+/** Main Items */
+#define HID_Input(x)           0x81,x
+#define HID_Output(x)          0x91,x
+#define HID_Feature(x)         0xB1,x
+#define HID_Collection(x)      0xA1,x
+#define HID_EndCollection      0xC0
+
+/** Data (Input, Output, Feature) */
+#define HID_Data               0<<0
+#define HID_Constant           1<<0
+#define HID_Array              0<<1
+#define HID_Variable           1<<1
+#define HID_Absolute           0<<2
+#define HID_Relative           1<<2
+#define HID_NoWrap             0<<3
+#define HID_Wrap               1<<3
+#define HID_Linear             0<<4
+#define HID_NonLinear          1<<4
+#define HID_PreferredState     0<<5
+#define HID_NoPreferred        1<<5
+#define HID_NoNullPosition     0<<6
+#define HID_NullState          1<<6
+#define HID_NonVolatile        0<<7
+#define HID_Volatile           1<<7
+
+/** Collection Data */
+#define HID_Physical           0x00
+#define HID_Application        0x01
+#define HID_Logical            0x02
+#define HID_Report             0x03
+#define HID_NamedArray         0x04
+#define HID_UsageSwitch        0x05
+#define HID_UsageModifier      0x06
+
+/** Global Items */
+#define HID_UsagePage(x)       0x05,x
+#define HID_UsagePageVendor(x) 0x06,x,0xFF
+#define HID_LogicalMin(x)      0x15,x
+#define HID_LogicalMinS(x)     0x16,(x&0xFF),((x>>8)&0xFF)
+#define HID_LogicalMinL(x)     0x17,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_LogicalMax(x)      0x25,x
+#define HID_LogicalMaxS(x)     0x26,(x&0xFF),((x>>8)&0xFF)
+#define HID_LogicalMaxL(x)     0x27,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_PhysicalMin(x)     0x35,x
+#define HID_PhysicalMinS(x)    0x36,(x&0xFF),((x>>8)&0xFF)
+#define HID_PhysicalMinL(x)    0x37,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_PhysicalMax(x)     0x45,x
+#define HID_PhysicalMaxS(x)    0x46,(x&0xFF),((x>>8)&0xFF)
+#define HID_PhysicalMaxL(x)    0x47,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_UnitExponent(x)    0x55,x
+#define HID_Unit(x)            0x65,x
+#define HID_UnitS(x)           0x66,(x&0xFF),((x>>8)&0xFF)
+#define HID_UnitL(x)           0x67,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
+#define HID_ReportSize(x)      0x75,x
+#define HID_ReportID(x)        0x85,x
+#define HID_ReportCount(x)     0x95,x
+#define HID_ReportCount16(x)   0x96,(x&0xFF),((x>>8)&0xFF)
+#define HID_Push               0xA0
+#define HID_Pop                0xB0
+
+/** Local Items */
+#define HID_Usage(x)           0x09,x
+#define HID_UsageMin(x)        0x19,x
+#define HID_UsageMax(x)        0x29,x
+/** @} */
+
+/** @} */
+
+#endif  /* __HID_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hiduser.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hiduser.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hiduser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hiduser.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,427 @@
+/***********************************************************************
+* $Id:: mw_usbd_hiduser.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     HID Custom User Module Definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __HIDUSER_H__
+#define __HIDUSER_H__
+
+#include "usbd.h"
+#include "usbd_hid.h"
+#include "usbd_core.h"
+
+/** \file
+ *  \brief Human Interface Device (HID) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based HID function driver.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_HID HID Class Function Driver
+ *  \section Sec_HIDModDescription Module Description
+ *  HID Class Function Driver module. This module contains an internal implementation of the USB HID Class.
+ *  User applications can use this class driver instead of implementing the HID class manually
+ *  via the low-level HW and core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB HID Class.
+ */
+
+/** \brief HID report descriptor data structure. 
+ *  \ingroup USBD_HID
+ *
+ *  \details  This structure is used as part of HID function driver initialization 
+ *  parameter structure \ref USBD_HID_INIT_PARAM. This structure contains
+ *  details of a report type supported by the application. An application
+ *  can support multiple report types as a single HID device. The application
+ *  should define this report type data structure per report it supports and
+ *  the array of report types to USBD_HID_API::init() through \ref USBD_HID_INIT_PARAM
+ *  structure. 
+ *
+ *  \note All descriptor pointers assigned in this structure should be on 4 byte
+ *  aligned address boundary. 
+ *
+ */
+typedef struct _HID_REPORT_T {
+  uint16_t len; /**< Size of the report descriptor in bytes. */ 
+  uint8_t idle_time; /**< This value is used by stack to respond to Set_Idle & 
+                     GET_Idle requests for the specified report ID. The value
+                     of this field specified the rate at which duplicate reports 
+                     are generated for the specified Report ID. For example, a 
+                     device with two input reports could specify an idle rate of 
+                     20 milliseconds for report ID 1 and 500 milliseconds for 
+                     report ID 2.
+                     */
+  uint8_t __pad; /**< Padding space. */
+  uint8_t* desc; /**< Report descriptor. */
+} USB_HID_REPORT_T;
+
+/** \brief USB descriptors data structure. 
+ *  \ingroup USBD_HID
+ *
+ *  \details  This module exposes functions which interact directly with USB device stack's core layer.
+ *  The application layer uses this component when it has to implement custom class function driver or 
+ *  standard class function driver which is not part of the current USB device stack.
+ *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
+ *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
+ *  function to register custom endpoint interrupt handler.
+ *
+ */
+typedef struct USBD_HID_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use. 
+                      \note The \em mem_size should be greater than the size 
+                      returned by USBD_HID_API::GetMemSize() routine.*/
+  /* HID paramas */
+  uint8_t max_reports; /**< Number of HID reports supported by this instance
+                       of HID class driver. 
+                       */
+  uint8_t pad[3];
+  uint8_t* intf_desc; /**< Pointer to the HID interface descriptor within the 
+                      descriptor array (\em high_speed_desc) passed to Init()
+                      through \ref USB_CORE_DESCS_T structure.  
+                      */
+  USB_HID_REPORT_T* report_data; /**< Pointer to an array of HID report descriptor
+                                 data structure (\ref USB_HID_REPORT_T). The number
+                                 of elements in the array should be same a \em max_reports
+                                 value. The stack uses this array to respond to 
+                                 requests received for various HID report descriptor
+                                 information. \note This array should be of global scope.
+                                 */
+
+  /* user defined functions */
+  /* required functions */
+  /** 
+  *  HID get report callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a HID_REQUEST_GET_REPORT request. The setup packet data (\em pSetup)
+  *  is passed to the callback so that application can extract the report ID, report
+  *  type and other information need to generate the report. \note HID reports are sent
+  *  via interrupt IN endpoint also. This function is called only when report request
+  *  is received on control endpoint. Application should implement \em HID_EpIn_Hdlr to
+  *  send reports to host via interrupt IN endpoint.
+  *   
+  *  
+  *  \param[in] hHid Handle to HID function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data. 
+  *                       Pointer-to-pointer is used to implement zero-copy buffers. 
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_GetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length); 
+  
+  /** 
+  *  HID set report callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a HID_REQUEST_SET_REPORT request. The setup packet data (\em pSetup)
+  *  is passed to the callback so that application can extract the report ID, report
+  *  type and other information need to modify the report. An application might choose 
+  *  to ignore input Set_Report requests as meaningless. Alternatively these reports 
+  *  could be used to reset the origin of a control (that is, current position should 
+  *  report zero).
+  *  
+  *  \param[in] hHid Handle to HID function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data. 
+  *                       Pointer-to-pointer is used to implement zero-copy buffers. 
+  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Amount of data copied to destination buffer.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_SetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+  
+  /* optional functions */
+  
+  /** 
+  *  Optional callback function to handle HID_GetPhysDesc request.
+  *
+  *  The application software could provide this callback HID_GetPhysDesc handler to
+  *  handle get physical descriptor requests sent by the host. When host requests 
+  *  Physical Descriptor set 0, application should return a special descriptor
+  *  identifying the number of descriptor sets and their sizes. A Get_Descriptor 
+  *  request with the Physical Index equal to 1 should return the first Physical 
+  *  Descriptor set. A device could possibly have alternate uses for its items. 
+  *  These can be enumerated by issuing subsequent Get_Descriptor requests while 
+  *  incrementing the Descriptor Index. A device should return the last descriptor
+  *  set to requests with an index greater than the last number defined in the HID 
+  *  descriptor.
+  *  \note Applications which don't have physical descriptor should set this data member
+  *  to zero before calling the USBD_HID_API::Init().
+  *  \n
+  *  
+  *  \param[in] hHid Handle to HID function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in] pBuf Pointer to a pointer of data buffer containing physical descriptor 
+  *                   data. If the physical descriptor is in USB accessible memory area
+  *                   application could just update the pointer or else it should copy 
+  *                   the descriptor to the address pointed by this pointer.
+  *  \param[in] length  Amount of data copied to destination buffer or descriptor length.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_GetPhysDesc)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+
+  /** 
+  *  Optional callback function to handle HID_REQUEST_SET_IDLE request.
+  *
+  *  The application software could provide this callback to handle HID_REQUEST_SET_IDLE
+  *  requests sent by the host. This callback is provided to applications to adjust
+  *  timers associated with various reports, which are sent to host over interrupt 
+  *  endpoint. The setup packet data (\em pSetup) is passed to the callback so that
+  *  application can extract the report ID, report type and other information need 
+  *  to modify the report's idle time.
+  *  \note Applications which don't send reports on Interrupt endpoint or don't
+  *  have idle time between reports should set this data member to zero before 
+  *  calling the USBD_HID_API::Init().
+  *  \n
+  *  
+  *  \param[in] hHid Handle to HID function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in] idleTime  Idle time to be set for the specified report.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_SetIdle)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t idleTime); 
+ 
+  /** 
+  *  Optional callback function to handle HID_REQUEST_SET_PROTOCOL request.
+  *
+  *  The application software could provide this callback to handle HID_REQUEST_SET_PROTOCOL
+  *  requests sent by the host. This callback is provided to applications to adjust
+  *  modes of their code between boot mode and report mode. 
+  *  \note Applications which don't support protocol modes should set this data member
+  *  to zero before calling the USBD_HID_API::Init().
+  *  \n
+  *  
+  *  \param[in] hHid Handle to HID function driver. 
+  *  \param[in] pSetup Pointer to setup packet received from host.
+  *  \param[in] protocol  Protocol mode. 
+  *                       0 = Boot Protocol
+  *                       1 = Report Protocol
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_SetProtocol)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t protocol); 
+  
+  /** 
+  *  Optional Interrupt IN endpoint event handler.
+  *
+  *  The application software could provide Interrupt IN endpoint event handler. 
+  *  Application which send reports to host on interrupt endpoint should provide
+  *  an endpoint event handler through this data member. This data member is
+  *  ignored if the interface descriptor \em intf_desc doesn't have any IN interrupt 
+  *  endpoint descriptor associated. 
+  *  \n
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Handle to HID function driver. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_EpIn_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+  /** 
+  *  Optional Interrupt OUT endpoint event handler.
+  *
+  *  The application software could provide Interrupt OUT endpoint event handler. 
+  *  Application which receives reports from host on interrupt endpoint should provide
+  *  an endpoint event handler through this data member. This data member is
+  *  ignored if the interface descriptor \em intf_desc doesn't have any OUT interrupt 
+  *  endpoint descriptor associated. 
+  *  \n
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Handle to HID function driver. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should return \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_EpOut_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  /* user override-able function */
+  /** 
+  *  Optional user override-able function to replace the default HID_GetReportDesc handler.
+  *
+  *  The application software could override the default HID_GetReportDesc handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_HID_API::Init() and also provide report data array
+  *  \em report_data field.
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_GetReportDesc)(USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+  /** 
+  *  Optional user override-able function to replace the default HID class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_HID_API::Init().
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*HID_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+} USBD_HID_INIT_PARAM_T;
+
+/** \brief HID class API functions structure.
+ *  \ingroup USBD_HID
+ *
+ *  This structure contains pointers to all the function exposed by HID function driver module.
+ *
+ */
+typedef struct USBD_HID_API 
+{
+  /** \fn uint32_t GetMemSize(USBD_HID_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the HID function driver module.
+   * 
+   *  This function is called by application layer before calling pUsbApi->hid->Init(), to allocate memory used 
+   *  by HID function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller. 
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing HID function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_HID_INIT_PARAM_T* param);
+
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param)
+   *  Function to initialize HID function driver module.
+   * 
+   *  This function is called by application layer to initialize HID function driver  
+   *  module. On successful initialization the function returns a handle to HID 
+   *  function driver module in passed param structure.  
+   *
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in, out] param Structure containing HID function driver module 
+   *      initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte 
+   *              aligned or smaller than required. 
+   *          \retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
+   *              callback are not defined. 
+   *          \retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined 
+   *              immediately after interface descriptor. 
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
+   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param);
+
+} USBD_HID_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _HID_CTRL_T {
+  /* pointer to controller */
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  /* descriptor pointers */
+  uint8_t* hid_desc;
+  USB_HID_REPORT_T* report_data;
+
+  uint8_t protocol;
+  uint8_t if_num;                  /* interface number */
+  uint8_t epin_adr;                /* IN interrupt endpoint */
+  uint8_t epout_adr;               /* OUT interrupt endpoint */
+
+  /* user defined functions */
+  ErrorCode_t (*HID_GetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length); 
+  ErrorCode_t (*HID_SetReport)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length);
+  ErrorCode_t (*HID_GetPhysDesc)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+  ErrorCode_t (*HID_SetIdle)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t idleTime); 
+  ErrorCode_t (*HID_SetProtocol)( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t protocol); 
+
+  /* virtual overridable functions */ 
+  ErrorCode_t (*HID_GetReportDesc)(USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuf, uint16_t* length);
+
+}USB_HID_CTRL_T;
+
+/** @cond  DIRECT_API */
+extern uint32_t mwHID_GetMemSize(USBD_HID_INIT_PARAM_T* param);
+extern ErrorCode_t mwHID_init(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param);
+/** @endcond */
+
+/** @endcond */
+
+#endif  /* __HIDUSER_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hw.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hw.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hw.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_hw.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,463 @@
+/***********************************************************************
+* $Id:: mw_usbd_hw.h 331 2012-08-09 18:54:34Z usb10131                        $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     USB Hardware Function prototypes.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __USBHW_H__
+#define __USBHW_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_core.h"
+
+/** \file
+ *  \brief USB Hardware Function prototypes.
+ *
+ *  Definition of functions exported by ROM based Device Controller Driver (DCD).
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_HW USB Device Controller Driver 
+ *  \section Sec_HWModDescription Module Description
+ *  The Device Controller Driver Layer implements the routines to deal directly with the hardware. 
+ */
+
+/** \ingroup USBD_HW
+*  USB Endpoint/class handler Callback Events. 
+* 
+*/
+enum USBD_EVENT_T {
+  USB_EVT_SETUP =1,    /**< 1   Setup Packet received */
+  USB_EVT_OUT,         /**< 2   OUT Packet received */
+  USB_EVT_IN,          /**< 3    IN Packet sent */
+  USB_EVT_OUT_NAK,     /**< 4   OUT Packet - Not Acknowledged */
+  USB_EVT_IN_NAK,      /**< 5    IN Packet - Not Acknowledged */
+  USB_EVT_OUT_STALL,   /**< 6   OUT Packet - Stalled */
+  USB_EVT_IN_STALL,    /**< 7    IN Packet - Stalled */
+  USB_EVT_OUT_DMA_EOT, /**< 8   DMA OUT EP - End of Transfer */
+  USB_EVT_IN_DMA_EOT,  /**< 9   DMA  IN EP - End of Transfer */
+  USB_EVT_OUT_DMA_NDR, /**< 10  DMA OUT EP - New Descriptor Request */
+  USB_EVT_IN_DMA_NDR,  /**< 11  DMA  IN EP - New Descriptor Request */
+  USB_EVT_OUT_DMA_ERR, /**< 12  DMA OUT EP - Error */
+  USB_EVT_IN_DMA_ERR,  /**< 13  DMA  IN EP - Error */
+  USB_EVT_RESET,       /**< 14  Reset event recieved */
+  USB_EVT_SOF,         /**< 15  Start of Frame event */
+  USB_EVT_DEV_STATE,   /**< 16  Device status events */
+  USB_EVT_DEV_ERROR   /**< 17  Device error events */
+};
+
+/** 
+ *  \brief Hardware API functions structure.
+ *  \ingroup USBD_HW
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_HW_API
+{
+  /** \fn uint32_t GetMemSize(USBD_API_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the USB device stack's DCD and core layers.
+   * 
+   *  This function is called by application layer before calling pUsbApi->hw->Init(), to allocate memory used
+   *  by DCD and core layers. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller. 
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing USB device stack initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_API_INIT_PARAM_T* param);
+  
+  /** \fn ErrorCode_t Init(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param)
+   *  Function to initialize USB device stack's DCD and core layers.
+   * 
+   *  This function is called by application layer to initialize USB hardware and core layers. 
+   *  On successful initialization the function returns a handle to USB device stack which should
+   *  be passed to the rest of the functions.  
+   *
+   *  \param[in,out] phUsb Pointer to the USB device stack handle of type USBD_HANDLE_T. 
+   *  \param[in]  pDesc Structure containing pointers to various descriptor arrays needed by the stack.
+   *                    These descriptors are reported to USB host as part of enumerations process.
+   *  \param[in]  param Structure containing USB device stack initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK(0) On success
+   *          \retval ERR_USBD_BAD_MEM_BUF(0x0004000b) When insufficient memory buffer is passed or memory
+   *                                             is not aligned on 2048 boundary.
+   */
+  ErrorCode_t (*Init)(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param);
+  
+  /** \fn void Connect(USBD_HANDLE_T hUsb, uint32_t con)
+   *  Function to make USB device visible/invisible on the USB bus.
+   *
+   *  This function is called after the USB initialization. This function uses the soft connect
+   *  feature to make the device visible on the USB bus. This function is called only after the
+   *  application is ready to handle the USB data. The enumeration process is started by the
+   *  host after the device detection. The driver handles the enumeration process according to
+   *  the USB descriptors passed in the USB initialization function.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] con  States whether to connect (1) or to disconnect (0).
+   *  \return Nothing.
+   */
+  void (*Connect)(USBD_HANDLE_T hUsb, uint32_t con);
+  
+  /** \fn void ISR(USBD_HANDLE_T hUsb)
+   *  Function to USB device controller interrupt events.
+   *  
+   *  When the user application is active the interrupt handlers are mapped in the user flash
+   *  space. The user application must provide an interrupt handler for the USB interrupt and
+   *  call this function in the interrupt handler routine. The driver interrupt handler takes
+   *  appropriate action according to the data received on the USB bus. 
+   *  
+   *  \param[in]  hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void (*ISR)(USBD_HANDLE_T hUsb);
+
+  /** \fn void Reset(USBD_HANDLE_T hUsb)
+   *  Function to Reset USB device stack and hardware controller.
+   *  
+   *  Reset USB device stack and hardware controller. Disables all endpoints except EP0.
+   *  Clears all pending interrupts and resets endpoint transfer queues.
+   *  This function is called internally by pUsbApi->hw->init() and from reset event.
+   *  
+   *  \param[in]  hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void  (*Reset)(USBD_HANDLE_T hUsb);
+  
+  /** \fn void ForceFullSpeed(USBD_HANDLE_T hUsb, uint32_t cfg)
+   *  Function to force high speed USB device to operate in full speed mode.
+   *
+   *  This function is useful for testing the behavior of current device when connected
+   *  to a full speed only hosts.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] cfg  When 1 - set force full-speed or 
+   *                       0 - clear force full-speed.
+   *  \return Nothing.
+   */
+  void  (*ForceFullSpeed )(USBD_HANDLE_T hUsb, uint32_t cfg);
+  
+  /** \fn void WakeUpCfg(USBD_HANDLE_T hUsb, uint32_t cfg)
+   *  Function to configure USB device controller to wake-up host on remote events.
+   *
+   *  This function is called by application layer to configure the USB device controller 
+   *  to wakeup on remote events. It is recommended to call this function from users's 
+   *  USB_WakeUpCfg() callback routine registered with stack. 
+   *  \note User's USB_WakeUpCfg() is registered with stack by setting the USB_WakeUpCfg member 
+   *  of USBD_API_INIT_PARAM_T structure before calling pUsbApi->hw->Init() routine.
+   *  Certain USB device controllers needed to keep some clocks always on to generate 
+   *  resume signaling through pUsbApi->hw->WakeUp(). This hook is provided to support 
+   *  such controllers. In most controllers cases this is an empty routine.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] cfg  When 1 - Configure controller to wake on remote events or 
+   *                       0 - Configure controller not to wake on remote events.
+   *  \return Nothing.
+   */
+  void  (*WakeUpCfg)(USBD_HANDLE_T hUsb, uint32_t  cfg);
+  
+  /** \fn void SetAddress(USBD_HANDLE_T hUsb, uint32_t adr)
+   *  Function to set USB address assigned by host in device controller hardware.
+   *
+   *  This function is called automatically when USB_REQUEST_SET_ADDRESS request is received  
+   *  by the stack from USB host.
+   *  This interface is provided to users to invoke this function in other scenarios which are not 
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's 
+   *  standard handlers through callback interface exposed by the stack. 
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] adr  USB bus Address to which the device controller should respond. Usually 
+   *                  assigned by the USB host.
+   *  \return Nothing.
+   */
+  void  (*SetAddress)(USBD_HANDLE_T hUsb, uint32_t adr);
+
+  /** \fn void Configure(USBD_HANDLE_T hUsb, uint32_t cfg)
+   *  Function to configure device controller hardware with selected configuration.
+   *
+   *  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received  
+   *  by the stack from USB host.
+   *  This interface is provided to users to invoke this function in other scenarios which are not 
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's 
+   *  standard handlers through callback interface exposed by the stack. 
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] cfg  Configuration index. 
+   *  \return Nothing.
+   */
+  void  (*Configure)(USBD_HANDLE_T hUsb, uint32_t  cfg);
+
+  /** \fn void ConfigEP(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD)
+   *  Function to configure USB Endpoint according to descriptor.
+   *
+   *  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received  
+   *  by the stack from USB host. All the endpoints associated with the selected configuration
+   *  are configured.
+   *  This interface is provided to users to invoke this function in other scenarios which are not 
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's 
+   *  standard handlers through callback interface exposed by the stack. 
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] pEPD Endpoint descriptor structure defined in USB 2.0 specification.
+   *  \return Nothing.
+   */
+  void  (*ConfigEP)(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD);
+
+  /** \fn void DirCtrlEP(USBD_HANDLE_T hUsb, uint32_t dir)
+   *  Function to set direction for USB control endpoint EP0.
+   *
+   *  This function is called automatically by the stack on need basis.
+   *  This interface is provided to users to invoke this function in other scenarios which are not 
+   *  handle by current stack. In most user applications this function is not called directly.
+   *  Also this function can be used by users who are selectively modifying the USB device stack's 
+   *  standard handlers through callback interface exposed by the stack. 
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] cfg  When 1 - Set EP0 in IN transfer mode 
+   *                       0 - Set EP0 in OUT transfer mode
+   *  \return Nothing.
+   */
+  void  (*DirCtrlEP)(USBD_HANDLE_T hUsb, uint32_t dir);
+
+  /** \fn void EnableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to enable selected USB endpoint.
+   *
+   *  This function enables interrupts on selected endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*EnableEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void DisableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to disable selected USB endpoint.
+   *
+   *  This function disables interrupts on selected endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*DisableEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void ResetEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to reset selected USB endpoint.
+   *
+   *  This function flushes the endpoint buffers and resets data toggle logic.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+  */
+  void  (*ResetEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void SetStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to STALL selected USB endpoint.
+   *
+   *  Generates STALL signaling for requested endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*SetStallEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn void ClrStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)
+   *  Function to clear STALL state for the requested endpoint.
+   *
+   *  This function clears STALL state for the requested endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \return Nothing.
+   */
+  void  (*ClrStallEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);
+
+  /** \fn ErrorCode_t SetTestMode(USBD_HANDLE_T hUsb, uint8_t mode)
+   *  Function to set high speed USB device controller in requested test mode.
+   *
+   *  USB-IF requires the high speed device to be put in various test modes
+   *  for electrical testing. This USB device stack calls this function whenever
+   *  it receives USB_REQUEST_CLEAR_FEATURE request for USB_FEATURE_TEST_MODE. 
+   *  Users can put the device in test mode by directly calling this function.
+   *  Returns ERR_USBD_INVALID_REQ when device controller is full-speed only.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] mode  Test mode defined in USB 2.0 electrical testing specification.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK(0) - On success
+   *          \retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid test mode or 
+   *                                             Device controller is full-speed only.
+   */
+  ErrorCode_t (*SetTestMode)(USBD_HANDLE_T hUsb, uint8_t mode); 
+
+  /** \fn uint32_t ReadEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData)
+   *  Function to read data received on the requested endpoint.
+   *
+   *  This function is called by USB stack and the application layer to read the data
+   *  received on the requested endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. 
+   *  \return Returns the number of bytes copied to the buffer.
+   */
+  uint32_t (*ReadEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData);
+
+  /** \fn uint32_t ReadReqEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len)
+   *  Function to queue read request on the specified endpoint.
+   *
+   *  This function is called by USB stack and the application layer to queue a read request
+   *  on the specified endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. This buffer
+   *                       address should be accessible by USB DMA master.
+   *  \param[in] len  Length of the buffer passed. 
+   *  \return Returns the length of the requested buffer.
+   */
+  uint32_t (*ReadReqEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len);
+
+  /** \fn uint32_t ReadSetupPkt(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData)
+   *  Function to read setup packet data received on the requested endpoint.
+   *
+   *  This function is called by USB stack and the application layer to read setup packet data
+   *  received on the requested endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP0_IN is represented by 0x80 number.
+   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. 
+   *  \return Returns the number of bytes copied to the buffer.
+   */
+  uint32_t (*ReadSetupPkt)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData);
+
+  /** \fn uint32_t WriteEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt)
+   *  Function to write data to be sent on the requested endpoint.
+   *
+   *  This function is called by USB stack and the application layer to send data
+   *  on the requested endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number as per USB specification. 
+   *                    ie. An EP1_IN is represented by 0x81 number.
+   *  \param[in] pData Pointer to the data buffer from where data is to be copied. 
+   *  \param[in] cnt  Number of bytes to write. 
+   *  \return Returns the number of bytes written.
+   */
+  uint32_t (*WriteEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt);
+
+  /** \fn void WakeUp(USBD_HANDLE_T hUsb)
+   *  Function to generate resume signaling on bus for remote host wakeup.
+   *
+   *  This function is called by application layer to remotely wakeup host controller 
+   *  when system is in suspend state. Application should indicate this remote wakeup
+   *  capability by setting USB_CONFIG_REMOTE_WAKEUP in bmAttributes of Configuration 
+   *  Descriptor. Also this routine will generate resume signalling only if host
+   *  enables USB_FEATURE_REMOTE_WAKEUP by sending SET_FEATURE request before suspending
+   *  the bus.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \return Nothing.
+   */
+  void  (*WakeUp)(USBD_HANDLE_T hUsb);
+
+  /** \fn void EnableEvent(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable)
+   *  Function to enable/disable selected USB event.
+   *
+   *  This function enables interrupts on selected endpoint.
+   *  
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in] EPNum  Endpoint number corresponding to the event.
+   *                    ie. An EP1_IN is represented by 0x81 number. For device events 
+   *                    set this param to 0x0. 
+   *  \param[in] event_type  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+   *  \param[in] enable  1 - enable event, 0 - disable event.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK(0) - On success
+   *          \retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid event type.
+   */
+  ErrorCode_t  (*EnableEvent)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable);
+
+} USBD_HW_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes used by stack internally
+ *-----------------------------------------------------------------------------*/
+/** @cond  DIRECT_API */
+
+/* Driver functions */
+uint32_t hwUSB_GetMemSize(USBD_API_INIT_PARAM_T* param);
+ErrorCode_t hwUSB_Init(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param);
+void hwUSB_Connect(USBD_HANDLE_T hUsb, uint32_t con);
+void hwUSB_ISR(USBD_HANDLE_T hUsb);
+
+/* USB Hardware Functions */
+extern void  hwUSB_Reset(USBD_HANDLE_T hUsb);
+extern void  hwUSB_ForceFullSpeed (USBD_HANDLE_T hUsb, uint32_t con);
+extern void  hwUSB_WakeUpCfg(USBD_HANDLE_T hUsb, uint32_t  cfg);
+extern void  hwUSB_SetAddress(USBD_HANDLE_T hUsb, uint32_t adr);
+extern void  hwUSB_Configure(USBD_HANDLE_T hUsb, uint32_t  cfg);
+extern void  hwUSB_ConfigEP(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD);
+extern void  hwUSB_DirCtrlEP(USBD_HANDLE_T hUsb, uint32_t dir);
+extern void  hwUSB_EnableEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_DisableEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_ResetEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_SetStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern void  hwUSB_ClrStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum);
+extern ErrorCode_t hwUSB_SetTestMode(USBD_HANDLE_T hUsb, uint8_t mode); /* for FS only devices return ERR_USBD_INVALID_REQ */
+extern uint32_t hwUSB_ReadEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData);
+extern uint32_t hwUSB_ReadReqEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len);
+extern uint32_t hwUSB_ReadSetupPkt(USBD_HANDLE_T hUsb, uint32_t, uint32_t *);
+extern uint32_t hwUSB_WriteEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt);
+
+/* generate resume signaling on the bus */
+extern void  hwUSB_WakeUp(USBD_HANDLE_T hUsb);
+extern ErrorCode_t  hwUSB_EnableEvent(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable);
+/* TODO implement following routines
+- function to program TD and queue them to ep Qh
+*/
+
+/** @endcond */
+
+
+#endif  /* __USBHW_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_msc.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_msc.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_msc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_msc.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,125 @@
+/***********************************************************************
+* $Id:: mw_usbd_msc.h 331 2012-08-09 18:54:34Z usb10131                       $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Mass Storage Class definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+
+#ifndef __MSC_H__
+#define __MSC_H__
+
+#include "usbd.h"
+
+/** \file
+ *  \brief Mass Storage class (MSC) descriptors.
+ *
+ *  Definition of MSC class descriptors and their bit defines.
+ *
+ */
+
+/* MSC Subclass Codes */
+#define MSC_SUBCLASS_RBC                0x01
+#define MSC_SUBCLASS_SFF8020I_MMC2      0x02
+#define MSC_SUBCLASS_QIC157             0x03
+#define MSC_SUBCLASS_UFI                0x04
+#define MSC_SUBCLASS_SFF8070I           0x05
+#define MSC_SUBCLASS_SCSI               0x06
+
+/* MSC Protocol Codes */
+#define MSC_PROTOCOL_CBI_INT            0x00
+#define MSC_PROTOCOL_CBI_NOINT          0x01
+#define MSC_PROTOCOL_BULK_ONLY          0x50
+
+
+/* MSC Request Codes */
+#define MSC_REQUEST_RESET               0xFF
+#define MSC_REQUEST_GET_MAX_LUN         0xFE
+
+
+/* MSC Bulk-only Stage */
+#define MSC_BS_CBW                      0       /* Command Block Wrapper */
+#define MSC_BS_DATA_OUT                 1       /* Data Out Phase */
+#define MSC_BS_DATA_IN                  2       /* Data In Phase */
+#define MSC_BS_DATA_IN_LAST             3       /* Data In Last Phase */
+#define MSC_BS_DATA_IN_LAST_STALL       4       /* Data In Last Phase with Stall */
+#define MSC_BS_CSW                      5       /* Command Status Wrapper */
+#define MSC_BS_ERROR                    6       /* Error */
+
+
+/* Bulk-only Command Block Wrapper */
+PRE_PACK struct POST_PACK _MSC_CBW
+{
+  uint32_t dSignature;
+  uint32_t dTag;
+  uint32_t dDataLength;
+  uint8_t  bmFlags;
+  uint8_t  bLUN;
+  uint8_t  bCBLength;
+  uint8_t  CB[16];
+} ;
+typedef struct _MSC_CBW MSC_CBW;
+
+/* Bulk-only Command Status Wrapper */
+PRE_PACK struct POST_PACK _MSC_CSW
+{
+  uint32_t dSignature;
+  uint32_t dTag;
+  uint32_t dDataResidue;
+  uint8_t  bStatus;
+} ;
+typedef struct _MSC_CSW MSC_CSW;
+
+#define MSC_CBW_Signature               0x43425355
+#define MSC_CSW_Signature               0x53425355
+
+
+/* CSW Status Definitions */
+#define CSW_CMD_PASSED                  0x00
+#define CSW_CMD_FAILED                  0x01
+#define CSW_PHASE_ERROR                 0x02
+
+
+/* SCSI Commands */
+#define SCSI_TEST_UNIT_READY            0x00
+#define SCSI_REQUEST_SENSE              0x03
+#define SCSI_FORMAT_UNIT                0x04
+#define SCSI_INQUIRY                    0x12
+#define SCSI_MODE_SELECT6               0x15
+#define SCSI_MODE_SENSE6                0x1A
+#define SCSI_START_STOP_UNIT            0x1B
+#define SCSI_MEDIA_REMOVAL              0x1E
+#define SCSI_READ_FORMAT_CAPACITIES     0x23
+#define SCSI_READ_CAPACITY              0x25
+#define SCSI_READ10                     0x28
+#define SCSI_WRITE10                    0x2A
+#define SCSI_VERIFY10                   0x2F
+#define SCSI_READ12                     0xA8
+#define SCSI_WRITE12                    0xAA
+#define SCSI_MODE_SELECT10              0x55
+#define SCSI_MODE_SENSE10               0x5A
+
+
+#endif  /* __MSC_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_mscuser.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_mscuser.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_mscuser.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_mscuser.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,276 @@
+/***********************************************************************
+* $Id:: mw_usbd_mscuser.h 577 2012-11-20 01:42:04Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     Mass Storage Class Custom User Module definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MSCUSER_H__
+#define __MSCUSER_H__
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_msc.h"
+#include "usbd_core.h"
+#include "app_usbd_cfg.h"
+
+/** \file
+ *  \brief Mass Storage Class (MSC) API structures and function prototypes.
+ *
+ *  Definition of functions exported by ROM based MSC function driver.
+ *
+ */
+
+/** \ingroup Group_USBD
+ *  @defgroup USBD_MSC Mass Storage Class (MSC) Function Driver
+ *  \section Sec_MSCModDescription Module Description
+ *  MSC Class Function Driver module. This module contains an internal implementation of the USB MSC Class.
+ *  User applications can use this class driver instead of implementing the MSC class manually
+ *  via the low-level USBD_HW and USBD_Core APIs.
+ *
+ *  This module is designed to simplify the user code by exposing only the required interface needed to interface with
+ *  Devices using the USB MSC Class.
+ */
+
+/** \brief Mass Storage class function driver initialization parameter data structure.
+ *  \ingroup USBD_MSC
+ *
+ *  \details  This data structure is used to pass initialization parameters to the 
+ *  Mass Storage class function driver's init function.
+ *
+ */
+typedef struct USBD_MSC_INIT_PARAM
+{
+  /* memory allocation params */
+  uint32_t mem_base;  /**< Base memory location from where the stack can allocate
+                      data and buffers. \note The memory address set in this field
+                      should be accessible by USB DMA controller. Also this value
+                      should be aligned on 4 byte boundary.
+                      */
+  uint32_t mem_size;  /**< The size of memory buffer which stack can use. 
+                      \note The \em mem_size should be greater than the size 
+                      returned by USBD_MSC_API::GetMemSize() routine.*/
+  /* mass storage params */
+  uint8_t*  InquiryStr; /**< Pointer to the 28 character string. This string is 
+                        sent in response to the SCSI Inquiry command. \note The data 
+                        pointed by the pointer should be of global scope. 
+                        */
+  uint32_t  BlockCount; /**< Number of blocks present in the mass storage device */
+  uint32_t  BlockSize; /**< Block size in number of bytes */
+  uint32_t  MemorySize; /**< Memory size in number of bytes */
+  /** Pointer to the interface descriptor within the descriptor
+  * array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T 
+  * structure. The stack assumes both HS and FS use same BULK endpoints. 
+  */
+
+  uint8_t* intf_desc;
+  /* user defined functions */
+
+ /** 
+  *  MSC Write callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a write command.
+  *  
+  *  \param[in] offset Destination start address. 
+  *  \param[in, out] src  Pointer to a pointer to the source of data. Pointer-to-pointer
+  *                       is used to implement zero-copy buffers. See \ref USBD_ZeroCopy
+  *                       for more details on zero-copy concept.
+  *  \param[in] length  Number of bytes to be written.
+  *  \return Nothing. 
+  *                                             
+  */
+  void (*MSC_Write)( uint32_t offset, uint8_t** src, uint32_t length, uint32_t high_offset); 
+ /** 
+  *  MSC Read callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a read command.
+  *  
+  *  \param[in] offset Source start address. 
+  *  \param[in, out] dst  Pointer to a pointer to the source of data. The MSC function drivers 
+  *         implemented in stack are written with zero-copy model. Meaning the stack doesn't make an 
+  *          extra copy of buffer before writing/reading data from USB hardware FIFO. Hence the 
+  *          parameter is pointer to a pointer containing address buffer (<em>uint8_t** dst</em>). 
+  *          So that the user application can update the buffer pointer instead of copying data to 
+  *          address pointed by the parameter. /note The updated buffer address should be accessible
+  *          by USB DMA master. If user doesn't want to use zero-copy model, then the user should copy
+  *          data to the address pointed by the passed buffer pointer parameter and shouldn't change 
+  *          the address value. See \ref USBD_ZeroCopy for more details on zero-copy concept.
+  *  \param[in] length  Number of bytes to be read.
+  *  \return Nothing. 
+  *                                             
+  */
+  void (*MSC_Read)( uint32_t offset, uint8_t** dst, uint32_t length, uint32_t high_offset);
+ /** 
+  *  MSC Verify callback function.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends a verify command. The callback function should compare the buffer
+  *  with the destination memory at the requested offset and 
+  *  
+  *  \param[in] offset Destination start address. 
+  *  \param[in] buf  Buffer containing the data sent by the host.
+  *  \param[in] length  Number of bytes to verify.
+  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK If data in the buffer matches the data at destination
+  *          \retval ERR_FAILED  At least one byte is different.
+  *                                             
+  */
+  ErrorCode_t (*MSC_Verify)( uint32_t offset, uint8_t buf[], uint32_t length, uint32_t high_offset);
+  /** 
+  *  Optional callback function to optimize MSC_Write buffer transfer.
+  *
+  *  This function is provided by the application software. This function gets called 
+  *  when host sends SCSI_WRITE10/SCSI_WRITE12 command. The callback function should 
+  *  update the \em buff_adr pointer so that the stack transfers the data directly
+  *  to the target buffer. /note The updated buffer address should be accessible
+  *  by USB DMA master. If user doesn't want to use zero-copy model, then the user 
+  *  should not update the buffer pointer. See \ref USBD_ZeroCopy for more details
+  *  on zero-copy concept.
+  *  
+  *  \param[in] offset Destination start address. 
+  *  \param[in,out] buf  Buffer containing the data sent by the host.
+  *  \param[in] length  Number of bytes to write.
+  *  \return Nothing. 
+  *                                             
+  */
+  void (*MSC_GetWriteBuf)( uint32_t offset, uint8_t** buff_adr, uint32_t length, uint32_t high_offset); 
+
+  /** 
+  *  Optional user override-able function to replace the default MSC class handler.
+  *
+  *  The application software could override the default EP0 class handler with their
+  *  own by providing the handler function address as this data member of the parameter
+  *  structure. Application which like the default handler should set this data member
+  *  to zero before calling the USBD_MSC_API::Init().
+  *  \n
+  *  \note 
+  *  
+  *  \param[in] hUsb Handle to the USB device stack. 
+  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
+  *  \param[in] event  Type of endpoint event. See \ref USBD_EVENT_T for more details.
+  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
+  *          \retval LPC_OK On success.
+  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
+  *          \retval ERR_USBD_xxx  For other error conditions. 
+  *                                             
+  */
+  ErrorCode_t (*MSC_Ep0_Hdlr) (USBD_HANDLE_T hUsb, void* data, uint32_t event);
+
+  uint64_t  MemorySize64;
+  
+} USBD_MSC_INIT_PARAM_T;
+
+/** \brief MSC class API functions structure.
+ *  \ingroup USBD_MSC
+ *
+ *  This module exposes functions which interact directly with USB device controller hardware.
+ *
+ */
+typedef struct USBD_MSC_API
+{
+  /** \fn uint32_t GetMemSize(USBD_MSC_INIT_PARAM_T* param)
+   *  Function to determine the memory required by the MSC function driver module.
+   * 
+   *  This function is called by application layer before calling pUsbApi->msc->Init(), to allocate memory used 
+   *  by MSC function driver module. The application should allocate the memory which is accessible by USB
+   *  controller/DMA controller. 
+   *  \note Some memory areas are not accessible by all bus masters.
+   *
+   *  \param[in] param Structure containing MSC function driver module initialization parameters.
+   *  \return Returns the required memory size in bytes.
+   */
+  uint32_t (*GetMemSize)(USBD_MSC_INIT_PARAM_T* param);
+  
+  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param)
+   *  Function to initialize MSC function driver module.
+   * 
+   *  This function is called by application layer to initialize MSC function driver module.
+   *
+   *  \param[in] hUsb Handle to the USB device stack. 
+   *  \param[in, out] param Structure containing MSC function driver module initialization parameters.
+   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
+   *          \retval LPC_OK On success
+   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte 
+   *              aligned or smaller than required. 
+   *          \retval ERR_API_INVALID_PARAM2 Either MSC_Write() or MSC_Read() or
+   *              MSC_Verify() callbacks are not defined. 
+   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
+   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
+   */
+  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param);
+
+} USBD_MSC_API_T;
+
+/*-----------------------------------------------------------------------------
+ *  Private functions & structures prototypes
+ *-----------------------------------------------------------------------------*/
+/** @cond  ADVANCED_API */
+
+typedef struct _MSC_CTRL_T
+{
+  /* If it's a USB HS, the max packet is 512, if it's USB FS,
+  the max packet is 64. Use 512 for both HS and FS. */
+  /*ALIGNED(4)*/ uint8_t  BulkBuf[USB_HS_MAX_BULK_PACKET]; /* Bulk In/Out Buffer */
+  /*ALIGNED(4)*/MSC_CBW CBW;                   /* Command Block Wrapper */
+  /*ALIGNED(4)*/MSC_CSW CSW;                   /* Command Status Wrapper */
+
+  USB_CORE_CTRL_T*  pUsbCtrl;
+  
+  uint64_t Offset;                  /* R/W Offset */
+  uint32_t Length;                  /* R/W Length */
+  uint32_t BulkLen;                 /* Bulk In/Out Length */
+  uint8_t* rx_buf;
+  
+  uint8_t BulkStage;               /* Bulk Stage */
+  uint8_t if_num;                  /* interface number */
+  uint8_t epin_num;                /* BULK IN endpoint number */
+  uint8_t epout_num;               /* BULK OUT endpoint number */
+  uint32_t MemOK;                  /* Memory OK */
+
+  uint8_t*  InquiryStr;
+  uint32_t  BlockCount;
+  uint32_t  BlockSize;
+  uint64_t  MemorySize;
+  /* user defined functions */
+  void (*MSC_Write)( uint32_t offset, uint8_t** src, uint32_t length, uint32_t high_offset); 
+  void (*MSC_Read)( uint32_t offset, uint8_t** dst, uint32_t length, uint32_t high_offset);
+  ErrorCode_t (*MSC_Verify)( uint32_t offset, uint8_t src[], uint32_t length, uint32_t high_offset);
+  /* optional call back for MSC_Write optimization */
+  void (*MSC_GetWriteBuf)( uint32_t offset, uint8_t** buff_adr, uint32_t length, uint32_t high_offset); 
+
+
+}USB_MSC_CTRL_T;
+
+/** @cond  DIRECT_API */
+extern uint32_t mwMSC_GetMemSize(USBD_MSC_INIT_PARAM_T* param);
+extern ErrorCode_t mwMSC_init(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param);
+/** @endcond */
+
+/** @endcond */
+
+
+#endif  /* __MSCUSER_H__ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_rom_api.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_rom_api.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_rom_api.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbd_rom/usbd_rom_api.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,98 @@
+/***********************************************************************
+* $Id:: mw_usbd_rom_api.h 331 2012-08-09 18:54:34Z usb10131                   $
+*
+* Project: USB device ROM Stack
+*
+* Description:
+*     ROM API Module definitions.
+*
+***********************************************************************
+*   Copyright(C) 2011, NXP Semiconductor
+*   All rights reserved.
+*
+* Software that is described herein is for illustrative purposes only
+* which provides customers with programming information regarding the
+* products. This software is supplied "AS IS" without any warranties.
+* NXP Semiconductors assumes no responsibility or liability for the
+* use of the software, conveys no license or title under any patent,
+* copyright, or mask work right to the product. NXP Semiconductors
+* reserves the right to make changes in the software without
+* notification. NXP Semiconductors also make no representation or
+* warranty that such application will be suitable for the specified
+* use without further testing or modification.
+**********************************************************************/
+#ifndef __MW_USBD_ROM_API_H
+#define __MW_USBD_ROM_API_H
+/** \file
+ *  \brief ROM API for USB device stack.
+ *
+ *  Definition of functions exported by ROM based USB device stack.
+ *
+ */
+
+#include "error.h"
+#include "usbd.h"
+#include "usbd_hw.h"
+#include "usbd_core.h"
+#include "usbd_mscuser.h"
+#include "usbd_dfuuser.h"
+#include "usbd_hiduser.h"
+#include "usbd_cdcuser.h"
+
+/** \brief Main USBD API functions structure.
+ *  \ingroup Group_USBD
+ *
+ *  This structure contains pointer to various USB Device stack's sub-module 
+ *  function tables. This structure is used as main entry point to access
+ *  various methods (grouped in sub-modules) exposed by ROM based USB device 
+ *  stack.
+ *
+ */
+typedef struct USBD_API 
+{
+  const USBD_HW_API_T* hw; /**< Pointer to function table which exposes functions 
+                           which interact directly with USB device stack's core 
+                           layer.*/
+  const USBD_CORE_API_T* core; /**< Pointer to function table which exposes functions 
+                           which interact directly with USB device controller 
+                           hardware.*/
+  const USBD_MSC_API_T* msc; /**< Pointer to function table which exposes functions 
+                           provided by MSC function driver module.
+                           */
+  const USBD_DFU_API_T* dfu; /**< Pointer to function table which exposes functions 
+                           provided by DFU function driver module.
+                           */
+  const USBD_HID_API_T* hid; /**< Pointer to function table which exposes functions 
+                           provided by HID function driver module.
+                           */
+  const USBD_CDC_API_T* cdc; /**< Pointer to function table which exposes functions 
+                           provided by CDC-ACM function driver module.
+                           */
+  const uint32_t* reserved6; /**< Reserved for future function driver module.
+                           */
+  const uint32_t version; /**< Version identifier of USB ROM stack. The version is
+                          defined as 0x0CHDMhCC where each nibble represents version
+                          number of the corresponding component.
+                          CC -  7:0  - 8bit core version number
+                           h - 11:8  - 4bit hardware interface version number
+                           M - 15:12 - 4bit MSC class module version number
+                           D - 19:16 - 4bit DFU class module version number
+                           H - 23:20 - 4bit HID class module version number
+                           C - 27:24 - 4bit CDC class module version number
+                           H - 31:28 - 4bit reserved 
+                           */
+
+} USBD_API_T;
+
+/* Applications using USBD ROM API should define this instance. The pointer should be assigned a value computed based on chip definitions. */ 
+extern const USBD_API_T* g_pUsbApi;
+#define USBD_API g_pUsbApi
+
+#endif /*__MW_USBD_ROM_API_H*/
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbhs_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/usbhs_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/usbhs_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/usbhs_18xx_43xx.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,129 @@
+/*
+ * @brief LPC18xx/43xx High-Speed USB driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __USBHS_18XX_43XX_H_
+#define __USBHS_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup USBHS_18XX_43XX CHIP: LPC18xx/43xx USBHS Device, Host, & OTG driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+/**
+ * @brief USB High-Speed register block structure
+ */
+typedef struct {							/*!< USB Structure         */
+	__I  uint32_t  RESERVED0[64];
+	__I  uint32_t  CAPLENGTH;				/*!< Capability register length */
+	__I  uint32_t  HCSPARAMS;				/*!< Host controller structural parameters */
+	__I  uint32_t  HCCPARAMS;				/*!< Host controller capability parameters */
+	__I  uint32_t  RESERVED1[5];
+	__I  uint32_t  DCIVERSION;				/*!< Device interface version number */
+	__I  uint32_t  RESERVED2[7];
+	union {
+		__IO uint32_t  USBCMD_H;			/*!< USB command (host mode) */
+		__IO uint32_t  USBCMD_D;			/*!< USB command (device mode) */
+	};
+
+	union {
+		__IO uint32_t  USBSTS_H;			/*!< USB status (host mode) */
+		__IO uint32_t  USBSTS_D;			/*!< USB status (device mode) */
+	};
+
+	union {
+		__IO uint32_t  USBINTR_H;			/*!< USB interrupt enable (host mode) */
+		__IO uint32_t  USBINTR_D;			/*!< USB interrupt enable (device mode) */
+	};
+
+	union {
+		__IO uint32_t  FRINDEX_H;			/*!< USB frame index (host mode) */
+		__I  uint32_t  FRINDEX_D;			/*!< USB frame index (device mode) */
+	};
+
+	__I  uint32_t  RESERVED3;
+	union {
+		__IO uint32_t  PERIODICLISTBASE;	/*!< Frame list base address */
+		__IO uint32_t  DEVICEADDR;			/*!< USB device address     */
+	};
+
+	union {
+		__IO uint32_t  ASYNCLISTADDR;		/*!< Address of endpoint list in memory (host mode) */
+		__IO uint32_t  ENDPOINTLISTADDR;	/*!< Address of endpoint list in memory (device mode) */
+	};
+
+	__IO uint32_t  TTCTRL;					/*!< Asynchronous buffer status for embedded TT (host mode) */
+	__IO uint32_t  BURSTSIZE;				/*!< Programmable burst size */
+	__IO uint32_t  TXFILLTUNING;			/*!< Host transmit pre-buffer packet tuning (host mode) */
+	__I  uint32_t  RESERVED4[2];
+	__IO uint32_t  ULPIVIEWPORT;			/*!< ULPI viewport          */
+	__IO uint32_t  BINTERVAL;				/*!< Length of virtual frame */
+	__IO uint32_t  ENDPTNAK;				/*!< Endpoint NAK (device mode) */
+	__IO uint32_t  ENDPTNAKEN;				/*!< Endpoint NAK Enable (device mode) */
+	__I  uint32_t  RESERVED5;
+	union {
+		__IO uint32_t  PORTSC1_H;			/*!< Port 1 status/control (host mode) */
+		__IO uint32_t  PORTSC1_D;			/*!< Port 1 status/control (device mode) */
+	};
+
+	__I  uint32_t  RESERVED6[7];
+	__IO uint32_t  OTGSC;					/*!< OTG status and control */
+	union {
+		__IO uint32_t  USBMODE_H;			/*!< USB mode (host mode)   */
+		__IO uint32_t  USBMODE_D;			/*!< USB mode (device mode) */
+	};
+
+	__IO uint32_t  ENDPTSETUPSTAT;			/*!< Endpoint setup status  */
+	__IO uint32_t  ENDPTPRIME;				/*!< Endpoint initialization */
+	__IO uint32_t  ENDPTFLUSH;				/*!< Endpoint de-initialization */
+	__I  uint32_t  ENDPTSTAT;				/*!< Endpoint status        */
+	__IO uint32_t  ENDPTCOMPLETE;			/*!< Endpoint complete      */
+	__IO uint32_t  ENDPTCTRL[6];			/*!< Endpoint control 0     */
+} LPC_USBHS_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __USBHS_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/wwdt_18xx_43xx.h ./libs/vendor_libs/lpc_chip_43xx/inc/wwdt_18xx_43xx.h
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/inc/wwdt_18xx_43xx.h	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/inc/wwdt_18xx_43xx.h	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,233 @@
+/*
+ * @brief LPC18xx/43xx WWDT driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __WWDT_18XX_43XX_H_
+#define __WWDT_18XX_43XX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup WWDT_18XX_43XX CHIP: LPC18xx/43xx Windowed Watchdog driver
+ * @ingroup CHIP_18XX_43XX_Drivers
+ * @{
+ */
+
+#define WATCHDOG_WINDOW_SUPPORT
+
+/** WDT oscillator frequency value */
+#define WDT_OSC     (CGU_IRC_FREQ)
+
+/**
+ * @brief Windowed Watchdog register block structure
+ */
+typedef struct {				/*!< WWDT Structure         */
+	__IO uint32_t  MOD;			/*!< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
+	__IO uint32_t  TC;			/*!< Watchdog timer constant register. This register determines the time-out value. */
+	__O  uint32_t  FEED;		/*!< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC. */
+	__I  uint32_t  TV;			/*!< Watchdog timer value register. This register reads out the current value of the Watchdog timer. */
+	__I  uint32_t  RESERVED0;
+#ifdef WATCHDOG_WINDOW_SUPPORT
+	__IO uint32_t  WARNINT;		/*!< Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value. */
+	__IO uint32_t  WINDOW;		/*!< Watchdog timer window register. This register contains the Watchdog window value. */
+#endif
+} LPC_WWDT_T;
+
+/**
+ * @brief Watchdog Mode register definitions
+ */
+/** Watchdog Mode Bitmask */
+#define WWDT_WDMOD_BITMASK          ((uint32_t) 0x1F)
+/** WWDT interrupt enable bit */
+#define WWDT_WDMOD_WDEN             ((uint32_t) (1 << 0))
+/** WWDT interrupt enable bit */
+#define WWDT_WDMOD_WDRESET          ((uint32_t) (1 << 1))
+/** WWDT time out flag bit */
+#define WWDT_WDMOD_WDTOF            ((uint32_t) (1 << 2))
+/** WDT Time Out flag bit */
+#define WWDT_WDMOD_WDINT            ((uint32_t) (1 << 3))
+/** WWDT Protect flag bit */
+#define WWDT_WDMOD_WDPROTECT        ((uint32_t) (1 << 4))
+
+/**
+ * @brief	Initialize the Watchdog timer
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ */
+void Chip_WWDT_Init(LPC_WWDT_T *pWWDT);
+
+/**
+ * @brief	Shutdown the Watchdog timer
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ */
+void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT);
+
+/**
+ * @brief	Set WDT timeout constant value used for feed
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
+ * @return	none
+ */
+STATIC INLINE void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+	pWWDT->TC = timeout;
+}
+
+/**
+ * @brief	Feed watchdog timer
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ * @note	If this function isn't called, a watchdog timer warning will occur.
+ * After the warning, a timeout will occur if a feed has happened.
+ */
+STATIC INLINE void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
+{
+	pWWDT->FEED = 0xAA;
+	pWWDT->FEED = 0x55;
+}
+
+#if defined(WATCHDOG_WINDOW_SUPPORT)
+/**
+ * @brief	Set WWDT warning interrupt
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	timeout	: WDT warning in ticks, between 0 and 1023
+ * @return	None
+ * @note	This is the number of ticks after the watchdog interrupt that the
+ * warning interrupt will be generated.
+ */
+STATIC INLINE void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+	pWWDT->WARNINT = timeout;
+}
+
+/**
+ * @brief	Set WWDT window time
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
+ * @return	None
+ * @note	The watchdog timer must be fed between the timeout from the Chip_WWDT_SetTimeOut()
+ * function and this function, with this function defining the last tick before the
+ * watchdog window interrupt occurs.
+ */
+STATIC INLINE void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+	pWWDT->WINDOW = timeout;
+}
+
+#endif
+
+/**
+ * @brief	Enable watchdog timer options
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	options	: An or'ed set of options of values
+ *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
+ * @return	None
+ * @note	You can enable more than one option at once (ie, WWDT_WDMOD_WDRESET |
+ * WWDT_WDMOD_WDPROTECT), but use the WWDT_WDMOD_WDEN after all other options
+ * are set (or unset) with no other options. If WWDT_WDMOD_LOCK is used, it cannot
+ * be unset.
+ */
+STATIC INLINE void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
+{
+	pWWDT->MOD |= options;
+}
+
+/**
+ * @brief	Disable/clear watchdog timer options
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	options	: An or'ed set of options of values
+ *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
+ * @return	None
+ * @note	You can disable more than one option at once (ie, WWDT_WDMOD_WDRESET |
+ * WWDT_WDMOD_WDTOF).
+ */
+STATIC INLINE void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
+{
+	pWWDT->MOD &= (~options) & WWDT_WDMOD_BITMASK;
+}
+
+/**
+ * @brief	Enable WWDT activity
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ */
+STATIC INLINE void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
+{
+	Chip_WWDT_SetOption(pWWDT, WWDT_WDMOD_WDEN);
+	Chip_WWDT_Feed(pWWDT);
+}
+
+/**
+ * @brief	Read WWDT status flag
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	Watchdog status, an Or'ed value of WWDT_WDMOD_*
+ */
+STATIC INLINE uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
+{
+	return pWWDT->MOD;
+}
+
+/**
+ * @brief	Clear WWDT interrupt status flags
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	status	: Or'ed value of status flag(s) that you want to clear, should be:
+ *              - WWDT_WDMOD_WDTOF: Clear watchdog timeout flag
+ *              - WWDT_WDMOD_WDINT: Clear watchdog warning flag
+ * @return	None
+ */
+void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status);
+
+/**
+ * @brief	Get the current value of WDT
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	current value of WDT
+ */
+STATIC INLINE uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
+{
+	return pWWDT->TV;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __WWDT_18XX_43XX_H_ */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/adc_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/adc_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/adc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/adc_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,263 @@
+/*
+ * @brief LPC18xx/43xx A/D conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Get the number of clock for a full conversion */
+STATIC INLINE uint8_t getFullConvClk(void)
+{
+	return 11;
+}
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_ADC_GetClockIndex(LPC_ADC_T *pADC)
+{
+	CHIP_CCU_CLK_T clkADC;
+
+	if (pADC == LPC_ADC1) {
+		clkADC = CLK_APB3_ADC1;
+	}
+	else {
+		clkADC = CLK_APB3_ADC0;
+	}
+
+	return clkADC;
+}
+
+/* Get divider value */
+STATIC uint8_t getClkDiv(LPC_ADC_T *pADC, bool burstMode, uint32_t adcRate, uint8_t clks)
+{
+	uint32_t adcBlockFreq;
+	uint32_t fullAdcRate;
+	uint8_t div;
+
+	/* The APB clock (PCLK_ADC0) is divided by (CLKDIV+1) to produce the clock for
+	   A/D converter, which should be less than or equal to 4.5MHz.
+	   A fully conversion requires (bits_accuracy+1) of these clocks.
+	   ADC Clock = PCLK_ADC0 / (CLKDIV + 1);
+	   ADC rate = ADC clock / (the number of clocks required for each conversion);
+	 */
+	adcBlockFreq = Chip_Clock_GetRate(Chip_ADC_GetClockIndex(pADC));
+	if (burstMode) {
+		fullAdcRate = adcRate * clks;
+	}
+	else {
+		fullAdcRate = adcRate * getFullConvClk();
+	}
+
+	/* Get the round value by fomular: (2*A + B)/(2*B) */
+	div = ((adcBlockFreq * 2 + fullAdcRate) / (fullAdcRate * 2)) - 1;
+	return div;
+}
+
+/* Set start mode for ADC */
+void setStartMode(LPC_ADC_T *pADC, uint8_t start_mode)
+{
+	uint32_t temp;
+	temp = pADC->CR & (~ADC_CR_START_MASK);
+	pADC->CR = temp | (ADC_CR_START_MODE_SEL((uint32_t) start_mode));
+}
+
+/* Get the ADC value */
+Status readAdcVal(LPC_ADC_T *pADC, uint8_t channel, uint16_t *data)
+{
+	uint32_t temp;
+	temp = pADC->DR[channel];
+	if (!ADC_DR_DONE(temp)) {
+		return ERROR;
+	}
+	/*	if(ADC_DR_OVERRUN(temp) && (pADC->CR & ADC_CR_BURST)) */
+	/*	return ERROR; */
+	*data = (uint16_t) ADC_DR_RESULT(temp);
+	return SUCCESS;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the ADC peripheral and the ADC setup structure to default value */
+void Chip_ADC_Init(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup)
+{
+	uint8_t div;
+	uint32_t cr = 0;
+	uint32_t clk;
+
+	Chip_Clock_EnableOpts(Chip_ADC_GetClockIndex(pADC), true, true, 1);
+
+	pADC->INTEN = 0;		/* Disable all interrupts */
+
+	cr |= ADC_CR_PDN;
+	ADCSetup->adcRate = ADC_MAX_SAMPLE_RATE;
+	ADCSetup->bitsAccuracy = ADC_10BITS;
+	clk = 11;
+	ADCSetup->burstMode = false;
+	div = getClkDiv(pADC, false, ADCSetup->adcRate, clk);
+	cr |= ADC_CR_CLKDIV(div);
+	cr |= ADC_CR_BITACC(ADCSetup->bitsAccuracy);
+	pADC->CR = cr;
+}
+
+/* Shutdown ADC */
+void Chip_ADC_DeInit(LPC_ADC_T *pADC)
+{
+	pADC->INTEN = 0x00000100;
+	pADC->CR = 0;
+	Chip_Clock_Disable(Chip_ADC_GetClockIndex(pADC));
+}
+
+/* Get the ADC value */
+Status Chip_ADC_ReadValue(LPC_ADC_T *pADC, uint8_t channel, uint16_t *data)
+{
+	return readAdcVal(pADC, channel, data);
+}
+
+/* Get ADC Channel status from ADC data register */
+FlagStatus Chip_ADC_ReadStatus(LPC_ADC_T *pADC, uint8_t channel, uint32_t StatusType)
+{
+	switch (StatusType) {
+	case ADC_DR_DONE_STAT:
+		return (pADC->STAT & (1UL << channel)) ? SET : RESET;
+
+	case ADC_DR_OVERRUN_STAT:
+		channel += 8;
+		return (pADC->STAT & (1UL << channel)) ? SET : RESET;
+
+	case ADC_DR_ADINT_STAT:
+		return pADC->STAT >> 16 ? SET : RESET;
+
+	default:
+		break;
+	}
+	return RESET;
+}
+
+/* Enable/Disable interrupt for ADC channel */
+void Chip_ADC_Int_SetChannelCmd(LPC_ADC_T *pADC, uint8_t channel, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		pADC->INTEN |= (1UL << channel);
+	}
+	else {
+		pADC->INTEN &= (~(1UL << channel));
+	}
+}
+
+/* Select the mode starting the AD conversion */
+void Chip_ADC_SetStartMode(LPC_ADC_T *pADC, ADC_START_MODE_T mode, ADC_EDGE_CFG_T EdgeOption)
+{
+	if ((mode != ADC_START_NOW) && (mode != ADC_NO_START)) {
+		if (EdgeOption) {
+			pADC->CR |= ADC_CR_EDGE;
+		}
+		else {
+			pADC->CR &= ~ADC_CR_EDGE;
+		}
+	}
+	setStartMode(pADC, (uint8_t) mode);
+}
+
+/* Set the ADC Sample rate */
+void Chip_ADC_SetSampleRate(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, uint32_t rate)
+{
+	uint8_t div;
+	uint32_t cr;
+
+	cr = pADC->CR & (~ADC_SAMPLE_RATE_CONFIG_MASK);
+	ADCSetup->adcRate = rate;
+	div = getClkDiv(pADC, ADCSetup->burstMode, rate, (11 - ADCSetup->bitsAccuracy));
+	cr |= ADC_CR_CLKDIV(div);
+	cr |= ADC_CR_BITACC(ADCSetup->bitsAccuracy);
+	pADC->CR = cr;
+}
+
+/* Set the ADC accuracy bits */
+void Chip_ADC_SetResolution(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, ADC_RESOLUTION_T resolution)
+{
+	ADCSetup->bitsAccuracy = resolution;
+	Chip_ADC_SetSampleRate(pADC, ADCSetup, ADCSetup->adcRate);
+}
+
+/* Enable or disable the ADC channel on ADC peripheral */
+void Chip_ADC_EnableChannel(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		pADC->CR |= ADC_CR_CH_SEL(channel);
+	}
+	else {
+		pADC->CR &= ~ADC_CR_START_MASK;
+		pADC->CR &= ~ADC_CR_CH_SEL(channel);
+	}
+}
+
+/* Enable burst mode */
+void Chip_ADC_SetBurstCmd(LPC_ADC_T *pADC, FunctionalState NewState)
+{
+	setStartMode(pADC, ADC_NO_START);
+	
+    if (NewState == DISABLE) {
+		pADC->CR &= ~ADC_CR_BURST;
+	}
+	else {
+		pADC->CR |= ADC_CR_BURST;
+	}
+}
+
+/* Read the ADC value and convert it to 8bits value */
+Status Chip_ADC_ReadByte(LPC_ADC_T *pADC, ADC_CHANNEL_T channel, uint8_t *data)
+{
+	uint16_t temp;
+	Status rt;
+
+	rt = readAdcVal(pADC, channel, &temp);
+	*data = (uint8_t) temp;
+
+	return rt;
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/aes_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/aes_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/aes_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/aes_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,180 @@
+/*
+ * @brief LPC18xx/43xx AES Engine driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define BOOTROM_BASE			0x10400100
+#define AES_API_TABLE_OFFSET	0x2
+
+typedef	void		(*V_FP_V)(void);
+typedef	uint32_t	(*U32_FP_V)(void);
+
+static unsigned long *BOOTROM_API_TABLE;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+static uint32_t (*aes_SetMode)(CHIP_AES_OP_MODE_T AesMode);
+static void (*aes_LoadKey1)(void);
+static void (*aes_LoadKey2)(void);
+static void (*aes_LoadKeyRNG)(void);
+static void (*aes_LoadKeySW)(uint8_t *pKey);
+static void (*aes_LoadIV_SW)(uint8_t *pVector);
+static void (*aes_LoadIV_IC)(void);
+static uint32_t (*aes_Operate)(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t size);
+static uint32_t (*aes_ProgramKey1)(uint8_t *pKey);
+static uint32_t (*aes_ProgramKey2)(uint8_t *pKey);
+static uint32_t (*aes_Config_DMA) (uint32_t channel_id);
+static uint32_t (*aes_Operate_DMA)(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size);
+static uint32_t (*aes_Get_Status_DMA) (uint32_t channel_id);
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* CHIP AES Initialisation function */
+void Chip_AES_Init(void)
+{
+	uint32_t (*ROM_aes_Init)(void);
+
+	BOOTROM_API_TABLE = *((unsigned long * *) BOOTROM_BASE + AES_API_TABLE_OFFSET);
+
+	ROM_aes_Init		= (uint32_t (*)(void))BOOTROM_API_TABLE[0];
+	aes_SetMode			= (uint32_t (*)(CHIP_AES_OP_MODE_T AesMode))BOOTROM_API_TABLE[1];
+	aes_LoadKey1		= (void (*)(void))BOOTROM_API_TABLE[2];
+	aes_LoadKey2		= (void (*)(void))BOOTROM_API_TABLE[3];
+	aes_LoadKeyRNG		= (void (*)(void))BOOTROM_API_TABLE[4];
+	aes_LoadKeySW		= (void (*)(uint8_t *pKey))BOOTROM_API_TABLE[5];
+	aes_LoadIV_SW		= (void (*)(uint8_t *pVector))BOOTROM_API_TABLE[6];
+	aes_LoadIV_IC		= (void (*)(void))BOOTROM_API_TABLE[7];
+	aes_Operate			= (uint32_t (*)(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t Size))BOOTROM_API_TABLE[8];
+	aes_ProgramKey1		= (uint32_t (*)(uint8_t *pKey))BOOTROM_API_TABLE[9];
+	aes_ProgramKey2		= (uint32_t (*)(uint8_t *pKey))BOOTROM_API_TABLE[10];
+	aes_Config_DMA		= (uint32_t (*)(uint32_t channel_id))BOOTROM_API_TABLE[11];
+	aes_Operate_DMA		= (uint32_t (*)(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size))BOOTROM_API_TABLE[12];
+	aes_Get_Status_DMA	= (uint32_t (*) (uint32_t channel_id))BOOTROM_API_TABLE[13];
+	
+	ROM_aes_Init();
+}
+
+/* Set Operation mode in AES Engine */
+uint32_t Chip_AES_SetMode(CHIP_AES_OP_MODE_T AesMode)
+{
+	return aes_SetMode(AesMode);
+}
+
+/* Load 128-bit user key in AES Engine */
+void Chip_AES_LoadKey(uint32_t keyNum)
+{
+	if (keyNum) {
+		aes_LoadKey2();
+	}
+	else {
+		aes_LoadKey1();
+	}
+}
+
+/* Load randomly generated key in AES engine */
+void Chip_AES_LoadKeyRNG(void)
+{
+	aes_LoadKeyRNG();
+}
+
+/* Load 128-bit AES software defined user key */
+void Chip_AES_LoadKeySW(uint8_t *pKey)
+{
+	aes_LoadKeySW(pKey);
+}
+
+/* Load 128-bit AES initialization vector */
+void Chip_AES_LoadIV_SW(uint8_t *pVector)
+{
+	aes_LoadIV_SW(pVector);
+}
+
+/* Load IC specific 128-bit AES initialization vector */
+void Chip_AES_LoadIV_IC(void)
+{
+	aes_LoadIV_IC();
+}
+
+/* Operate AES Engine */
+uint32_t Chip_AES_Operate(uint8_t *pDatOut, uint8_t *pDatIn, uint32_t Size)
+{
+	return aes_Operate(pDatOut, pDatIn, Size);
+}
+
+/* Program 128-bit AES Key in OTP */
+uint32_t Chip_AES_ProgramKey(uint32_t KeyNum, uint8_t *pKey)
+{
+	uint32_t status;
+
+	if (KeyNum) {
+		status = aes_ProgramKey2(pKey);
+	}
+	else {
+		status = aes_ProgramKey1(pKey);
+	}
+	return status;
+}
+
+/* Configure DMA channel to process AES block */
+uint32_t Chip_AES_Config_DMA(uint32_t channel_id)
+{
+	return aes_Config_DMA(channel_id);
+}
+
+/* Enables DMA channel and Operates AES Engine */
+uint32_t Chip_AES_OperateDMA(uint32_t channel_id, uint8_t *dataOutAddr, uint8_t *dataInAddr, uint32_t size)
+{
+	return aes_Operate_DMA(channel_id,dataOutAddr,dataInAddr,size);
+}
+
+/* Read status of DMA channels that process an AES data block. */
+uint32_t Chip_AES_GetStatusDMA(uint32_t channel_id)
+{
+	return aes_Get_Status_DMA(channel_id);
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/atimer_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/atimer_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/atimer_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/atimer_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,69 @@
+/*
+ * @brief LPC18xx/43xx Alarm Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize Alarm Timer */
+void Chip_ATIMER_Init(LPC_ATIMER_T *pATIMER, uint32_t PresetValue)
+{
+	Chip_ATIMER_UpdatePresetValue(pATIMER, PresetValue);
+	Chip_ATIMER_ClearIntStatus(pATIMER);
+}
+
+/* Close ATIMER device */
+void Chip_ATIMER_DeInit(LPC_ATIMER_T *pATIMER)
+{
+	Chip_ATIMER_ClearIntStatus(pATIMER);
+	Chip_ATIMER_IntDisable(pATIMER);
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ccan_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/ccan_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ccan_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/ccan_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,317 @@
+/*
+ * @brief LPC18xx/43xx CCAN driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Configure the bit timing for CCAN bus */
+STATIC void configTimming(LPC_CCAN_T *pCCAN,
+						  uint32_t ClkDiv,
+						  uint32_t BaudRatePrescaler,
+						  uint8_t SynJumpWidth,
+						  uint8_t Tseg1,
+						  uint8_t Tseg2)
+{
+	/* Reset software */
+	if (!(pCCAN->CNTL & CCAN_CTRL_INIT)) {
+		pCCAN->CNTL |= CCAN_CTRL_INIT;
+	}
+
+	/*Set bus timing */
+	pCCAN->CLKDIV = ClkDiv;			/* Divider for CAN VPB3 clock */
+	pCCAN->CNTL |= CCAN_CTRL_CCE;		/* Start configuring bit timing */
+	pCCAN->BT = (BaudRatePrescaler & 0x3F) | (SynJumpWidth & 0x03) << 6 | (Tseg1 & 0x0F) << 8 | (Tseg2 & 0x07) << 12;
+	pCCAN->BRPE = BaudRatePrescaler >> 6;	/* Set Baud Rate Prescaler MSBs */
+	pCCAN->CNTL &= ~CCAN_CTRL_CCE;		/* Stop configuring bit timing */
+
+	/* Finish software initialization */
+	pCCAN->CNTL &= ~CCAN_CTRL_INIT;
+	while ( pCCAN->CNTL & CCAN_CTRL_INIT ) {}
+}
+
+/* Return 1->32; 0 if not find free msg */
+STATIC uint8_t getFreeMsgObject(LPC_CCAN_T *pCCAN)
+{
+	uint32_t msg_valid;
+	uint8_t i;
+	msg_valid = Chip_CCAN_GetValidMsg(pCCAN);
+	for (i = 0; i < CCAN_MSG_MAX_NUM; i++) {
+		if (!((msg_valid >> i) & 1UL)) {
+			return i + 1;
+		}
+	}
+	return 0;	// No free object
+}
+
+STATIC void freeMsgObject(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum)
+{
+	Chip_CCAN_SetValidMsg(pCCAN, IFSel, msgNum, false);
+}
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_CCAN_GetClockIndex(LPC_CCAN_T *pCCAN)
+{
+	CHIP_CCU_CLK_T clkCCAN;
+
+	if (pCCAN == LPC_C_CAN1) {
+		clkCCAN = CLK_APB1_CAN1;
+	}
+	else {
+		clkCCAN = CLK_APB3_CAN0;
+	}
+
+	return clkCCAN;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the CCAN peripheral, free all message object in RAM */
+void Chip_CCAN_Init(LPC_CCAN_T *pCCAN)
+{
+	uint8_t i;
+
+	Chip_Clock_EnableOpts(Chip_CCAN_GetClockIndex(pCCAN), true, false, 1);
+
+	for (i = 1; i <= CCAN_MSG_MAX_NUM; i++) {
+		freeMsgObject(pCCAN, CCAN_MSG_IF1, i);
+	}
+	Chip_CCAN_ClearStatus(pCCAN, (CCAN_STAT_RXOK | CCAN_STAT_TXOK));
+}
+
+/* De-initialize the CCAN peripheral */
+void Chip_CCAN_DeInit(LPC_CCAN_T *pCCAN)
+{
+	Chip_Clock_Disable(Chip_CCAN_GetClockIndex(pCCAN));
+}
+
+/* Select bit rate for CCAN bus */
+Status Chip_CCAN_SetBitRate(LPC_CCAN_T *pCCAN, uint32_t bitRate)
+{
+	uint32_t pClk, div, quanta, segs, seg1, seg2, clk_per_bit, can_sjw;
+	pClk = Chip_Clock_GetRate(Chip_CCAN_GetClockIndex(pCCAN));
+	clk_per_bit = pClk / bitRate;
+
+	for (div = 0; div <= 15; div++) {
+		for (quanta = 1; quanta <= 32; quanta++) {
+			for (segs = 3; segs <= 17; segs++) {
+				if (clk_per_bit == (segs * quanta * (div + 1))) {
+					segs -= 3;
+					seg1 = segs / 2;
+					seg2 = segs - seg1;
+					can_sjw = seg1 > 3 ? 3 : seg1;
+					configTimming(pCCAN, div, quanta - 1, can_sjw, seg1, seg2);
+					return SUCCESS;
+				}
+			}
+		}
+	}
+	return ERROR;
+}
+
+/* Clear the status of CCAN bus */
+void Chip_CCAN_ClearStatus(LPC_CCAN_T *pCCAN, uint32_t val)
+{
+	uint32_t tmp = Chip_CCAN_GetStatus(pCCAN);
+	Chip_CCAN_SetStatus(pCCAN, tmp & (~val));
+}
+
+/* Set a message into the message object in message RAM */
+void Chip_CCAN_SetMsgObject(LPC_CCAN_T *pCCAN,
+							CCAN_MSG_IF_T IFSel,
+							CCAN_TRANSFER_DIR_T dir,
+							bool remoteFrame,
+							uint8_t msgNum,
+							const CCAN_MSG_OBJ_T *pMsgObj)
+{
+	uint16_t *pData;
+	uint32_t msgCtrl = 0;
+
+	if (pMsgObj == NULL) {
+		return;
+	}
+	pData = (uint16_t *) (pMsgObj->data);
+
+	msgCtrl |= CCAN_IF_MCTRL_UMSK | CCAN_IF_MCTRL_RMTEN(remoteFrame) | CCAN_IF_MCTRL_EOB |
+			   (pMsgObj->dlc & CCAN_IF_MCTRL_DLC_MSK);
+	if (dir == CCAN_TX_DIR) {
+		msgCtrl |= CCAN_IF_MCTRL_TXIE;
+		if (!remoteFrame) {
+			msgCtrl |= CCAN_IF_MCTRL_TXRQ;
+		}
+	}
+	else {
+		msgCtrl |= CCAN_IF_MCTRL_RXIE;
+	}
+
+	pCCAN->IF[IFSel].MCTRL = msgCtrl;
+	pCCAN->IF[IFSel].DA1 = *pData++;	/* Lower two bytes of message pointer */
+	pCCAN->IF[IFSel].DA2 = *pData++;	/* Upper two bytes of message pointer */
+	pCCAN->IF[IFSel].DB1 = *pData++;	/* Lower two bytes of message pointer */
+	pCCAN->IF[IFSel].DB2 = *pData;	/* Upper two bytes of message pointer */
+
+	/* Configure arbitration */
+	if (!(pMsgObj->id & (0x1 << 30))) {					/* bit 30 is 0, standard frame */
+		/* Mxtd: 0, Mdir: 1, Mask is 0x7FF */
+		pCCAN->IF[IFSel].MSK2 = CCAN_IF_MASK2_MDIR(dir) | (CCAN_MSG_ID_STD_MASK << 2);
+		pCCAN->IF[IFSel].MSK1 = 0x0000;
+
+		/* MsgVal: 1, Mtd: 0, Dir: 1, ID = 0x200 */
+		pCCAN->IF[IFSel].ARB2 = CCAN_IF_ARB2_MSGVAL | CCAN_IF_ARB2_DIR(dir) | (pMsgObj->id << 2);
+		pCCAN->IF[IFSel].ARB1 = 0x0000;
+	}
+	else {										/* Extended frame */
+		/* Mxtd: 1, Mdir: 1, Mask is 0x1FFFFFFF */
+		pCCAN->IF[IFSel].MSK2 = CCAN_IF_MASK2_MXTD | CCAN_IF_MASK2_MDIR(dir) | (CCAN_MSG_ID_EXT_MASK >> 16);
+		pCCAN->IF[IFSel].MSK1 = CCAN_MSG_ID_EXT_MASK & 0x0000FFFF;
+
+		/* MsgVal: 1, Mtd: 1, Dir: 1, ID = 0x200000 */
+		pCCAN->IF[IFSel].ARB2 = CCAN_IF_ARB2_MSGVAL | CCAN_IF_ARB2_XTD | CCAN_IF_ARB2_DIR(dir) | (pMsgObj->id >> 16);
+		pCCAN->IF[IFSel].ARB1 = pMsgObj->id & 0x0000FFFF;
+	}
+
+	Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_WR | CCAN_IF_CMDMSK_TRANSFER_ALL, msgNum);
+}
+
+/* Get a message object in message RAM into the message buffer */
+void Chip_CCAN_GetMsgObject(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, CCAN_MSG_OBJ_T *pMsgObj)
+{
+	uint32_t *pData;
+	if (!pMsgObj) {
+		return;
+	}
+	pData = (uint32_t *) pMsgObj->data;
+	Chip_CCAN_TransferMsgObject(pCCAN,
+								IFSel,
+								CCAN_IF_CMDMSK_RD | CCAN_IF_CMDMSK_TRANSFER_ALL | CCAN_IF_CMDMSK_R_CLRINTPND,
+								msgNum);
+
+	if (pCCAN->IF[IFSel].MCTRL & CCAN_IF_MCTRL_NEWD) {
+		pMsgObj->id = (pCCAN->IF[IFSel].ARB1) | (pCCAN->IF[IFSel].ARB2 << 16);
+		pMsgObj->dlc = pCCAN->IF[IFSel].MCTRL & CCAN_IF_MCTRL_DLC_MSK;
+		*pData++ = (pCCAN->IF[IFSel].DA2 << 16) | pCCAN->IF[IFSel].DA1;
+		*pData = (pCCAN->IF[IFSel].DB2 << 16) | pCCAN->IF[IFSel].DB1;
+
+		if (pMsgObj->id & (0x1 << 30)) {
+			pMsgObj->id &= CCAN_MSG_ID_EXT_MASK;
+		}
+		else {
+			pMsgObj->id >>= 18;
+			pMsgObj->id &= CCAN_MSG_ID_STD_MASK;
+		}
+	}
+}
+
+/* Data transfer between IF registers and Message RAM */
+void Chip_CCAN_TransferMsgObject(LPC_CCAN_T *pCCAN,
+								 CCAN_MSG_IF_T IFSel,
+								 uint32_t mask,
+								 uint32_t msgNum) {
+	msgNum &= 0x3F;
+	pCCAN->IF[IFSel].CMDMSK = mask;
+	pCCAN->IF[IFSel].CMDREQ = msgNum;
+	while (pCCAN->IF[IFSel].CMDREQ & CCAN_IF_CMDREQ_BUSY ) {}
+}
+
+/* Enable/Disable the message object to valid */
+void Chip_CCAN_SetValidMsg(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint8_t msgNum, bool valid)
+{
+
+	uint32_t temp;
+	temp = pCCAN->IF[IFSel].ARB2;
+	if (!valid) {
+		pCCAN->IF[IFSel].ARB2 = (temp & (~CCAN_IF_ARB2_MSGVAL));
+	}
+	else {
+		pCCAN->IF[IFSel].ARB2 = (temp | (CCAN_IF_ARB2_MSGVAL));
+	}
+
+	Chip_CCAN_TransferMsgObject(pCCAN, IFSel, CCAN_IF_CMDMSK_WR | CCAN_IF_CMDMSK_ARB, msgNum);
+}
+
+/* Send a message */
+void Chip_CCAN_Send(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, bool remoteFrame, CCAN_MSG_OBJ_T *pMsgObj)
+{
+	uint8_t msgNum = getFreeMsgObject(pCCAN);
+	if (!msgNum) {
+		return;
+	}
+	Chip_CCAN_SetMsgObject(pCCAN, IFSel, CCAN_TX_DIR, remoteFrame, msgNum, pMsgObj);
+	while (Chip_CCAN_GetTxRQST(pCCAN) >> (msgNum - 1)) {	// blocking , wait for sending completed
+	}
+	if (!remoteFrame) {
+		freeMsgObject(pCCAN, IFSel, msgNum);
+	}
+}
+
+/* Register a message ID for receiving */
+void Chip_CCAN_AddReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id)
+{
+	CCAN_MSG_OBJ_T temp;
+	uint8_t msgNum = getFreeMsgObject(pCCAN);
+	if (!msgNum) {
+		return;
+	}
+	temp.id = id;
+	Chip_CCAN_SetMsgObject(pCCAN, IFSel, CCAN_RX_DIR, false, msgNum, &temp);
+}
+
+/* Remove a registered message ID from receiving */
+void Chip_CCAN_DeleteReceiveID(LPC_CCAN_T *pCCAN, CCAN_MSG_IF_T IFSel, uint32_t id)
+{
+	uint8_t i;
+	CCAN_MSG_OBJ_T temp;
+	for (i = 1; i <= CCAN_MSG_MAX_NUM; i++) {
+		Chip_CCAN_GetMsgObject(pCCAN, IFSel, i, &temp);
+		if (temp.id == id) {
+			freeMsgObject(pCCAN, IFSel, i);
+		}
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/chip_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/chip_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/chip_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/chip_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,123 @@
+/*
+ * @brief LPC18xx/LPC43xx chip driver source
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+/* USB PLL pre-initialized setup values for 480MHz output rate */
+static const CGU_USBAUDIO_PLL_SETUP_T usbPLLSetup = {
+	0x0000601D,	/* Default control with main osc input, PLL disabled */
+	0x06167FFA,	/* M-divider value for 480MHz output from 12MHz input */
+	0x00000000,	/* N-divider value */
+	0x00000000,	/* Not applicable for USB PLL */
+	480000000   /* PLL output frequency */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+/* System Clock Frequency (Core Clock) */
+uint32_t SystemCoreClock;
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+static void Chip_USB_PllSetup(void)
+{
+	/* No need to setup anything if PLL is already setup for the frequency */
+	if (Chip_Clock_GetClockInputHz(CLKIN_USBPLL) == usbPLLSetup.freq)
+		return ;
+
+	/* Setup default USB PLL state for a 480MHz output and attach */
+	Chip_Clock_SetupPLL(CLKIN_CRYSTAL, CGU_USB_PLL, &usbPLLSetup);
+
+	/* enable USB PLL */
+	Chip_Clock_EnablePLL(CGU_USB_PLL);
+
+	/* Wait for PLL lock */
+	while (!(Chip_Clock_GetPLLStatus(CGU_USB_PLL) & CGU_PLL_LOCKED)) {}
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+void Chip_USB0_Init(void)
+{
+	/* Set up USB PLL */
+	Chip_USB_PllSetup();
+
+	/* Setup USB0 base clock as clock out from USB PLL */
+	Chip_Clock_SetBaseClock( CLK_BASE_USB0, CLKIN_USBPLL, true, true);
+
+	/* enable USB main clock */
+	Chip_Clock_EnableBaseClock(CLK_BASE_USB0);
+	Chip_Clock_EnableOpts(CLK_MX_USB0, true, true, 1);
+	/* enable USB0 phy */
+	Chip_CREG_EnableUSB0Phy();
+}
+
+void Chip_USB1_Init(void)
+{
+	/* Setup and enable the PLL */
+	Chip_USB_PllSetup();
+
+	/* USB1 needs a 60MHz clock. To get it, a divider of 4 and then 2 are
+	   chained to make a divide by 8 function. Connect the output of
+	   divider D to the USB1 base clock. */
+	Chip_Clock_SetDivider(CLK_IDIV_A, CLKIN_USBPLL, 4);
+	Chip_Clock_SetDivider(CLK_IDIV_D, CLKIN_IDIVA, 2);
+	Chip_Clock_SetBaseClock(CLK_BASE_USB1, CLKIN_IDIVD, true, true);
+
+	/* enable USB main clock */
+	Chip_Clock_EnableBaseClock(CLK_BASE_USB1);
+	Chip_Clock_EnableOpts(CLK_MX_USB1, true, true, 1);
+	/* enable USB1_DP and USB1_DN on chip FS phy.*/
+	LPC_SCU->SFSUSB = 0x12;
+}
+
+
+/* Update system core clock rate, should be called if the system has
+   a clock rate change */
+void SystemCoreClockUpdate(void)
+{
+	/* CPU core speed */
+	SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/clock_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/clock_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/clock_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/clock_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,832 @@
+/*
+ * @brief LPC18xx/43xx clock driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Maps a peripheral clock to it's base clock */
+typedef struct {
+	CHIP_CCU_CLK_T clkstart;
+	CHIP_CCU_CLK_T clkend;
+	CHIP_CGU_BASE_CLK_T clkbase;
+} CLK_PERIPH_TO_BASE_T;
+static const CLK_PERIPH_TO_BASE_T periph_to_base[] = {
+	{CLK_APB3_BUS, CLK_APB3_CAN0, CLK_BASE_APB3},
+	{CLK_APB1_BUS, CLK_APB1_CAN1, CLK_BASE_APB1},
+	{CLK_SPIFI, CLK_SPIFI, CLK_BASE_SPIFI},
+	{CLK_MX_BUS, CLK_MX_QEI, CLK_BASE_MX},
+#if defined(CHIP_LPC43XX)
+	{CLK_PERIPH_BUS, CLK_PERIPH_SGPIO, CLK_BASE_PERIPH},
+#endif
+	{CLK_USB0, CLK_USB0, CLK_BASE_USB0},
+	{CLK_USB1, CLK_USB1, CLK_BASE_USB1},
+#if defined(CHIP_LPC43XX)
+	{CLK_SPI, CLK_SPI, CLK_BASE_SPI},
+	{CLK_ADCHS, CLK_ADCHS, CLK_BASE_ADCHS},
+#endif
+	{CLK_APLL, CLK_APLL, CLK_BASE_APLL},
+	{CLK_APB2_UART3, CLK_APB2_UART3, CLK_BASE_UART3},
+	{CLK_APB2_UART2, CLK_APB2_UART2, CLK_BASE_UART2},
+	{CLK_APB0_UART1, CLK_APB0_UART1, CLK_BASE_UART1},
+	{CLK_APB0_UART0, CLK_APB0_UART0, CLK_BASE_UART0},
+	{CLK_APB2_SSP1, CLK_APB2_SSP1, CLK_BASE_SSP1},
+	{CLK_APB0_SSP0, CLK_APB0_SSP0, CLK_BASE_SSP0},
+	{CLK_APB2_SDIO, CLK_APB2_SDIO, CLK_BASE_SDIO},
+	{CLK_CCU2_LAST, CLK_CCU2_LAST, CLK_BASE_NONE}
+};
+
+#define CRYSTAL_32K_FREQ_IN    (32 * 1024)
+
+/* Variables to use audio and usb pll frequency */
+static uint32_t audio_usb_pll_freq[CGU_AUDIO_PLL+1];
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+__STATIC_INLINE uint32_t ABS(int val)
+{
+	if (val < 0)
+		return -val;
+	return val;
+}
+
+static void pll_calc_divs(uint32_t freq, PLL_PARAM_T *ppll)
+{
+
+	uint32_t prev = freq;
+	int n, m, p;
+
+	/* When direct mode is set FBSEL should be a don't care */
+	if (ppll->ctrl & (1 << 7)) {
+		ppll->ctrl &= ~(1 << 6);
+	}
+	for (n = 1; n <= 4; n++) {
+		for (p = 0; p < 4; p ++) {
+			for (m = 1; m <= 256; m++) {
+				uint32_t fcco, fout;
+				if (ppll->ctrl & (1 << 6)) {
+					fcco = ((m << (p + 1)) * ppll->fin) / n;
+				} else {
+					fcco = (m * ppll->fin) / n;
+				}
+				if (fcco < PLL_MIN_CCO_FREQ) continue;
+				if (fcco > PLL_MAX_CCO_FREQ) break;
+				if (ppll->ctrl & (1 << 7)) {
+					fout = fcco;
+				} else {
+					fout = fcco >> (p + 1);
+				}
+
+				if (ABS(freq - fout) < prev) {
+					ppll->nsel = n;
+					ppll->psel = p + 1;
+					ppll->msel = m;
+					ppll->fout = fout;
+					ppll->fcco = fcco;
+					prev = ABS(freq - fout);
+				}
+			}
+		}
+	}
+}
+
+static void pll_get_frac(uint32_t freq, PLL_PARAM_T *ppll)
+{
+	int diff[3];
+	PLL_PARAM_T pll[3] = {{0},{0},{0}};
+
+	/* Try direct mode */
+	pll[0].ctrl |= (1 << 7);
+	pll[0].fin = ppll->fin;
+	pll[0].srcin = ppll->srcin;
+	pll_calc_divs(freq, &pll[0]);
+	if (pll[0].fout == freq) {
+		*ppll = pll[0];
+		return ;
+	}
+	diff[0] = ABS(freq - pll[0].fout);
+
+	/* Try non-Integer mode */
+	pll[2].ctrl &= ~(1 << 6);			// need to set FBSEL to 0
+	pll[2].fin = ppll->fin;
+	pll[2].srcin = ppll->srcin;
+	pll_calc_divs(freq, &pll[2]);
+	if (pll[2].fout == freq) {
+		*ppll = pll[2];
+		return ;
+	}
+	diff[2] = ABS(freq - pll[2].fout);
+	
+	if (freq <= 110000000) {
+		/* Try integer mode */
+		pll[1].ctrl = (1 << 6);
+		pll[1].fin = ppll->fin;
+		pll_calc_divs(freq, &pll[1]);
+		if (pll[1].fout == freq) {
+			*ppll = pll[1];
+			return ;
+		}
+	}
+	diff[1] = ABS(freq - pll[1].fout);
+
+	/* Find the min of 3 and return */
+	if (diff[0] <= diff[1]) {
+		if (diff[0] <= diff[2]) {
+			*ppll = pll[0];
+		} else {
+			*ppll = pll[2];
+		}
+	} else {
+		if (diff[1] <= diff[2]) {
+			*ppll = pll[1];
+		} else {
+			*ppll = pll[2];
+		}
+	}
+}
+
+/* Test PLL input values for a specific frequency range */
+static uint32_t Chip_Clock_TestMainPLLMultiplier(uint32_t InputHz, uint32_t TestMult, uint32_t MinHz, uint32_t MaxHz)
+{
+	uint32_t TestHz = TestMult * InputHz;
+
+	if ((TestHz < MinHz) || (TestHz > MAX_CLOCK_FREQ) || (TestHz > MaxHz)) {
+		TestHz = 0;
+	}
+
+	return TestHz;
+}
+
+/* Returns clock rate out of a divider */
+static uint32_t Chip_Clock_GetDivRate(CHIP_CGU_CLKIN_T clock, CHIP_CGU_IDIV_T divider)
+{
+	CHIP_CGU_CLKIN_T input;
+	uint32_t div;
+
+	input = Chip_Clock_GetDividerSource(divider);
+	div = Chip_Clock_GetDividerDivisor(divider);
+	return Chip_Clock_GetClockInputHz(input) / (div + 1);
+}
+
+/* Finds the base clock for the peripheral clock */
+static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
+{
+	CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
+	int i = 0;
+
+	while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
+		if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
+			baseclk = periph_to_base[i].clkbase;
+		}
+		else {
+			i++;
+		}
+	}
+
+	return baseclk;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Enables the crystal oscillator */
+void Chip_Clock_EnableCrystal(void)
+{
+	volatile uint32_t delay = 1000;
+
+	uint32_t OldCrystalConfig = LPC_CGU->XTAL_OSC_CTRL;
+
+	/* Clear bypass mode */
+	OldCrystalConfig &= (~2);
+	if (OldCrystalConfig != LPC_CGU->XTAL_OSC_CTRL) {
+		LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
+	}
+
+	/* Enable crystal oscillator */
+	OldCrystalConfig &= (~1);
+	if (OscRateIn >= 20000000) {
+		OldCrystalConfig |= 4;	/* Set high frequency mode */
+
+	}
+	LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
+
+	/* Delay for 250uSec */
+	while(delay--) {}
+}
+
+/* Calculate the Main PLL div values */
+int Chip_Clock_CalcMainPLLValue(uint32_t freq, PLL_PARAM_T *ppll)
+{
+	ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);
+
+	/* Do sanity check on frequency */
+	if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
+		return -1;
+	}
+
+	ppll->ctrl = 1 << 7; /* Enable direct mode [If possible] */
+	ppll->nsel = 0;
+	ppll->psel = 0;
+	ppll->msel = freq / ppll->fin;
+
+	if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
+		pll_get_frac(freq, ppll);
+		if (!ppll->nsel) {
+			return -1;
+		}
+		ppll->nsel --;
+	}
+
+	if (ppll->msel == 0) {
+		return - 1;
+	}
+
+	if (ppll->psel) {
+		ppll->psel --;
+	}
+
+	ppll->msel --;
+
+	return 0;
+}
+
+/* Disables the crystal oscillator */
+void Chip_Clock_DisableCrystal(void)
+{
+	/* Disable crystal oscillator */
+	LPC_CGU->XTAL_OSC_CTRL |= 1;
+}
+
+/* Configures the main PLL */
+uint32_t Chip_Clock_SetupMainPLLHz(CHIP_CGU_CLKIN_T Input, uint32_t MinHz, uint32_t DesiredHz, uint32_t MaxHz)
+{
+	uint32_t freqin = Chip_Clock_GetClockInputHz(Input);
+	uint32_t Mult, LastMult, MultEnd;
+	uint32_t freqout, freqout2;
+
+	if (DesiredHz != 0xFFFFFFFF) {
+		/* Test DesiredHz rounded down */
+		Mult = DesiredHz / freqin;
+		freqout = Chip_Clock_TestMainPLLMultiplier(freqin, Mult, MinHz, MaxHz);
+
+		/* Test DesiredHz rounded up */
+		Mult++;
+		freqout2 = Chip_Clock_TestMainPLLMultiplier(freqin, Mult, MinHz, MaxHz);
+
+		if (freqout && !freqout2) {	/* rounding up is no good? set first multiplier */
+			Mult--;
+			return Chip_Clock_SetupMainPLLMult(Input, Mult);
+		}
+		if (!freqout && freqout2) {	/* didn't work until rounded up? set 2nd multiplier */
+			return Chip_Clock_SetupMainPLLMult(Input, Mult);
+		}
+
+		if (freqout && freqout2) {	/* either multiplier okay? choose closer one */
+			if ((DesiredHz - freqout) > (freqout2 - DesiredHz)) {
+				Mult--;
+				return Chip_Clock_SetupMainPLLMult(Input, Mult);
+			}
+			else {
+				return Chip_Clock_SetupMainPLLMult(Input, Mult);
+			}
+		}
+	}
+
+	/* Neither multiplier okay? Try to start at MinHz and increment.
+	   This should find the highest multiplier that is still good */
+	Mult = MinHz / freqin;
+	MultEnd = MaxHz / freqin;
+	LastMult = 0;
+	while (1) {
+		freqout = Chip_Clock_TestMainPLLMultiplier(freqin, Mult, MinHz, MaxHz);
+
+		if (freqout) {
+			LastMult = Mult;
+		}
+
+		if (Mult >= MultEnd) {
+			break;
+		}
+		Mult++;
+	}
+
+	if (LastMult) {
+		return Chip_Clock_SetupMainPLLMult(Input, LastMult);
+	}
+
+	return 0;
+}
+
+/* Directly set the PLL multipler */
+uint32_t Chip_Clock_SetupMainPLLMult(CHIP_CGU_CLKIN_T Input, uint32_t mult)
+{
+	volatile uint32_t delay = 250;
+	uint32_t freq = Chip_Clock_GetClockInputHz(Input);
+	uint32_t msel = 0, nsel = 0, psel = 0, pval = 1;
+	uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
+
+	freq *= mult;
+	msel = mult - 1;
+
+	PLLReg &= ~(0x1F << 24);/* clear input source bits */
+	PLLReg |= Input << 24;	/* set input source bits to parameter */
+
+	/* Clear other PLL input bits */
+	PLLReg &= ~((1 << 6) |	/* FBSEL */
+				(1 << 1) |	/* BYPASS */
+				(1 << 7) |	/* DIRECT */
+				(0x03 << 8) | (0xFF << 16) | (0x03 << 12));	/* PSEL, MSEL, NSEL- divider ratios */
+	
+	PLLReg |= (1 << 11);		/* AUTOBLOCK */
+
+	if (freq < 156000000) {
+		/* psel is encoded such that 0=1, 1=2, 2=4, 3=8 */
+		while ((2 * (pval) * freq) < 156000000) {
+			psel++;
+			pval *= 2;
+		}
+
+		PLLReg |= (msel << 16) | (nsel << 12) | (psel << 8) | (1 << 6);	/* dividers + FBSEL */
+	}
+	else if (freq < 320000000) {
+		PLLReg |= (msel << 16) | (nsel << 12) | (psel << 8) | (1 << 7) | (1 << 6);	/* dividers + DIRECT + FBSEL */
+	}
+	else {
+		Chip_Clock_DisableMainPLL();
+		return 0;
+	}
+	LPC_CGU->PLL1_CTRL = PLLReg & ~(1 << 0);
+
+	/* Wait for 50uSec */
+	while(delay--) {}
+
+	return freq;
+}
+
+/* Returns the frequency of the main PLL */
+uint32_t Chip_Clock_GetMainPLLHz(void)
+{
+	uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
+	uint32_t freq = Chip_Clock_GetClockInputHz((CHIP_CGU_CLKIN_T) ((PLLReg >> 24) & 0xF));
+	uint32_t msel, nsel, psel, direct, fbsel;
+	uint32_t m, n, p;
+	const uint8_t ptab[] = {1, 2, 4, 8};
+
+	/* No lock? */
+	if (!(LPC_CGU->PLL1_STAT & 1)) {
+		return 0;
+	}
+
+	msel = (PLLReg >> 16) & 0xFF;
+	nsel = (PLLReg >> 12) & 0x3;
+	psel = (PLLReg >> 8) & 0x3;
+	direct = (PLLReg >> 7) & 0x1;
+	fbsel = (PLLReg >> 6) & 0x1;
+
+	m = msel + 1;
+	n = nsel + 1;
+	p = ptab[psel];
+
+	if (direct || fbsel) {
+		return m * (freq / n);
+	}
+
+	return (m / (2 * p)) * (freq / n);
+}
+
+/* Sets up a CGU clock divider and it's input clock */
+void Chip_Clock_SetDivider(CHIP_CGU_IDIV_T Divider, CHIP_CGU_CLKIN_T Input, uint32_t Divisor)
+{
+	uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
+
+	Divisor--;
+
+	if (Input != CLKINPUT_PD) {
+		/* Mask off bits that need to changes */
+		reg &= ~((0x1F << 24) | 1 | (CHIP_CGU_IDIV_MASK(Divider) << 2));
+
+		/* Enable autoblocking, clear PD, and set clock source & divisor */
+		LPC_CGU->IDIV_CTRL[Divider] = reg | (1 << 11) | (Input << 24) | (Divisor << 2);
+	}
+	else {
+		LPC_CGU->IDIV_CTRL[Divider] = reg | 1;	/* Power down this divider */
+	}
+}
+
+/* Gets a CGU clock divider source */
+CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
+{
+	uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
+
+	if (reg & 1) {	/* divider is powered down */
+		return CLKINPUT_PD;
+	}
+
+	return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
+}
+
+/* Gets a CGU clock divider divisor */
+uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider)
+{
+	return (CHIP_CGU_CLKIN_T) ((LPC_CGU->IDIV_CTRL[Divider] >> 2) & CHIP_CGU_IDIV_MASK(Divider));
+}
+
+/* Returns the frequency of the specified input clock source */
+uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
+{
+	uint32_t rate = 0;
+
+	switch (input) {
+	case CLKIN_32K:
+		rate = CRYSTAL_32K_FREQ_IN;
+		break;
+
+	case CLKIN_IRC:
+		rate = CGU_IRC_FREQ;
+		break;
+
+	case CLKIN_ENET_RX:
+		if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
+			/* MII mode requires 25MHz clock */
+			rate = 25000000;
+		}
+		break;
+
+	case CLKIN_ENET_TX:
+		if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
+			rate = 25000000; /* MII uses 25 MHz */
+		} else {
+			rate = 50000000; /* RMII uses 50 MHz */
+		}
+		break;
+
+	case CLKIN_CLKIN:
+		rate = ExtRateIn;
+		break;
+
+	case CLKIN_CRYSTAL:
+		rate = OscRateIn;
+		break;
+
+	case CLKIN_USBPLL:
+		rate = audio_usb_pll_freq[CGU_USB_PLL];
+		break;
+
+	case CLKIN_AUDIOPLL:
+		rate = audio_usb_pll_freq[CGU_AUDIO_PLL];
+		break;
+
+	case CLKIN_MAINPLL:
+		rate = Chip_Clock_GetMainPLLHz();
+		break;
+
+	case CLKIN_IDIVA:
+		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_A);
+		break;
+
+	case CLKIN_IDIVB:
+		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_B);
+		break;
+
+	case CLKIN_IDIVC:
+		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_C);
+		break;
+
+	case CLKIN_IDIVD:
+		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_D);
+		break;
+
+	case CLKIN_IDIVE:
+		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_E);
+		break;
+
+	case CLKINPUT_PD:
+		rate = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return rate;
+}
+
+/* Returns the frequency of the specified base clock source */
+uint32_t Chip_Clock_GetBaseClocktHz(CHIP_CGU_BASE_CLK_T clock)
+{
+	return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
+}
+
+/* Sets a CGU Base Clock clock source */
+void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn)
+{
+	uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
+
+	if (BaseClock < CLK_BASE_NONE) {
+		if (Input != CLKINPUT_PD) {
+			/* Mask off fields we plan to update */
+			reg &= ~((0x1F << 24) | 1 | (1 << 11));
+
+			if (autoblocken) {
+				reg |= (1 << 11);
+			}
+			if (powerdn) {
+				reg |= (1 << 0);
+			}
+
+			/* Set clock source */
+			reg |= (Input << 24);
+
+			LPC_CGU->BASE_CLK[BaseClock] = reg;
+		}
+	}
+	else {
+		LPC_CGU->BASE_CLK[BaseClock] = reg | 1;	/* Power down this base clock */
+	}
+}
+
+/* Reads CGU Base Clock clock source information */
+void Chip_Clock_GetBaseClockOpts(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T *Input, bool *autoblocken,
+								 bool *powerdn)
+{
+	uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
+	CHIP_CGU_CLKIN_T ClkIn = (CHIP_CGU_CLKIN_T) ((reg  >> 24) & 0x1F );
+
+	if (BaseClock < CLK_BASE_NONE) {
+		/* Get settings */
+		*Input = ClkIn;
+		*autoblocken = (reg & (1 << 11)) ? true : false;
+		*powerdn = (reg & (1 << 0)) ? true : false;
+	}
+	else {
+		*Input = CLKINPUT_PD;
+		*powerdn = true;
+		*autoblocken = true;
+	}
+}
+
+/*Enables a base clock source */
+void Chip_Clock_EnableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+	if (BaseClock < CLK_BASE_NONE) {
+		LPC_CGU->BASE_CLK[BaseClock] &= ~1;
+	}
+}
+
+/* Disables a base clock source */
+void Chip_Clock_DisableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+	if (BaseClock < CLK_BASE_NONE) {
+		LPC_CGU->BASE_CLK[BaseClock] |= 1;
+	}
+}
+
+/* Returns base clock enable state */
+bool Chip_Clock_IsBaseClockEnabled(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+	bool enabled;
+
+	if (BaseClock < CLK_BASE_NONE) {
+		enabled = (bool) ((LPC_CGU->BASE_CLK[BaseClock] & 1) == 0);
+	}
+	else {
+		enabled = false;
+	}
+
+	return enabled;
+}
+
+/* Gets a CGU Base Clock clock source */
+CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
+{
+	uint32_t reg;
+
+	if (BaseClock >= CLK_BASE_NONE) {
+		return CLKINPUT_PD;
+	}
+
+	reg = LPC_CGU->BASE_CLK[BaseClock];
+
+	/* base clock is powered down? */
+	if (reg & 1) {
+		return CLKINPUT_PD;
+	}
+
+	return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
+}
+
+/* Enables a peripheral clock and sets clock states */
+void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
+{
+	uint32_t reg = 1;
+
+	if (autoen) {
+		reg |= (1 << 1);
+	}
+	if (wakeupen) {
+		reg |= (1 << 2);
+	}
+
+	/* Not all clocks support a divider, but we won't check that here. Only
+	   dividers of 1 and 2 are allowed. Assume 1 if not 2 */
+	if (div == 2) {
+		reg |= (1 << 5);
+	}
+
+	/* Setup peripheral clock and start running */
+	if (clk >= CLK_CCU2_START) {
+		LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
+	}
+	else {
+		LPC_CCU1->CLKCCU[clk].CFG = reg;
+	}
+}
+
+/* Enables a peripheral clock */
+void Chip_Clock_Enable(CHIP_CCU_CLK_T clk)
+{
+	/* Start peripheral clock running */
+	if (clk >= CLK_CCU2_START) {
+		LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG |= 1;
+	}
+	else {
+		LPC_CCU1->CLKCCU[clk].CFG |= 1;
+	}
+}
+
+/* Enable RTC Clock */
+void Chip_Clock_RTCEnable(void)
+{
+	LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));	/* Reset 32Khz oscillator */
+	LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);	/* Enable 32 kHz & 1 kHz on osc32k and release reset */
+}
+
+/* Disables a peripheral clock */
+void Chip_Clock_Disable(CHIP_CCU_CLK_T clk)
+{
+	/* Stop peripheral clock */
+	if (clk >= CLK_CCU2_START) {
+		LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG &= ~1;
+	}
+	else {
+		LPC_CCU1->CLKCCU[clk].CFG &= ~1;
+	}
+}
+
+/**
+ * Disable all branch output clocks with wake up mechanism enabled.
+ * Only the clocks with wake up mechanism enabled will be disabled &
+ * power down sequence started
+ */
+void Chip_Clock_StartPowerDown(void)
+{
+	/* Set Power Down bit */
+	LPC_CCU1->PM = 1;
+	LPC_CCU2->PM = 1;
+}
+
+/**
+ * Enable all branch output clocks after the wake up event.
+ * Only the clocks with wake up mechanism enabled will be enabled
+ */
+void Chip_Clock_ClearPowerDown(void)
+{
+	/* Clear Power Down bit */
+	LPC_CCU1->PM = 0;
+	LPC_CCU2->PM = 0;
+}
+
+/* Returns a peripheral clock rate */
+uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk)
+{
+	CHIP_CGU_BASE_CLK_T baseclk;
+	uint32_t reg, div, rate;
+
+	/* Get CCU config register for clock */
+	if (clk >= CLK_CCU2_START) {
+		reg = LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG;
+	}
+	else {
+		reg = LPC_CCU1->CLKCCU[clk].CFG;
+	}
+
+	/* Is the clock enabled? */
+	if (reg & 1) {
+		/* Get base clock for this peripheral clock */
+		baseclk = Chip_Clock_FindBaseClock(clk);
+
+		/* Get base clock rate */
+		rate = Chip_Clock_GetBaseClocktHz(baseclk);
+
+		/* Get divider for this clock */
+		if (((reg >> 5) & 0x7) == 0) {
+			div = 1;
+		}
+		else {
+			div = 2;/* No other dividers supported */
+
+		}
+		rate = rate / div;
+	}
+	else {
+		rate = 0;
+	}
+
+	return rate;
+}
+
+/* Get EMC Clock Rate */
+uint32_t Chip_Clock_GetEMCRate(void)
+
+{
+	uint32_t ClkFreq;
+	uint32_t EMCDiv;
+	ClkFreq = Chip_Clock_GetRate(CLK_MX_EMC);
+
+	/* EMC Divider readback at pos 27
+	    TODO: just checked but dont mention in UM */
+	EMCDiv = (LPC_CCU1->CLKCCU[CLK_MX_EMC_DIV].CFG >> 27) & 0x07;
+
+	/* Check EMC Divider to get real EMC clock out */
+	if ((EMCDiv == 1) && (LPC_CREG->CREG6 & (1 << 16))) {
+		ClkFreq >>= 1;
+	}
+	return ClkFreq;
+}
+
+/* Sets up the audio or USB PLL */
+void Chip_Clock_SetupPLL(CHIP_CGU_CLKIN_T Input, CHIP_CGU_USB_AUDIO_PLL_T pllnum,
+						 const CGU_USBAUDIO_PLL_SETUP_T *pPLLSetup)
+{
+	uint32_t reg = pPLLSetup->ctrl | (Input << 24);
+
+	/* Setup from passed values */
+	LPC_CGU->PLL[pllnum].PLL_CTRL = reg;
+	LPC_CGU->PLL[pllnum].PLL_MDIV = pPLLSetup->mdiv;
+	LPC_CGU->PLL[pllnum].PLL_NP_DIV = pPLLSetup->ndiv;
+
+	/* Fractional divider is for audio PLL only */
+	if (pllnum == CGU_AUDIO_PLL) {
+		LPC_CGU->PLL0AUDIO_FRAC = pPLLSetup->fract;
+	}
+	audio_usb_pll_freq[pllnum] = pPLLSetup->freq;
+}
+
+/* Enables the audio or USB PLL */
+void Chip_Clock_EnablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
+{
+	LPC_CGU->PLL[pllnum].PLL_CTRL &= ~1;
+}
+
+/* Disables the audio or USB PLL */
+void Chip_Clock_DisablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
+{
+	LPC_CGU->PLL[pllnum].PLL_CTRL |= 1;
+}
+
+/* Returns the PLL status */
+uint32_t Chip_Clock_GetPLLStatus(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
+{
+	return LPC_CGU->PLL[pllnum].PLL_STAT;
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/dac_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/dac_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/dac_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/dac_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,91 @@
+/*
+ * @brief LPC18xx/43xx D/A conversion driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the DAC peripheral */
+void Chip_DAC_Init(LPC_DAC_T *pDAC)
+{
+	Chip_Clock_EnableOpts(CLK_APB3_DAC, true, true, 1);
+
+	/* Set maximum update rate 1MHz */
+	Chip_DAC_SetBias(pDAC, DAC_MAX_UPDATE_RATE_1MHz);
+}
+
+/* Shutdown DAC peripheral */
+void Chip_DAC_DeInit(LPC_DAC_T *pDAC)
+{
+	Chip_Clock_Disable(CLK_APB3_DAC);
+}
+
+/* Update value to DAC buffer*/
+void Chip_DAC_UpdateValue(LPC_DAC_T *pDAC, uint32_t dac_value)
+{
+	uint32_t tmp;
+
+	tmp = pDAC->CR & DAC_BIAS_EN;
+	tmp |= DAC_VALUE(dac_value);
+	/* Update value */
+	pDAC->CR = tmp;
+}
+
+/* Set Maximum update rate for DAC */
+void Chip_DAC_SetBias(LPC_DAC_T *pDAC, uint32_t bias)
+{
+	pDAC->CR &= ~DAC_BIAS_EN;
+
+	if (bias  == DAC_MAX_UPDATE_RATE_400kHz) {
+		pDAC->CR |= DAC_BIAS_EN;
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/eeprom_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/eeprom_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/eeprom_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/eeprom_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,106 @@
+/*
+ * @brief LPC18xx/43xx EEPROM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Setup EEPROM clock */
+STATIC void setClkDiv(LPC_EEPROM_T *pEEPROM)
+{
+	uint32_t clk;
+
+	/* Setup EEPROM timing to 375KHz based on PCLK rate */
+	clk = Chip_Clock_GetRate(CLK_MX_EEPROM);
+
+	/* Set EEPROM clock divide value*/
+	pEEPROM->CLKDIV = clk / EEPROM_CLOCK_DIV - 1;
+}
+
+/* Setup EEPROM clock */
+STATIC INLINE void setWaitState(LPC_EEPROM_T *pEEPROM)
+{
+	/* Setup EEPROM wait states*/
+	Chip_EEPROM_SetReadWaitState(pEEPROM, EEPROM_READ_WAIT_STATE_VAL);
+	Chip_EEPROM_SetWaitState(pEEPROM, EEPROM_WAIT_STATE_VAL);
+
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the EEPROM peripheral with specified parameter */
+void Chip_EEPROM_Init(LPC_EEPROM_T *pEEPROM)
+{
+	/* Disable EEPROM power down mode */
+	Chip_EEPROM_DisablePowerDown(pEEPROM);
+	setClkDiv(pEEPROM);
+	setWaitState(pEEPROM);
+}
+
+/* Write data from page register to non-volatile memory */
+void Chip_EEPROM_EraseProgramPage(LPC_EEPROM_T *pEEPROM)
+{
+	Chip_EEPROM_ClearIntStatus(pEEPROM, EEPROM_CMD_ERASE_PRG_PAGE);
+	Chip_EEPROM_SetCmd(pEEPROM, EEPROM_CMD_ERASE_PRG_PAGE);
+	Chip_EEPROM_WaitForIntStatus(pEEPROM, EEPROM_INT_ENDOFPROG);
+}
+
+/* Wait for interrupt */
+void Chip_EEPROM_WaitForIntStatus(LPC_EEPROM_T *pEEPROM, uint32_t mask)
+{
+	uint32_t status;
+	while (1) {
+		status = Chip_EEPROM_GetIntStatus(pEEPROM);
+		if ((status & mask) == mask) {
+			break;
+		}
+	}
+	Chip_EEPROM_ClearIntStatus(pEEPROM, mask);
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/emc_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/emc_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/emc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/emc_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,295 @@
+/*
+ * @brief LPC18xx/43xx EMC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* DIV function with result rounded up */
+#define EMC_DIV_ROUND_UP(x, y)  ((x + y - 1) / y)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+#ifndef EMC_SUPPORT_ONLY_PL172
+/* Get ARM External Memory Controller Version */
+STATIC uint32_t getARMPeripheralID(void)
+{
+	uint32_t *RegAdd;
+	RegAdd = (uint32_t *) ((uint32_t) LPC_EMC + 0xFE0);
+	return (RegAdd[0] & 0xFF) | ((RegAdd[1] & 0xFF) << 8) |
+		   ((RegAdd[2] & 0xFF) << 16) | (RegAdd[3] << 24);
+}
+
+#endif
+
+/* Calculate Clock Count from Timing Unit(nanoseconds) */
+STATIC uint32_t convertTimmingParam(uint32_t EMC_Clock, int32_t input_ns, uint32_t adjust)
+{
+	uint32_t temp;
+	if (input_ns < 0) {
+		return (-input_ns) >> 8;
+	}
+	temp = EMC_Clock / 1000000;		/* MHz calculation */
+	temp = temp * input_ns / 1000;
+
+	/* round up */
+	temp += 0xFF;
+
+	/* convert to simple integer number format */
+	temp >>= 8;
+	if (temp > adjust) {
+		return temp - adjust;
+	}
+
+	return 0;
+}
+
+/* Get Dynamic Memory Device Colum len */
+STATIC uint32_t getColsLen(uint32_t DynConfig)
+{
+	uint32_t DevBusWidth;
+	DevBusWidth = (DynConfig >> EMC_DYN_CONFIG_DEV_BUS_BIT) & 0x03;
+	if (DevBusWidth == 2) {
+		return 8;
+	}
+	else if (DevBusWidth == 1) {
+		return ((DynConfig >> (EMC_DYN_CONFIG_DEV_SIZE_BIT + 1)) & 0x03) + 8;
+	}
+	else if (DevBusWidth == 0) {
+		return ((DynConfig >> (EMC_DYN_CONFIG_DEV_SIZE_BIT + 1)) & 0x03) + 9;
+	}
+
+	return 0;
+}
+
+/* Initializes the Dynamic Controller according to the specified parameters
+   in the IP_EMC_DYN_CONFIG_T */
+void initDynMem(LPC_EMC_T *pEMC, IP_EMC_DYN_CONFIG_T *Dynamic_Config, uint32_t EMC_Clock)
+{
+	uint32_t ChipSelect, tmpclk;
+	volatile int i;
+
+	for (ChipSelect = 0; ChipSelect < 4; ChipSelect++) {
+		LPC_EMC_T *EMC_Reg_add = (LPC_EMC_T *) ((uint32_t) pEMC + (ChipSelect << 5));
+
+		EMC_Reg_add->DYNAMICRASCAS0    = Dynamic_Config->DevConfig[ChipSelect].RAS |
+										 ((Dynamic_Config->DevConfig[ChipSelect].ModeRegister <<
+										   (8 - EMC_DYN_MODE_CAS_BIT)) & 0xF00);
+		EMC_Reg_add->DYNAMICCONFIG0    = Dynamic_Config->DevConfig[ChipSelect].DynConfig;
+	}
+	pEMC->DYNAMICREADCONFIG = Dynamic_Config->ReadConfig;	/* Read strategy */
+
+	pEMC->DYNAMICRP         = convertTimmingParam(EMC_Clock, Dynamic_Config->tRP, 1);
+	pEMC->DYNAMICRAS        = convertTimmingParam(EMC_Clock, Dynamic_Config->tRAS, 1);
+	pEMC->DYNAMICSREX       = convertTimmingParam(EMC_Clock, Dynamic_Config->tSREX, 1);
+	pEMC->DYNAMICAPR        = convertTimmingParam(EMC_Clock, Dynamic_Config->tAPR, 1);
+	pEMC->DYNAMICDAL        = convertTimmingParam(EMC_Clock, Dynamic_Config->tDAL, 0);
+	pEMC->DYNAMICWR         = convertTimmingParam(EMC_Clock, Dynamic_Config->tWR, 1);
+	pEMC->DYNAMICRC         = convertTimmingParam(EMC_Clock, Dynamic_Config->tRC, 1);
+	pEMC->DYNAMICRFC        = convertTimmingParam(EMC_Clock, Dynamic_Config->tRFC, 1);
+	pEMC->DYNAMICXSR        = convertTimmingParam(EMC_Clock, Dynamic_Config->tXSR, 1);
+	pEMC->DYNAMICRRD        = convertTimmingParam(EMC_Clock, Dynamic_Config->tRRD, 1);
+	pEMC->DYNAMICMRD        = convertTimmingParam(EMC_Clock, Dynamic_Config->tMRD, 1);
+
+	for (i = 0; i < 1000; i++) {	/* wait 100us */
+	}
+	pEMC->DYNAMICCONTROL    = 0x00000183;	/* Issue NOP command */
+
+	for (i = 0; i < 1000; i++) {}
+	pEMC->DYNAMICCONTROL    = 0x00000103;	/* Issue PALL command */
+
+	pEMC->DYNAMICREFRESH = 2;	/* ( 2 * 16 ) -> 32 clock cycles */
+
+	for (i = 0; i < 80; i++) {}
+
+	tmpclk = EMC_DIV_ROUND_UP(convertTimmingParam(EMC_Clock, Dynamic_Config->RefreshPeriod, 0), 16);
+	pEMC->DYNAMICREFRESH    = tmpclk;
+
+	pEMC->DYNAMICCONTROL    = 0x00000083;	/* Issue MODE command */
+
+	for (ChipSelect = 0; ChipSelect < 4; ChipSelect++) {
+		/*uint32_t burst_length;*/
+		uint32_t DynAddr;
+		uint8_t Col_len;
+
+		Col_len = getColsLen(Dynamic_Config->DevConfig[ChipSelect].DynConfig);
+		/* get bus wide: if 32bit, len is 4 else if 16bit len is 2 */
+		/* burst_length = 1 << ((((Dynamic_Config->DynConfig[ChipSelect] >> 14) & 1)^1) +1); */
+		if (Dynamic_Config->DevConfig[ChipSelect].DynConfig & (1 << EMC_DYN_CONFIG_DATA_BUS_WIDTH_BIT)) {
+			/*32bit bus */
+			/*burst_length = 2;*/
+			Col_len += 2;
+		}
+		else {
+			/*burst_length = 4;*/
+			Col_len += 1;
+		}
+
+		/* Check for RBC mode */
+		if (!(Dynamic_Config->DevConfig[ChipSelect].DynConfig & EMC_DYN_CONFIG_LPSDRAM)) {
+			if (!(Dynamic_Config->DevConfig[ChipSelect].DynConfig & (0x7 << EMC_DYN_CONFIG_DEV_SIZE_BIT))) {
+				/* 2 banks => 1 bank select bit */
+				Col_len += 1;
+			}
+			else {
+				/* 4 banks => 2 bank select bits */
+				Col_len += 2;
+			}
+		}
+
+		DynAddr = Dynamic_Config->DevConfig[ChipSelect].BaseAddr;
+
+
+		if (DynAddr != 0) {
+			uint32_t temp;
+			uint32_t ModeRegister;
+			ModeRegister = Dynamic_Config->DevConfig[ChipSelect].ModeRegister;
+			temp = *((volatile uint32_t *) (DynAddr | (ModeRegister << Col_len)));
+			temp = temp;
+		}
+	}
+	pEMC->DYNAMICCONTROL    = 0x00000000;	/* Issue NORMAL command */
+
+	/* enable buffers */
+	pEMC->DYNAMICCONFIG0    |= 1 << 19;
+	pEMC->DYNAMICCONFIG1    |= 1 << 19;
+	pEMC->DYNAMICCONFIG2    |= 1 << 19;
+	pEMC->DYNAMICCONFIG3    |= 1 << 19;
+}
+
+/* Initializes the Static Controller according to the specified parameters
+ * in the IP_EMC_STATIC_CONFIG_T
+ */
+void initStaticMem(LPC_EMC_T *pEMC, IP_EMC_STATIC_CONFIG_T *Static_Config, uint32_t EMC_Clock)
+{
+	LPC_EMC_T *EMC_Reg_add = (LPC_EMC_T *) ((uint32_t) pEMC + ((Static_Config->ChipSelect) << 5));
+	EMC_Reg_add->STATICCONFIG0      = Static_Config->Config;
+	EMC_Reg_add->STATICWAITWEN0     = convertTimmingParam(EMC_Clock, Static_Config->WaitWen, 1);
+	EMC_Reg_add->STATICWAITOEN0     = convertTimmingParam(EMC_Clock, Static_Config->WaitOen, 0);
+	EMC_Reg_add->STATICWAITRD0      = convertTimmingParam(EMC_Clock, Static_Config->WaitRd, 1);
+	EMC_Reg_add->STATICWAITPAG0     = convertTimmingParam(EMC_Clock, Static_Config->WaitPage, 1);
+	EMC_Reg_add->STATICWAITWR0      = convertTimmingParam(EMC_Clock, Static_Config->WaitWr, 2);
+	EMC_Reg_add->STATICWAITTURN0    = convertTimmingParam(EMC_Clock, Static_Config->WaitTurn, 1);
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Dyanmic memory setup */
+void Chip_EMC_Dynamic_Init(IP_EMC_DYN_CONFIG_T *Dynamic_Config)
+{
+	uint32_t ClkFreq;
+
+	/* Note clocks must be enabled prior to this call */
+	ClkFreq = Chip_Clock_GetEMCRate();
+
+	initDynMem(LPC_EMC, Dynamic_Config, ClkFreq);
+}
+
+/* Enable Dynamic Memory Controller */
+void Chip_EMC_Dynamic_Enable(uint8_t Enable)
+{
+	if (Enable) {
+		LPC_EMC->DYNAMICCONTROL |= EMC_DYN_CONTROL_ENABLE;
+	}
+	else {
+		LPC_EMC->DYNAMICCONTROL &= ~EMC_DYN_CONTROL_ENABLE;
+	}
+}
+
+/* Static memory setup */
+void Chip_EMC_Static_Init(IP_EMC_STATIC_CONFIG_T *Static_Config)
+{
+	uint32_t ClkFreq;
+
+	/* Note clocks must be enabled prior to this call */
+	ClkFreq = Chip_Clock_GetEMCRate();
+
+	initStaticMem(LPC_EMC, Static_Config, ClkFreq);
+}
+
+/* Mirror CS1 to CS0 and DYCS0 */
+void Chip_EMC_Mirror(uint8_t Enable)
+{
+	if (Enable) {
+		LPC_EMC->CONTROL |= 1 << 1;
+	}
+	else {
+		LPC_EMC->CONTROL &= ~(1 << 1);
+	}
+}
+
+/* Enable EMC */
+void Chip_EMC_Enable(uint8_t Enable)
+{
+	if (Enable) {
+		LPC_EMC->CONTROL |= 1;
+	}
+	else {
+		LPC_EMC->CONTROL &= ~(1);
+	}
+}
+
+/* Set EMC LowPower Mode */
+void Chip_EMC_LowPowerMode(uint8_t Enable)
+{
+	if (Enable) {
+		LPC_EMC->CONTROL |= 1 << 2;
+	}
+	else {
+		LPC_EMC->CONTROL &= ~(1 << 2);
+	}
+}
+
+/* Initialize EMC */
+void Chip_EMC_Init(uint32_t Enable, uint32_t ClockRatio, uint32_t EndianMode)
+{
+	LPC_EMC->CONFIG    = (EndianMode ? 1 : 0) | ((ClockRatio ? 1 : 0) << 8);
+
+	/* Enable EMC 001 Normal Memory Map, No low power mode */
+	LPC_EMC->CONTROL     = (Enable ? 1 : 0);
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/enet_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/enet_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/enet_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/enet_18xx_43xx.c	2018-12-01 17:15:06.665606743 -0300
@@ -0,0 +1,188 @@
+/*
+ * @brief LPC18xx/43xx Ethernet driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Saved address for PHY and clock divider */
+STATIC uint32_t phyCfg;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+STATIC INLINE void reset(LPC_ENET_T *pENET)
+{
+    Chip_RGU_TriggerReset(RGU_ETHERNET_RST);
+	while (Chip_RGU_InReset(RGU_ETHERNET_RST))
+    {}
+
+	/* Reset ethernet peripheral */
+	Chip_ENET_Reset(pENET);
+}
+
+STATIC uint32_t Chip_ENET_CalcMDCClock(void)
+{
+	uint32_t val = SystemCoreClock / 1000000UL;
+
+	if (val >= 20 && val < 35)
+		return 2;
+	if (val >= 35 && val < 60)
+		return 3;
+	if (val >= 60 && val < 100)
+		return 0;
+	if (val >= 100 && val < 150)
+		return 1;
+	if (val >= 150 && val < 250)
+		return 4;
+	if (val >= 250 && val < 300)
+		return 5;
+
+	/* Code should never reach here
+	   unless there is BUG in frequency settings
+	*/
+	return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Basic Ethernet interface initialization */
+void Chip_ENET_Init(LPC_ENET_T *pENET, uint32_t phyAddr)
+{
+	Chip_Clock_EnableOpts(CLK_MX_ETHERNET, true, true, 1);
+
+	reset(pENET);
+
+	/* Setup MII link divider to /102 and PHY address 1 */
+	Chip_ENET_SetupMII(pENET, Chip_ENET_CalcMDCClock(), phyAddr);
+
+	/* Enhanced descriptors, burst length = 1 */
+	pENET->DMA_BUS_MODE = DMA_BM_ATDS | DMA_BM_PBL(1) | DMA_BM_RPBL(1);
+
+	/* Initial MAC configuration for checksum offload, full duplex,
+	   100Mbps, disable receive own in half duplex, inter-frame gap
+	   of 64-bits */
+	pENET->MAC_CONFIG = MAC_CFG_BL(0) | MAC_CFG_IPC | MAC_CFG_DM |
+						MAC_CFG_DO | MAC_CFG_FES | MAC_CFG_PS | MAC_CFG_IFG(3);
+
+	/* Setup default filter */
+	pENET->MAC_FRAME_FILTER = MAC_FF_PR | MAC_FF_RA;
+
+	/* Flush transmit FIFO */
+	pENET->DMA_OP_MODE = DMA_OM_FTF;
+
+	/* Setup DMA to flush receive FIFOs at 32 bytes, service TX FIFOs at
+	   64 bytes */
+	pENET->DMA_OP_MODE |= DMA_OM_RTC(1) | DMA_OM_TTC(0);
+
+	/* Clear all MAC interrupts */
+	pENET->DMA_STAT = DMA_ST_ALL;
+
+	/* Enable MAC interrupts */
+	pENET->DMA_INT_EN = 0;
+}
+
+/* Ethernet interface shutdown */
+void Chip_ENET_DeInit(LPC_ENET_T *pENET)
+{
+	/* Disable packet reception */
+	pENET->MAC_CONFIG = 0;
+
+	/* Flush transmit FIFO */
+	pENET->DMA_OP_MODE = DMA_OM_FTF;
+
+	/* Disable receive and transmit DMA processes */
+	pENET->DMA_OP_MODE = 0;
+
+	Chip_Clock_Disable(CLK_MX_ETHERNET);
+}
+
+/* Sets up the PHY link clock divider and PHY address */
+void Chip_ENET_SetupMII(LPC_ENET_T *pENET, uint32_t div, uint8_t addr)
+{
+	/* Save clock divider and PHY address in MII address register */
+	phyCfg = MAC_MIIA_PA(addr) | MAC_MIIA_CR(div);
+}
+
+/* Starts a PHY write via the MII */
+void Chip_ENET_StartMIIWrite(LPC_ENET_T *pENET, uint8_t reg, uint16_t data)
+{
+	/* Write value at PHY address and register */
+	pENET->MAC_MII_ADDR = phyCfg | MAC_MIIA_GR(reg) | MAC_MIIA_W;
+	pENET->MAC_MII_DATA = (uint32_t) data;
+	pENET->MAC_MII_ADDR |= MAC_MIIA_GB;
+}
+
+/*Starts a PHY read via the MII */
+void Chip_ENET_StartMIIRead(LPC_ENET_T *pENET, uint8_t reg)
+{
+	/* Read value at PHY address and register */
+	pENET->MAC_MII_ADDR = phyCfg | MAC_MIIA_GR(reg);
+	pENET->MAC_MII_ADDR |= MAC_MIIA_GB;
+}
+
+/* Sets full or half duplex for the interface */
+void Chip_ENET_SetDuplex(LPC_ENET_T *pENET, bool full)
+{
+	if (full) {
+		pENET->MAC_CONFIG |= MAC_CFG_DM;
+	}
+	else {
+		pENET->MAC_CONFIG &= ~MAC_CFG_DM;
+	}
+}
+
+/* Sets speed for the interface */
+void Chip_ENET_SetSpeed(LPC_ENET_T *pENET, bool speed100)
+{
+	if (speed100) {
+		pENET->MAC_CONFIG |= MAC_CFG_FES;
+	}
+	else {
+		pENET->MAC_CONFIG &= ~MAC_CFG_FES;
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/evrt_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/evrt_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/evrt_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/evrt_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,117 @@
+/*
+ * @brief LPC18xx/43xx event router driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the EVRT */
+void Chip_EVRT_Init(void)
+{
+	uint8_t i = 0;
+	// Clear all register to be default
+	LPC_EVRT->HILO      = 0x0000;
+	LPC_EVRT->EDGE      = 0x0000;
+	LPC_EVRT->CLR_EN    = 0xFFFF;
+	do {
+		i++;
+		LPC_EVRT->CLR_STAT  = 0xFFFFF;
+	} while ((LPC_EVRT->STATUS != 0) && (i < 10));
+}
+
+/* Set up the type of interrupt type for a source to EVRT */
+void Chip_EVRT_ConfigIntSrcActiveType(CHIP_EVRT_SRC_T EVRT_Src, CHIP_EVRT_SRC_ACTIVE_T type)
+{
+	switch (type) {
+	case EVRT_SRC_ACTIVE_LOW_LEVEL:
+		LPC_EVRT->HILO &= ~(1 << (uint8_t) EVRT_Src);
+		LPC_EVRT->EDGE &= ~(1 << (uint8_t) EVRT_Src);
+		break;
+
+	case EVRT_SRC_ACTIVE_HIGH_LEVEL:
+		LPC_EVRT->HILO |= (1 << (uint8_t) EVRT_Src);
+		LPC_EVRT->EDGE &= ~(1 << (uint8_t) EVRT_Src);
+		break;
+
+	case EVRT_SRC_ACTIVE_FALLING_EDGE:
+		LPC_EVRT->HILO &= ~(1 << (uint8_t) EVRT_Src);
+		LPC_EVRT->EDGE |= (1 << (uint8_t) EVRT_Src);
+		break;
+
+	case EVRT_SRC_ACTIVE_RISING_EDGE:
+		LPC_EVRT->HILO |= (1 << (uint8_t) EVRT_Src);
+		LPC_EVRT->EDGE |= (1 << (uint8_t) EVRT_Src);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* Enable or disable interrupt sources to EVRT */
+void Chip_EVRT_SetUpIntSrc(CHIP_EVRT_SRC_T EVRT_Src, FunctionalState state)
+{
+	if (state == ENABLE) {
+		LPC_EVRT->SET_EN = (1 << (uint8_t) EVRT_Src);
+	}
+	else {
+		LPC_EVRT->CLR_EN = (1 << (uint8_t) EVRT_Src);
+	}
+}
+
+/* Check if a source is sending interrupt to EVRT */
+IntStatus Chip_EVRT_IsSourceInterrupting(CHIP_EVRT_SRC_T EVRT_Src)
+{
+	if (LPC_EVRT->STATUS & (1 << (uint8_t) EVRT_Src)) {
+		return SET;
+	}
+	else {return RESET; }
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/fpu_init.c ./libs/vendor_libs/lpc_chip_43xx/src/fpu_init.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/fpu_init.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/fpu_init.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,103 @@
+/*
+ * @brief FPU init code
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#if defined(CORE_M4)
+
+#include "sys_config.h"
+#include "cmsis.h"
+#include "stdint.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define LPC_CPACR           0xE000ED88
+
+#define SCB_MVFR0           0xE000EF40
+#define SCB_MVFR0_RESET     0x10110021
+
+#define SCB_MVFR1           0xE000EF44
+#define SCB_MVFR1_RESET     0x11000011
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Early initialization of the FPU */
+void fpuInit(void)
+{
+#if __FPU_PRESENT != 0
+	// from arm trm manual:
+	//                ; CPACR is located at address 0xE000ED88
+	//                LDR.W R0, =0xE000ED88
+	//                ; Read CPACR
+	//                LDR R1, [R0]
+	//                ; Set bits 20-23 to enable CP10 and CP11 coprocessors
+	//                ORR R1, R1, #(0xF << 20)
+	//                ; Write back the modified value to the CPACR
+	//                STR R1, [R0]
+
+	volatile uint32_t *regCpacr = (uint32_t *) LPC_CPACR;
+	volatile uint32_t *regMvfr0 = (uint32_t *) SCB_MVFR0;
+	volatile uint32_t *regMvfr1 = (uint32_t *) SCB_MVFR1;
+	volatile uint32_t Cpacr;
+	volatile uint32_t Mvfr0;
+	volatile uint32_t Mvfr1;
+	char vfpPresent = 0;
+
+	Mvfr0 = *regMvfr0;
+	Mvfr1 = *regMvfr1;
+
+	vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
+
+	if (vfpPresent) {
+		Cpacr = *regCpacr;
+		Cpacr |= (0xF << 20);
+		*regCpacr = Cpacr;	// enable CP10 and CP11 for full access
+	}
+#endif /* __FPU_PRESENT != 0 */
+}
+
+#endif /* defined(CORE_M4 */
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/gpdma_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/gpdma_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/gpdma_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/gpdma_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,752 @@
+/*
+ * @brief LPC18xx/43xx GPDMA driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Channel array to monitor free channel */
+static DMA_ChannelHandle_t ChannelHandlerArray[GPDMA_NUMBER_CHANNELS];
+
+/* Optimized Peripheral Source and Destination burst size (18xx,43xx) */
+static const uint8_t GPDMA_LUTPerBurst[] = {
+	GPDMA_BSIZE_4,	/* MEMORY             */
+	GPDMA_BSIZE_1,	/* MAT0.0             */
+	GPDMA_BSIZE_1,	/* UART0 Tx           */
+	GPDMA_BSIZE_1,	/* MAT0.1             */
+	GPDMA_BSIZE_1,	/* UART0 Rx           */
+	GPDMA_BSIZE_1,	/* MAT1.0             */
+	GPDMA_BSIZE_1,	/* UART1 Tx           */
+	GPDMA_BSIZE_1,	/* MAT1.1             */
+	GPDMA_BSIZE_1,	/* UART1 Rx           */
+	GPDMA_BSIZE_1,	/* MAT2.0             */
+	GPDMA_BSIZE_1,	/* UART2 Tx           */
+	GPDMA_BSIZE_1,	/* MAT2.1             */
+	GPDMA_BSIZE_1,	/* UART2 Rx           */
+	GPDMA_BSIZE_1,	/* MAT3.0             */
+	GPDMA_BSIZE_1,	/* UART3 Tx           */
+	0,				/* SCT timer channel 0*/
+	GPDMA_BSIZE_1,	/* MAT3.1             */
+	GPDMA_BSIZE_1,	/* UART3 Rx           */
+	0,				/* SCT timer channel 1*/
+	GPDMA_BSIZE_4,	/* SSP0 Rx            */
+	GPDMA_BSIZE_32,	/* I2S channel 0      */
+	GPDMA_BSIZE_4,	/* SSP0 Tx            */
+	GPDMA_BSIZE_32,	/* I2S channel 1      */
+	GPDMA_BSIZE_4,	/* SSP1 Rx            */
+	GPDMA_BSIZE_4,	/* SSP1 Tx            */
+	GPDMA_BSIZE_4,	/* ADC 0              */
+	GPDMA_BSIZE_4,	/* ADC 1              */
+	GPDMA_BSIZE_1,	/* DAC                */
+	GPDMA_BSIZE_32,	/* I2S channel 0      */
+	GPDMA_BSIZE_32	/* I2S channel 0      */
+};
+
+/* Optimized Peripheral Source and Destination transfer width (18xx,43xx) */
+static const uint8_t GPDMA_LUTPerWid[] = {
+	GPDMA_WIDTH_WORD,	/* MEMORY             */
+	GPDMA_WIDTH_WORD,	/* MAT0.0             */
+	GPDMA_WIDTH_BYTE,	/* UART0 Tx           */
+	GPDMA_WIDTH_WORD,	/* MAT0.1             */
+	GPDMA_WIDTH_BYTE,	/* UART0 Rx           */
+	GPDMA_WIDTH_WORD,	/* MAT1.0             */
+	GPDMA_WIDTH_BYTE,	/* UART1 Tx           */
+	GPDMA_WIDTH_WORD,	/* MAT1.1             */
+	GPDMA_WIDTH_BYTE,	/* UART1 Rx           */
+	GPDMA_WIDTH_WORD,	/* MAT2.0             */
+	GPDMA_WIDTH_BYTE,	/* UART2 Tx           */
+	GPDMA_WIDTH_WORD,	/* MAT2.1             */
+	GPDMA_WIDTH_BYTE,	/* UART2 Rx           */
+	GPDMA_WIDTH_WORD,	/* MAT3.0             */
+	GPDMA_WIDTH_BYTE,	/* UART3 Tx           */
+	0,					/* SCT timer channel 0*/
+	GPDMA_WIDTH_WORD,	/* MAT3.1             */
+	GPDMA_WIDTH_BYTE,	/* UART3 Rx           */
+	0,					/* SCT timer channel 1*/
+	GPDMA_WIDTH_BYTE,	/* SSP0 Rx            */
+	GPDMA_WIDTH_WORD,	/* I2S channel 0      */
+	GPDMA_WIDTH_BYTE,	/* SSP0 Tx            */
+	GPDMA_WIDTH_WORD,	/* I2S channel 1      */
+	GPDMA_WIDTH_BYTE,	/* SSP1 Rx            */
+	GPDMA_WIDTH_BYTE,	/* SSP1 Tx            */
+	GPDMA_WIDTH_WORD,	/* ADC 0              */
+	GPDMA_WIDTH_WORD,	/* ADC 1              */
+	GPDMA_WIDTH_WORD,	/* DAC                */
+	GPDMA_WIDTH_WORD,	/* I2S channel 0      */
+	GPDMA_WIDTH_WORD/* I2S channel 0      */
+};
+
+/* Lookup Table of Connection Type matched with (18xx,43xx) Peripheral Data (FIFO) register base address */
+volatile static const void *GPDMA_LUTPerAddr[] = {
+	NULL,							/* MEMORY             */
+	(&LPC_TIMER0->MR),				/* MAT0.0             */
+	(&LPC_USART0-> /*RBTHDLR.*/ THR),	/* UART0 Tx           */
+	((uint32_t *) &LPC_TIMER0->MR + 1),	/* MAT0.1             */
+	(&LPC_USART0-> /*RBTHDLR.*/ RBR),	/* UART0 Rx           */
+	(&LPC_TIMER1->MR),				/* MAT1.0             */
+	(&LPC_UART1-> /*RBTHDLR.*/ THR),/* UART1 Tx           */
+	((uint32_t *) &LPC_TIMER1->MR + 1),	/* MAT1.1             */
+	(&LPC_UART1-> /*RBTHDLR.*/ RBR),/* UART1 Rx           */
+	(&LPC_TIMER2->MR),				/* MAT2.0             */
+	(&LPC_USART2-> /*RBTHDLR.*/ THR),	/* UART2 Tx           */
+	((uint32_t *) &LPC_TIMER2->MR + 1),	/* MAT2.1             */
+	(&LPC_USART2-> /*RBTHDLR.*/ RBR),	/* UART2 Rx           */
+	(&LPC_TIMER3->MR),				/* MAT3.0             */
+	(&LPC_USART3-> /*RBTHDLR.*/ THR),	/* UART3 Tx           */
+	0,								/* SCT timer channel 0*/
+	((uint32_t *) &LPC_TIMER3->MR + 1),	/* MAT3.1             */
+	(&LPC_USART3-> /*RBTHDLR.*/ RBR),	/* UART3 Rx           */
+	0,								/* SCT timer channel 1*/
+	(&LPC_SSP0->DR),				/* SSP0 Rx            */
+	(&LPC_I2S0->TXFIFO),			/* I2S0 Tx on channel 0 */
+	(&LPC_SSP0->DR),				/* SSP0 Tx            */
+	(&LPC_I2S0->RXFIFO),			/* I2S0 Rx on channel 1  */
+	(&LPC_SSP1->DR),				/* SSP1 Rx            */
+	(&LPC_SSP1->DR),				/* SSP1 Tx            */
+	(&LPC_ADC0->GDR),				/* ADC 0              */
+	(&LPC_ADC1->GDR),				/* ADC 1              */
+	(&LPC_DAC->CR),					/* DAC                */
+	(&LPC_I2S1->TXFIFO),			/* I2S1 Tx on channel 0 */
+	(&LPC_I2S1->RXFIFO)				/* I2S1 Rx on channel 1 */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+/* Control which set of peripherals is connected to the DMA controller */
+STATIC uint8_t configDMAMux(uint32_t gpdma_peripheral_connection_number)
+{
+	uint8_t function, channel;
+
+	switch (gpdma_peripheral_connection_number) {
+	case GPDMA_CONN_MAT0_0:
+		function = 0;
+		channel = 1;
+		break;
+
+	case GPDMA_CONN_UART0_Tx:
+		function = 1;
+		channel = 1;
+		break;
+
+	case GPDMA_CONN_MAT0_1:
+		function = 0;
+		channel = 2;
+		break;
+
+	case GPDMA_CONN_UART0_Rx:
+		function = 1;
+		channel = 2;
+		break;
+
+	case GPDMA_CONN_MAT1_0:
+		function = 0;
+		channel = 3;
+		break;
+
+	case GPDMA_CONN_UART1_Tx:
+		function = 1;
+		channel = 3;
+		break;
+
+	case GPDMA_CONN_I2S1_Tx_Channel_0:
+		function = 2;
+		channel = 3;
+		break;
+
+	case GPDMA_CONN_MAT1_1:
+		function = 0;
+		channel = 4;
+		break;
+
+	case GPDMA_CONN_UART1_Rx:
+		function = 1;
+		channel = 4;
+		break;
+
+	case GPDMA_CONN_I2S1_Rx_Channel_1:
+		function = 2;
+		channel =  4;
+		break;
+
+	case GPDMA_CONN_MAT2_0:
+		function = 0;
+		channel = 5;
+		break;
+
+	case GPDMA_CONN_UART2_Tx:
+		function = 1;
+		channel = 5;
+		break;
+
+	case GPDMA_CONN_MAT2_1:
+		function = 0;
+		channel = 6;
+		break;
+
+	case GPDMA_CONN_UART2_Rx:
+		function = 1;
+		channel = 6;
+		break;
+
+	case GPDMA_CONN_MAT3_0:
+		function = 0;
+		channel = 7;
+		break;
+
+	case GPDMA_CONN_UART3_Tx:
+		function = 1;
+		channel = 7;
+		break;
+
+	case GPDMA_CONN_SCT_0:
+		function = 2;
+		channel = 7;
+		break;
+
+	case GPDMA_CONN_MAT3_1:
+		function = 0;
+		channel = 8;
+		break;
+
+	case GPDMA_CONN_UART3_Rx:
+		function = 1;
+		channel = 8;
+		break;
+
+	case GPDMA_CONN_SCT_1:
+		function = 2;
+		channel = 8;
+		break;
+
+	case GPDMA_CONN_SSP0_Rx:
+		function = 0;
+		channel = 9;
+		break;
+
+	case GPDMA_CONN_I2S_Tx_Channel_0:
+		function = 1;
+		channel = 9;
+		break;
+
+	case GPDMA_CONN_SSP0_Tx:
+		function = 0;
+		channel = 10;
+		break;
+
+	case GPDMA_CONN_I2S_Rx_Channel_1:
+		function = 1;
+		channel = 10;
+		break;
+
+	case GPDMA_CONN_SSP1_Rx:
+		function = 0;
+		channel = 11;
+		break;
+
+	case GPDMA_CONN_SSP1_Tx:
+		function = 0;
+		channel = 12;
+		break;
+
+	case GPDMA_CONN_ADC_0:
+		function = 0;
+		channel = 13;
+		break;
+
+	case GPDMA_CONN_ADC_1:
+		function = 0;
+		channel = 14;
+		break;
+
+	case GPDMA_CONN_DAC:
+		function = 0;
+		channel = 15;
+		break;
+
+	default:
+		function = 3;
+		channel = 15;
+		break;
+	}
+	/* Set select function to dmamux register */
+	if (0 != gpdma_peripheral_connection_number) {
+		uint32_t temp;
+		temp = LPC_CREG->DMAMUX & (~(0x03 << (2 * channel)));
+		LPC_CREG->DMAMUX = temp | (function << (2 * channel));
+	}
+	return channel;
+}
+
+uint32_t makeCtrlWord(const GPDMA_CH_CFG_T *GPDMAChannelConfig,
+					  uint32_t GPDMA_LUTPerBurstSrcConn,
+					  uint32_t GPDMA_LUTPerBurstDstConn,
+					  uint32_t GPDMA_LUTPerWidSrcConn,
+					  uint32_t GPDMA_LUTPerWidDstConn)
+{
+	uint32_t ctrl_word = 0;
+
+	switch (GPDMAChannelConfig->TransferType) {
+	/* Memory to memory */
+	case GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA:
+		ctrl_word = GPDMA_DMACCxControl_TransferSize(GPDMAChannelConfig->TransferSize)
+					| GPDMA_DMACCxControl_SBSize((4UL))				/**< Burst size = 32 */
+					| GPDMA_DMACCxControl_DBSize((4UL))				/**< Burst size = 32 */
+					| GPDMA_DMACCxControl_SWidth(GPDMAChannelConfig->TransferWidth)
+					| GPDMA_DMACCxControl_DWidth(GPDMAChannelConfig->TransferWidth)
+					| GPDMA_DMACCxControl_SI
+					| GPDMA_DMACCxControl_DI
+					| GPDMA_DMACCxControl_I;
+		break;
+
+	case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA:
+	case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL:
+		ctrl_word = GPDMA_DMACCxControl_TransferSize((uint32_t) GPDMAChannelConfig->TransferSize)
+					| GPDMA_DMACCxControl_SBSize(GPDMA_LUTPerBurstDstConn)
+					| GPDMA_DMACCxControl_DBSize(GPDMA_LUTPerBurstDstConn)
+					| GPDMA_DMACCxControl_SWidth(GPDMA_LUTPerWidDstConn)
+					| GPDMA_DMACCxControl_DWidth(GPDMA_LUTPerWidDstConn)
+					| GPDMA_DMACCxControl_DestTransUseAHBMaster1
+					| GPDMA_DMACCxControl_SI
+					| GPDMA_DMACCxControl_I;
+		break;
+
+	case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA:
+	case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL:
+		ctrl_word = GPDMA_DMACCxControl_TransferSize((uint32_t) GPDMAChannelConfig->TransferSize)
+					| GPDMA_DMACCxControl_SBSize(GPDMA_LUTPerBurstSrcConn)
+					| GPDMA_DMACCxControl_DBSize(GPDMA_LUTPerBurstSrcConn)
+					| GPDMA_DMACCxControl_SWidth(GPDMA_LUTPerWidSrcConn)
+					| GPDMA_DMACCxControl_DWidth(GPDMA_LUTPerWidSrcConn)
+					| GPDMA_DMACCxControl_SrcTransUseAHBMaster1
+					| GPDMA_DMACCxControl_DI
+					| GPDMA_DMACCxControl_I;
+		break;
+
+	case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA:
+	case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL:
+	case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL:
+		ctrl_word = GPDMA_DMACCxControl_TransferSize((uint32_t) GPDMAChannelConfig->TransferSize)
+					| GPDMA_DMACCxControl_SBSize(GPDMA_LUTPerBurstSrcConn)
+					| GPDMA_DMACCxControl_DBSize(GPDMA_LUTPerBurstDstConn)
+					| GPDMA_DMACCxControl_SWidth(GPDMA_LUTPerWidSrcConn)
+					| GPDMA_DMACCxControl_DWidth(GPDMA_LUTPerWidDstConn)
+					| GPDMA_DMACCxControl_SrcTransUseAHBMaster1
+					| GPDMA_DMACCxControl_DestTransUseAHBMaster1
+					| GPDMA_DMACCxControl_I;
+
+		break;
+
+	/* Do not support any more transfer type, return ERROR */
+	default:
+		return ERROR;
+	}
+	return ctrl_word;
+}
+
+/* Set up the DPDMA according to the specification configuration details */
+Status setupChannel(LPC_GPDMA_T *pGPDMA,
+					GPDMA_CH_CFG_T *GPDMAChannelConfig,
+					uint32_t CtrlWord,
+					uint32_t LinkListItem,
+					uint8_t SrcPeripheral,
+					uint8_t DstPeripheral)
+{
+	GPDMA_CH_T *pDMAch;
+
+	if (pGPDMA->ENBLDCHNS & ((((1UL << (GPDMAChannelConfig->ChannelNum)) & 0xFF)))) {
+		/* This channel is enabled, return ERROR, need to release this channel first */
+		return ERROR;
+	}
+
+	/* Get Channel pointer */
+	pDMAch = (GPDMA_CH_T *) &(pGPDMA->CH[GPDMAChannelConfig->ChannelNum]);
+
+	/* Reset the Interrupt status */
+	pGPDMA->INTTCCLEAR = (((1UL << (GPDMAChannelConfig->ChannelNum)) & 0xFF));
+	pGPDMA->INTERRCLR = (((1UL << (GPDMAChannelConfig->ChannelNum)) & 0xFF));
+
+	/* Assign Linker List Item value */
+	pDMAch->LLI = LinkListItem;
+
+	/* Enable DMA channels, little endian */
+	pGPDMA->CONFIG = GPDMA_DMACConfig_E;
+	while (!(pGPDMA->CONFIG & GPDMA_DMACConfig_E)) {}
+
+	pDMAch->SRCADDR = GPDMAChannelConfig->SrcAddr;
+	pDMAch->DESTADDR = GPDMAChannelConfig->DstAddr;
+
+	/* Configure DMA Channel, enable Error Counter and Terminate counter */
+	pDMAch->CONFIG = GPDMA_DMACCxConfig_IE
+					 | GPDMA_DMACCxConfig_ITC		/*| GPDMA_DMACCxConfig_E*/
+					 | GPDMA_DMACCxConfig_TransferType((uint32_t) GPDMAChannelConfig->TransferType)
+					 | GPDMA_DMACCxConfig_SrcPeripheral(SrcPeripheral)
+					 | GPDMA_DMACCxConfig_DestPeripheral(DstPeripheral);
+
+	pDMAch->CONTROL = CtrlWord;
+
+	return SUCCESS;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the GPDMA */
+void Chip_GPDMA_Init(LPC_GPDMA_T *pGPDMA)
+{
+	uint8_t i;
+
+	Chip_Clock_EnableOpts(CLK_MX_DMA, true, true, 1);
+
+	/* Reset all channel configuration register */
+	for (i = 8; i > 0; i--) {
+		pGPDMA->CH[i - 1].CONFIG = 0;
+	}
+
+	/* Clear all DMA interrupt and error flag */
+	pGPDMA->INTTCCLEAR = 0xFF;
+	pGPDMA->INTERRCLR = 0xFF;
+
+	/* Reset all channels are free */
+	for (i = 0; i < GPDMA_NUMBER_CHANNELS; i++) {
+		ChannelHandlerArray[i].ChannelStatus = DISABLE;
+	}
+}
+
+/* Shutdown the GPDMA */
+void Chip_GPDMA_DeInit(LPC_GPDMA_T *pGPDMA)
+{
+	Chip_Clock_Disable(CLK_MX_DMA);
+}
+
+/* Stop a stream DMA transfer */
+void Chip_GPDMA_Stop(LPC_GPDMA_T *pGPDMA,
+					 uint8_t ChannelNum)
+{
+	Chip_GPDMA_ChannelCmd(pGPDMA, (ChannelNum), DISABLE);
+	if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTTC, ChannelNum)) {
+		/* Clear terminate counter Interrupt pending */
+		Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTTC, ChannelNum);
+	}
+	if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTERR, ChannelNum)) {
+		/* Clear terminate counter Interrupt pending */
+		Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTERR, ChannelNum);
+	}
+	ChannelHandlerArray[ChannelNum].ChannelStatus = DISABLE;
+}
+
+/* The GPDMA stream interrupt status checking */
+Status Chip_GPDMA_Interrupt(LPC_GPDMA_T *pGPDMA,
+							uint8_t ChannelNum)
+{
+
+	if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INT, ChannelNum)) {
+		/* Check counter terminal status */
+		if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTTC, ChannelNum)) {
+			/* Clear terminate counter Interrupt pending */
+			Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTTC, ChannelNum);
+			return SUCCESS;
+		}
+		/* Check error terminal status */
+		if (Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_INTERR, ChannelNum)) {
+			/* Clear error counter Interrupt pending */
+
+			Chip_GPDMA_ClearIntPending(pGPDMA, GPDMA_STATCLR_INTERR, ChannelNum);
+			return ERROR;
+		}
+	}
+	return ERROR;
+}
+
+int Chip_GPDMA_InitChannelCfg(LPC_GPDMA_T *pGPDMA,
+							  GPDMA_CH_CFG_T *GPDMACfg,
+							  uint8_t  ChannelNum,
+							  uint32_t src,
+							  uint32_t dst,
+							  uint32_t Size,
+							  GPDMA_FLOW_CONTROL_T TransferType)
+{
+	int rval = -1;
+	GPDMACfg->ChannelNum = ChannelNum;
+	GPDMACfg->TransferType = TransferType;
+	GPDMACfg->TransferSize = Size;
+
+	switch (TransferType) {
+	case GPDMA_TRANSFERTYPE_M2M_CONTROLLER_DMA:
+		GPDMACfg->SrcAddr = (uint32_t) src;
+		GPDMACfg->DstAddr = (uint32_t) dst;
+		rval = 3;
+		GPDMACfg->TransferWidth = GPDMA_WIDTH_WORD;
+		GPDMACfg->TransferSize = Size / 4;
+		break;
+
+	case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA:
+	case GPDMA_TRANSFERTYPE_M2P_CONTROLLER_PERIPHERAL:
+		GPDMACfg->SrcAddr = (uint32_t) src;
+		rval = 1;
+		GPDMACfg->DstAddr = (uint32_t) GPDMA_LUTPerAddr[dst];
+		break;
+
+	case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA:
+	case GPDMA_TRANSFERTYPE_P2M_CONTROLLER_PERIPHERAL:
+		GPDMACfg->SrcAddr = (uint32_t) GPDMA_LUTPerAddr[src];
+		GPDMACfg->DstAddr = (uint32_t) dst;
+		rval = 2;
+		break;
+
+	case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DMA:
+	case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_DestPERIPHERAL:
+	case GPDMA_TRANSFERTYPE_P2P_CONTROLLER_SrcPERIPHERAL:
+		GPDMACfg->SrcAddr = (uint32_t) GPDMA_LUTPerAddr[src];
+		GPDMACfg->DstAddr = (uint32_t) GPDMA_LUTPerAddr[dst];
+		rval = 0;
+		break;
+
+	default:
+		break;
+	}
+	return rval;
+}
+
+/* Read the status from different registers according to the type */
+IntStatus Chip_GPDMA_IntGetStatus(LPC_GPDMA_T *pGPDMA, GPDMA_STATUS_T type, uint8_t channel)
+{
+	/**
+	 * TODO check the channel <=8 type is exited
+	 */
+	switch (type) {
+	case GPDMA_STAT_INT:/* check status of DMA channel interrupts */
+		return (IntStatus) (pGPDMA->INTSTAT & (((1UL << channel) & 0xFF)));
+
+	case GPDMA_STAT_INTTC:	/* check terminal count interrupt request status for DMA */
+		return (IntStatus) (pGPDMA->INTTCSTAT & (((1UL << channel) & 0xFF)));
+
+	case GPDMA_STAT_INTERR:	/* check interrupt status for DMA channels */
+		return (IntStatus) (pGPDMA->INTERRSTAT & (((1UL << channel) & 0xFF)));
+
+	case GPDMA_STAT_RAWINTTC:	/* check status of the terminal count interrupt for DMA channels */
+		return (IntStatus) (pGPDMA->RAWINTTCSTAT & (((1UL << channel) & 0xFF)));
+
+	case GPDMA_STAT_RAWINTERR:	/* check status of the error interrupt for DMA channels */
+		return (IntStatus) (pGPDMA->RAWINTERRSTAT & (((1UL << channel) & 0xFF)));
+
+	default:/* check enable status for DMA channels */
+		return (IntStatus) (pGPDMA->ENBLDCHNS & (((1UL << channel) & 0xFF)));
+	}
+}
+
+/* Clear the Interrupt Flag from different registers according to the type */
+void Chip_GPDMA_ClearIntPending(LPC_GPDMA_T *pGPDMA, GPDMA_STATECLEAR_T type, uint8_t channel)
+{
+	if (type == GPDMA_STATCLR_INTTC) {
+		/* clears the terminal count interrupt request on DMA channel */
+		pGPDMA->INTTCCLEAR = (((1UL << (channel)) & 0xFF));
+	}
+	else {
+		/* clear the error interrupt request */
+		pGPDMA->INTERRCLR = (((1UL << (channel)) & 0xFF));
+	}
+}
+
+/* Enable or Disable the GPDMA Channel */
+void Chip_GPDMA_ChannelCmd(LPC_GPDMA_T *pGPDMA, uint8_t channelNum, FunctionalState NewState)
+{
+	GPDMA_CH_T *pDMAch;
+
+	/* Get Channel pointer */
+	pDMAch = (GPDMA_CH_T *) &(pGPDMA->CH[channelNum]);
+
+	if (NewState == ENABLE) {
+		pDMAch->CONFIG |= GPDMA_DMACCxConfig_E;
+	}
+	else {
+		pDMAch->CONFIG &= ~GPDMA_DMACCxConfig_E;
+	}
+}
+
+/* Do a DMA transfer M2M, M2P,P2M or P2P */
+Status Chip_GPDMA_Transfer(LPC_GPDMA_T *pGPDMA,
+						   uint8_t ChannelNum,
+						   uint32_t src,
+						   uint32_t dst,
+						   GPDMA_FLOW_CONTROL_T TransferType,
+						   uint32_t Size)
+{
+	GPDMA_CH_CFG_T GPDMACfg;
+	uint8_t SrcPeripheral = 0, DstPeripheral = 0;
+	uint32_t cwrd;
+	int ret;
+
+	ret = Chip_GPDMA_InitChannelCfg(pGPDMA, &GPDMACfg, ChannelNum, src, dst, Size, TransferType);
+	if (ret < 0) {
+		return ERROR;
+	}
+
+	/* Adjust src/dst index if they are memory */
+	if (ret & 1) {
+		src = 0;
+	}
+	else {
+		SrcPeripheral = configDMAMux(src);
+	}
+
+	if (ret & 2) {
+		dst = 0;
+	}
+	else {
+		DstPeripheral = configDMAMux(dst);
+	}
+
+	cwrd = makeCtrlWord(&GPDMACfg,
+						(uint32_t) GPDMA_LUTPerBurst[src],
+						(uint32_t) GPDMA_LUTPerBurst[dst],
+						(uint32_t) GPDMA_LUTPerWid[src],
+						(uint32_t) GPDMA_LUTPerWid[dst]);
+	if (setupChannel(pGPDMA, &GPDMACfg, cwrd, 0, SrcPeripheral, DstPeripheral) == ERROR) {
+		return ERROR;
+	}
+
+	/* Start the Channel */
+	Chip_GPDMA_ChannelCmd(pGPDMA, ChannelNum, ENABLE);
+	return SUCCESS;
+}
+
+Status Chip_GPDMA_PrepareDescriptor(LPC_GPDMA_T *pGPDMA,
+									DMA_TransferDescriptor_t *DMADescriptor,
+									uint32_t src,
+									uint32_t dst,
+									uint32_t Size,
+									GPDMA_FLOW_CONTROL_T TransferType,
+									const DMA_TransferDescriptor_t *NextDescriptor)
+{
+	int ret;
+	GPDMA_CH_CFG_T GPDMACfg;
+
+	ret = Chip_GPDMA_InitChannelCfg(pGPDMA, &GPDMACfg, 0, src, dst, Size, TransferType);
+	if (ret < 0) {
+		return ERROR;
+	}
+
+	/* Adjust src/dst index if they are memory */
+	if (ret & 1) {
+		src = 0;
+	}
+
+	if (ret & 2) {
+		dst = 0;
+	}
+
+	DMADescriptor->src  = GPDMACfg.SrcAddr;
+	DMADescriptor->dst  = GPDMACfg.DstAddr;
+	DMADescriptor->lli  = (uint32_t) NextDescriptor;
+	DMADescriptor->ctrl = makeCtrlWord(&GPDMACfg,
+									   (uint32_t) GPDMA_LUTPerBurst[src],
+									   (uint32_t) GPDMA_LUTPerBurst[dst],
+									   (uint32_t) GPDMA_LUTPerWid[src],
+									   (uint32_t) GPDMA_LUTPerWid[dst]);
+
+	/* By default set interrupt only for last transfer */
+	if (NextDescriptor) {
+		DMADescriptor->ctrl &= ~GPDMA_DMACCxControl_I;
+	}
+
+	return SUCCESS;
+}
+
+/* Do a DMA scatter-gather transfer M2M, M2P,P2M or P2P using DMA descriptors */
+Status Chip_GPDMA_SGTransfer(LPC_GPDMA_T *pGPDMA,
+							 uint8_t ChannelNum,
+							 const DMA_TransferDescriptor_t *DMADescriptor,
+							 GPDMA_FLOW_CONTROL_T TransferType)
+{
+	const DMA_TransferDescriptor_t *dsc = DMADescriptor;
+	GPDMA_CH_CFG_T GPDMACfg;
+	uint8_t SrcPeripheral = 0, DstPeripheral = 0;
+	uint32_t src = DMADescriptor->src, dst = DMADescriptor->dst;
+	int ret;
+
+	ret = Chip_GPDMA_InitChannelCfg(pGPDMA, &GPDMACfg, ChannelNum, src, dst, 0, TransferType);
+	if (ret < 0) {
+		return ERROR;
+	}
+
+	/* Adjust src/dst index if they are memory */
+	if (ret & 1) {
+		src = 0;
+	}
+	else {
+		SrcPeripheral = configDMAMux(src);
+	}
+
+	if (ret & 2) {
+		dst = 0;
+	}
+	else {
+		DstPeripheral = configDMAMux(dst);
+	}
+
+	if (setupChannel(pGPDMA, &GPDMACfg, dsc->ctrl, dsc->lli, SrcPeripheral, DstPeripheral) == ERROR) {
+		return ERROR;
+	}
+
+	/* Start the Channel */
+	Chip_GPDMA_ChannelCmd(pGPDMA, ChannelNum, ENABLE);
+	return SUCCESS;
+}
+
+/* Get a free GPDMA channel for one DMA connection */
+uint8_t Chip_GPDMA_GetFreeChannel(LPC_GPDMA_T *pGPDMA,
+								  uint32_t PeripheralConnection_ID)
+{
+	uint8_t temp = 0;
+	for (temp = 0; temp < GPDMA_NUMBER_CHANNELS; temp++) {
+		if (!Chip_GPDMA_IntGetStatus(pGPDMA, GPDMA_STAT_ENABLED_CH,
+									 temp) && (ChannelHandlerArray[temp].ChannelStatus == DISABLE)) {
+			ChannelHandlerArray[temp].ChannelStatus = ENABLE;
+			return temp;
+		}
+	}
+	return 0;
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/gpio_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/gpio_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/gpio_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/gpio_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,66 @@
+/*
+ * @brief LPC18xx/43xx GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize GPIO block */
+void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
+{
+}
+
+/* De-Initialize GPIO block */
+void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO)
+{
+}
+
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/gpiogroup_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/gpiogroup_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/gpiogroup_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/gpiogroup_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,54 @@
+/*
+ * @brief LPC18xx/43xx GPIO group driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/i2c_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/i2c_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/i2c_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/i2c_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,560 @@
+/*
+ * @brief LPC18xx/43xx I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Control flags */
+#define I2C_CON_FLAGS (I2C_CON_AA | I2C_CON_SI | I2C_CON_STO | I2C_CON_STA)
+#define LPC_I2Cx(id)      ((i2c[id].ip))
+#define SLAVE_ACTIVE(iic) (((iic)->flags & 0xFF00) != 0)
+
+/* I2C common interface structure */
+struct i2c_interface {
+	LPC_I2C_T *ip;		/* IP base address of the I2C device */
+	CHIP_CCU_CLK_T clk;	/* Clock used by I2C */
+	I2C_EVENTHANDLER_T mEvent;	/* Current active Master event handler */
+	I2C_EVENTHANDLER_T sEvent;	/* Slave transfer events */
+	I2C_XFER_T *mXfer;	/* Current active xfer pointer */
+	I2C_XFER_T *sXfer;	/* Pointer to store xfer when bus is busy */
+	uint32_t flags;		/* Flags used by I2C master and slave */
+};
+
+/* Slave interface structure */
+struct i2c_slave_interface {
+	I2C_XFER_T *xfer;
+	I2C_EVENTHANDLER_T event;
+};
+
+/* I2C interfaces */
+static struct i2c_interface i2c[I2C_NUM_INTERFACE] = {
+	{LPC_I2C0, CLK_APB1_I2C0, Chip_I2C_EventHandler, NULL, NULL, NULL, 0},
+	{LPC_I2C1, CLK_APB3_I2C1, Chip_I2C_EventHandler, NULL, NULL, NULL, 0}
+};
+
+static struct i2c_slave_interface i2c_slave[I2C_NUM_INTERFACE][I2C_SLAVE_NUM_INTERFACE];
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+STATIC INLINE void enableClk(I2C_ID_T id)
+{
+	Chip_Clock_Enable(i2c[id].clk);
+}
+
+STATIC INLINE void disableClk(I2C_ID_T id)
+{
+	Chip_Clock_Disable(i2c[id].clk);
+}
+
+/* Get the ADC Clock Rate */
+STATIC INLINE uint32_t getClkRate(I2C_ID_T id)
+{
+	return Chip_Clock_GetRate(i2c[id].clk);
+}
+
+/* Enable I2C and start master transfer */
+STATIC INLINE void startMasterXfer(LPC_I2C_T *pI2C)
+{
+	/* Reset STA, STO, SI */
+	pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA | I2C_CON_AA;
+
+	/* Enter to Master Transmitter mode */
+	pI2C->CONSET = I2C_CON_I2EN | I2C_CON_STA;
+}
+
+/* Enable I2C and enable slave transfers */
+STATIC INLINE void startSlaverXfer(LPC_I2C_T *pI2C)
+{
+	/* Reset STA, STO, SI */
+	pI2C->CONCLR = I2C_CON_SI | I2C_CON_STA;
+
+	/* Enter to Master Transmitter mode */
+	pI2C->CONSET = I2C_CON_I2EN | I2C_CON_AA;
+}
+
+/* Check if I2C bus is free */
+STATIC INLINE int isI2CBusFree(LPC_I2C_T *pI2C)
+{
+	return !(pI2C->CONSET & I2C_CON_STO);
+}
+
+/* Get current state of the I2C peripheral */
+STATIC INLINE int getCurState(LPC_I2C_T *pI2C)
+{
+	return (int) (pI2C->STAT & I2C_STAT_CODE_BITMASK);
+}
+
+/* Check if the active state belongs to master mode*/
+STATIC INLINE int isMasterState(LPC_I2C_T *pI2C)
+{
+	return getCurState(pI2C) < 0x60;
+}
+
+/* Set OWN slave address for specific slave ID */
+STATIC void setSlaveAddr(LPC_I2C_T *pI2C, I2C_SLAVE_ID sid, uint8_t addr, uint8_t mask)
+{
+	uint32_t index = (uint32_t) sid - 1;
+	pI2C->MASK[index] = mask;
+	if (sid == I2C_SLAVE_0) {
+		pI2C->ADR0 = addr;
+	}
+	else {
+		volatile uint32_t *abase = &pI2C->ADR1;
+		abase[index - 1] = addr;
+	}
+}
+
+/* Match the slave address */
+STATIC int isSlaveAddrMatching(uint8_t addr1, uint8_t addr2, uint8_t mask)
+{
+	mask |= 1;
+	return (addr1 & ~mask) == (addr2 & ~mask);
+}
+
+/* Get the index of the active slave */
+STATIC I2C_SLAVE_ID lookupSlaveIndex(LPC_I2C_T *pI2C, uint8_t slaveAddr)
+{
+	if (!(slaveAddr >> 1)) {
+		return I2C_SLAVE_GENERAL;					/* General call address */
+	}
+	if (isSlaveAddrMatching(pI2C->ADR0, slaveAddr, pI2C->MASK[0])) {
+		return I2C_SLAVE_0;
+	}
+	if (isSlaveAddrMatching(pI2C->ADR1, slaveAddr, pI2C->MASK[1])) {
+		return I2C_SLAVE_1;
+	}
+	if (isSlaveAddrMatching(pI2C->ADR2, slaveAddr, pI2C->MASK[2])) {
+		return I2C_SLAVE_2;
+	}
+	if (isSlaveAddrMatching(pI2C->ADR3, slaveAddr, pI2C->MASK[3])) {
+		return I2C_SLAVE_3;
+	}
+
+	/* If everything is fine the code should never come here */
+	return I2C_SLAVE_GENERAL;
+}
+
+/* Master transfer state change handler handler */
+int handleMasterXferState(LPC_I2C_T *pI2C, I2C_XFER_T  *xfer)
+{
+	uint32_t cclr = I2C_CON_FLAGS;
+
+	switch (getCurState(pI2C)) {
+	case 0x08:		/* Start condition on bus */
+	case 0x10:		/* Repeated start condition */
+		pI2C->DAT = (xfer->slaveAddr << 1) | (xfer->txSz == 0);
+		break;
+
+	/* Tx handling */
+	case 0x18:		/* SLA+W sent and ACK received */
+	case 0x28:		/* DATA sent and ACK received */
+		if (!xfer->txSz) {
+			cclr &= ~(xfer->rxSz ? I2C_CON_STA : I2C_CON_STO);
+		}
+		else {
+			pI2C->DAT = *xfer->txBuff++;
+			xfer->txSz--;
+		}
+		break;
+
+	/* Rx handling */
+	case 0x58:		/* Data Received and NACK sent */
+		cclr &= ~I2C_CON_STO;
+
+	case 0x50:		/* Data Received and ACK sent */
+		*xfer->rxBuff++ = pI2C->DAT;
+		xfer->rxSz--;
+
+	case 0x40:		/* SLA+R sent and ACK received */
+		if (xfer->rxSz > 1) {
+			cclr &= ~I2C_CON_AA;
+		}
+		break;
+
+	/* NAK Handling */
+	case 0x20:		/* SLA+W sent NAK received */
+	case 0x48:		/* SLA+R sent NAK received */
+		xfer->status = I2C_STATUS_SLAVENAK;
+		cclr &= ~I2C_CON_STO;
+		break;
+
+	case 0x30:		/* DATA sent NAK received */
+		xfer->status = I2C_STATUS_NAK;
+		cclr &= ~I2C_CON_STO;
+		break;
+
+	case 0x38:		/* Arbitration lost */
+		xfer->status = I2C_STATUS_ARBLOST;
+		break;
+
+	/* Bus Error */
+	case 0x00:
+		xfer->status = I2C_STATUS_BUSERR;
+		cclr &= ~I2C_CON_STO;
+	}
+
+	/* Set clear control flags */
+	pI2C->CONSET = cclr ^ I2C_CON_FLAGS;
+	pI2C->CONCLR = cclr & ~I2C_CON_STO;
+
+	/* If stopped return 0 */
+	if (!(cclr & I2C_CON_STO) || (xfer->status == I2C_STATUS_ARBLOST)) {
+		if (xfer->status == I2C_STATUS_BUSY) {
+			xfer->status = I2C_STATUS_DONE;
+		}
+		return 0;
+	}
+	return 1;
+}
+
+/* Find the slave address of SLA+W or SLA+R */
+I2C_SLAVE_ID getSlaveIndex(LPC_I2C_T *pI2C)
+{
+	switch (getCurState(pI2C)) {
+	case 0x60:
+	case 0x68:
+	case 0x70:
+	case 0x78:
+	case 0xA8:
+	case 0xB0:
+		return lookupSlaveIndex(pI2C, pI2C->DAT);
+	}
+
+	/* If everything is fine code should never come here */
+	return I2C_SLAVE_GENERAL;
+}
+
+/* Slave state machine handler */
+int handleSlaveXferState(LPC_I2C_T *pI2C, I2C_XFER_T *xfer)
+{
+	uint32_t cclr = I2C_CON_FLAGS;
+	int ret = RET_SLAVE_BUSY;
+
+	xfer->status = I2C_STATUS_BUSY;
+	switch (getCurState(pI2C)) {
+	case 0x80:		/* SLA: Data received + ACK sent */
+	case 0x90:		/* GC: Data received + ACK sent */
+		*xfer->rxBuff++ = pI2C->DAT;
+		xfer->rxSz--;
+		ret = RET_SLAVE_RX;
+		if (xfer->rxSz > 1) {
+			cclr &= ~I2C_CON_AA;
+		}
+		break;
+
+	case 0x60:		/* Own SLA+W received */
+	case 0x68:		/* Own SLA+W received after losing arbitration */
+	case 0x70:		/* GC+W received */
+	case 0x78:		/* GC+W received after losing arbitration */
+		xfer->slaveAddr = pI2C->DAT & ~1;
+		if (xfer->rxSz > 1) {
+			cclr &= ~I2C_CON_AA;
+		}
+		break;
+
+	case 0xA8:		/* SLA+R received */
+	case 0xB0:		/* SLA+R received after losing arbitration */
+		xfer->slaveAddr = pI2C->DAT & ~1;
+
+	case 0xB8:		/* DATA sent and ACK received */
+		pI2C->DAT = *xfer->txBuff++;
+		xfer->txSz--;
+		if (xfer->txSz > 0) {
+			cclr &= ~I2C_CON_AA;
+		}
+		ret = RET_SLAVE_TX;
+		break;
+
+	case 0xC0:		/* Data transmitted and NAK received */
+	case 0xC8:		/* Last data transmitted and ACK received */
+	case 0x88:		/* SLA: Data received + NAK sent */
+	case 0x98:		/* GC: Data received + NAK sent */
+	case 0xA0:		/* STOP/Repeated START condition received */
+		ret = RET_SLAVE_IDLE;
+		cclr &= ~I2C_CON_AA;
+		xfer->status = I2C_STATUS_DONE;
+		if (xfer->slaveAddr & 1) {
+			cclr &= ~I2C_CON_STA;
+		}
+		break;
+	}
+
+	/* Set clear control flags */
+	pI2C->CONSET = cclr ^ I2C_CON_FLAGS;
+	pI2C->CONCLR = cclr & ~I2C_CON_STO;
+
+	return ret;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Chip event handler interrupt based */
+void Chip_I2C_EventHandler(I2C_ID_T id, I2C_EVENT_T event)
+{
+	struct i2c_interface *iic = &i2c[id];
+	volatile I2C_STATUS_T *stat;
+
+	/* Only WAIT event needs to be handled */
+	if (event != I2C_EVENT_WAIT) {
+		return;
+	}
+
+	stat = &iic->mXfer->status;
+	/* Wait for the status to change */
+	while (*stat == I2C_STATUS_BUSY) {}
+}
+
+/* Chip polling event handler */
+void Chip_I2C_EventHandlerPolling(I2C_ID_T id, I2C_EVENT_T event)
+{
+	struct i2c_interface *iic = &i2c[id];
+	volatile I2C_STATUS_T *stat;
+
+	/* Only WAIT event needs to be handled */
+	if (event != I2C_EVENT_WAIT) {
+		return;
+	}
+
+	stat = &iic->mXfer->status;
+	/* Call the state change handler till xfer is done */
+	while (*stat == I2C_STATUS_BUSY) {
+		if (Chip_I2C_IsStateChanged(id)) {
+			Chip_I2C_MasterStateHandler(id);
+		}
+	}
+}
+
+/* Initializes the LPC_I2C peripheral with specified parameter */
+void Chip_I2C_Init(I2C_ID_T id)
+{
+	enableClk(id);
+
+	/* Set I2C operation to default */
+	LPC_I2Cx(id)->CONCLR = (I2C_CON_AA | I2C_CON_SI | I2C_CON_STA | I2C_CON_I2EN);
+}
+
+/* De-initializes the I2C peripheral registers to their default reset values */
+void Chip_I2C_DeInit(I2C_ID_T id)
+{
+	/* Disable I2C control */
+	LPC_I2Cx(id)->CONCLR = I2C_CON_I2EN | I2C_CON_SI | I2C_CON_STA | I2C_CON_AA;
+
+	disableClk(id);
+}
+
+/* Set up clock rate for LPC_I2C peripheral */
+void Chip_I2C_SetClockRate(I2C_ID_T id, uint32_t clockrate)
+{
+	uint32_t SCLValue;
+
+	SCLValue = (getClkRate(id) / clockrate);
+	LPC_I2Cx(id)->SCLH = (uint32_t) (SCLValue >> 1);
+	LPC_I2Cx(id)->SCLL = (uint32_t) (SCLValue - LPC_I2Cx(id)->SCLH);
+}
+
+/* Get current clock rate for LPC_I2C peripheral */
+uint32_t Chip_I2C_GetClockRate(I2C_ID_T id)
+{
+	return getClkRate(id) / (LPC_I2Cx(id)->SCLH + LPC_I2Cx(id)->SCLL);
+}
+
+/* Set the master event handler */
+int Chip_I2C_SetMasterEventHandler(I2C_ID_T id, I2C_EVENTHANDLER_T event)
+{
+	struct i2c_interface *iic = &i2c[id];
+	if (!iic->mXfer) {
+		iic->mEvent = event;
+	}
+	return iic->mEvent == event;
+}
+
+/* Get the master event handler */
+I2C_EVENTHANDLER_T Chip_I2C_GetMasterEventHandler(I2C_ID_T id)
+{
+	return i2c[id].mEvent;
+}
+
+/* Transmit and Receive data in master mode */
+int Chip_I2C_MasterTransfer(I2C_ID_T id, I2C_XFER_T *xfer)
+{
+	struct i2c_interface *iic = &i2c[id];
+
+	iic->mEvent(id, I2C_EVENT_LOCK);
+	xfer->status = I2C_STATUS_BUSY;
+	iic->mXfer = xfer;
+
+	/* If slave xfer not in progress */
+	if (!iic->sXfer) {
+		startMasterXfer(iic->ip);
+	}
+	iic->mEvent(id, I2C_EVENT_WAIT);
+	iic->mXfer = 0;
+
+	/* Wait for stop condition to appear on bus */
+	while (!isI2CBusFree(iic->ip)) {}
+
+	/* Start slave if one is active */
+	if (SLAVE_ACTIVE(iic)) {
+		startSlaverXfer(iic->ip);
+	}
+
+	iic->mEvent(id, I2C_EVENT_UNLOCK);
+	return (int) xfer->status;
+}
+
+/* Master tx only */
+int Chip_I2C_MasterSend(I2C_ID_T id, uint8_t slaveAddr, const uint8_t *buff, uint8_t len)
+{
+	I2C_XFER_T xfer = {0};
+	xfer.slaveAddr = slaveAddr;
+	xfer.txBuff = buff;
+	xfer.txSz = len;
+	while (Chip_I2C_MasterTransfer(id, &xfer) == I2C_STATUS_ARBLOST) {}
+	return len - xfer.txSz;
+}
+
+/* Transmit one byte and receive an array of bytes after a repeated start condition is generated in Master mode.
+ * This function is useful for communicating with the I2C slave registers
+ */
+int Chip_I2C_MasterCmdRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t cmd, uint8_t *buff, int len)
+{
+	I2C_XFER_T xfer = {0};
+	xfer.slaveAddr = slaveAddr;
+	xfer.txBuff = &cmd;
+	xfer.txSz = 1;
+	xfer.rxBuff = buff;
+	xfer.rxSz = len;
+	while (Chip_I2C_MasterTransfer(id, &xfer) == I2C_STATUS_ARBLOST) {}
+	return len - xfer.rxSz;
+}
+
+/* Sequential master read */
+int Chip_I2C_MasterRead(I2C_ID_T id, uint8_t slaveAddr, uint8_t *buff, int len)
+{
+	I2C_XFER_T xfer = {0};
+	xfer.slaveAddr = slaveAddr;
+	xfer.rxBuff = buff;
+	xfer.rxSz = len;
+	while (Chip_I2C_MasterTransfer(id, &xfer) == I2C_STATUS_ARBLOST) {}
+	return len - xfer.rxSz;
+}
+
+/* Check if master state is active */
+int Chip_I2C_IsMasterActive(I2C_ID_T id)
+{
+	return isMasterState(i2c[id].ip);
+}
+
+/* State change handler for master transfer */
+void Chip_I2C_MasterStateHandler(I2C_ID_T id)
+{
+	if (!handleMasterXferState(i2c[id].ip, i2c[id].mXfer)) {
+		i2c[id].mEvent(id, I2C_EVENT_DONE);
+	}
+}
+
+/* Setup slave function */
+void Chip_I2C_SlaveSetup(I2C_ID_T id,
+						 I2C_SLAVE_ID sid,
+						 I2C_XFER_T *xfer,
+						 I2C_EVENTHANDLER_T event,
+						 uint8_t addrMask)
+{
+	struct i2c_interface *iic = &i2c[id];
+	struct i2c_slave_interface *si2c = &i2c_slave[id][sid];
+	si2c->xfer = xfer;
+	si2c->event = event;
+
+	/* Set up the slave address */
+	if (sid != I2C_SLAVE_GENERAL) {
+		setSlaveAddr(iic->ip, sid, xfer->slaveAddr, addrMask);
+	}
+
+	if (!SLAVE_ACTIVE(iic) && !iic->mXfer) {
+		startSlaverXfer(iic->ip);
+	}
+	iic->flags |= 1 << (sid + 8);
+}
+
+/* I2C Slave event handler */
+void Chip_I2C_SlaveStateHandler(I2C_ID_T id)
+{
+	int ret;
+	struct i2c_interface *iic = &i2c[id];
+
+	/* Get the currently addressed slave */
+	if (!iic->sXfer) {
+		struct i2c_slave_interface *si2c;
+
+		I2C_SLAVE_ID sid = getSlaveIndex(iic->ip);
+		si2c = &i2c_slave[id][sid];
+		iic->sXfer = si2c->xfer;
+		iic->sEvent = si2c->event;
+	}
+
+	iic->sXfer->slaveAddr |= iic->mXfer != 0;
+	ret = handleSlaveXferState(iic->ip, iic->sXfer);
+	if (ret) {
+		if (iic->sXfer->status == I2C_STATUS_DONE) {
+			iic->sXfer = 0;
+		}
+		iic->sEvent(id, (I2C_EVENT_T) ret);
+	}
+}
+
+/* Disable I2C device */
+void Chip_I2C_Disable(I2C_ID_T id)
+{
+	LPC_I2Cx(id)->CONCLR = I2C_I2CONCLR_I2ENC;
+}
+
+/* State change checking */
+int Chip_I2C_IsStateChanged(I2C_ID_T id)
+{
+	return (LPC_I2Cx(id)->CONSET & I2C_CON_SI) != 0;
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/i2cm_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/i2cm_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/i2cm_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/i2cm_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,274 @@
+/*
+ * @brief LPC18xx/43xx I2C master driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Control flags */
+#define I2C_CON_FLAGS (I2C_CON_AA | I2C_CON_SI | I2C_CON_STO | I2C_CON_STA)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+/* Get the ADC Clock Rate */
+static CHIP_CCU_CLK_T i2cm_getClkId(LPC_I2C_T *pI2C)
+{
+	return (pI2C == LPC_I2C0)? CLK_APB1_I2C0 : CLK_APB3_I2C1;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the LPC_I2C peripheral with specified parameter */
+void Chip_I2CM_Init(LPC_I2C_T *pI2C)
+{
+	/* Enable I2C clock */
+	Chip_Clock_Enable(i2cm_getClkId(pI2C));
+	/* Reset I2C state machine */
+	Chip_I2CM_ResetControl(pI2C);
+}
+
+/* De-initializes the I2C peripheral registers to their default reset values */
+void Chip_I2CM_DeInit(LPC_I2C_T *pI2C)
+{
+	/* Reset I2C state machine */
+	Chip_I2CM_ResetControl(pI2C);
+	/* Disable I2C clock */
+	Chip_Clock_Disable(i2cm_getClkId(pI2C));
+}
+
+/* Set up bus speed for LPC_I2C interface */
+void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed)
+{
+	uint32_t clockDiv = (Chip_Clock_GetRate(i2cm_getClkId(pI2C)) / busSpeed);
+
+	Chip_I2CM_SetDutyCycle(pI2C, (clockDiv >> 1), (clockDiv - (clockDiv >> 1)));
+}
+
+/* Master transfer state change handler handler */
+uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+	uint32_t cclr = I2C_CON_FLAGS;
+
+	switch (Chip_I2CM_GetCurState(pI2C)) {
+	case 0x08:		/* Start condition on bus */
+	case 0x10:		/* Repeated start condition */
+		pI2C->DAT = (xfer->slaveAddr << 1) | (xfer->txSz == 0);
+		break;
+
+	/* Tx handling */
+	case 0x20:		/* SLA+W sent NAK received */
+	case 0x30:		/* DATA sent NAK received */
+		if ((xfer->options & I2CM_XFER_OPTION_IGNORE_NACK) == 0) {
+			xfer->status = I2CM_STATUS_NAK;
+			cclr &= ~I2C_CON_STO;
+			break;
+		}
+
+	case 0x18:		/* SLA+W sent and ACK received */
+	case 0x28:		/* DATA sent and ACK received */
+		if (!xfer->txSz) {
+			if (xfer->rxSz) {
+				cclr &= ~I2C_CON_STA;
+			}
+			else {
+				xfer->status = I2CM_STATUS_OK;
+				cclr &= ~I2C_CON_STO;
+			}
+
+		}
+		else {
+			pI2C->DAT = *xfer->txBuff++;
+			xfer->txSz--;
+		}
+		break;
+
+	/* Rx handling */
+	case 0x58:		/* Data Received and NACK sent */
+	case 0x50:		/* Data Received and ACK sent */
+		*xfer->rxBuff++ = pI2C->DAT;
+		xfer->rxSz--;
+
+	case 0x40:		/* SLA+R sent and ACK received */
+		if ((xfer->rxSz > 1) || (xfer->options & I2CM_XFER_OPTION_LAST_RX_ACK)) {
+			cclr &= ~I2C_CON_AA;
+		}
+		if (xfer->rxSz == 0) {
+			xfer->status = I2CM_STATUS_OK;
+			cclr &= ~I2C_CON_STO;
+		}
+		break;
+
+	/* NAK Handling */
+	case 0x48:		/* SLA+R sent NAK received */
+		xfer->status = I2CM_STATUS_SLAVE_NAK;
+		cclr &= ~I2C_CON_STO;
+		break;
+
+	case 0x38:		/* Arbitration lost */
+		xfer->status = I2CM_STATUS_ARBLOST;
+		break;
+
+	case 0x00:		/* Bus Error */
+		xfer->status = I2CM_STATUS_BUS_ERROR;
+		cclr &= ~I2C_CON_STO;
+        break;
+    case 0xF8:
+      return 0;
+      
+    default:
+		xfer->status = I2CM_STATUS_ERROR;
+		cclr &= ~I2C_CON_STO;
+        break;
+	}
+
+	/* Set clear control flags */
+	pI2C->CONSET = cclr ^ I2C_CON_FLAGS;
+	/* Stop flag should not be cleared as it is a reserved bit */
+	pI2C->CONCLR = cclr & (I2C_CON_AA | I2C_CON_SI | I2C_CON_STA);
+
+	return xfer->status != I2CM_STATUS_BUSY;
+}
+
+/* Transmit and Receive data in master mode */
+void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+	/* set the transfer status as busy */
+	xfer->status = I2CM_STATUS_BUSY;
+	/* Clear controller state. */
+	Chip_I2CM_ResetControl(pI2C);
+	/* Enter to Master Transmitter mode */
+	Chip_I2CM_SendStart(pI2C);
+}
+
+/* Transmit and Receive data in master mode */
+uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+	uint32_t ret = 0;
+	/* start transfer */
+	Chip_I2CM_Xfer(pI2C, xfer);
+
+	while (ret == 0) {
+		/* wait for status change interrupt */
+		while ( Chip_I2CM_StateChanged(pI2C) == 0) {}
+		/* call state change handler */
+		ret = Chip_I2CM_XferHandler(pI2C, xfer);
+	}
+	return ret;
+}
+
+/* Master tx only */
+uint32_t Chip_I2CM_Write(LPC_I2C_T *pI2C, const uint8_t *buff, uint32_t len)
+{
+	uint32_t txLen = 0, err = 0;
+
+	/* clear state change interrupt status */
+	Chip_I2CM_ClearSI(pI2C);
+	/* generate START condition */
+	Chip_I2CM_SendStart(pI2C);
+
+	while ((txLen < len) && (err == 0)) {
+		/* wait for status change interrupt */
+		while ( Chip_I2CM_StateChanged(pI2C) == 0) {}
+
+		/* check status and send data */
+		switch (Chip_I2CM_GetCurState(pI2C)) {
+		case 0x08:		/* Start condition on bus */
+		case 0x10:		/* Repeated start condition */
+		case 0x18:		/* SLA+W sent and ACK received */
+		case 0x28:		/* DATA sent and ACK received */
+			Chip_I2CM_WriteByte(pI2C, buff[txLen++]);
+			break;
+
+		case 0x38:		/* Arbitration lost */
+			break;
+
+		default:		/* we shouldn't be in any other state */
+			err = 1;
+			break;
+		}
+		/* clear state change interrupt status */
+		Chip_I2CM_ClearSI(pI2C);
+	}
+
+	return txLen;
+}
+
+/* Sequential master read */
+uint32_t Chip_I2CM_Read(LPC_I2C_T *pI2C, uint8_t *buff, uint32_t len)
+{
+	uint32_t rxLen = 0, err = 0;
+
+	/* clear state change interrupt status */
+	Chip_I2CM_ClearSI(pI2C);
+	/* generate START condition and auto-ack data received */
+	pI2C->CONSET = I2C_CON_AA | I2C_CON_STA;
+
+	while ((rxLen < len) && (err == 0)) {
+		/* wait for status change interrupt */
+		while ( Chip_I2CM_StateChanged(pI2C) == 0) {}
+
+		/* check status and send data */
+		switch (Chip_I2CM_GetCurState(pI2C)) {
+		case 0x08:		/* Start condition on bus */
+		case 0x10:		/* Repeated start condition */
+		case 0x40:		/* SLA+R sent and ACK received */
+		case 0x50:		/* Data Received and ACK sent */
+			buff[rxLen++] = Chip_I2CM_ReadByte(pI2C);
+			break;
+
+		case 0x38:		/* Arbitration lost */
+			break;
+
+		default:		/* we shouldn't be in any other state */
+			err = 1;
+			break;
+		}
+		/* clear state change interrupt status */
+		Chip_I2CM_ClearSI(pI2C);
+	}
+
+	return rxLen;
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/i2s_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/i2s_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/i2s_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/i2s_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,264 @@
+/*
+ * @brief LPC18xx/43xx I2S driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Get divider value */
+STATIC Status getClkDiv(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format, uint16_t *pxDiv, uint16_t *pyDiv, uint32_t *pN)
+{
+	uint32_t pClk;
+	uint32_t x, y;
+	uint64_t divider;
+	uint16_t dif;
+	uint16_t xDiv = 0, yDiv = 0;
+	uint32_t N;
+	uint16_t err, ErrorOptimal = 0xFFFF;
+
+	pClk = Chip_Clock_GetRate(CLK_APB1_I2S);
+
+	/* divider is a fixed point number with 16 fractional bits */
+	divider = (((uint64_t) (format->SampleRate) * 2 * (format->WordWidth) * 2) << 16) / pClk;
+	/* find N that make x/y <= 1 -> divider <= 2^16 */
+	for (N = 64; N > 0; N--) {
+		if ((divider * N) < (1 << 16)) {
+			break;
+		}
+	}
+	if (N == 0) {
+		return ERROR;
+	}
+	divider *= N;
+	for (y = 255; y > 0; y--) {
+		x = y * divider;
+		if (x & (0xFF000000)) {
+			continue;
+		}
+		dif = x & 0xFFFF;
+		if (dif > 0x8000) {
+			err = 0x10000 - dif;
+		}
+		else {
+			err = dif;
+		}
+		if (err == 0) {
+			yDiv = y;
+			break;
+		}
+		else if (err < ErrorOptimal) {
+			ErrorOptimal = err;
+			yDiv = y;
+		}
+	}
+	xDiv = ((uint64_t) yDiv * (format->SampleRate) * 2 * (format->WordWidth) * N * 2) / pClk;
+	if (xDiv >= 256) {
+		xDiv = 0xFF;
+	}
+	if (xDiv == 0) {
+		xDiv = 1;
+	}
+
+	*pxDiv = xDiv;
+	*pyDiv = yDiv;
+	*pN = N;
+	return SUCCESS;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the I2S interface */
+void Chip_I2S_Init(LPC_I2S_T *pI2S)
+{
+	Chip_Clock_Enable(CLK_APB1_I2S);
+}
+
+/* Shutdown I2S */
+void Chip_I2S_DeInit(LPC_I2S_T *pI2S)
+{
+	pI2S->DAI = 0x07E1;
+	pI2S->DAO = 0x87E1;
+	pI2S->IRQ = 0;
+	pI2S->TXMODE = 0;
+	pI2S->RXMODE = 0;
+	pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] = 0;
+	pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] = 0;
+	Chip_Clock_Disable(CLK_APB1_I2S);
+}
+
+/* Configure I2S for Audio Format input */
+Status Chip_I2S_TxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format)
+{
+	uint32_t temp;
+	uint16_t xDiv, yDiv;
+	uint32_t N;
+
+	if (getClkDiv(pI2S, format, &xDiv, &yDiv, &N) == ERROR) {
+		return ERROR;
+	}
+
+	temp = pI2S->DAO & (~(I2S_DAO_WORDWIDTH_MASK | I2S_DAO_MONO | I2S_DAO_SLAVE | I2S_DAO_WS_HALFPERIOD_MASK));
+	if (format->WordWidth <= 8) {
+		temp |= I2S_WORDWIDTH_8;
+	}
+	else if (format->WordWidth <= 16) {
+		temp |= I2S_WORDWIDTH_16;
+	}
+	else {
+		temp |= I2S_WORDWIDTH_32;
+	}
+
+	temp |= (format->ChannelNumber) == 1 ? I2S_MONO : I2S_STEREO;
+	temp |= I2S_MASTER_MODE;
+	temp |= I2S_DAO_WS_HALFPERIOD(format->WordWidth - 1);
+	pI2S->DAO = temp;
+	pI2S->TXMODE = I2S_TXMODE_CLKSEL(0);
+	pI2S->TXBITRATE = N - 1;
+	pI2S->TXRATE = yDiv | (xDiv << 8);
+	return SUCCESS;
+}
+
+/* Configure I2S for Audio Format input */
+Status Chip_I2S_RxConfig(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *format)
+{
+	uint32_t temp;
+	uint16_t xDiv, yDiv;
+	uint32_t N;
+
+	if (getClkDiv(pI2S, format, &xDiv, &yDiv, &N) == ERROR) {
+		return ERROR;
+	}
+	temp = pI2S->DAI & (~(I2S_DAI_WORDWIDTH_MASK | I2S_DAI_MONO | I2S_DAI_SLAVE | I2S_DAI_WS_HALFPERIOD_MASK));
+	if (format->WordWidth <= 8) {
+		temp |= I2S_WORDWIDTH_8;
+	}
+	else if (format->WordWidth <= 16) {
+		temp |= I2S_WORDWIDTH_16;
+	}
+	else {
+		temp |= I2S_WORDWIDTH_32;
+	}
+
+	temp |= (format->ChannelNumber) == 1 ? I2S_MONO : I2S_STEREO;
+	temp |= I2S_MASTER_MODE;
+	temp |= I2S_DAI_WS_HALFPERIOD(format->WordWidth - 1);
+	pI2S->DAI = temp;
+	pI2S->RXMODE = I2S_RXMODE_CLKSEL(0);
+	pI2S->RXBITRATE = N - 1;
+	pI2S->RXRATE = yDiv | (xDiv << 8);
+	return SUCCESS;
+}
+
+/* Enable/Disable Interrupt with a specific FIFO depth */
+void Chip_I2S_Int_TxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth)
+{
+	uint32_t temp;
+	depth &= 0x0F;
+	if (newState == ENABLE) {
+	    temp = pI2S->IRQ & (~I2S_IRQ_TX_DEPTH_MASK);
+	    pI2S->IRQ = temp | (I2S_IRQ_TX_DEPTH(depth));
+		pI2S->IRQ |= 0x02;
+	}
+	else {
+		pI2S->IRQ &= (~0x02);
+	}
+}
+
+/* Enable/Disable Interrupt with a specific FIFO depth */
+void Chip_I2S_Int_RxCmd(LPC_I2S_T *pI2S, FunctionalState newState, uint8_t depth)
+{
+	uint32_t temp;
+	depth &= 0x0F;
+	if (newState == ENABLE) {
+	    temp = pI2S->IRQ & (~I2S_IRQ_RX_DEPTH_MASK);
+	    pI2S->IRQ = temp | (I2S_IRQ_RX_DEPTH(depth));
+		pI2S->IRQ |= 0x01;
+	}
+	else {
+		pI2S->IRQ &= (~0x01);
+	}
+}
+
+/* Enable/Disable DMA with a specific FIFO depth */
+void Chip_I2S_DMA_TxCmd(LPC_I2S_T *pI2S,
+						I2S_DMA_CHANNEL_T dmaNum,
+						FunctionalState newState,
+						uint8_t depth)
+{
+	/* Enable/Disable I2S transmit*/
+	if (newState == ENABLE) {
+	    /* Set FIFO Level */
+	    pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] &= ~(0x0F << 16);
+	    pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] |= depth << 16;
+		pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] |= 0x02;
+	}
+	else {
+		pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_1] &= ~0x02;
+	}
+}
+
+/* Enable/Disable DMA with a specific FIFO depth */
+void Chip_I2S_DMA_RxCmd(LPC_I2S_T *pI2S,
+						I2S_DMA_CHANNEL_T dmaNum,
+						FunctionalState newState,
+						uint8_t depth)
+{
+	
+	/* Enable/Disable I2S Receive */
+	if (newState == ENABLE) {
+	    /* Set FIFO Level */
+	    pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] &= ~(0x0F << 8);
+	    pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] |= depth << 8;
+		pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] |= 0x01;
+	}
+	else {
+		pI2S->DMA[I2S_DMA_REQUEST_CHANNEL_2] &= ~0x01;
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/iap_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/iap_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/iap_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/iap_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,211 @@
+/*
+ * @brief Common FLASH IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the IAP command interface */
+uint8_t Chip_IAP_Init(void)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = 49; /* IAP_INIT */
+	result[0] = IAP_CMD_SUCCESS;
+	iap_entry(command, result);
+	return result[0];
+}
+
+/* Prepare sector for write operation */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector, uint8_t flashBank)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_PREWRRITE_CMD;
+	command[1] = strSector;
+	command[2] = endSector;
+	command[3] = flashBank;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Copy RAM to flash */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_WRISECTOR_CMD;
+	command[1] = dstAdd;
+	command[2] = (uint32_t) srcAdd;
+	command[3] = byteswrt;
+	command[4] = SystemCoreClock / 1000;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Erase sector */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector, uint8_t flashBank)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_ERSSECTOR_CMD;
+	command[1] = strSector;
+	command[2] = endSector;
+	command[3] = SystemCoreClock / 1000;
+	command[4] = flashBank;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Blank check sector */
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector, uint8_t flashBank)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_BLANK_CHECK_SECTOR_CMD;
+	command[1] = strSector;
+	command[2] = endSector;
+	command[3] = flashBank;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Read part identification number */
+uint32_t Chip_IAP_ReadPID()
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_REPID_CMD;
+	iap_entry(command, result);
+
+	return result[1];
+}
+
+/* Read boot code version number */
+uint8_t Chip_IAP_ReadBootCode()
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_READ_BOOT_CODE_CMD;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* IAP compare */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_COMPARE_CMD;
+	command[1] = dstAdd;
+	command[2] = srcAdd;
+	command[3] = bytescmp;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Reinvoke ISP */
+uint8_t Chip_IAP_ReinvokeISP()
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_REINVOKE_ISP_CMD;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Read the unique ID */
+uint32_t Chip_IAP_ReadUID(uint32_t uid[])
+{
+	uint32_t command[5], result[5], i;
+
+	command[0] = IAP_READ_UID_CMD;
+	iap_entry(command, result);
+    for(i = 0; i < 4; i++) {
+      uid[i] = result[i + 1];
+    }
+
+	return result[0];
+}
+
+/* Erase page */
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_ERASE_PAGE_CMD;
+	command[1] = strPage;
+	command[2] = endPage;
+	command[3] = SystemCoreClock / 1000;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Set active boot flash bank */
+uint8_t Chip_IAP_SetBootFlashBank(uint8_t bankNum)
+{
+	uint32_t command[5], result[4];
+
+	command[0] = IAP_SET_BOOT_FLASH;
+	command[1] = bankNum;
+	command[2] = SystemCoreClock / 1000;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/lcd_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/lcd_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/lcd_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/lcd_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,212 @@
+/*
+ * @brief LPC18xx/43xx LCD chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+static LCD_CURSOR_SIZE_OPT_T LCD_Cursor_Size = LCD_CURSOR_64x64;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the LCD controller */
+void Chip_LCD_Init(LPC_LCD_T *pLCD, LCD_CONFIG_T *LCD_ConfigStruct)
+{
+	uint32_t i, regValue, *pPal;
+	uint32_t pcd;
+
+	/* Enable LCD Clock */
+	Chip_Clock_EnableOpts(CLK_MX_LCD, true, true, 1);
+
+	/* disable the display */
+	pLCD->CTRL &= ~CLCDC_LCDCTRL_ENABLE;
+
+	/* Setting LCD_TIMH register */
+	regValue = ( ((((LCD_ConfigStruct->PPL / 16) - 1) & 0x3F) << 2)
+				 |         (( (LCD_ConfigStruct->HSW - 1)    & 0xFF) << 8)
+				 |         (( (LCD_ConfigStruct->HFP - 1)    & 0xFF) << 16)
+				 |         (( (LCD_ConfigStruct->HBP - 1)    & 0xFF) << 24) );
+	pLCD->TIMH = regValue;
+
+	/* Setting LCD_TIMV register */
+	regValue = ((((LCD_ConfigStruct->LPP - 1) & 0x3FF) << 0)
+				|        (((LCD_ConfigStruct->VSW - 1) & 0x03F) << 10)
+				|        (((LCD_ConfigStruct->VFP - 1) & 0x0FF) << 16)
+				|        (((LCD_ConfigStruct->VBP - 1) & 0x0FF) << 24) );
+	pLCD->TIMV = regValue;
+
+	/* Generate the clock and signal polarity control word */
+	regValue = 0;
+	regValue = (((LCD_ConfigStruct->ACB - 1) & 0x1F) << 6);
+	regValue |= (LCD_ConfigStruct->IOE & 1) << 14;
+	regValue |= (LCD_ConfigStruct->IPC & 1) << 13;
+	regValue |= (LCD_ConfigStruct->IHS & 1) << 12;
+	regValue |= (LCD_ConfigStruct->IVS & 1) << 11;
+
+	/* Compute clocks per line based on panel type */
+	switch (LCD_ConfigStruct->LCD) {
+	case LCD_MONO_4:
+		regValue |= ((((LCD_ConfigStruct->PPL / 4) - 1) & 0x3FF) << 16);
+		break;
+
+	case LCD_MONO_8:
+		regValue |= ((((LCD_ConfigStruct->PPL / 8) - 1) & 0x3FF) << 16);
+		break;
+
+	case LCD_CSTN:
+		regValue |= (((((LCD_ConfigStruct->PPL * 3) / 8) - 1) & 0x3FF) << 16);
+		break;
+
+	case LCD_TFT:
+	default:
+		regValue |=	 /*1<<26 |*/ (((LCD_ConfigStruct->PPL - 1) & 0x3FF) << 16);
+	}
+
+	/* panel clock divisor */
+	pcd = 5;// LCD_ConfigStruct->pcd;   // TODO: should be calculated from LCDDCLK
+	pcd &= 0x3FF;
+	regValue |=  ((pcd >> 5) << 27) | ((pcd) & 0x1F);
+	pLCD->POL = regValue;
+
+	/* disable interrupts */
+	pLCD->INTMSK = 0;
+
+	/* set bits per pixel */
+	regValue = LCD_ConfigStruct->BPP << 1;
+
+	/* set color format RGB */
+	regValue |= LCD_ConfigStruct->color_format << 8;
+	regValue |= LCD_ConfigStruct->LCD << 4;
+	if (LCD_ConfigStruct->Dual == 1) {
+		regValue |= 1 << 7;
+	}
+	pLCD->CTRL = regValue;
+
+	/* clear palette */
+	pPal = (uint32_t *) (&(pLCD->PAL));
+	for (i = 0; i < 128; i++) {
+		*pPal = 0;
+		pPal++;
+	}
+}
+
+/* Shutdown the LCD controller */
+void Chip_LCD_DeInit(LPC_LCD_T *pLCD)
+{
+	Chip_Clock_Disable(CLK_MX_LCD);
+}
+
+/* Configure Cursor */
+void Chip_LCD_Cursor_Config(LPC_LCD_T *pLCD, LCD_CURSOR_SIZE_OPT_T cursor_size, bool sync)
+{
+	LCD_Cursor_Size = cursor_size;
+	pLCD->CRSR_CFG = ((sync ? 1 : 0) << 1) | cursor_size;
+}
+
+/* Write Cursor Image into Internal Cursor Image Buffer */
+void Chip_LCD_Cursor_WriteImage(LPC_LCD_T *pLCD, uint8_t cursor_num, void *Image)
+{
+	int i, j;
+	uint32_t *fifoptr, *crsr_ptr = (uint32_t *) Image;
+
+	/* Check if Cursor Size was configured as 32x32 or 64x64*/
+	if (LCD_Cursor_Size == LCD_CURSOR_32x32) {
+		i = cursor_num * 64;
+		j = i + 64;
+	}
+	else {
+		i = 0;
+		j = 256;
+	}
+	fifoptr = (void *) &(pLCD->CRSR_IMG[0]);
+
+	/* Copy Cursor Image content to FIFO */
+	for (; i < j; i++) {
+
+		*fifoptr = *crsr_ptr;
+		crsr_ptr++;
+		fifoptr++;
+	}
+}
+
+/* Load LCD Palette */
+void Chip_LCD_LoadPalette(LPC_LCD_T *pLCD, void *palette)
+{
+	LCD_PALETTE_ENTRY_T pal_entry = {0}; 
+	uint8_t i, *pal_ptr;
+	/* This function supports loading of the color palette from
+	   the C file generated by the bmp2c utility. It expects the
+	   palette to be passed as an array of 32-bit BGR entries having
+	   the following format:
+	   2:0 - Not used
+	   7:3 - Blue
+	   10:8 - Not used
+	   15:11 - Green
+	   18:16 - Not used
+	   23:19 - Red
+	   31:24 - Not used
+	   arg = pointer to input palette table address */
+	pal_ptr = (uint8_t *) palette;
+
+	/* 256 entry in the palette table */
+	for (i = 0; i < 256 / 2; i++) {
+		pal_entry.Bl = (*pal_ptr++) >> 3;	/* blue first */
+		pal_entry.Gl = (*pal_ptr++) >> 3;	/* get green */
+		pal_entry.Rl = (*pal_ptr++) >> 3;	/* get red */
+		pal_ptr++;	/* skip over the unused byte */
+		/* do the most significant halfword of the palette */
+		pal_entry.Bu = (*pal_ptr++) >> 3;	/* blue first */
+		pal_entry.Gu = (*pal_ptr++) >> 3;	/* get green */
+		pal_entry.Ru = (*pal_ptr++) >> 3;	/* get red */
+		pal_ptr++;	/* skip over the unused byte */
+
+		pLCD->PAL[i] = *((uint32_t *)&pal_entry);
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/otp_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/otp_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/otp_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/otp_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,151 @@
+/*
+ * @brief LPC18xx/43xx OTP Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define BOOTROM_BASE            0x10400100
+#define OTP_API_TABLE_OFFSET    0x1
+
+static unsigned long *BOOTROM_API_TABLE;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+static uint32_t (*Otp_ProgBootSrc)(CHIP_OTP_BOOT_SRC_T BootSrc);
+static uint32_t (*Otp_ProgJTAGDis)(void);
+static uint32_t (*Otp_ProgUSBID)(uint32_t ProductID, uint32_t VendorID);
+static uint32_t (*Otp_ProgGP0)(uint32_t Data, uint32_t Mask);
+static uint32_t (*Otp_ProgGP1)(uint32_t Data, uint32_t Mask);
+static uint32_t (*Otp_ProgGP2)(uint32_t Data, uint32_t Mask);
+static uint32_t (*Otp_ProgKey1)(uint8_t *key);
+static uint32_t (*Otp_ProgKey2)(uint8_t *key);
+static uint32_t (*Otp_GenRand)(void);
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* CHIP OTP Initialisation function */
+uint32_t Chip_OTP_Init(void)
+{
+	uint32_t (*ROM_otp_Init)(void);
+
+	BOOTROM_API_TABLE = *((unsigned long * *) BOOTROM_BASE + OTP_API_TABLE_OFFSET);
+
+	ROM_otp_Init      = (uint32_t (*)(void))BOOTROM_API_TABLE[0];
+	Otp_ProgBootSrc   = (uint32_t (*)(CHIP_OTP_BOOT_SRC_T BootSrc))BOOTROM_API_TABLE[1];
+	Otp_ProgJTAGDis   = (uint32_t (*)(void))BOOTROM_API_TABLE[2];
+	Otp_ProgUSBID     = (uint32_t (*)(uint32_t ProductID, uint32_t VendorID))BOOTROM_API_TABLE[3];
+	Otp_ProgGP0       = (uint32_t (*)(uint32_t Data, uint32_t Mask))BOOTROM_API_TABLE[8];
+	Otp_ProgGP1       = (uint32_t (*)(uint32_t Data, uint32_t Mask))BOOTROM_API_TABLE[9];
+	Otp_ProgGP2       = (uint32_t (*)(uint32_t Data, uint32_t Mask))BOOTROM_API_TABLE[10];
+	Otp_ProgKey1      = (uint32_t (*)(uint8_t *key))BOOTROM_API_TABLE[11];
+	Otp_ProgKey2      = (uint32_t (*)(uint8_t *key))BOOTROM_API_TABLE[12];
+	Otp_GenRand       = (uint32_t (*)(void))BOOTROM_API_TABLE[13];
+
+	return ROM_otp_Init();
+}
+
+/* Program boot source in OTP Controller */
+uint32_t Chip_OTP_ProgBootSrc(CHIP_OTP_BOOT_SRC_T BootSrc)
+{
+	return Otp_ProgBootSrc(BootSrc);
+}
+
+/* Program the JTAG bit in OTP Controller */
+uint32_t Chip_OTP_ProgJTAGDis(void)
+{
+	return Otp_ProgJTAGDis();
+}
+
+/* Program USB ID in OTP Controller */
+uint32_t Chip_OTP_ProgUSBID(uint32_t ProductID, uint32_t VendorID)
+{
+	return Otp_ProgUSBID(ProductID, VendorID);
+}
+
+/* Program OTP GP Word memory */
+uint32_t Chip_OTP_ProgGPWord(uint32_t WordNum, uint32_t Data, uint32_t Mask)
+{
+	uint32_t status;
+
+	switch (WordNum) {
+	case 1:
+		status = Otp_ProgGP1(Data, Mask);
+		break;
+
+	case 2:
+		status = Otp_ProgGP2(Data, Mask);
+		break;
+
+	case 0:
+	default:
+		status = Otp_ProgGP0(Data, Mask);
+		break;
+	}
+
+	return status;
+}
+
+/* Program AES Key */
+uint32_t Chip_OTP_ProgKey(uint32_t KeyNum, uint8_t *key)
+{
+	uint32_t status;
+
+	if (KeyNum) {
+		status = Otp_ProgKey2(key);
+	}
+	else {
+		status = Otp_ProgKey1(key);
+	}
+	return status;
+}
+
+/* Generate Random Number using HW Random Number Generator */
+uint32_t Chip_OTP_GenRand(void)
+{
+	return Otp_GenRand();
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/pinint_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/pinint_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/pinint_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/pinint_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,54 @@
+/*
+ * @brief LPC18xx/43xx Pin Interrupt and Pattern Match driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/pmc_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/pmc_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/pmc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/pmc_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,75 @@
+/*
+ * @brief LPC18xx/43xx Power Management Controller driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set to sleep mode */
+void Chip_PMC_Sleep(void)
+{
+	/* Sleep Mode*/
+	__WFI();
+}
+
+/* Set power state */
+void Chip_PMC_Set_PwrState(CHIP_PMC_PWR_STATE_T PwrState)
+{
+
+	/* Set Deep sleep mode bit in System Control register of M4 core */
+	SCB->SCR = 0x4;
+
+	/* Set power state in PMC */
+	LPC_PMC->PD0_SLEEP0_MODE = (uint32_t) PwrState;
+
+	__WFI();
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ring_buffer.c ./libs/vendor_libs/lpc_chip_43xx/src/ring_buffer.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ring_buffer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/ring_buffer.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,173 @@
+/*
+ * @brief Common ring buffer support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include <string.h>
+#include "ring_buffer.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define RB_INDH(rb)                ((rb)->head & ((rb)->count - 1))
+#define RB_INDT(rb)                ((rb)->tail & ((rb)->count - 1))
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize ring buffer */
+int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
+{
+	RingBuff->data = buffer;
+	RingBuff->count = count;
+	RingBuff->itemSz = itemSize;
+	RingBuff->head = RingBuff->tail = 0;
+
+	return 1;
+}
+
+/* Insert a single item into Ring Buffer */
+int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
+{
+	uint8_t *ptr = RingBuff->data;
+
+	/* We cannot insert when queue is full */
+	if (RingBuffer_IsFull(RingBuff))
+		return 0;
+
+	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
+	memcpy(ptr, data, RingBuff->itemSz);
+	RingBuff->head++;
+
+	return 1;
+}
+
+/* Insert multiple items into Ring Buffer */
+int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num)
+{
+	uint8_t *ptr = RingBuff->data;
+	int cnt1, cnt2;
+
+	/* We cannot insert when queue is full */
+	if (RingBuffer_IsFull(RingBuff))
+		return 0;
+
+	/* Calculate the segment lengths */
+	cnt1 = cnt2 = RingBuffer_GetFree(RingBuff);
+	if (RB_INDH(RingBuff) + cnt1 >= RingBuff->count)
+		cnt1 = RingBuff->count - RB_INDH(RingBuff);
+	cnt2 -= cnt1;
+
+	cnt1 = MIN(cnt1, num);
+	num -= cnt1;
+
+	cnt2 = MIN(cnt2, num);
+	num -= cnt2;
+
+	/* Write segment 1 */
+	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
+	memcpy(ptr, data, cnt1 * RingBuff->itemSz);
+	RingBuff->head += cnt1;
+
+	/* Write segment 2 */
+	ptr = (uint8_t *) RingBuff->data + RB_INDH(RingBuff) * RingBuff->itemSz;
+	data = (const uint8_t *) data + cnt1 * RingBuff->itemSz;
+	memcpy(ptr, data, cnt2 * RingBuff->itemSz);
+	RingBuff->head += cnt2;
+
+	return cnt1 + cnt2;
+}
+
+/* Pop single item from Ring Buffer */
+int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data)
+{
+	uint8_t *ptr = RingBuff->data;
+
+	/* We cannot pop when queue is empty */
+	if (RingBuffer_IsEmpty(RingBuff))
+		return 0;
+
+	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
+	memcpy(data, ptr, RingBuff->itemSz);
+	RingBuff->tail++;
+
+	return 1;
+}
+
+/* Pop multiple items from Ring buffer */
+int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num)
+{
+	uint8_t *ptr = RingBuff->data;
+	int cnt1, cnt2;
+
+	/* We cannot insert when queue is empty */
+	if (RingBuffer_IsEmpty(RingBuff))
+		return 0;
+
+	/* Calculate the segment lengths */
+	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
+	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
+		cnt1 = RingBuff->count - RB_INDT(RingBuff);
+	cnt2 -= cnt1;
+
+	cnt1 = MIN(cnt1, num);
+	num -= cnt1;
+
+	cnt2 = MIN(cnt2, num);
+	num -= cnt2;
+
+	/* Write segment 1 */
+	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
+	memcpy(data, ptr, cnt1 * RingBuff->itemSz);
+	RingBuff->tail += cnt1;
+
+	/* Write segment 2 */
+	ptr = (uint8_t *) RingBuff->data + RB_INDT(RingBuff) * RingBuff->itemSz;
+	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
+	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
+	RingBuff->tail += cnt2;
+
+	return cnt1 + cnt2;
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ritimer_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/ritimer_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ritimer_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/ritimer_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,103 @@
+/*
+ * @brief LPC18xx/43xx RITimer chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the RIT */
+void Chip_RIT_Init(LPC_RITIMER_T *pRITimer)
+{
+	Chip_Clock_EnableOpts(CLK_MX_RITIMER, true, true, 1);
+	pRITimer->COMPVAL = 0xFFFFFFFF;
+	pRITimer->MASK  = 0x00000000;
+	pRITimer->CTRL  = 0x0C;
+	pRITimer->COUNTER   = 0x00000000;
+}
+
+/* DeInitialize the RIT */
+void Chip_RIT_DeInit(LPC_RITIMER_T *pRITimer)
+{
+	Chip_RIT_Init(pRITimer);
+	Chip_Clock_Disable(CLK_MX_RITIMER);
+}
+
+/* Set timer interval value */
+void Chip_RIT_SetTimerInterval(LPC_RITIMER_T *pRITimer, uint32_t time_interval)
+{
+	uint32_t cmp_value;
+
+	/* Determine aapproximate compare value based on clock rate and passed interval */
+	cmp_value = (Chip_Clock_GetRate(CLK_MX_RITIMER) / 1000) * time_interval;
+
+	/* Set timer compare value */
+	Chip_RIT_SetCOMPVAL(pRITimer, cmp_value);
+
+	/* Set timer enable clear bit to clear timer to 0 whenever
+	   counter value equals the contents of RICOMPVAL */
+	Chip_RIT_EnableCTRL(pRITimer, RIT_CTRL_ENCLR);
+}
+
+/* Check whether interrupt is pending */
+IntStatus Chip_RIT_GetIntStatus(LPC_RITIMER_T *pRITimer)
+{
+	uint8_t result;
+
+	if ((pRITimer->CTRL & RIT_CTRL_INT) == 1) {
+		result = SET;
+	}
+	else {
+		return RESET;
+	}
+
+	return (IntStatus) result;
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/rtc_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/rtc_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/rtc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/rtc_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,226 @@
+/*
+ * @brief LPC18xx/43xx RTC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the RTC peripheral */
+void Chip_RTC_Init(LPC_RTC_T *pRTC)
+{
+	Chip_Clock_RTCEnable();
+
+	/* 2-Second delay after enabling RTC clock */
+	LPC_ATIMER->DOWNCOUNTER = 2048;
+	while (LPC_ATIMER->DOWNCOUNTER);
+
+	/* Disable RTC */
+	Chip_RTC_Enable(pRTC, DISABLE);
+
+	/* Disable Calibration */
+	Chip_RTC_CalibCounterCmd(pRTC, DISABLE);
+
+	/* Reset RTC Clock */
+	Chip_RTC_ResetClockTickCounter(pRTC);
+
+	/* Clear counter increment and alarm interrupt */
+	pRTC->ILR = RTC_IRL_RTCCIF | RTC_IRL_RTCALF;
+	while (pRTC->ILR != 0) {}
+
+	/* Clear all register to be default */
+	pRTC->CIIR = 0x00;
+	pRTC->AMR = 0xFF;
+	pRTC->CALIBRATION = 0x00;
+}
+
+/*De-initialize the RTC peripheral */
+void Chip_RTC_DeInit(LPC_RTC_T *pRTC)
+{
+	pRTC->CCR = 0x00;
+}
+
+/* Reset clock tick counter in the RTC peripheral */
+void Chip_RTC_ResetClockTickCounter(LPC_RTC_T *pRTC)
+{
+	/* Reset RTC clock*/
+	pRTC->CCR |= RTC_CCR_CTCRST;
+	while (!(pRTC->CCR & RTC_CCR_CTCRST)) {}
+
+	/* Finish resetting RTC clock */
+	pRTC->CCR = (pRTC->CCR & ~RTC_CCR_CTCRST) & RTC_CCR_BITMASK;
+	while (pRTC->CCR & RTC_CCR_CTCRST) {}
+}
+
+/* Start/Stop RTC peripheral */
+void Chip_RTC_Enable(LPC_RTC_T *pRTC, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		pRTC->CCR |= RTC_CCR_CLKEN;
+	} else {
+		pRTC->CCR = (pRTC->CCR & ~RTC_CCR_CLKEN) & RTC_CCR_BITMASK;
+	}
+}
+
+/* Enable/Disable Counter increment interrupt for a time type in the RTC peripheral */
+void Chip_RTC_CntIncrIntConfig(LPC_RTC_T *pRTC, uint32_t cntrMask, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		pRTC->CIIR |= cntrMask;
+	}
+
+	else {
+		pRTC->CIIR &= (~cntrMask) & RTC_AMR_CIIR_BITMASK;
+		while (pRTC->CIIR & cntrMask) {}
+	}
+}
+
+/* Enable/Disable Alarm interrupt for a time type in the RTC peripheral */
+void Chip_RTC_AlarmIntConfig(LPC_RTC_T *pRTC, uint32_t alarmMask, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		pRTC->AMR &= (~alarmMask) & RTC_AMR_CIIR_BITMASK;
+	}
+	else {
+		pRTC->AMR |= (alarmMask);
+		while ((pRTC->AMR & alarmMask) == 0) {}
+	}
+}
+
+/* Set full time in the RTC peripheral */
+void Chip_RTC_SetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+	RTC_TIMEINDEX_T i;
+	uint32_t ccr_val = pRTC->CCR;
+
+	/* Temporarily disable */
+	if (ccr_val & RTC_CCR_CLKEN) {
+		pRTC->CCR = ccr_val & (~RTC_CCR_CLKEN) & RTC_CCR_BITMASK;
+	}
+
+	/* Date time setting */
+	for (i = RTC_TIMETYPE_SECOND; i < RTC_TIMETYPE_LAST; i++) {
+		pRTC->TIME[i] = pFullTime->time[i];
+	}
+
+	/* Restore to old setting */
+	pRTC->CCR = ccr_val;
+}
+
+/* Get full time from the RTC peripheral */
+void Chip_RTC_GetFullTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+	RTC_TIMEINDEX_T i;
+	uint32_t secs = 0xFF;
+
+	/* Read full time, but verify second tick didn't change during the read. If
+	   it did, re-read the time again so it will be consistent across all fields. */
+	while (secs != pRTC->TIME[RTC_TIMETYPE_SECOND]) {
+		secs = pFullTime->time[RTC_TIMETYPE_SECOND] = pRTC->TIME[RTC_TIMETYPE_SECOND];
+		for (i = RTC_TIMETYPE_MINUTE; i < RTC_TIMETYPE_LAST; i++) {
+			pFullTime->time[i] = pRTC->TIME[i];
+		}
+	}
+}
+
+/* Set full alarm time in the RTC peripheral */
+void Chip_RTC_SetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+	RTC_TIMEINDEX_T i;
+
+	for (i = RTC_TIMETYPE_SECOND; i < RTC_TIMETYPE_LAST; i++) {
+		pRTC->ALRM[i] = pFullTime->time[i];
+	}
+}
+
+/* Get full alarm time in the RTC peripheral */
+void Chip_RTC_GetFullAlarmTime(LPC_RTC_T *pRTC, RTC_TIME_T *pFullTime)
+{
+	RTC_TIMEINDEX_T i;
+
+	for (i = RTC_TIMETYPE_SECOND; i < RTC_TIMETYPE_LAST; i++) {
+		pFullTime->time[i] = pRTC->ALRM[i];
+	}
+}
+
+/* Enable/Disable calibration counter in the RTC peripheral */
+void Chip_RTC_CalibCounterCmd(LPC_RTC_T *pRTC, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		do {
+			pRTC->CCR &= (~RTC_CCR_CCALEN) & RTC_CCR_BITMASK;
+		} while (pRTC->CCR & RTC_CCR_CCALEN);
+	}
+	else {
+		pRTC->CCR |= RTC_CCR_CCALEN;
+	}
+}
+
+#if RTC_EV_SUPPORT
+/* Get first timestamp value */
+void Chip_RTC_EV_GetFirstTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp)
+{
+	pTimeStamp->sec = RTC_ER_TIMESTAMP_SEC(pRTC->ERFIRSTSTAMP[ch]);
+	pTimeStamp->min = RTC_ER_TIMESTAMP_MIN(pRTC->ERFIRSTSTAMP[ch]);
+	pTimeStamp->hour = RTC_ER_TIMESTAMP_HOUR(pRTC->ERFIRSTSTAMP[ch]);
+	pTimeStamp->dayofyear = RTC_ER_TIMESTAMP_DOY(pRTC->ERFIRSTSTAMP[ch]);
+}
+
+/* Get last timestamp value */
+void Chip_RTC_EV_GetLastTimeStamp(LPC_RTC_T *pRTC, RTC_EV_CHANNEL_T ch, RTC_EV_TIMESTAMP_T *pTimeStamp)
+{
+	pTimeStamp->sec = RTC_ER_TIMESTAMP_SEC(pRTC->ERLASTSTAMP[ch]);
+	pTimeStamp->min = RTC_ER_TIMESTAMP_MIN(pRTC->ERLASTSTAMP[ch]);
+	pTimeStamp->hour = RTC_ER_TIMESTAMP_HOUR(pRTC->ERLASTSTAMP[ch]);
+	pTimeStamp->dayofyear = RTC_ER_TIMESTAMP_DOY(pRTC->ERLASTSTAMP[ch]);
+}
+
+#endif /*RTC_EV_SUPPORT*/
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sct_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/sct_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sct_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/sct_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,93 @@
+/*
+ * @brief LPC18xx/43xx State Configurable Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize SCT */
+void Chip_SCT_Init(LPC_SCT_T *pSCT)
+{
+	Chip_Clock_EnableOpts(CLK_MX_SCT, true, true, 1);
+}
+
+/* Shutdown SCT */
+void Chip_SCT_DeInit(LPC_SCT_T *pSCT)
+{
+	Chip_Clock_Disable(CLK_MX_SCT);
+}
+
+/* Set/Clear SCT control register */
+void Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena)
+{
+	uint32_t tem;
+
+	tem = pSCT->CTRL_U;
+	if (ena == ENABLE) {
+		tem |= value;
+	}
+	else {
+		tem &= (~value);
+	}
+	pSCT->CTRL_U = tem;
+}
+
+/* Set Conflict resolution */
+void Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value)
+{
+	uint32_t tem;
+
+	tem = pSCT->RES;
+	tem &= ~(0x03 << (2 * outnum));
+	tem |= (value << (2 * outnum));
+	pSCT->RES = tem;
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sct_pwm_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/sct_pwm_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sct_pwm_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/sct_pwm_18xx_43xx.c	2018-12-01 17:15:06.669606793 -0300
@@ -0,0 +1,93 @@
+/*
+ * @brief LPC18xx_43xx State Configurable Timer PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Setup the OUTPUT pin corresponding to the PWM index */
+void Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin)
+{
+	int ix = (int) index;
+	pSCT->EVENT[ix].CTRL = index | (1 << 12);
+	pSCT->EVENT[ix].STATE = 1;
+	pSCT->OUT[pin].SET = 1;
+	pSCT->OUT[pin].CLR = 1 << ix;
+
+	/* Clear the output in-case of conflict */
+	pSCT->RES = (pSCT->RES & ~(3 << (pin << 1))) | (0x01 << (pin << 1));
+
+	/* Set and Clear do not depend on direction */
+	pSCT->OUTPUTDIRCTRL = (pSCT->OUTPUTDIRCTRL & ~(3 << (pin << 1)));
+}
+
+/* Set the PWM frequency */
+void Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq)
+{
+	uint32_t rate;
+
+	rate = Chip_Clock_GetRate(CLK_MX_SCT) / freq;;
+
+	/* Stop the SCT before configuration */
+	Chip_SCTPWM_Stop(pSCT);
+
+	/* Set MATCH0 for max limit */
+	pSCT->REGMODE_L = 0;
+	pSCT->REGMODE_H = 0;
+	Chip_SCT_SetMatchCount(pSCT, SCT_MATCH_0, 0);
+	Chip_SCT_SetMatchReload(pSCT, SCT_MATCH_0, rate);
+	pSCT->EVENT[0].CTRL = 1 << 12;
+	pSCT->EVENT[0].STATE = 1;
+	pSCT->LIMIT_L = 1;
+
+	/* Set SCT Counter to count 32-bits and reset to 0 after reaching MATCH0 */
+	Chip_SCT_Config(pSCT, SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_AUTOLIMIT_L);
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sdif_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/sdif_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sdif_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/sdif_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,229 @@
+/*
+ * @brief LPC18xx/43xx SD/SDIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "string.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the SD/MMC controller */
+void Chip_SDIF_Init(LPC_SDMMC_T *pSDMMC)
+{
+    /* Enable SDIO module clock */
+	Chip_Clock_EnableOpts(CLK_MX_SDIO, true, true, 1);
+	
+    /* Software reset */
+	pSDMMC->BMOD = MCI_BMOD_SWR;
+
+	/* reset all blocks */
+	pSDMMC->CTRL = MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET | MCI_CTRL_DMA_RESET;
+	while (pSDMMC->CTRL & (MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET | MCI_CTRL_DMA_RESET)) {}
+
+	/* Internal DMA setup for control register */
+	pSDMMC->CTRL = MCI_CTRL_USE_INT_DMAC | MCI_CTRL_INT_ENABLE;
+	pSDMMC->INTMASK = 0;
+
+	/* Clear the interrupts for the host controller */
+	pSDMMC->RINTSTS = 0xFFFFFFFF;
+
+	/* Put in max timeout */
+	pSDMMC->TMOUT = 0xFFFFFFFF;
+
+	/* FIFO threshold settings for DMA, DMA burst of 4,   FIFO watermark at 16 */
+	pSDMMC->FIFOTH = MCI_FIFOTH_DMA_MTS_4 | MCI_FIFOTH_RX_WM((SD_FIFO_SZ / 2) - 1) | MCI_FIFOTH_TX_WM(SD_FIFO_SZ / 2);
+
+	/* Enable internal DMA, burst size of 4, fixed burst */
+	pSDMMC->BMOD = MCI_BMOD_DE | MCI_BMOD_PBL4 | MCI_BMOD_DSL(4);
+
+	/* disable clock to CIU (needs latch) */
+	pSDMMC->CLKENA = 0;
+	pSDMMC->CLKSRC = 0;
+}
+
+/* Shutdown the SD/MMC controller */
+void Chip_SDIF_DeInit(LPC_SDMMC_T *pSDMMC)
+{
+    /* Disable the clock */
+	Chip_Clock_Disable(CLK_MX_SDIO);
+}
+
+/* Function to send command to Card interface unit (CIU) */
+int32_t Chip_SDIF_SendCmd(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg)
+{
+	volatile int32_t tmo = 50;
+	volatile int delay;
+
+	/* set command arg reg*/
+	pSDMMC->CMDARG = arg;
+	pSDMMC->CMD = MCI_CMD_START | cmd;
+
+	/* poll untill command is accepted by the CIU */
+	while (--tmo && (pSDMMC->CMD & MCI_CMD_START)) {
+		if (tmo & 1) {
+			delay = 50;
+		}
+		else {
+			delay = 18000;
+		}
+
+		while (--delay > 1) {}
+	}
+
+	return (tmo < 1) ? 1 : 0;
+}
+
+/* Read the response from the last command */
+void Chip_SDIF_GetResponse(LPC_SDMMC_T *pSDMMC, uint32_t *resp)
+{
+	/* on this chip response is not a fifo so read all 4 regs */
+	resp[0] = pSDMMC->RESP0;
+	resp[1] = pSDMMC->RESP1;
+	resp[2] = pSDMMC->RESP2;
+	resp[3] = pSDMMC->RESP3;
+}
+
+/* Sets the SD bus clock speed */
+void Chip_SDIF_SetClock(LPC_SDMMC_T *pSDMMC, uint32_t clk_rate, uint32_t speed)
+{
+	/* compute SD/MMC clock dividers */
+	uint32_t div;
+
+	div = ((clk_rate / speed) + 2) >> 1;
+
+	if ((div == pSDMMC->CLKDIV) && pSDMMC->CLKENA) {
+		return;	/* Closest speed is already set */
+
+	}
+	/* disable clock */
+	pSDMMC->CLKENA = 0;
+
+	/* User divider 0 */
+	pSDMMC->CLKSRC = MCI_CLKSRC_CLKDIV0;
+
+	/* inform CIU */
+	Chip_SDIF_SendCmd(pSDMMC, MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+
+	/* set divider 0 to desired value */
+	pSDMMC->CLKDIV = MCI_CLOCK_DIVIDER(0, div);
+
+	/* inform CIU */
+	Chip_SDIF_SendCmd(pSDMMC, MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+
+	/* enable clock */
+	pSDMMC->CLKENA = MCI_CLKEN_ENABLE;
+
+	/* inform CIU */
+	Chip_SDIF_SendCmd(pSDMMC, MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+}
+
+/* Function to clear interrupt & FIFOs */
+void Chip_SDIF_SetClearIntFifo(LPC_SDMMC_T *pSDMMC)
+{
+	/* reset all blocks */
+	pSDMMC->CTRL |= MCI_CTRL_FIFO_RESET;
+
+	/* wait till resets clear */
+	while (pSDMMC->CTRL & MCI_CTRL_FIFO_RESET) {}
+
+	/* Clear interrupt status */
+	pSDMMC->RINTSTS = 0xFFFFFFFF;
+}
+
+/* Setup DMA descriptors */
+void Chip_SDIF_DmaSetup(LPC_SDMMC_T *pSDMMC, sdif_device *psdif_dev, uint32_t addr, uint32_t size)
+{
+	int i = 0;
+	uint32_t ctrl, maxs;
+
+	/* Reset DMA */
+	pSDMMC->CTRL |= MCI_CTRL_DMA_RESET | MCI_CTRL_FIFO_RESET;
+	while (pSDMMC->CTRL & MCI_CTRL_DMA_RESET) {}
+
+	/* Build a descriptor list using the chained DMA method */
+	while (size > 0) {
+		/* Limit size of the transfer to maximum buffer size */
+		maxs = size;
+		if (maxs > MCI_DMADES1_MAXTR) {
+			maxs = MCI_DMADES1_MAXTR;
+		}
+		size -= maxs;
+
+		/* Set buffer size */
+		psdif_dev->mci_dma_dd[i].des1 = MCI_DMADES1_BS1(maxs);
+
+		/* Setup buffer address (chained) */
+		psdif_dev->mci_dma_dd[i].des2 = addr + (i * MCI_DMADES1_MAXTR);
+
+		/* Setup basic control */
+		ctrl = MCI_DMADES0_OWN | MCI_DMADES0_CH;
+		if (i == 0) {
+			ctrl |= MCI_DMADES0_FS;	/* First DMA buffer */
+
+		}
+		/* No more data? Then this is the last descriptor */
+		if (!size) {
+			ctrl |= MCI_DMADES0_LD;
+		}
+		else {
+			ctrl |= MCI_DMADES0_DIC;
+		}
+
+		/* Another descriptor is needed */
+		psdif_dev->mci_dma_dd[i].des3 = (uint32_t) &psdif_dev->mci_dma_dd[i + 1];
+		psdif_dev->mci_dma_dd[i].des0 = ctrl;
+
+		i++;
+	}
+
+	/* Set DMA derscriptor base address */
+	pSDMMC->DBADDR = (uint32_t) &psdif_dev->mci_dma_dd[0];
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sdio_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/sdio_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sdio_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/sdio_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,524 @@
+/*
+ * @brief LPC18xx/43xx SDIO Card driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define SDIO_CMD_INT_MSK    0xA146       /* Interrupts to be enabled for CMD */
+#define SDIO_DATA_INT_MSK   0xBE88       /* Interrupts to enable for data transfer */
+#define SDIO_CARD_INT_MSK   (1UL << 16)  /* SDIO Card interrupt */
+
+static struct
+{
+	void (*wake_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg);
+	uint32_t (*wait_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg);
+	uint32_t flag;
+	uint32_t response[4];
+	int fnum;
+	uint16_t blkSz[8];     /* Block size setting for the 8- function blocks */
+	sdif_device sdev;      /* SDIO interface device structure */
+}sdio_context, *sdioif = &sdio_context;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Set the SDIO Card voltage level to 3v3 */
+static int SDIO_Card_SetVoltage(LPC_SDMMC_T *pSDMMC)
+{
+	int ret, i;
+	uint32_t val;
+
+	ret = SDIO_Send_Command(pSDMMC, CMD5, 0);
+	if (ret) return ret;
+	val = sdioif->response[0];
+
+	/* Number of functions supported by the card */
+	sdioif->fnum = (val >> 28) & 7;
+
+	/* Check number of I/O functions*/
+	if(sdioif->fnum == 0) {
+		/* Number of I/O functions */
+		return SDIO_ERR_FNUM;
+	}
+
+	/* ---- check OCR ---- */
+	if((val & SDIO_VOLT_3_3) == 0){
+		/* invalid voltage */
+		return SDIO_ERR_VOLT;
+	}
+
+	/* ==== send CMD5 write new voltage  === */
+	for(i = 0; i < 100; i++){
+		ret = SDIO_Send_Command(pSDMMC, CMD5, SDIO_VOLT_3_3);
+		if (ret) return ret;
+		val = sdioif->response[0];
+
+		/* Is card ready ? */
+		if(val & (1UL << 31)){
+			break;
+		}
+
+		sdioif->wait_evt(pSDMMC, SDIO_WAIT_DELAY, (void *)10);
+	}
+
+	/* ==== Check C bit  ==== */
+	if(val & (1UL << 31)){
+		return 0;
+	}
+
+	return SDIO_ERR_VOLT; /* error end */
+}
+
+/* Set SDIO Card RCA */
+static int SDIO_CARD_SetRCA(LPC_SDMMC_T *pSDMMC)
+{
+	int ret;
+
+	/* ==== send CMD3 get RCA  ==== */
+	ret = SDIO_Send_Command(pSDMMC, CMD3, 0);
+	if (ret) return ret;
+
+	/* R6 response to CMD3 */
+	if((sdioif->response[0] & 0x0000e000) != 0){
+						/* COM_CRC_ERROR */
+						/* ILLEGAL_CRC_ERROR */
+						/* ERROR */
+		return SDIO_ERR_RCA;
+	}
+
+	/* change card state */
+	sdioif->flag |= SDIO_POWER_INIT;
+
+	/* New published RCA */
+	sdioif->response[0] &= 0xffff0000;
+
+	/* ==== change state to Stanby State ==== */
+	return SDIO_Send_Command(pSDMMC, CMD7, sdioif->response[0]);
+}
+
+/* Set the Clock speed and mode [1/4 bit] of the card */
+static int SDIO_Card_SetMode(LPC_SDMMC_T *pSDMMC, uint32_t clk, int mode_4bit)
+{
+	int ret;
+	uint32_t val;
+
+	Chip_SDIF_SetClock(pSDMMC, Chip_Clock_GetBaseClocktHz(CLK_BASE_SDIO), clk);
+
+	if (!mode_4bit)
+		return 0;
+
+	val = 0x02;
+	ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, 0x07, &val);
+	if (ret) return ret;
+
+	if (val & 0x02) {
+		Chip_SDIF_SetCardType(pSDMMC, MCI_CTYPE_4BIT);
+	}
+	return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Set the block size of a function */
+int SDIO_Card_SetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t blkSize)
+{
+	int ret;
+	uint32_t tmp, asz;
+	if (func > sdioif->fnum)
+		return SDIO_ERR_INVFUNC;
+
+	if (blkSize > 2048)
+		return SDIO_ERR_INVARG;
+
+	tmp = blkSize & 0xFF;
+	ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, (func << 8) + 0x10, &tmp);
+	if (ret) return ret;
+	asz = tmp;
+
+	tmp = blkSize >> 8;
+	ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, (func << 8) + 0x11, &tmp);
+	if (ret) return ret;
+	asz |= tmp << 8;
+	sdioif->blkSz[func] = asz;
+	return 0;
+}
+
+/* Get the block size of a particular function */
+uint32_t SDIO_Card_GetBlockSize(LPC_SDMMC_T *pSDMMC, uint32_t func)
+{
+	if (func > sdioif->fnum)
+		return 0;
+
+	return sdioif->blkSz[func];
+}
+
+/* Write data to SDIO Card */
+int SDIO_Card_WriteData(LPC_SDMMC_T *pSDMMC, uint32_t func,
+	uint32_t dest_addr, const uint8_t *src_addr,
+	uint32_t size, uint32_t flags)
+{
+	int ret;
+	uint32_t bs = size, bsize = size;
+	uint32_t cmd = CMD53 | (1UL << 10);
+
+	if (func > sdioif->fnum)
+		return SDIO_ERR_INVFUNC;
+
+	if (bsize > 512 || bsize == 0)
+		return SDIO_ERR_INVARG;
+
+	if (flags & SDIO_MODE_BLOCK) {
+		uint32_t bs = SDIO_Card_GetBlockSize(pSDMMC, func);
+		if (!bs) return SDIO_ERR_INVARG;
+		size *= bs;
+	}
+
+	/* Set Block Size */
+	Chip_SDIF_SetBlkSize(pSDMMC, bs);
+
+	/* set number of bytes to read */
+	Chip_SDIF_SetByteCnt(pSDMMC, size);
+
+	sdioif->wait_evt(pSDMMC, SDIO_START_DATA, 0);
+	Chip_SDIF_DmaSetup(pSDMMC, &sdioif->sdev, (uint32_t) src_addr, size);
+
+	ret = SDIO_Send_Command(pSDMMC, cmd, (func << 28) | (dest_addr << 9) | (bsize & 0x1FF) | (1UL << 31) | (flags & (0x3 << 26)));
+	if (ret) return ret;
+
+	/* Check response for errors */
+	if(sdioif->response[0] & 0xcb00){
+						/* COM_CRC_ERROR */
+						/* ILLEGAL_CRC_ERROR */
+						/* ERROR */
+						/* RFU FUNCTION_NUMBER */
+						/* OUT_OF_RANGE */
+		/* Response flag error */
+		return SDIO_ERR_READWRITE;
+	}
+	return sdioif->wait_evt(pSDMMC, SDIO_WAIT_DATA, 0);
+}
+
+/* Write data to SDIO Card */
+int SDIO_Card_ReadData(LPC_SDMMC_T *pSDMMC, uint32_t func, uint8_t *dest_addr, uint32_t src_addr, uint32_t size, uint32_t flags)
+{
+	int ret;
+	uint32_t bs = size, bsize = size;
+	uint32_t cmd = CMD53;
+
+	if (func > sdioif->fnum)
+		return SDIO_ERR_INVFUNC;
+
+	if (bsize > 512 || bsize == 0)
+		return SDIO_ERR_INVARG;
+
+	if (flags & SDIO_MODE_BLOCK) {
+		bs = SDIO_Card_GetBlockSize(pSDMMC, func);
+		if (!bs) return SDIO_ERR_INVARG;
+		size *= bs;
+	}
+	/* Set the block size */
+	Chip_SDIF_SetBlkSize(pSDMMC, bs);
+
+	/* set number of bytes to read */
+	Chip_SDIF_SetByteCnt(pSDMMC, size);
+
+	sdioif->wait_evt(pSDMMC, SDIO_START_DATA, 0);
+	Chip_SDIF_DmaSetup(pSDMMC, &sdioif->sdev, (uint32_t) dest_addr, size);
+
+	ret = SDIO_Send_Command(pSDMMC, cmd | (1 << 13), (func << 28) | (src_addr << 9) | (bsize & 0x1FF) | (flags & (0x3 << 26)));
+	if (ret) return ret;
+
+	/* Check response for errors */
+	if(sdioif->response[0] & 0xcb00){
+						/* COM_CRC_ERROR */
+						/* ILLEGAL_CRC_ERROR */
+						/* ERROR */
+						/* RFU FUNCTION_NUMBER */
+						/* OUT_OF_RANGE */
+		/* Response flag error */
+		return SDIO_ERR_READWRITE;
+	}
+
+	return sdioif->wait_evt(pSDMMC, SDIO_WAIT_DATA, 0);
+}
+
+/* Enable SDIO function interrupt */
+int SDIO_Card_EnableInt(LPC_SDMMC_T *pSDMMC, uint32_t func)
+{
+	int ret;
+	uint32_t val;
+
+	if (func > sdioif->fnum)
+		return SDIO_ERR_INVFUNC;
+
+	ret = SDIO_Read_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, &val);
+	if (ret) return ret;
+	val |= (1 << func) | 1;
+	ret = SDIO_Write_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, val);
+	if (ret) return ret;
+	pSDMMC->INTMASK |= SDIO_CARD_INT_MSK;
+
+	return 0;
+}
+
+/* Disable SDIO function interrupt */
+int SDIO_Card_DisableInt(LPC_SDMMC_T *pSDMMC, uint32_t func)
+{
+	int ret;
+	uint32_t val;
+
+	if (func > sdioif->fnum)
+		return SDIO_ERR_INVFUNC;
+
+	ret = SDIO_Read_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, &val);
+	if (ret) return ret;
+	val &= ~(1 << func);
+
+	/* Disable master interrupt if it is the only thing enabled */
+	if (val == 1)
+		val = 0;
+	ret = SDIO_Write_Direct(pSDMMC, SDIO_AREA_CIA, 0x04, val);
+	if (ret) return ret;
+	if (!val)
+		pSDMMC->INTMASK &= ~SDIO_CARD_INT_MSK;
+
+	return 0;
+}
+
+/* Initialize the SDIO card */
+int SDIO_Card_Init(LPC_SDMMC_T *pSDMMC, uint32_t freq)
+{
+	int ret;
+	uint32_t val;
+
+	/* Set Clock to 400KHz */
+	Chip_SDIF_SetClock(pSDMMC, Chip_Clock_GetBaseClocktHz(CLK_BASE_SDIO), freq);
+	Chip_SDIF_SetCardType(pSDMMC, 0);
+
+	sdioif->wait_evt(pSDMMC, SDIO_WAIT_DELAY, (void *) 100); /* Wait for card to wake up */
+
+	if (sdioif->flag & SDIO_POWER_INIT) {
+		/* Write to the Reset Bit */
+		ret = SDIO_Write_Direct(pSDMMC, SDIO_AREA_CIA, 0x06, 0x08);
+		if (ret) return ret;
+	}
+
+	/* Set Voltage level to 3v3 */
+	ret = SDIO_Card_SetVoltage(pSDMMC);
+	if (ret) return ret;
+
+	/* Set the RCA */
+	ret = SDIO_CARD_SetRCA(pSDMMC);
+	if (ret) return ret;
+
+	/* ==== check card capability ==== */
+	val = 0x02;
+	ret = SDIO_WriteRead_Direct(pSDMMC, SDIO_AREA_CIA, 0x13, &val);
+	if (ret) return ret;
+
+	/* FIXME: Verify */
+	/* FIFO threshold settings for DMA, DMA burst of 4,   FIFO watermark at 16 */
+	pSDMMC->FIFOTH = MCI_FIFOTH_DMA_MTS_1 | MCI_FIFOTH_RX_WM(0) | MCI_FIFOTH_TX_WM(1);
+
+	/* Enable internal DMA, burst size of 4, fixed burst */
+	pSDMMC->BMOD = MCI_BMOD_DE | MCI_BMOD_PBL1 | MCI_BMOD_DSL(0);
+
+	/* High Speed Support? */
+	if ((val & 0x03) == 3) {
+		return SDIO_Card_SetMode(pSDMMC, SDIO_CLK_HISPEED, 1);
+	}
+
+	ret = SDIO_Read_Direct(pSDMMC, SDIO_AREA_CIA, 0x08, &val);
+	if (ret) return ret;
+
+	/* Full Speed Support? */
+	if (val & SDIO_CCCR_LSC) {
+		return SDIO_Card_SetMode(pSDMMC, SDIO_CLK_FULLSPEED, 1);
+	}
+
+	/* Low Speed Card */
+	return SDIO_Card_SetMode(pSDMMC, SDIO_CLK_LOWSPEED, val & SDIO_CCCR_4BLS);
+}
+
+/* Write given data to register space of the CARD */
+int SDIO_Write_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t data)
+{
+	int ret;
+
+	ret = SDIO_Send_Command(pSDMMC, CMD52, (func << 28) | (addr << 9) | (data & 0xFF) | (1UL << 31));
+	if (ret) return ret;
+
+	/* Check response for errors */
+	if(sdioif->response[0] & 0xcb00){
+						/* COM_CRC_ERROR */
+						/* ILLEGAL_CRC_ERROR */
+						/* ERROR */
+						/* RFU FUNCTION_NUMBER */
+						/* OUT_OF_RANGE */
+		/* Response flag error */
+		return SDIO_ERR_READWRITE;
+	}
+	return data != (sdioif->response[0] & 0xFF);
+}
+
+/* Write given data to register, and read back the register into data */
+int SDIO_WriteRead_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data)
+{
+	int ret;
+
+	ret = SDIO_Send_Command(pSDMMC, CMD52, (func << 28) | (1 << 27) | (addr << 9) | ((*data) & 0xFF) | (1UL << 31));
+	if (ret) return ret;
+
+	/* Check response for errors */
+	if(sdioif->response[0] & 0xcb00){
+						/* COM_CRC_ERROR */
+						/* ILLEGAL_CRC_ERROR */
+						/* ERROR */
+						/* RFU FUNCTION_NUMBER */
+						/* OUT_OF_RANGE */
+		/* Response flag error */
+		return SDIO_ERR_READWRITE;
+	}
+	*data = sdioif->response[0] & 0xFF;
+	return 0;
+}
+
+/* Read a register from the register address space of the CARD */
+int SDIO_Read_Direct(LPC_SDMMC_T *pSDMMC, uint32_t func, uint32_t addr, uint32_t *data)
+{
+	int ret;
+	ret = SDIO_Send_Command(pSDMMC, CMD52, ((func & 7) << 28) | ((addr & 0x1FFFF) << 9));
+	if (ret) return ret;
+
+	/* Check response for errors */
+	if(sdioif->response[0] & 0xcb00){
+						/* COM_CRC_ERROR */
+						/* ILLEGAL_CRC_ERROR */
+						/* ERROR */
+						/* RFU FUNCTION_NUMBER */
+						/* OUT_OF_RANGE */
+		/* Response flag error */
+		return SDIO_ERR_READWRITE;
+	}
+	*data = sdioif->response[0] & 0xFF;
+	return 0;
+}
+
+/* Set up the wait and wake call-back functions */
+void SDIO_Setup_Callback(LPC_SDMMC_T *pSDMMC,
+	void (*wake_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg),
+	uint32_t (*wait_evt)(LPC_SDMMC_T *pSDMMC, uint32_t event, void *arg))
+{
+	sdioif->wake_evt = wake_evt;
+	sdioif->wait_evt = wait_evt;
+}
+
+/* Send and SD Command to the SDIO Card */
+uint32_t SDIO_Send_Command(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg)
+{
+	uint32_t ret, ival;
+	uint32_t imsk = pSDMMC->INTMASK;
+	ret = sdioif->wait_evt(pSDMMC, SDIO_START_COMMAND, (void *)(cmd & 0x3F));
+	ival = SDIO_CMD_INT_MSK & ~ret;
+
+	/* Set data interrupts for data commands */
+	if (cmd & SDIO_CMD_DATA) {
+		ival |= SDIO_DATA_INT_MSK;
+		imsk |= SDIO_DATA_INT_MSK;
+	}
+
+	Chip_SDIF_SetIntMask(pSDMMC, ival);
+	Chip_SDIF_SendCmd(pSDMMC, cmd, arg);
+	ret = sdioif->wait_evt(pSDMMC, SDIO_WAIT_COMMAND, 0);
+	if (!ret && (cmd & SDIO_CMD_RESP_R1)) {
+		Chip_SDIF_GetResponse(pSDMMC, &sdioif->response[0]);
+	}
+
+	Chip_SDIF_SetIntMask(pSDMMC, imsk);
+	return ret;
+}
+
+/* SDIO Card interrupt handler */
+void SDIO_Handler(LPC_SDMMC_T *pSDMMC)
+{
+	uint32_t status = pSDMMC->MINTSTS;
+	uint32_t iclr = 0;
+
+	/* Card Detected */
+	if (status & 1) {
+		sdioif->wake_evt(pSDMMC, SDIO_CARD_DETECT, 0);
+		iclr = 1;
+	}
+
+	/* Command event error */
+	if (status & (SDIO_CMD_INT_MSK & ~4)) {
+		sdioif->wake_evt(pSDMMC, SDIO_CMD_ERR, (void *) (status & (SDIO_CMD_INT_MSK & ~4)));
+		iclr |= status & SDIO_CMD_INT_MSK;
+	} else if (status & 4) {
+		/* Command event done */
+		sdioif->wake_evt(pSDMMC, SDIO_CMD_DONE, (void *) status);
+		iclr |= status & SDIO_CMD_INT_MSK;
+	}
+
+	/* Command event error */
+	if (status & (SDIO_DATA_INT_MSK & ~8)) {
+		sdioif->wake_evt(pSDMMC, SDIO_DATA_ERR, (void *) (status & (SDIO_DATA_INT_MSK & ~8)));
+		iclr |= (status & SDIO_DATA_INT_MSK) | (3 << 4);
+	} else if (status & 8) {
+		/* Command event done */
+		sdioif->wake_evt(pSDMMC, SDIO_DATA_DONE, (void *) status);
+		iclr |= (status & SDIO_DATA_INT_MSK) | (3 << 4);
+	}
+
+	/* Handle Card interrupt */
+	if (status & SDIO_CARD_INT_MSK) {
+		sdioif->wake_evt(pSDMMC, SDIO_CARD_INT, 0);
+		iclr |= status & SDIO_CARD_INT_MSK;
+	}
+
+	/* Clear the interrupts */
+	pSDMMC->RINTSTS = iclr;
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sdmmc_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/sdmmc_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sdmmc_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/sdmmc_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,598 @@
+/*
+ * @brief LPC18xx/43xx SD/SDIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "string.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Global instance of the current card */
+static mci_card_struct *g_card_info;
+
+/* Helper definition: all SD error conditions in the status word */
+#define SD_INT_ERROR (MCI_INT_RESP_ERR | MCI_INT_RCRC | MCI_INT_DCRC | \
+					  MCI_INT_RTO | MCI_INT_DTO | MCI_INT_HTO | MCI_INT_FRUN | MCI_INT_HLE | \
+					  MCI_INT_SBE | MCI_INT_EBE)
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Function to execute a command */
+static int32_t sdmmc_execute_command(LPC_SDMMC_T *pSDMMC, uint32_t cmd, uint32_t arg, uint32_t wait_status)
+{
+	int32_t step = (cmd & CMD_BIT_APP) ? 2 : 1;
+	int32_t status = 0;
+	uint32_t cmd_reg = 0;
+
+	if (!wait_status) {
+		wait_status = (cmd & CMD_MASK_RESP) ? MCI_INT_CMD_DONE : MCI_INT_DATA_OVER;
+	}
+
+	/* Clear the interrupts & FIFOs*/
+	if (cmd & CMD_BIT_DATA) {
+		Chip_SDIF_SetClearIntFifo(pSDMMC);
+	}
+
+	/* also check error conditions */
+	wait_status |= MCI_INT_EBE | MCI_INT_SBE | MCI_INT_HLE | MCI_INT_RTO | MCI_INT_RCRC | MCI_INT_RESP_ERR;
+	if (wait_status & MCI_INT_DATA_OVER) {
+		wait_status |= MCI_INT_FRUN | MCI_INT_HTO | MCI_INT_DTO | MCI_INT_DCRC;
+	}
+
+	while (step) {
+		Chip_SDIF_SetClock(pSDMMC, Chip_Clock_GetBaseClocktHz(CLK_BASE_SDIO), g_card_info->card_info.speed);
+
+		/* Clear the interrupts */
+		Chip_SDIF_ClrIntStatus(pSDMMC, 0xFFFFFFFF);
+
+		g_card_info->card_info.evsetup_cb((void *) &wait_status);
+
+		switch (step) {
+		case 1:	/* Execute command */
+			cmd_reg = ((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) |
+					  ((cmd & CMD_BIT_INIT)  ? MCI_CMD_INIT : 0) |
+					  ((cmd & CMD_BIT_DATA)  ? (MCI_CMD_DAT_EXP | MCI_CMD_PRV_DAT_WAIT) : 0) |
+					  (((cmd & CMD_MASK_RESP) == CMD_RESP_R2) ? MCI_CMD_RESP_LONG : 0) |
+					  ((cmd & CMD_MASK_RESP) ? MCI_CMD_RESP_EXP : 0) |
+					  ((cmd & CMD_BIT_WRITE)  ? MCI_CMD_DAT_WR : 0) |
+					  ((cmd & CMD_BIT_STREAM) ? MCI_CMD_STRM_MODE : 0) |
+					  ((cmd & CMD_BIT_BUSY) ? MCI_CMD_STOP : 0) |
+					  ((cmd & CMD_BIT_AUTO_STOP)  ? MCI_CMD_SEND_STOP : 0) |
+					  MCI_CMD_START;
+
+			/* wait for previos data finsh for select/deselect commands */
+			if (((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) == MMC_SELECT_CARD) {
+				cmd_reg |= MCI_CMD_PRV_DAT_WAIT;
+			}
+
+			/* wait for command to be accepted by CIU */
+			if (Chip_SDIF_SendCmd(pSDMMC, cmd_reg, arg) == 0) {
+				--step;
+			}
+			break;
+
+		case 0:
+			return 0;
+
+		case 2:	/* APP prefix */
+			cmd_reg = MMC_APP_CMD | MCI_CMD_RESP_EXP |
+					  ((cmd & CMD_BIT_INIT)  ? MCI_CMD_INIT : 0) |
+					  MCI_CMD_START;
+
+			if (Chip_SDIF_SendCmd(pSDMMC, cmd_reg, g_card_info->card_info.rca << 16) == 0) {
+				--step;
+			}
+			break;
+		}
+
+		/* wait for command response */
+		status = g_card_info->card_info.waitfunc_cb();
+
+		/* We return an error if there is a timeout, even if we've fetched  a response */
+		if (status & SD_INT_ERROR) {
+			return status;
+		}
+
+		if (status & MCI_INT_CMD_DONE) {
+			switch (cmd & CMD_MASK_RESP) {
+			case 0:
+				break;
+
+			case CMD_RESP_R1:
+			case CMD_RESP_R3:
+			case CMD_RESP_R2:
+				Chip_SDIF_GetResponse(pSDMMC, &g_card_info->card_info.response[0]);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* Checks whether card is acquired properly or not */
+static int32_t prv_card_acquired(void)
+{
+	return g_card_info->card_info.cid[0] != 0;
+}
+
+/* Helper function to get a bit field withing multi-word  buffer. Used to get
+   fields with-in CSD & EXT-CSD */
+static uint32_t prv_get_bits(int32_t start, int32_t end, uint32_t *data)
+{
+	uint32_t v;
+	uint32_t i = end >> 5;
+	uint32_t j = start & 0x1f;
+
+	if (i == (start >> 5)) {
+		v = (data[i] >> j);
+	}
+	else {
+		v = ((data[i] << (32 - j)) | (data[start >> 5] >> j));
+	}
+
+	return v & ((1 << (end - start + 1)) - 1);
+}
+
+/* Function to process the CSD & EXT-CSD of the card */
+static void prv_process_csd(LPC_SDMMC_T *pSDMMC)
+{
+	int32_t status = 0;
+	int32_t c_size = 0;
+	int32_t c_size_mult = 0;
+	int32_t mult = 0;
+
+	/* compute block length based on CSD response */
+	g_card_info->card_info.block_len = 1 << prv_get_bits(80, 83, g_card_info->card_info.csd);
+
+	if ((g_card_info->card_info.card_type & CARD_TYPE_HC) && (g_card_info->card_info.card_type & CARD_TYPE_SD)) {
+		/* See section 5.3.3 CSD Register (CSD Version 2.0) of SD2.0 spec  an explanation for the calculation of these values */
+		c_size = prv_get_bits(48, 69, (uint32_t *) g_card_info->card_info.csd) + 1;
+		g_card_info->card_info.blocknr = c_size << 10;	/* 512 byte blocks */
+	}
+	else {
+		/* See section 5.3 of the 4.1 revision of the MMC specs for  an explanation for the calculation of these values */
+		c_size = prv_get_bits(62, 73, (uint32_t *) g_card_info->card_info.csd);
+		c_size_mult = prv_get_bits(47, 49, (uint32_t *) g_card_info->card_info.csd);
+		mult = 1 << (c_size_mult + 2);
+		g_card_info->card_info.blocknr = (c_size + 1) * mult;
+
+		/* adjust blocknr to 512/block */
+		if (g_card_info->card_info.block_len > MMC_SECTOR_SIZE) {
+			g_card_info->card_info.blocknr = g_card_info->card_info.blocknr * (g_card_info->card_info.block_len >> 9);
+		}
+
+		/* get extended CSD for newer MMC cards CSD spec >= 4.0*/
+		if (((g_card_info->card_info.card_type & CARD_TYPE_SD) == 0) &&
+			(prv_get_bits(122, 125, (uint32_t *) g_card_info->card_info.csd) >= 4)) {
+			/* put card in trans state */
+			status = sdmmc_execute_command(pSDMMC, CMD_SELECT_CARD, g_card_info->card_info.rca << 16, 0);
+
+			/* set block size and byte count */
+			Chip_SDIF_SetBlkSizeByteCnt(pSDMMC, MMC_SECTOR_SIZE);
+
+			/* send EXT_CSD command */
+			Chip_SDIF_DmaSetup(pSDMMC,
+							  &g_card_info->sdif_dev,
+							  (uint32_t) g_card_info->card_info.ext_csd,
+							  MMC_SECTOR_SIZE);
+
+			status = sdmmc_execute_command(pSDMMC, CMD_SEND_EXT_CSD, 0, 0 | MCI_INT_DATA_OVER);
+			if ((status & SD_INT_ERROR) == 0) {
+				/* check EXT_CSD_VER is greater than 1.1 */
+				if ((g_card_info->card_info.ext_csd[48] & 0xFF) > 1) {
+					g_card_info->card_info.blocknr = g_card_info->card_info.ext_csd[53];/* bytes 212:215 represent sec count */
+
+				}
+				/* switch to 52MHz clock if card type is set to 1 or else set to 26MHz */
+				if ((g_card_info->card_info.ext_csd[49] & 0xFF) == 1) {
+					/* for type 1 MMC cards high speed is 52MHz */
+					g_card_info->card_info.speed = MMC_HIGH_BUS_MAX_CLOCK;
+				}
+				else {
+					/* for type 0 MMC cards high speed is 26MHz */
+					g_card_info->card_info.speed = MMC_LOW_BUS_MAX_CLOCK;
+				}
+			}
+		}
+	}
+
+	g_card_info->card_info.device_size = (uint64_t) g_card_info->card_info.blocknr << 9;	/* blocknr * 512 */
+}
+
+/* Puts current selected card in trans state */
+static int32_t prv_set_trans_state(LPC_SDMMC_T *pSDMMC)
+{
+	uint32_t status;
+
+	/* get current state of the card */
+	status = sdmmc_execute_command(pSDMMC, CMD_SEND_STATUS, g_card_info->card_info.rca << 16, 0);
+	if (status & MCI_INT_RTO) {
+		/* unable to get the card state. So return immediatly. */
+		return -1;
+	}
+
+	/* check card state in response */
+	status = R1_CURRENT_STATE(g_card_info->card_info.response[0]);
+	switch (status) {
+	case SDMMC_STBY_ST:
+		/* put card in 'Trans' state */
+		status = sdmmc_execute_command(pSDMMC, CMD_SELECT_CARD, g_card_info->card_info.rca << 16, 0);
+		if (status != 0) {
+			/* unable to put the card in Trans state. So return immediatly. */
+			return -1;
+		}
+		break;
+
+	case SDMMC_TRAN_ST:
+		/*do nothing */
+		break;
+
+	default:
+		/* card shouldn't be in other states so return */
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Sets card data width and block size */
+static int32_t prv_set_card_params(LPC_SDMMC_T *pSDMMC)
+{
+	int32_t status;
+
+#if SDIO_BUS_WIDTH > 1
+	if (g_card_info->card_info.card_type & CARD_TYPE_SD) {
+		status = sdmmc_execute_command(pSDMMC, CMD_SD_SET_WIDTH, 2, 0);
+		if (status != 0) {
+			return -1;
+		}
+
+		/* if positive response */
+		Chip_SDIF_SetCardType(pSDMMC, MCI_CTYPE_4BIT);
+	}
+#elif SDIO_BUS_WIDTH > 4
+#error 8-bit mode not supported yet!
+#endif
+
+	/* set block length */
+	Chip_SDIF_SetBlkSize(pSDMMC, MMC_SECTOR_SIZE);
+	status = sdmmc_execute_command(pSDMMC, CMD_SET_BLOCKLEN, MMC_SECTOR_SIZE, 0);
+	if (status != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Get card's current state (idle, transfer, program, etc.) */
+int32_t Chip_SDMMC_GetState(LPC_SDMMC_T *pSDMMC)
+{
+	uint32_t status;
+
+	/* get current state of the card */
+	status = sdmmc_execute_command(pSDMMC, CMD_SEND_STATUS, g_card_info->card_info.rca << 16, 0);
+	if (status & MCI_INT_RTO) {
+		return -1;
+	}
+
+	/* check card state in response */
+	return (int32_t) R1_CURRENT_STATE(g_card_info->card_info.response[0]);
+}
+
+/* Function to enumerate the SD/MMC/SDHC/MMC+ cards */
+uint32_t Chip_SDMMC_Acquire(LPC_SDMMC_T *pSDMMC, mci_card_struct *pcardinfo)
+{
+	int32_t status;
+	int32_t tries = 0;
+	uint32_t ocr = OCR_VOLTAGE_RANGE_MSK;
+	uint32_t r;
+	int32_t state = 0;
+	uint32_t command = 0;
+
+	g_card_info = pcardinfo;
+
+	/* clear card type */
+	Chip_SDIF_SetCardType(pSDMMC, 0);
+
+	/* set high speed for the card as 20MHz */
+	g_card_info->card_info.speed = MMC_MAX_CLOCK;
+
+	status = sdmmc_execute_command(pSDMMC, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+
+	while (state < 100) {
+		switch (state) {
+		case 0:	/* Setup for SD */
+			/* check if it is SDHC card */
+			status = sdmmc_execute_command(pSDMMC, CMD_SD_SEND_IF_COND, SD_SEND_IF_ARG, 0);
+			if (!(status & MCI_INT_RTO)) {
+				/* check response has same echo pattern */
+				if ((g_card_info->card_info.response[0] & SD_SEND_IF_ECHO_MSK) == SD_SEND_IF_RESP) {
+					ocr |= OCR_HC_CCS;
+				}
+			}
+
+			++state;
+			command = CMD_SD_OP_COND;
+			tries = INIT_OP_RETRIES;
+
+			/* assume SD card */
+			g_card_info->card_info.card_type |= CARD_TYPE_SD;
+			g_card_info->card_info.speed = SD_MAX_CLOCK;
+			break;
+
+		case 10:	/* Setup for MMC */
+			/* start fresh for MMC crds */
+			g_card_info->card_info.card_type &= ~CARD_TYPE_SD;
+			status = sdmmc_execute_command(pSDMMC, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+			command = CMD_MMC_OP_COND;
+			tries = INIT_OP_RETRIES;
+			ocr |= OCR_HC_CCS;
+			++state;
+
+			/* for MMC cards high speed is 20MHz */
+			g_card_info->card_info.speed = MMC_MAX_CLOCK;
+			break;
+
+		case 1:
+		case 11:
+			status = sdmmc_execute_command(pSDMMC, command, 0, 0);
+			if (status & MCI_INT_RTO) {
+				state += 9;	/* Mode unavailable */
+			}
+			else {
+				++state;
+			}
+			break;
+
+		case 2:		/* Initial OCR check  */
+		case 12:
+			ocr = g_card_info->card_info.response[0] | (ocr & OCR_HC_CCS);
+			if (ocr & OCR_ALL_READY) {
+				++state;
+			}
+			else {
+				state += 2;
+			}
+			break;
+
+		case 3:		/* Initial wait for OCR clear */
+		case 13:
+			while ((ocr & OCR_ALL_READY) && --tries > 0) {
+				g_card_info->card_info.msdelay_func(MS_ACQUIRE_DELAY);
+				status = sdmmc_execute_command(pSDMMC, command, 0, 0);
+				ocr = g_card_info->card_info.response[0] | (ocr & OCR_HC_CCS);
+			}
+			if (ocr & OCR_ALL_READY) {
+				state += 7;
+			}
+			else {
+				++state;
+			}
+			break;
+
+		case 14:
+			/* for MMC cards set high capacity bit */
+			ocr |= OCR_HC_CCS;
+
+		case 4:	/* Assign OCR */
+			tries = SET_OP_RETRIES;
+			ocr &= OCR_VOLTAGE_RANGE_MSK | OCR_HC_CCS;	/* Mask for the bits we care about */
+			do {
+				g_card_info->card_info.msdelay_func(MS_ACQUIRE_DELAY);
+				status = sdmmc_execute_command(pSDMMC, command, ocr, 0);
+				r = g_card_info->card_info.response[0];
+			} while (!(r & OCR_ALL_READY) && --tries > 0);
+
+			if (r & OCR_ALL_READY) {
+				/* is it high capacity card */
+				g_card_info->card_info.card_type |= (r & OCR_HC_CCS);
+				++state;
+			}
+			else {
+				state += 6;
+			}
+			break;
+
+		case 5:	/* CID polling */
+		case 15:
+			status = sdmmc_execute_command(pSDMMC, CMD_ALL_SEND_CID, 0, 0);
+			memcpy(&g_card_info->card_info.cid, &g_card_info->card_info.response[0], 16);
+			++state;
+			break;
+
+		case 6:	/* RCA send, for SD get RCA */
+			status = sdmmc_execute_command(pSDMMC, CMD_SD_SEND_RCA, 0, 0);
+			g_card_info->card_info.rca = (g_card_info->card_info.response[0]) >> 16;
+			++state;
+			break;
+
+		case 16:	/* RCA assignment for MMC set to 1 */
+			g_card_info->card_info.rca = 1;
+			status = sdmmc_execute_command(pSDMMC, CMD_MMC_SET_RCA, g_card_info->card_info.rca << 16, 0);
+			++state;
+			break;
+
+		case 7:
+		case 17:
+			status = sdmmc_execute_command(pSDMMC, CMD_SEND_CSD, g_card_info->card_info.rca << 16, 0);
+			memcpy(&g_card_info->card_info.csd, &g_card_info->card_info.response[0], 16);
+			state = 100;
+			break;
+
+		default:
+			state += 100;	/* break from while loop */
+			break;
+		}
+	}
+
+	/* Compute card size, block size and no. of blocks  based on CSD response recived. */
+	if (prv_card_acquired()) {
+		prv_process_csd(pSDMMC);
+
+		/* Setup card data width and block size (once) */
+		if (prv_set_trans_state(pSDMMC) != 0) {
+			return 0;
+		}
+		if (prv_set_card_params(pSDMMC) != 0) {
+			return 0;
+		}
+	}
+
+	return prv_card_acquired();
+}
+
+/* Get the device size of SD/MMC card (after enumeration) */
+uint64_t Chip_SDMMC_GetDeviceSize(LPC_SDMMC_T *pSDMMC)
+{
+	return g_card_info->card_info.device_size;
+}
+
+/* Get the number of blocks in SD/MMC card (after enumeration) */
+int32_t Chip_SDMMC_GetDeviceBlocks(LPC_SDMMC_T *pSDMMC)
+{
+	return g_card_info->card_info.blocknr;
+}
+
+/* Performs the read of data from the SD/MMC card */
+int32_t Chip_SDMMC_ReadBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks)
+{
+	int32_t cbRead = (num_blocks) * MMC_SECTOR_SIZE;
+	int32_t status = 0;
+	int32_t index;
+
+	/* if card is not acquired return immediately */
+	if (( start_block < 0) || ( (start_block + num_blocks) > g_card_info->card_info.blocknr) ) {
+		return 0;
+	}
+
+	/* put card in trans state */
+	if (prv_set_trans_state(pSDMMC) != 0) {
+		return 0;
+	}
+
+	/* set number of bytes to read */
+	Chip_SDIF_SetByteCnt(pSDMMC, cbRead);
+
+	/* if high capacity card use block indexing */
+	if (g_card_info->card_info.card_type & CARD_TYPE_HC) {
+		index = start_block;
+	}
+	else {	/*fix at 512 bytes*/
+		index = start_block << 9;	// \* g_card_info->card_info.block_len;
+
+	}
+	Chip_SDIF_DmaSetup(pSDMMC, &g_card_info->sdif_dev, (uint32_t) buffer, cbRead);
+
+	/* Select single or multiple read based on number of blocks */
+	if (num_blocks == 1) {
+		status = sdmmc_execute_command(pSDMMC, CMD_READ_SINGLE, index, 0 | MCI_INT_DATA_OVER);
+	}
+	else {
+		status = sdmmc_execute_command(pSDMMC, CMD_READ_MULTIPLE, index, 0 | MCI_INT_DATA_OVER);
+	}
+
+	if (status != 0) {
+		cbRead = 0;
+	}
+	/*Wait for card program to finish*/
+	while (Chip_SDMMC_GetState(pSDMMC) != SDMMC_TRAN_ST) {}
+
+	return cbRead;
+}
+
+/* Performs write of data to the SD/MMC card */
+int32_t Chip_SDMMC_WriteBlocks(LPC_SDMMC_T *pSDMMC, void *buffer, int32_t start_block, int32_t num_blocks)
+{
+	int32_t cbWrote = num_blocks *  MMC_SECTOR_SIZE;
+	int32_t status;
+	int32_t index;
+
+	/* if card is not acquired return immediately */
+	if (( start_block < 0) || ( (start_block + num_blocks) > g_card_info->card_info.blocknr) ) {
+		return 0;
+	}
+
+	/*Wait for card program to finish*/
+	while (Chip_SDMMC_GetState(pSDMMC) != SDMMC_TRAN_ST) {}
+
+	/* put card in trans state */
+	if (prv_set_trans_state(pSDMMC) != 0) {
+		return 0;
+	}
+
+	/* set number of bytes to write */
+	Chip_SDIF_SetByteCnt(pSDMMC, cbWrote);
+
+	/* if high capacity card use block indexing */
+	if (g_card_info->card_info.card_type & CARD_TYPE_HC) {
+		index = start_block;
+	}
+	else {	/*fix at 512 bytes*/
+		index = start_block << 9;	// * g_card_info->card_info.block_len;
+
+	}
+
+	Chip_SDIF_DmaSetup(pSDMMC, &g_card_info->sdif_dev, (uint32_t) buffer, cbWrote);
+
+	/* Select single or multiple write based on number of blocks */
+	if (num_blocks == 1) {
+		status = sdmmc_execute_command(pSDMMC, CMD_WRITE_SINGLE, index, 0 | MCI_INT_DATA_OVER);
+	}
+	else {
+		status = sdmmc_execute_command(pSDMMC, CMD_WRITE_MULTIPLE, index, 0 | MCI_INT_DATA_OVER);
+	}
+
+	/*Wait for card program to finish*/
+	while (Chip_SDMMC_GetState(pSDMMC) != SDMMC_TRAN_ST) {}
+
+	if (status != 0) {
+		cbWrote = 0;
+	}
+
+	return cbWrote;
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/spi_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/spi_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/spi_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/spi_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,234 @@
+/*
+ * @brief LPC43xx SPI driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+#if defined(CHIP_LPC43XX)
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Execute callback function */
+STATIC void executeCallback(LPC_SPI_T *pSPI, SPI_CALLBACK_T pfunc)
+{
+	if (pfunc) {
+		(pfunc) ();
+	}
+}
+
+/* Write byte(s) to FIFO buffer */
+STATIC void writeData(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup, uint32_t num_bytes)
+{
+	uint16_t data2write = 0xFFFF;
+
+	if ( pXfSetup->pTxData) {
+		data2write =  pXfSetup->pTxData[pXfSetup->cnt];
+		if (num_bytes == 2) {
+			data2write |= pXfSetup->pTxData[pXfSetup->cnt + 1] << 8;
+		}
+	}
+
+	Chip_SPI_SendFrame(pSPI, data2write);
+
+}
+
+/* Read byte(s) from FIFO buffer */
+STATIC void readData(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup, uint16_t rDat, uint32_t num_bytes)
+{
+	rDat = Chip_SPI_ReceiveFrame(pSPI);
+	if (pXfSetup->pRxData) {
+		pXfSetup->pRxData[pXfSetup->cnt] = rDat;
+		if (num_bytes == 2) {
+			pXfSetup->pRxData[pXfSetup->cnt + 1] = rDat >> 8;
+		}
+	}
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* SPI Polling Read/Write in blocking mode */
+uint32_t Chip_SPI_RWFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
+{
+	uint32_t status;
+	uint16_t rDat = 0x0000;
+	uint8_t bytes = 1;
+
+	/* Clear status */
+	Chip_SPI_Int_FlushData(pSPI);
+
+	if (Chip_SPI_GetDataSize(pSPI) != SPI_BITS_8) {
+		bytes = 2;
+	}
+
+	executeCallback(pSPI, pXfSetup->fnBefTransfer);
+
+	while (pXfSetup->cnt < pXfSetup->length) {
+
+		executeCallback(pSPI, pXfSetup->fnBefFrame);
+
+		/* write data to buffer */
+		writeData(pSPI, pXfSetup, bytes);
+
+		/* Wait for transfer completes */
+		while (1) {
+			status = Chip_SPI_GetStatus(pSPI);
+			/* Check error */
+			if (status & SPI_SR_ERROR) {
+				goto rw_end;
+			}
+			if (status & SPI_SR_SPIF) {
+				break;
+			}
+		}
+
+		executeCallback(pSPI, pXfSetup->fnAftFrame);
+
+		/* Read data*/
+		readData(pSPI, pXfSetup, rDat, bytes);
+		pXfSetup->cnt += bytes;
+	}
+
+rw_end:
+	executeCallback(pSPI, pXfSetup->fnAftTransfer);
+	return pXfSetup->cnt;
+}
+
+/* Clean all data in RX FIFO of SPI */
+void Chip_SPI_Int_FlushData(LPC_SPI_T *pSPI)
+{
+	volatile uint32_t tmp;
+	Chip_SPI_GetStatus(pSPI);
+	tmp = Chip_SPI_ReceiveFrame(pSPI);
+	Chip_SPI_Int_ClearStatus(pSPI, SPI_INT_SPIF);
+    (void) tmp;
+}
+
+/* SPI Interrupt Read/Write with 8-bit frame width */
+Status Chip_SPI_Int_RWFrames(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup, uint8_t bytes)
+{
+	uint32_t status;
+	uint16_t rDat = 0x0000;
+
+	status = Chip_SPI_GetStatus(pSPI);
+	/* Check error status */
+	if (status & SPI_SR_ERROR) {
+		return ERROR;
+	}
+
+	Chip_SPI_Int_ClearStatus(pSPI, SPI_INT_SPIF);
+	if (status & SPI_SR_SPIF) {
+		executeCallback(pSPI, pXfSetup->fnAftFrame);
+		if (pXfSetup->cnt < pXfSetup->length) {
+			/* read data */
+			readData(pSPI, pXfSetup, rDat, bytes);
+			pXfSetup->cnt += bytes;
+		}
+	}
+
+	if (pXfSetup->cnt < pXfSetup->length) {
+
+		executeCallback(pSPI, pXfSetup->fnBefFrame);
+
+		/* Write data  */
+		writeData(pSPI, pXfSetup, bytes);
+	}
+	else {
+		executeCallback(pSPI, pXfSetup->fnAftTransfer);
+	}
+	return SUCCESS;
+}
+
+/* SPI Interrupt Read/Write with 8-bit frame width */
+Status Chip_SPI_Int_RWFrames8Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
+{
+	return Chip_SPI_Int_RWFrames(pSPI, pXfSetup, 1);
+}
+
+/* SPI Interrupt Read/Write with 16-bit frame width */
+Status Chip_SPI_Int_RWFrames16Bits(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
+{
+	return Chip_SPI_Int_RWFrames(pSPI, pXfSetup, 2);
+}
+
+/* Set the clock frequency for SPI interface */
+void Chip_SPI_SetBitRate(LPC_SPI_T *pSPI, uint32_t bitRate)
+{
+	uint32_t spiClk, counter;
+	/* Get SPI clock rate */
+	spiClk = Chip_Clock_GetRate(CLK_SPI);
+
+	counter = spiClk / bitRate;
+	if (counter < 8) {
+		counter = 8;
+	}
+	counter = ((counter + 1) / 2) * 2;
+
+	if (counter > 254) {
+		counter = 254;
+	}
+
+	Chip_SPI_SetClockCounter(pSPI, counter);
+}
+
+/* Initialize the SPI */
+void Chip_SPI_Init(LPC_SPI_T *pSPI)
+{
+	Chip_Clock_Enable(CLK_SPI);
+
+	Chip_SPI_SetMode(pSPI, SPI_MODE_MASTER);
+	pSPI->CR = (pSPI->CR & (~0xF1C)) | SPI_CR_BIT_EN | SPI_BITS_8 | SPI_CLOCK_CPHA0_CPOL0 | SPI_DATA_MSB_FIRST;
+	Chip_SPI_SetBitRate(pSPI, 400000);
+}
+
+/* De-initializes the SPI peripheral */
+void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
+{
+	Chip_Clock_Disable(CLK_SPI);
+}
+
+#endif
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ssp_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/ssp_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/ssp_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/ssp_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,475 @@
+/*
+ * @brief LPC18xx/43xx SSP driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+STATIC void SSP_Write2BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	if (xf_setup->tx_data) {
+		Chip_SSP_SendFrame(pSSP, (*(uint16_t *) ((uint32_t) xf_setup->tx_data +
+												 xf_setup->tx_cnt)));
+	}
+	else {
+		Chip_SSP_SendFrame(pSSP, 0xFFFF);
+	}
+
+	xf_setup->tx_cnt += 2;
+}
+
+/** SSP macro: write 1 bytes to FIFO buffer */
+STATIC void SSP_Write1BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	if (xf_setup->tx_data) {
+		Chip_SSP_SendFrame(pSSP, (*(uint8_t *) ((uint32_t) xf_setup->tx_data + xf_setup->tx_cnt)));
+	}
+	else {
+		Chip_SSP_SendFrame(pSSP, 0xFF);
+	}
+
+	xf_setup->tx_cnt++;
+}
+
+/** SSP macro: read 1 bytes from FIFO buffer */
+STATIC void SSP_Read2BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	uint16_t rDat;
+
+	while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET) &&
+		   (xf_setup->rx_cnt < xf_setup->length)) {
+		rDat = Chip_SSP_ReceiveFrame(pSSP);
+		if (xf_setup->rx_data) {
+			*(uint16_t *) ((uint32_t) xf_setup->rx_data + xf_setup->rx_cnt) = rDat;
+		}
+
+		xf_setup->rx_cnt += 2;
+	}
+}
+
+/** SSP macro: read 2 bytes from FIFO buffer */
+STATIC void SSP_Read1BFifo(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	uint16_t rDat;
+
+	while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET) &&
+		   (xf_setup->rx_cnt < xf_setup->length)) {
+		rDat = Chip_SSP_ReceiveFrame(pSSP);
+		if (xf_setup->rx_data) {
+			*(uint8_t *) ((uint32_t) xf_setup->rx_data + xf_setup->rx_cnt) = rDat;
+		}
+
+		xf_setup->rx_cnt++;
+	}
+}
+
+/* Returns clock index for the register interface */
+STATIC CHIP_CCU_CLK_T Chip_SSP_GetClockIndex(LPC_SSP_T *pSSP)
+{
+	CHIP_CCU_CLK_T clkSSP;
+
+	if (pSSP == LPC_SSP1) {
+		clkSSP = CLK_MX_SSP1;
+	}
+	else {
+		clkSSP = CLK_MX_SSP0;
+	}
+
+	return clkSSP;
+}
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_SSP_GetPeriphClockIndex(LPC_SSP_T *pSSP)
+{
+	CHIP_CCU_CLK_T clkSSP;
+
+	if (pSSP == LPC_SSP1) {
+		clkSSP = CLK_APB2_SSP1;
+	}
+	else {
+		clkSSP = CLK_APB0_SSP0;
+	}
+
+	return clkSSP;
+}
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/*Set up output clocks per bit for SSP bus*/
+void Chip_SSP_SetClockRate(LPC_SSP_T *pSSP, uint32_t clk_rate, uint32_t prescale)
+{
+	uint32_t temp;
+	temp = pSSP->CR0 & (~(SSP_CR0_SCR(0xFF)));
+	pSSP->CR0 = temp | (SSP_CR0_SCR(clk_rate));
+	pSSP->CPSR = prescale;
+}
+
+/* SSP Polling Read/Write in blocking mode */
+uint32_t Chip_SSP_RWFrames_Blocking(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	/* Clear all remaining frames in RX FIFO */
+	while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+		Chip_SSP_ReceiveFrame(pSSP);
+	}
+
+	/* Clear status */
+	Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+
+	if (Chip_SSP_GetDataSize(pSSP) > SSP_BITS_8) {
+		while (xf_setup->rx_cnt < xf_setup->length || xf_setup->tx_cnt < xf_setup->length) {
+			/* write data to buffer */
+			if (( Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && ( xf_setup->tx_cnt < xf_setup->length) ) {
+				SSP_Write2BFifo(pSSP, xf_setup);
+			}
+
+			/* Check overrun error */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/* Check for any data available in RX FIFO */
+			SSP_Read2BFifo(pSSP, xf_setup);
+		}
+	}
+	else {
+		while (xf_setup->rx_cnt < xf_setup->length || xf_setup->tx_cnt < xf_setup->length) {
+			/* write data to buffer */
+			if (( Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && ( xf_setup->tx_cnt < xf_setup->length) ) {
+				SSP_Write1BFifo(pSSP, xf_setup);
+			}
+
+			/* Check overrun error */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/* Check for any data available in RX FIFO */
+			SSP_Read1BFifo(pSSP, xf_setup);
+		}
+	}
+	if (xf_setup->tx_data) {
+		return xf_setup->tx_cnt;
+	}
+	else if (xf_setup->rx_data) {
+		return xf_setup->rx_cnt;
+	}
+
+	return 0;
+}
+
+/* SSP Polling Write in blocking mode */
+uint32_t Chip_SSP_WriteFrames_Blocking(LPC_SSP_T *pSSP, const uint8_t *buffer, uint32_t buffer_len)
+{
+	uint32_t tx_cnt = 0, rx_cnt = 0;
+
+	/* Clear all remaining frames in RX FIFO */
+	while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+		Chip_SSP_ReceiveFrame(pSSP);
+	}
+
+	/* Clear status */
+	Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+
+	if (Chip_SSP_GetDataSize(pSSP) > SSP_BITS_8) {
+		uint16_t *wdata16;
+
+		wdata16 = (uint16_t *) buffer;
+
+		while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+			/* write data to buffer */
+			if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+				Chip_SSP_SendFrame(pSSP, *wdata16);
+				wdata16++;
+				tx_cnt += 2;
+			}
+
+			/* Check overrun error */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/* Check for any data available in RX FIFO */
+			while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET) {
+				Chip_SSP_ReceiveFrame(pSSP);	/* read dummy data */
+				rx_cnt += 2;
+			}
+		}
+	}
+	else {
+		const uint8_t *wdata8;
+
+		wdata8 = buffer;
+
+		while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+			/* write data to buffer */
+			if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+				Chip_SSP_SendFrame(pSSP, *wdata8);
+				wdata8++;
+				tx_cnt++;
+			}
+
+			/* Check overrun error */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/* Check for any data available in RX FIFO */
+			while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET && rx_cnt < buffer_len) {
+				Chip_SSP_ReceiveFrame(pSSP);	/* read dummy data */
+				rx_cnt++;
+			}
+		}
+	}
+
+	return tx_cnt;
+
+}
+
+/* SSP Polling Read in blocking mode */
+uint32_t Chip_SSP_ReadFrames_Blocking(LPC_SSP_T *pSSP, uint8_t *buffer, uint32_t buffer_len)
+{
+	uint32_t rx_cnt = 0, tx_cnt = 0;
+
+	/* Clear all remaining frames in RX FIFO */
+	while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+		Chip_SSP_ReceiveFrame(pSSP);
+	}
+
+	/* Clear status */
+	Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+
+	if (Chip_SSP_GetDataSize(pSSP) > SSP_BITS_8) {
+		uint16_t *rdata16;
+
+		rdata16 = (uint16_t *) buffer;
+
+		while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+			/* write data to buffer */
+			if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+				Chip_SSP_SendFrame(pSSP, 0xFFFF);	/* just send dummy data */
+				tx_cnt += 2;
+			}
+
+			/* Check overrun error */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/* Check for any data available in RX FIFO */
+			while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET && rx_cnt < buffer_len) {
+				*rdata16 = Chip_SSP_ReceiveFrame(pSSP);
+				rdata16++;
+				rx_cnt += 2;
+			}
+		}
+	}
+	else {
+		uint8_t *rdata8;
+
+		rdata8 = buffer;
+
+		while (tx_cnt < buffer_len || rx_cnt < buffer_len) {
+			/* write data to buffer */
+			if ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF) == SET) && (tx_cnt < buffer_len)) {
+				Chip_SSP_SendFrame(pSSP, 0xFF);	/* just send dummy data		 */
+				tx_cnt++;
+			}
+
+			/* Check overrun error */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/* Check for any data available in RX FIFO */
+			while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE) == SET && rx_cnt < buffer_len) {
+				*rdata8 = Chip_SSP_ReceiveFrame(pSSP);
+				rdata8++;
+				rx_cnt++;
+			}
+		}
+	}
+
+	return rx_cnt;
+
+}
+
+/* Clean all data in RX FIFO of SSP */
+void Chip_SSP_Int_FlushData(LPC_SSP_T *pSSP)
+{
+	if (Chip_SSP_GetStatus(pSSP, SSP_STAT_BSY)) {
+		while (Chip_SSP_GetStatus(pSSP, SSP_STAT_BSY)) {}
+	}
+
+	/* Clear all remaining frames in RX FIFO */
+	while (Chip_SSP_GetStatus(pSSP, SSP_STAT_RNE)) {
+		Chip_SSP_ReceiveFrame(pSSP);
+	}
+
+	/* Clear status */
+	Chip_SSP_ClearIntPending(pSSP, SSP_INT_CLEAR_BITMASK);
+}
+
+/* SSP Interrupt Read/Write with 8-bit frame width */
+Status Chip_SSP_Int_RWFrames8Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	/* Check overrun error in RIS register */
+	if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+		return ERROR;
+	}
+
+	if ((xf_setup->tx_cnt != xf_setup->length) || (xf_setup->rx_cnt != xf_setup->length)) {
+		/* check if RX FIFO contains data */
+		SSP_Read1BFifo(pSSP, xf_setup);
+
+		while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF)) && (xf_setup->tx_cnt != xf_setup->length)) {
+			/* Write data to buffer */
+			SSP_Write1BFifo(pSSP, xf_setup);
+
+			/* Check overrun error in RIS register */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/*  Check for any data available in RX FIFO */
+			SSP_Read1BFifo(pSSP, xf_setup);
+		}
+
+		return SUCCESS;
+	}
+
+	return ERROR;
+}
+
+/* SSP Interrupt Read/Write with 16-bit frame width */
+Status Chip_SSP_Int_RWFrames16Bits(LPC_SSP_T *pSSP, Chip_SSP_DATA_SETUP_T *xf_setup)
+{
+	/* Check overrun error in RIS register */
+	if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+		return ERROR;
+	}
+
+	if ((xf_setup->tx_cnt != xf_setup->length) || (xf_setup->rx_cnt != xf_setup->length)) {
+		/* check if RX FIFO contains data */
+		SSP_Read2BFifo(pSSP, xf_setup);
+
+		while ((Chip_SSP_GetStatus(pSSP, SSP_STAT_TNF)) && (xf_setup->tx_cnt != xf_setup->length)) {
+			/* Write data to buffer */
+			SSP_Write2BFifo(pSSP, xf_setup);
+
+			/* Check overrun error in RIS register */
+			if (Chip_SSP_GetRawIntStatus(pSSP, SSP_RORRIS) == SET) {
+				return ERROR;
+			}
+
+			/*  Check for any data available in RX FIFO			 */
+			SSP_Read2BFifo(pSSP, xf_setup);
+		}
+
+		return SUCCESS;
+	}
+
+	return ERROR;
+}
+
+/* Set the SSP operating modes, master or slave */
+void Chip_SSP_SetMaster(LPC_SSP_T *pSSP, bool master)
+{
+	if (master) {
+		Chip_SSP_Set_Mode(pSSP, SSP_MODE_MASTER);
+	}
+	else {
+		Chip_SSP_Set_Mode(pSSP, SSP_MODE_SLAVE);
+	}
+}
+
+/* Set the clock frequency for SSP interface */
+void Chip_SSP_SetBitRate(LPC_SSP_T *pSSP, uint32_t bitRate)
+{
+	uint32_t ssp_clk, cr0_div, cmp_clk, prescale;
+
+	ssp_clk = Chip_Clock_GetRate(Chip_SSP_GetPeriphClockIndex(pSSP));
+
+	cr0_div = 0;
+	cmp_clk = 0xFFFFFFFF;
+	prescale = 2;
+
+	while (cmp_clk > bitRate) {
+		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
+		if (cmp_clk > bitRate) {
+			cr0_div++;
+			if (cr0_div > 0xFF) {
+				cr0_div = 0;
+				prescale += 2;
+			}
+		}
+	}
+
+	Chip_SSP_SetClockRate(pSSP, cr0_div, prescale);
+}
+
+/* Initialize the SSP */
+void Chip_SSP_Init(LPC_SSP_T *pSSP)
+{
+	Chip_Clock_Enable(Chip_SSP_GetClockIndex(pSSP));
+	Chip_Clock_Enable(Chip_SSP_GetPeriphClockIndex(pSSP));
+
+	Chip_SSP_Set_Mode(pSSP, SSP_MODE_MASTER);
+	Chip_SSP_SetFormat(pSSP, SSP_BITS_8, SSP_FRAMEFORMAT_SPI, SSP_CLOCK_CPHA0_CPOL0);
+	Chip_SSP_SetBitRate(pSSP, 100000);
+}
+
+/* De-initializes the SSP peripheral */
+void Chip_SSP_DeInit(LPC_SSP_T *pSSP)
+{
+	Chip_SSP_Disable(pSSP);
+
+	Chip_Clock_Disable(Chip_SSP_GetPeriphClockIndex(pSSP));
+	Chip_Clock_Disable(Chip_SSP_GetClockIndex(pSSP));
+	
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/stopwatch_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/stopwatch_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/stopwatch_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/stopwatch_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,112 @@
+/*
+ * @brief LPC18xx/43xx specific stopwatch implementation
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "stopwatch.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Precompute these to optimize runtime */
+static uint32_t ticksPerSecond;
+static uint32_t ticksPerMs;
+static uint32_t ticksPerUs;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize stopwatch */
+void StopWatch_Init(void)
+{
+	/* Use timer 1. Set prescaler to divide by 8 */
+	const uint32_t prescaleDivisor = 8;
+	Chip_TIMER_Init(LPC_TIMER0);
+	Chip_TIMER_PrescaleSet(LPC_TIMER0, prescaleDivisor - 1);
+	Chip_TIMER_Enable(LPC_TIMER0);
+
+	/* Pre-compute tick rate. */
+	ticksPerSecond = Chip_Clock_GetRate(CLK_MX_TIMER0) / prescaleDivisor;
+	ticksPerMs = ticksPerSecond / 1000;
+	ticksPerUs = ticksPerSecond / 1000000;
+}
+
+/* Start a stopwatch */
+uint32_t StopWatch_Start(void)
+{
+	/* Return the current timer count. */
+	return Chip_TIMER_ReadCount(LPC_TIMER0);
+}
+
+/* Returns number of ticks per second of the stopwatch timer */
+uint32_t StopWatch_TicksPerSecond(void)
+{
+	return ticksPerSecond;
+}
+
+/* Converts from stopwatch ticks to mS. */
+uint32_t StopWatch_TicksToMs(uint32_t ticks)
+{
+	return ticks / ticksPerMs;
+}
+
+/* Converts from stopwatch ticks to uS. */
+uint32_t StopWatch_TicksToUs(uint32_t ticks)
+{
+	return ticks / ticksPerUs;
+}
+
+/* Converts from mS to stopwatch ticks. */
+uint32_t StopWatch_MsToTicks(uint32_t mS)
+{
+	return mS * ticksPerMs;
+}
+
+/* Converts from uS to stopwatch ticks. */
+uint32_t StopWatch_UsToTicks(uint32_t uS)
+{
+	return uS * ticksPerUs;
+}
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sysinit_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/sysinit_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/sysinit_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/sysinit_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,160 @@
+/*
+ * @brief LPC18xx/LPC43xx Chip specific SystemInit
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Structure for initial base clock states */
+struct CLK_BASE_STATES {
+	CHIP_CGU_BASE_CLK_T clk;	/* Base clock */
+	CHIP_CGU_CLKIN_T clkin;	/* Base clock source, see UM for allowable souorces per base clock */
+	bool autoblock_enab;	/* Set to true to enable autoblocking on frequency change */
+	bool powerdn;			/* Set to true if the base clock is initially powered down */
+};
+
+static const struct CLK_BASE_STATES InitClkStates[] = {
+	{CLK_BASE_SAFE, CLKIN_IRC, true, false},
+	{CLK_BASE_APB1, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_APB3, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_USB0, CLKIN_USBPLL, true, true},
+#if defined(CHIP_LPC43XX)
+	{CLK_BASE_PERIPH, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_SPI, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_ADCHS, CLKIN_MAINPLL, true, true},
+#endif
+	{CLK_BASE_SDIO, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_SSP0, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_SSP1, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_UART0, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_UART1, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_UART2, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_UART3, CLKIN_MAINPLL, true, false},
+	{CLK_BASE_OUT, CLKINPUT_PD, true, false},
+	{CLK_BASE_APLL, CLKINPUT_PD, true, false},
+	{CLK_BASE_CGU_OUT0, CLKINPUT_PD, true, false},
+	{CLK_BASE_CGU_OUT1, CLKINPUT_PD, true, false},
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+/* Setup Chip Core clock */
+void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
+{
+	int i;
+	volatile uint32_t delay = 10000; // FIXME: original was 500, fix for horrible crystals. @Eric
+	uint32_t direct = 0, pdivide = 0;
+	PLL_PARAM_T ppll;
+
+	if (clkin == CLKIN_CRYSTAL) {
+		/* Switch main system clocking to crystal */
+		Chip_Clock_EnableCrystal();
+	}
+	Chip_Clock_SetBaseClock(CLK_BASE_MX, clkin, true, false);
+	Chip_Clock_DisableMainPLL(); /* Disable PLL */
+
+	/* Calculate the PLL Parameters */
+	ppll.srcin = clkin;
+	Chip_Clock_CalcMainPLLValue(core_freq, &ppll);
+
+	if (core_freq > 110000000UL) {
+		if (ppll.ctrl & (1 << 6)) {
+			while(1);		// to run in integer mode above 110 MHz, you need to use IDIV clock to boot strap CPU to that freq
+		} else if (ppll.ctrl & (1 << 7)){
+			direct = 1;
+			ppll.ctrl &= ~(1 << 7);
+		} else {
+			pdivide = 1;
+			ppll.psel++;
+		}
+	}
+
+	/* Setup and start the PLL */
+	Chip_Clock_SetupMainPLL(&ppll);
+
+	/* Wait for the PLL to lock */
+	while(!Chip_Clock_MainPLLLocked()) {}
+
+	/* Set core clock base as PLL1 */
+	Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
+
+	if (direct) {
+		delay = 10000; // FIXME: original was 1000, fix for horrible crystals. @Eric
+		while(delay --){} /* Wait for approx 50 uSec -- for power supply to stabilize*/
+		ppll.ctrl |= 1 << 7;
+		Chip_Clock_SetupMainPLL(&ppll); /* Set DIRECT to operate at full frequency */
+	} else if (pdivide) {
+		delay = 10000; // FIXME: original was 1000, fix for horrible crystals. @Eric
+		while(delay --){} /* Wait for approx 50 uSec -- for power supply to stabilize */
+		ppll.psel--;
+		Chip_Clock_SetupMainPLL(&ppll); /* Set PDIV to operate at full frequency */
+	}
+
+	if (setbase) {
+		/* Setup system base clocks and initial states. This won't enable and
+		   disable individual clocks, but sets up the base clock sources for
+		   each individual peripheral clock. */
+		for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
+			Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
+									InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
+		}
+	}
+}
+
+/* Setup system clocking */
+void Chip_SetupXtalClocking(void)
+{
+	Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Chip_SetupIrcClocking(void)
+{
+	Chip_SetupCoreClock(CLKIN_IRC, MAX_CLOCK_FREQ, true);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Chip_SystemInit(void)
+{
+	/* Initial internal clocking */
+	Chip_SetupIrcClocking();
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/timer_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/timer_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/timer_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/timer_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,123 @@
+/*
+ * @brief LPC18xx/43xx 16/32-bit Timer/PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Returns clock index for the peripheral block */
+STATIC CHIP_CCU_CLK_T Chip_TIMER_GetClockIndex(LPC_TIMER_T *pTMR)
+{
+	CHIP_CCU_CLK_T clkTMR;
+
+	if (pTMR == LPC_TIMER3) {
+		clkTMR = CLK_MX_TIMER3;
+	}
+    else if (pTMR == LPC_TIMER2) {
+		clkTMR = CLK_MX_TIMER2;
+	}
+    else if (pTMR == LPC_TIMER1) {
+		clkTMR = CLK_MX_TIMER1;
+	}
+	else {
+		clkTMR = CLK_MX_TIMER0;
+	}
+
+	return clkTMR;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize a timer */
+void Chip_TIMER_Init(LPC_TIMER_T *pTMR)
+{
+	Chip_Clock_Enable(Chip_TIMER_GetClockIndex(pTMR));
+}
+
+/*	Shutdown a timer */
+void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR)
+{
+	Chip_Clock_Disable(Chip_TIMER_GetClockIndex(pTMR));
+}
+
+/* Resets the timer terminal and prescale counts to 0 */
+void Chip_TIMER_Reset(LPC_TIMER_T *pTMR)
+{
+	uint32_t reg;
+
+	/* Disable timer, set terminal count to non-0 */
+	reg = pTMR->TCR;
+	pTMR->TCR = 0;
+	pTMR->TC = 1;
+
+	/* Reset timer counter */
+	pTMR->TCR = TIMER_RESET;
+
+	/* Wait for terminal count to clear */
+	while (pTMR->TC != 0) {}
+
+	/* Restore timer state */
+	pTMR->TCR = reg;
+}
+
+/* Sets external match control (MATn.matchnum) pin control */
+void Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
+								   TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum)
+{
+	uint32_t mask, reg;
+
+	/* Clear bits corresponding to selected match register */
+	mask = (1 << matchnum) | (0x03 << (4 + (matchnum * 2)));
+	reg = pTMR->EMR &= ~mask;
+
+	/* Set new configuration for selected match register */
+	pTMR->EMR = reg | (((uint32_t) initial_state) << matchnum) |
+				(((uint32_t) matchState) << (4 + (matchnum * 2)));
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/uart_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/uart_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/uart_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/uart_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,432 @@
+/*
+ * @brief LPC18xx/43xx UART chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Autobaud status flag */
+STATIC volatile FlagStatus ABsyncSts = RESET;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+ /* UART Peripheral clocks */
+static const CHIP_CCU_CLK_T UART_PClock[] = {CLK_MX_UART0, CLK_MX_UART1, CLK_MX_UART2, CLK_MX_UART3};
+
+/* UART Bus clocks */
+static const CHIP_CCU_CLK_T UART_BClock[] = {CLK_APB0_UART0, CLK_APB0_UART1, CLK_APB2_UART2, CLK_APB2_UART3};
+
+/* Returns clock index for the peripheral block */
+static int Chip_UART_GetIndex(LPC_USART_T *pUART)
+{
+	uint32_t base = (uint32_t) pUART;
+	switch(base) {
+		case LPC_USART0_BASE:
+			return 0;
+		case LPC_UART1_BASE:
+			return 1;
+		case LPC_USART2_BASE:
+			return 2;
+		case LPC_USART3_BASE:
+			return 3;
+		default:
+			return 0; /* Should never come here */
+	}
+}
+
+/* UART Autobaud command interrupt handler */
+STATIC void Chip_UART_ABIntHandler(LPC_USART_T *pUART)
+{
+	/* Handle End Of Autobaud interrupt */
+	if((Chip_UART_ReadIntIDReg(pUART) & UART_IIR_ABEO_INT) != 0) {
+        Chip_UART_SetAutoBaudReg(pUART, UART_ACR_ABEOINT_CLR);
+		Chip_UART_IntDisable(pUART, UART_IER_ABEOINT);
+	    if (ABsyncSts == RESET) {
+	        ABsyncSts = SET;
+        }
+	}
+
+    /* Handle Autobaud Timeout interrupt */
+	if((Chip_UART_ReadIntIDReg(pUART) & UART_IIR_ABTO_INT) != 0) {
+        Chip_UART_SetAutoBaudReg(pUART, UART_ACR_ABTOINT_CLR);
+		Chip_UART_IntDisable(pUART, UART_IER_ABTOINT);
+	}
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the pUART peripheral */
+void Chip_UART_Init(LPC_USART_T *pUART)
+{
+    volatile uint32_t tmp;
+
+	/* Enable UART clocking. UART base clock(s) must already be enabled */
+	Chip_Clock_EnableOpts(UART_PClock[Chip_UART_GetIndex(pUART)], true, true, 1);
+
+	/* Enable FIFOs by default, reset them */
+	Chip_UART_SetupFIFOS(pUART, (UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS));
+
+    /* Disable Tx */
+    Chip_UART_TXDisable(pUART);
+
+    /* Disable interrupts */
+	pUART->IER = 0;
+	/* Set LCR to default state */
+	pUART->LCR = 0;
+	/* Set ACR to default state */
+	pUART->ACR = 0;
+    /* Set RS485 control to default state */
+	pUART->RS485CTRL = 0;
+	/* Set RS485 delay timer to default state */
+	pUART->RS485DLY = 0;
+	/* Set RS485 addr match to default state */
+	pUART->RS485ADRMATCH = 0;
+
+    /* Clear MCR */
+    if (pUART == LPC_UART1) {
+		/* Set Modem Control to default state */
+		pUART->MCR = 0;
+		/*Dummy Reading to Clear Status */
+		tmp = pUART->MSR;
+	}
+
+	/* Default 8N1, with DLAB disabled */
+	Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));
+
+	/* Disable fractional divider */
+	pUART->FDR = 0x10;
+
+    (void) tmp;
+}
+
+/* De-initializes the pUART peripheral */
+void Chip_UART_DeInit(LPC_USART_T *pUART)
+{
+    /* Disable Tx */
+    Chip_UART_TXDisable(pUART);
+
+    /* Disable clock */
+	Chip_Clock_Disable(UART_PClock[Chip_UART_GetIndex(pUART)]);
+}
+
+/* Transmit a byte array through the UART peripheral (non-blocking) */
+int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes)
+{
+	int sent = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	/* Send until the transmit FIFO is full or out of bytes */
+	while ((sent < numBytes) &&
+		   ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_THRE) != 0)) {
+		Chip_UART_SendByte(pUART, *p8);
+		p8++;
+		sent++;
+	}
+
+	return sent;
+}
+
+/* Check whether if UART is busy or not */
+FlagStatus Chip_UART_CheckBusy(LPC_USART_T *pUART)
+{
+	if (pUART->LSR & UART_LSR_TEMT) {
+		return RESET;
+	}
+	else {
+		return SET;
+	}
+}
+
+/* Transmit a byte array through the UART peripheral (blocking) */
+int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
+{
+	int pass, sent = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	while (numBytes > 0) {
+		pass = Chip_UART_Send(pUART, p8, numBytes);
+		numBytes -= pass;
+		sent += pass;
+		p8 += pass;
+	}
+
+	return sent;
+}
+
+/* Read data through the UART peripheral (non-blocking) */
+int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes)
+{
+	int readBytes = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	/* Send until the transmit FIFO is full or out of bytes */
+	while ((readBytes < numBytes) &&
+		   ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_RDR) != 0)) {
+		*p8 = Chip_UART_ReadByte(pUART);
+		p8++;
+		readBytes++;
+	}
+
+	return readBytes;
+}
+
+/* Read data through the UART peripheral (blocking) */
+int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes)
+{
+	int pass, readBytes = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	while (numBytes > 0) {
+		pass = Chip_UART_Read(pUART, p8, numBytes);
+		numBytes -= pass;
+		readBytes += pass;
+		p8 += pass;
+	}
+
+	return readBytes;
+}
+
+/* Determines and sets best dividers to get a target bit rate */
+uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
+{
+	uint32_t div, divh, divl, clkin;
+
+	/* Determine UART clock in rate without FDR */
+	clkin = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
+	div = clkin / (baudrate * 16);
+
+	/* High and low halves of the divider */
+	divh = div / 256;
+	divl = div - (divh * 256);
+
+	Chip_UART_EnableDivisorAccess(pUART);
+	Chip_UART_SetDivisorLatches(pUART, divl, divh);
+	Chip_UART_DisableDivisorAccess(pUART);
+
+	/* Fractional FDR alreadt setup for 1 in UART init */
+
+	return (clkin / div) >> 4;
+}
+
+/* UART receive-only interrupt handler for ring buffers */
+void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
+{
+	/* New data will be ignored if data not popped in time */
+	while (Chip_UART_ReadLineStatus(pUART) & UART_LSR_RDR) {
+		uint8_t ch = Chip_UART_ReadByte(pUART);
+		RingBuffer_Insert(pRB, &ch);
+	}
+}
+
+/* UART transmit-only interrupt handler for ring buffers */
+void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
+{
+	uint8_t ch;
+
+	/* Fill FIFO until full or until TX ring buffer is empty */
+	while ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_THRE) != 0 &&
+		   RingBuffer_Pop(pRB, &ch)) {
+		Chip_UART_SendByte(pUART, ch);
+	}
+
+	/* Turn off interrupt if the ring buffer is empty */
+	if (RingBuffer_IsEmpty(pRB)) {
+		/* Shut down transmit */
+		Chip_UART_IntDisable(pUART, UART_IER_THREINT);
+	}
+}
+
+/* Populate a transmit ring buffer and start UART transmit */
+uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int bytes)
+{
+	uint32_t ret;
+	uint8_t *p8 = (uint8_t *) data;
+
+	/* Don't let UART transmit ring buffer change in the UART IRQ handler */
+	Chip_UART_IntDisable(pUART, UART_IER_THREINT);
+
+	/* Move as much data as possible into transmit ring buffer */
+	ret = RingBuffer_InsertMult(pRB, p8, bytes);
+	Chip_UART_TXIntHandlerRB(pUART, pRB);
+
+	/* Add additional data to transmit ring buffer if possible */
+	ret += RingBuffer_InsertMult(pRB, (p8 + ret), (bytes - ret));
+
+	/* Enable UART transmit interrupt */
+	Chip_UART_IntEnable(pUART, UART_IER_THREINT);
+
+	return ret;
+}
+
+/* Copy data from a receive ring buffer */
+int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
+{
+	(void) pUART;
+
+	return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
+}
+
+/* UART receive/transmit interrupt handler for ring buffers */
+void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB)
+{
+	/* Handle transmit interrupt if enabled */
+	if (pUART->IER & UART_IER_THREINT) {
+		Chip_UART_TXIntHandlerRB(pUART, pTXRB);
+
+		/* Disable transmit interrupt if the ring buffer is empty */
+		if (RingBuffer_IsEmpty(pTXRB)) {
+			Chip_UART_IntDisable(pUART, UART_IER_THREINT);
+		}
+	}
+
+	/* Handle receive interrupt */
+	Chip_UART_RXIntHandlerRB(pUART, pRXRB);
+
+    /* Handle Autobaud interrupts */
+    Chip_UART_ABIntHandler(pUART);
+}
+
+/* Determines and sets best dividers to get a target baud rate */
+uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
+{
+	uint32_t sdiv = 0, sm = 1, sd = 0;
+	uint32_t pclk, m, d;
+	uint32_t odiff = -1UL; /* old best diff */
+
+	/* Get base clock for the corresponding UART */
+	pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
+
+	/* Loop through all possible fractional divider values */
+	for (m = 1; odiff && m < 16; m++) {
+		for (d = 0; d < m; d++) {
+			uint32_t diff, div;
+			uint64_t dval = (((uint64_t) pclk << 28) * m) / (baud * (m + d));
+
+			/* Lower 32-bit of dval has diff */
+			diff = (uint32_t) dval;
+			/* Upper 32-bit of dval has div */
+			div = (uint32_t) (dval >> 32);
+
+			/* Closer to next div */
+			if ((int)diff < 0) {
+				diff = -diff;
+				div ++;
+			}
+
+			/* Check if new value is worse than old or out of range */
+			if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
+				continue;
+			}
+
+			/* Store the new better values */
+			sdiv = div;
+			sd = d;
+			sm = m;
+			odiff = diff;
+
+			/* On perfect match, break loop */
+			if(!diff) {
+				break;
+			}
+		}
+	}
+
+	/* Return 0 if a vaild divisor is not possible */
+	if (!sdiv) {
+		return 0;
+	}
+
+	/* Update UART registers */
+	Chip_UART_EnableDivisorAccess(pUART);
+	Chip_UART_SetDivisorLatches(pUART, UART_LOAD_DLL(sdiv), UART_LOAD_DLM(sdiv));
+	Chip_UART_DisableDivisorAccess(pUART);
+
+	/* Set best fractional divider */
+	pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));
+
+	/* Return actual baud rate */
+	return (pclk >> 4) * sm / (sdiv * (sm + sd));
+}
+
+/* UART interrupt service routine */
+FlagStatus Chip_UART_GetABEOStatus(LPC_USART_T *pUART)
+{
+	(void) pUART;
+	return ABsyncSts;
+}
+
+/* Start/Stop Auto Baudrate activity */
+void Chip_UART_ABCmd(LPC_USART_T *pUART, uint32_t mode, bool autorestart, FunctionalState NewState)
+{
+    uint32_t tmp = 0;
+
+	if (NewState == ENABLE) {
+		/* Clear DLL and DLM value */
+		pUART->LCR |= UART_LCR_DLAB_EN;
+		pUART->DLL = 0;
+		pUART->DLM = 0;
+		pUART->LCR &= ~UART_LCR_DLAB_EN;
+
+		/* FDR value must be reset to default value */
+		pUART->FDR = 0x10;
+
+		if (mode == UART_ACR_MODE1) {
+			tmp = UART_ACR_START | UART_ACR_MODE;
+		}
+		else {
+			tmp = UART_ACR_START;
+		}
+
+		if (autorestart == true) {
+			tmp |= UART_ACR_AUTO_RESTART;
+		}
+		pUART->ACR = tmp;
+	}
+	else {
+		pUART->ACR = 0;
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/wwdt_18xx_43xx.c ./libs/vendor_libs/lpc_chip_43xx/src/wwdt_18xx_43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_chip_43xx/src/wwdt_18xx_43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_chip_43xx/src/wwdt_18xx_43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,84 @@
+/*
+ * @brief LPC18xx/43xx WWDT driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the Watchdog timer */
+void Chip_WWDT_Init(LPC_WWDT_T *pWWDT)
+{
+	/* Disable watchdog */
+	pWWDT->MOD       = 0;
+	pWWDT->TC        = 0xFF;
+#if defined(WATCHDOG_WINDOW_SUPPORT)
+	pWWDT->WARNINT   = 0xFFFF;
+	pWWDT->WINDOW    = 0xFFFFFF;
+#endif
+}
+
+/* Shutdown the Watchdog timer */
+void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT)
+{
+}
+
+/* Clear WWDT interrupt status flags */
+void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status)
+{
+	if (status & WWDT_WDMOD_WDTOF) {
+		pWWDT->MOD &= (~WWDT_WDMOD_WDTOF) & WWDT_WDMOD_BITMASK;
+	}
+
+	if (status & WWDT_WDMOD_WDINT) {
+		pWWDT->MOD |= WWDT_WDMOD_WDINT;
+	}
+}
+
+
+
+
+
+
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_startup/src/crp.c ./libs/vendor_libs/lpc_startup/src/crp.c
--- a_bRU7kv/libs/vendor_libs/lpc_startup/src/crp.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_startup/src/crp.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,3 @@
+#define CRP_NO_CRP          0xFFFFFFFF
+
+__attribute__ ((used,section(".crp"))) const unsigned int CRP_WORD = CRP_NO_CRP ;
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/lpc_startup/src/cr_startup_lpc43xx.c ./libs/vendor_libs/lpc_startup/src/cr_startup_lpc43xx.c
--- a_bRU7kv/libs/vendor_libs/lpc_startup/src/cr_startup_lpc43xx.c	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/lpc_startup/src/cr_startup_lpc43xx.c	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1,504 @@
+//*****************************************************************************
+// LPC43xx (Cortex-M4) Microcontroller Startup code for use with LPCXpresso IDE
+//
+// Version : 140113
+//*****************************************************************************
+//
+// Copyright(C) NXP Semiconductors, 2013-2014
+// All rights reserved.
+//
+// Software that is described herein is for illustrative purposes only
+// which provides customers with programming information regarding the
+// LPC products.  This software is supplied "AS IS" without any warranties of
+// any kind, and NXP Semiconductors and its licensor disclaim any and
+// all warranties, express or implied, including all implied warranties of
+// merchantability, fitness for a particular purpose and non-infringement of
+// intellectual property rights.  NXP Semiconductors assumes no responsibility
+// or liability for the use of the software, conveys no license or rights under any
+// patent, copyright, mask work right, or any other intellectual property rights in
+// or to any products. NXP Semiconductors reserves the right to make changes
+// in the software without notification. NXP Semiconductors also makes no
+// representation or warranty that such application will be suitable for the
+// specified use without further testing or modification.
+//
+// Permission to use, copy, modify, and distribute this software and its
+// documentation is hereby granted, under NXP Semiconductors' and its
+// licensor's relevant copyrights in the software, without fee, provided that it
+// is used in conjunction with NXP Semiconductors microcontrollers.  This
+// copyright, permission, and disclaimer notice must appear in all copies of
+// this code.
+//*****************************************************************************
+
+#include "board.h"
+
+#if defined (__cplusplus)
+#ifdef __REDLIB__
+#error Redlib does not support C++
+#else
+//*****************************************************************************
+//
+// The entry point for the C++ library startup
+//
+//*****************************************************************************
+extern "C" {
+    extern void __libc_init_array(void);
+}
+#endif
+#endif
+
+#define WEAK __attribute__ ((weak))
+#define ALIAS(f) __attribute__ ((weak, alias (#f)))
+
+//*****************************************************************************
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+//*****************************************************************************
+#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
+// Declaration of external SystemInit function
+extern void SystemInit(void);
+#endif
+
+//*****************************************************************************
+//
+// Forward declaration of the default handlers. These are aliased.
+// When the application defines a handler (with the same name), this will
+// automatically take precedence over these weak definitions
+//
+//*****************************************************************************
+void ResetISR(void);
+WEAK void NMI_Handler(void);
+WEAK void HardFault_Handler(void);
+WEAK void MemManage_Handler(void);
+WEAK void BusFault_Handler(void);
+WEAK void UsageFault_Handler(void);
+WEAK void SVC_Handler(void);
+WEAK void DebugMon_Handler(void);
+WEAK void PendSV_Handler(void);
+WEAK void SysTick_Handler(void);
+WEAK void IntDefaultHandler(void);
+
+//*****************************************************************************
+//
+// Forward declaration of the specific IRQ handlers. These are aliased
+// to the IntDefaultHandler, which is a 'forever' loop. When the application
+// defines a handler (with the same name), this will automatically take
+// precedence over these weak definitions
+//
+//*****************************************************************************
+void DAC_IRQHandler(void) ALIAS(IntDefaultHandler);
+#if defined (__USE_LPCOPEN)
+void M0APP_IRQHandler(void) ALIAS(IntDefaultHandler);
+#else
+void M0CORE_IRQHandler(void) ALIAS(IntDefaultHandler);
+#endif
+void DMA_IRQHandler(void) ALIAS(IntDefaultHandler);
+void FLASH_EEPROM_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ETH_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SDIO_IRQHandler(void) ALIAS(IntDefaultHandler);
+void LCD_IRQHandler(void) ALIAS(IntDefaultHandler);
+void USB0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void USB1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SCT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void RIT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void TIMER3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void MCPWM_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPI_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SSP0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SSP1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2S0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2S1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPIFI_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SGPIO_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO4_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO5_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO6_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GPIO7_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GINT0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GINT1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void EVRT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CAN1_IRQHandler(void) ALIAS(IntDefaultHandler);
+#if defined (__USE_LPCOPEN)
+void ADCHS_IRQHandler(void) ALIAS(IntDefaultHandler);
+#else
+void VADC_IRQHandler(void) ALIAS(IntDefaultHandler);
+#endif
+void ATIMER_IRQHandler(void) ALIAS(IntDefaultHandler);
+void RTC_IRQHandler(void) ALIAS(IntDefaultHandler);
+void WDT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void M0SUB_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CAN0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void QEI_IRQHandler(void) ALIAS(IntDefaultHandler);
+
+//*****************************************************************************
+//
+// The entry point for the application.
+// __main() is the entry point for Redlib based applications
+// main() is the entry point for Newlib based applications
+//
+//*****************************************************************************
+#if defined (__REDLIB__)
+extern void __main(void);
+#endif
+extern int main(void);
+extern void __libc_init_array(void);
+//*****************************************************************************
+//
+// External declaration for the pointer to the stack top from the Linker Script
+//
+//*****************************************************************************
+extern void _vStackTop(void);
+extern void __valid_user_code_checksum(void);
+
+//*****************************************************************************
+#if defined (__cplusplus)
+} // extern "C"
+#endif
+//*****************************************************************************
+//
+// The vector table.
+// This relies on the linker script to place at correct location in memory.
+//
+//*****************************************************************************
+extern void (* const g_pfnVectors[])(void);
+__attribute__ ((used,section(".isr_vector")))
+void (* const g_pfnVectors[])(void) = {
+    // Core Level - CM4
+    &_vStackTop,                    // The initial stack pointer
+    ResetISR,                       // The reset handler
+    NMI_Handler,                    // The NMI handler
+    HardFault_Handler,              // The hard fault handler
+    MemManage_Handler,              // The MPU fault handler
+    BusFault_Handler,               // The bus fault handler
+    UsageFault_Handler,             // The usage fault handler
+    __valid_user_code_checksum,     // Reserved
+    0,                              // Reserved
+    0,                              // Reserved
+    0,                              // Reserved
+    SVC_Handler,                    // SVCall handler
+    DebugMon_Handler,               // Debug monitor handler
+    0,                              // Reserved
+    PendSV_Handler,                 // The PendSV handler
+    SysTick_Handler,                // The SysTick handler
+
+    // Chip Level - LPC43 (M4)
+    DAC_IRQHandler,           // 16
+#if defined (__USE_LPCOPEN)
+    M0APP_IRQHandler,        // 17 CortexM4/M0 (LPC43XX ONLY)
+#else
+    M0CORE_IRQHandler,        // 17
+#endif
+    DMA_IRQHandler,           // 18
+    0,           // 19
+    FLASH_EEPROM_IRQHandler,   // 20 ORed flash Bank A, flash Bank B, EEPROM interrupts
+    ETH_IRQHandler,           // 21
+    SDIO_IRQHandler,          // 22
+    LCD_IRQHandler,           // 23
+    USB0_IRQHandler,          // 24
+    USB1_IRQHandler,          // 25
+    SCT_IRQHandler,           // 26
+    RIT_IRQHandler,           // 27
+    TIMER0_IRQHandler,        // 28
+    TIMER1_IRQHandler,        // 29
+    TIMER2_IRQHandler,        // 30
+    TIMER3_IRQHandler,        // 31
+    MCPWM_IRQHandler,         // 32
+    ADC0_IRQHandler,          // 33
+    I2C0_IRQHandler,          // 34
+    I2C1_IRQHandler,          // 35
+    SPI_IRQHandler,           // 36
+    ADC1_IRQHandler,          // 37
+    SSP0_IRQHandler,          // 38
+    SSP1_IRQHandler,          // 39
+    UART0_IRQHandler,         // 40
+    UART1_IRQHandler,         // 41
+    UART2_IRQHandler,         // 42
+    UART3_IRQHandler,         // 43
+    I2S0_IRQHandler,          // 44
+    I2S1_IRQHandler,          // 45
+    SPIFI_IRQHandler,         // 46
+    SGPIO_IRQHandler,         // 47
+    GPIO0_IRQHandler,         // 48
+    GPIO1_IRQHandler,         // 49
+    GPIO2_IRQHandler,         // 50
+    GPIO3_IRQHandler,         // 51
+    GPIO4_IRQHandler,         // 52
+    GPIO5_IRQHandler,         // 53
+    GPIO6_IRQHandler,         // 54
+    GPIO7_IRQHandler,         // 55
+    GINT0_IRQHandler,         // 56
+    GINT1_IRQHandler,         // 57
+    EVRT_IRQHandler,          // 58
+    CAN1_IRQHandler,          // 59
+    0,                        // 60
+#if defined (__USE_LPCOPEN)
+    ADCHS_IRQHandler,         // 61 ADCHS combined interrupt
+#else
+    VADC_IRQHandler,          // 61
+#endif
+    ATIMER_IRQHandler,        // 62
+    RTC_IRQHandler,           // 63
+    0,                        // 64
+    WDT_IRQHandler,           // 65
+    M0SUB_IRQHandler,         // 66
+    CAN0_IRQHandler,          // 67
+    QEI_IRQHandler,           // 68
+};
+
+
+//*****************************************************************************
+// Functions to carry out the initialization of RW and BSS data sections. These
+// are written as separate functions rather than being inlined within the
+// ResetISR() function in order to cope with MCUs with multiple banks of
+// memory.
+//*****************************************************************************
+        __attribute__((section(".after_vectors"
+)))
+void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
+    unsigned int *pulDest = (unsigned int*) start;
+    unsigned int *pulSrc = (unsigned int*) romstart;
+    unsigned int loop;
+    for (loop = 0; loop < len; loop = loop + 4)
+        *pulDest++ = *pulSrc++;
+}
+
+__attribute__ ((section(".after_vectors")))
+void bss_init(unsigned int start, unsigned int len) {
+    unsigned int *pulDest = (unsigned int*) start;
+    unsigned int loop;
+    for (loop = 0; loop < len; loop = loop + 4)
+        *pulDest++ = 0;
+}
+
+void _init(void) {}
+
+//*****************************************************************************
+// The following symbols are constructs generated by the linker, indicating
+// the location of various points in the "Global Section Table". This table is
+// created by the linker via the Code Red managed linker script mechanism. It
+// contains the load address, execution address and length of each RW data
+// section and the execution and length of each BSS (zero initialized) section.
+//*****************************************************************************
+extern unsigned int __data_section_table;
+extern unsigned int __data_section_table_end;
+extern unsigned int __bss_section_table;
+extern unsigned int __bss_section_table_end;
+
+//*****************************************************************************
+// Reset entry point for your code.
+// Sets up a simple runtime environment and initializes the C/C++
+// library.
+//
+//*****************************************************************************
+void ResetISR(void) {
+
+// *************************************************************
+// The following conditional block of code manually resets as
+// much of the peripheral set of the LPC43 as possible. This is
+// done because the LPC43 does not provide a means of triggering
+// a full system reset under debugger control, which can cause
+// problems in certain circumstances when debugging.
+//
+// You can prevent this code block being included if you require
+// (for example when creating a final executable which you will
+// not debug) by setting the define 'DONT_RESET_ON_RESTART'.
+//
+#ifndef DONT_RESET_ON_RESTART
+
+    // Disable interrupts
+    __asm volatile ("cpsid i");
+    // equivalent to CMSIS '__disable_irq()' function
+
+    unsigned int *RESET_CONTROL = (unsigned int *) 0x40053100;
+    // LPC_RGU->RESET_CTRL0 @ 0x40053100
+    // LPC_RGU->RESET_CTRL1 @ 0x40053104
+    // Note that we do not use the CMSIS register access mechanism,
+    // as there is no guarantee that the project has been configured
+    // to use CMSIS.
+
+    // Write to LPC_RGU->RESET_CTRL0
+    *(RESET_CONTROL + 0) = 0x10DF1000;
+    // GPIO_RST|AES_RST|ETHERNET_RST|SDIO_RST|DMA_RST|
+    // USB1_RST|USB0_RST|LCD_RST|M0_SUB_RST
+
+    // Write to LPC_RGU->RESET_CTRL1
+    *(RESET_CONTROL + 1) = 0x01DFF7FF;
+    // M0APP_RST|CAN0_RST|CAN1_RST|I2S_RST|SSP1_RST|SSP0_RST|
+    // I2C1_RST|I2C0_RST|UART3_RST|UART1_RST|UART1_RST|UART0_RST|
+    // DAC_RST|ADC1_RST|ADC0_RST|QEI_RST|MOTOCONPWM_RST|SCT_RST|
+    // RITIMER_RST|TIMER3_RST|TIMER2_RST|TIMER1_RST|TIMER0_RST
+
+    // Clear all pending interrupts in the NVIC
+    volatile unsigned int *NVIC_ICPR = (unsigned int *) 0xE000E280;
+    unsigned int irqpendloop;
+    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
+        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
+    }
+
+    // Reenable interrupts
+    __asm volatile ("cpsie i");
+    // equivalent to CMSIS '__enable_irq()' function
+
+#endif  // ifndef DONT_RESET_ON_RESTART
+// *************************************************************
+
+#if defined (__USE_LPCOPEN)
+    SystemInit();
+#endif
+
+    //
+    // Copy the data sections from flash to SRAM.
+    //
+    unsigned int LoadAddr, ExeAddr, SectionLen;
+    unsigned int *SectionTableAddr;
+
+    // Load base address of Global Section Table
+    SectionTableAddr = &__data_section_table;
+
+    // Copy the data sections from flash to SRAM.
+    while (SectionTableAddr < &__data_section_table_end) {
+        LoadAddr = *SectionTableAddr++;
+        ExeAddr = *SectionTableAddr++;
+        SectionLen = *SectionTableAddr++;
+        data_init(LoadAddr, ExeAddr, SectionLen);
+    }
+    // At this point, SectionTableAddr = &__bss_section_table;
+    // Zero fill the bss segment
+    while (SectionTableAddr < &__bss_section_table_end) {
+        ExeAddr = *SectionTableAddr++;
+        SectionLen = *SectionTableAddr++;
+        bss_init(ExeAddr, SectionLen);
+    }
+
+#if !defined (__USE_LPCOPEN)
+// LPCOpen init code deals with FP and VTOR initialisation
+#if defined (__VFP_FP__) && !defined (__SOFTFP__)
+    /*
+     * Code to enable the Cortex-M4 FPU only included
+     * if appropriate build options have been selected.
+     * Code taken from Section 7.1, Cortex-M4 TRM (DDI0439C)
+     */
+    // CPACR is located at address 0xE000ED88
+    asm("LDR.W R0, =0xE000ED88");
+    // Read CPACR
+    asm("LDR R1, [R0]");
+    // Set bits 20-23 to enable CP10 and CP11 coprocessors
+    asm(" ORR R1, R1, #(0xF << 20)");
+    // Write back the modified value to the CPACR
+    asm("STR R1, [R0]");
+#endif // (__VFP_FP__) && !(__SOFTFP__)
+    // ******************************
+    // Check to see if we are running the code from a non-zero
+    // address (eg RAM, external flash), in which case we need
+    // to modify the VTOR register to tell the CPU that the
+    // vector table is located at a non-0x0 address.
+
+    // Note that we do not use the CMSIS register access mechanism,
+    // as there is no guarantee that the project has been configured
+    // to use CMSIS.
+    unsigned int * pSCB_VTOR = (unsigned int *) 0xE000ED08;
+    if ((unsigned int *) g_pfnVectors != (unsigned int *) 0x00000000) {
+        // CMSIS : SCB->VTOR = <address of vector table>
+        *pSCB_VTOR = (unsigned int) g_pfnVectors;
+    }
+#endif
+
+#if defined (__USE_CMSIS)
+    SystemInit();
+#endif
+
+    __libc_init_array();
+
+#if defined (__REDLIB__)
+    // Call the Redlib library, which in turn calls main()
+    __main();
+#else
+    Board_Init(); // From Board module (modules/lpc4337_m4/board)
+    main();
+#endif
+
+    //
+    // main() shouldn't return, but if it does, we'll just enter an infinite loop
+    //
+    while (1) {
+        ;
+    }
+}
+
+//*****************************************************************************
+// Default exception handlers. Override the ones here by defining your own
+// handler routines in your application code.
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void NMI_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void HardFault_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void MemManage_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void BusFault_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void UsageFault_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void SVC_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void DebugMon_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void PendSV_Handler(void) {
+    while (1) {
+    }
+}
+__attribute__ ((section(".after_vectors")))
+void SysTick_Handler(void) {
+    while (1) {
+    }
+}
+
+//*****************************************************************************
+//
+// Processor ends up here if an unexpected interrupt occurs or a specific
+// handler is not present in the application code.
+//
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void IntDefaultHandler(void) {
+    while (1) {
+    }
+}
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/module.mk ./libs/vendor_libs/module.mk
--- a_bRU7kv/libs/vendor_libs/module.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/module.mk	2018-12-01 17:21:51.083203046 -0300
@@ -0,0 +1,30 @@
+ifeq ($(USE_LPCOPEN),y)
+
+DEFINES+=__USE_LPCOPEN
+
+SRC+=$(wildcard libs/vendor_libs/lpc_board_ciaa_edu_4337/src/*.c) 
+INCLUDES+=-Ilibs/vendor_libs/lpc_board_ciaa_edu_4337/inc
+
+SRC+=$(wildcard libs/vendor_libs/lpc_chip_43xx/src/*.c) 
+INCLUDES+=-Ilibs/vendor_libs/lpc_chip_43xx/inc
+INCLUDES+=-Ilibs/vendor_libs/lpc_chip_43xx/inc/usbd_rom
+INCLUDES+=-Ilibs/vendor_libs/lpc_chip_43xx/inc/config_43xx
+
+endif
+
+DEFINES+=CORE_M4 __USE_NEWLIB
+ARCH_FLAGS=-mcpu=cortex-m4 -mthumb
+
+ifeq ($(USE_FPU),y)
+ARCH_FLAGS+=-mfloat-abi=hard -mfpu=fpv4-sp-d16
+endif
+
+ifeq ($(USE_RAM),y)
+LDSCRIPT=flat.ld
+else
+LDSCRIPT=link.ld
+endif
+
+SRC+=$(wildcard libs/vendor_libs/lpc_startup/src/*.c) 
+INCLUDES+=-Ilibs/vendor_libs/lpc_startup/inc
+
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/libs/vendor_libs/version.txt ./libs/vendor_libs/version.txt
--- a_bRU7kv/libs/vendor_libs/version.txt	1969-12-31 21:00:00.000000000 -0300
+++ ./libs/vendor_libs/version.txt	2018-12-01 17:15:06.673606844 -0300
@@ -0,0 +1 @@
+LPCOpen v3.01
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/LICENSE ./LICENSE
--- a_bRU7kv/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ ./LICENSE	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,29 @@
+BSD 3-Clause License
+
+Copyright (c) 2018, Eric Pernia - Martin Ribelotta
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/Makefile ./Makefile
--- a_bRU7kv/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ ./Makefile	2018-12-01 18:01:54.636650233 -0300
@@ -0,0 +1,167 @@
+# ---------- Project path ----------------------------------------------
+# Project path 
+# (relative to this folder, leave void if the project is in this folder)
+PROJECT_PATH =
+
+# ---------- Project name ----------------------------------------------
+PROJECT_NAME = app
+# ----------------------------------------------------------------------
+
+ifeq ($(PROJECT_PATH),)
+PROJECT_PATH_AND_NAME=$(PROJECT_NAME)
+else
+PROJECT_PATH_AND_NAME=$(PROJECT_PATH)/$(PROJECT_NAME)
+endif
+
+include $(PROJECT_PATH_AND_NAME)/config.mk
+
+MODULES=$(sort $(dir $(wildcard libs/*/)))
+SRC=$(wildcard $(PROJECT_PATH_AND_NAME)/src/*.c)
+SRC+=$(foreach m, $(MODULES), $(wildcard $(m)/src/*.c))
+
+CXXSRC=$(wildcard $(PROJECT_PATH_AND_NAME)/src/*.cpp)
+CXXSRC+=$(foreach m, $(MODULES), $(wildcard $(m)/src/*.cpp))
+
+ASRC=$(wildcard $(PROJECT_PATH_AND_NAME)/src/*.s)
+ASRC+=$(foreach m, $(MODULES), $(wildcard $(m)/src/*.s))
+
+OUT=$(PROJECT_PATH_AND_NAME)/out
+OBJECTS=$(CXXSRC:%.cpp=$(OUT)/%.o) $(ASRC:%.s=$(OUT)/%.o) $(SRC:%.c=$(OUT)/%.o)
+DEPS=$(OBJECTS:%.o=%.d)
+
+OOCD_SCRIPT=scripts/openocd.cfg
+
+TARGET=$(OUT)/$(PROJECT_NAME).elf
+TARGET_BIN=$(basename $(TARGET)).bin
+TARGET_LST=$(basename $(TARGET)).lst
+TARGET_MAP=$(basename $(TARGET)).map
+TARGET_NM=$(basename $(TARGET)).names.csv
+
+INCLUDE_FLAGS=$(foreach m, $(MODULES), -I$(m)/inc) -I$(PROJECT_PATH_AND_NAME)/inc $(INCLUDES)
+DEFINES_FLAGS=$(foreach m, $(DEFINES), -D$(m))
+OPT_FLAGS=-ggdb3 -O$(OPT) -ffunction-sections -fdata-sections
+
+COMMON_FLAGS=$(ARCH_FLAGS) $(DEFINES_FLAGS) $(INCLUDE_FLAGS) $(OPT_FLAGS)
+
+CFLAGS=$(COMMON_FLAGS) -std=c99
+CXXFLAGS=$(COMMON_FLAGS) -fno-rtti -fno-exceptions -std=c++11
+
+LDFLAGS=$(ARCH_FLAGS)
+LDFLAGS+=$(foreach m, $(MODULES), -L$(m)/lib)
+LDFLAGS+=-T$(LDSCRIPT)
+LDFLAGS+=-nostartfiles -Wl,-gc-sections -Wl,-Map=$(TARGET_MAP) -Wl,--cref
+
+ifeq ($(USE_NANO),y)
+LDFLAGS+=--specs=nano.specs
+endif
+
+ifeq ($(SEMIHOST),y)
+LDFLAGS+=--specs=rdimon.specs
+endif
+
+CROSS=arm-none-eabi-
+CC=$(CROSS)gcc
+CXX=$(CROSS)g++
+ifeq ($(CXXSRC),)
+LD=$(CROSS)gcc
+else
+LD=$(CROSS)g++
+endif
+SIZE=$(CROSS)size
+LIST=$(CROSS)objdump -xdS
+OBJCOPY=$(CROSS)objcopy
+NM=$(CROSS)nm
+GDB=$(CROSS)gdb
+OOCD=openocd
+
+ifeq ($(VERBOSE),y)
+Q=
+else
+Q=@
+endif
+
+compilar_proyecto: $(TARGET) $(TARGET_BIN) $(TARGET_LST) $(TARGET_NM) ocupacion
+
+-include $(foreach m, $(MODULES), $(wildcard $(m)/module.mk))
+
+-include $(DEPS)
+
+$(OUT)/%.o: %.c
+	@echo CC $(notdir $<)
+	@mkdir -p $(dir $@)
+	$(Q)$(CC) -MMD $(CFLAGS) -c -o $@ $<
+
+$(OUT)/%.o: %.cpp
+	@echo CXX $(notdir $<)
+	@mkdir -p $(dir $@)
+	$(Q)$(CXX) -MMD $(CXXFLAGS) -c -o $@ $<
+
+$(OUT)/%.o: %.s
+	@echo AS $(notdir $<)
+	@mkdir -p $(dir $@)
+	$(Q)$(CC) -MMD $(CFLAGS) -c -o $@ $<
+
+$(TARGET): $(OBJECTS)
+	@echo LD $@...
+	$(Q)$(LD) $(LDFLAGS) -o $@ $(OBJECTS)
+
+$(TARGET_BIN): $(TARGET)
+	$(Q)$(OBJCOPY) -v -O binary $< $@
+
+$(TARGET_LST): $(TARGET)
+	@echo LIST
+	$(Q)$(LIST) $< > $@
+
+# If you have sed
+#$(TARGET_NM): $(TARGET)
+#	@echo NAME
+#	$(Q)$(NM) -nAsSCp $< \
+#		| sed -r 's/(.+?\:[^ ]+) ([a-zA-Z\?] [a-zA-Z_].*)/\1 00000000 \2/' \
+#		| sed -r 's/(.+?)\:([a-fA-F0-9]+) ([a-fA-F0-9]+) ([a-zA-Z\?]) (.*)/\1\t0x\2\t0x\3\t\4\t\5/' \
+#		> $@
+
+# If you doesn't have sed
+$(TARGET_NM): $(TARGET)
+	@echo NAME
+	$(Q)$(NM) -nAsSCp $< > $@
+
+ocupacion: $(TARGET)
+	$(Q)$(SIZE) $<
+
+.descargar_en_ram: $(TARGET_BIN)
+	@echo DOWNLOAD
+	$(Q)$(OOCD) -f $(OOCD_SCRIPT) \
+		-c "init" \
+		-c "halt 0" \
+		-c "load_image $< 0x20000000 bin" \
+		-c "reset run" \
+		-c "shutdown" 2>&1
+
+.descargar_a_flash: $(TARGET_BIN)
+	@echo DOWNLOAD
+	$(Q)$(OOCD) -f $(OOCD_SCRIPT) \
+		-c "init" \
+		-c "halt 0" \
+		-c "flash write_image erase unlock $< 0x1A000000 bin" \
+		-c "reset run" \
+		-c "shutdown" 2>&1
+
+ifeq ($(USE_RAM),y)
+descargar_a_placa: .descargar_en_ram
+else
+descargar_a_placa: .descargar_a_flash
+endif
+		
+borrar_flash:
+	@echo ERASE
+	$(Q)$(OOCD) -f $(OOCD_SCRIPT) \
+		-c "init" \
+		-c "halt 0" \
+		-c "flash erase_sector 0 0 last" \
+		-c "shutdown" 2>&1
+
+limpiar_proyecto:
+	@echo CLEAN
+	$(Q)rm -fR $(OBJECTS) $(TARGET) $(TARGET_BIN) $(TARGET_LST) $(DEPS) $(OUT)
+
+.PHONY: compilar_proyecto ocupacion descargar_a_placa borrar_flash limpiar_proyecto
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/README.md ./README.md
--- a_bRU7kv/README.md	1969-12-31 21:00:00.000000000 -0300
+++ ./README.md	2018-12-01 17:15:06.585605740 -0300
@@ -0,0 +1,149 @@
+# CIAA CAPSE project template for EDU-CIAA-NXP
+
+
+
+Available libraries:
+   - LPCOpen v3.01
+   - sAPI r0.5.0.
+   - FreeRTOS Kernel V10.0.1
+   - Elm-Chan FatFS (SSP & USB).
+
+## IMPORTANT
+
+**This environment is under construction!!**
+
+**Always use the [released versions](../../releases) because in these all examples are tested and the API documentation is consistent. The master branch may contain inconsistencies because this environment is currently under development.**
+
+## Supported boards
+- CIAA-NXP (LPC4337).
+- EDU-CIAA-NXP (LPC4337).
+
+## Supported toolchains
+- gcc-arm-none-eabi
+
+## Usage
+* Make sure you have an ```arm-none-eabi-*``` toolchain configured in your ```PATH```. If you don't have it, download [GCC ARM Embedded](https://developer.arm.com/open-source/gnu-toolchain/gnu-rm).
+* Define ```PROJECT_NAME```  and ```PROJECT_PATH``` variables in ```project.mk``` according to the project you want to compile (PROJECT_PATH is relative to this folder, leave void if the project is in this folder).
+* Compile with ```make```.
+* Clean with ```make clean```. Clean for all targets with ```make clean_all```.
+* Download to target via OpenOCD with ```make download```.
+
+## Create a new project
+
+Each project consist in a folder (with a non-spaces name) that includes inside 2 folders, one named ```src``` (here go, .c, .cpp or .s source code files), and another one named ```inc``` (here go, .h or .hpp source header files) and one file named ```config.mk```, where you may configure which libraries you include and compiler options.
+
+## Add a new library
+
+The ```libs``` folder allow you to include 2 types of libraries:
+
+ - Simplie library. Consist in a folder (with a non-spaces name) that includes inside 2 folders, one named ```src``` (here go .c, .cpp or .s source code files), and another one named ```inc``` (here go .h or .hpp header files). This kind of library compiles automaticaly by the Makefile.
+ - Advanced library. Consist in a library whit a complex folder and files strcuture, i.e. LibUSB. This case reuire make your own makefile. You can inspire from sAPI makefile to do that.
+
+
+## Examples
+
+Included examples are:
+
+**Bare-metal with sAPI library examples**
+
+ - GPIO:
+    - gpio_01_switches_leds: each switch drives the upper led.
+    - gpio_02_blinky: the simply led blinky with a blocking delay.
+    - gpio_03_blinky_switch: led blinky with a with a non-blocking delay, to allow you to respond to a switch at the same time.
+    - gpio_04_led_sequences: led sequences by using a non-blocking delay.
+    - keypad_7segment_01: Drives a keypad and 7 segment display.
+    - lcd_01: Drives an LCD display.
+ - UART:
+    - uart_01_echo: UART echo, it respond the same that you send from PC.
+    - uart_02_receive_string_blocking: Waits until receive a certain pattern String in a UART or timeout expire (blocking code).
+    - uart_03_receive_string:  Waits until receive a certain pattern String in a UART or timeout expire (non-blocking code).
+ - Printf
+    - stdio_01_printf_sprintf: printf() and other similar standard C libray functions.
+ - ADC, DAC:
+    - adc_dac_01: ADC and DAC example.
+ - TIMER, RTC:
+    - cycles_counter_01: clock cycles counter functions, only work in debug mode. Allows execution time trazability.
+    - tick_01_tickHook: Periodic tick function (interrupt-based) with periodic callback.
+    - rtc_01: RTC peripheral to have date and time clock.
+    - pwm_01: PWM applied to LEDs.
+    - pwm_02_rgb_controller_uart: RGB LED example.
+    - servo_01: Servomotor PWM control example.
+ - External peripherals:
+    - I2C Magnetometers. In Chinese GY-273 module you can have one of this magnetometers, that have the same pinout but different register map. To difference them see the chip, ignore the board serigraphy:
+       - i2c_01_hmc5883l: HMC5883L magnetometer. 
+       - i2c_02_qmc5883l: QMC5883L magnetometer.
+    - dht11_01: Humidity an Temperature sensor.
+    - ultrasonicSensor_HCSR04_01: HC-SR04 utrasonic distance sensor.
+    - spi_01_sdCard_fatFileSystem: ADC logging in a SD/MicroSD Card (SPI connected) by using a FAT File System (ChanFS).
+    - WiFi ESP01 (ESP8266) module:
+       - 01_uart_bridge: Use this to send AT commands directly to ESP01 module.
+       - 02_http_server: Embedded web Server to see sensor values.
+       - 03_thingspeak: Send data to thingspeak dashboards.
+
+**Embedded Operating Systems with sAPI library examples**
+
+ - Cooperative O.S. (see M.J. Pont's book at https://www.safetty.net/publications/pttes )
+    - scheduler_01_seos: Cooperative O.S. introduction.
+    - scheduler_02_seos_background_foreground: Cooperative O.S., foreground-background.
+    - seos_Pont2014_01: SEOS Cooperative O.S. from M.J. Pont (2014).
+    - seos_pont_02_microwave: SEOS Cooperative O.S. from M.J. Pont (2014), microwave example.
+ - FreeOSEK
+    - freeOSEK_01_blinky: Blinky led with freeOSEK RTOS.
+ - FreeRTOS
+    - freeRTOS_01_blinky: Blinky led with freeRTOS RTOS and sAPI.
+    - freeRTOS_02_Queue: Queue management with freeRTOS and sAPI.
+    - freeRTOS_03_ChanFatFS_SPI_SdCard_ADC_log: ADC logging in a SD/MicroSD Card (SPI connected) by using a FAT File System (ChanFS), freeRTOS and sAPI.
+    - freeRTOS_book: Richard Barry's book examples with FreeRTOS and sAPI:
+       - EXAMPLE001: Creating tasks
+       - EXAMPLE002: Using the task parameter
+       - EXAMPLE003: Experimenting with priorities
+       - EXAMPLE004: Using the Blocked state to create delay
+       - EXAMPLE005: Converting the example tasks to use vTaskDelayUntil()
+       - EXAMPLE006: Combining blocking and non-blocking tasks
+       - EXAMPLE007: Defining an idle task hook function
+       - EXAMPLE008: Changing task priorities
+       - EXAMPLE009: Deleting tasks
+       - EXAMPLE010: Blocking when receiving from a queue
+       - EXAMPLE011: Blocking when sending to a queue or sending structures on a queue
+       - EXAMPLE012: Using a queue set
+       - EXAMPLE013: Creating one-shot and auto-reload timers
+       - EXAMPLE014: Using the callback function parameter and the software timer ID
+       - EXAMPLE015: Resetting a software timer
+       - EXAMPLE016: Using a binary semaphore to synchronize a task with an interrupt
+       - EXAMPLE017: Using a counting semaphore to synchronize a task with an interrupt
+       - EXAMPLE018: Centralized deferred interrupt processing
+       - EXAMPLE019: Sending and receiving on a queue from within an interrupt
+       - EXAMPLE020: Re-writing vPrintString() to use a semaphore
+       - EXAMPLE021: Re-writing vPrintString() to use a gatekeeper task
+       - EXAMPLE022: Experimenting with event groups
+       - EXAMPLE023: Synchronizing tasks
+       - EXAMPLE024: Using a task notification in place of a semaphore, method 1
+       - EXAMPLE025: Using a task notification in place of a semaphore, method 2
+
+**Statecharts with sAPI library examples**
+       
+**LPC Open examples**
+
+ - LPC4337 LPC Open:
+     - adc_fir_dac 
+     - asm
+     - blinky
+     - blinky_ram 	
+     - blinky_rit
+     - blinky_input
+     - boot: LPCBootloader example
+     - mpu
+     - start_m0 	
+     - trilat
+     - i2c
+     - pwm
+     - sd_spi
+     - usb_cdc
+     - usb_msc_host
+     - usb_rom_cdc
+     - statechart
+     - tcpecho
+ - LPC4337 LPC Open and RTOS:
+     - freertos_blinky
+     - blinky_osek
+     - multicore 	
diff -u -r --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_bRU7kv/scripts/openocd.cfg ./scripts/openocd.cfg
--- a_bRU7kv/scripts/openocd.cfg	1969-12-31 21:00:00.000000000 -0300
+++ ./scripts/openocd.cfg	2018-12-01 17:27:21.288968990 -0300
@@ -0,0 +1,44 @@
+interface ftdi
+ftdi_device_desc "Dual RS232-HS"
+ftdi_vid_pid 0x0403 0x6010
+ftdi_channel 0
+
+ftdi_layout_init 0x0708 0xFFFB
+ftdi_layout_signal nTRST -data 0x0100
+ftdi_layout_signal nSRST -data 0x0200
+
+transport select jtag
+adapter_khz 2000
+
+set _CHIPNAME lpc4337
+
+set _M4_JTAG_TAPID 0x4ba00477
+set _M0_JTAG_TAPID 0x0ba01477
+
+jtag newtap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M4_JTAG_TAPID
+jtag newtap $_CHIPNAME m0 -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M0_JTAG_TAPID
+
+# https://elinux.org/OpenOCD_User_Guide
+# 21.3 OpenOCD specific Global Variables
+echo ""
+echo "Openocd is runninng on $ocd_HOSTOS" 
+echo ""
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+target create $_CHIPNAME.m0 cortex_m -chain-position $_CHIPNAME.m0
+
+set _WORKAREASIZE 0x8000
+$_CHIPNAME.m4 configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME lpc2000 0x1a000000 0x80000 0 0 $_CHIPNAME.m4 lpc4300 96000 calc_checksum
+
+reset_config none
+
+cortex_m reset_config vectreset
+
+targets $_CHIPNAME.m4
+
+$_CHIPNAME.m4 configure -event gdb-attach {
+   echo "Reset Halt, due to gdb attached...!"
+   reset halt
+}
